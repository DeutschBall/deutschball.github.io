<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="机器级算术运算的原理 落脚在加法,全加器,半加器,全加器级联,等最基础的知识 机器在算术的时候有很多行为和人不一样,但是权位的思想是相同的 人在算术的时候通过列竖式对其的方式,隐含着权位规则. 机器将权位规则体现在,随着运算会有中间结果的位移 理解了机器将中间结果移位的原因,也就理解了机器级算术运算的原理 计组第三章讲的机器机计算方法实际上和程序员距离比较远,ALU中已经封装好了各种计">
<meta property="og:type" content="article">
<meta property="og:title" content="机器级算术运算的原理">
<meta property="og:url" content="http://deutschball.github.io/2022/06/17/%E6%9C%BA%E5%99%A8%E7%BA%A7%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%9A%84%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="机器级算术运算的原理 落脚在加法,全加器,半加器,全加器级联,等最基础的知识 机器在算术的时候有很多行为和人不一样,但是权位的思想是相同的 人在算术的时候通过列竖式对其的方式,隐含着权位规则. 机器将权位规则体现在,随着运算会有中间结果的位移 理解了机器将中间结果移位的原因,也就理解了机器级算术运算的原理 计组第三章讲的机器机计算方法实际上和程序员距离比较远,ALU中已经封装好了各种计">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-06-17T04:20:00.000Z">
<meta property="article:modified_time" content="2022-06-17T04:24:34.872Z">
<meta property="article:author" content="dustball">
<meta property="article:tag" content="CS">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://deutschball.github.io/2022/06/17/%E6%9C%BA%E5%99%A8%E7%BA%A7%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%9A%84%E5%8E%9F%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>机器级算术运算的原理 | dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/17/%E6%9C%BA%E5%99%A8%E7%BA%A7%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%9A%84%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          机器级算术运算的原理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-17 12:20:00 / Modified: 12:24:34" itemprop="dateCreated datePublished" datetime="2022-06-17T12:20:00+08:00">2022-06-17</time>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="机器级算术运算的原理">机器级算术运算的原理</h1>
<p>落脚在加法,全加器,半加器,全加器级联,等最基础的知识</p>
<p>机器在算术的时候有很多行为和人不一样,但是权位的思想是相同的</p>
<p>人在算术的时候通过列竖式对其的方式,隐含着权位规则.</p>
<p><strong>机器将权位规则体现在,随着运算会有中间结果的位移</strong></p>
<p>理解了机器将中间结果移位的原因,也就理解了机器级算术运算的原理</p>
<p>计组第三章讲的机器机计算方法实际上和程序员距离比较远,ALU中已经封装好了各种计算方法,那为什么还要我们学这一部分呢?</p>
<p>我的感觉让我们是理解计算机底层实现中的状态机思想,</p>
<p>在推导适应机器的算法时,越发感觉出,有固定的状态的转移套路</p>
<p>而这种思想将对我们在开发状态机服务端的时候提供世界观上的支持</p>
<p>然而课本对于该部分的介绍基本止步于如何计算,并没有下到算法如何设计得到的,可以说是一大遗憾.</p>
<p>现在将我的设计和课本给出的设计思想其补上</p>
<h2 id="手算原码乘法">手算原码乘法</h2>
<p>这是万恶之源,通过一个例题观察人类对权位规则的应用</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617122401353.png"
alt="image-20220617122401353" />
<figcaption aria-hidden="true">image-20220617122401353</figcaption>
</figure>
<p>之前一直不知道怎么描述这个过程,只能是手写比划比划,直到看了CSAPP第二章位向量表示法,终于知道怎么描述这个过程了</p>
<p>只看小数点后面的部分,把<span
class="math inline">\(X,Y\)</span>表示成位向量,有 <span
class="math display">\[
X=[X_3X_2X_1X_0]=\sum_{i=0}^3[2^i\times X_i](X_i=0\ or\ 1)
\]</span></p>
<p><span class="math display">\[
Y=[Y_3Y_2Y_1Y_0]=\sum_{i=0}^3[2^i\times Y_i](Y_i=0\ or\ 1)
\]</span></p>
<p>那么手算的思想可以用下式表示: <span class="math display">\[
\begin{aligned}
ANS&amp;=X\times Y\\
&amp;=X\times\sum_{i=0}^3[2^i\times Y_i]\\
&amp;=\sum_{i=0}^3[ 2^i\times X\times Y_i]\\
&amp;=[X\times Y_0]+2[X\times Y_1]+4[X\times Y_2]+8[X\times Y_3]\\
&amp;=A_0+A_1+A_2+A_3\\
&amp;=E\\
&amp;=[E_3E_2E_1E_0]
\end{aligned}
\]</span> 其中 <span class="math display">\[
A_i=2^i\times [X\times Y_i],i\in[0,3]
\]</span></p>
<p><span class="math display">\[
E_j=\sum_{i=0}^3A_{ij}+低位进位\\
j\in[0,7]\
\]</span> <img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616210922544.png"
alt="image-20220616210922544" /></p>
<p>这里<span
class="math inline">\(E_i\)</span>的计算方法就是小学里算竖式的时候,老师常说的"落下来"</p>
<p>从图上我们可以更清晰地看出,被乘数分别和乘数的"个十百千位"相乘,按位对其之后落下来累加得到E</p>
<h2 id="原码一位乘法">原码一位乘法</h2>
<p>如果让机器原封不动重复刚才手算的过程</p>
<h3 id="替机器瞎操心">替机器瞎操心</h3>
<p>他需要维护一个二维数组,记录用X和Y的每一位相乘,分别得到的中间位向量<span
class="math inline">\(A_i\)</span></p>
<p>然后"落下来"求<span class="math inline">\(E\)</span></p>
<p>就这个二维数组就把机器难为住了</p>
<p>1.如果两个32位整数相乘,就需要32*32个方格的二维数组,ALU可是没有记忆功能的,寄存器也就稀松几个,记忆能力有限,显然32²个方格没处放.</p>
<p>2.机器怎么知道当前应该用X对齐Y的"个位"还是"十位"还是"百位"呢?用一个寄存器,记录Y已经被对齐过几位吗?</p>
<p>不需要,因为本次对齐的位一定是只比上一次对齐位高一位,只需要将被乘数左移一下.</p>
<p>然后根据本次Y的对齐位是1则<span class="math inline">\(Ai=X\times
权重\)</span>,比如图表中<span class="math inline">\(A_3\)</span></p>
<p>如果本次Y的对齐位为0则<span
class="math inline">\(A_i=0\)</span>,比如图表中<span
class="math inline">\(A_2\)</span></p>
<p>问题又来了,权重用谁来记住呢?再开一个寄存器,初始记录1,表示权重为<span
class="math inline">\(2^0\)</span>,随着被乘数<span
class="math inline">\(X\)</span>的左移,这个寄存器也要左移一下表示权重乘以2</p>
<p>如果继续研究如何让硬件实现,还能发现更多问题.<del>第一,机器算账,这钱怎么进了你自己的腰包</del></p>
<h3 id="滚动数组">滚动数组</h3>
<p>现在考虑一下,有必要维护这个二维数组吗?滚动数组行吗?</p>
<p>中间过程不使用二维数组,就维护一个位向量<span
class="math inline">\(A\)</span>,计算过程中A只有累加和右移两种行为.</p>
<p>乘数个位为1,则被乘数直接加到A的<strong>高四位</strong></p>
<blockquote>
<p>为啥是高四位呢?似乎有点违反直觉,因为A的高位表示的是高权重,但是现在用被乘数乘的是乘数的个位,权位最低才对啊.别忘了A要右移</p>
</blockquote>
<p>然后A右移一位,乘数右移一位</p>
<blockquote>
<p>这个过程干了一个啥事呢?</p>
<p>被乘数一直和乘数的"最低位"对齐,刚才最低位是"个位",现在经过右移,个位直接扬了,十位成了"最低位".被乘数时钟看乘数最低位脸色行事,当这个最低位是1的时候才把自己加到A上,加到A的最高四位上</p>
<p>A右移一位,则所有历史记录都降权2,</p>
<p>可想而知,当乘数的千位右移到最低位,这时候被乘数将自己加到了A的高四位上,此时计算结束.乘数的千位和被乘数的积
的权就最高,根本不需要降权</p>
<p>而乘数的个位和被乘数的积此时已经经历了4次降权,权重仅为<span
class="math inline">\(\frac{1}{2^4}=\frac{1}{16}\)</span></p>
<p>这正好满足我们的目的</p>
</blockquote>
<p>现在可以用机器实现了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616213145320.png"
alt="image-20220616213145320" />
<figcaption aria-hidden="true">image-20220616213145320</figcaption>
</figure>
<h4 id="硬件框图的意义">硬件框图的意义</h4>
<p>这个图怎么看呢?</p>
<p>D和A合起来作为"中间过程位向量",D就是高四位,A就是低四位</p>
<p>一开始的时候D=0,A=Y,这好像和我们刚才的分析不一样,我们分析的滚动数组思想中,Y是独立存在的,不会放在A中.</p>
<p>而实际上Y需要独立存在吗?考虑每次被乘数要么不加,要么加到高四位上,而Y一开始放在低四位,两者不会相互影响.</p>
<p>随着这个中间过程位向量不断右移,Y被一位一位移除了A,当Y恰好移出的时候计算恰好结束.</p>
<p><span
class="math inline">\(A_0\)</span>就是乘数的"最低位",随着乘数Y的不断右移,硬件A的最低位会以此存放Y的个十百千位,相当于将Y遍历了一遍</p>
<p>"被乘数看乘数最低位颜色决定加不加"这个事怎么实现的呢?</p>
<p>用一个B寄存器存放被加数X,X和0作为二选一选择器的数据段,<span
class="math inline">\(A_0\)</span>作为该二选一的地址端,当<span
class="math inline">\(A_0=1\)</span>则选通X,当<span
class="math inline">\(A_0=0\)</span>则选通0</p>
<p>选通的信号就进入了<span
class="math inline">\(\Sigma\)</span>多位加法器</p>
<p>左上角这个循环干了啥事呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616213859376.png"
alt="image-20220616213859376" />
<figcaption aria-hidden="true">image-20220616213859376</figcaption>
</figure>
<p>被加数总是加到中间过程位向量的高四位,这怎么实现?将旧的高四位作为加数和X相加就得到了新的高四位</p>
<p>这个半调子CF是干啥的呢?</p>
<p>CF是PSW程序状态字中的一位,用来记录是否有进位,啥时候会有进位呢?</p>
<p>比如头一次D=1111,右移变成0111,然后下一次又加了1111,显然0111+1111溢出了,但是顶多溢出一位,于是放到CF里,然后D右移的时候,再从CF里拿出来放到D里</p>
<h3 id="手写模拟">手写模拟</h3>
<p>模拟机器计算<span class="math inline">\(0.1101\times
1.1011\)</span>(都是原码)</p>
<p>符号显然同号得负数,这对机器来说也是小菜一碟,两符号娶个异或即可</p>
<p>去掉小数点,后面的直接作为整数乘法,怎么乘的呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616215950459.png"
alt="image-20220616215950459" />
<figcaption aria-hidden="true">image-20220616215950459</figcaption>
</figure>
<p>最左侧这里列也是有实际意义的,里面是CF位的状态.</p>
<p>这一点课本并没有给出,这导致我一开始认为只有手算模拟才会用到这一列</p>
<p>乘数有四位,因此共有四次操作,恰好将Y从A中扬了,中间结果积逐渐充斥整个D和A</p>
<blockquote>
<p>这个过程要是找个现实中的类比的话,可以举这么一个不恰当的例子:</p>
<p>一个公司有10个部长,资本家的总是嫌这十个人好吃懒惰不干活,或者说即使比较勤奋,但是不想再给他发太多工资,直接降薪吧人家也不愿意.反正就是想找个理由踢了这是个人换成新人</p>
<p>但是资本家还不敢一口气全体了,这会造成一段时间没人管事儿.</p>
<p>于是资本家想了一个温水煮癞蛤蟆的方法,每隔一个月从这10个人里找一个业绩最差的,</p>
<p>要是他真的好吃懒惰啥也不干,直接踢了,公司正常运转.</p>
<p>要是他确实负责一些事情,那么找一个能干的新人把他挤了,公司正常运转</p>
<p>10个月后,10个部长就全是优秀并且高效的00后了</p>
</blockquote>
<h4 id="无符号右移">无符号右移?</h4>
<p>关于"无符号右移",这个事情发生在</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616220805565.png"
alt="image-20220616220805565" />
<figcaption aria-hidden="true">image-20220616220805565</figcaption>
</figure>
<table>
<thead>
<tr>
<th>原数</th>
<th>带符号右移结果</th>
<th>无符号右移结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\(1&#39;0011&#39;1101\)</span></td>
<td><span class="math inline">\(1&#39;1001&#39;1110\)</span></td>
<td><span class="math inline">\(0&#39;1001&#39;1110\)</span></td>
</tr>
</tbody>
</table>
<p>显然正确的计算方法是无符号右移,为啥不是带符号的呢?</p>
<p>首先,带符号意味着负数,而我们整个计算过程中要么加0,要么加x,反正不会加一个负数,理论上就不存在加负数的情况</p>
<p>再者,这里最左侧的"符号"实际上是CF位,是上一次加被乘数之后的进位,不是"符号",我们一直在进行无符号运算</p>
<h2 id="原码两位乘法">原码两位乘法</h2>
<h3 id="为啥要两位乘">为啥要两位乘?</h3>
<p>原码两位乘法和原码一位乘法的思想基本相同,但是设计硬件的那伙子人嫌一位乘法太慢,这就好比一个人上楼梯,每次上一个台阶嫌慢,非得上两个</p>
<p>为啥没有原码三位乘法?<del>一次上三个台阶这不扯蛋吗</del></p>
<p>因为计算机中的数据都占用偶数位,从来没有说有一个66位计算机,有一个63位计算机,有一个30位计算机.</p>
<p>实际存在的计算机都是64位,32位,这些位数都是2的幂次,为啥非要是2的幂次?方便使用二进制呗.为啥一定使用二进制?逻辑门高电位和低电位就两种状态呗</p>
<p>为啥没有原码四位乘法?32和64不也是4的倍数吗?</p>
<p>还要考虑一个复杂性问题</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616230513076.png"
alt="image-20220616230513076" />
<figcaption aria-hidden="true">image-20220616230513076</figcaption>
</figure>
<p>如图原码二位乘已经有<span
class="math inline">\(2^3=8\)</span>种情况了,要是原码四位乘,不考虑低位进位的情况至少这四位需要考虑,就已经有<span
class="math inline">\(2^4=16\)</span>种情况了,显然让ALU考虑多种情况也是需要记忆功能的</p>
<p>在记忆能力和速度都可以接收的范围内,只有原码一位乘和原码二位乘是可行的</p>
<h3 id="规则">规则</h3>
<p>两位乘怎么玩呢?</p>
<p>原来被乘数看乘数最低位的脸色行事,现在被乘数还要看次低位的脸色.真的太卑微了</p>
<p>最低位和次低位的权还不一样,次低位更狠,权更重.</p>
<p>为了更详细的描述这个意思,规定X和Y的位向量表示</p>
<p>X和Y都忽略小数点和符号位,小数点后面的直接作为一个整数</p>
<p><span class="math inline">\(X=X_3X_2X_1X_0\)</span></p>
<p><span class="math inline">\(Y=Y_3Y_2Y_1Y_0\)</span></p>
<p>现在最低位就是<span
class="math inline">\(Y_0\)</span>,次低位就是<span
class="math inline">\(Y_1\)</span>,随着Y不断右移,这两个位会遍历整个Y</p>
<p>当<span
class="math inline">\(Y_1Y_0=11=3(Dec)\)</span>需要向中间过程位向量上加三个被乘数X,</p>
<p>当<span
class="math inline">\(Y_1Y_0=10=2(Dec)\)</span>需要向中间过程位向量上加两个被乘数X</p>
<p>当<span
class="math inline">\(Y_1Y_0=01=1(Dec)\)</span>需要向中间过程位向量上加一个被乘数X</p>
<p>当<span class="math inline">\(Y_1Y_0=00=0(Dec)\)</span>啥也不加</p>
<p>啥也不加,加一个X都好说,加两个X通过将X左移一位×2也容易实现,但是这个半吊子3怎么办呢?</p>
<p><code>3=4-1</code>,啥意思呢?</p>
<p>先从中间过程位向量的高四位减去一个被乘数X,</p>
<p>然后右移两位,这导致刚才减去的X降权4(右移两位相当于除以4),</p>
<p>此时再向高四位加上一个被乘数X,这个刚加上的X的权就高,是刚才减去的X的四倍,</p>
<p>这样一减一加,相当于在上一步(刚才减一的那一步)往中间过程位向量上加上了3个X.</p>
<p>达到了我们的目的</p>
<p>当<span
class="math inline">\(Y_1Y_0=11\)</span>,这时候才会加3X,还有加2X,1X,0的时候,怎么区分多种状态呢?用一个flag开关</p>
<p>也就是下表中的C</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616231945745.png"
alt="image-20220616231945745" />
<figcaption aria-hidden="true">image-20220616231945745</figcaption>
</figure>
<p>这个表什么意思呢?</p>
<h4 id="我一开始的理解">我一开始的理解</h4>
<p><strong>(当然是错误的,但是有借鉴意义)</strong></p>
<p>刚才我们推导怎么实现加3X的时候,先减X,位移后再加上X,看上去顺理成章,确实解决了上一回合需要加3X这个问题,</p>
<p>但是同时引入了新问题,即</p>
<p><strong>位移后的本回合有本回合要做的事情,而你却在本回合处理了上回合要做的事情,那么本回合本来要做的事情啥时候做呢?</strong></p>
<blockquote>
<p>啥叫本回合应该做的事?</p>
<p>每个回合要做的事就是根据<strong>当前</strong>乘数最低两位的脸色决定往中间过程位向量上加几个X</p>
</blockquote>
<p>要么本回合开一个额外回合,在给上回合擦腚之后,先不忙着将乘数右移开启下一个回合,而是正式处理本回合的事.处理完了再右移开启下一回合</p>
<p>但是这样怎么让一个傻子CPU知道这一次有没有额外回合呢?</p>
<p>可以用标志位C.每个正式回合都根据乘数最低两位是否全1,设置C是否为1,</p>
<p>当回合开始的时候,让CPU先检查C开关是否打开,</p>
<p>​ 如果开着则先擦腚,然后C给他关上,</p>
<p>​
如果C关着(不管是本来就管着还是擦完腚关上的,一视同仁),则处理本回合事物</p>
<p>我确实一开始是这样想的,但是仔细观察法则表之后发现人家的想法和我不一样</p>
<h4 id="人家的想法"><strong>人家的想法</strong></h4>
<p>如果按照我的设想,当C为1的时候,不需要看<span
class="math inline">\(Y_1Y_0\)</span>的脸色,直接加X,然后C置零</p>
<p><strong>然而</strong>表中即使C为1也需要看<span
class="math inline">\(Y_{i+1}Y_{i}\)</span>的脸色</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616233254740.png"
alt="image-20220616233254740" />
<figcaption aria-hidden="true">image-20220616233254740</figcaption>
</figure>
<p>那么人家的方法什么思想呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616233344339.png"
alt="image-20220616233344339" />
<figcaption aria-hidden="true">image-20220616233344339</figcaption>
</figure>
<p>这段文字十分滴珍贵,但是是那种懂的人一看就懂,不懂的看了还是不懂(此名言出自计组老师gx)</p>
<p>啥意思呢?不妨从研究这个表的结构规则入手</p>
<p>可以发现,</p>
<p>1.当<span class="math inline">\(Y_{i+1}\)</span>固定时,<span
class="math inline">\(Y_i\)</span>和<span
class="math inline">\(C\)</span>具有对称结构,具体表现为:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616233605441.png"
alt="image-20220616233605441" />
<figcaption aria-hidden="true">image-20220616233605441</figcaption>
</figure>
<p>2.<span class="math inline">\(Y_i\)</span>和<span
class="math inline">\(C\)</span>联手的时候相当于<span
class="math inline">\(Y_{i+1}\)</span> <img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616233706177.png"
alt="image-20220616233706177" /></p>
<p>也就是说,<span class="math inline">\(Y_i\)</span>和<span
class="math inline">\(C\)</span>就有完全相同的地位,<span
class="math inline">\(Y_{i+1}\)</span>权为2, <span
class="math inline">\(Y_i\)</span>权为1,<span
class="math inline">\(C\)</span>的权也是1</p>
<p>而这种类似的结构我们在什么地方见过呢?全加器</p>
<blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/v2-9b6f89175b854c4c335a704982d3520f_r.jpg"
alt="一位全加器真值表" />
<figcaption aria-hidden="true">一位全加器真值表</figcaption>
</figure>
<p>全加器中<span
class="math inline">\(X,Y,C_{i-1}\)</span>三者具有轮换对称结构</p>
<p>而<span
class="math inline">\(C_{i-1}\)</span>表示的是低位向本位的进位开关,类比到原码两位乘法中,他就是低位计算时没擦干净的屁股</p>
<p>在这个全加器运算的时候,会同时考虑三路输入,将<span
class="math inline">\(X_i,Y_i,C_{i-1}\)</span>同时加起来,也就是在完成本回合的事物时,同时把上回合的屁股擦了</p>
<p>但是也可以设计成,<span
class="math inline">\(X_i+Y_i\)</span>先算好,然后将上回合的屁股<span
class="math inline">\(C_{i-1}\)</span>加上</p>
<p>设计固然可以这样设计,但是何必呢?算好的结果还需要保存一下然后才和<span
class="math inline">\(C_{i-1}\)</span>相加.</p>
<p>直接三个加起来不用保存中间结果并且更容易实现,岂不美哉</p>
</blockquote>
<p>就用全加器的思想考虑在原码两位乘法</p>
<p>C不也是低位向本位的进位吗?或者说,上一个回合留到本回合才能擦干净的屁股</p>
<p>在上个回合加4X,不就相当于在本回合加X吗?</p>
<p>处理上回合的屁股顶多在本回合加一个X,</p>
<p>要是本回合本来啥也不干,那么处理屁股,加上X就完了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235501743.png"
alt="image-20220616235501743" />
<figcaption aria-hidden="true">image-20220616235501743</figcaption>
</figure>
<p>要是本回合本来就应该加X,那么一块处理了,加上2X就完了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235511820.png"
alt="image-20220616235511820" />
<figcaption aria-hidden="true">image-20220616235511820</figcaption>
</figure>
<p>要是本回合本来应该加2X,加上屁股一个X,一共3X,只需要减一个X然后继续把屁股交给下一个回合</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235623070.png"
alt="image-20220616235623070" />
<figcaption aria-hidden="true">image-20220616235623070</figcaption>
</figure>
<p>要是本回合本来应该加3X,加上屁股一共四个X,可以加上左移两次的X,但是留一个屁股给下一回合加上也是相当于本回合加4X,还不用位移,岂不美哉</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235634096.png"
alt="image-20220616235634096" />
<figcaption aria-hidden="true">image-20220616235634096</figcaption>
</figure>
<p>如果上个回合没有留屁股(即C=0),则本回合只需要看<span
class="math inline">\(Y_1Y_0\)</span>脸色行事,不用擦屁股</p>
<p>如此这个法则表就不用死记硬背了</p>
<h4 id="手写模拟-1">手写模拟</h4>
<p><span
class="math inline">\(X=+0.100111,Y=-0.100111\)</span>用原码两位乘法求积</p>
<p>符号显然为1</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235859593.png"
alt="image-20220616235859593" />
<figcaption aria-hidden="true">image-20220616235859593</figcaption>
</figure>
<p>这个"符号位"是啥呢?</p>
<p>这确实是符号位,因为过程中有<span
class="math inline">\(-X\)</span>的行为.为啥要三个符号位呢?这个是人为规定的</p>
<p>因为两位乘每回合需要右移两位,那么符号位至少有两位,至于为什么是三位呢?</p>
<p>因为<strong>存在带符号右移</strong>的行为,右移两位之后符号位高两位是填充0呢还是填充1呢?</p>
<p>能不能全都填充0呢?诚如是则三个符号位都是摆设,编课本的人也不用编了.多此一举何必呢?</p>
<p>这符号位的最高位起一个提示的作用,如果最高位为1则右移的时候最高位也补1,否则补0</p>
<p>因此最高位完全是个人爱好添加的,因为只要是最高位是1,则符号位的第二位也是1,完全可以根据第二位的提示填充符号位的高两位</p>
<p>这里就有问题了,为什么会有带符号右移?原码一位乘法的时候明明没有带符号右移啊?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617000021929.png"
alt="image-20220617000021929" />
<figcaption aria-hidden="true">image-20220617000021929</figcaption>
</figure>
<p>因为过程中确实有<span
class="math inline">\(-X\)</span>这种行为,通过加补实现,而补码的符号位就是负数.</p>
<p>如果无符号右移,则本回合<span
class="math inline">\(-X\)</span>在右移后进入下回合时,符号位也跟着移到右侧,这个<span
class="math inline">\(-X\)</span>成了加一个数,失去减法的意义并且导致错误</p>
<h2 id="补码一位乘法--布斯法">补码一位乘法--布斯法</h2>
<h3 id="推导算法原理">推导算法原理</h3>
<p>令<span
class="math inline">\(X=X_0.X_{-1}X_{-2}...X_{-(n-1)}\)</span>,<span
class="math inline">\(Y=Y_0.Y_{-1}Y_{-2}...Y_{-(n-1)}\)</span></p>
<p>将<span class="math inline">\(Y\)</span>按照权位展开 <span
class="math display">\[
\begin{aligned}
Y&amp;=Y_0.Y_{-1}Y_{-2}...Y_{-(n-1)}\\
&amp;=Y_0\times 2^0+Y_{-1}\times 2^{-1}+Y_{-2}\times
2^{-2}+...+Y_{-(n-1)}\times 2^{-(n-1)}\\
&amp;=Y_0(2^1-2^0)+Y_{-1}\times(2^0-2^{-1})+Y_{-2}\times
(2^{-1}-2^{-2})+...+Y_{-(n-1)}\times (2^{-(n-2)}-2^{-(n-1)})\\
&amp;=2Y_0+2^0(Y_{-1}-Y_0)+2^{-1}(Y_{-2}-Y_1)+2^{-2}(Y_{-3}-Y_{-2})+...+2^{-(n-2)}(Y_{-(n-1)}-Y_{-(n-2)})+2^{-(n-1)}(0-Y_{-(n-1)})
\end{aligned}
\]</span> 其中<span class="math inline">\(Y_0\)</span>是符号位,当<span
class="math inline">\(Y_0=0\)</span>,<span
class="math inline">\(2Y_0=0\)</span>,可以忽略</p>
<p>当<span class="math inline">\(Y_1=1\)</span>,<span
class="math inline">\(2Y_1=10\)</span>进位不管,本位还是<span
class="math inline">\(0\)</span>,也可以忽略</p>
<p>那么<span
class="math inline">\(Y=2^0(Y_{-1}-Y_0)+2^{-1}(Y_{-2}-Y_1)+2^{-2}(Y_{-3}-Y_{-2})+...+2^{-(n-2)}(Y_{-(n-1)}-Y_{-(n-2)})+2^{-(n-1)}(0-Y_{-(n-1)})\)</span></p>
<p>不妨令<span class="math inline">\(Y\)</span>最后再加一位<span
class="math inline">\(Y_{-n}=0\)</span>反正小数部分最后添0不会影响小数大小</p>
<p>那么 <span class="math display">\[
\begin{aligned}
Y&amp;=2^0(Y_{-1}-Y_0)+2^{-1}(Y_{-2}-Y_1)+2^{-2}(Y_{-3}-Y_{-2})+...+2^{-(n-2)}(Y_{-(n-1)}-Y_{-(n-2)})+2^{-(n-1)}(Y_{-n}-Y_{-(n-1)})\\
&amp;=\sum_{i=-(n-1)}^{0}2^{i}\times (Y_{i-1}-Y_i)
\end{aligned}
\]</span> 好了,现在<span
class="math inline">\(Y\)</span>经过各种调教,已经连同符号位都可以一起计算了
<span class="math display">\[
\begin{aligned}
X\times Y&amp;=X\times \sum_{i=-(n-1)}^{0}2^{i}\times (Y_{i-1}-Y_i)\\
&amp;=\sum_{i=-(n-1)}^{0}[2^{i}\times (Y_{i-1}-Y_i)\times X]
\end{aligned}
\]</span> 这是一种啥形式呢?每次<span
class="math inline">\(X\)</span>都看<span
class="math inline">\(Y_{i-1}Y_{i}\)</span>的脸色行事,<span
class="math inline">\(2^i\)</span>是这俩哥们儿的权重.此时不再考虑<span
class="math inline">\(Y_{i-1},Y_{i}\)</span>的权重区别了,因为<span
class="math inline">\(2^i\)</span>是两个家伙的共同的权重,两者权重的二倍关系,已经应用在在刚才的转化过程中</p>
<table>
<thead>
<tr>
<th><span class="math inline">\(Y_{i-1}Y_{i}\)</span></th>
<th><span class="math inline">\(Y_{i-1}-Y_{i}\)</span></th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>0</td>
<td>啥也不干</td>
</tr>
<tr>
<td>01</td>
<td>-1</td>
<td>-X</td>
</tr>
<tr>
<td>10</td>
<td>1</td>
<td>+X</td>
</tr>
<tr>
<td>11</td>
<td>0</td>
<td>啥也不干</td>
</tr>
</tbody>
</table>
<p>在一个回合内应该干的事情:</p>
<p>从<span
class="math inline">\(i=-(n-1)\)</span>这个最低权位开始算,每次根据<span
class="math inline">\(Y\)</span>的最低两位确定行为,然后右移一位,将<span
class="math inline">\(Y_i\)</span>移出扬了,刚才的<span
class="math inline">\(Y_{i-1}\)</span>现在是最低位.</p>
<p>每个回合开始前,将上回合的中间过程位向量右移一位,作用是给先前的计算结果都降权2</p>
<h3 id="硬件实现">硬件实现</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617081422674.png"
alt="image-20220617081422674" />
<figcaption aria-hidden="true">image-20220617081422674</figcaption>
</figure>
<p>这个图应该怎样理解呢?</p>
<p>D和A两个寄存器共同组成中间过程位向量,最右边有一个<span
class="math inline">\(A_{-1}\)</span>是附加位,这个刚才我们也分析过了,小数部分最后随便添0不影响结果大小</p>
<p>一开始的时候,乘数<span
class="math inline">\(Y\)</span>符号位和数值位都放在A中,小数点扬了,<span
class="math inline">\(Y\)</span>的最低位落到<span
class="math inline">\(A_0\)</span>,此时<span
class="math inline">\(A_{-1}=0,D=0\)</span></p>
<p>右移的时候<span
class="math inline">\(A_{-1}\)</span>也要参与,刚才的<span
class="math inline">\(A_0\)</span>就移入<span
class="math inline">\(A_{-1}\)</span>,一共右移多少次呢?将A中的乘数刚好扬了为止,比如<span
class="math inline">\(Y=1.0011\)</span>则右移5次(符号位和数值为没有区别)</p>
<p><span
class="math inline">\(A_0A_{-1}\)</span>接入一个二四译码器,而实际上一共有三种情况,啥也不干,+X,-X,怎么把这三种情况转化成机器能听懂的语言呢?</p>
<p>当<span class="math inline">\(A_0A_{-1}=00\)</span>则选择器选通<span
class="math inline">\(D_0=0\)</span></p>
<p>当<span class="math inline">\(A_0A_-1=01\)</span>则选择器选通<span
class="math inline">\(D_1={B}\)</span></p>
<p>当<span class="math inline">\(A_0A_{-1}=10\)</span>则选择器选通<span
class="math inline">\(D_2=\overline {B}\)</span>,此时<span
class="math inline">\(A_0\overline
A_{-1}\)</span>接入与门,与门接到全加器最低位,作用是对<span
class="math inline">\(B\)</span>的取反再+1得到补码</p>
<p>当<span class="math inline">\(A_0A_{-1}=11\)</span>则选择器选通<span
class="math inline">\(D_3=0\)</span></p>
<p>选通信号都输入全加器</p>
<p>中间过程位向量<span
class="math inline">\([D:A]\)</span>在右移的时候带符号右移,即<span
class="math inline">\(CF\)</span>跟着移入最高位,并且右移之后<span
class="math inline">\(CF\)</span>状态不变</p>
<h3 id="手算模拟">手算模拟</h3>
<p><span
class="math inline">\(X=0.1010,Y=-0.1101\)</span>,计算两个数的补码一位布斯乘法</p>
<p><span class="math inline">\([X]_补=00.1010\)</span></p>
<p><span class="math inline">\([Y]_补=11.0011\)</span></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617081351470.png"
alt="image-20220617081351470" />
<figcaption aria-hidden="true">image-20220617081351470</figcaption>
</figure>
<p>最终没有特判符号位,而是符号位已经在CF中了</p>
<p>经过刚才的分析,现在<span
class="math inline">\(A_{-1}\)</span>就具有实际意义了,不再是一个根据人的意愿补上的一位了</p>
<p>每个回合,被乘数都根据<span
class="math inline">\(A_{0}A_{-1}\)</span>的脸色行事,比如当<span
class="math inline">\(A_0A_{-1}=10\)</span>时,应该-X</p>
<p>而这似乎和我们一开始推导算法的时候相反</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617084040120.png"
alt="image-20220617084040120" />
<figcaption aria-hidden="true">image-20220617084040120</figcaption>
</figure>
<p>我们推导的是当<span
class="math inline">\(Y_{i-1}Y_i=10\)</span>时+X</p>
<p>实际上令i=0得到<span
class="math inline">\(Y_{-1}Y_0=10\)</span>调个个儿就得到<span
class="math inline">\(Y_0Y_{-1}=01\)</span></p>
<p>因此<span
class="math inline">\(A_{0}A_{-1}=10\)</span>实际对应的是<span
class="math inline">\(Y_{i-1}Y_i=01\)</span>的情况,行为是-X</p>
<p>这里一定要分清关系</p>
<blockquote>
<p>在手算模拟的时候,只需要用<span
class="math inline">\(A_{-1}-A_0\)</span>,根据结果的正负决定加减X,<span
class="math inline">\(A_{-1}-A_0=1\)</span>则+X</p>
</blockquote>
<p>关于手算时符号位为啥要两位?</p>
<p>实际上机器只需要一位,这一位就有实际意义,即CF的值</p>
<p>然而由于计算过程中需要带符号右移一位,这样符号位是11时右移一位变成01,我们模拟时一看符号位还有1,于是高位填充1,修正成11</p>
<p>即最高位是防止人计算的过程中犯糊涂用的</p>
<p>并且符号位两位起到了双符号位判断溢出的作用,如果计算过程中,出现了两个符号位不同的情况,啃腚是算错了</p>
<h2 id="原码除法">原码除法</h2>
<h3 id="手算">手算</h3>
<p>约定规则</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617085630330.png"
alt="image-20220617085630330" />
<figcaption aria-hidden="true">image-20220617085630330</figcaption>
</figure>
<p>这个规则第一条我就绷不住了,就算是两个定点纯小数,被除数的绝对值也不一定比除数小吧,比如<span
class="math inline">\(0.1111\div 0.0111\)</span>,整数也是如此</p>
<p>那为啥要这样规定呢?为了保证两个定点纯小数的除法结果还是一个定点纯小数,</p>
<p>一旦被除数的绝对值大,则至少结果的整数部分可以商出一个1来,这时候运算结果就是定点既有整数也有小数了</p>
<p>而我们希望的是不使用整数部分,硬件上根本就不允许整数部分有意义,而是只保留小数部分</p>
<p>比如<span class="math inline">\(0.1111\div
0.0111=1.00010001..\)</span></p>
<p>而硬件是这样计算的:<span class="math inline">\(1111\div
0111=00010001\)</span>,因为硬件就认为这个结果只可能是小数</p>
<p>下面通过列竖式的方法计算<span
class="math inline">\(X=0.1011\)</span>,<span
class="math inline">\(Y=0.1101\)</span>两数的除法,推导适用于机器的算法</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617090654188.png"
alt="image-20220617090654188" />
<figcaption aria-hidden="true">image-20220617090654188</figcaption>
</figure>
<p>由于已经保证被除数绝对值小,因此结果的整数个位必定商0</p>
<p>人类在计算竖式的过程中有一个特点---人类会<strong>试商</strong>,啥意思呢?</p>
<p>在商了前两个1之后,下面要计算<span class="math inline">\(1010\div
1101\)</span>,</p>
<p>人类一看除数大,商1就过分了,剪出来一个负数,因此人类此时会商0.</p>
<blockquote>
<p>试商我们从小学就学过了,那时候是在十进制下,每次试商都要按照9,8,7,...,2,1,0这种顺序试商(熟练了可以用二分结果试商),直到试到某个值n,此时用n去乘被除数得到的积刚好比中间结果小或者相等整除,并且商<span
class="math inline">\(n+1\)</span>刚好比中间结果大,那么n就是该位应该上的商</p>
<p>而现在对于二进制,每一位只有两种状态0或者1,我们只需要试商1,成功则商1,失败则商0</p>
<p>本质思想是相同的,只不过二进制中商0和商1是相互对立事件,而十进制中商0和商1是互不相容事件,因为十进制下还可以商2,3,等等</p>
</blockquote>
<p>然而机器怎么试商呢?机器进行的每步运算都要改变硬件状态,试商会直接把商写进中间过程位向量,他只有一次机会,不允许试.而人类可以在草稿上试商然后将准确的商写道卷子上</p>
<h3 id="恢复余数法">恢复余数法</h3>
<p>虽然机器不能试商,但是机器可以知道的是,自己尚一个1,有没有商的太过分了,</p>
<p>商1,则用中间结果去减被除数,如果减出来结果是个负数,机器就能根据符号位知道发生了什么.</p>
<p>他知道刚才商的太狠了,本应该下手轻点的.</p>
<p>于是他可以反悔,刚才商1导致中间结果负了,那么现在改商0,中间结果再加一个被除数还原到商1之前的情况,刚才商的1不算数.这个过程叫做"<strong>恢复余数</strong>"</p>
<p>手算模拟<span
class="math inline">\(X=-0.10001011除以Y=0.0110\)</span>的过程</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617093100955.png"
alt="image-20220617093100955" />
<figcaption aria-hidden="true">image-20220617093100955</figcaption>
</figure>
<p>最终结果咋看呢?</p>
<p>看最后一行,</p>
<p>商的绝对值是<span
class="math inline">\(0.1001\)</span>,最前面这个0肯定是0,这就是整数位个位的商,由于被除数比除数小,因此这一位必定为0,商的结果根据除数和被除数的符号位异或决定,因此商是<span
class="math inline">\(1.1001\)</span></p>
<p>余数的绝对值是<span class="math inline">\(0.1101\times
2^{-4}\)</span>,符号应该和商一致,因此余数是<span
class="math inline">\(1.1101\times 2^{-4}\)</span></p>
<p>这里<span
class="math inline">\(2^{-4}\)</span>怎么来的呢?余数实际上是中间过程位向量最开始时的低四位经过运算和左移得到的,其本来的权就是<span
class="math inline">\(2^{-4}\)</span></p>
<p>为啥乘法的时候需要中间过程右移,而除法的时候需要中间过程左移呢?</p>
<p>在做除法的时候我们都是从高位往低位商,而做乘法的时候是从低位向高位乘,两种运算的顺序相反</p>
<p>做除法时早商应该比晚商权重高,通过左移,越早的商越高,权重越大</p>
<p>从图上可以发现一个问题,够减的时候,中间结果左移,不够减的时候,恢复余数,不左移</p>
<p>怎么让机器知道够不够减?前面分析的是根据符号位.</p>
<p>确实根据符号位可以知道这个事情,但是知道了怎么处理呢?</p>
<p>哪个元件可以根据CF的状态,决定给ALU送什么数呢?这个过程对硬件来说太抽象,不容易实现</p>
<p>想法总是千奇百怪,但是真到落地实现的时候,直接摔死</p>
<blockquote>
<p>这让我想到大二上学微信小程序的时候,我竟然痴心妄想整一个支持markdown,用缩进表示分支的思维导图(Flowchart).属实是高估自己的编程能力和知识储备了</p>
<p>然而本学期tx学写游戏的时候,一些听上去天马行空的事情,都被库函数实现了,只能说,人定胜天</p>
</blockquote>
<h3 id="加减交替法">加减交替法</h3>
<p>由于恢复余数法不方便实现,考虑一个让硬件舒服的方法</p>
<p>还是从恢复余数法中吸取教训</p>
<p>不妨定义一个说法"回合",感觉这像是一个状态机</p>
<p>每一回合都要经过,恢复余数(这算是上回合留下的屁股),左移一位,上本次的商,这几个过程</p>
<p>如果上回合留下了一个屁股,即上回合商1导致中间过程负了,本回合需要首先加上被除数恢复余数,并且上回合的商1作废,改为0,然后左移一位,让上回合的商升权2,然后直接商1,把屁股留给下一个回合</p>
<p>如果上回合没有留下屁股,即上回合商1,中间过程减去被除数得到正数,则不需要恢复余数,直接左移让上回合的商1升权2,然后直接商1把本回合的屁股留给下一个回合</p>
<p>好的, 现在考虑,</p>
<p>本回合需要处理上回合的屁股,首先R(中间过程结果)+Y(被除数),</p>
<p>然后左移一位,<span class="math inline">\(2(R+Y)\)</span></p>
<p>然后处理本回合事物,直接商1有<span
class="math inline">\(2(R+Y)-Y=2R+Y\)</span></p>
<p>这不就相当于刚才不擦屁股,直接余数R左移,然后加上Y吗</p>
<p>本回合不用擦上回合的屁股</p>
<p>直接R左移一位变成2R</p>
<p>然后处理本回合事物,直接商1有<span
class="math inline">\(2R-Y\)</span></p>
<p>综上,每个回合要么<span class="math inline">\(2R+Y\)</span>,要么<span
class="math inline">\(2R-Y\)</span>,总共两种状态,</p>
<p>通过中间过程符号位决定本回合采用哪种状态</p>
<p>啥时候上商呢?在回合开始还没有位移的时候,根据中间过程的符号上商,</p>
<p>中间过程符号为0则商1,中间过程符号为1则商0</p>
<p>这就好实现了,</p>
<p>2R相当于本回合上来就中间过程左移,</p>
<p>中间过程符号位作为地址端接到2选1选择器,</p>
<p>符号为1则<span
class="math inline">\(-Y\)</span>选通,并且还要向ALU最低位加一个1,实现加补操作</p>
<p>符号为0则<span class="math inline">\(+Y\)</span>选通</p>
<p>硬件实现如图</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617102424109.png"
alt="image-20220617102424109" />
<figcaption aria-hidden="true">image-20220617102424109</figcaption>
</figure>
<p>怎么解读这个框图呢?</p>
<p>以<span
class="math inline">\(X=-0.10001011,Y=0.1110\)</span>为例,</p>
<p><span class="math inline">\(|X|=0.10001011,|Y|=0.1110\)</span></p>
<p>一开始<span class="math inline">\(|X|\)</span>放在D和A中</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617103310655.png"
alt="image-20220617103310655" />
<figcaption aria-hidden="true">image-20220617103310655</figcaption>
</figure>
<p>第一回合,本回合比较特殊,当前中间过程就是被除数(绝对值),符号为正,但是商0</p>
<p>然后左移,刚才的符号位0取反后移入<span
class="math inline">\(A_0\)</span>,<span
class="math inline">\(A_0=1\)</span>决定本回合-Y,即加Y补</p>
<p>得到新的中间过程</p>
<p>如下图描述</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617104129464.png"
alt="image-20220617104129464" />
<figcaption aria-hidden="true">image-20220617104129464</figcaption>
</figure>
<p>第二回合,当前中间过程为<span
class="math inline">\(00&#39;00110110&#39;\)</span>,符号为正,商1</p>
<p>左移一位,符号位0取反之后移入<span
class="math inline">\(A_0\)</span>,<span
class="math inline">\(A_0=1\)</span>决定本回合<span
class="math inline">\(-|Y|\)</span>,即加补</p>
<p>得到新的中间过程</p>
<p>如下图描述</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617104639433.png"
alt="image-20220617104639433" />
<figcaption aria-hidden="true">image-20220617104639433</figcaption>
</figure>
<p>第三回合,当前中间过程为<span
class="math inline">\(11&#39;10001101\)</span>,符号为负,商1</p>
<p>左移一位,符号位1取反得0之后移入<span
class="math inline">\(A_0\)</span>,<span
class="math inline">\(A_0=0\)</span>决定本回合应该<span
class="math inline">\(+|Y|\)</span></p>
<p>得到新的中间过程</p>
<p>如下图描述</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617104826502.png"
alt="image-20220617104826502" />
<figcaption aria-hidden="true">image-20220617104826502</figcaption>
</figure>
<p>以此类推</p>
<p>最终结果怎么看呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617105339564.png"
alt="image-20220617105339564" />
<figcaption aria-hidden="true">image-20220617105339564</figcaption>
</figure>
<p>商这一列从上到下就是商,最上面这个0不用管,每次都是0,原因是我们故意控制被除数绝对值比除数小</p>
<p>或者看最下面这一行最右边01001,就是商这一列不断右移得到的</p>
<p>余数绝对值<span class="math inline">\(0.1101\times
2^{-4}\)</span>,符号和商相同,都要看被除数和除数的符号异或</p>
<h2 id="补码除法">补码除法</h2>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617110237294.png"
alt="image-20220617110237294" />
<figcaption aria-hidden="true">image-20220617110237294</figcaption>
</figure>
<p>这句话我看了好半天才看明白,</p>
<p>"与乘法运算的情况类似,有时也会<strong>迂回</strong>到补码乘法"</p>
<p>好家伙算个数还有迂回战术,就gx那三眼一板,一丝不苟的治学态度,我不大相信他能整出这样的词儿来</p>
<p>看了好几遍发现没有"回",就一个"迂",</p>
<p>是在说用补码做除法的人都<strong>迂</strong>吗?想到这里我都笑出了声,</p>
<p>用迂字骂人真有感觉,尤其和13合起来,"迂13!",这山东话绝对有气势</p>
<blockquote>
<p>巧了宿舍群就这样命名的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617110800214.png"
alt="image-20220617110800214" />
<figcaption aria-hidden="true">image-20220617110800214</figcaption>
</figure>
</blockquote>
<p>应该是错字,本来想用"用"字的</p>
<p>绷不住了</p>
<h3 id="补码除法状态机">补码除法状态机</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617111542233.png"
alt="image-20220617111542233" />
<figcaption aria-hidden="true">image-20220617111542233</figcaption>
</figure>
<p><strong>状态</strong>就是被除数或者说余数,或者说中间过程位向量的符号状态,所有的状态转移都是根据该符号位决定的</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CS/" rel="tag"># CS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/06/15/%E8%B5%B7%E6%9D%A5,%E4%B8%8D%E6%84%BF%E5%81%9A%E6%9D%BF%E7%A0%96%E5%84%BF%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="prev" title="起来,不愿作板儿砖的计算机">
      <i class="fa fa-chevron-left"></i> 起来,不愿作板儿砖的计算机
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/06/20/xctf-pwn-%E9%AB%98%E6%89%8B%E6%9D%91/" rel="next" title="xctf攻防世界-pwn-高手村">
      xctf攻防世界-pwn-高手村 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E7%BA%A7%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">机器级算术运算的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E7%AE%97%E5%8E%9F%E7%A0%81%E4%B9%98%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">手算原码乘法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">原码一位乘法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%BF%E6%9C%BA%E5%99%A8%E7%9E%8E%E6%93%8D%E5%BF%83"><span class="nav-number">1.2.1.</span> <span class="nav-text">替机器瞎操心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.2.</span> <span class="nav-text">滚动数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E6%A1%86%E5%9B%BE%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">硬件框图的意义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E6%A8%A1%E6%8B%9F"><span class="nav-number">1.2.3.</span> <span class="nav-text">手写模拟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8F%B3%E7%A7%BB"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">无符号右移?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%A0%81%E4%B8%A4%E4%BD%8D%E4%B9%98%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">原码两位乘法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E5%95%A5%E8%A6%81%E4%B8%A4%E4%BD%8D%E4%B9%98"><span class="nav-number">1.3.1.</span> <span class="nav-text">为啥要两位乘?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%84%E5%88%99"><span class="nav-number">1.3.2.</span> <span class="nav-text">规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%91%E4%B8%80%E5%BC%80%E5%A7%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">我一开始的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%BA%E5%AE%B6%E7%9A%84%E6%83%B3%E6%B3%95"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">人家的想法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E6%A8%A1%E6%8B%9F-1"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">手写模拟</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95--%E5%B8%83%E6%96%AF%E6%B3%95"><span class="nav-number">1.4.</span> <span class="nav-text">补码一位乘法--布斯法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E5%AF%BC%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.1.</span> <span class="nav-text">推导算法原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.2.</span> <span class="nav-text">硬件实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E7%AE%97%E6%A8%A1%E6%8B%9F"><span class="nav-number">1.4.3.</span> <span class="nav-text">手算模拟</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%A0%81%E9%99%A4%E6%B3%95"><span class="nav-number">1.5.</span> <span class="nav-text">原码除法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E7%AE%97"><span class="nav-number">1.5.1.</span> <span class="nav-text">手算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E4%BD%99%E6%95%B0%E6%B3%95"><span class="nav-number">1.5.2.</span> <span class="nav-text">恢复余数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%95"><span class="nav-number">1.5.3.</span> <span class="nav-text">加减交替法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E7%A0%81%E9%99%A4%E6%B3%95"><span class="nav-number">1.6.</span> <span class="nav-text">补码除法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E7%A0%81%E9%99%A4%E6%B3%95%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">1.6.1.</span> <span class="nav-text">补码除法状态机</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
