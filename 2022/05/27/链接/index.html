<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","width":500,"display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文的typora onedark风格见:linkage 链接 win11+vscode+wsl 链接是对.o,.a,.so而言的,在此之前要先经过编译,即程序从源代码.c文件编译成目标文件.o 从.c到.o 将要遭遇的概念 GCC:(GNU Compiler Collection)GNU编译器集合 gcc和g++都属于&quot;编译器驱动程序&quot;(driver),实际上编译器是cc1(C语言">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP-chapter7 链接">
<meta property="og:url" content="http://deutschball.github.io/2022/05/27/%E9%93%BE%E6%8E%A5/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="本文的typora onedark风格见:linkage 链接 win11+vscode+wsl 链接是对.o,.a,.so而言的,在此之前要先经过编译,即程序从源代码.c文件编译成目标文件.o 从.c到.o 将要遭遇的概念 GCC:(GNU Compiler Collection)GNU编译器集合 gcc和g++都属于&quot;编译器驱动程序&quot;(driver),实际上编译器是cc1(C语言">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-05-27T04:20:00.000Z">
<meta property="article:modified_time" content="2024-03-09T12:50:49.270Z">
<meta property="article:author" content="dustball">
<meta property="article:tag" content="CSAPP">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://deutschball.github.io/2022/05/27/%E9%93%BE%E6%8E%A5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>CSAPP-chapter7 链接 | dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/05/27/%E9%93%BE%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CSAPP-chapter7 链接
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-27 12:20:00" itemprop="dateCreated datePublished" datetime="2022-05-27T12:20:00+08:00">2022-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-03-09 20:50:49" itemprop="dateModified" datetime="2024-03-09T20:50:49+08:00">2024-03-09</time>
              </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文的typora onedark风格见:<a
target="_blank" rel="noopener" href="https://dustball.top/HTML/linkage.html">linkage</a></p>
<h1 id="链接">链接</h1>
<p>win11+vscode+wsl</p>
<p>链接是对.o,.a,.so而言的,在此之前要先经过编译,即程序从源代码.c文件编译成目标文件.o</p>
<h2 id="从.c到.o">从.c到.o</h2>
<h3 id="将要遭遇的概念">将要遭遇的概念</h3>
<p>GCC:(GNU Compiler Collection)GNU编译器集合</p>
<p>gcc和g++都属于"编译器驱动程序"(driver),实际上编译器是cc1(C语言),cc1plus(C++语言)</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:~/mydir# whereis gcc</span><br><span class="line">gcc: /usr/bin/gcc /usr/lib/gcc /usr/share/gcc /usr/share/man/man1/gcc.1.gz</span><br></pre></td></tr></table></figure>
<p>在linux系统上自带,可以用whereis 命令查询gcc的位置</p>
<p>我们实际调用的是第一个<code>/usr/bin/gcc</code></p>
<p>/usr目录:unix system
resources缩写,包含了所有共享文件,是unix系统最重要的目录之一</p>
<p>用户的家原来也在这里,但是现在改成了/home</p>
<p>/usr/bin目录:所有可执行文件,比如gcc,g++</p>
</blockquote>
<p>GAS:GNU汇编器（GNU
Assembler），简称为GAS.使用gcc命令时汇编器(as)和链接器(ld)都是GAS提供的</p>
<h3 id="gcc和g的区别">gcc和g++的区别</h3>
<p>包括但是不止下面两条</p>
<ol type="1">
<li></li>
</ol>
<p>gcc对于.c文件调用cc1编译器,对于.cpp文件调用cc1plus编译器</p>
<p>g++不管是.c和.cpp都会调用cc1plus编译器</p>
<ol start="2" type="1">
<li></li>
</ol>
<p>在链接时gcc==不会==传递给链接器链接C++标准库的命令但是g++会</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;v;<span class="comment">//此处需要使用STL中的vector</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如这样一个test.cpp文件</p>
<p>使用gcc命令编译则会报错:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# gcc test.cpp -o test.out</span><br><span class="line">/usr/bin/ld: /tmp/ccfXp0Kz.o: <span class="keyword">in</span> <span class="keyword">function</span> `__gnu_cxx::new_allocator&lt;int&gt;::deallocate(int*, unsigned long)<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">test.cpp:(.text._ZN9__gnu_cxx13new_allocatorIiE10deallocateEPim[_ZN9__gnu_cxx13new_allocatorIiE10deallocateEPim]+0x20): undefined reference to `operator delete(void*)&#x27;</span></span><br><span class="line">/usr/bin/ld: /tmp/ccfXp0Kz.o:(.data.rel.local.DW.ref.__gxx_personality_v0[DW.ref.__gxx_personality_v0]+0x0): undefined reference to `__gxx_personality_v0<span class="string">&#x27;</span></span><br><span class="line"><span class="string">collect2: error: ld returned 1 exit status</span></span><br></pre></td></tr></table></figure>
<p>但是使用g++命令编译则不会报错</p>
<p>如果想让gcc命令编译时让链接器可以链接标准库可以使用命令行参数<code>-lstdc++</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# gcc test.cpp -o test.out -lstdc++</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是即使加上该参数,使用gcc和g++对于.cpp的编译还是有区别的.</p>
<p>啥区别我现在不知道,也不想知道</p>
<p>因此现阶段在编译.c源代码时就用gcc命令,编译.cpp源代码时就用g++命令</p>
<h3
id="gcc命令行参数和.c到.exe的过程">gcc命令行参数和.c到.exe的过程</h3>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/441e2211a121079fdd5f07542a3b2313.png"
alt="image-20220401003811834" />
<figcaption aria-hidden="true">image-20220401003811834</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/6ade9eae51f7c18adf10e6905673a554.png"
alt="image-20220401003612021" />
<figcaption aria-hidden="true">image-20220401003612021</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/86a785b63483f768b90553bb2b84a6e6.png"
alt="image-20220331235005241" />
<figcaption aria-hidden="true">image-20220331235005241</figcaption>
</figure>
<h4 id="预编译-e">预编译-E</h4>
<p>预编译命令只能作用于源代码文件(.c,.cpp)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E balabala.c</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpp balabala.c</span><br></pre></td></tr></table></figure>
<p>1.将所有include(包括库文件和自己写的文件)展开</p>
<p>2.替换所有的宏定义</p>
<p>比如</p>
<p>test.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> word;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> a=N;</span><br><span class="line">  word b=N;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>gcc test.c -E</code>(使用<code>cpp test.c</code>作用相同)之后会将预编译内容打印到屏幕,但是不会生成.i文件</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/9bbf91702b485741525fd0e7657384e9.png"
alt="image-20220331222506965" />
<figcaption aria-hidden="true">image-20220331222506965</figcaption>
</figure>
<p>(截图仅为一小部分)</p>
<p>观察到<code>#define N 10</code>消失,N被10替换</p>
<p><code>typedef</code>起别名并不会被替换</p>
<p>使用-o命令行参数指定预编译生成文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpp test.c -o test.i</span><br></pre></td></tr></table></figure>
<p>然后使用<code>ls -sh -l</code>名令以列表方式查看当前目录下文件大小</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/213bf06d5c5260f55778c0ad5cb99876.png"
alt="image-20220331224027046" />
<figcaption aria-hidden="true">image-20220331224027046</figcaption>
</figure>
<p>可见.i文件明显比.c文件大</p>
<h5 id="i命令行参数指定自定义头文件">-I命令行参数指定自定义头文件</h5>
<p><strong>如果需要包含的头文件和就在当前目录下则自动包含,</strong></p>
<p>比如当前目录(mydir/)下</p>
<p>有一个自定义头文件<code>myheader.h</code>里面只有一个变量a的定义</p>
<p>有一个test.c里面没有定义a直接拿来用</p>
<p>此时预编译是可以通过的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir<span class="meta"># ls -l</span></span><br><span class="line">总用量 <span class="number">8</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">10</span> <span class="number">3</span>月  <span class="number">31</span> <span class="number">22</span>:<span class="number">43</span> myheader.h</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">51</span> <span class="number">3</span>月  <span class="number">31</span> <span class="number">22</span>:<span class="number">44</span> test.c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir<span class="meta"># cpp test.c -o test.i</span></span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir<span class="meta"># cat test.i</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">31</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">32</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;myheader.h&quot;</span> <span class="number">1</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"># <span class="number">2</span> <span class="string">&quot;test.c&quot;</span> <span class="number">2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> a;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果在其他目录则需要<code>- I &lt;directory&gt;</code>指定包含文件所在的目录</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 8</span><br><span class="line">-rw-r--r-- 1 root root 10 3月  31 22:43 myheader.h</span><br><span class="line">-rw-r--r-- 1 root root 51 3月  31 22:44 test.c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">mv</span> myheader.h ..</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span></span><br><span class="line">test.c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# cpp test.c</span><br><span class="line"><span class="comment"># 1 &quot;test.c&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"><span class="comment"># 31 &quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4</span></span><br><span class="line"><span class="comment"># 32 &quot;&lt;command-line&gt;&quot; 2</span></span><br><span class="line"><span class="comment"># 1 &quot;test.c&quot;</span></span><br><span class="line">test.c:1:10: fatal error: myheader.h: 没有那个文件或目录</span><br><span class="line">    1 | <span class="comment">#include &quot;myheader.h&quot;</span></span><br><span class="line">      |          ^~~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure>
<p>将原本与test.c同目录的myheader.h移动到上级目录(..)中,此时使用cpp命令则在当前目录下找不到myheader.h报错了</p>
<p>此时使用<code>-I &lt;directory&gt;</code>指定上级目录(..)为包含路径则预编译通过</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# cpp test.c -I ..</span><br><span class="line"><span class="comment"># 1 &quot;test.c&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"><span class="comment"># 31 &quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4</span></span><br><span class="line"><span class="comment"># 32 &quot;&lt;command-line&gt;&quot; 2</span></span><br><span class="line"><span class="comment"># 1 &quot;test.c&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;../myheader.h&quot; 1</span></span><br><span class="line">int a=10;</span><br><span class="line"><span class="comment"># 2 &quot;test.c&quot; 2</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line"> a;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译compilation-s">编译(Compilation)-S</h4>
<p>编译命令可以应用于前面所有类型的文件(.c,.i)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S balabala.c</span><br></pre></td></tr></table></figure>
<p>作用是将源代码(或者说预编译之后的源代码)编译成汇编语言</p>
<p>将一个全空的c程序(一个字都没写的,这样写当然不对,但是是在后来的某一阶段报错)test.c编译成汇编语言,会在同一目录下生成test.s文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# gcc test.c -S</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">cat</span> test.s</span><br><span class="line">  .file <span class="string">&quot;test.c&quot;</span></span><br><span class="line">  .text</span><br><span class="line">  .ident      <span class="string">&quot;GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0&quot;</span></span><br><span class="line">  .section    .note.GNU-stack,<span class="string">&quot;&quot;</span>,@progbits</span><br><span class="line">  .section    .note.gnu.property,<span class="string">&quot;a&quot;</span></span><br><span class="line">  .align 8</span><br><span class="line">  .long  1f - 0f</span><br><span class="line">  .long  4f - 1f</span><br><span class="line">  .long  5</span><br><span class="line">0:</span><br><span class="line">  .string      <span class="string">&quot;GNU&quot;</span></span><br><span class="line">1:</span><br><span class="line">  .align 8</span><br><span class="line">  .long  0xc0000002</span><br><span class="line">  .long  3f - 2f</span><br><span class="line">2:</span><br><span class="line">  .long  0x3</span><br><span class="line">3:</span><br><span class="line">  .align 8</span><br><span class="line">4:</span><br></pre></td></tr></table></figure>
<p>关于汇编语言后来会学,但不是现在</p>
<h4 id="汇编assembly-c">汇编(Assembly)-c</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc balabala.c -c</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as balabala.c</span><br></pre></td></tr></table></figure>
<p>汇编命令可以应用于前面过程中生成的所有文件(.c,.i,.s)</p>
<blockquote>
<p><strong>汇编过程将上一步的汇编代码转换成机器码(machine
code)</strong>，这一步产生的文件叫做<strong>目标文件</strong>，是二进制格式</p>
</blockquote>
<p>对于一个啥也没写的test.c文件,预编译,编译,汇编都是可以通过的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">echo</span> &gt; test.c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 4</span><br><span class="line">-rw-r--r-- 1 root root 1 3月  31 23:04 test.c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">cat</span> test.c</span><br><span class="line"></span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# cpp test.c -o test.i</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# gcc test.i -S</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 12</span><br><span class="line">-rw-r--r-- 1 root root   1 3月  31 23:04 test.c</span><br><span class="line">-rw-r--r-- 1 root root 149 3月  31 23:04 test.i</span><br><span class="line">-rw-r--r-- 1 root root 298 3月  31 23:04 test.s</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# gcc test.s -c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 16</span><br><span class="line">-rw-r--r-- 1 root root    1 3月  31 23:04 test.c</span><br><span class="line">-rw-r--r-- 1 root root  149 3月  31 23:04 test.i</span><br><span class="line">-rw-r--r-- 1 root root 1072 3月  31 23:06 test.o</span><br><span class="line">-rw-r--r-- 1 root root  298 3月  31 23:04 test.s</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">cat</span> test.o</span><br><span class="line">ELF&gt;�@@</span><br><span class="line">  GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0GNU���test.c.symtab.strtab.shstrtab.text.data.bss.comment.note.GNU-stack.note.gnu.property!@@,0@,5lEp�� PXX</span><br></pre></td></tr></table></figure>
<p>到此为止,我们完成了下图中红框中的部分</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/37c9008fc9dd09ea605e54bb4b5787ff.png"
alt="image-20220401001520336" />
<figcaption aria-hidden="true">image-20220401001520336</figcaption>
</figure>
<p>下面来到了链接阶段对应图中load time</p>
<h4 id="链接linking">链接(Linking)</h4>
<p>ld负责将程序的目标文件与所需的所有附加的目标文件连接起来，最终生成可执行文件。</p>
<p>附加的目标文件包括==静态连接库和动态连接库==。</p>
<p>还是一个字也没写的test</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# gcc test.o -o test.out</span><br><span class="line">/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o: <span class="keyword">in</span> <span class="keyword">function</span> `_start<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">(.text+0x24): undefined reference to `main&#x27;</span></span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br><span class="line"></span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# ld test.o</span><br><span class="line">ld: 警告: 无法找到项目符号 _start; 缺省为 0000000000401000</span><br></pre></td></tr></table></figure>
<p>在链接阶段终于报错了</p>
<p>报错原因是程序总要有一个main函数入口,一个空的test自然没有main函数</p>
<h5 id="库">库</h5>
<p>库就是现成的可以复用的"代码".</p>
<p>这里"代码"加了引号,因为库不是我们使用的高级语言代码,而是机器码</p>
<blockquote>
<p>一看到"库"我第一反应是包含的头文件</p>
<p><code>#include &lt;stdio.h&gt;</code>之后使用-E编译命令可以看到预编译生成的.i文件,里面全都是声明,没有实现,函数也都是一些接口,没有函数体,显然只通过include头文件是没法运行这些函数的,那么这些函数的实现在哪里呢?程序怎么找到的函数实现呢?</p>
<p>从前道听途说的是在.cpp文件中,在cpp源文件中我们确实可以看到函数的实现,但是我们在编译过程中一直没有与cpp文件发生关联啊?只有.cpp文件包含了.h但是没有见.h包含.cpp啊?从前我幼稚可笑的想法是会根据文件名自动找,比如<code>#include "balabala.h"</code>之后编译器会自动在同目录下找同名的<code>balabala.cpp</code>.但是通过<code>gcc -E</code>命令可以清楚的看到并没有.并且从来没有规定说头文件和源文件的文件名相同.我原来的想法纯属胡扯</p>
<p>库,头文件,源文件的区别和联系,参考https://www.runoob.com/w3cnote/cpp-header.html</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/389c0f3472cca4d688f97a3e3fc606f3.png"
alt="image-20220401011132234" />
<figcaption aria-hidden="true">image-20220401011132234</figcaption>
</figure>
<p><strong>可以得到几点结论:</strong></p>
<p>1..cpp这种拓展名不是必须的</p>
<p>2.寻找函数实现是在链接阶段完成的,而引入只有声明的头文件是为了使得编译可以通过</p>
<p>3.函数实现以.o或.obj格式参与到链接中</p>
<p>4.unix下即使不引入头文件,只指明链接阶段需要的.o文件,也可以通过编译,但不是一个好习惯</p>
<p>5.我们程序中使用到符号(函数名,变量名等)会在==参与链接的所有.o文件==中寻找,重复定义报错发生在该阶段</p>
<p><strong>经过前面的学习,我们自己了解到的知识</strong></p>
<p>1..o是.s文件经过汇编生成的,我们自己写的程序也会经历该阶段</p>
<p>2.链接时会连接多个.o文件,包括==自己的==和==库中的==</p>
<p>那么虽然菜鸟教程里没有提到"库",==我们也可以推测,预定义的.cpp编译生成的.o文件就是库==</p>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37806908/article/details/97686753">这篇博客证明了我的猜测</a></p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/4776958a286c0e87718c164b107099d0.png"
alt="image-20220401013407948" />
<figcaption aria-hidden="true">image-20220401013407948</figcaption>
</figure>
<p>.a是多个.o合在一起,和.o是一个性质的文件</p>
<p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/skynet/p/3372855.html">这个博客也证明了我的想法</a></p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/3d75cf7547fcd04ae74a1286e24df585.png"
alt="image-20220401015054137" />
<figcaption aria-hidden="true">image-20220401015054137</figcaption>
</figure>
<p>还有一个问题,makefile是啥?</p>
<p>记得在上学期用Dev-cpp写一卡通乘车系统项目时,建立项目后会在项目目录下生成一个makefile文件</p>
<p>现在用devcpp建立一个空白项目</p>
<p>项目根目录下有这么几个文件</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/24c6bc0e7cf5d3cdec752f46ef64de9b.png"
alt="image-20220401013807320" />
<figcaption aria-hidden="true">image-20220401013807320</figcaption>
</figure>
<p>其中Makefile.win</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Project: project</span><br><span class="line"># Makefile created by Dev-C++ <span class="number">5.15</span></span><br><span class="line"></span><br><span class="line">CPP      = g++.exe -D__DEBUG__</span><br><span class="line">CC       = gcc.exe -D__DEBUG__</span><br><span class="line">WINDRES  = windres.exe</span><br><span class="line">OBJ      = main.o</span><br><span class="line">LINKOBJ  = main.o</span><br><span class="line">LIBS     = -<span class="string">L&quot;D:/Dev-Cpp/TDM-GCC-64/x86_64-w64-mingw32/lib32&quot;</span> -<span class="type">static</span>-libgcc -m32 -g3</span><br><span class="line">INCS     = -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/x86_64-w64-mingw32/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/9.2.0/include&quot;</span></span><br><span class="line">CXXINCS  = -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/x86_64-w64-mingw32/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/9.2.0/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/9.2.0/include/c++&quot;</span></span><br><span class="line">BIN      = project.exe</span><br><span class="line">CXXFLAGS = $(CXXINCS) -Og -m32 -g3</span><br><span class="line">CFLAGS   = $(INCS) -Og -m32 -g3</span><br><span class="line">RM       = del /q</span><br><span class="line"></span><br><span class="line">.PHONY: all all-before all-after clean clean-custom</span><br><span class="line"></span><br><span class="line">all: all-before $(BIN) all-after</span><br><span class="line"></span><br><span class="line">clean: clean-custom</span><br><span class="line">	$&#123;RM&#125; $(OBJ) $(BIN)</span><br><span class="line"></span><br><span class="line">$(BIN): $(OBJ)</span><br><span class="line">	$(CC) $(LINKOBJ) -o $(BIN) $(LIBS)</span><br><span class="line"></span><br><span class="line">main.o: main.c</span><br><span class="line">	$(CC) -c main.c -o main.o $(CFLAGS)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPP      = g++.exe -D__DEBUG__</span><br><span class="line">CC       = gcc.exe -D__DEBUG__</span><br></pre></td></tr></table></figure>
<p>这里好像把<code>g++.exe -D__DEBUG__</code>命令重新起名CPP</p>
<p>后来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.o: main.c</span><br><span class="line">	$(CC) -c main.c -o main.o $(CFLAGS)</span><br></pre></td></tr></table></figure>
<p>在这里带入的话相当于</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc.exe -D__DEBUG__ -c main.c -o main.o -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/x86_64-w64-mingw32/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/9.2.0/include&quot;</span> -Og -m32 -g3</span><br></pre></td></tr></table></figure>
<p>用gcc执行了命令,==并且用-I参数指定了链接阶段需要加入链接的库文件的目录==</p>
<p>由此可见,Makefile不过是一个脚本罢了,是我们不用在命令行在==链接阶段==输入冗长的命令</p>
<p>如果在项目中加入源文件比如<code>test.cpp</code>并且编译运行main.c</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/fcb8fec5ac02c2c60d79be136b9451b7.png"
alt="image-20220401015434869" />
<figcaption aria-hidden="true">image-20220401015434869</figcaption>
</figure>
<p>之后会在Makefile.win里面增加一条记录</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test.o: test.cpp</span><br><span class="line">	$(CC) -c test.cpp -o test.o $(CFLAGS)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是向项目中加入头文件比如test.h然后编译运行main.c则不会在Makefile.win中增加记录</p>
<p>说明Makefile只管.cpp和.c文件时如何编译为.o文件的,头文件.h它毫不关心</p>
</blockquote>
<p>到此我们知道了多个文件是如何互相找到,在何时互相找到的,也就是链接要做的事情</p>
<p>下面为了更清楚地理解库的作用,我们需要亲自写几个库试试</p>
<p>然后我查阅了这个博客https://www.cnblogs.com/skynet/p/3372855.html</p>
<p>库有两种,一种是静态库,一种是动态库</p>
<p><strong>静态库</strong>(.a,.lib)</p>
<p>静态库会在链接时与我们自己编译生成的.o文件一起链接打包到可执行文件,这种链接方式称为"静态链接"</p>
<p>静态库可以看作一组目标文件(.o)的集合</p>
<p>静态库对函数库的链接是在编译链接时期完成的</p>
<p>程序运行时与函数库已经没有关系,方便移植</p>
<p>浪费空间,不容易更新</p>
<p><strong>动态库</strong>(.so.dll)</p>
<blockquote>
<p>windows上的动态库.dll我们早就见过了</p>
<p>比如红警3根目录下面就可以见到</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/c34f7f9dcbb4783085a0b1277ec42747.png"
alt="image-20220401113523196" />
<figcaption aria-hidden="true">image-20220401113523196</figcaption>
</figure>
</blockquote>
<p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/skynet/p/3372855.html">图片来自播客</a></p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/719104933403b1f0681d43d0c32dc318.png"
alt="image-20220401112348428" />
<figcaption aria-hidden="true">image-20220401112348428</figcaption>
</figure>
<p>动态库的出现是为了解决两个问题</p>
<p>1.静态库占用空间,多个程序可能有相同的静态库</p>
<p>2.更新时,静态库即使静态库稍微改动一点,也需要全部重新编译(全量更新)</p>
<p>动态库相对这两点的特性</p>
<p>1.多个程序复用同一个库</p>
<p>2.增量更新,哪里更新就编译哪里</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/42c1dee76a6f7a6ec8b7985e2496bc18.png"
alt="image-20220401112727292" />
<figcaption aria-hidden="true">image-20220401112727292</figcaption>
</figure>
<p>这就要求动态库在运行时才会装载</p>
<h5 id="静态库的使用">静态库的使用</h5>
<p>在<code>/home/deutschball/mydir</code>文件夹下写了三个文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 12</span><br><span class="line">-rw-r--r-- 1 root root 156 4月   1 09:44 main.cpp</span><br><span class="line">-rw-r--r-- 1 root root 985 4月   1 09:46 Point.cpp</span><br><span class="line">-rw-r--r-- 1 root root 872 4月   1 09:43 Point.h</span><br></pre></td></tr></table></figure>
<p><strong>point.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::ostream;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">double</span> x, y;</span><br><span class="line">		string name;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Point</span>(<span class="type">const</span> <span class="type">double</span> &amp;, <span class="type">const</span> <span class="type">double</span> &amp;);</span><br><span class="line">		<span class="built_in">Point</span>(<span class="type">const</span> Point &amp;);</span><br><span class="line">		<span class="built_in">Point</span>();</span><br><span class="line">		<span class="built_in">Point</span>(<span class="type">const</span> string &amp;);</span><br><span class="line">		<span class="built_in">Point</span>(<span class="type">const</span> string &amp;, <span class="type">const</span> <span class="type">double</span> &amp;, <span class="type">const</span> <span class="type">double</span> &amp;);</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp;)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp;)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">double</span> <span class="title">getX</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="type">double</span> <span class="title">getY</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">		<span class="function">string <span class="title">getName</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="type">double</span> <span class="title">getDistance</span><span class="params">(<span class="type">const</span> Point &amp;)</span></span>;</span><br><span class="line">		<span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;, <span class="type">const</span> Point &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>point.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Point.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">const</span> <span class="type">double</span> &amp;x, <span class="type">const</span> <span class="type">double</span> &amp;y) &#123;</span><br><span class="line">	name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">	<span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = p.name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;x = p.x;</span><br><span class="line">	<span class="keyword">this</span>-&gt;y = p.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>() &#123;</span><br><span class="line">	name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	x = y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">const</span> string &amp;n) &#123;</span><br><span class="line">	name = n;</span><br><span class="line">	x = y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">const</span> string &amp;name, <span class="type">const</span> <span class="type">double</span> &amp;x, <span class="type">const</span> <span class="type">double</span> &amp;y) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">	<span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::setX</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp;x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::setY</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp;y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::setName</span><span class="params">(<span class="type">const</span> string &amp;name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Point:: <span class="built_in">getX</span>()<span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Point:: <span class="built_in">getY</span>()<span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string Point:: <span class="built_in">getName</span>()<span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Point::getDistance</span><span class="params">(<span class="type">const</span> Point &amp;p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Point &amp;p) &#123;</span><br><span class="line">	os &lt;&lt; p.name &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Point.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Point <span class="title">p</span><span class="params">(<span class="string">&quot;A&quot;</span>, <span class="number">5.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/skynet/p/3372855.html">图片来自博客</a></p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/965e66764fab853fdf885313e4535d87.png" /></p>
<p>准备工作完毕,下面开始创建静态库</p>
<p>main.cpp为入口,Point.h是头文件,我们需要将Point.cpp创建为静态库</p>
<p>1.将Point.cpp编译成目标文件.o</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# g++ Point.cpp -c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 20</span><br><span class="line">-rw-r--r-- 1 root root  156 4月   1 09:44 main.cpp</span><br><span class="line">-rw-r--r-- 1 root root  985 4月   1 09:46 Point.cpp</span><br><span class="line">-rw-r--r-- 1 root root  872 4月   1 09:43 Point.h</span><br><span class="line">-rw-r--r-- 1 root root 7704 4月   1 10:01 Point.o</span><br></pre></td></tr></table></figure>
<p>2.使用<code>ar</code>工具将刚才生成的目标文件打包成.a静态库文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# ar -crv libpoint.a Point.o</span><br><span class="line">a - Point.o</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 32</span><br><span class="line">-rw-r--r-- 1 root root 8540 4月   1 10:02 libpoint.a</span><br><span class="line">-rw-r--r-- 1 root root  156 4月   1 09:44 main.cpp</span><br><span class="line">-rw-r--r-- 1 root root  985 4月   1 09:46 Point.cpp</span><br><span class="line">-rw-r--r-- 1 root root  872 4月   1 09:43 Point.h</span><br><span class="line">-rw-r--r-- 1 root root 7704 4月   1 10:01 Point.o</span><br></pre></td></tr></table></figure>
<blockquote>
<p>linux下静态库的命名规范是lib开头</p>
</blockquote>
<p>我们没有指定libpoint.a的目录,因此在当前文件夹下形成</p>
<p>到此,静态库libpoint.a建立完毕</p>
<p>下面我们在编译<code>main.cpp</code>时<strong>使用</strong>静态库</p>
<p><code>-L</code>指定静态库目录</p>
<p><code>-l</code>指定静态库和动态库的名字</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# g++ main.cpp -L ./ -l point -o main</span><br><span class="line">.out</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 52</span><br><span class="line">-rw-r--r-- 1 root root  8540 4月   1 10:02 libpoint.a</span><br><span class="line">-rw-r--r-- 1 root root   156 4月   1 09:44 main.cpp</span><br><span class="line">-rwxr-xr-x 1 root root 19824 4月   1 10:07 main.out</span><br><span class="line">-rw-r--r-- 1 root root   985 4月   1 09:46 Point.cpp</span><br><span class="line">-rw-r--r-- 1 root root   872 4月   1 09:43 Point.h</span><br><span class="line">-rw-r--r-- 1 root root  7704 4月   1 10:01 Point.o</span><br></pre></td></tr></table></figure>
<p>可执行文件main.out就生成了</p>
<blockquote>
<p>-L指定静态库目录,由于我们的静态库就在当前文件夹,于是-L ./</p>
<p>-l指定静态库名字,会自动在名字前面加上lib,在后面加上.a后缀,于是指定-l
point就找到了libpoint.a</p>
</blockquote>
<h5 id="动态库的使用">动态库的使用</h5>
<p>linux上动态库的命令规则libbalabala.so,前缀lib后缀.so</p>
<p>windows上动态库使用比较复杂,不管他了</p>
<p><strong>创建动态库</strong></p>
<p>首先生成目标文件,注意使用-fPIC命令行参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# g++ -fPIC -c Point.cpp</span><br></pre></td></tr></table></figure>
<p><code>-fPIC</code>(<strong>position independent
code</strong>)作用是创建==地址无关==代码</p>
<blockquote>
<p>与地址无关?</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/fead4e692210f2756e3b97a437a26de1.png"
alt="image-20220401115548277" />
<figcaption aria-hidden="true">image-20220401115548277</figcaption>
</figure>
<p>参考博客<a
target="_blank" rel="noopener" href="https://www.cnblogs.com/fengliu-/p/10216878.html">linux编译动态库
fPIC作用 - feng..liu - 博客园 (cnblogs.com)</a></p>
</blockquote>
<p>然后<strong>生成</strong>动态链接库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# g++ -shared -o libpoint.so Point.o</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 60</span><br><span class="line">-rwxr-xr-x 1 root root 18712 4月   1 12:12 libpoint.so</span><br><span class="line">-rw-r--r-- 1 root root   156 4月   1 09:44 main.cpp</span><br><span class="line">-rw-r--r-- 1 root root   985 4月   1 09:46 Point.cpp</span><br><span class="line">-rw-r--r-- 1 root root   872 4月   1 09:43 Point.h</span><br><span class="line">-rw-r--r-- 1 root root  7704 4月   1 12:12 Point.o</span><br><span class="line">-rw-r--r-- 1 root root 16441 4月   1 11:46 Point.s</span><br></pre></td></tr></table></figure>
<p>生成了libpoint.so</p>
<p>到此动态库创建完毕,下面<strong>使用</strong>动态库</p>
<p>尝试用使用静态库的方法使用动态库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# g++ main.cpp -L ./ -l point -o main.out</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 80</span><br><span class="line">-rwxr-xr-x 1 root root 18712 4月   1 12:12 libpoint.so</span><br><span class="line">-rw-r--r-- 1 root root   156 4月   1 09:44 main.cpp</span><br><span class="line">-rwxr-xr-x 1 root root 18064 4月   1 12:17 main.out</span><br><span class="line">-rw-r--r-- 1 root root   985 4月   1 09:46 Point.cpp</span><br><span class="line">-rw-r--r-- 1 root root   872 4月   1 09:43 Point.h</span><br><span class="line">-rw-r--r-- 1 root root  7704 4月   1 12:12 Point.o</span><br><span class="line">-rw-r--r-- 1 root root 16441 4月   1 11:46 Point.s</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# ./main.out</span><br><span class="line">./main.out: error <span class="keyword">while</span> loading shared libraries: libpoint.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>可以通过编译但是out文件执行出错,说是找不到libpoint.so</p>
<p>==那么动态库到底在哪里呢?==</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/6c1ebfe5e82c9f20cb3684876fca8ff8.png"
alt="image-20220401122038391" />
<figcaption aria-hidden="true">image-20220401122038391</figcaption>
</figure>
<p>使用第一种方法,将我们自己编写的动态库放在/usr/lib下面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">cp</span> libpoint.so /usr/lib</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# ./main.out</span><br><span class="line">A(5,4)</span><br></pre></td></tr></table></figure>
<p>发现可以正常运行了</p>
<h3 id="参考文档">参考文档</h3>
<p><a
target="_blank" rel="noopener" href="https://www.ibm.com/docs/en/zos-basic-skills?topic=zos-how-programs-are-prepared-run">How
programs are prepared to run on z/OS</a></p>
<p>参考博客</p>
<p>https://www.cnblogs.com/skynet/p/3372855.html</p>
<p>https://www.runoob.com/w3cnote/cpp-header.html</p>
<h2 id="目标文件">目标文件</h2>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220509190447711.png"
alt="image-20220509190447711" />
<figcaption aria-hidden="true">image-20220509190447711</figcaption>
</figure>
<p>又称为elf文件</p>
<p><code>executable and linkable file</code></p>
<blockquote>
<p>ELF文件有三种:</p>
<p>可重定位目标文件<code>.o</code></p>
<p>共享目标文件<code>.so</code></p>
<p>可执行目标文件<code>.out</code></p>
<p>编译器和汇编器生成可重定位目标文件和共享目标文件(<code>.o</code>),连接器生成可执行目标文件(<code>.out</code>)</p>
</blockquote>
<h2 id="可重定位目标文件.o">可重定位目标文件<code>.o</code></h2>
<p><code>.o</code>文件的结构</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220509195158089.png"
alt="image-20220509195158089" />
<figcaption aria-hidden="true">image-20220509195158089</figcaption>
</figure>
<p>一个<code>.c</code>源文件就是一个模块</p>
<p><code>.c</code>源文件使用编译器和汇编器得到<code>.o</code>可重定位目标文件</p>
<h3 id="readelf命令的使用">readelf命令的使用</h3>
<p>对于<code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n)</span>;<span class="comment">//在使用其他模块中定义的函数前,要先引用该函数,否则报编译错</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> val=sum(<span class="built_in">array</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>gcc main.c -Og -c -o main.o</code>将其编译成为可重定位目标文件<code>main.o</code></p>
<p>下面对<code>main.o</code>使用<code>readelf</code>的一系列命令进行观察</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220509193405618.png"
alt="image-20220509193405618" />
<figcaption aria-hidden="true">image-20220509193405618</figcaption>
</figure>
<h4 id="h打印elf文件头信息"><code>-h</code>打印elf文件头信息</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              REL (Relocatable file)</span></span><br><span class="line"><span class="string">  Machine:                           Advanced Micro Devices X86-64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x0</span></span><br><span class="line"><span class="string">  Start of program headers:          0 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          776 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           0 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         0</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         13</span></span><br><span class="line"><span class="string">  Section header string table index: 12</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>1.<code>Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220509194647169.png"
alt="image-20220509194647169" />
<figcaption aria-hidden="true">image-20220509194647169</figcaption>
</figure>
<p>魔数,表明本文件类型等基本信息</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 4%" />
<col style="width: 3%" />
<col style="width: 3%" />
<col style="width: 3%" />
<col style="width: 24%" />
<col style="width: 27%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th>16进制</th>
<th>7f</th>
<th>45</th>
<th>4c</th>
<th>46</th>
<th>02</th>
<th>01</th>
<th>01</th>
</tr>
</thead>
<tbody>
<tr>
<td>ascii码或意义</td>
<td>DEL符</td>
<td>'E'</td>
<td>'L'</td>
<td>'F'</td>
<td>01表示32位<br />02表示64位</td>
<td>01表示小端法<br />02表示大端法</td>
<td>ELF版本号<br />通常为1</td>
</tr>
</tbody>
</table>
<p>后面9个字节==ELF标准==中无定义,用0填充,和前面的<code>7f 45 4c 46 02 01 01</code>凑成16个字节</p>
<p>2.<code>Start of program headers:          0 (bytes into file)</code></p>
<p>程序头开始位置,对于.o文件来说,它距离可执行还缺链接这一大步,程序头对他来说没意义</p>
<p>3.<code>Start of section headers:          776 (bytes into file)</code></p>
<p>节头开始时的字节,即本文件的第776字节开始时节头</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220510184122775.png"
alt="image-20220510184122775" />
<figcaption aria-hidden="true">image-20220510184122775</figcaption>
</figure>
<p>使用010editor观察,<code>section header table</code>的起始位置是<code>0300h+8=776</code>字节</p>
<p>4.<code>Size of this header:               64 (bytes)</code></p>
<p>本头(elf文件头)的大小为64字节(16进制表示为0x40)即本elf头部分占用本文件的0到63字节,则下一部分即sections部分从0x40开始</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220510184615368.png"
alt="image-20220510184615368" />
<figcaption aria-hidden="true">image-20220510184615368</figcaption>
</figure>
<p>5.<code>Size of section headers:           64 (bytes)</code></p>
<p><code>section header table</code>中,每个<code>section</code>表项的大小</p>
<p>6.<code>Number of section headers:         13</code></p>
<p><code>section header table</code>中的表项数</p>
<p>5和6合计可以计算出<code>section header table</code>的大小为13*64=832字节</p>
<p>又知道<code>section header table</code>
的起始位置为<code>776</code>(10进制)字节处,加上该部分大小832字节可以计算得到本<code>.o</code>文件总大小为<code>1608</code></p>
<p>使用wc命令可以验证刚才计算(<code>wordcount</code>统计文件大小(字节数))</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/Linker# <span class="built_in">wc</span> main.o</span><br><span class="line">   3   13 1608 main.o</span><br></pre></td></tr></table></figure>
<p>7.<code>Section header string table index: 12</code></p>
<h4
id="s打印整个section-header-table表信息"><code>-S</code>打印整个<code>section header table</code>表信息</h4>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 25%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 7%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr>
<th>表头</th>
<th>Name</th>
<th>Type</th>
<th>Address</th>
<th>Offset</th>
<th>Size</th>
<th>EntSize</th>
<th>Flags</th>
<th>Link</th>
<th>Info</th>
<th>Align</th>
</tr>
</thead>
<tbody>
<tr>
<td>含义</td>
<td>节名</td>
<td>节类型</td>
<td></td>
<td>在本文件中的偏移量</td>
<td>节大小</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">There are 13 section headers, starting at offset 0x308:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000	</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000001e  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000250</span><br><span class="line">       0000000000000030  0000000000000018   I      10     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  00000060</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  00000068</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 5] .comment          PROGBITS         0000000000000000  00000068</span><br><span class="line">       000000000000002c  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  00000094</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .note.gnu.propert NOTE             0000000000000000  00000098</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .eh_frame         PROGBITS         0000000000000000  000000b8</span><br><span class="line">       0000000000000030  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .rela.eh_frame    RELA             0000000000000000  00000280</span><br><span class="line">       0000000000000018  0000000000000018   I      10     8     8</span><br><span class="line">  [10] .symtab           SYMTAB           0000000000000000  000000e8</span><br><span class="line">       0000000000000138  0000000000000018          11     9     8</span><br><span class="line">  [11] .strtab           STRTAB           0000000000000000  00000220</span><br><span class="line">       000000000000002d  0000000000000000           0     0     1</span><br><span class="line">  [12] .shstrtab         STRTAB           0000000000000000  00000298</span><br><span class="line">       000000000000006c  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以<code>.text</code>节为例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">     000000000000001e  0000000000000000  AX       0     0     1</span><br></pre></td></tr></table></figure>
<p><code>Offset=0x40</code>即本节在本文件中的<code>0x40</code>位置,又elfheader占用了前64个字节(0~0x3F),因此<code>.text</code>节是紧接着elfheader存放的,大小为<code>0x1e=30</code>字节</p>
<p>那么下一个节的起始位置就应该是<code>0x40+0x1e=0x5e</code></p>
<p>然而下一个节<code>.data</code>的<code>Offset=0x60</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ 3] .data             PROGBITS         0000000000000000  00000060</span><br><span class="line">     0000000000000008  0000000000000000  WA       0     0     8;Align对齐为8</span><br></pre></td></tr></table></figure>
<p>用010editor观察发现0x5e和0x5f全是0,估计是考虑了对齐的原因</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220510201200464.png"
alt="image-20220510201200464" />
<figcaption aria-hidden="true">image-20220510201200464</figcaption>
</figure>
<p>用objdump -s观察</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Contents of section .text:</span><br><span class="line"> 0000 f30f1efa 4883ec08 be020000 00488d3d  ....H........H.=</span><br><span class="line"> 0010 00000000 e8000000 004883c4 08c3      .........H....  </span><br><span class="line">Contents of section .data:</span><br><span class="line"> 0000 01000000 02000000                    ........     </span><br><span class="line"> 如果0x5e和0x5f是.data的前两个字符,合计应该是10个字节,而readelf统计的data区大小为8字节</span><br></pre></td></tr></table></figure>
<p>可以断定<code>0x5e</code>和<code>0x5f</code>的<code>0</code>是对齐方式导致的</p>
<h4 id="观察某一节">观察某一节</h4>
<p>只需要在参数上指定该节的首字符,比如要观察<code>.rel</code>开头的节</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/Linker# readelf -r main.o</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rela.text&#x27;</span> at offset 0x2f0 contains 2 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000000016  000700000002 R_X86_64_PC32     0000000000000000 .rodata - 4</span><br><span class="line">000000000020  001100000004 R_X86_64_PLT32    0000000000000000 <span class="built_in">printf</span> - 4</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rela.eh_frame&#x27;</span> at offset 0x320 contains 1 entry:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0</span><br></pre></td></tr></table></figure>
<p>观察符号表节</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/Linker# readelf -s main.o</span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains 18 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3</span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4</span><br><span class="line">     5: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 c</span><br><span class="line">     6: 0000000000000000     4 OBJECT  LOCAL  DEFAULT    4 d</span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5</span><br><span class="line">     8: 0000000000000008     4 OBJECT  LOCAL  DEFAULT    3 f.2320</span><br><span class="line">     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    7</span><br><span class="line">    10: 0000000000000000     0 SECTION LOCAL  DEFAULT    8</span><br><span class="line">    11: 0000000000000000     0 SECTION LOCAL  DEFAULT    9</span><br><span class="line">    12: 0000000000000000     0 SECTION LOCAL  DEFAULT    6</span><br><span class="line">    13: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 a</span><br><span class="line">    14: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM b</span><br><span class="line">    15: 0000000000000000    43 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    16: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    17: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND <span class="built_in">printf</span></span><br></pre></td></tr></table></figure>
<h3 id="可重定位目标文件的常用节">可重定位目标文件的常用节</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> c=<span class="number">20</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> d;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> e=<span class="number">30</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> f=<span class="number">40</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="text"><code>.text</code></h4>
<p>存放指令</p>
<p>使用<code>objdump -d main.o</code>可以观察<code>.text</code>的反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">main.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:	f3 0f 1e fa          	endbr64 </span><br><span class="line">   4:	55                   	push   %rbp</span><br><span class="line">   5:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">   8:	48 83 ec 10          	sub    $0x10,%rsp</span><br><span class="line">   c:	c7 45 fc 1e 00 00 00 	movl   $0x1e,-0x4(%rbp)</span><br><span class="line">  13:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 1a &lt;main+0x1a&gt;</span><br><span class="line">  1a:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  1f:	e8 00 00 00 00       	callq  24 &lt;main+0x24&gt;</span><br><span class="line">  24:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  29:	c9                   	leaveq </span><br><span class="line">  2a:	c3                   	retq   </span><br></pre></td></tr></table></figure>
<h4 id="data"><code>.data</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">     000000000000001e  0000000000000000  AX       0     0     1</span><br></pre></td></tr></table></figure>
<p>存放已经初始化(且不为零)的全局变量或者局部变量</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220510203006548.png"
alt="image-20220510203006548" />
<figcaption aria-hidden="true">image-20220510203006548</figcaption>
</figure>
<p>如图被data节表管理的data节中只有10,20,40这三个已经赋值的全局或者静态变量</p>
<h4 id="bss"><code>.bss</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ 4] .bss              NOBITS           0000000000000000  00000068</span><br><span class="line">     0000000000000000  0000000000000000  WA       0     0     1</span><br></pre></td></tr></table></figure>
<p>该部分只有一个节表表项,在节中实际不存在,只是起一个占位符的作用</p>
<p>未初始化的静态变量或者初始化为<code>0</code>的全局或静态变量,当程序运行时才会给<code>bss</code>变量在内存分配空间并赋值0</p>
<p><code>COMMON</code>存放未初始化的全局变量,这和链接有关</p>
<h4 id="rodata"><code>.rodata</code></h4>
<p><code>printf</code>要打印的字符串字面值就存放在该区域</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220510203554082.png"
alt="image-20220510203554082" />
<figcaption aria-hidden="true">image-20220510203554082</figcaption>
</figure>
<p><code>.rel</code>开头的节及其他节</p>
<p><code>.rel</code>的节和重定位有关</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220510203810791.png"
alt="image-20220510203810791" />
<figcaption aria-hidden="true">image-20220510203810791</figcaption>
</figure>
<p>链接依赖于符号<code>.symtab</code>节管理符号</p>
<h3 id="symtab节"><code>.symtab</code>节</h3>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> c=sum(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sum.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只将<code>main.c</code>编译成<code>main.o</code>可重定位目标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -Og -c -o main.o</span><br></pre></td></tr></table></figure>
<p>然后<code>readelf -s</code>观察符号表节</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/Linker# readelf -s main.o</span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains 12 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 </span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     9: 0000000000000000    33 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 2%" />
<col style="width: 2%" />
<col style="width: 22%" />
<col style="width: 2%" />
<col style="width: 11%" />
<col style="width: 10%" />
<col style="width: 2%" />
<col style="width: 25%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th>项目</th>
<th>Num</th>
<th>Value</th>
<th>Size</th>
<th>Type</th>
<th>Bind</th>
<th>Vis</th>
<th>Ndx</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>意义</td>
<td>编号</td>
<td>符号在其所在节中,举例节首地址的偏移量</td>
<td>大小</td>
<td>类型(函数/对象等等)</td>
<td>属性,本地还是全局</td>
<td></td>
<td>section节索引,在section header table中确定</td>
<td>名称,这个字符串名称放在.strtab节中</td>
</tr>
</tbody>
</table>
<p><code>Ndx</code>中的值是该符号在本文件中的哪一节,<code>UND</code>则为本模块中引用的其他模块的符号</p>
<h3 id="符号和符号表">符号和符号表</h3>
<p><code>.o</code>目标模块都有一共符号表,其中包含该目标模块中定义和引用的符号信息</p>
<p>对于连接器来说有三种符号</p>
<p>1.本模块定义的全局符号,对其他模块可见</p>
<p>2.其他模块定义的全局符号,对本模块可见</p>
<p>3.本模块定义的静态符号,只对本模块可见</p>
<blockquote>
<p>static的作用类似于java中的private或者protected,而全局变量则相当于public修饰</p>
</blockquote>
<p>函数栈中的局部变量不会出现在符号表中,其符号由堆栈维护,或者说不需要符号.</p>
<p>每个符号都属于一个节</p>
<p>比如函数就属于text节,已初始化且不为0的全局变量属于.data节,未初始化的静态变量属于.bss节等等</p>
<blockquote>
<p><strong>只有.o可重定位目标模块中存在的</strong>,并且节头表.symtab中没有条目的三个伪节:</p>
<p>.ABS 不该被重定位的符号</p>
<p>.UNDEF 本模块中只有引用没有定义的符号</p>
<p><strong>.COMMON 未初始化的全局变量</strong></p>
</blockquote>
<blockquote>
<p>注意存放全局变量时,放在.COMMON和.bss的区别,static变量不会涉及链接问题,但是全局变量会</p>
<p>将未初始化的全局变量放到.COMMON,将已初始化为0的全局变量放到.bss,将已初始化不为零的全局变量放在data</p>
<p>这样做的目的和链接时符号的强弱性质有关,这都是后话了</p>
</blockquote>
<p>链接形成可执行目标文件之后这三个伪节就不复存在了</p>
<h3 id="符号解析">符号解析</h3>
<p>多个目标文件或者库还有命令行参数构成链接器的<strong>输入</strong></p>
<p>连接器在链接时,会给每个引用在其<strong>输入</strong>的一个模块的符号表中找到与该引用对应的符号定义</p>
<p>关键在于全局符号的引用解析</p>
<p>如果<strong>编译器</strong>遇到了一个引用并且在本模块中没有找到定义,则<strong>编译器</strong>会假设其定义在其他模块中,生成一共链接器符号表条目</p>
<p>如果链接器在所有输入的目标模块中都没有找到该引用的定义则报错</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;<span class="comment">//func只是一个引用,在本模块中没有定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   func();</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链接报错:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ghX.o:main.c:(.text+0xe): undefined reference to `func<span class="string">&#x27;</span></span><br><span class="line"><span class="string">collect2.exe: error: ld returned 1 exit status</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   func();</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;&#125;<span class="comment">//func在本模块中有定义</span></span><br></pre></td></tr></table></figure>
<p>此时链接不会发生报错</p>
</blockquote>
<p>如果链接器找到了多个定义,则按照下面三条规则处理多重定义符号名</p>
<blockquote>
<p>强符号:函数,已初始化的全局变量(data或者bss节)</p>
<p>弱符号:未初始化的全局变量,放在COMMON伪节</p>
<p><code>int a;</code>这就是一个弱符号</p>
<p><code>int a=0;</code>这就是一个强符号</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220520170252584.png"
alt="image-20220520170252584" />
<figcaption aria-hidden="true">image-20220520170252584</figcaption>
</figure>
<p>因此将全局变量按照是否初始化,被分到common还是data或者bss节</p>
<p>common中符号的在链接时会被作为弱符号</p>
<h3 id="重定位">重定位</h3>
<p>重定位的两个步骤</p>
<h4 id="重定位节">1.重定位节</h4>
<p>将所有输入的目标文件合并成一个文件,由于每个目标文件都有.data等节,因此需要合并每个目标文件中的相同节,形成一个文件</p>
<p>如此,所有的符号定义相对于该文件都有一个确定的偏移量位置,此时就可以给每个符号一个虚拟内存地址了</p>
<h4
id="重定位节中的符号引用"><strong>2.</strong>重定位节中的符号引用</h4>
<p>在1中我们已经给每个符号定义确定了一个绝对的虚拟内存地址,但是怎么让该符号的引用也知道应该引用这个绝对的虚拟内存地址?</p>
<p>本步骤就是让所有符号引用都有着落</p>
<blockquote>
<p>举个例子,<code>main.c</code>是这样写的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;<span class="comment">//声明一个函数符号引用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> 	func();</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让编译停止在链接前,此时<code>func</code>函数对于<code>main</code>模块来说还只是一个符号引用,</p>
<p>对<code>main.o</code>反汇编之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\desktop\os\Linker&gt; gcc main.c -O0 -c -o main.o</span><br><span class="line">PS C:\Users\86135\desktop\os\Linker&gt; objdump main.o -d </span><br><span class="line"></span><br><span class="line">main.o:     file format pe-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">0:   55                      push   %rbp</span><br><span class="line">1:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">4:   48 83 ec 20             sub    $0x20,%rsp</span><br><span class="line">8:   e8 00 00 00 00          callq  d &lt;main+0xd&gt;</span><br><span class="line">d:   e8 00 00 00 00          callq  12 &lt;main+0x12&gt;</span><br><span class="line">12:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">17:   48 83 c4 20             add    $0x20,%rsp</span><br><span class="line">1b:   5d                      pop    %rbp</span><br><span class="line">1c:   c3                      retq</span><br><span class="line">1d:   90                      nop</span><br><span class="line">1e:   90                      nop</span><br><span class="line">1f:   90                      nop</span><br></pre></td></tr></table></figure>
<p>发现反汇编的代码中并没有出现func函数的影子,并且有两条很诡异的call指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8:   e8 00 00 00 00          callq  d &lt;main+0xd&gt;</span><br><span class="line">d:   e8 00 00 00 00          callq  12 &lt;main+0x12&gt;</span><br></pre></td></tr></table></figure>
<p>明明就在本函数之中,却还要<code>call</code>一下</p>
<p>这样写的原因是,目前本模块并不知道<code>func</code>的地址,因此指令中根本没法写<code>call</code>谁<code>e8 00 00 00 00</code>这里后面8个0就是未知地址,<code>e8</code>是只是<code>call</code>指令的操作码</p>
<p>这里写了两个不明所以的<code>call</code>指令,原因是,上面这个<code>8:   e8 00 00 00 00          callq  d &lt;main+0xd&gt;</code>在链接后调用的是<code>__main</code>函数,作用是进行一些初始化</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0000000000401650 &lt;__main&gt;:</span><br><span class="line">  401650:	8b 05 da 59 00 00    	mov    0x59da(%rip),%eax        # 407030 &lt;initialized&gt;</span><br><span class="line">  401656:	85 c0                	test   %eax,%eax</span><br><span class="line">  401658:	74 06                	je     401660 &lt;__main+0x10&gt;</span><br><span class="line">  40165a:	c3                   	retq   </span><br><span class="line">  40165b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)</span><br><span class="line">  401660:	c7 05 c6 59 00 00 01 	movl   $0x1,0x59c6(%rip)        # 407030 &lt;initialized&gt;</span><br><span class="line">  401667:	00 00 00 </span><br><span class="line">  40166a:	e9 71 ff ff ff       	jmpq   4015e0 &lt;__do_global_ctors&gt;</span><br><span class="line">  40166f:	90                   	nop</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面这个才是<code>call func</code>,调用<code>func</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000401560</span> &lt;main&gt;:</span><br><span class="line">  <span class="number">401560</span>:	<span class="number">55</span>                   	push   %rbp</span><br><span class="line">  <span class="number">401561</span>:	<span class="number">48</span> <span class="number">89</span> e5             	mov    %rsp,%rbp</span><br><span class="line">  <span class="number">401564</span>:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">20</span>          	sub    $<span class="number">0x20</span>,%rsp</span><br><span class="line">  <span class="number">401568</span>:	e8 e3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">401650</span> &lt;__main&gt;</span><br><span class="line">  <span class="number">40156</span>d:	e8 <span class="number">0</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">401580</span> &lt;func&gt;</span><br><span class="line">  <span class="number">401572</span>:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">401577</span>:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">20</span>          	add    $<span class="number">0x20</span>,%rsp</span><br><span class="line">  <span class="number">40157b</span>:	<span class="number">5</span>d                   	pop    %rbp</span><br><span class="line">  <span class="number">40157</span>c:	c3                   	retq   </span><br><span class="line">  <span class="number">40157</span>d:	<span class="number">90</span>                   	nop</span><br><span class="line">  <span class="number">40157</span>e:	<span class="number">90</span>                   	nop</span><br><span class="line">  <span class="number">40157f</span>:	<span class="number">90</span>                   	nop</span><br></pre></td></tr></table></figure>
</blockquote>
<p>链接器依赖可<strong>重定位模块</strong>(<code>.o</code>)中的<strong>重定位条目</strong>实现该步骤</p>
<h5 id="重定位条目">重定位条目</h5>
<p>汇编器在遇到一个本模块中没有定义的符号引用时,就会为该符号引用创建一个重定位条目</p>
<p>代码的重定位条目存放在<code>.rel.text</code>节中</p>
<p><strong>已初始化</strong>数据的重定位条目存放在<code>.rel.data</code>节中</p>
<p>重定位条目结构定义:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525095006902.png"
alt="image-20220525095006902" />
<figcaption aria-hidden="true">image-20220525095006902</figcaption>
</figure>
<blockquote>
<p>offset:引用的节偏移量</p>
<p>type:重定位类型(着重关心其中的两种)</p>
<p>symbol:符号表的下标</p>
<p>addend:修正参数</p>
</blockquote>
<p><code>R_X86_64_PC32</code>重定位一个使用32位PC相对地址的引用</p>
<blockquote>
<p>PC相对地址:某地址与当前PC值的距离</p>
</blockquote>
<p>32位<strong>相对地址</strong>加上当前PC值得到有效地址</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0000000000001139 &lt;func&gt;:</span><br><span class="line">    1139:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">    113d:	48 8d 3d c0 0e 00 00 	lea    0xec0(%rip),%rdi        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">    1144:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    1149:	e8 e2 fe ff ff       	call   1030 &lt;printf@plt&gt;</span><br><span class="line">    114e:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">    1152:	c3                   	ret    </span><br><span class="line">    </span><br><span class="line">0000000000001153 &lt;main&gt;:</span><br><span class="line">    1153:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">    1157:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    115c:	e8 d8 ff ff ff       	call   1139 &lt;func&gt;</span><br><span class="line">    1161:	b8 00 00 00 00       	mov    $0x0,%eax</span><br></pre></td></tr></table></figure>
<p>比如当执行115c处的<code>115c: e8 d8 ff ff ff          call   1139 &lt;func&gt;</code>时</p>
<p>此时程序计数器指向下一条指令<code>PC=0x1161</code></p>
<p>操作码<code>e8</code>表示call</p>
<p>相对地址<code>d8 ff ff ff</code>按照小端模式存放,写成16进制数应该为<code>0xff ff ff d8=-40=-0x28</code></p>
<p>PC加上相对地址即<code>0x1161-0x28=0x1139</code>恰好为<code>0000000000001139 &lt;func&gt;:</code>的首条指令的地址</p>
</blockquote>
<p><code>R_x86_64_32</code>重定位一个使用32位<strong>绝对地址</strong>的引用</p>
<p>绝对寻址,直接在指令编码中给出有效地址</p>
<h5 id="重定位算法">重定位算法</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220527115221609.png"
alt="image-20220527115221609" />
<figcaption aria-hidden="true">image-20220527115221609</figcaption>
</figure>
<p>重定位算法也是比较容易理解的,</p>
<p>说了一个啥事呢?</p>
<p>现在各个模块的text合并成一个text节,所有符号都有一个重定位条目,记录了自己在本节中的偏移量(相对于节基地址的位置)</p>
<p>然后本节中的一个符号想要找另一个符号的位置</p>
<p>这就相当鱼一个数组arr中,要计算<code>arr[20]</code>和<code>arr[200]</code>的举例,直接用200-20=180,这里下标就是数组元素相对于数组基地址的偏移量</p>
<p>数组就相当于这一整个text节,元素相当于text节中的一个符号,下标相当于该符号相对于text</p>
<p>所有引用符号重定位之后,此时所有引用,所有符号
都有址可循,链接完全完成,形成可执行目标文件.out</p>
<h2 id="可执行目标文件.out">可执行目标文件<code>.out</code></h2>
<p>可执行目标文件通常以<code>.out</code>作为拓展名,或者根本就不写拓展名,反正linux上对拓展名没有windows上那么严格</p>
<h3 id="文件视图">文件视图</h3>
<p>完全链接之后,所有的目标模块都融洽地形成一个可执行目标文件,原来每个目标模块中都有<code>text,data</code>等节,在可执行目标文件中,每种节有且只有一个</p>
<p>可执行目标文件的格式:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525095816498.png"
alt="image-20220525095816498" />
<figcaption aria-hidden="true">image-20220525095816498</figcaption>
</figure>
<p>ELF头从0开始,这并不意味着ELF在真正执行的时候,起运行地址空间从0开始.</p>
<p><code>.init</code>节是一个小型的代码段,里面就一个小函数<code>_init</code>作用是进行一些初始化,具体初始化了啥我不知道,也不是学这一部分所应关心的重点</p>
<p>用010editor elf模板观察一个可执行目标文件</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525143339664.png"
alt="image-20220525143339664" />
<figcaption aria-hidden="true">image-20220525143339664</figcaption>
</figure>
<p><code>elf_header</code>的作用和<code>.o</code>可重定位目标模块中的类似,作用是声明ELF魔数,规定后续各部分的偏移量和大小</p>
<h3 id="program_header程序头"><code>program_header</code>程序头</h3>
<p>作用是规定</p>
<p>1.各节在本可执行目标文件中的偏移,</p>
<p>2.虚拟内存地址,</p>
<p>3.对齐要求,</p>
<p>4.本目标文件中的段大小,</p>
<p>5.实际执行时内存中的段大小,</p>
<p>6.运行时的读写执行权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─$ objdump -h prog</span><br><span class="line"></span><br><span class="line">prog:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .interp       0000001c  0000000000000318  0000000000000318  00000318  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  1 .note.gnu.property 00000020  0000000000000338  0000000000000338  00000338  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .note.gnu.build-id 00000024  0000000000000358  0000000000000358  00000358  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .note.ABI-tag 00000020  000000000000037c  000000000000037c  0000037c  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .gnu.hash     00000024  00000000000003a0  00000000000003a0  000003a0  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  5 .dynsym       00000090  00000000000003c8  00000000000003c8  000003c8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  6 .dynstr       0000007d  0000000000000458  0000000000000458  00000458  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  7 .gnu.version  0000000c  00000000000004d6  00000000000004d6  000004d6  2**1</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  8 .gnu.version_r 00000020  00000000000004e8  00000000000004e8  000004e8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  9 .rela.dyn     000000c0  0000000000000508  0000000000000508  00000508  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"> 10 .init         00000017  0000000000001000  0000000000001000  00001000  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 11 .plt          00000010  0000000000001020  0000000000001020  00001020  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 12 .plt.got      00000008  0000000000001030  0000000000001030  00001030  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 13 .text         00000171  0000000000001040  0000000000001040  00001040  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 14 .fini         00000009  00000000000011b4  00000000000011b4  000011b4  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 15 .rodata       00000004  0000000000002000  0000000000002000  00002000  2**2</span><br><span class="line">0000000000003e20  00002e20  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 20 .dynamic      000001b0  0000000000003e28  0000000000003e28  00002e28  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 21 .got          00000028  0000000000003fd8  0000000000003fd8  00002fd8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 22 .got.plt      00000018  0000000000004000  0000000000004000  00003000  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 23 .data         00000010  0000000000004018  0000000000004018  00003018  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 24 .bss          00000008  0000000000004028  0000000000004028  00003028  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line"> 25 .comment      0000001f  0000000000000000  0000000000000000  00003028  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure>
<h3 id="运行视图">运行视图</h3>
<p>在<code>shell</code>上,<code>./prog</code>命令即可加载并执行可执行目标文件<code>prog</code></p>
<p>实际上是<code>shell</code>调用<code>execve</code>函数来调用加载器,加载器是操作系统的组成部分.</p>
<p>加载器把<code>prog</code>的所有代码和数据从磁盘拷贝到内存,然后跳转到程序的第一条指令,然后控制转移到该程序,程序执行.这个过程叫做加载</p>
<p>至于加载器究竟干了啥,我不知道,现在也不想知道</p>
<p>加载完成后,程序在内存中的映像图是这样的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525145002132.png"
alt="image-20220525145002132" />
<figcaption aria-hidden="true">image-20220525145002132</figcaption>
</figure>
<blockquote>
<p>其中忽略了一些无关紧要的信息,比如</p>
<p>1.各段都有自己的对齐要求,但是图上都画的紧挨着.实际上有可能"相邻"两段之间有一些没有意义的空隙,当程序错误执行到这些空当时就会触发段错误</p>
<p>2.没有表现出地址空间布局随机化.ASLR的作用是对抗pwn攻击的,在做一些简单的pwn题目时,一个变量,一个函数的地址都是确定的,使用ida打开看到了,那么就可以确定下一次运行时那个函数,那个变量还是在那个位置.而开启ASLR之后每次运行,同一个变量会有不同的地址.</p>
<blockquote>
<p>但是仍然可以确定的是,两个变量,变量和函数,函数之间的相对位置都是不变的,就相当于把整个村从城南搬到城北,李四还是知道张三住哪里,走多远到张三家</p>
</blockquote>
</blockquote>
<p>运行时视图没有"<code>section</code>"这种说法了,类似的概念叫"<code>segment</code>"</p>
<p>比如只读代码段(由原来的<code>.init,.text,.rodata</code>节组成)</p>
<p>性质类似的节(比如只读数据和代码都不可执行,合并到一个段</p>
<p>段也有类似于节的属性,比如读写执行权限</p>
<p>如果企图在只读代码段修改或写入东西</p>
<p>或者在开启了NX保护(堆栈不可执行)之后在堆栈上写<code>shellcode</code>并<code>ret2shellcode</code></p>
<p>都会引起段错误</p>
<h2 id="库文件.a-.so">库文件<code>.a &amp; .so</code></h2>
<p>CSAPP中将静态库放在静态链接讲完之后,动态链接开始讲之前.</p>
<p>但实际上讲动态链接时并没有涉及到静态库.</p>
<p>现在改变一下思路把静态库和动态库这两种库文件放在一起阐述</p>
<h3 id="源头之争">源头之"争"</h3>
<blockquote>
<p><strong>去年的历史遗留问题</strong></p>
<p><strong>1.</strong>在大一学习c语言时我们就知道,如果要使用<code>printf</code>和<code>scanf</code>函数,必须<code>#include &lt;stdio.h&gt;</code>,</p>
<p>如果使用<code>srand(time(0))</code>,其中的<code>time(0)</code>要求<code>#include &lt;time.h&gt;</code></p>
<p>然而实际上去观察一下<code>&lt;stdio.h&gt;</code>这种.h头文件,其中并没有函数的实现,只有函数的接口.那<code>#include &lt;xxx.h&gt;</code>的目的是啥呢?</p>
<p><strong>2.</strong>在大二上学习C++时,函数,类的定义和声明分别写在源还是头文件中,给我们带来了巨大麻烦</p>
<p>头文件既然妹有写实现,源文件中声明和实现相当于都有,那么头文件还有存在的意义吗?难道是只写接口看起来干净整洁好看吗?</p>
<p>非也</p>
</blockquote>
<p><strong>头文件提供一个引用</strong></p>
<p>啥意思呢?下面以一个例子说明,在这个例子中虽然不涉及头文件,但是实际上包括了头文件要做的事</p>
<blockquote>
<p>注意一些文字游戏</p>
<p>"定义"和"实现"是一个说法,都是带函数体的函数,比如<code>int func()&#123;/*花括号里是函数体*/&#125;</code></p>
<p>"声明"和"接口"是一个说法,都是不带函数体,只有一个函数声明,比如<code>int func();//分号结尾,妹有函数体</code></p>
</blockquote>
<p>考虑这么一个程序<code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>main.c</code>中,<code>func</code>函数既没有定义也没有实现,直接在<code>main</code>函数中调用</p>
<p>现在我们把编译和链接分别执行</p>
<h4 id="编译阶段">编译阶段</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc main.c -c -o main</span><br><span class="line">main.c: In <span class="keyword">function</span> ‘main’:</span><br><span class="line">main.c:3:11: warning: implicit declaration of <span class="keyword">function</span> ‘func’ [-Wimplicit-function-declaration]</span><br><span class="line">    3 |     int a=func();</span><br><span class="line">      |           ^~~~</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里报了一个警告,意思是<code>func</code>没有直接言明</p>
<blockquote>
<p>编译器很懵逼,func是个啥啊,你妹有定义实现也就罢了,竟然连声明都不打招呼,</p>
<p>上来就用,玩意func有参数,万一func根本就不是函数,是个变量咋整?func有没有返回值啊&gt;_&lt;,返回啥类型值啊?</p>
<p>我编译器只能联系上下文,按照func是一个返回int的无参函数来编译了</p>
<p>链接器你就自求多福吧,我摆烂了</p>
</blockquote>
<blockquote>
<p>那么怎么才能让编译器知道关于func的信息呢?在使用之前声明一下这个函数接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时<strong>编译</strong>就妹有警告了,这意味着编译器此时已经非常自信地认为自己的工作很perfect</p>
</blockquote>
<h4 id="链接阶段">链接阶段</h4>
<p>链接的作用是给每个引用都找到实现,让所有悬而未决的议案落地</p>
<p>在同文件夹下有一个<code>func.c</code>,其中有<code>func()</code>函数的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此时<code>main.c</code>这样写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>main.c</code>和<code>func.c</code>都已经正确经过编译,生成了可重定位目标文件<code>main.o</code>和<code>func.o</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc func.c -c -o func.o</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc main.c -c -o main.o</span><br></pre></td></tr></table></figure>
<p>根据前面章节的学习,<code>main.o</code>中有一个func函数的引用悬而未决,如果要形成<code>main.out</code>,需要让这个引用落地</p>
<p>如果直接写<code>gcc main.o -o main</code>不用想都知道会报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc main.o -o main</span><br><span class="line">/usr/bin/ld: main.o: <span class="keyword">in</span> <span class="keyword">function</span> `main<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">main.c:(.text+0xe): undefined reference to `func&#x27;</span></span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure>
<p>链接器报错:func引用未定义</p>
<blockquote>
<p>考虑如下场景</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525165401741.png"
alt="image-20220525165401741" />
<figcaption aria-hidden="true">image-20220525165401741</figcaption>
</figure>
<p>这里printf未定义的报错是不是和刚才func妹有定义的报错是同一种错误?</p>
</blockquote>
<p>给gcc怎样传递命令行参数,才能不让链接器报错呢?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc main.o func.o -o main</span><br></pre></td></tr></table></figure>
<p>这句话的意思是,将<code>main.o</code>和<code>func.o</code>进行链接,(如果妹有链接错误的话)形成可执行目标文件<code>main</code></p>
<h4 id="整个过程">整个过程</h4>
<p>现在考虑编译到链接整个过程,怎样才能不报错不报警告?</p>
<p>1.编译时引用要提前声明一下</p>
<p>2.链接时要包含所有引用实现的模块</p>
<h4 id="回到源头之争">回到源头之"争"</h4>
<p><code>#include &lt;stdio.h&gt;</code>是一条宏定义,在预编译阶段会被展开,也就是将<code>stdio.h</code>中的所有东西都加在<code>main.c</code>的一开始,形成<code>main.i</code></p>
<p><code>main.i</code>实际上还是<code>ASCII</code>文本文档,和<code>main.c</code>几乎妹有区别</p>
<p>还记得<code>&lt;stdio.h&gt;</code>中都是写的啥吗?函数声明</p>
<p>那么<code>main.i</code>是个啥?</p>
<p>一伙子函数引用+我们自己写的<code>main</code>函数,</p>
<p>which调用了<code>printf</code>,</p>
<p>which在前面一伙子函数引用中有一席之地.</p>
<p>可见<code>&lt;stdio.h&gt;</code>帮我们完成了声明函数引用的工作.</p>
<blockquote>
<p>为什么要用一个头文件来做这个工作?我们程序员是傻吗?自己声明一个printf的引用不行吗?</p>
<p>其一,printf是个变参函数,这一下子就限制了很多人写函数引用,变参函数的函数接口长啥样啊?我也不知道</p>
<p>其二,printf的返回值是啥,<code>int?long?unsigned?size_t?</code>调用约定是啥?<code>__cdecl?__fastcall?</code>即使我记性好,这些都记住了,那么<code>scanf,sprintf,fgetc,fwrite....</code>等等函数的接口又长啥样?难道每次调用一个库函数都要去查手册吗?手册得多厚啊,新华字典见了都怕</p>
</blockquote>
<p>在预编译阶段过后,宏定义被展开,此时头文件就完成了自己的使命</p>
<p>奇怪的是,即使我们用到了<code>glibc</code>库中的函数<code>printf</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Helloworld&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在编译链接时,也没有指定<code>printf</code>在哪里实现啊?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc main.c -o main</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# ./main</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure>
<p>按照我们在"链接阶段"举的例子,这里就应该链接报错<code>"undefined reference : 'printf' "</code></p>
<p>而实际上程序链接地好好的</p>
<p>这是因为,<code>printf</code>
的实现在<code>glibc.so</code>动态库中,而该动态库会被链接器自动且隐式地链接</p>
<p><code>printf</code>实现所在的源文件去哪了?</p>
<p>源文件被编译成<code>glibc.so</code>动态库了,从一个ASCII文档变成二进制文件了,源文件的灵魂已经装进<code>glibc.so</code></p>
<p>如果想要看<code>printf</code>源文件怎么实现的,去哪里找呢?</p>
<p>谷歌或者百度<code>glibc-2.9</code>或者其他版本,去官网下载吧</p>
<h4 id="明确分工">明确分工</h4>
<p>在大二上学面向对象C++的时候,曾经费尽心思记什么东西应该写到头文件里,什么东西应该写到源文件里(到考试,到现在也没记住)</p>
<p>其实学了链接时符号解析规则,这些问题根本就不是问题</p>
<p>刚才已经举例说明了,头文件的作用就是声明一下函数接口,起引用作用</p>
<h5 id="头文件可以写函数实现吗">头文件可以写函数实现吗</h5>
<p>现在基于对链接的了解,考虑<strong>头文件里可以写函数实现吗</strong>?</p>
<blockquote>
<p>貌似可以,并且可以说出歪歪理儿,举一个有模有样的例子:</p>
<p><code>func.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样<code>gcc main.c -o main</code>不会报错,并且连链接时指定可重定位目标文件或者库文件都省去了,岂不美哉?</p>
<p>当然不会报错,这样写<code>func.h</code>改名为<code>func.balabala</code>都可以,<code>.h</code>后缀妹有意义</p>
<p>实际上相当于写了</p>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这里不报错的原因是,整个编译链接就涉及到两个模块,并且只有<code>main</code>引用了<code>func</code>,这关系简单明了</p>
<p>可如果这样写呢?</p>
<p><code>func.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func1.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func2.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>*func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序入口这样写:</p>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func1();		<span class="comment">//要调用func1必然要链接func1.o目标模块</span></span><br><span class="line">    <span class="type">int</span> b=func2();		<span class="comment">//要调用func2必然要链接func2.o目标模块</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525202607308.png"
alt="image-20220525202607308" />
<figcaption aria-hidden="true">image-20220525202607308</figcaption>
</figure>
<blockquote>
<p>main中相当于有两个func的定义</p>
</blockquote>
<p>使用<code>gcc main.c func1.c func2.c -o prog</code>企图编译链接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc main.c func1.c func2.c -o prog</span><br><span class="line">/usr/bin/ld: /tmp/ccb95Wtp.o: <span class="keyword">in</span> <span class="keyword">function</span> `func<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">func2.c:(.text+0x0): multiple definition of `func&#x27;</span>; /tmp/ccAEawPN.o:func1.c:(.text+0x0): first defined here</span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure>
<p>发现编译是可以通过的,报错全是链接错,<code>func</code>有多重定义</p>
<p>为啥会报错呢?</p>
<p>第一次预见<code>func</code>的定义是在<code>func1.c</code>中,竟然在<code>func2.c</code>中又预见了<code>func</code>的定义</p>
<p>实际上相当于写了这么一个程序:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;					<span class="comment">//func第一处定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*func();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;					<span class="comment">//func第二处定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>*func();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func1();	</span><br><span class="line">    <span class="type">int</span> b=func2();	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func</code>被定义了两次,函数名字和参数表一模一样,不是重载也不是重写,必然会报错</p>
<p>用前面章节的知识解释,函数定义是硬符号,符号解析时硬符号最多有一个,如果链接器发现有两个以上的同名硬符号则报错</p>
<blockquote>
<p>有人在往linux内核里添加系统调用的时候就在<code>syscalls.h</code>里面写了内核函数的实现,我不说是谁</p>
</blockquote>
<p>那么为了防止上述多重定义的情况发生,应该怎么办呢?</p>
<p>不允许多重定义,还能不允许多重引用吗?</p>
<p>头文件里只写函数声明或者说函数接口,源文件里写函数实现呗</p>
<h6 id="正确写法">正确写法</h6>
<h6 id="main.c"><code>main.c</code></h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func1.h&quot;</span>		<span class="comment">//main中只引用了func1和func2,妹有引用func,因此不用#include &lt;func.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func2.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func1();</span><br><span class="line">    <span class="type">int</span> b=func2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="func.h-func.c"><code>func.h &amp; func.c</code></h6>
<p><code>func.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FUNC		<span class="comment">//如果妹有定义FUNC符号才拓展该宏,条件展开发生在预编译时期</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNC</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<p><code>func.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span>	<span class="comment">//引用func.h的作用是,在预编译阶段把int func()搞进来,</span></span></span><br><span class="line">					<span class="comment">//实际上由于只有一个函数,并且接口简单,不使用头文件都可以.规范期间还是使用头文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="func1.h-func1.c"><code>func1.h &amp; func1.c</code></h6>
<p><code>func1.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FUNC1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNC1</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>;		<span class="comment">//虽然func1中会引用func,但头文件中不写include &lt;func.h&gt;,因为头文件就只是提供该模块中函数的引用,</span></span><br><span class="line">						<span class="comment">//具体函数实现中引用了什么其他家的花草,头文件并不关心</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<p><code>func1.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func1.h&quot;</span>					<span class="comment">//这里两个头的include先后顺序无所谓,反正都是引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="func2.h-func2.c"><code>func2.h &amp; func2.c</code></h6>
<p><code>func2.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FUNC2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNC2</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<p><code>func2.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func2.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>*func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="通过链接">通过链接</h6>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc func1.c func.c main.c func2.c -o prog				<span class="comment">#这里源文件的先后顺序妹有区别,但是一定要写全需要的源文件</span></span><br><span class="line">															<span class="comment">#编译链接成功</span></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# ./prog													<span class="comment">#运行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="头文件可以写全局变量吗">头文件可以写全局变量吗</h5>
<p>还是以<code>geometry</code>的例子(见下文静态库-&gt;使用静态库),假如在<code>geometry.h</code>中,我们定义了一个全局变量<code>PI</code></p>
<p><code>geometry.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GEOMETRY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GEOMETRY</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="number">3.1415926</span>;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>我们的目的是,只要引用了该头文件就可以直接使用PI,比如</p>
<p>在<code>main.c</code>中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="type">int</span> pi=PI;	<span class="comment">//试图阔的PI的拷贝</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果却报告链接错误了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─$ ./makedynamiclib.sh</span><br><span class="line">/usr/bin/ld: /tmp/cc9eI8oy.o:(.rodata+0x0): multiple definition of `PI<span class="string">&#x27;; /tmp/cci0ubCp.o:(.rodata+0x0): first defined here</span></span><br><span class="line"><span class="string">collect2: error: ld returned 1 exit status</span></span><br><span class="line"><span class="string">/usr/bin/ld: cannot find ./libgeometry.so: No such file or directory</span></span><br><span class="line"><span class="string">collect2: error: ld returned 1 exit status</span></span><br><span class="line"><span class="string">./makedynamiclib.sh: line 5: ./prog: No such file or directory</span></span><br></pre></td></tr></table></figure>
<p>意思是<code>PI</code>有多重定义了</p>
<p>为啥会报链接错:有多重定义?</p>
<p><code>line.c</code>和<code>point.c</code>,<code>main.c</code>中都有<code>#include "geometry.h"</code></p>
<p>前面我们也分析了头文件的作用,头文件中的东西在预编译宏展开之后会直接加到源文件前面.</p>
<p>那么预编译之后,<code>line.i,point.i,main.i</code>中各有一次<code>const double PI=3.1415926</code>的定义,这是硬符号,然后三个文件都被编译成可重定位目标文件.o准备链接</p>
<p>链接时同名的全局符号只允许有至多一个硬符号,而对于<code>PI</code>符号,链接器可以发现两个(找到第二个就报错了,不管第三个了)因此报链接错,多重定义</p>
<blockquote>
<p>可是我们头文件中宏定义是条件展开的啊,已经定义过就不会被定义了啊?</p>
<p>考虑宏定义的展开是在预编译阶段,远没到链接,等到链接的时候,早就都展开了
.条件展开的作用是防止同一个头文件被多次include</p>
<blockquote>
<p>比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这两个头文件是包含关系,完全可以只<code>#include &lt;cstdio&gt;</code>,但是这时<code>#include &lt;stdio.h&gt;</code>之后再<code>#include &lt;cstdio&gt;</code>时,会引入<code>&lt;cstdio&gt;</code>中除了包含的的<code>&lt;stdio.h&gt;</code>之外的其他内容.当然,如果再引入一遍<code>&lt;stdio.h&gt;</code>也不会报错,因为都是引用</p>
<p>但是有时候去重的作用就很重要,比如<code>"a.h"</code>中会<code>#include "b.h"</code>同理<code>"b.h"</code>会<code>#include "a.h"</code>,即两个头文件会互相引入,如果此时不使用条件展开去重,则预编译器会不停引入两个文件,直到崩溃</p>
</blockquote>
</blockquote>
<h6 id="正确写法-1">正确写法</h6>
<h6 id="方法一宏定义pi">方法一:宏定义PI</h6>
<p>在<code>geometry.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GEOMETRY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GEOMETRY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line">....</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这也是glibc库的头文件中使用的方法</p>
<p>比如<code>stdio.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZ 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NFILE _NSTREAM_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NSTREAM_ 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOB_ENTRIES 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOF (-1)</span></span><br></pre></td></tr></table></figure>
<p>我们自己写一个<code>main.c</code>,<code>#include &lt;stdio.h&gt;</code>之后就可以直接使用这些宏定义</p>
</blockquote>
<blockquote>
<p>为什么可以使用宏定义呢?</p>
<p>各组成模块宏定义展开之后可能会有多条同样的宏定义,宏定义允许多次定义,在调用时使用最后一次的宏定义</p>
<p>比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.142</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1416</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; PI;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.14159</span><br></pre></td></tr></table></figure>
<p>但是会报告编译警告</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">testGlobal.c:3: warning: <span class="string">&quot;PI&quot;</span> redefined</span><br><span class="line">    3 | <span class="comment">#define PI 3.142</span></span><br><span class="line">      |</span><br><span class="line">testGlobal.c:2: note: this is the location of the previous definition</span><br><span class="line">    2 | <span class="comment">#define PI 3.14</span></span><br><span class="line">      |</span><br><span class="line">testGlobal.c:4: warning: <span class="string">&quot;PI&quot;</span> redefined</span><br><span class="line">    4 | <span class="comment">#define PI 3.1416</span></span><br><span class="line">      |</span><br><span class="line">testGlobal.c:3: note: this is the location of the previous definition</span><br><span class="line">    3 | <span class="comment">#define PI 3.142</span></span><br><span class="line">      |</span><br><span class="line">testGlobal.c:5: warning: <span class="string">&quot;PI&quot;</span> redefined</span><br><span class="line">    5 | <span class="comment">#define PI 3.14159</span></span><br><span class="line">      |</span><br><span class="line">testGlobal.c:4: note: this is the location of the previous definition</span><br><span class="line">    4 | <span class="comment">#define PI 3.1416</span></span><br><span class="line">      |</span><br></pre></td></tr></table></figure>
<p>而如果多次宏定义一模一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br></pre></td></tr></table></figure>
<p>则不会报告编译警告</p>
</blockquote>
<h6 id="方法二使用extern引用">方法二:使用extern引用</h6>
<p>比如在<code>point.c</code>中全局位置写入<code>const double PI=3.1415926;</code></p>
<p><code>main</code>函数中要使用<code>PI</code>值,那么在<code>main.c</code>中找一个使用<code>PI</code>之前的位置(不管是局部还是全局位置),<code>extern double PI;</code></p>
<p>作用是,声明一下<code>PI</code>是一个外部符号(本模块中妹有定义),编译时产生一个引用,至于引用的解析,让链接器去找</p>
<blockquote>
<p>实际上用<code>extern</code>声明一个变量和声明一个函数引用的作用是类似的,都是声明引用.</p>
<p>但是为啥函数引用不用<code>extern</code>声明,但是变量就一定得用<code>extern</code>声明呢?</p>
<p>函数只要不写函数体,在参数表小括号后面一个分号,立刻就可以断定这是一个函数引用.</p>
<p>而全局变量即使不赋值直接写分号,<code>int a;</code>编译器就认为这是一个应该放在.bss节的本模块中的数据.为了突出是个引用,因此使用<code>extern</code>关键字</p>
</blockquote>
<blockquote>
<p>extern的作用</p>
<p>如果一个程序这样写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">double</span> PI;			<span class="comment">//试图声明一个引用,并在main函数之后赋值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; PI;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>
<p>会报错<code>[注解] 'double PI' previously 被声明于此处</code>.同一个模块中存在多重定义了</p>
<p>正确的写法应该是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> PI;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; PI;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>
<p>运行结果:<code>3.14</code></p>
<p>对于函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;<span class="comment">//这两种写法都可以</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	func();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;		<span class="comment">//实现</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;fcntl.h&gt;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">open</span> <span class="params">(__const <span class="type">char</span> *__file, <span class="type">int</span> __oflag, ...)</span> __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6
id="extern-double-pi能否写入头文件"><code>extern double PI;</code>能否写入头文件</h6>
<p>既然可以将<code>extern double PI;</code>写入<code>main.c</code>,那么写入<code>geometry.h</code>不一样吗?被<code>main.c</code>引入之后不就相当于在<code>main.c</code>中写了这句吗</p>
<p>这样写可以通过编译链接,感觉上妹有问题,但是用CLion搜索了整个glibc库,所有头文件中都没有这么写,只在<code>configure.in</code>中有这么一句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> glibc_conftest_frobozz;</span><br></pre></td></tr></table></figure>
<h5 id="静态变量">静态变量</h5>
<p>静态变量的作用是,将"全局位置"的变量的访问权限限定在本模块中.</p>
<p>啥意思呢?</p>
<p><code>point.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span></span></span><br><span class="line"><span class="comment">//全局位置</span></span><br><span class="line"><span class="comment">//const double PI=3.1415926;					//真·全局变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> PI=<span class="number">3.1415926</span>;				<span class="comment">//假·全局变量</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>被<code>static</code>修饰的变量即使放在本模块的"全局位置",也是相对于本模块中的函数而言的"全局位置"</p>
<p>此时如果在<code>main.c</code>中想要使用<code>PI</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span></span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">double</span> PI;			<span class="comment">//声明PI引用,让链接器去解析</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">....</span><br><span class="line">    <span class="type">int</span> pi=PI;				<span class="comment">//试图使用引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而此时会报链接错</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/<span class="number">86135</span>/Desktop/linkage]</span><br><span class="line">└─$ ./makedynamiclib.sh</span><br><span class="line">/usr/bin/ld: /tmp/ccSIplb4.o: warning: relocation against `PI<span class="number">&#x27;</span> in read-only section `.text<span class="number">&#x27;</span></span><br><span class="line">/usr/bin/ld: /tmp/ccSIplb4.o: in function `main<span class="number">&#x27;</span>:</span><br><span class="line">main.c:(.text+<span class="number">0xd7</span>): undefined reference to `PI<span class="number">&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>static修饰的变量就类似于java和C++中<code>private</code>修饰的变量</p>
<p>只不过static限制模块之间的访问权限</p>
<p><code>private</code>限制类之间的访问权限</p>
<p>这是两种编程范式,模块化编程和面向对象编程</p>
</blockquote>
<h3 id="静态库.a">静态库.a</h3>
<p>静态库<code>static library</code>实际上是一伙子可重定位目标模块<code>.o</code>的集合</p>
<h4 id="起源">起源</h4>
<p>现在假设我们一个工程有成百上千个目标模块<code>.o</code>,</p>
<p>在其中一个目标模块引用了其他若干个目标模块中的符号.</p>
<p>如果引用的其他目标模块不多,尚且看不出问题,只需要<code>gcc main.o module1.o module2. ... -o prog</code>即可完成链接</p>
<p>如果引用的其他目标模块成百上千,那么可以想象到<code>gcc main.o module1.o module2. ... -o prog</code>这条编译命令能有多长</p>
<p>"可以编写<code>makefile</code>完成链接"</p>
<p>即使用<code>makefile</code>,还是存在难以解决的问题</p>
<p><strong>引用的符号在哪个模块里,是在<code>module1.o</code>还是在<code>module2.o</code>?程序员记得住吗?每次编译都要查表吗?</strong></p>
<p><strong>静态库也是可重定位目标文件<code>.o</code>吗?</strong></p>
<p>最容易想到的是,将一些工具性质的,经常被调用的一些目标模块,编译成一个大目标模块<code>.o</code>,注意还是可重定位目标模块<code>.o</code></p>
<p>当程序员自己写一个源文件<code>test.c</code>并编译成目标模块<code>test.o</code>,其中要用到一些库函数时,只需要将刚才生成的大<code>.o</code>文件链接进来</p>
<p>诚如是,则链接时该包含成千上万函数的大<code>.o</code>文件将会在运行时全部加载进入进程的地址空间,即使<code>test.o</code>只引用到了一个或者几个函数.</p>
<blockquote>
<p>这就好比要去图书馆接一本书,却把图书馆整个儿搬回家了</p>
</blockquote>
<p>能不能真正像借书一样,用到哪本书拿哪本,用到一个函数就只加载该函数所在的模块?</p>
<p><strong>于是归档文件(archieve)<code>.a</code>产生了,即静态库</strong></p>
<blockquote>
<p><code>.o</code>可重定位目标模块可能是静态库.a的组成,也可能是源代码<code>test.c</code>编译后链接前的中间文件.也就是说,.o中有可能有程序的入口点<code>main</code>函数.</p>
<p><code>.a</code>作为一个库文件,只能起到支持的作用,它就相当于一个服务器被动地给客户端服务.也就是说,只有用户的程序中有入口点,.a是不会主动执行的.直接试图将静态库编译链接为可执行目标文件是不可能的,因为库中没有<code>main</code>函数</p>
</blockquote>
<h4
id="使用静态库ar-rcs-静态库名.a-组成目标1.o-组成目标2.o-....">使用静态库<code>ar rcs &lt;静态库名&gt;.a &lt;组成目标1&gt;.o &lt;组成目标2&gt;.o ....</code></h4>
<p>举一个比较有实际意义的例子,模拟平面几何中的点和线</p>
<p>工作目录下有五个文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# <span class="built_in">ls</span> -l</span><br><span class="line">total 4</span><br><span class="line">-rwxrwxrwx 1 kali kali 731 May 25 21:57 geometry.h</span><br><span class="line">-rwxrwxrwx 1 kali kali 667 May 25 22:02 line.c</span><br><span class="line">-rwxrwxrwx 1 kali kali 285 May 25 21:26 main.c</span><br><span class="line">-rwxrwxrwx 1 kali kali 520 May 25 21:57 point.c</span><br><span class="line">-rwxrwxrwx 1 kali kali 140 May 25 22:03 shellscript.sh</span><br></pre></td></tr></table></figure>
<h5 id="geometry.h"><code>geometry.h</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GEOMETRY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GEOMETRY</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>		<span class="comment">//点结构体</span></span><br><span class="line">        <span class="type">double</span> x;</span><br><span class="line">        <span class="type">double</span> y;</span><br><span class="line">    &#125;Point;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getEuclideanDistance</span><span class="params">(Point,Point)</span>;   <span class="comment">//计算两点之间的欧几里得距离</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">getManhattanDistance</span><span class="params">(Point,Point)</span>;   <span class="comment">//计算两点之间的曼哈顿距离</span></span><br><span class="line">    Point <span class="title function_">newPoint</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span>;      <span class="comment">//构造新点</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">showPoint</span><span class="params">(Point)</span>;              <span class="comment">//打印点坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>		<span class="comment">//线结构体</span></span><br><span class="line">        Point a;</span><br><span class="line">        Point b;</span><br><span class="line">    &#125;Line;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getLength</span><span class="params">(Line)</span>;         <span class="comment">//计算线段长</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">getSlope</span><span class="params">(Line)</span>;          <span class="comment">//计算斜率</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">isParallel</span><span class="params">(Line,Line)</span>;      <span class="comment">//判断平行</span></span><br><span class="line">    Line <span class="title function_">newLine</span><span class="params">(Point,Point)</span>;      <span class="comment">//构造新线段</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">showLine</span><span class="params">(Line)</span>;			<span class="comment">//打印线两端点</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这里面的函数声明被分在两个源文件实现,<code>point.c</code>实现有关点计算的函数,<code>line.c</code>实现有关线计算的函数</p>
<h5 id="point.c"><code>point.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span>			<span class="comment">//引入符号</span></span></span><br><span class="line">    <span class="comment">// typedef struct&#123;</span></span><br><span class="line">    <span class="comment">//     double x;</span></span><br><span class="line">    <span class="comment">//     double y;</span></span><br><span class="line">    <span class="comment">// &#125;Point;</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">getEuclideanDistance</span><span class="params">(Point a,Point b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">getManhattanDistance</span><span class="params">(Point a,Point b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a.x-b.x)+<span class="built_in">abs</span>(a.y-b.y);</span><br><span class="line">&#125;</span><br><span class="line">Point <span class="title function_">newPoint</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>&#123;</span><br><span class="line">    Point a;</span><br><span class="line">    a.x=x;</span><br><span class="line">    a.y=y;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">showPoint</span><span class="params">(Point p)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%.2f,%.2f)&quot;</span>,p.x,p.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="line.c"><code>line.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span>			<span class="comment">//引入符号</span></span></span><br><span class="line">    <span class="comment">// typedef struct&#123;</span></span><br><span class="line">    <span class="comment">//     Point a;</span></span><br><span class="line">    <span class="comment">//     Point b;</span></span><br><span class="line">    <span class="comment">// &#125;Line;</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">getLength</span><span class="params">(Line L)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getEuclideanDistance(L.a,L.b);			<span class="comment">//此处要用到计算欧几里得距离的函数,其实现在point.c中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getSlope</span><span class="params">(Line L)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>*(L.a.y-L.b.y)/(L.a.x-L.b.x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">isParallel</span><span class="params">(Line L1,Line L2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(getSlope(L1)-getSlope(L2))&lt;<span class="number">0.001</span>;	<span class="comment">//控制精度为0.001</span></span><br><span class="line">    &#125;</span><br><span class="line">    Line <span class="title function_">newLine</span><span class="params">(Point a,Point b)</span>&#123;</span><br><span class="line">        Line L;</span><br><span class="line">        L.a=a;</span><br><span class="line">        L.b=b;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">showLine</span><span class="params">(Line L)</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[(%.2f,%2f)(%.2f,%.2f)]&quot;</span>,L.a.x,L.a.y,L.b.x,L.b.y);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="main.c-1"><code>main.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Point a=newPoint(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    Point b=newPoint(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="type">double</span> euclidean_distance=getEuclideanDistance(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;euclidean_distance=%.2f\n&quot;</span>,euclidean_distance);</span><br><span class="line">    showPoint(a);</span><br><span class="line">    showPoint(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>main</code>函数中只用到了和点有关的函数,与线有关的函数一个也妹有用到</p>
<p>下面编写<code>bash</code>脚本进行编译,制作静态库,链接,运行</p>
<h5 id="shellscript.sh"><code>shellscript.sh</code></h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcc point.c -c -o point.o</span><br><span class="line">gcc line.c -c -o line.o</span><br><span class="line">ar rcs libgeometry.a point.o line.o				#创建静态库</span><br><span class="line"></span><br><span class="line">gcc -static main.c -L. -lgeometry -lm -o prog </span><br><span class="line">./prog</span><br></pre></td></tr></table></figure>
<p>执行该<code>shell</code>脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# ./shellscript.sh</span><br><span class="line">euclidean_distance=2.83</span><br><span class="line">(4.00,5.00)(2.00,3.00)</span><br></pre></td></tr></table></figure>
<p>同时在工作目录下生成了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libgeometry.a</span><br><span class="line">line.o</span><br><span class="line">point.o</span><br><span class="line">prog</span><br></pre></td></tr></table></figure>
<p>这么几个文件</p>
<p>现在好奇的是,这个<code>libgeometry.a</code>到底有没有用啥拿啥的功能,也就是说,<code>line.o</code>有没有被链接进入可执行目标文件<code>prog</code>.用ida64打开<code>prog</code>,搜一下<code>function</code>看看<code>newLine</code>函数存不存在即可</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525221037808.png"
alt="image-20220525221037808" />
<figcaption aria-hidden="true">image-20220525221037808</figcaption>
</figure>
<p>结果证明它不存在,也就是说<code>line.o</code>妹有链接进入<code>prog</code></p>
<p>还有就是<code>main</code>中妹有用到<code>point.c</code>中的<code>getManhattanDistance</code>函数,它有没有随着<code>point.o</code>一起被链接进入<code>prog</code>呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525221208601.png"
alt="image-20220525221208601" />
<figcaption aria-hidden="true">image-20220525221208601</figcaption>
</figure>
<p>事实上是有的,也就是说,从归档文件<code>.a</code>中用啥拿啥是以模块为单位的,而不是以函数为单位的,</p>
<p>归档文件中的一个模块,不管有多少个函数,只要有其中之一被引用,该模块中的所有函数都会随着该模块链接进入可执行目标文件</p>
<h4 id="a如何链接"><code>.a</code>如何链接</h4>
<p>前面章节中符号解析重定位等等都是<code>.o</code>的链接方法.现在对于一个静态库<code>.a</code>,应该如何链接呢?</p>
<p><strong>1.</strong>当输入<code>gcc f1 f2 ... fn</code>之后,编译器首先将各个源文件编译为可重定位目标文件<code>.o</code>,已经是<code>.o</code>或者<code>.a</code>文件则跳过不编译,得到一个全都是<code>.o</code>或者<code>.a</code>的参数序列</p>
<p><strong>2.</strong>链接器从左向右扫描这些<code>.o</code>或者<code>.a</code>文件,这两种文件有不同的待遇.</p>
<blockquote>
<p>链接器会维护三个集合:</p>
<p>可重定位目标文件集合E</p>
<p>未解析符号集合U(undefined)</p>
<p>已定义符号集合D(defined)</p>
</blockquote>
<p><strong>3.</strong>如果链接器当前扫描到的文件是一个.o,则</p>
<blockquote>
<p>本.o文件添加到E集合</p>
<p>本.o文件中的定义放到D集合</p>
<p>本.o文件中的引用放到U集合</p>
</blockquote>
<p><strong>4.</strong>如果链接器当前扫描到的文件是一个.a,则</p>
<blockquote>
<p>遍历本.a文件中所有组成模块,寻找U中引用的定义模块,</p>
<p>如果找到则将该模块放到E,将该引用从U中去掉,将定义放到D中</p>
<p><strong>遍历完后本.a文件不再发挥作用</strong></p>
</blockquote>
<p><strong>5.</strong>当链接器扫描完了参数,此时检查U集合是否为空</p>
<blockquote>
<p>如果U非空则有未解析的引用,报错<code>undefined reference</code></p>
<p>如果U为空则连接成功,合并并重定位E中的模块,形成可执行目标文件</p>
</blockquote>
<p>链接结束</p>
<blockquote>
<p>注意第4条最后的"<strong>遍历完后本.a文件不再发挥作用</strong>"</p>
<p>这就要求命令行上的参数有顺序了</p>
<p>如果都是.o妹有.a,则所有.o的所有定义和引用都会被放在D和U中,不怕有遗漏的定义</p>
<p>但是如果有.a,则链接器扫描.a时,只负责解析先前存在在U中的引用,后面的目标模块它现在看都不看</p>
<p>比如假如参数序列是这样的:<code>gcc a.o b.o lib.a c.o</code></p>
<p>其中a,b,c中都有<code>lib.a</code>中的引用,并且</p>
<p><code>a.o</code>引用了<code>lib.a</code>中的<code>a</code>模块,</p>
<p><code>b.o</code>引用了<code>lib.a</code>中的<code>b</code>模块,</p>
<p><code>c.o</code>引用了<code>lib.a</code>中的<code>c</code>模块,</p>
<p>当链接器扫描到<code>lib.a</code>时,链接器会依据<code>lib.a</code>,解析<code>a.o</code>和<code>b.o</code>中的引用,但是链接器此时并不知道后面还有啥参数,在用<code>lib.a</code>解析了<code>a.o</code>和<code>b.o</code>之后就丢弃了<code>lib.a</code>的其他部分,</p>
<p>然后扫描<code>c.o</code>又有了新的引用,而此时链接器已经扫描到头了,找不到一个能给出定义的模块了</p>
<p>链接出错</p>
<p>这样设计虽然会因为顺序问题导致链接出错,但是注意一下或者多写几遍.a就可以克服.并且能够做到尽量少引入目标模块,非用不引.并且时间最优</p>
</blockquote>
<h3 id="动态库.so">动态库.so</h3>
<p>动态库又叫做共享目标文件</p>
<h4 id="起源-1">起源</h4>
<blockquote>
<p>静态库的缺点:</p>
<p>试想现在要同时运行多个进程,每个进程都要调用库函数<code>printf</code>,按照静态库的链接方法,每个进程的虚拟地址空间都会有一个printf
的拷贝,并且会物理地址空间上建立相应物理页</p>
<p>而实际上<code>printf</code>就是一段只读的代码,给定参数就可以当作黑盒用.</p>
<p>就像办公室的打印机,不同的用户只需要给定自己想要打印的材料,用同一台打印机就可以获得不同的输出</p>
</blockquote>
<p>在兼容静态库拿啥用啥的思想上,让只读的代码和数据不需要有多份拷贝,<strong>一份足矣</strong>,这就是动态库的思想.</p>
<p>动态库在<strong>运行或加载</strong>时,可以加载到<strong>任意地址</strong></p>
<p>在linux上动态库后缀.so,在windows上动态库后缀.dll</p>
<h4 id="动态库的链接">动态库的链接</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220526001100718.png"
alt="image-20220526001100718" />
<figcaption aria-hidden="true">image-20220526001100718</figcaption>
</figure>
<p>在链接阶段,动态库传递给链接器的只有重定位和符号表信息,并没有让只读代码段参与链接.</p>
<p>啥时候动态库中的只读代码才会参与链接呢?在执行过程中,首次用到了动态库中的引用时,不得不动态加载了,此时动态链接器才会将动态库映射到进程的地址空间,并进行重定位让悬空引用落地</p>
<blockquote>
<p>这个过程我没有亲眼见证,都是道听途说,暂且认为它是这样的</p>
</blockquote>
<p>为了让不同的进程都能将共享库的物理地址空间映射到自己的虚拟地址空间,有好多种办法</p>
<p>1.物理地址空间为共享库专门留出空间,一个萝卜一个坑,就算妹有萝卜,坑也得留着,其他代码数据都往后稍稍.用到该共享库的时候就一定加载到给他预留的物理地址空间.</p>
<blockquote>
<p>缺点是,程序不一定会用到该共享库,或者程序刚开始时只用到该共享库的一小部分代码,共享库只有一小部分加载进入物理地址空间.然后是其他代码,占用了为共享库预留的剩余空间,现在又要调用共享库中的其他代码,这时一开始预留的空间已经被占用,不够用了.又得重新找一个空旷的地方放动态库.这样重复多了,物理地址空间就变得呲离破碎,全是下脚料空间</p>
<p>这可能比静态库还要浪费物理内存,这不就废了吗</p>
</blockquote>
<p>2.位置无关代码</p>
<p>动态库可以任意加载进入物理地址空间,由动态链接器完成程序中动态库引用的解析</p>
<h4 id="使用动态库">使用动态库</h4>
<p>还是使用静态库时举的<code>geometry</code>的例子</p>
<p><code>makedynamiclib.sh</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fpic -o libgeometry.so line.c point.c  #制作代码位置无关的共享库libgeometry.so</span><br><span class="line"></span><br><span class="line">gcc  main.c ./libgeometry.so -lm -o prog </span><br><span class="line"></span><br><span class="line">./prog</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/linkage]</span><br><span class="line">└─# ./makedynamiclib.sh</span><br><span class="line">euclidean_distance=2.83</span><br><span class="line">(4.00,5.00)(2.00,3.00)</span><br></pre></td></tr></table></figure>
<p>同时在工作目录下生成了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libgeometry.so</span><br><span class="line">prog</span><br></pre></td></tr></table></figure>
<p>两个目标文件</p>
<p>使用ida64打开prog观察,发现函数少的可怜</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220526093938243.png"
alt="image-20220526093938243" />
<figcaption aria-hidden="true">image-20220526093938243</figcaption>
</figure>
<p>并且可以发现,在<code>point.c</code>中定义的<code>getManhattanDistance</code>并没有被解析.</p>
<p>即,使用动态库时引用解析是<strong>以函数为单位</strong>的,相对于以模块为单位进行解析的静态库更加灵活</p>
<p>以<code>getEuclideanDistance</code>为例,观察该函数引用是如何被解析的</p>
<p>在<code>main</code>函数中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000011EB                 call    _getEuclideanDistance</span><br></pre></td></tr></table></figure>
<p>跟踪<code>_getEuclideanDistance</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.plt:0000000000001060 _getEuclideanDistance proc near         ; CODE XREF: main+82↓p</span><br><span class="line">.plt:0000000000001060                 jmp     cs:off_4030</span><br><span class="line">.plt:0000000000001060 _getEuclideanDistance endp</span><br></pre></td></tr></table></figure>
<p>跟踪<code>cs:off_4030</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.got.plt:0000000000004030 off_4030        dq offset getEuclideanDistance</span><br><span class="line">.got.plt:0000000000004030                                         ; DATA XREF: _getEuclideanDistance↑r</span><br><span class="line">.got.plt:0000000000004030 _got_plt        ends</span><br><span class="line">.got.plt:0000000000004030</span><br></pre></td></tr></table></figure>
<p>跟踪<code>offset getEuclideanDistance</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern:0000000000004078                 extrn getEuclideanDistance:near</span><br><span class="line">extern:0000000000004078                                         ; CODE XREF: _getEuclideanDistance↑j</span><br><span class="line">extern:0000000000004078                                         ; DATA XREF: .got.plt:off_4030↑o</span><br></pre></td></tr></table></figure>
<p>此时已经跟踪到头了,点谁都不会跳转了.但是自始至终妹有看见该函数的实现,好像一直在踢皮球</p>
<p>这涉及到位置无关代码PIC的理论</p>
<h4 id="位置无关代码pic">位置无关代码PIC</h4>
<p>Position-Independent Code</p>
<p>共享库在编译时要求必须使用位置无关选项<code>-fpic</code></p>
<h5 id="pic数据引用">PIC数据引用</h5>
<p>全局偏移量表global offset table,GOT</p>
<p>GOT位于<strong>数据段的开始</strong></p>
<p>编译时使用<code>-static</code>选项得到的可执行目标文件中是妹有GOT表的</p>
<p>只有使用位置无关代码的动态链接才会生成GOT表,即使就写一个空壳子main函数啥也不干,什么头文件也不导入,动态链接之后的可执行目标文件也是会有GOT的</p>
<h6 id="got表结构">GOT表结构:</h6>
<p>GOT表项八字节一个,表项内容是引用指向的地址,即一个位置无关代码在运行时的实际地址</p>
<blockquote>
<p>为什么是八字节?</p>
<p>八个字节即64位,考虑进程的虚拟地址空间有64位吗?</p>
<p><img
src="https://pic2.zhimg.com/v2-76f7edab5d8e719cc150fc382c18a10e_1440w.jpg?source=172ae18b" /></p>
<p>图片来自<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/207001939">Linux内存管理：虚拟地址空间
- 知乎 (zhihu.com)</a></p>
<p>用户的虚拟地址空间只有48位,从<code>0x0</code>到<code>0xFFFF FFFF FFFF</code></p>
<p>内核的虚拟地址空间也是48位,从<code>0xFFFF 0000 0000 0000</code>到<code>0xFFFF FFFF FFFF FFFF</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Start                 End                     Size            Use</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">0000000000000000      0000ffffffffffff         256TB          user</span><br><span class="line">ffff000000000000      ffff7fffffffffff         128TB          kernel logical memory map</span><br><span class="line">ffff800000000000      ffff9fffffffffff          32TB          kasan shadow region</span><br><span class="line">ffffa00000000000      ffffa00007ffffff         128MB          bpf jit region</span><br><span class="line">ffffa00008000000      ffffa0000fffffff         128MB          modules</span><br><span class="line">ffffa00010000000      fffffdffbffeffff         ~93TB          vmalloc</span><br><span class="line">fffffdffbfff0000      fffffdfffe5f8fff        ~998MB          [guard region]</span><br><span class="line">fffffdfffe5f9000      fffffdfffe9fffff        4124KB          fixed mappings</span><br><span class="line">fffffdfffea00000      fffffdfffebfffff           2MB          [guard region]</span><br><span class="line">fffffdfffec00000      fffffdffffbfffff          16MB          PCI I/O space</span><br><span class="line">fffffdffffc00000      fffffdffffdfffff           2MB          [guard region]</span><br><span class="line">fffffdffffe00000      ffffffffffdfffff           2TB          vmemmap</span><br><span class="line">ffffffffffe00000      ffffffffffffffff           2MB          [guard region]</span><br></pre></td></tr></table></figure>
<p>如果GOT表项可以指向一个内核中的函数或者变量,则显然需要8字节的表项,</p>
<p>如果GOT表项只是指向用户模块中的变量或者函数,则只需要6字节(48位)的表项</p>
<p>因此问题转化为一个进程是否会访问内核</p>
<p>显然是可以的,比如系统调用</p>
</blockquote>
<h6 id="got表怎么干活的">GOT表怎么干活的?</h6>
<p>CSAPP上举了这么一个例子</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220526192907692.png"
alt="image-20220526192907137" />
<figcaption aria-hidden="true">image-20220526192907137</figcaption>
</figure>
<p>一定时刻记住以下几点:</p>
<p>1.代码段是c源代码经过<strong>编译</strong>得到的,与链接无关</p>
<p>2.本模块中引用了一个位于其它模块中的符号<code>addcnt</code>,本模块中妹有定义,因此编译器会为其生成一个<code>GOT</code>表项,又从代码段到数据段GOT的跳转需要重定位,因此汇编器会生成一个重定位条目,为静态链接器(相对动态链接器的说法)进行重定位做准备</p>
<p>3.编译阶段是不知道GOT表在哪里的(即使GOT表和代码段在同一模块中),汇编器只会生成重定位条目</p>
<p>4.静态链接阶段才会将代码段中对GOT的引用重定位,</p>
<p>5.静态链接后,在代码段只需要对GOT表的PC相对寻址,在实际运行时,由动态链接器去实际填充该表项应该指向的地址</p>
<blockquote>
<p>注意这里有两次引用,一是代码段引用数据段的GOT表,二是GOT表引用其他模块中的符号</p>
</blockquote>
<blockquote>
<p>GOT表的存在,相当于编译器和静态链接器给动态链接器减轻了负担,动态链接器不需要去代码段找需要解析的引用,只需要看看数据段的开头,就知道哪些引用需要解析</p>
<p>至于动态链接器是个啥,怎么工作的,现在不关心,就当是一个黑盒,它在程序运行阶段发挥作用,结果是给GOT表中的引用找到实际地址,填充到GOT表项</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R[%rax]&lt;---R[%rip]+0x2008b9=&amp;GOT[3]		//主存中GOT[3]的地址放到rax寄存器中</span><br><span class="line">M[R[%rax]]=M[R[%rip]+0x2008b9]=M[%GOT[3]]&lt;---M[%GOT[3]]+1			//解引用后+1再放回去</span><br></pre></td></tr></table></figure>
<h5 id="pic函数调用">PIC函数调用</h5>
<p>GOT和PLT协作</p>
<p>CSAPP教材上给出了看起来不长,却信息量巨大的图文,下面就这一段文字进行解读</p>
<figure>
<img
src="../../AppData/Roaming/Typora/typora-user-images/image-20220526201953361.png"
alt="image-20220526201953361" />
<figcaption aria-hidden="true">image-20220526201953361</figcaption>
</figure>
<h6 id="过程链接表plt">·过程链接表(PLT)</h6>
<p>1.PLT是一个数组,其中每个条目都是16字节的代码.</p>
<blockquote>
<p>PLT表:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.plt:0000000000001020</span><br><span class="line">.plt:0000000000001020                               ; Segment type: Pure code	;段类型:纯代码</span><br><span class="line">.plt:0000000000001020                               ; Segment permissions: Read/Execute	;段权限:读/执行/不可写</span><br><span class="line">.plt:0000000000001020                               _plt            segment para public &#x27;CODE&#x27; use64</span><br><span class="line">.plt:0000000000001020                                               assume cs:_plt	;令cs段寄存器指向plt段</span><br><span class="line">.plt:0000000000001020                                               ;org 1020h</span><br><span class="line">.plt:0000000000001020                                               assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing</span><br></pre></td></tr></table></figure>
<p>PLT表的表项16字节一个,表项内容是<strong>代码(指令)</strong></p>
<p>比如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;6字节</span><br><span class="line">.plt:0000000000001030                               _isPrime        proc near               ; CODE XREF: main+D↓p</span><br><span class="line">.plt:0000000000001030 FF 25 E2 2F 00 00                             jmp     cs:off_4018</span><br><span class="line">.plt:0000000000001030                               _isPrime        endp</span><br><span class="line"></span><br><span class="line">;10字节</span><br><span class="line">.plt:0000000000001036 68 00 00 00 00                                push    0</span><br><span class="line">.plt:000000000000103B E9 E0 FF FF FF                                jmp     sub_1020</span><br></pre></td></tr></table></figure>
<p>为什么是16字节?</p>
<p>有些指令长,有些指令短,有些plt条目中有多条指令</p>
<p>16字节应该是存在的最长的plt表项</p>
</blockquote>
<p>2.PLT[0]是一个特殊条目,它跳转到动态链接器中.</p>
<blockquote>
<p>1.动态链接器本身就是一个动态库中的函数,是位置无关代码.因此也需要借助GOT和PLT表跳转.</p>
<p>2.PLT表中不只有用户显示引用的动态库中的函数,还有用户妹有显示引用却不可或缺的动态库函数,比如动态链接器</p>
</blockquote>
<p>3.每个被可执行程序调用的库函数都有自己的PLT表条目.每个条目都负责一个具体的函数</p>
<p>不光调用<code>glibc.so</code>动态库中的函数比如<code>printf</code>时有PLT条目,调用自定义的动态库也会有PLT条目</p>
<blockquote>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span>)</span>;<span class="comment">//isPrime为自定义动态库libfunc.so中的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=isPrime(<span class="number">510</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);		<span class="comment">//printf为glibc.so中的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&amp;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>制作动态库并链接,执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fpic -o libfunc.so func.c</span><br><span class="line"></span><br><span class="line">gcc -g main.c ./libfunc.so  -O0 -o prog </span><br></pre></td></tr></table></figure>
<p>使用ida64打开prog观察反汇编视图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.plt:0000000000001030 ; int printf(const char *format, ...)</span><br><span class="line">.plt:0000000000001030 _printf         proc near               ; CODE XREF: main+29↓p</span><br><span class="line">.plt:0000000000001030                 jmp     cs:off_4018</span><br><span class="line">.plt:0000000000001030 _printf         endp</span><br><span class="line">...</span><br><span class="line">.plt:0000000000001040 _isPrime        proc near               ; CODE XREF: main+D↓p</span><br><span class="line">.plt:0000000000001040                 jmp     cs:off_4020</span><br><span class="line">.plt:0000000000001040 _isPrime        endp</span><br></pre></td></tr></table></figure>
<p>都生成了plt条目</p>
</blockquote>
<h6 id="全局偏移量表got">·全局偏移量表(GOT)</h6>
<p>初始时,每个GOT条目都对应PLT条目的第二条指令</p>
<blockquote>
<p>这其实不是GOT的特性了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:   55                      push   %rbp</span><br><span class="line">   1:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   4:   48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">   8:   bf fe 01 00 00          mov    $0x1fe,%edi</span><br><span class="line">   d:   e8 00 00 00 00          call   12 &lt;main+0x12&gt;	//此处call的地址就在下一行啊</span><br><span class="line">  12:   89 45 fc                mov    %eax,-0x4(%rbp)</span><br><span class="line">  15:   8b 45 fc                mov    -0x4(%rbp),%eax</span><br><span class="line">  18:   89 c6                   mov    %eax,%esi</span><br><span class="line">  1a:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # 21 &lt;main+0x21&gt;</span><br><span class="line">  21:   48 89 c7                mov    %rax,%rdi</span><br><span class="line">  24:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  29:   e8 00 00 00 00          call   2e &lt;main+0x2e&gt;//此处call的地址就在下一行</span><br><span class="line">  2e:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  33:   c9                      leave</span><br><span class="line">  34:   c3                      ret</span><br></pre></td></tr></table></figure>
<p>由于编译器和静态链接器不能决定引用函数的具体地址,因此他俩只能摆烂.</p>
<p>动态链接器会把GOT指向的地址修改为动态库函数地址</p>
</blockquote>
<h5 id="举个例子">举个例子</h5>
<p>CSAPP举的例子</p>
<figure>
<img
src="../../AppData/Roaming/Typora/typora-user-images/image-20220526211008954.png"
alt="image-20220526211008954" />
<figcaption aria-hidden="true">image-20220526211008954</figcaption>
</figure>
<h6 id="首次调用addvec"><strong>首次调用addvec</strong></h6>
<p>1.<code>callq 0x4005c0 #call addvec()</code></p>
<p>该指令执行时会将该call指令的后一条指令的地址作为返回时的地址压栈,然后置<code>PC=0x0x4005c0</code>,然后转移控制</p>
<p>2.<code>0x4005c0  jmpq *GOT[4]</code></p>
<p>这里<code>*GOT[4]</code>不是汇编语言的写法,是编者方便读者理解,使用了C语言中数组的表示方法</p>
<p>这里的意思是,跳转到<code>GOT[4]</code>指向的地址(即<code>GOT[4]</code>表项中存放的地址),而不是跳转到<code>GOT[4]</code>的地址</p>
<blockquote>
<p>实际上是这种写法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    1040:	ff 25 da 2f 00 00    	jmp    *0x2fda(%rip)        # 4020 &lt;isPrime@Base&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>间接跳转</p>
</blockquote>
<p>在第一次调用addvec时,<code>GOT[4]=0x4005c6</code>即<code>0x4005c0</code>的下一条地址</p>
<p>3.<code>pushq $0x1</code></p>
<p>CSAPP上对这条指令的解释是"把<code>addvec</code>的ID(0x1)压栈"</p>
<p>啥意思呢?</p>
<p>我的理解是,addvec是用户指定调用的第一条库函数(不包括编译器自己写上的动态链接器等隐式调用的函数),因此把1这个魔数压栈,压栈的目的是作为参数,接下来就要调用动态链接器了,因此传递1作为参数,告诉动态链接器应该动态链接的是用户调用的第一个库函数addvec</p>
<p>4.<code>pushq *GOT[1]</code></p>
<p><code>GOT[1]</code>存放的是<code>.reloc</code>节的首地址</p>
<p>联系刚才的<code>push $0x1</code>,可以猜测,<code>.reloc</code>是一个表,每一个表项对应一个需要重定位的库函数,其中第一条就是<code>addvec</code>的表项,然后动态链接器要用这个<code>0x1</code>去查<code>.reloc</code>表</p>
<p>5.<code>jmpq *GOT[2]</code></p>
<p><code>GOT[2]</code>存放的是动态链接器的地址,</p>
<p>用<code>jmpq GOT[2]</code>会跳转到<code>GOT[2]</code>,啥也不会发生</p>
<p>用<code>jmpq *GOT[2]</code>会跳转到<code>GOT[2]</code>的内容,也就是动态链接器的地址</p>
<p>为啥不用<code>call</code>指令调用,却用<code>jmpq</code>直接跳转到函数的开始呢?</p>
<p><code>call</code>指令需要将跳转前的下一条指令压栈作为返回地址,返回地址将会覆盖栈顶上用于动态链接器的参数.</p>
<p>而<code>jmpq</code>直接跳转到动态链接器,栈顶此时就是他要使用的参数</p>
<p>6.动态链接器会确定<code>.reloc</code>表中第一个库函数即<code>addvec</code>的运行时地址,然后用该地址改写<code>GOT[4]</code></p>
<blockquote>
<p>具体怎么查的addvec运行时地址,怎么改写的GOT[4],那是后话了,现在当成黑盒子用</p>
</blockquote>
<p>7.动态链接器将控制交给addvec,此时才开始真正执行<code>call addvec</code></p>
<h6 id="第二次调用addvec"><strong>第二次调用addvec</strong></h6>
<p>由于第一次调用addvec时,动态链接器已经将<code>GOT[4]</code>改写为正确的<code>addvec</code>运行时地址,现在调用就不会在请动态链接器出马了</p>
<p>在<code>jmpq *GOT[4]</code>之后就跳转到了<code>addvec</code>的首地址</p>
<p>这里不用call的原因是,这里就是想把控制交给addvec,不需要记录PLT表中的返回地址</p>
<p>在主函数调用addvec时已经<code>call addvec</code>了</p>
<blockquote>
<p>这有点类似于记忆化搜索</p>
<p>记忆数组对应GOT表</p>
<p>搜索函数对应动态链接器</p>
<p>第一次搜索前记忆数组都是空的,对应GOT表返回地址不正确</p>
<p>搜索到之后搜素函数会改写记忆数组相应元素,对应动态链接器会修改GOT表项为函数运行时地址</p>
<p>第二次搜索时如果记忆数组不为空则直接使用数组内容,不调用搜索函数,对应第二次调用函数时直接根据GOT表跳转</p>
</blockquote>
<h3 id="库打桩">库打桩</h3>
<blockquote>
<p>打桩:打桩，指把桩打进地里，使<a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/建筑物/673834">建筑物</a>基础坚固。--百度百科</p>
</blockquote>
<p>很纳闷为什么library interpositioning要翻译成打桩</p>
<p>library interpositioning 库 插入</p>
<p>就是程序本来应该调用一个库函数却被劫持调用一个包装函数或者其他逻辑的函数.甚至不如叫"库劫持"更直观</p>
<h4 id="预编译时打桩">预编译时打桩</h4>
<p>使用宏定义劫持库函数</p>
<h5 id="main.c-2"><code>main.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span>				<span class="comment">//此处的&lt;malloc.h&gt;不一定就是glibc中的头文件,有可能是劫持使用的&quot;malloc.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> *p=<span class="built_in">malloc</span>(<span class="number">510</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只是有这么一个<code>main.c</code>文件,
用<code>gcc main.c -o main</code>命令,编译链接之后所有都按部就班地发生,真正调用glibc库的malloc函数申请堆内存</p>
<p>下面给他劫持喽</p>
<h5 id="malloc.h"><code>malloc.h</code></h5>
<p>注意本头文件和库函数<code>malloc</code>声明所在的头文件<code>malloc.h</code>同名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYMALLOC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYMALLOC</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> malloc(size) mymalloc(size)				<span class="comment">//宏定义劫持库函数</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> free(ptr) mymalloc(ptr)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *<span class="title function_">mymalloc</span><span class="params">(<span class="type">size_t</span>)</span>;			<span class="comment">//声明函数接口</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">myfree</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h5 id="mymalloc.c"><code>mymalloc.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;malloc.h&quot;</span>				</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mymalloc</span><span class="params">(<span class="type">size_t</span>)</span>&#123;				<span class="comment">//mymalloc的实现</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc啥也不干&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myfree</span><span class="params">(<span class="type">void</span>*)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free啥也不干&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="命令">命令:</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -c mymalloc.c</span><br><span class="line"></span><br><span class="line">gcc -I. -o main main.c mymalloc.c</span><br><span class="line"></span><br><span class="line">./main</span><br></pre></td></tr></table></figure>
<blockquote>
<p>gcc搜索头文件的规则</p>
<blockquote>
<p>当#include &lt;headerfile.h&gt;
时，编译时按照"<code>编译命令指定目录---&gt;系统预设目录---&gt;编译器预设</code>"的顺序搜索头文件。</p>
<p>当#include
"headerfile.h"，编译时按照"<code>源文件当前目录---&gt;编译命令指定目录---&gt;系统预设目录---&gt;编译器预设</code>"的顺序搜索头文件。</p>
</blockquote>
<p>我们在使用glibc库函数时一般使用<code>&lt;malloc.h&gt;</code>,在不加编译命令时,编译器根本不会在当前工作目录下搜索这种尖括号头文件</p>
<p>而我们现在就想给他劫持到搜索当前工作目录,这就是编译时打桩</p>
<p>怎么实现这个头文件劫持呢?编译时加入<code>-I</code>选项,意思是告诉编译器,在搜索系统预设目录前,先按照编译命令指定目录(<code>-I.</code>这里的点号<code>.</code>就是当前目录)搜索头文件.</p>
<p>当前文件夹下恰好有我们自己写的同名头文件malloc.h,只要能找到,编译器就不会再在其他目录找这个头文件</p>
<p>然后在链接时需要给出我们自己写的<code>malloc.h</code>中的两个函数引用<code>mymalloc</code>和<code>myfree</code>,这就是<code>mymalloc.c</code>要做的事情了</p>
</blockquote>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc啥也不干malloc啥也不干</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上glibc中的malloc从未被调用过</p>
<p>总结预编译时打桩的步骤:</p>
<p>1.修改库函数头文件搜索位置</p>
<p>2.链接新的实现</p>
</blockquote>
<p>但是吧,PWN的题目都是给出一个已经编译链接完成的可执行目标文件.谁会让你在预编译阶段做手脚呢?</p>
<p>只能说,没用的知识又怎加了</p>
<h4 id="链接时打桩">链接时打桩</h4>
<h5 id="main.c-3"><code>main.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> *p=<span class="built_in">malloc</span>(<span class="number">510</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时<code>main.c</code>看起来还是非常正常的,使用<code>gcc main.c -o main</code>可以编译链接得到一个正儿八经的程序</p>
<p>下面用链接时打桩给他劫持喽</p>
<h5 id="mymalloc.c-1"><code>mymalloc.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *__real_malloc(<span class="type">size_t</span>);		<span class="comment">//对glibc中真·库函数malloc的引用</span></span><br><span class="line"><span class="type">void</span> *__real_free(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *__wrap_malloc(<span class="type">size_t</span> size)&#123;	<span class="comment">//包装函数</span></span><br><span class="line">    <span class="type">void</span> *ptr=__real_malloc(<span class="number">510</span>);<span class="comment">//包装函数会调用真函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in wrapper malloc\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *__wrap_free(<span class="type">void</span> *ptr)&#123;</span><br><span class="line">    __real_free(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in wrapper free\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为啥函数名前面要假设<code>__real,__wrap</code>这种前缀?</p>
<h5 id="命令-1">命令</h5>
<p><code>shellscript.sh</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gcc -c mymalloc.c		<span class="meta">#mymalloc.c编译成可重定位目标文件</span></span><br><span class="line">	</span><br><span class="line">gcc -c main.c			<span class="meta">#main.c编译成可重定位目标文件</span></span><br><span class="line"></span><br><span class="line">gcc -Wl,--wrap,<span class="built_in">malloc</span> -Wl,--wrap,<span class="built_in">free</span>  -o  prog main.o mymalloc.o	</span><br><span class="line">    </span><br><span class="line">./prog</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Wl,&lt;options&gt;            Pass comma-separated &lt;options&gt; on to the linker.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>comma-separated 用逗号分开的</p>
<p>给链接器传递用逗号分开的<选项></p>
</blockquote>
<p><code>--wrap,malloc</code>的作用是,链接器将malloc这个符号解析为<code>__wrap_malloc</code>这个符号,并且将<code>__real_malloc</code>这个符号解析为<code>malloc</code></p>
<p>那么在<code>main.c</code>中调用malloc时会被链接器重定位到<code>__wrap_malloc</code>的定义,</p>
<p>真正的glibc库中的<code>malloc</code>需要使用<code>__real_malloc</code>调用</p>
</blockquote>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/link]</span><br><span class="line">└─# ./shellscript.sh</span><br><span class="line"><span class="keyword">in</span> wrapper malloc</span><br><span class="line"><span class="keyword">in</span> wrapper free</span><br></pre></td></tr></table></figure>
<p>同样的道理,CTF题也不会让在链接阶段办手续,又是没用的知识</p>
<h4 id="运行时打桩">运行时打桩</h4>
<h5 id="运行时加载链接共享库">运行时加载链接共享库</h5>
<p>Linux系统为<strong>动态链接器</strong>提供的<strong>系统调用</strong>:]</p>
<h6 id="dlopen"><code>dlopen</code></h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">int</span> flag)</span>;<span class="comment">//成功则返回指向句柄的指针,一个代表共享库的句柄handle</span></span><br></pre></td></tr></table></figure>
<p>加载链接共享库<code>filename</code></p>
<p>flag参数值含义:</p>
<p><code>RTLD_GLOBAL</code>用其他用该选项打开的库解析filename库中的外部符号</p>
<p><code>RTLD_NOW</code>,链接器立刻解析外部符号引用</p>
<p><code>RTLD_LAZY</code>,链接器不得不解析外部符号时才进行解析</p>
<h6 id="dlsym"><code>dlsym</code></h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlsym</span><span class="params">(<span class="type">void</span> *handle,<span class="type">char</span> *symbol)</span>;</span><br></pre></td></tr></table></figure>
<p><code>handle</code>是<code>dlopen</code>的返回值,即指向共享库句柄的指针</p>
<p><code>symbol</code>是handle指向的共享库中的符号,比如一个全局变量或者一个符号</p>
<p>如果存在则返回该symbol的地址,否则返回NULL</p>
<h6 id="dlclose"><code>dlclose</code></h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dlclose</span><span class="params">(<span class="type">void</span> *handle)</span>;</span><br></pre></td></tr></table></figure>
<p>卸载handle指向的共享库</p>
<h6 id="dlerror"><code>dlerror</code></h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">dlerror</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>返回字符串,内容是最近调用前面三个函数时发生的错误,如果妹有错误则返回NULL</p>
<h6 id="举个例子-1">举个例子</h6>
<p>由于gcc会隐式加载链接glibc.so库,我们需要自己写一个动态库,比如<code>geometry</code></p>
<blockquote>
<p><code>geometry.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GEOMETRY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GEOMETRY</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">double</span> x;</span><br><span class="line">        <span class="type">double</span> y;</span><br><span class="line">    &#125;Point;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getEuclideanDistance</span><span class="params">(Point,Point)</span>;   <span class="comment">//计算两点之间的欧几里得距离</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">getManhattanDistance</span><span class="params">(Point,Point)</span>;   <span class="comment">//计算两点之间的曼哈顿距离</span></span><br><span class="line">    Point <span class="title function_">newPoint</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span>;      <span class="comment">//构造新点</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">showPoint</span><span class="params">(Point)</span>;              <span class="comment">//打印点坐标</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>geometry.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> PI=<span class="number">3.1415926</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">getEuclideanDistance</span><span class="params">(Point a,Point b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">getManhattanDistance</span><span class="params">(Point a,Point b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a.x-b.x)+<span class="built_in">abs</span>(a.y-b.y);</span><br><span class="line">&#125;</span><br><span class="line">Point <span class="title function_">newPoint</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>&#123;</span><br><span class="line">    Point a;</span><br><span class="line">    a.x=x;</span><br><span class="line">    a.y=y;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">showPoint</span><span class="params">(Point p)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%.2f,%.2f)&quot;</span>,p.x,p.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译成动态库<code>libgeometry.so</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fpic -o libgeometry.so geometry.</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span>		<span class="comment">//引入该头文件的主要作用是,获得Point结构体的定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">void</span> *handle=dlopen(<span class="string">&quot;./libgeometry.so&quot;</span>,RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span>(!handle)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s\n&quot;</span>,dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Point (*newPoint)(<span class="type">double</span>,<span class="type">double</span>)=dlsym(handle,<span class="string">&quot;newPoint&quot;</span>);<span class="comment">//函数指针指向handle库中&quot;newPoint&quot;符号</span></span><br><span class="line">    <span class="type">void</span> (*showPoint)(Point)=dlsym(handle,<span class="string">&quot;showPoint&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!newPoint||!showPoint)&#123;			<span class="comment">//检查newPoint和showPoint是否真的获得了地址</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s\n&quot;</span>,dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Point p=newPoint(<span class="number">1.2</span>,<span class="number">3.4</span>);			</span><br><span class="line">    showPoint(p);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dlclose(handle)&lt;<span class="number">0</span>)&#123;	<span class="comment">//卸载动态库</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s\n&quot;</span>,dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point (*newPoint)(<span class="type">double</span>,<span class="type">double</span>);</span><br></pre></td></tr></table></figure>
<p>声明一个返回值为Point类型,双参数都是double类型的函数指针</p>
</blockquote>
<p>编译命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/runtimelink]</span><br><span class="line">└─# gcc -rdynamic -o prog main.c -ldl</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://lenky.info/tag/rdynamic/">-rdynamic</a> 却是一个 <a
target="_blank" rel="noopener" href="http://gcc.gnu.org/onlinedocs/gcc/Link-Options.html">连接选项</a>
，它将指示连接器把所有符号（而不仅仅只是程序已使用到的外部符号）都添加到动态符号表（即.dynsym表）里，以便那些通过
<a
target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man3/dlopen.3.html">dlopen()</a>
或 <a
target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man3/backtrace.3.html">backtrace()</a>
（这一系列函数使用.dynsym表内符号）这样的函数使用。</p>
<p>添加-rdynamic选项后，.dynsym表就包含了所有的符号，不仅是已使用到的外部动态符号，还包括本程序内定义的符号，比如bar、foo、baz等。</p>
<p>参考博客<a
target="_blank" rel="noopener" href="https://blog.csdn.net/fengdijiang/article/details/108882608">gcc或g++的编译选项
-shared -fPIC 与 -g -rdynamic
部分转载_字正腔圆的博客-CSDN博客_rdynamic</a></p>
<p><code>-ldl</code>的作用是链接<code>dlfcn</code>库,是我们能够使用<code>dlopen</code>这种函数</p>
</blockquote>
<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/runtimelink]</span><br><span class="line">└─# ./prog</span><br><span class="line">(1.20,3.40)</span><br></pre></td></tr></table></figure>
<h5 id="运行时打桩-1">运行时打桩</h5>
<p>运行时打桩的思想是,自己写一个家的<code>malloc</code>函数,该函数使用dlopen等函数在运行时加载<code>glibc</code></p>
<p>奇怪,我按照CSAPP的说法做的实验,结果会报告段错误,留作后话吧</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>dustball
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="http://deutschball.github.io/2022/05/27/%E9%93%BE%E6%8E%A5/" title="CSAPP-chapter7 链接">http://deutschball.github.io/2022/05/27/链接/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CSAPP/" rel="tag"># CSAPP</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/24/markdown%E8%8A%B1%E9%87%8C%E7%8B%90%E7%AC%91%E5%8A%9F%E8%83%BD/" rel="prev" title="markdown花里狐笑功能">
      <i class="fa fa-chevron-left"></i> markdown花里狐笑功能
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/05/27/birth/" rel="next" title="Imperial March!">
      Imperial March! <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5"><span class="nav-number">1.</span> <span class="nav-text">链接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E.c%E5%88%B0.o"><span class="nav-number">1.1.</span> <span class="nav-text">从.c到.o</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E8%A6%81%E9%81%AD%E9%81%87%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.1.</span> <span class="nav-text">将要遭遇的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gcc%E5%92%8Cg%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.2.</span> <span class="nav-text">gcc和g++的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gcc%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%92%8C.c%E5%88%B0.exe%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.3.</span> <span class="nav-text">gcc命令行参数和.c到.exe的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91-e"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">预编译-E</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#i%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E6%8C%87%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">1.1.3.1.1.</span> <span class="nav-text">-I命令行参数指定自定义头文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91compilation-s"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">编译(Compilation)-S</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%87%E7%BC%96assembly-c"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">汇编(Assembly)-c</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5linking"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">链接(Linking)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%93"><span class="nav-number">1.1.3.4.1.</span> <span class="nav-text">库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.3.4.2.</span> <span class="nav-text">静态库的使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.3.4.3.</span> <span class="nav-text">动态库的使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="nav-number">1.1.4.</span> <span class="nav-text">参考文档</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="nav-number">1.2.</span> <span class="nav-text">目标文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6.o"><span class="nav-number">1.3.</span> <span class="nav-text">可重定位目标文件.o</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#readelf%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">readelf命令的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#h%E6%89%93%E5%8D%B0elf%E6%96%87%E4%BB%B6%E5%A4%B4%E4%BF%A1%E6%81%AF"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">-h打印elf文件头信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#s%E6%89%93%E5%8D%B0%E6%95%B4%E4%B8%AAsection-header-table%E8%A1%A8%E4%BF%A1%E6%81%AF"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">-S打印整个section header table表信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E6%9F%90%E4%B8%80%E8%8A%82"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">观察某一节</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E5%B8%B8%E7%94%A8%E8%8A%82"><span class="nav-number">1.3.2.</span> <span class="nav-text">可重定位目标文件的常用节</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#text"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">.text</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#data"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">.data</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bss"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">.bss</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rodata"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">.rodata</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#symtab%E8%8A%82"><span class="nav-number">1.3.3.</span> <span class="nav-text">.symtab节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E5%92%8C%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="nav-number">1.3.4.</span> <span class="nav-text">符号和符号表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90"><span class="nav-number">1.3.5.</span> <span class="nav-text">符号解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="nav-number">1.3.6.</span> <span class="nav-text">重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%8A%82"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">1.重定位节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%8A%82%E4%B8%AD%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">2.重定位节中的符号引用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E6%9D%A1%E7%9B%AE"><span class="nav-number">1.3.6.2.1.</span> <span class="nav-text">重定位条目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.6.2.2.</span> <span class="nav-text">重定位算法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6.out"><span class="nav-number">1.4.</span> <span class="nav-text">可执行目标文件.out</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%A7%86%E5%9B%BE"><span class="nav-number">1.4.1.</span> <span class="nav-text">文件视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#program_header%E7%A8%8B%E5%BA%8F%E5%A4%B4"><span class="nav-number">1.4.2.</span> <span class="nav-text">program_header程序头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E8%A7%86%E5%9B%BE"><span class="nav-number">1.4.3.</span> <span class="nav-text">运行视图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%93%E6%96%87%E4%BB%B6.a-.so"><span class="nav-number">1.5.</span> <span class="nav-text">库文件.a &amp; .so</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E5%A4%B4%E4%B9%8B%E4%BA%89"><span class="nav-number">1.5.1.</span> <span class="nav-text">源头之&quot;争&quot;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">编译阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">链接阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">整个过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E5%88%B0%E6%BA%90%E5%A4%B4%E4%B9%8B%E4%BA%89"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">回到源头之&quot;争&quot;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%8E%E7%A1%AE%E5%88%86%E5%B7%A5"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">明确分工</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8F%AF%E4%BB%A5%E5%86%99%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%90%97"><span class="nav-number">1.5.1.5.1.</span> <span class="nav-text">头文件可以写函数实现吗</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95"><span class="nav-number">1.5.1.5.1.1.</span> <span class="nav-text">正确写法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#main.c"><span class="nav-number">1.5.1.5.1.2.</span> <span class="nav-text">main.c</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#func.h-func.c"><span class="nav-number">1.5.1.5.1.3.</span> <span class="nav-text">func.h &amp; func.c</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#func1.h-func1.c"><span class="nav-number">1.5.1.5.1.4.</span> <span class="nav-text">func1.h &amp; func1.c</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#func2.h-func2.c"><span class="nav-number">1.5.1.5.1.5.</span> <span class="nav-text">func2.h &amp; func2.c</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E9%93%BE%E6%8E%A5"><span class="nav-number">1.5.1.5.1.6.</span> <span class="nav-text">通过链接</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8F%AF%E4%BB%A5%E5%86%99%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%90%97"><span class="nav-number">1.5.1.5.2.</span> <span class="nav-text">头文件可以写全局变量吗</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95-1"><span class="nav-number">1.5.1.5.2.1.</span> <span class="nav-text">正确写法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%AE%8F%E5%AE%9A%E4%B9%89pi"><span class="nav-number">1.5.1.5.2.2.</span> <span class="nav-text">方法一:宏定义PI</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%BD%BF%E7%94%A8extern%E5%BC%95%E7%94%A8"><span class="nav-number">1.5.1.5.2.3.</span> <span class="nav-text">方法二:使用extern引用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#extern-double-pi%E8%83%BD%E5%90%A6%E5%86%99%E5%85%A5%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">1.5.1.5.2.4.</span> <span class="nav-text">extern double PI;能否写入头文件</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">1.5.1.5.3.</span> <span class="nav-text">静态变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93.a"><span class="nav-number">1.5.2.</span> <span class="nav-text">静态库.a</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%B7%E6%BA%90"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">起源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%BA%93ar-rcs-%E9%9D%99%E6%80%81%E5%BA%93%E5%90%8D.a-%E7%BB%84%E6%88%90%E7%9B%AE%E6%A0%871.o-%E7%BB%84%E6%88%90%E7%9B%AE%E6%A0%872.o-...."><span class="nav-number">1.5.2.2.</span> <span class="nav-text">使用静态库ar rcs &lt;静态库名&gt;.a &lt;组成目标1&gt;.o &lt;组成目标2&gt;.o ....</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#geometry.h"><span class="nav-number">1.5.2.2.1.</span> <span class="nav-text">geometry.h</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#point.c"><span class="nav-number">1.5.2.2.2.</span> <span class="nav-text">point.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#line.c"><span class="nav-number">1.5.2.2.3.</span> <span class="nav-text">line.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#main.c-1"><span class="nav-number">1.5.2.2.4.</span> <span class="nav-text">main.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#shellscript.sh"><span class="nav-number">1.5.2.2.5.</span> <span class="nav-text">shellscript.sh</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#a%E5%A6%82%E4%BD%95%E9%93%BE%E6%8E%A5"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">.a如何链接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93.so"><span class="nav-number">1.5.3.</span> <span class="nav-text">动态库.so</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%B7%E6%BA%90-1"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">起源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E9%93%BE%E6%8E%A5"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">动态库的链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">使用动态库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81pic"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">位置无关代码PIC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#pic%E6%95%B0%E6%8D%AE%E5%BC%95%E7%94%A8"><span class="nav-number">1.5.3.4.1.</span> <span class="nav-text">PIC数据引用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#got%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.3.4.1.1.</span> <span class="nav-text">GOT表结构:</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#got%E8%A1%A8%E6%80%8E%E4%B9%88%E5%B9%B2%E6%B4%BB%E7%9A%84"><span class="nav-number">1.5.3.4.1.2.</span> <span class="nav-text">GOT表怎么干活的?</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pic%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">1.5.3.4.2.</span> <span class="nav-text">PIC函数调用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E9%93%BE%E6%8E%A5%E8%A1%A8plt"><span class="nav-number">1.5.3.4.2.1.</span> <span class="nav-text">·过程链接表(PLT)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%81%8F%E7%A7%BB%E9%87%8F%E8%A1%A8got"><span class="nav-number">1.5.3.4.2.2.</span> <span class="nav-text">·全局偏移量表(GOT)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="nav-number">1.5.3.4.3.</span> <span class="nav-text">举个例子</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A6%96%E6%AC%A1%E8%B0%83%E7%94%A8addvec"><span class="nav-number">1.5.3.4.3.1.</span> <span class="nav-text">首次调用addvec</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%B0%83%E7%94%A8addvec"><span class="nav-number">1.5.3.4.3.2.</span> <span class="nav-text">第二次调用addvec</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%93%E6%89%93%E6%A1%A9"><span class="nav-number">1.5.4.</span> <span class="nav-text">库打桩</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91%E6%97%B6%E6%89%93%E6%A1%A9"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">预编译时打桩</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#main.c-2"><span class="nav-number">1.5.4.1.1.</span> <span class="nav-text">main.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#malloc.h"><span class="nav-number">1.5.4.1.2.</span> <span class="nav-text">malloc.h</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mymalloc.c"><span class="nav-number">1.5.4.1.3.</span> <span class="nav-text">mymalloc.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.4.1.4.</span> <span class="nav-text">命令:</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E6%97%B6%E6%89%93%E6%A1%A9"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">链接时打桩</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#main.c-3"><span class="nav-number">1.5.4.2.1.</span> <span class="nav-text">main.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mymalloc.c-1"><span class="nav-number">1.5.4.2.2.</span> <span class="nav-text">mymalloc.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4-1"><span class="nav-number">1.5.4.2.3.</span> <span class="nav-text">命令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%93%E6%A1%A9"><span class="nav-number">1.5.4.3.</span> <span class="nav-text">运行时打桩</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="nav-number">1.5.4.3.1.</span> <span class="nav-text">运行时加载链接共享库</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#dlopen"><span class="nav-number">1.5.4.3.1.1.</span> <span class="nav-text">dlopen</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#dlsym"><span class="nav-number">1.5.4.3.1.2.</span> <span class="nav-text">dlsym</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#dlclose"><span class="nav-number">1.5.4.3.1.3.</span> <span class="nav-text">dlclose</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#dlerror"><span class="nav-number">1.5.4.3.1.4.</span> <span class="nav-text">dlerror</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90-1"><span class="nav-number">1.5.4.3.1.5.</span> <span class="nav-text">举个例子</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%93%E6%A1%A9-1"><span class="nav-number">1.5.4.3.2.</span> <span class="nav-text">运行时打桩</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
