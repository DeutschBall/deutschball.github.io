<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="dustland">
<meta property="og:type" content="website">
<meta property="og:title" content="dustland">
<meta property="og:url" content="http://deutschball.github.io/impossible/page/10/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="dustland">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="dustball">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://deutschball.github.io/impossible/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/05/07/datastruct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/07/datastruct/" class="post-title-link" itemprop="url">数据结构在汇编语言下的表现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-07 17:19:00" itemprop="dateCreated datePublished" datetime="2022-05-07T17:19:00+08:00">2022-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-23 19:19:29" itemprop="dateModified" datetime="2022-05-23T19:19:29+08:00">2022-05-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据结构在汇编语言下的表现">数据结构在汇编语言下的表现</h1>
<h2 id="数组">数组</h2>
<h3 id="栈上数组">栈上数组</h3>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> local_array[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> index=<span class="number">2</span>;</span><br><span class="line">    local_array[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">    local_array[<span class="number">1</span>]=<span class="number">20</span>;</span><br><span class="line">    local_array[<span class="number">2</span>]=<span class="number">30</span>;</span><br><span class="line">    local_array[index]=<span class="number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; </span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -O0 -o main.exe</span><br><span class="line">ida64 main.exe					<span class="comment">#需要将ida的根目录添加到环境变量path</span></span><br></pre></td></tr></table></figure>
<p><code>func</code>函数的反汇编:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 ; 64位windows上不再有__fastcall和_cdecl等调用约定的区别,只有一个同一的微软x64调用约定</span><br><span class="line">.text:0000000000401560 ; Attributes: bp-based frame</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 ; void __fastcall func()</span><br><span class="line">.text:0000000000401560                 public func</span><br><span class="line">.text:0000000000401560 func            proc near               ; CODE XREF: main+D↓p</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 var_10          = dword ptr -10h			</span><br><span class="line">.text:0000000000401560 var_C           = dword ptr -0Ch</span><br><span class="line">.text:0000000000401560 var_8           = dword ptr -8</span><br><span class="line">.text:0000000000401560 var_4           = dword ptr -4</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560                 push    rbp</span><br><span class="line">.text:0000000000401561                 mov     rbp, rsp</span><br><span class="line">.text:0000000000401564                 sub     rsp, 10h        ; 栈上开0x10=16字节的空间,用于存放局部变量(int local_array[3] 数组和int index变量,恰好4个int*一个int占用4字节)</span><br><span class="line">.text:0000000000401568                 mov     [rbp+var_4], 2  ; int index=2,可以判断var_4变量对应index</span><br><span class="line">.text:000000000040156F                 mov     [rbp+var_10], 0Ah ; 0x0Ah=10,对应local_array[0]=10;可以判断var_10对应local_array[0]</span><br><span class="line">.text:0000000000401576                 mov     [rbp+var_C], 14h ; 同理var_C=local_array[1]</span><br><span class="line">.text:000000000040157D                 mov     [rbp+var_8], 1Eh ; 同理var_8=local_array[2]</span><br><span class="line">.text:0000000000401584                 mov     eax, [rbp+var_4] ; 把index变量放在寄存器中,为0x401589的寻址做准备</span><br><span class="line">.text:0000000000401587                 cdqe					  ;将eax寄存器拓展为rax寄存器,该指令只作用于eax寄存器</span><br><span class="line">.text:0000000000401589                 mov     [rbp+rax*4+var_10], 28h ; local_array[index]=40</span><br><span class="line">.text:0000000000401591                 nop</span><br><span class="line">.text:0000000000401592                 add     rsp, 10h			;函数执行完毕,退栈</span><br><span class="line">.text:0000000000401596                 pop     rbp				;还原rbp原始功能</span><br><span class="line">.text:0000000000401597                 retn</span><br><span class="line">.text:0000000000401597 func            endp</span><br><span class="line">.text:0000000000401597</span><br></pre></td></tr></table></figure>
<p>函数栈帧基于rbp帧指针,主函数没有对其传递参数,栈帧中
有返回值,rbp保存值,还有四个变量</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220502203420528.png"
alt="image-20220502203420528" />
<figcaption aria-hidden="true">image-20220502203420528</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220502204300823.png"
alt="image-20220502204300823" />
<figcaption aria-hidden="true">image-20220502204300823</figcaption>
</figure>
<p>源程序中写的数组<code>int local_array[3]</code>被拆成了3个独立的int变量</p>
<p>只有在<code>.text:0000000000401589                 mov     [rbp+rax*4+var_10], 28h</code>这里可以隐约看出实在对数组进行寻址操作</p>
<p><code>var_10(rbp,rax,4)=M[rbp+rax*4+var_10]</code></p>
<p><code>rax</code>中存放的是index的值,用rax*4是因为一个int占4字节,<code>rbp+var_10</code>是数组的基地址,<code>rax*4</code>是偏移量</p>
<p>在分析出<code>var_8,var_C,var_10</code>同属于一个基地址<code>var_10</code>的数组结构后,可以在func函数的栈帧视图下高亮这三个变量,使用右键菜单的<code>array</code>选项将其合并为一个数组</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220502205958995.png"
alt="image-20220502205958995" />
<figcaption aria-hidden="true">image-20220502205958995</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220502205827491.png"
alt="image-20220502205827491" />
<figcaption aria-hidden="true">image-20220502205827491</figcaption>
</figure>
<p>​ 合并后回到反汇编视图</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220502210142961.png"
alt="image-20220502210142961" />
<figcaption aria-hidden="true">image-20220502210142961</figcaption>
</figure>
<p>发现三个变量合并为一个<code>var_10</code>,其地址<code>rbp-10h</code>,刚好和<code>var_4</code>相差<code>0xC=12字节</code>即三个int类型变量</p>
<p>然后可以在反汇编视图下使用右键菜单的<code>rename</code>功能将变量命名有意义</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220502210513069.png"
alt="image-20220502210513069" />
<figcaption aria-hidden="true">image-20220502210513069</figcaption>
</figure>
<p>rename之后后文相关位置都会重新命名</p>
<h3 id="全局数组">全局数组</h3>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_array[<span class="number">3</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> index=<span class="number">2</span>;</span><br><span class="line">    global_array[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">    global_array[<span class="number">1</span>]=<span class="number">20</span>;</span><br><span class="line">    global_array[<span class="number">2</span>]=<span class="number">30</span>;</span><br><span class="line">    local_array[index]=<span class="number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; </span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func</code>函数的反汇编:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 ; Attributes: bp-based frame				;局部变量和参数在栈帧中的地址基于rbp帧指针</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 ; void __fastcall func()</span><br><span class="line">.text:0000000000401560                 public func</span><br><span class="line">.text:0000000000401560 func            proc near               ; CODE XREF: main+D↓p</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 var_4           = dword ptr -4			;局部变量只有一个,只能对应index</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560                 push    rbp</span><br><span class="line">.text:0000000000401561                 mov     rbp, rsp</span><br><span class="line">.text:0000000000401564                 sub     rsp, 10h				</span><br><span class="line">.text:0000000000401568                 mov     [rbp+var_4], 2		;int index=2</span><br><span class="line">.text:000000000040156F                 lea     rax, global_array		;R[rax]=&amp;global_array,将global_array的地址放在rax</span><br><span class="line">.text:0000000000401576                 mov     dword ptr [rax], 0Ah  ;寄存器寻址,然后dword ptr指定双字访问内存,global_array[0]=10</span><br><span class="line">.text:000000000040157C                 lea     rax, global_array	;重复R[rax]=&amp;global_array,目的是防止上一次装载和本次之间rax有变化</span><br><span class="line">.text:0000000000401583                 mov     dword ptr [rax+4], 14h ;寄存器+立即数寻址,双字访问内存</span><br><span class="line">.text:000000000040158A                 lea     rax, global_array</span><br><span class="line">.text:0000000000401591                 mov     dword ptr [rax+8], 1Eh</span><br><span class="line">.text:0000000000401598                 lea     rax, global_array</span><br><span class="line">.text:000000000040159F                 mov     edx, [rbp+var_4]		 ;将var_4的拷贝到edx寄存器中</span><br><span class="line">.text:00000000004015A2                 movsxd  rdx, edx				;edx有符号拓展到rdx</span><br><span class="line">.text:00000000004015A5                 mov     dword ptr [rax+rdx*4], 28h ; 基址比例变址寻址,然后放入40</span><br><span class="line">.text:00000000004015AC                 nop</span><br><span class="line">.text:00000000004015AD                 add     rsp, 10h</span><br><span class="line">.text:00000000004015B1                 pop     rbp</span><br><span class="line">.text:00000000004015B2                 retn</span><br><span class="line">.text:00000000004015B2 func            endp</span><br><span class="line">.text:00000000004015B2</span><br></pre></td></tr></table></figure>
<p>问题是<code>global_array</code>貌似没有体现出声明来就直接使用了,左键双击<code>global_array</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000000000407970                 public global_array</span><br><span class="line">.bss:0000000000407970 global_array     db    ? ;               ; DATA XREF: func+F↑o</span><br><span class="line">.bss:0000000000407970                                         ; func+1C↑o ...</span><br><span class="line">.bss:0000000000407971                 db    ? ;</span><br><span class="line">.bss:0000000000407972                 db    ? ;</span><br><span class="line">.bss:0000000000407973                 db    ? ;</span><br><span class="line">.bss:0000000000407974                 db    ? ;</span><br><span class="line">.bss:0000000000407975                 db    ? ;</span><br><span class="line">.bss:0000000000407976                 db    ? ;</span><br><span class="line">.bss:0000000000407977                 db    ? ;</span><br><span class="line">.bss:0000000000407978                 db    ? ;</span><br><span class="line">.bss:0000000000407979                 db    ? ;</span><br><span class="line">.bss:000000000040797A                 db    ? ;</span><br><span class="line">.bss:000000000040797B                 db    ? ;</span><br><span class="line">.bss:000000000040797C                 db    ? ;</span><br><span class="line">.bss:000000000040797D                 db    ? ;</span><br><span class="line">.bss:000000000040797E                 db    ? ;</span><br><span class="line">.bss:000000000040797F                 db    ? ;</span><br></pre></td></tr></table></figure>
<p>发现<code>global_array</code>是位于bss段的,确实<code>global_array</code>在声明的时候并没有初始化,就应该放在bss段</p>
<p><code>global_array</code>以<code>db=define byte</code>即字节为单位,在bss段留了<code>0407970~040797F</code>一共16个字节的空间</p>
<p>如果在<code>func</code>函数的反汇编视图下修改<code>global_array</code>的名字改成空即显示ida给他命的哑名<code>unk_407970</code>,unk为unknown未知的缩写</p>
<p>如果在源代码中不写全局函数<code>global_array</code>,改用三个int类型变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> l0;</span><br><span class="line"><span class="type">int</span> l1;</span><br><span class="line"><span class="type">int</span> l2;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    l0=<span class="number">10</span>;</span><br><span class="line">    l1=<span class="number">20</span>;</span><br><span class="line">    l2=<span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; </span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时三个全局变量在bss段中的分布</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000000000407970                 public l2</span><br><span class="line">.bss:0000000000407970 l2              db    ? ;               ; DATA XREF: func+1E↑o</span><br><span class="line">.bss:0000000000407971                 db    ? ;</span><br><span class="line">.bss:0000000000407972                 db    ? ;</span><br><span class="line">.bss:0000000000407973                 db    ? ;</span><br><span class="line">.bss:0000000000407974                 public l0</span><br><span class="line">.bss:0000000000407974 l0              db    ? ;               ; DATA XREF: func+4↑o</span><br><span class="line">.bss:0000000000407975                 db    ? ;</span><br><span class="line">.bss:0000000000407976                 db    ? ;</span><br><span class="line">.bss:0000000000407977                 db    ? ;</span><br><span class="line">.bss:0000000000407978                 public l1</span><br><span class="line">.bss:0000000000407978 l1              db    ? ;               ; DATA XREF: func+11↑o</span><br><span class="line">.bss:0000000000407979                 db    ? ;</span><br><span class="line">.bss:000000000040797A                 db    ? ;</span><br><span class="line">.bss:000000000040797B                 db    ? ;</span><br><span class="line">.bss:000000000040797C                 db    ? ;</span><br><span class="line">.bss:000000000040797D                 db    ? ;</span><br><span class="line">.bss:000000000040797E                 db    ? ;</span><br><span class="line">.bss:000000000040797F                 db    ? ;</span><br><span class="line">.bss:0000000000407980                 public __native_startup_state</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>很诡异的是三个变量的分布是没有顺序的,l2和l0都分到了4个db即4字节的空间,但是l1却分到了8字节的空间</p>
<p>如果试图使用<code>*(&amp;l0+2)</code>来得到l2实际上会算得<code>*(0x407974+2*sizeof(int))=*(0x40797C)</code></p>
<p>而实际上<code>l2</code>在<code>0x407970</code>,刚才指针运算得到的值是属于l1"管理"的</p>
<h3 id="堆上数组">堆上数组</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> *heap_array=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> index=<span class="number">2</span>;</span><br><span class="line">    heap_array[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">    heap_array[<span class="number">1</span>]=<span class="number">20</span>;</span><br><span class="line">    heap_array[<span class="number">2</span>]=<span class="number">30</span>;</span><br><span class="line">    heap_array[index]=<span class="number">40</span>;</span><br><span class="line">    <span class="built_in">free</span>(heap_array);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; </span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func</code>函数反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 ; Attributes: bp-based frame</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560                 public func</span><br><span class="line">.text:0000000000401560 func            proc near               ; CODE XREF: main+D↓p</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 var_C           = dword ptr -0Ch			;var_C显然为index</span><br><span class="line">.text:0000000000401560 Block           = qword ptr -8			;Block为堆上申请空间的指针</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560                 push    rbp</span><br><span class="line">.text:0000000000401561                 mov     rbp, rsp</span><br><span class="line">.text:0000000000401564                 sub     rsp, 30h		;蜜汁操作,栈上分配了0x30h=48字节的巨大空间,但是只有两个局部变量</span><br><span class="line">.text:0000000000401568                 mov     ecx, 0Ch        ; Size,第一个参数使用ecx寄存器传递,这里0x0C=12字节相当于给出了堆上数组的大小</span><br><span class="line">.text:000000000040156D                 call    malloc			;malloc遵守 微软64位调用约定</span><br><span class="line">.text:0000000000401572                 mov     [rbp+Block], rax	;rax寄存器带着malloc函数的返回值,即堆上地址的指针,赋值给Block</span><br><span class="line">.text:0000000000401576                 mov     [rbp+var_C], 2	;int index=2</span><br><span class="line">.text:000000000040157D                 mov     rax, [rbp+Block]	;将堆上指针放到rax中</span><br><span class="line">.text:0000000000401581                 mov     dword ptr [rax], 0Ah	;字访问rax指向的地址,放入10</span><br><span class="line">.text:0000000000401587                 mov     rax, [rbp+Block]		;将堆上指针再次放到rax中</span><br><span class="line">.text:000000000040158B                 add     rax, 4				;rax中的指针副本后移4字节,恰好移过一个int</span><br><span class="line">.text:000000000040158F                 mov     dword ptr [rax], 14h		;单字访问rax指向的地址,放入20</span><br><span class="line">.text:0000000000401595                 mov     rax, [rbp+Block]	</span><br><span class="line">.text:0000000000401599                 add     rax, 8</span><br><span class="line">.text:000000000040159D                 mov     dword ptr [rax], 1Eh</span><br><span class="line">.text:00000000004015A3                 mov     eax, [rbp+var_C]			;将index放到eax中</span><br><span class="line">.text:00000000004015A6                 cdqe								;拓展eax到rax</span><br><span class="line">.text:00000000004015A8                 lea     rdx, ds:0[rax*4]			;将ds:0+rax*4这个地址放到rdx寄存器</span><br><span class="line">.text:00000000004015B0                 mov     rax, [rbp+Block]			;rax寄存器获得Block堆指针的拷贝</span><br><span class="line">.text:00000000004015B4                 add     rax, rdx					;rax指向Block+4*rax即heap_array[index]</span><br><span class="line">.text:00000000004015B7                 mov     dword ptr [rax], 28h ; 单字访问rax指向的地址,放入40</span><br><span class="line">.text:00000000004015BD                 mov     rax, [rbp+Block]			;rax获得Block堆指针拷贝</span><br><span class="line">.text:00000000004015C1                 mov     rcx, rax        ; rcx获得拷贝,准备作为参数传递给free函数</span><br><span class="line">.text:00000000004015C4                 call    free</span><br><span class="line">.text:00000000004015C9                 nop</span><br><span class="line">.text:00000000004015CA                 add     rsp, 30h</span><br><span class="line">.text:00000000004015CE                 pop     rbp</span><br><span class="line">.text:00000000004015CF                 retn</span><br><span class="line">.text:00000000004015CF func            endp</span><br><span class="line">.text:00000000004015CF</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://diveintosystems.org/book/C2-C_depth/_images/program_memory.png"
alt="The parts of program memory showing a stack variable pointing to dynamically allocated heap memory." />
<figcaption aria-hidden="true">The parts of program memory showing a
stack variable pointing to dynamically allocated heap
memory.</figcaption>
</figure>
<p>堆上数组的特征还是比较明显的</p>
<p>综上,使用变量下标访问数组时更容易察觉数组结构的存在,而使用常量下标访问数组时汇更像访问独立的变量</p>
<h2 id="结构体">结构体</h2>
<h3 id="对齐">对齐</h3>
<p>对齐在大多数情况下不是硬性要求,不对齐的话x86-64的硬件也是可以干活的,</p>
<p>但是为了提高性能intel建议对齐,编译器默认情况下是会自动对齐的</p>
<h4 id="基本数据类型的对齐规则">基本数据类型的对齐规则:</h4>
<p>某种类型的对象,其地址必须是K的倍数</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220503010303191.png"
alt="image-20220503010303191" />
<figcaption aria-hidden="true">image-20220503010303191</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> achar;</span><br><span class="line">	<span class="type">char</span> bchar;</span><br><span class="line">	<span class="type">int</span> aint;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x,%x,%x&quot;</span>, &amp;achar, &amp;bchar, &amp;aint);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -O0 -g -o main.out</span><br><span class="line">gdb -tui -q main.out</span><br></pre></td></tr></table></figure>
<p>使用gdb进行调试,观察运行时的堆栈</p>
<p>1.在func函数处下断点</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220503013023486.png"
alt="image-20220503013023486" />
<figcaption aria-hidden="true">image-20220503013023486</figcaption>
</figure>
<p>2.在断点处停下,打印观察</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /mnt/c/Users/86135/Desktop/reverse/mytest/main.exe</span><br><span class="line"></span><br><span class="line">Breakpoint 1, func () at main.c:7</span><br><span class="line">(gdb) p <span class="variable">$rbp</span></span><br><span class="line"><span class="variable">$1</span> = (void *) 0x7fffffffdc90</span><br><span class="line">(gdb) p &amp;achar</span><br><span class="line"><span class="variable">$2</span> = 0x7fffffffdc8f <span class="string">&quot;&quot;</span></span><br><span class="line">(gdb) p &amp;bchar</span><br><span class="line"><span class="variable">$3</span> = 0x7fffffffdc8e <span class="string">&quot;&quot;</span></span><br><span class="line">(gdb) p &amp;aint</span><br><span class="line"><span class="variable">$4</span> = (int *) 0x7fffffffdc88</span><br></pre></td></tr></table></figure>
<p>帧指针<code>rbp</code>指向<code>0x7fffffffdc90</code></p>
<p>achar是一个char类型,无对齐要求,必然在紧接着帧指针下方<code>0x7fffffffdc8f</code>,bchar同理在achar下方<code>0x7fffffffdc8e</code></p>
<p>但是aint并没有紧挨着bchar在<code>0x7fffffffdc8d</code>,而是在<code>0x7fffffffdc88</code></p>
<p>栈向下增长,但是小端模式下,栈中的元素的起始位置是低地址,然后向高地址增长,比如aint就从<code>0x7fffffffdc88</code>然后向高地址增长直到<code>0x7fffffffdc8b</code></p>
<p><code>func</code>函数的栈帧:</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>相对rbp的偏移量</th>
<th>存储内容</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>1</code></td>
<td>返回值地址</td>
</tr>
<tr>
<td><code>0x7fffffffdc90</code></td>
<td><code>0</code></td>
<td><code>rbp</code>帧指针保存地址</td>
</tr>
<tr>
<td><code>0x7fffffffdc8f</code></td>
<td><code>-1</code></td>
<td><code>achar</code></td>
</tr>
<tr>
<td><code>0x7fffffffdc8e</code></td>
<td><code>-2</code></td>
<td><code>bchar</code></td>
</tr>
<tr>
<td></td>
<td><code>-3</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>-4</code></td>
<td></td>
</tr>
<tr>
<td><code>0x7fffffffdc8b</code></td>
<td><code>-5</code></td>
<td><code>aint</code>高位</td>
</tr>
<tr>
<td></td>
<td><code>-6</code></td>
<td><code>aint</code></td>
</tr>
<tr>
<td></td>
<td><code>-7</code></td>
<td><code>aint</code></td>
</tr>
<tr>
<td><code>0x7fffffffdc88</code></td>
<td><code>-8</code></td>
<td><code>aint</code>低位</td>
</tr>
<tr>
<td></td>
<td><code>-9</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>-10</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>...</td>
<td></td>
</tr>
<tr>
<td></td>
<td>...</td>
<td></td>
</tr>
</tbody>
</table>
<p>这里aint就没有从-6到-3,而是为了对齐采用-8到-5</p>
<blockquote>
<h4 id="小端模式">小端模式</h4>
<p>小端模式:假如<code>int aint=10d=0xAh=0x0000 0000 0000 0000 0000 0000 0000 1010 b</code></p>
<p>那么<code>0x7fffffffdc88</code>这个低地址上应该存放<code>aint</code>的低八位即<code>0000 1010b=0x10h</code></p>
<p>为了观察这个事情</p>
<p>使用几乎相同的程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">char</span> achar;</span><br><span class="line">	<span class="type">char</span> bchar;</span><br><span class="line">	<span class="type">int</span> aint=<span class="number">10</span>;<span class="comment">//注意此处给aint赋值10,小端模式下应该存放在&amp;aint的第一个字节单元</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x,%x,%x&quot;</span>, &amp;achar, &amp;bchar, &amp;aint);</span><br><span class="line"> <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	func();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用gdb在第7行下断点,然后运行到第七行的时候停下,打印&amp;aint,结果为<code>0x7fffffffe2e8</code>,然后<code>x/1 0x7fffffffe2e8</code>打印从该地址开始的第一个单元(单位字节)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220503020706566.png"
alt="image-20220503020706566" />
<figcaption aria-hidden="true">image-20220503020706566</figcaption>
</figure>
<p>结果为10,即证明低地址存放低位,小端模式</p>
</blockquote>
<h4 id="结构体的对齐规则">结构体的对齐规则</h4>
<p>结构体各项目依然满足基本数据类型的对齐方式</p>
<p>结构体自身也有对齐要求,其==基地址必须是最大成员大小的整数倍==</p>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> name;</span><br><span class="line">	<span class="type">int</span> from;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">&#125;Edge;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> a ;</span><br><span class="line">	Edge e;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x,%x,%x&quot;</span>,&amp;a,&amp;e,&amp;b);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;	</span><br><span class="line">	func();</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -O0 -g -o main.exe</span><br><span class="line">gdb -tui -q main.exe</span><br></pre></td></tr></table></figure>
<p>在<code>func</code>函数处下断点然后在该断点处停下,打印观察</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p &amp;e</span><br><span class="line"><span class="variable">$4</span> = (Edge *) 0x7fffffffdc80</span><br><span class="line">(gdb) p &amp;e.name</span><br><span class="line"><span class="variable">$5</span> = 0x7fffffffdc80 <span class="string">&quot;&quot;</span>						;e.name的位置</span><br><span class="line">(gdb) p &amp;e.from</span><br><span class="line"><span class="variable">$6</span> = (int *) 0x7fffffffdc84					;e.from的位置</span><br><span class="line">(gdb) p &amp;e.to</span><br><span class="line"><span class="variable">$7</span> = (int *) 0x7fffffffdc88					;e.to的位置</span><br><span class="line">(gdb) p &amp;b</span><br><span class="line"><span class="variable">$8</span> = 0x7fffffffdc7f <span class="string">&quot;&quot;</span>						;char b的位置</span><br><span class="line">(gdb) p &amp;a</span><br><span class="line"><span class="variable">$9</span> = 0x7fffffffdc8f <span class="string">&quot;&quot;</span>					    ;char a的位置</span><br><span class="line">(gdb) p <span class="variable">$rbp</span></span><br><span class="line"><span class="variable">$10</span> = (void *) 0x7fffffffdc90				;帧指针位置</span><br></pre></td></tr></table></figure>
<p><code>func</code>函数的栈帧</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220503111359404.png"
alt="image-20220503111359404" />
<figcaption aria-hidden="true">image-20220503111359404</figcaption>
</figure>
<p><strong>首先在结构体内部安排对齐</strong>:</p>
<p><code>name</code>放在偏移量为0的位置,然后<code>int from</code>放在偏移量为4的倍数的最小位置,显然是4,然后<code>int to</code>同理放在8,from和name之间就空出了3字节,原因就是考虑对齐</p>
<p><strong>然后对结构体整体安排对齐</strong>:</p>
<blockquote>
<p><strong>为什么要进行整体对齐?</strong></p>
<p>如果不进行此步,只进行内部对齐,那么考虑如下情形</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220503112100035.png"
alt="image-20220503112100035" />
<figcaption aria-hidden="true">image-20220503112100035</figcaption>
</figure>
<p>左右两种排列方法均满足结构体内对齐,对于右侧,<code>e.from</code>的起始地址是<code>0x7fffffffdc85</code>显然不满足int的对齐规则,而左侧经过整体对齐,<code>e.from</code>在<code>0x7fffffffdc84</code>是可以整除4的,满足int的对齐规则</p>
<p>此时sizeof(e)=12,而不是1+4+4=9</p>
</blockquote>
<p>整体对齐要求结构体的起始地址必须是最大成员大小的整数倍,在这里是int,4字节</p>
<p>因此结构体e的起始地址应当是能够整除4的并且距离rbp最近的并且能够放得下结构体e的地方,显然是<code>0x7fffffffdc80</code></p>
<blockquote>
<p>整体对齐只是考虑了最大成员大小的整数倍,一定能保证所有成员的对齐吗?</p>
<p>由于任意基本数据类型的大小都是2的幂次,因此最大成员的大小一定是任意成员大小的整数倍,那么起始地址是最大成员大小的整数倍的同时,也一定是任意成员大小的整数倍</p>
</blockquote>
<h4 id="pragma-packn指定对齐">#pragma pack(n)指定对齐</h4>
<p>如果不写该语句则默认n=8字节对齐,所有对象的对齐方式改为:</p>
<p>地址值是<span
class="math inline">\(min\{自己大小,n\}的整数倍\)</span></p>
<p>同样的程序在一开始时加入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br></pre></td></tr></table></figure>
<p>指定一字节对齐,任意对象的地址是<span
class="math inline">\(min\{自己大小,1\}的整数倍=1的整数倍\)</span>,即没有对齐</p>
<p>然后使用gdb调试观察</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p <span class="variable">$rbp</span></span><br><span class="line"><span class="variable">$1</span> = (void *) 0x7fffffffe2f0</span><br><span class="line">(gdb) p sizeof(e)</span><br><span class="line"><span class="variable">$2</span> = 9</span><br><span class="line">(gdb) p &amp;a</span><br><span class="line"><span class="variable">$3</span> = 0x7fffffffe2ef <span class="string">&quot;&quot;</span></span><br><span class="line">(gdb) p &amp;b</span><br><span class="line"><span class="variable">$4</span> = 0x7fffffffe2e5 <span class="string">&quot;&quot;</span></span><br><span class="line">(gdb) p &amp;e.name</span><br><span class="line"><span class="variable">$5</span> = 0x7fffffffe2e6 <span class="string">&quot;&quot;</span></span><br><span class="line">(gdb) p &amp;e.from</span><br><span class="line"><span class="variable">$6</span> = (int *) 0x7fffffffe2e7</span><br><span class="line">(gdb) p &amp;e.to</span><br><span class="line"><span class="variable">$7</span> = (int *) 0x7fffffffe2eb</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220503115539724.png"
alt="image-20220503115539724" />
<figcaption aria-hidden="true">image-20220503115539724</figcaption>
</figure>
<p>此时栈帧就非常紧凑了,从rbp向下顺次紧密排列</p>
<blockquote>
<p>反汇编观察栈的分布</p>
<p>无对齐时的func函数的反汇编视图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001139 func            proc near               ; CODE XREF: main+9↓p</span><br><span class="line">.text:0000000000001139</span><br><span class="line">.text:0000000000001139 var_B           = byte ptr -0Bh</span><br><span class="line">.text:0000000000001139 var_A           = byte ptr -0Ah		;var_A放在rbp-10</span><br><span class="line">.text:0000000000001139 var_1           = byte ptr -1</span><br><span class="line">.text:0000000000001139</span><br><span class="line">.text:0000000000001139 ; __unwind &#123;</span><br><span class="line">.text:0000000000001139                 push    rbp</span><br><span class="line">.text:000000000000113A                 mov     rbp, rsp</span><br><span class="line">.text:000000000000113D                 sub     rsp, 10h				;此处申请了16字节的栈空间</span><br><span class="line">.text:0000000000001141                 lea     rcx, [rbp+var_B]</span><br><span class="line">.text:0000000000001145                 lea     rdx, [rbp+var_A]</span><br><span class="line">.text:0000000000001149                 lea     rax, [rbp+var_1]</span><br><span class="line">.text:000000000000114D                 mov     rsi, rax</span><br><span class="line">.text:0000000000001150                 lea     rax, format     ; &quot;%x,%x,%x&quot;</span><br><span class="line">.text:0000000000001157                 mov     rdi, rax        ; format</span><br><span class="line">.text:000000000000115A                 mov     eax, 0</span><br><span class="line">.text:000000000000115F                 call    _printf</span><br><span class="line">.text:0000000000001164                 nop</span><br><span class="line">.text:0000000000001165                 leave</span><br><span class="line">.text:0000000000001166                 retn</span><br><span class="line">.text:0000000000001166 ; &#125; // starts at 1139</span><br><span class="line">.text:0000000000001166 func            endp</span><br></pre></td></tr></table></figure>
<p>默认对齐时的<code>func</code>函数反汇编视图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001139 func            proc near               ; CODE XREF: main+9↓p</span><br><span class="line">.text:0000000000001139</span><br><span class="line">.text:0000000000001139 var_11          = byte ptr -11h</span><br><span class="line">.text:0000000000001139 var_10          = byte ptr -10h			;var_10放在rbp-16</span><br><span class="line">.text:0000000000001139 var_1           = byte ptr -1</span><br><span class="line">.text:0000000000001139</span><br><span class="line">.text:0000000000001139 ; __unwind &#123;</span><br><span class="line">.text:0000000000001139                 push    rbp</span><br><span class="line">.text:000000000000113A                 mov     rbp, rsp</span><br><span class="line">.text:000000000000113D                 sub     rsp, 20h			;此处申请了32字节的栈空间</span><br><span class="line">.text:0000000000001141                 lea     rcx, [rbp+var_11]</span><br><span class="line">.text:0000000000001145                 lea     rdx, [rbp+var_10]</span><br><span class="line">.text:0000000000001149                 lea     rax, [rbp+var_1]</span><br><span class="line">.text:000000000000114D                 mov     rsi, rax</span><br><span class="line">.text:0000000000001150                 lea     rax, format     ; &quot;%x,%x,%x&quot;</span><br><span class="line">.text:0000000000001157                 mov     rdi, rax        ; format</span><br><span class="line">.text:000000000000115A                 mov     eax, 0</span><br><span class="line">.text:000000000000115F                 call    _printf</span><br><span class="line">.text:0000000000001164                 nop</span><br><span class="line">.text:0000000000001165                 leave</span><br><span class="line">.text:0000000000001166                 retn</span><br><span class="line">.text:0000000000001166 ; &#125; // starts at 1139</span><br><span class="line">.text:0000000000001166 func            endp</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="全局结构体">全局结构体</h4>
<p>以网络流中可能会用到的边结构体举例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> from;		<span class="comment">//源</span></span><br><span class="line">	<span class="type">int</span> to;			<span class="comment">//目的</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> dist;<span class="comment">//距离</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> flow;<span class="comment">//流量</span></span><br><span class="line">&#125;Edge;<span class="comment">//边结构体</span></span><br><span class="line"></span><br><span class="line">Edge e;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;<span class="comment">//初始化边e</span></span><br><span class="line">	e.from=<span class="number">1</span>;</span><br><span class="line">	e.to=<span class="number">2</span>;</span><br><span class="line">	e.dist=<span class="number">1e12</span>;</span><br><span class="line">	e.flow=<span class="number">1e13</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5
id="ida观察带gdb调试信息的exe文件">ida观察带gdb调试信息的exe文件</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -g -O0 -o main.exe</span><br><span class="line">ida64 main.exe</span><br></pre></td></tr></table></figure>
<p><code>init</code>函数的反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401560 ; void __cdecl init()</span><br><span class="line">.text:0000000000401560                 public init</span><br><span class="line">.text:0000000000401560 init            proc near               ; CODE XREF: main+D↓p</span><br><span class="line">.text:0000000000401560                 push    rbp</span><br><span class="line">.text:0000000000401561                 mov     rbp, rsp</span><br><span class="line">.text:0000000000401564                 lea     rax, e			;把e的地址放在rax中</span><br><span class="line">.text:000000000040156B                 mov     dword ptr [rax], 1	;把1放在rax指向地址的第一个字</span><br><span class="line">.text:0000000000401571                 lea     rax, e				</span><br><span class="line">.text:0000000000401578                 mov     dword ptr [rax+4], 2	;把2放在rax指向地址偏移4字节之后的字中</span><br><span class="line">.text:000000000040157F                 lea     rax, e</span><br><span class="line">.text:0000000000401586                 mov     rdx, 0E8D4A51000h	;把1e12放在rdx中</span><br><span class="line">.text:0000000000401590                 mov     [rax+8], rdx			;把rdx中的值放在rax+8位置,宽度以rdx的64位为准</span><br><span class="line">.text:0000000000401594                 lea     rax, e</span><br><span class="line">.text:000000000040159B                 mov     rcx, 9184E72A000h	;把1e13放在rcx中</span><br><span class="line">.text:00000000004015A5                 mov     [rax+10h], rcx		;把rcx中的值放在rax+10位置,64位宽</span><br><span class="line">.text:00000000004015A9                 nop</span><br><span class="line">.text:00000000004015AA                 pop     rbp</span><br><span class="line">.text:00000000004015AB                 retn</span><br><span class="line">.text:00000000004015AB init            endp</span><br></pre></td></tr></table></figure>
<p>值得庆幸的是e被ida识别为一个Edge结构体的对象,这是因为使用<code>gcc -g</code>命令,编译形成的exe带有gbd调试信息</p>
<p>可以看出使用e的基地址+成员的偏移量进行结构体成员访问</p>
<p>其中e在bss段:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000000000407970                 public e</span><br><span class="line">.bss:0000000000407970 ; Edge e</span><br><span class="line">.bss:0000000000407970 e               Edge &lt;?&gt;                ; DATA XREF: init+4↑o</span><br><span class="line">.bss:0000000000407970                                         ; init+11↑o ...</span><br><span class="line">.bss:0000000000407988                 public __native_startup_state</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>e在bss段的地址<code>[0x407970,407987]</code>共24字节</p>
<blockquote>
<p>默认8字节对齐下,最大成员long
long正好8字节,因此任何成员都是按照地址是自己大小倍数进行对齐的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> from;		<span class="comment">//源</span></span><br><span class="line">	<span class="type">int</span> to;			<span class="comment">//目的</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> dist;<span class="comment">//距离</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> flow;<span class="comment">//流量</span></span><br><span class="line">&#125;Edge;<span class="comment">//边结构体</span></span><br></pre></td></tr></table></figure>
<p>from和to恰好占用第一个8字节,然后dist占用第二个8字节,然后flow占用第三个8字节,合计24字节</p>
</blockquote>
<p>双击Edge可以观察其Structures视图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000 Edge            struc ; (sizeof=0x18, align=0x8, copyof_102)	;大小0x18=24字节,8字节对齐</span><br><span class="line">00000000                                         ; XREF: .bss:e/r</span><br><span class="line">00000000 from            dd ?	;dword双字类型</span><br><span class="line">00000004 to              dd ?	;dword双字类型</span><br><span class="line">00000008 dist            dq ?	;quad四字类型</span><br><span class="line">00000010 flow            dq ?	;quad四字类型</span><br><span class="line">00000018 Edge            ends</span><br></pre></td></tr></table></figure>
<h5 id="ida观察不带调试信息的exe">ida观察不带调试信息的exe</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -O0 -o main.exe			;不使用-g</span><br><span class="line">ida64 main.exe</span><br></pre></td></tr></table></figure>
<p><code>init</code>函数的反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401560                 public init</span><br><span class="line">.text:0000000000401560 init            proc near               ; CODE XREF: main+D↓p</span><br><span class="line">.text:0000000000401560                 push    rbp</span><br><span class="line">.text:0000000000401561                 mov     rbp, rsp</span><br><span class="line">.text:0000000000401564                 lea     rax, e</span><br><span class="line">.text:000000000040156B                 mov     dword ptr [rax], 1</span><br><span class="line">.text:0000000000401571                 lea     rax, e</span><br><span class="line">.text:0000000000401578                 mov     dword ptr [rax+4], 2</span><br><span class="line">.text:000000000040157F                 lea     rax, e</span><br><span class="line">.text:0000000000401586                 mov     rdx, 0E8D4A51000h</span><br><span class="line">.text:0000000000401590                 mov     [rax+8], rdx</span><br><span class="line">.text:0000000000401594                 lea     rax, e</span><br><span class="line">.text:000000000040159B                 mov     rcx, 9184E72A000h</span><br><span class="line">.text:00000000004015A5                 mov     [rax+10h], rcx</span><br><span class="line">.text:00000000004015A9                 nop</span><br><span class="line">.text:00000000004015AA                 pop     rbp</span><br><span class="line">.text:00000000004015AB                 retn</span><br><span class="line">.text:00000000004015AB init            endp</span><br></pre></td></tr></table></figure>
<p>到此和刚才带有调试信息的情况几乎相同,但是当我们双击e试图观察e是个什么东西时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000000000407970                 public e</span><br><span class="line">.bss:0000000000407970 e               db    ? ;               ; DATA XREF: init+4↑o</span><br><span class="line">.bss:0000000000407970                                         ; init+11↑o ...</span><br><span class="line">.bss:0000000000407971                 db    ? ;</span><br><span class="line">.bss:0000000000407972                 db    ? ;</span><br><span class="line">.bss:0000000000407973                 db    ? ;</span><br><span class="line">.bss:0000000000407974                 db    ? ;</span><br><span class="line">.bss:0000000000407975                 db    ? ;</span><br><span class="line">.bss:0000000000407976                 db    ? ;</span><br><span class="line">.bss:0000000000407977                 db    ? ;</span><br><span class="line">.bss:0000000000407978                 db    ? ;</span><br><span class="line">.bss:0000000000407979                 db    ? ;</span><br><span class="line">.bss:000000000040797A                 db    ? ;</span><br><span class="line">.bss:000000000040797B                 db    ? ;</span><br><span class="line">.bss:000000000040797C                 db    ? ;</span><br><span class="line">.bss:000000000040797D                 db    ? ;</span><br><span class="line">.bss:000000000040797E                 db    ? ;</span><br><span class="line">.bss:000000000040797F                 db    ? ;</span><br><span class="line">.bss:0000000000407980                 db    ? ;</span><br><span class="line">.bss:0000000000407981                 db    ? ;</span><br><span class="line">.bss:0000000000407982                 db    ? ;</span><br><span class="line">.bss:0000000000407983                 db    ? ;</span><br><span class="line">.bss:0000000000407984                 db    ? ;</span><br><span class="line">.bss:0000000000407985                 db    ? ;</span><br><span class="line">.bss:0000000000407986                 db    ? ;</span><br><span class="line">.bss:0000000000407987                 db    ? ;</span><br><span class="line">.bss:0000000000407988                 public __native_startup_state</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>e退化为bss段上的24个字节,看不出结构体的痕迹了,</p>
<p>但是至少我们可以知道有这么一个叫做e的集合,它管理着24个字节</p>
<p>此时的结构体更像是一个鱼龙混杂的数组,有着不同大小的元素</p>
<h4 id="栈上结构体">栈上结构体</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> from;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> dist;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> flow;</span><br><span class="line">&#125;Edge;</span><br><span class="line">Edge <span class="title function_">newEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">long</span> <span class="type">long</span> d,<span class="type">long</span> <span class="type">long</span> f)</span>&#123;<span class="comment">//获取新的边对象,功能模仿构造函数</span></span><br><span class="line">	Edge e;</span><br><span class="line">	e.from=u;</span><br><span class="line">	e.to=v;</span><br><span class="line">	e.dist=d;</span><br><span class="line">	e.flow=f;</span><br><span class="line">	<span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Edge e=newEdge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1e12</span>,<span class="number">1e13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="带调试信息">带调试信息</h5>
<p><code>newEdge</code>函数的反汇编视图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401560 ; Edge *__cdecl newEdge(Edge *__return_ptr __struct_ptr retstr, int u, int v, __int64 d, __int64 f)</span><br><span class="line">.text:0000000000401560                 public newEdge</span><br><span class="line">.text:0000000000401560 newEdge         proc near               ; CODE XREF: main+38↓p</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560 e               = Edge ptr -20h			;可以识别出结构体e</span><br><span class="line">.text:0000000000401560 arg_0           = qword ptr  10h			;蜜汁操作,多一个arg_0参数</span><br><span class="line">.text:0000000000401560 u               = dword ptr  18h			;由于带调试信息,ida认识四个参数名</span><br><span class="line">.text:0000000000401560 v               = dword ptr  20h</span><br><span class="line">.text:0000000000401560 d               = qword ptr  28h</span><br><span class="line">.text:0000000000401560 f               = qword ptr  30h</span><br><span class="line">.text:0000000000401560</span><br><span class="line">.text:0000000000401560                 push    rbp</span><br><span class="line">.text:0000000000401561                 mov     rbp, rsp</span><br><span class="line">.text:0000000000401564                 sub     rsp, 20h</span><br><span class="line">.text:0000000000401568                 mov     [rbp+arg_0], rcx</span><br><span class="line">.text:000000000040156C                 mov     [rbp+u], edx</span><br><span class="line">.text:000000000040156F                 mov     [rbp+v], r8d</span><br><span class="line">.text:0000000000401573                 mov     [rbp+d], r9</span><br><span class="line">.text:0000000000401577                 mov     eax, [rbp+u]</span><br><span class="line">.text:000000000040157A                 mov     [rbp+e.from], eax</span><br><span class="line">.text:000000000040157D                 mov     eax, [rbp+v]</span><br><span class="line">.text:0000000000401580                 mov     [rbp+e.to], eax</span><br><span class="line">.text:0000000000401583                 mov     rax, [rbp+d]</span><br><span class="line">.text:0000000000401587                 mov     [rbp+e.dist], rax</span><br><span class="line">.text:000000000040158B                 mov     rax, [rbp+f]</span><br><span class="line">.text:000000000040158F                 mov     [rbp+e.flow], rax</span><br><span class="line">.text:0000000000401593                 mov     rcx, [rbp+arg_0]</span><br><span class="line">.text:0000000000401597                 mov     rax, qword ptr [rbp+e.from]</span><br><span class="line">.text:000000000040159B                 mov     rdx, [rbp+e.dist]</span><br><span class="line">.text:000000000040159F                 mov     [rcx], rax</span><br><span class="line">.text:00000000004015A2                 mov     [rcx+8], rdx</span><br><span class="line">.text:00000000004015A6                 mov     rax, [rbp+e.flow]</span><br><span class="line">.text:00000000004015AA                 mov     [rcx+10h], rax</span><br><span class="line">.text:00000000004015AE                 mov     rax, [rbp+arg_0]</span><br><span class="line">.text:00000000004015B2                 add     rsp, 20h</span><br><span class="line">.text:00000000004015B6                 pop     rbp</span><br><span class="line">.text:00000000004015B7                 retn</span><br><span class="line">.text:00000000004015B7 newEdge         endp</span><br></pre></td></tr></table></figure>
<h5 id="不带调试信息">不带调试信息</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> from;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> dist;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> flow;</span><br><span class="line">&#125;Edge;</span><br><span class="line">Edge <span class="title function_">newEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">long</span> <span class="type">long</span> d,<span class="type">long</span> <span class="type">long</span> f)</span>&#123;<span class="comment">//获取新的边对象,功能模仿构造函数</span></span><br><span class="line">	Edge e;</span><br><span class="line">	e.from=u;</span><br><span class="line">	e.to=v;</span><br><span class="line">	e.dist=d;</span><br><span class="line">	e.flow=f;</span><br><span class="line">	<span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Edge e=newEdge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1e12</span>,<span class="number">1e13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main</code>函数反汇编视图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004015B8 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00000000004015B8                 public main</span><br><span class="line">.text:00000000004015B8 main            proc near               ; CODE XREF: __tmainCRTStartup+22F↑p</span><br><span class="line">.text:00000000004015B8</span><br><span class="line">.text:00000000004015B8 var_30          = qword ptr -30h			</span><br><span class="line">.text:00000000004015B8 var_20          = byte ptr -20h</span><br><span class="line">.text:00000000004015B8</span><br><span class="line">.text:00000000004015B8                 push    rbp</span><br><span class="line">.text:00000000004015B9                 mov     rbp, rsp</span><br><span class="line">.text:00000000004015BC                 sub     rsp, 50h				</span><br><span class="line">.text:00000000004015C0                 call    __main				</span><br><span class="line">.text:00000000004015C5                 lea     rax, [rbp+var_20]	;&amp;var_20-&gt;rax</span><br><span class="line">.text:00000000004015C9                 mov     rdx, 9184E72A000h	 ;1e13-&gt;rdx</span><br><span class="line">.text:00000000004015D3                 mov     [rsp+50h+var_30], rdx ;1e13-&gt;rdx-&gt;*(var_30+50h)</span><br><span class="line">.text:00000000004015D8                 mov     r9, 0E8D4A51000h		;1e12-&gt;r9</span><br><span class="line">.text:00000000004015E2                 mov     r8d, 2				;2放在r8</span><br><span class="line">.text:00000000004015E8                 mov     edx, 1				;1放在rdx</span><br><span class="line">.text:00000000004015ED                 mov     rcx, rax				;rax是var_20的栈地址</span><br><span class="line">.text:00000000004015F0                 call    newEdge</span><br><span class="line">.text:00000000004015F5                 mov     eax, 0</span><br><span class="line">.text:00000000004015FA                 add     rsp, 50h</span><br><span class="line">.text:00000000004015FE                 pop     rbp</span><br><span class="line">.text:00000000004015FF                 retn</span><br><span class="line">.text:00000000004015FF main            endp</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/05/07/xctf-reverse-%E6%96%B0%E6%89%8B12%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/07/xctf-reverse-%E6%96%B0%E6%89%8B12%E9%A2%98/" class="post-title-link" itemprop="url">xctf攻防世界-reverse-新手村</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-07 17:16:00" itemprop="dateCreated datePublished" datetime="2022-05-07T17:16:00+08:00">2022-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-03 16:27:03" itemprop="dateModified" datetime="2022-06-03T16:27:03+08:00">2022-06-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="xctf攻防世界-reverse-新手村">xctf攻防世界-reverse-新手村</h1>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507171516740.png"
alt="image-20220507171516740" />
<figcaption aria-hidden="true">image-20220507171516740</figcaption>
</figure>
<h2 id="logmein">002logmein</h2>
<h3 id="main函数">main函数</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">main proc near</span><br><span class="line"></span><br><span class="line">var_90= qword ptr -90h;很奇怪的是,申请了好多变量,有四字的也有双字的还有字节的</span><br><span class="line">var_88= qword ptr -88h</span><br><span class="line">var_80= qword ptr -80h</span><br><span class="line">var_74= dword ptr -74h</span><br><span class="line">var_70= qword ptr -70h</span><br><span class="line">var_64= dword ptr -64h</span><br><span class="line">var_60= dword ptr -60h</span><br><span class="line">var_5C= dword ptr -5Ch</span><br><span class="line">var_57= byte ptr -57h</span><br><span class="line">var_56= byte ptr -56h</span><br><span class="line">var_55= byte ptr -55h</span><br><span class="line">var_54= dword ptr -54h</span><br><span class="line">s= byte ptr -50h</span><br><span class="line">var_2C= dword ptr -2Ch</span><br><span class="line">var_28= qword ptr -28h</span><br><span class="line">var_20= byte ptr -20h</span><br><span class="line">var_4= dword ptr -4</span><br><span class="line"></span><br><span class="line">; __unwind &#123;</span><br><span class="line">;开端:</span><br><span class="line">push    rbp</span><br><span class="line">mov     rbp, rsp</span><br><span class="line">sub     rsp, 90h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov     rdi, offset format ; &quot;Welcome to the RC3 secure password gues&quot;...</span><br><span class="line">mov     [rbp+var_4], 0</span><br><span class="line"></span><br><span class="line">;一系列蜜汁操作</span><br><span class="line">mov     rax, ds:qword_4008B0					;0x5E54525F4C41223A;</span><br><span class="line">mov     qword ptr [rbp+var_20], rax</span><br><span class="line">mov     rax, ds:qword_4008B8					;0x342F362B3F2E2A4C;</span><br><span class="line">mov     qword ptr [rbp+var_20+8], rax</span><br><span class="line">mov     cx, ds:word_4008C0						;0x36;</span><br><span class="line">mov     word ptr [rbp+var_20+10h], cx</span><br></pre></td></tr></table></figure>
<p>分析一下这里将数据传来传去干了啥</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506112847647.png"
alt="image-20220506112847647" />
<figcaption aria-hidden="true">image-20220506112847647</figcaption>
</figure>
<p><code>var_20</code>占据了栈上<code>rbp-20到rbp-9</code>共24字节空间</p>
<p><code>0x5E54525F4C41223A</code>放在栈上<code>var_20</code>,占用四字8字节,</p>
<p><code>0x342F362B3F2E2A4C</code>放在栈上<code>var_20+8</code>,恰好顺着刚才的<code>var_20</code>存放八个字节</p>
<p><code>0x36</code>放在栈上<code>var_20+10h</code>即<code>var_20+16</code>也是顺着放的</p>
<p>到此为止,<code>var_20</code>一共使用了<code>0~16</code>共17字节,十六进制的表示为:<code>0x36342F362B3F2E2A4C5E54525F4C41223A</code></p>
<p>表示成ascii码为:<code>64/6+?.*L^TR_LA":</code>,下面的字符啥也没写即为<code>'\0'</code>结束符号,一定要考虑清楚小端模式</p>
<p>由此可见<code>var_20</code>应当是开在栈上的一个字符数组,大小是<code>24bytes</code>,实际使用<code>17bytes</code></p>
<p>然后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov     rax, qword ptr ds:byte_4008D0			 ;<span class="number">0x65626D61726168</span>;</span><br><span class="line">mov     [rbp+var_28], rax</span><br></pre></td></tr></table></figure>
<p><code>0x65626D61726168</code>一个四字放在栈中<code>var_28</code>上,<code>var_28</code>恰好也是8字节四字长度,表示成8个ascii字符为<code>ebmarah</code>刚好7个字符</p>
<p>然后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov     [rbp+var_2C], 7</span><br></pre></td></tr></table></figure>
<p><code>var_2C</code>是个双字但是却只放了一个7,可能会与<code>var_28</code>长度7有染</p>
<p>接着下面的反汇编应该调整一下指令顺序,调用<code>_printf</code>或者<code>_scanf</code>函数返回后立刻处理eax中的返回值,看起来比较直观,并且不影响程序逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">;打印第一句废话</span><br><span class="line">mov     rdi, offset format ; &quot;Welcome to the RC3 secure password gues&quot;...</span><br><span class="line">mov     ...</span><br><span class="line">call    _printf				;printf函数返回值是实际打印字符数</span><br><span class="line">mov     [rbp+var_5C], eax	</span><br><span class="line">mov     al, 0</span><br><span class="line"></span><br><span class="line">;打印第二句废话</span><br><span class="line">mov     rdi, offset aToContinueYouM ; &quot;To continue, you must enter the correct&quot;...</span><br><span class="line">call    _printf</span><br><span class="line">mov     [rbp+var_60], eax</span><br><span class="line">mov     al, 0</span><br><span class="line"></span><br><span class="line">;打印第三句废话</span><br><span class="line">mov     rdi, offset aEnterYourGuess ; &quot;Enter your guess: &quot;</span><br><span class="line">call    _printf</span><br><span class="line">mov     [rbp+var_64], eax</span><br><span class="line">mov     al, 0</span><br><span class="line"></span><br><span class="line">;调用scanf获取输入</span><br><span class="line">mov     rdi, offset a32s ; &quot;%32s&quot;</span><br><span class="line">lea     rsi, [rbp+s]    ; s作为scanf的缓冲区,获取输入</span><br><span class="line">call    ___isoc99_scanf		;scanf返回值是实际获取到的输入字符数</span><br><span class="line">mov     [rbp+var_74], eax	;输入字符数-&gt;eax</span><br><span class="line"></span><br><span class="line">;获取输入长度</span><br><span class="line">lea     rdi, [rbp+var_20]	;&amp;var_20-&gt;rdi</span><br><span class="line">lea     rsi, [rbp+s]	    ;&amp;s-&gt;rsi</span><br><span class="line">mov     [rbp+var_70], rdi	;&amp;var_20-&gt;rdi-&gt;var_70</span><br><span class="line">mov     rdi, rsi        	;&amp;s-&gt;rdi </span><br><span class="line">call    _strlen				;strlen(s)-&gt;rax</span><br><span class="line">mov     [rbp+var_80], rax	;strlen(s)-&gt;rax-&gt;var_80</span><br><span class="line"></span><br><span class="line">;获取存好的字符串长度</span><br><span class="line">mov     rdi, [rbp+var_70] 	;&amp;var_20-&gt;var_70-&gt;rdi	 </span><br><span class="line">call    _strlen				;strlen(&amp;var_20)-&gt;rax</span><br><span class="line">mov     rsi, [rbp+var_80]	;strlen(s)-&gt;var_80-&gt;rsi</span><br><span class="line"></span><br><span class="line">;比较两个长度是否相同</span><br><span class="line">cmp     rsi, rax			;比较s和var_20的长度(17)是否一致,即判断是否输入了17个字符</span><br><span class="line">jnb     loc_400700			;如果不一致则跳转报告失败,否则继续检查</span><br></pre></td></tr></table></figure>
<p>下面即将进入循环,现在我们已知的是输入要17个字符</p>
<h4 id="循环体分析">循环体分析</h4>
<p><code>sub_4007c0</code>函数报告失败,不妨给他起名<code>failure</code></p>
<p><code>sub_4007F0</code>函数报告成功,不妨给他起名<code>success</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506120601387.png"
alt="image-20220506120601387" />
<figcaption aria-hidden="true">image-20220506120601387</figcaption>
</figure>
<p>进入循环之前有一个<code>var_54=0</code>很自然可以想到的一种循环结构:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	...</span><br><span class="line">	++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这里<code>var_54</code>是循环变量i吗?</p>
<p>再看最下方的<code>loc_40079E</code>,其中对<code>var_54</code>进行了++,然后跳转<code>loc_400707</code>即循环开头,那么<code>var_54</code>基本上可以确定为循环变量i了</p>
<p>将反汇编翻译为伪代码</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506124657651.png"
alt="image-20220506124657651" />
<figcaption aria-hidden="true">image-20220506124657651</figcaption>
</figure>
<p>解密算法已经很明显了,把<code>var_20</code>和<code>var_28</code>都看成字符数组然后<code>decrypt[i]=var_20[i]^var_28[i%7]</code>即可</p>
<h3 id="解密算法">解密算法</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string var_20 = <span class="string">&quot;64/6+?.*L^TR_LA\&quot;:&quot;</span>;</span><br><span class="line">string var_28 = <span class="string">&quot;ebmarah&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">reverse</span>(var_<span class="number">20.</span><span class="built_in">begin</span>(), var_<span class="number">20.</span><span class="built_in">end</span>());<span class="comment">//反转一下是因为string字符串最左面的字符是低位,而小端模式下最右边是低位</span></span><br><span class="line">	<span class="built_in">reverse</span>(var_<span class="number">28.</span><span class="built_in">begin</span>(), var_<span class="number">28.</span><span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; var_<span class="number">20.</span><span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="type">int</span> temp = (<span class="type">int</span>)var_20[i] ^ (<span class="type">int</span>)var_28[i % <span class="number">7</span>];</span><br><span class="line">		cout &lt;&lt; (<span class="type">char</span>)temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RC3-2016-XORISGUD</span><br></pre></td></tr></table></figure>
<h2 id="insanity">003insanity</h2>
<h3 id="信息收集">信息收集</h3>
<p>每次运行都根开盲盒似的,等待大约5秒之后给出一个结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/xctf12/insanity]</span><br><span class="line">└─$ ./insanity</span><br><span class="line">Reticulating splines, please <span class="built_in">wait</span>..</span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/xctf12/insanity]</span><br><span class="line">└─$ ./insanity</span><br><span class="line">Reticulating splines, please <span class="built_in">wait</span>..</span><br><span class="line">Your ability to hack is about as good as my ability to have free will.</span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/xctf12/insanity]</span><br><span class="line">└─$ ./insanity</span><br><span class="line">Reticulating splines, please <span class="built_in">wait</span>..</span><br><span class="line"><span class="comment">#define YOU &quot;massive failure&quot;</span></span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/xctf12/insanity]</span><br><span class="line">└─$ ./insanity</span><br><span class="line">Reticulating splines, please <span class="built_in">wait</span>..</span><br><span class="line">I<span class="string">&#x27;ve got a good feeling about this one..... wait no. Maybe next time.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/xctf12/insanity]</span></span><br><span class="line"><span class="string">└─$ ./insanity</span></span><br><span class="line"><span class="string">Reticulating splines, please wait..</span></span><br><span class="line"><span class="string">#define YOU &quot;massive failure&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/xctf12/insanity]</span></span><br><span class="line"><span class="string">└─$ ./insanity</span></span><br><span class="line"><span class="string">Reticulating splines, please wait..</span></span><br><span class="line"><span class="string">Your ability to hack is about as good as my ability to have free will.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/xctf12/insanity]</span></span><br><span class="line"><span class="string">└─$ ./insanity</span></span><br><span class="line"><span class="string">Reticulating splines, please wait..</span></span><br><span class="line"><span class="string">rm -rf / : Permission denied</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/xctf12/insanity]</span></span><br><span class="line"><span class="string">└─$ ./insanity</span></span><br><span class="line"><span class="string">Reticulating splines, please wait..</span></span><br><span class="line"><span class="string">Your ability to hack is about as good as my ability to have free will.</span></span><br></pre></td></tr></table></figure>
<h3 id="静态分析">静态分析</h3>
<p>一张图截完,题啃腚不难</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507122441995.png"
alt="image-20220507122441995" />
<figcaption aria-hidden="true">image-20220507122441995</figcaption>
</figure>
<p>实际上点进s或者任意一个存好的字符串到rodata区看一下就找到答案了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507171407247.png"
alt="image-20220507171407247" />
<figcaption aria-hidden="true">image-20220507171407247</figcaption>
</figure>
<p>下面分析一下程序逻辑</p>
<p>猜测是这样的:假设rodata区有n条语句组成一个数组,生成一个随机数然后对n取模,取该值对应下标的语句打印</p>
<p><code>main</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">public main</span><br><span class="line">main proc near</span><br><span class="line"></span><br><span class="line">argc= dword ptr  8</span><br><span class="line">argv= dword ptr  0Ch</span><br><span class="line">envp= dword ptr  10h</span><br><span class="line"></span><br><span class="line">; __unwind &#123;</span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">and     esp, 0FFFFFFF0h													</span><br><span class="line">sub     esp, 10h</span><br><span class="line">mov     dword ptr [esp], offset s ; &quot;Reticulating splines, please wait..&quot;		;废话压栈</span><br><span class="line">call    _puts																;打印废话</span><br><span class="line">mov     dword ptr [esp], 5 ; seconds										;5秒压栈</span><br><span class="line">call    _sleep																;休眠5秒</span><br><span class="line"></span><br><span class="line">;生成随机数种子</span><br><span class="line">mov     dword ptr [esp], 0 ; timer											;time(0)</span><br><span class="line">call    _time</span><br><span class="line">mov     [esp], eax      ; seed												;time(0)的返回值作为参数</span><br><span class="line">call    _srand																;srand(time(0))</span><br><span class="line"></span><br><span class="line">;获得一个随机数</span><br><span class="line">call    _rand																;rand()-&gt;eax</span><br><span class="line">mov     ecx, eax															;rand()-&gt;eax-&gt;ecx</span><br><span class="line"></span><br><span class="line">;下面这一系列操作好迷啊</span><br><span class="line">mov     edx, 0CCCCCCCDh														;3435973837这个魔数是啥呢</span><br><span class="line">mul     edx																	;eax*edx-&gt;edx:eax</span><br><span class="line">shr     edx, 3																;edx/8</span><br><span class="line">lea     eax, [edx+edx*4]													;5edx-&gt;eax</span><br><span class="line">add     eax, eax															;10edx-&gt;eax</span><br><span class="line">sub     ecx, eax															;10edx</span><br><span class="line">;分析了一阵子屁用没有</span><br><span class="line"></span><br><span class="line">;取对应字符串并打印</span><br><span class="line">mov     eax, strs[ecx*4]													;ecx是下标,相邻亮指针偏移4字节</span><br><span class="line">mov     [esp], eax      ; s													</span><br><span class="line">call    _puts																</span><br><span class="line">xor     eax, eax															</span><br><span class="line">leave</span><br><span class="line">retn</span><br><span class="line">; &#125; // starts at 80483F0</span><br><span class="line">main endp</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507162916682.png"
alt="image-20220507162916682" />
<figcaption aria-hidden="true">image-20220507162916682</figcaption>
</figure>
<p>全篇没有看出一个取模来,难道是我老眼昏花了?</p>
<h3 id="取模时的编译优化">取模时的编译优化</h3>
<p>这里应该就是取模,但是其实现好迷啊</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">call    _rand																;rand()-&gt;eax假设为16</span><br><span class="line">mov     ecx, eax															;rand()=16-&gt;eax-&gt;ecx</span><br><span class="line"></span><br><span class="line">;下面这一系列操作好迷啊</span><br><span class="line">mov     edx, 0CCCCCCCDh														;3435973837这个魔数是啥呢</span><br><span class="line">mul     edx																	;eax*edx-&gt;edx:eax=Ch:CCCCCCD0h</span><br><span class="line">shr     edx, 3																;edx/8=C/8=1</span><br><span class="line">lea     eax, [edx+edx*4]													;		5-&gt;eax</span><br><span class="line">add     eax, eax															;		10-&gt;eax</span><br><span class="line">sub     ecx, eax															;	16-10=6			</span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/Wang_1997/article/details/104775975">(5条消息)
逆向-取模运算_嘻嘻兮的博客-CSDN博客_取模的逆运算</a></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507170255414.png"
alt="image-20220507170255414" />
<figcaption aria-hidden="true">image-20220507170255414</figcaption>
</figure>
<h2 id="re1">006re1</h2>
<h3 id="信息收集-1">信息收集</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\xctf12\re1&gt; ./re1   </span><br><span class="line">欢迎来到DUTCTF呦</span><br><span class="line">这是一道很可爱很简单的逆向题呦</span><br><span class="line">输入flag吧:123456</span><br><span class="line">flag不太对呦，再试试呗，加油呦</span><br><span class="line">请按任意键继续. . . </span><br></pre></td></tr></table></figure>
<p>输入flag之后必然会flag不对,然后程序阻塞,并且提示"请按任意键继续..."</p>
<p>这个题的图视图竟然可以用一个截屏截下来,必然简单</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507101716875.png"
alt="image-20220507101716875" />
<figcaption aria-hidden="true">image-20220507101716875</figcaption>
</figure>
<h3 id="逆向分析">逆向分析</h3>
<h4 id="开端">开端</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;开端</span><br><span class="line">.text:00401000                 push    ebp</span><br><span class="line">.text:00401001                 mov     ebp, esp</span><br><span class="line">.text:00401003                 sub     esp, 44h</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="防止栈缓冲区溢出">防止栈缓冲区溢出</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00401006                 mov     eax, ___security_cookie</span><br><span class="line">.text:0040100B                 xor     eax, ebp</span><br><span class="line">.text:0040100D                 mov     [ebp+var_4], eax</span><br></pre></td></tr></table></figure>
<h4
id="装填flag指令顺序有改动但是不影响逻辑">装填flag,指令顺序有改动但是不影响逻辑</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:00401018                 xor     eax, eax					;eax归零</span><br><span class="line">.text:00401010                 movdqu  xmm0, ds:xmmword_413E34	;3074656D30633165577B465443545544h</span><br><span class="line">															;即 0tem0c1eW&#123;FTCTUD</span><br><span class="line">.text:0040101F                 movdqu  [ebp+var_44], xmm0			;0tem0c1eW&#123;FTCTUD-&gt;var_44	</span><br><span class="line">.text:00401024                 mov     [ebp+var_2C], eax			;eax=0-&gt;var_2C	</span><br><span class="line">.text:00401027                 movq    xmm0, ds:qword_413E44		;7D465443545544h即 &#125;FTCTUD</span><br><span class="line">.text:0040102F                 movq    [ebp+var_34], xmm0			;&#125;FTCTUD -&gt;var_34</span><br><span class="line">.text:00401034                 mov     [ebp+var_28], ax				;0-&gt;var_28</span><br></pre></td></tr></table></figure>
<h4 id="打印废话">打印废话</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:0040101A                 push    offset aDutctf  ; &quot;欢迎来到DUTCTF呦\n&quot;	;废话压栈作为参数</span><br><span class="line">.text:00401038                 call    _printf						;打印第一句废话</span><br><span class="line">.text:0040103D                 push    offset asc_413E60 ; &quot;这是一道很可爱很简单的逆向题呦\n&quot;</span><br><span class="line">.text:00401042                 call    _printf</span><br><span class="line">.text:00401047                 push    offset aFlag    ; &quot;输入flag吧:&quot;</span><br><span class="line">.text:0040104C                 call    _printf</span><br></pre></td></tr></table></figure>
<h4 id="获取输入输入存储到var_24">获取输入,输入存储到var_24</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00401051                 lea     eax, [ebp+var_24]</span><br><span class="line">.text:00401054                 push    eax</span><br><span class="line">.text:00401055                 push    offset Format   ; &quot;%s&quot;</span><br><span class="line">.text:0040105A                 call    _scanf</span><br></pre></td></tr></table></figure>
<h4 id="加载输入和flag">加载输入和flag</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0040105F                 add     esp, 14h</span><br><span class="line">.text:00401062                 lea     eax, [ebp+var_24]		;输入字符串的地址</span><br><span class="line">.text:00401065                 lea     ecx, [ebp+var_44]		;flag的地址</span><br></pre></td></tr></table></figure>
<h4
id="循环比较输入和flag每次比较两个字节">循环比较输入和flag,每次比较两个字节</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:00401068 loc_401068:                             ; CODE XREF: _main+82↓j</span><br><span class="line">.text:00401068                 mov     dl, [ecx]			;flag[0]值放在dl</span><br><span class="line">.text:0040106A                 cmp     dl, [eax]			;比较flag[0]和输入值的大小</span><br><span class="line">.text:0040106C                 jnz     short loc_401088		;如果不为零即输入和flag不相等则跳转,大概率跳转到寄</span><br><span class="line">.text:0040106E                 test    dl, dl				;dl中存放的是flag[i]如果为0说明遍历完毕,循环跳出</span><br><span class="line">.text:00401070                 jz      short loc_401084		;如果遍历完毕则跳转loc_401084</span><br><span class="line">.text:00401072                 mov     dl, [ecx+1]			</span><br><span class="line">.text:00401075                 cmp     dl, [eax+1]</span><br><span class="line">.text:00401078                 jnz     short loc_401088</span><br><span class="line">.text:0040107A                 add     ecx, 2</span><br><span class="line">.text:0040107D                 add     eax, 2</span><br><span class="line">.text:00401080                 test    dl, dl</span><br><span class="line">.text:00401082                 jnz     short loc_401068</span><br></pre></td></tr></table></figure>
<h4
id="两种情况置eax为0或1然后合并判断">两种情况,置eax为0或1然后合并判断</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00401084 loc_401084:                             ; CODE XREF: _main+70↑j</span><br><span class="line">.text:00401084                 xor     eax, eax				;eax归零</span><br><span class="line">.text:00401086                 jmp     short loc_40108D		 ;跳转loc_401108D</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00401088 loc_401088:                             ; CODE XREF: _main+6C↑j</span><br><span class="line">.text:00401088                                         ; _main+78↑j</span><br><span class="line">.text:00401088                 sbb     eax, eax			;带借位减法,eax=-1=0xFFFFFFFF</span><br><span class="line">.text:0040108A                 or      eax, 1			;eax=1&amp;0xFFFFFFF=1</span><br></pre></td></tr></table></figure>
<h4 id="合并.根据刚才的eax判断">合并.根据刚才的eax判断</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:0040108D loc_40108D:                             ; CODE XREF: _main+86↑j</span><br><span class="line">.text:0040108D                 test    eax, eax					;判断eax是否为0</span><br><span class="line">.text:0040108F                 jnz     short loc_401098			 ;如果eax!=0则跳转loc_401098</span><br><span class="line">.text:00401091                 push    offset unk_413E90;flag get ;否则eax=0表示成功,&quot;flag get&quot;的地址压栈准备打印</span><br><span class="line">.text:00401096                 jmp     short loc_40109D			 ;跳转loc_40109D</span><br><span class="line">.text:00401098 loc_401098:                             ; CODE XREF: _main+8F↑j</span><br><span class="line">.text:00401098                 push    offset aFlag_0  ; &quot;flag不太对呦&quot;		;&quot;flag不太对呦&quot;地址压栈,准备打印</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="尾声">尾声</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:0040109D loc_40109D:                             ; CODE XREF: _main+96↑j</span><br><span class="line">.text:0040109D                 call    _printf				;打印刚才压入栈中的缓冲区</span><br><span class="line">.text:004010A2                 add     esp, 4				;退栈4</span><br><span class="line">.text:004010A5                 push    offset Command  ; &quot;pause&quot;  ;&quot;pause&quot;串的地址压栈,准备为system函数传参</span><br><span class="line">.text:004010AA                 call    _system					;程序阻塞暂停</span><br><span class="line"></span><br><span class="line">;以下部分可能是在检查栈缓冲区溢出?</span><br><span class="line">.text:004010AF                 mov     ecx, [ebp+var_4]			</span><br><span class="line">.text:004010B2                 add     esp, 4</span><br><span class="line">.text:004010B5                 xor     ecx, ebp        ; StackCookie</span><br><span class="line">.text:004010B7                 xor     eax, eax</span><br><span class="line">.text:004010B9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class="line">.text:004010BE                 mov     esp, ebp</span><br><span class="line">.text:004010C0                 pop     ebp</span><br><span class="line">.text:004010C1                 retn</span><br><span class="line">.text:004010C1 _main           endp</span><br></pre></td></tr></table></figure>
<h3 id="security_cookie">___security_cookie</h3>
<p><a
target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/c-runtime-library/reference/security-init-cookie?view=msvc-170">参考微软官方文档</a></p>
<blockquote>
<p>全局安全 Cookie 用于在使用 <a
target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/build/reference/gs-buffer-security-check?view=msvc-170">/GS（缓冲区安全检查）</a>编译的代码中和使用异常处理的代码中提供缓冲区溢出保护。
进入受到溢出保护的函数时，Cookie
被置于堆栈之上；退出时，会将堆栈上的值与全局 Cookie 进行比较。
它们之间存在任何差异则表示已经发生缓冲区溢出，并导致该程序的立即终止。</p>
<p>通常， <strong><code>__security_init_cookie</code></strong>
在初始化时由 CRT 调用。 如果你跳过 CRT 初始化（例如，如果使用 <a
target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/build/reference/entry-entry-point-symbol?view=msvc-170"><code>/ENTRY</code></a>
指定入口点），则必须自己调用
<strong><code>__security_init_cookie</code></strong> 。 如果
<strong><code>__security_init_cookie</code></strong> 不调用，全局安全
cookie 将设置为默认值，并且会危及缓冲区溢出保护。 由于攻击者可利用此默认
Cookie 值使缓冲区溢出检查无效，我们建议，在定义自己的入口点时，始终调用
<strong><code>__security_init_cookie</code></strong>。</p>
<p>在进入任何受到溢出保护的函数前，必须调用
<strong><code>__security_init_cookie</code></strong>，否则将检测到虚假的缓冲区溢出。
有关详细信息，请参阅 <a
target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/error-messages/tool-errors/c-runtime-error-r6035?view=msvc-170">C
运行时错误 R6035</a>。</p>
</blockquote>
<h2 id="game">007game</h2>
<h3 id="信息收集-2">信息收集</h3>
<p>一个32位exe程序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                     |------------／ --------△--------|</span><br><span class="line">                     |-----------------------●--------|</span><br><span class="line">                     |------------／ --------◇--------|</span><br><span class="line">                     |-----------------------■--------|</span><br><span class="line">|--------------------|------------／ --------☆--------|</span><br><span class="line">|                    |------------／ --------▽--------|</span><br><span class="line">|                    |------------／ -----(￣▽￣)／---|</span><br><span class="line">|                    |--------------------(*°▽°)=3--|</span><br><span class="line">二                                                     |</span><br><span class="line">|           by 0x61                                    |</span><br><span class="line">|                                                      |</span><br><span class="line">|------------------------------------------------------|</span><br><span class="line">input n,n(1-8)</span><br><span class="line">1.△ 2.○ 3.◇ 4.□ 5.☆ 6.▽ 7.(￣▽￣)／ 8.(;°Д°) 0.restart</span><br><span class="line">n=</span><br></pre></td></tr></table></figure>
<p>一个开灯和关灯的游戏,大意是:</p>
<p>有八栈灯编号为1到8,每次可以选择一盏灯改变其开关状态,并且其左右的灯也会改变开关状态,认为8号灯和1号灯也是相邻的</p>
<p>初始时八盏灯都是灭的</p>
<p>当八盏灯都亮起来的时候,就给flag</p>
<h3 id="算法解决">算法解决</h3>
<p>首先考虑这个问题是否有解?</p>
<p>方便取模运算,将灯号从0编到7</p>
<table>
<thead>
<tr>
<th>灯号</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>第一次</td>
<td>1</td>
<td>==1==</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>第二次</td>
<td>1</td>
<td>0</td>
<td>==0==</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>第三次</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>==1==</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>第四次</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>==0==</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>第五次</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>==1==</td>
</tr>
</tbody>
</table>
<p>经过五次变化之后,我们可以得到一栈两着的灯,并且其他暗着的灯我们可以视为一直暗着</p>
<p>==因此同时改变三栈灯的状态是可以推出等价于只改变一盏灯的状态==</p>
<p>从1号灯开始的变化导致了7号灯变化</p>
<p>同理可知从2号灯开始的变化导致0号灯变化</p>
<p>...</p>
<p>从i号灯开始的变化导致(i+6)%8的灯变化,其路径为<code>i%8,(i+1)%8,(i+3)%8,(i+4)%8,(i+6)%8</code>共五次变化</p>
<p>则8盏灯全部由暗变亮需要40次变化</p>
<p>可以编写解密脚本打印出这40个数字然后粘贴进game.exe解密</p>
<p>解密脚本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;i)</span> &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; i % <span class="number">8</span> + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//实际上还得是从1开始编号</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (i + <span class="number">1</span>) % <span class="number">8</span> + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (i + <span class="number">3</span>) % <span class="number">8</span> + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (i + <span class="number">4</span>) % <span class="number">8</span> + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (i + <span class="number">6</span>) % <span class="number">8</span> + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">		change(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果粘贴进<code>game.exe</code>之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">done!!! the flag is zsctf&#123;T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态分析-1">静态分析</h3>
<h4 id="尝试1">尝试1</h4>
<p>假设我们不会玩这个游戏,但是可以猜测,这⑧盏灯是可以都点亮的,诚如是,则程序交出flag,退出</p>
<p>那么在反汇编图视图中应当有一些没有后继的叶子块,即成功的分支</p>
<p>满足条件的块只有一个,如图所示红色块</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506234409960.png"
alt="image-20220506234409960" />
<figcaption aria-hidden="true">image-20220506234409960</figcaption>
</figure>
<p>但是这个块实际上干了和栈有关一些事,具体啥事也不想管了,总之这样猜测是错的</p>
<p>刚才用算法方法点亮了所有的灯,程序也给出了flag但是程序依然在执行</p>
<h4 id="尝试2">尝试2</h4>
<p>每次输入改变灯状态之后会有一个对所有灯的状态检查,要么是在循环开始,要么是在循环尾部</p>
<p>这八盏灯的状态可能是在放在一个字节里的八位,通过按位操作改变状态</p>
<p>或者每个灯一个单元,放在一个数组里</p>
<p>观察反汇编的图视图,发现有这么八块基本相同的结构,大概率就是逐次判断灯的状态</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507075557175.png"
alt="image-20220507075557175" />
<figcaption aria-hidden="true">image-20220507075557175</figcaption>
</figure>
<p>观察其中的一块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, 1					;1-&gt;eax</span><br><span class="line">shl     eax, 0					</span><br><span class="line">movzx   ecx, byte_532E28[eax]	  ;byte_532E28[1]-&gt;ecx</span><br><span class="line">cmp     ecx, 1					;cmp byte_532E28[1],1</span><br><span class="line">jnz     short loc_45F671		 ;不为0则表明灯灭,跳转从头再来</span><br></pre></td></tr></table></figure>
<p>那么如果八块均不跳转jnz,那么紧接着就应该给出flag了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507080122539.png"
alt="image-20220507080122539" />
<figcaption aria-hidden="true">image-20220507080122539</figcaption>
</figure>
<p>结果该函数开头给出了好长一坨字符数组,然后给了这么一个循环,明显是有加密算法的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507081140177.png"
alt="image-20220507081140177" />
<figcaption aria-hidden="true">image-20220507081140177</figcaption>
</figure>
<p>蓝色块用作打印,和加密算法无关,暂时不关心</p>
<p>结尾<code>loc_45EB61</code>将var_94++,显然是作为循环变量的,</p>
<p>开头<code>loc_45EB70</code>将<code>var_94</code>和<code>0x38h=56</code>进行比较,应该是判断循环结束条件,循环56次</p>
<p><code>loc_45EB70</code>之前有一个<code>mov [ebp+var_94],0</code>显然是循环变量var_94一开始是下标0</p>
<p>那么不妨给<code>var_94</code>重命名i</p>
<p>循环体:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, [ebp+i]</span><br><span class="line">movsx   ecx, [ebp+eax+var_44]			;var_44[i]-&gt;ecx</span><br><span class="line">mov     edx, [ebp+i]					</span><br><span class="line">movsx   eax, [ebp+edx+var_88]			;var_88[i]-&gt;eax</span><br><span class="line">xor     eax, ecx						;var_44[i]^var_88[i]-&gt;eax</span><br><span class="line">mov     ecx, [ebp+i]					</span><br><span class="line">mov     [ebp+ecx+var_88], al			;var_44[i]^var_88[i]-&gt;var_88[i]</span><br><span class="line">mov     eax, [ebp+i]</span><br><span class="line">movsx   ecx, [ebp+eax+var_88]			;var_88[i]-&gt;ecx</span><br><span class="line">xor     ecx, 13h						;var_88[i]^13h-&gt;ecx</span><br><span class="line">mov     edx, [ebp+i]					</span><br><span class="line">mov     [ebp+edx+var_88], cl			;var_88[i]^13h-&gt;var_88[i]</span><br><span class="line">jmp     short loc_45EB61				</span><br></pre></td></tr></table></figure>
<p>这么一长段干了一件事 <span class="math display">\[
var\_88[i]=var\_88[i]\oplus var\_44[i]\oplus 0x13
\]</span>
<code>var_88</code>在内存中占用-88到-50刚好0x38大小,与循环变量i的范围相同</p>
<p>同理<code>var_44</code>应当占用<code>-44</code>到<code>-C</code></p>
<p>在栈视图下编好数组</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507083640431.png"
alt="image-20220507083640431" />
<figcaption aria-hidden="true">image-20220507083640431</figcaption>
</figure>
<p>回到反汇编视图</p>
<p>接下来考虑怎样把mov进入var_44数组的值提取出来放到一个数组里</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507084508649.png"
alt="image-20220507084508649" />
<figcaption aria-hidden="true">image-20220507084508649</figcaption>
</figure>
<p>如果高亮<code>.text:0045E975</code>到<code>.text:0045EA55</code>之后右键convert
to C/C++ array(DWORD)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507084855688.png"
alt="image-20220507084855688" />
<figcaption aria-hidden="true">image-20220507084855688</figcaption>
</figure>
<p>得到的数组是这样的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[+] Dump <span class="number">0x45E975</span> - <span class="number">0x45EA55</span> (<span class="number">224</span> bytes) :</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> data[<span class="number">56</span>] = &#123;</span><br><span class="line">    <span class="number">0x12BC45C6</span>, <span class="number">0x40BD45C6</span>, <span class="number">0x62BE45C6</span>, <span class="number">0x05BF45C6</span>, <span class="number">0x02C045C6</span>, <span class="number">0x04C145C6</span>, <span class="number">0x06C245C6</span>, <span class="number">0x03C345C6</span>, </span><br><span class="line">    <span class="number">0x06C445C6</span>, <span class="number">0x30C545C6</span>, <span class="number">0x31C645C6</span>, <span class="number">0x41C745C6</span>, <span class="number">0x20C845C6</span>, <span class="number">0x0CC945C6</span>, <span class="number">0x30CA45C6</span>, <span class="number">0x41CB45C6</span>, </span><br><span class="line">    <span class="number">0x1FCC45C6</span>, <span class="number">0x4ECD45C6</span>, <span class="number">0x3ECE45C6</span>, <span class="number">0x20CF45C6</span>, <span class="number">0x31D045C6</span>, <span class="number">0x20D145C6</span>, <span class="number">0x01D245C6</span>, <span class="number">0x39D345C6</span>, </span><br><span class="line">    <span class="number">0x60D445C6</span>, <span class="number">0x03D545C6</span>, <span class="number">0x15D645C6</span>, <span class="number">0x09D745C6</span>, <span class="number">0x04D845C6</span>, <span class="number">0x3ED945C6</span>, <span class="number">0x03DA45C6</span>, <span class="number">0x05DB45C6</span>, </span><br><span class="line">    <span class="number">0x04DC45C6</span>, <span class="number">0x01DD45C6</span>, <span class="number">0x02DE45C6</span>, <span class="number">0x03DF45C6</span>, <span class="number">0x2CE045C6</span>, <span class="number">0x41E145C6</span>, <span class="number">0x4EE245C6</span>, <span class="number">0x20E345C6</span>, </span><br><span class="line">    <span class="number">0x10E445C6</span>, <span class="number">0x61E545C6</span>, <span class="number">0x36E645C6</span>, <span class="number">0x10E745C6</span>, <span class="number">0x2CE845C6</span>, <span class="number">0x34E945C6</span>, <span class="number">0x20EA45C6</span>, <span class="number">0x40EB45C6</span>, </span><br><span class="line">    <span class="number">0x59EC45C6</span>, <span class="number">0x2DED45C6</span>, <span class="number">0x20EE45C6</span>, <span class="number">0x41EF45C6</span>, <span class="number">0x0FF045C6</span>, <span class="number">0x22F145C6</span>, <span class="number">0x12F245C6</span>, <span class="number">0x10F345C6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实际上存储的是指令不是我们要的数值</p>
<p>但是可以发现,每个数据的高两个16进制位是我们要的数值</p>
<p>比如<code>0x12BC45C6</code>高两位那么将每个16进制数按位与<code>0xFF000000</code>即可只保留高两位,或者直接右移24位即可转化为低两位</p>
<p>但是对于<code>var_88</code>这个数组,它头几个元素赋值的指令占了7字节,可以手动抄到数组里</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220507090007954.png"
alt="image-20220507090007954" />
<figcaption aria-hidden="true">image-20220507090007954</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> var_88_2[<span class="number">56</span>] = &#123;</span><br><span class="line">	<span class="number">0x7b000000</span>, <span class="number">0x20000000</span>, <span class="number">0x12000000</span>, <span class="number">0x62000000</span>, <span class="number">0x77000000</span>, <span class="number">0x6C000000</span>, <span class="number">0x41000000</span>, <span class="number">0x29000000</span>,</span><br><span class="line">    <span class="number">0x7C8045C6</span>, <span class="number">0x508145C6</span>, <span class="number">0x7D8245C6</span>, <span class="number">0x268345C6</span>, <span class="number">0x7C8445C6</span>, <span class="number">0x6F8545C6</span>, <span class="number">0x4A8645C6</span>, <span class="number">0x318745C6</span>, </span><br><span class="line">    <span class="number">0x538845C6</span>, <span class="number">0x6C8945C6</span>, <span class="number">0x5E8A45C6</span>, <span class="number">0x6C8B45C6</span>, <span class="number">0x548C45C6</span>, <span class="number">0x068D45C6</span>, <span class="number">0x608E45C6</span>, <span class="number">0x538F45C6</span>, </span><br><span class="line">    <span class="number">0x2C9045C6</span>, <span class="number">0x799145C6</span>, <span class="number">0x689245C6</span>, <span class="number">0x6E9345C6</span>, <span class="number">0x209445C6</span>, <span class="number">0x5F9545C6</span>, <span class="number">0x759645C6</span>, <span class="number">0x659745C6</span>, </span><br><span class="line">    <span class="number">0x639845C6</span>, <span class="number">0x7B9945C6</span>, <span class="number">0x7F9A45C6</span>, <span class="number">0x779B45C6</span>, <span class="number">0x609C45C6</span>, <span class="number">0x309D45C6</span>, <span class="number">0x6B9E45C6</span>, <span class="number">0x479F45C6</span>, </span><br><span class="line">    <span class="number">0x5CA045C6</span>, <span class="number">0x1DA145C6</span>, <span class="number">0x51A245C6</span>, <span class="number">0x6BA345C6</span>, <span class="number">0x5AA445C6</span>, <span class="number">0x55A545C6</span>, <span class="number">0x40A645C6</span>, <span class="number">0x0CA745C6</span>, </span><br><span class="line">    <span class="number">0x2BA845C6</span>, <span class="number">0x4CA945C6</span>, <span class="number">0x56AA45C6</span>, <span class="number">0x0DAB45C6</span>, <span class="number">0x72AC45C6</span>, <span class="number">0x01AD45C6</span>, <span class="number">0x75AE45C6</span>, <span class="number">0x7EAF45C6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解密脚本">解密脚本</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> var_44[<span class="number">56</span>] = &#123;</span><br><span class="line">	<span class="number">0x12BC45C6</span>, <span class="number">0x40BD45C6</span>, <span class="number">0x62BE45C6</span>, <span class="number">0x05BF45C6</span>, <span class="number">0x02C045C6</span>, <span class="number">0x04C145C6</span>, <span class="number">0x06C245C6</span>, <span class="number">0x03C345C6</span>,</span><br><span class="line">	<span class="number">0x06C445C6</span>, <span class="number">0x30C545C6</span>, <span class="number">0x31C645C6</span>, <span class="number">0x41C745C6</span>, <span class="number">0x20C845C6</span>, <span class="number">0x0CC945C6</span>, <span class="number">0x30CA45C6</span>, <span class="number">0x41CB45C6</span>,</span><br><span class="line">	<span class="number">0x1FCC45C6</span>, <span class="number">0x4ECD45C6</span>, <span class="number">0x3ECE45C6</span>, <span class="number">0x20CF45C6</span>, <span class="number">0x31D045C6</span>, <span class="number">0x20D145C6</span>, <span class="number">0x01D245C6</span>, <span class="number">0x39D345C6</span>,</span><br><span class="line">	<span class="number">0x60D445C6</span>, <span class="number">0x03D545C6</span>, <span class="number">0x15D645C6</span>, <span class="number">0x09D745C6</span>, <span class="number">0x04D845C6</span>, <span class="number">0x3ED945C6</span>, <span class="number">0x03DA45C6</span>, <span class="number">0x05DB45C6</span>,</span><br><span class="line">	<span class="number">0x04DC45C6</span>, <span class="number">0x01DD45C6</span>, <span class="number">0x02DE45C6</span>, <span class="number">0x03DF45C6</span>, <span class="number">0x2CE045C6</span>, <span class="number">0x41E145C6</span>, <span class="number">0x4EE245C6</span>, <span class="number">0x20E345C6</span>,</span><br><span class="line">	<span class="number">0x10E445C6</span>, <span class="number">0x61E545C6</span>, <span class="number">0x36E645C6</span>, <span class="number">0x10E745C6</span>, <span class="number">0x2CE845C6</span>, <span class="number">0x34E945C6</span>, <span class="number">0x20EA45C6</span>, <span class="number">0x40EB45C6</span>,</span><br><span class="line">	<span class="number">0x59EC45C6</span>, <span class="number">0x2DED45C6</span>, <span class="number">0x20EE45C6</span>, <span class="number">0x41EF45C6</span>, <span class="number">0x0FF045C6</span>, <span class="number">0x22F145C6</span>, <span class="number">0x12F245C6</span>, <span class="number">0x10F345C6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> var_88[<span class="number">56</span>] = &#123;</span><br><span class="line">	<span class="number">0x7b000000</span>, <span class="number">0x20000000</span>, <span class="number">0x12000000</span>, <span class="number">0x62000000</span>, <span class="number">0x77000000</span>, <span class="number">0x6C000000</span>, <span class="number">0x41000000</span>, <span class="number">0x29000000</span>,<span class="comment">//手动补的</span></span><br><span class="line">	<span class="number">0x7C8045C6</span>, <span class="number">0x508145C6</span>, <span class="number">0x7D8245C6</span>, <span class="number">0x268345C6</span>, <span class="number">0x7C8445C6</span>, <span class="number">0x6F8545C6</span>, <span class="number">0x4A8645C6</span>, <span class="number">0x318745C6</span>,</span><br><span class="line">	<span class="number">0x538845C6</span>, <span class="number">0x6C8945C6</span>, <span class="number">0x5E8A45C6</span>, <span class="number">0x6C8B45C6</span>, <span class="number">0x548C45C6</span>, <span class="number">0x068D45C6</span>, <span class="number">0x608E45C6</span>, <span class="number">0x538F45C6</span>,</span><br><span class="line">	<span class="number">0x2C9045C6</span>, <span class="number">0x799145C6</span>, <span class="number">0x689245C6</span>, <span class="number">0x6E9345C6</span>, <span class="number">0x209445C6</span>, <span class="number">0x5F9545C6</span>, <span class="number">0x759645C6</span>, <span class="number">0x659745C6</span>,</span><br><span class="line">	<span class="number">0x639845C6</span>, <span class="number">0x7B9945C6</span>, <span class="number">0x7F9A45C6</span>, <span class="number">0x779B45C6</span>, <span class="number">0x609C45C6</span>, <span class="number">0x309D45C6</span>, <span class="number">0x6B9E45C6</span>, <span class="number">0x479F45C6</span>,</span><br><span class="line">	<span class="number">0x5CA045C6</span>, <span class="number">0x1DA145C6</span>, <span class="number">0x51A245C6</span>, <span class="number">0x6BA345C6</span>, <span class="number">0x5AA445C6</span>, <span class="number">0x55A545C6</span>, <span class="number">0x40A645C6</span>, <span class="number">0x0CA745C6</span>,</span><br><span class="line">	<span class="number">0x2BA845C6</span>, <span class="number">0x4CA945C6</span>, <span class="number">0x56AA45C6</span>, <span class="number">0x0DAB45C6</span>, <span class="number">0x72AC45C6</span>, <span class="number">0x01AD45C6</span>, <span class="number">0x75AE45C6</span>, <span class="number">0x7EAF45C6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">char</span>&gt; <span class="title function_">preprocesser</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> arr[], <span class="type">int</span> length)</span> &#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">char</span>&gt; <span class="title function_">v</span><span class="params">(length)</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">		v[i] = arr[i] &gt;&gt; <span class="number">24</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">char</span>&gt; result = preprocesser(var_44, <span class="number">56</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">char</span>&gt; key = preprocesser(var_88, <span class="number">56</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">56</span>; ++i) &#123;</span><br><span class="line">		result[i] = result[i] ^ key[i] ^ <span class="number">0x13</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (<span class="type">char</span>)result[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zsctf&#123;T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hellocctf">008Helloc,CTF</h2>
<h3 id="没见过的指令">没见过的指令</h3>
<p>在分析之前,补几个指令</p>
<p>关于CSAPP上没有见过的指令</p>
<p>1.rep/repne</p>
<p>2.movsd/movsw/movsb</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rep movsd               ; 没有见过的指令</span><br><span class="line">movsw</span><br><span class="line">movsb</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查阅<a
target="_blank" rel="noopener" href="https://stackoverflow.com/questions/27804852/assembly-rep-movs-mechanism">x86
- Assembly: REP MOVS mechanism - Stack Overflow</a></p>
<p>According to <a
target="_blank" rel="noopener" href="http://msdn.microsoft.com/en-us/library/windows/hardware/ff561504(v=vs.85).aspx">MSDN</a>,
"The instruction can be prefixed by REP to repeat the operation the
number of times specified by the ecx register."</p>
<p>rep的操作数是一个指令,rep的作用是将该指令重复若干次,以ecx中的数字为重复次数,(每次ecx中的数字-1直到归零)</p>
<p>repne 当ecx!=0且ZF!=0,重复执行后边的指令,每执行一次ecx的值减1</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506171358295.png"
alt="image-20220506171358295" />
<figcaption aria-hidden="true">image-20220506171358295</figcaption>
</figure>
</blockquote>
<p>3.stosd/stosw/stosb</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rep stosd</span><br><span class="line">stosw</span><br><span class="line">stosb</span><br></pre></td></tr></table></figure>
<blockquote>
<p>STOSB、STOSW 和 STOSD 指令分别将 AL/AX/EAX 的内容存入由 EDI
中偏移量指向的内存位置。</p>
<p>EDI 根据方向标志位的状态递增或递减。</p>
</blockquote>
<p>4.scasd/scasw/scasb</p>
<blockquote>
<p>SCASB、SCASW 和 SCASD 指令分别将 AL/AX/EAX 中的值与 EDI
寻址的一个字节 / 字 / 双字进行比较。</p>
<p>这些指令可用于在字符串或数组中寻找一个数值。</p>
<p>结合 REPE（或 REPZ）前缀，当 ECX &gt; 0 且 AL/AX/EAX
的值等于内存中每个连续的值时，不断扫描字符串或数组。</p>
</blockquote>
<h3 id="收集信息">收集信息</h3>
<p>输入比较短的字符串会报告wrong!然后让重新输入,输入很长的字符串报告wrong!之后程序退出</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506163947900.png"
alt="image-20220506163947900" />
<figcaption aria-hidden="true">image-20220506163947900</figcaption>
</figure>
<p>ida打开之后</p>
<p>main函数开端部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">mov     esi, offset a437261636b4d65 ; &quot;437261636b4d654a757374466f7246756e&quot;</span><br><span class="line">lea     edi, [esp+70h+var_24]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里有一串16进制编码,其他不管先解一下,<code>CrackMeJustForFun</code>"撬我只是为了娱乐",看上去是有一定语言意义的,作为flag交上去试试就对了</p>
<h3 id="反汇编分析">反汇编分析</h3>
<p>下面分析一下程序都干了啥</p>
<h4 id="开端-1">开端</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">;开端</span><br><span class="line">sub     esp, 60h</span><br><span class="line">mov     ecx, 8			</span><br><span class="line">push    ebx;寄存器值保存</span><br><span class="line">push    ebp</span><br><span class="line">push    esi</span><br><span class="line">push    edi</span><br><span class="line"></span><br><span class="line">mov     esi, offset a437261636b4d65 ; esi存放flag的地址</span><br><span class="line">lea     edi, [esp+70h+var_24] ; &amp;var_24-&gt;edi</span><br><span class="line">rep movsd               ;ecx事先放好了8,这里重复执行movsd八次</span><br><span class="line">movsw</span><br><span class="line">movsb</span><br></pre></td></tr></table></figure>
<p>这里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rep movsd  </span><br><span class="line">movsw</span><br><span class="line">movsb</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三句话,让我蒙蔽了18分钟,我真是一个计组学的一塌糊涂的虚蛋</p>
<p>参考博客<a
target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33443333/article/details/113010189">标志寄存器df_标志寄存器_shikaao14的博客-CSDN博客</a></p>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506171615659.png" /></p>
<p>这里干了一个字符串拷贝的事情,<code>offset a437261636b4d65</code>这个位置的字符串作为源,<code>esp+70h+var_24</code>这个位置的缓冲区作为目的进行拷贝.</p>
<p>为什么用到了三条指令?</p>
<p>源串:<code>437261636b4d654a757374466f7246756e</code>共占用了35字节
<span class="math display">\[
35\div 4=8··\ ·3
\]</span>
首先<code>rep movsd</code>重复8次,每次拷贝4字节,一共拷贝了32字节,剩下了3个字节,拆成一个字用movsw然后最后一个字节用movsb</p>
</blockquote>
<p>上述部分做的就是拷贝.data上的字符串到栈上<code>var_24</code>开始的35个字节</p>
<p>下面进入循环体</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506181931623.png"
alt="image-20220506181931623" />
<figcaption aria-hidden="true">image-20220506181931623</figcaption>
</figure>
<h4 id="外循环外侧蓝线">外循环(外侧蓝线)</h4>
<p>这个循环体的结构很容易猜想,收集信息时我们知道如果输入字符数比较少则程序会一直重复运行,不存在循环变量,终止条件之类.因此循环体完全可以按照单独一次执行进行饭分析</p>
<h5 id="loc_40101a"><code>loc_40101A</code></h5>
<p>这是循环体的起始部分</p>
<p>一些参数及其函数调用距离太远不直观,这里调整了一些语句位置,但是不改变程序逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">loc_40101A:</span><br><span class="line">mov     ecx, 8				;rep的帮凶</span><br><span class="line">xor     eax, eax			;eax归零</span><br><span class="line">lea     edi, [esp+70h+var_48] ; edi指向了&amp;var_48</span><br><span class="line">rep stosd					;STOSB、STOSW 和 STOSD 指令分别将 AL/AX/EAX 的内容存入由 EDI 中偏移量指向的内存位置。</span><br><span class="line">stosw</span><br><span class="line">stosb</span><br><span class="line">;eax被xor指令清零了,那么这里三条指令的作用是让var_48开始的35字节的栈空间置0</span><br><span class="line"></span><br><span class="line">;打印第一句废话</span><br><span class="line">push    offset aPleaseInputYou ; &quot;please input your serial:&quot;</span><br><span class="line">call    _printf</span><br><span class="line"></span><br><span class="line">;准备获取用户输入</span><br><span class="line">lea     eax, [esp+74h+var_5C]	;eax指向&amp;var_5C</span><br><span class="line">push    eax             ;&amp;var_5C压栈作为scanf的缓冲区</span><br><span class="line">push    offset aS       ; &quot;%s&quot;压栈作为第一个参数</span><br><span class="line">call    _scanf</span><br><span class="line"></span><br><span class="line">;检查是否给了太多字符</span><br><span class="line">lea     edi, [esp+7Ch+var_5C] ; &amp;var_5C-&gt;edi</span><br><span class="line">or      ecx, 0FFFFFFFFh ; ecx置全1</span><br><span class="line">xor     eax, eax		;eax归零,如果eax为0则ZF置零,eax存放scanf返回值,即实际输入字符数</span><br><span class="line">add     esp, 0Ch		;退栈12字节,不会修改ZF位</span><br><span class="line">repne scasb				;ecx中全是1,相当于无限大,只要scanf有输入则repne成立;从var_5C指向的缓冲区中寻找0(eax中放的是0),每次ecx-1</span><br><span class="line">not     ecx             ;ecx取反</span><br><span class="line">dec     ecx             ;ecx-1</span><br><span class="line">cmp     ecx, 11h        ;检查ecx和11h=17的大小</span><br><span class="line"></span><br><span class="line">ja      loc_40110D		;跳转则寄</span><br><span class="line"></span><br><span class="line">xor     ebx, ebx		;ebx寄存器归零,在loc_40101A的结尾干了这么一件事,不明觉厉,实际上是为后来的内圈循环初始化循环变量</span><br></pre></td></tr></table></figure>
<blockquote>
<p>检查输入字符数是怎样实现的?</p>
<p>1.第25行的<code>scasb</code>从edi指向的缓冲区检查,是否存在eax中的字符,因此之前(第21行)就安置好了edi<code>lea     edi, [esp+7Ch+var_5C]</code></p>
<p>2.22行ecx置全1,需要减<code>2^8</code>次才能归零,因此该条件对第25行的repne指令没有限制作用</p>
<p>3.23行eax中是scanf的返回值,根据其值置ZF位(假设scanf获取到了输入,则eax不为0,则ZF为0),然后eax归零</p>
<p>4.24行退栈啥作用不知道,推测一开始预先多开了一些栈空间,可能是防止栈缓冲区溢出</p>
<p>5.25行repne成立的条件是<code>ecx!=0,ZF!=1</code>显然当scanf有获取到输入时是成立的,重复执行scasb,即在edi指向的<code>&amp;var_5C</code>中寻找eax中存放的值<code>0</code>,即寻找<code>var_5C</code>的结束字符,每次ecx-1</p>
<p>6.26行ecx取反,然后第27行ecx-1,啥作用呢?</p>
<blockquote>
<p>假设输入了ABC就三个字符,scanf返回后eax存3,<code>var_5C=&#123;'A','B','C',0,0,...,0&#125;</code>,</p>
<p>此时repne条件成立,在第四次检查时检查到0,目前的值为0xFFFFFFFB</p>
<p>然后ecx取反得到0b0100=4</p>
<p>然后ecx-1=3即输入字符数</p>
</blockquote>
<p>即这两步执行完后ecx存放输入字符数</p>
<p>7.28行ecx和11h进行比较,如果ecx中的值大则跳转loc_40110D,即判断输入字符是否超过了11h=17个,</p>
<p>而我们一开始收集到的信息也是字符数很多时直接程序退出</p>
<p>8.loc_40110D作用是报告失败</p>
</blockquote>
<p><code>loc_40101A</code>的作用就是获取输入并检查输入长度是否超过17字节,超过则寄,没超过则进一步检查</p>
<h5 id="loc_40105f内侧绿线"><code>loc_40105F</code>(内侧绿线)</h5>
<blockquote>
<p>在研究该部分之前,先要弄明白<code>sprintf</code>函数</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506184650282.png"
alt="image-20220506184650282" />
<figcaption aria-hidden="true">image-20220506184650282</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br></pre></td></tr></table></figure>
<p>返回值是实际str接收到的字符数,将源缓冲区从基地址到'\0'以某种格式输出到str目的缓冲区</p>
</blockquote>
<p>内圈循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">loc_40105F:</span><br><span class="line">mov     al, [esp+ebx+70h+var_5C]	;在进入循环体之前,loc_40101A最的最后,ebx置零,这里又和var_5C结合使用,可以大胆推测这是一个基址变址寻址,基址是esp+70h+var_5c即&amp;var_5C,变址即偏移量ebx,以后都记作i</span><br><span class="line">test    al, al					</span><br><span class="line">jz      short loc_4010B0			;如果var_5c[i]为0即i遍历到var_5c字符串的末尾则跳转loc_4010B0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;如果jz条件跳转未实现则var_5C[i]!=0即不是字符串末尾</span><br><span class="line">;以下将var_5C处的字符串转化成16进制格式的字符串然后放到var_48位置</span><br><span class="line"></span><br><span class="line">;将var_5c[i]转化成16进制字符串,放到buffer</span><br><span class="line">movsx   ecx, al						;var_5c[i]-&gt;ecx	;字节拓展双字</span><br><span class="line">push    ecx							;var_5c[i]-&gt;ecx-&gt;压栈作为参数</span><br><span class="line">lea     edx, [esp+74h+Buffer]		 ;&amp;Buffer-&gt;edx,			;Buffer是栈上两个字节</span><br><span class="line">push    offset Format   ; &quot;%x&quot;		  ;%x压栈作为参数</span><br><span class="line">push    edx             ; Buffer	  ;&amp;Buffer-&gt;edx-&gt;压栈作为参数</span><br><span class="line">call    _sprintf					;sprintf(&amp;Buffer,&quot;%x&quot;,&amp;var_5c[i]),返回值(写入字符总数)放eax</span><br><span class="line">							;这里sprintf函数把var_5c[i]以十六进制字符格式转换成字符串放到Buffer</span><br><span class="line">							;(Buffer两个字节,一个ascii码的16进制字符串也是两个字节)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lea     edi, [esp+7Ch+Buffer]		 ;&amp;Buffer-&gt;edi</span><br><span class="line">or      ecx, 0FFFFFFFFh				;ecx置全1</span><br><span class="line">xor     eax, eax					;根据eax置ZF,然后eax置零</span><br><span class="line">add     esp, 0Ch</span><br><span class="line">repne scasb							;寻找buffer的结束位置</span><br><span class="line">not     ecx							;ecx存放buffer的结束字符下标</span><br><span class="line">sub     edi, ecx					;edi-ecx之后edi回退到Buffer起始位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;下面加载var_48并确定其末尾位置</span><br><span class="line">lea     edx, [esp+70h+var_48]		 ;&amp;var_48-&gt;edx,		;var_48是栈上一个32字节的缓冲区</span><br><span class="line">mov     ebp, ecx					;ebp暂时保存之前的ecx</span><br><span class="line">or      ecx, 0FFFFFFFFh</span><br><span class="line"></span><br><span class="line">mov     esi, edi					;edi存放Buffer基地址,放到esi</span><br><span class="line">mov     edi, edx					;edx存放var_48基地址,放到edi		</span><br><span class="line"></span><br><span class="line">repne scasb							;寻找edi中var_48串的结束字符位置</span><br><span class="line">dec     edi							;减1后edi指向var_48的最后一个字符</span><br><span class="line"></span><br><span class="line">;这里看似是蜜汁操作,啥也没干,但是我感觉是因为没有用编译优化,编译器在将Buffer向var_48拷贝的时候,没有考虑Buffer的长度,而是假设Buffer是一个不知长度的字符串,先以最大效率双字拷贝,然后最后剩下的不足双字的1或者2或者3个字节使用字节拷贝</span><br><span class="line">;这蜜汁操作想了一下午才想明白</span><br><span class="line">mov     ecx, ebp					;ebp把之前暂时保存的值还给ecx</span><br><span class="line">shr     ecx, 2						;ecx之前存放buffer结束字符下标,现在/4必然是0</span><br><span class="line">rep movsd							;按双字拷贝,但是Buffer长度/4=0,因此实际上这三句话啥也没干</span><br><span class="line"></span><br><span class="line">mov     ecx, ebp					;ebp把之前暂时保存的值还给ecx</span><br><span class="line">and     ecx, 3						;ecx保留低2位(模4余数)</span><br><span class="line">rep movsb							;Buffer按字节拷贝到var_48</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inc     ebx							;++i;</span><br><span class="line">cmp     ebx, 11h					;判断i是否遍历完了var_5C</span><br><span class="line">jl      short loc_40105F			;如果i&lt;17则跳到本部分开头重新内圈循环,如果i&gt;=17则意味着遍历完毕,跳出内圈循环</span><br></pre></td></tr></table></figure>
<p>内圈循环做的就是将var_5c存放的串换成16进制格式,输出到var_48位置的串,以Buffer作为转换过渡</p>
<p><code>var_5c[i]--sprintf--&gt;Buffer--strcat--&gt;var_48</code></p>
<h5 id="loc_4040b0"><code>loc_4040B0</code></h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loc_4010B0:	</span><br><span class="line">lea     esi, [esp+70h+var_24]		;var_24事先放好了flag的16进制表示					&amp;var_24-&gt;esi</span><br><span class="line">lea     eax, [esp+70h+var_48]		;var_48是刚才内圈循环时将输入转换成16进制串的表示	 &amp;var_28-&gt;eax</span><br></pre></td></tr></table></figure>
<p>两个16进制数都放好了,可想而知下面要对两个数比较判断是否相同了,显然直接调用strcmp这种函数太过于明显,可能会采用逐个字节比较的方式</p>
<p>但是这样也比较容易发现,</p>
<p>当比较完了<code>*var_24</code>和<code>*var_48</code>即<code>var_24[0]</code>和<code>var_48[0]</code>之后,如果要继续比较<code>var_24[1]</code>和<code>var_48[1]</code>,需要移动一下指针,即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inc esi;</span><br><span class="line">inc eax;</span><br></pre></td></tr></table></figure>
<p>这类的指令</p>
<h5 id="loc_4010b8"><code>loc_4010B8</code></h5>
<p>按照刚才的猜想,这里应该有一个循环,实际上也是这样的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506205727285.png"
alt="image-20220506205727285" />
<figcaption aria-hidden="true">image-20220506205727285</figcaption>
</figure>
<p>我们很容易就在<code>.text:004010D2</code>找到了移动指针的语句,只不过是一次性移动两位,因为前面比较了两位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:004010B8 loc_4010B8:                             ; CODE XREF: _main+DA↓j</span><br><span class="line">.text:004010B8                 mov     dl, [eax]			;解引用</span><br><span class="line">.text:004010BA                 mov     bl, [esi]</span><br><span class="line">.text:004010BC                 mov     cl, dl</span><br><span class="line">.text:004010BE                 cmp     dl, bl</span><br><span class="line">.text:004010C0                 jnz     short loc_4010E0		;这个跳转通向 寄 ,如果不让他跳则dl和bl要相同,即两个串对应字符相同</span><br><span class="line">.text:004010C2                 test    cl, cl				;如果cl是0说明指针已经移动到空了,应当跳出循环</span><br><span class="line">.text:004010C4                 jz      short loc_4010DC		;跳出循环,通向 成功</span><br><span class="line">.text:004010C6                 mov     dl, [eax+1]			;一次性比较两个字符</span><br><span class="line">.text:004010C9                 mov     bl, [esi+1]			</span><br><span class="line">.text:004010CC                 mov     cl, dl</span><br><span class="line">.text:004010CE                 cmp     dl, bl</span><br><span class="line">.text:004010D0                 jnz     short loc_4010E0		;跳转就寄</span><br><span class="line">.text:004010D2                 add     eax, 2					;移动指针</span><br><span class="line">.text:004010D5                 add     esi, 2</span><br><span class="line">.text:004010D8                 test    cl, cl</span><br><span class="line">.text:004010DA                 jnz     short loc_4010B8		;本次两个字符都相同,继续循环判断下两个字符是否相同</span><br></pre></td></tr></table></figure>
<h5 id="尾声-1">尾声</h5>
<p>从刚才的循环出来就能够决定命运了,刚才的循环有两种跳转,一是<code>loc_4010DC</code>,另一个是<code>loc_4010E0</code></p>
<p>其中<code>loc_4010DC</code>将eax置零</p>
<p><code>loc_4010E0</code>将eax置-1</p>
<p>然后两路殊途同归到<code>loc_4010E5</code></p>
<p>而<code>loc_4010E5</code>是一个法官,只有eax值为0才让打印成功</p>
<p>如果eax值不为0则跳转<code>loc_4010FB</code>寄</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506205845976.png"
alt="image-20220506205845976" />
<figcaption aria-hidden="true">image-20220506205845976</figcaption>
</figure>
<h2 id="opensource">009opensource</h2>
<p>给出的是一段c程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;<span class="comment">//要求argc=4,argv[0]是自带的程序位置,剩下即要输入3个参数</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;what?\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> first = atoi(argv[<span class="number">1</span>]);<span class="comment">//第一个参数转化成字符串</span></span><br><span class="line">    <span class="keyword">if</span> (first != <span class="number">0xcafe</span>) &#123;<span class="comment">//要求first=51966</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;you are wrong, sorry.\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> second = atoi(argv[<span class="number">2</span>]);<span class="comment">//second为第二个参数转化成字符串</span></span><br><span class="line">    <span class="keyword">if</span> (second % <span class="number">5</span> == <span class="number">3</span> || second % <span class="number">17</span> != <span class="number">8</span>) &#123;<span class="comment">//要求second 模5不余三,模17余8</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;ha, you won&#x27;t get it!\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;h4cky0u&quot;</span>, argv[<span class="number">3</span>])) &#123;<span class="comment">//要求argv[3]=&quot;h4cky0u&quot;,长度为7</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;so close, dude!\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Brr wrrr grr\n&quot;</span>);</span><br><span class="line">	<span class="comment">//second%17=8,strlen(argv[3])=7</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash = first * <span class="number">31337</span> + (second % <span class="number">17</span>) * <span class="number">11</span> + <span class="built_in">strlen</span>(argv[<span class="number">3</span>]) - <span class="number">1615810207</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Get your key: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, hash);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三个参数可以为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">51966</span> <span class="number">25</span>  h4cky0u</span><br></pre></td></tr></table></figure>
<p>编译之后运行一下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\xctf12\opensource&gt; ./opensource 51966 25  h4cky0u</span><br><span class="line">Brr wrrr grr</span><br><span class="line">Get your key: c0ffee</span><br></pre></td></tr></table></figure>
<h2 id="no-strings-attached">010no-strings-attached</h2>
<p>尽量不依赖工具,比如ida-F5的伪代码,那么应该在以什么为基础进行分析呢?</p>
<p>objdump和ida的反汇编视图起码是可以的,没有必要和0和1组成的二进制码打交道,直接看反汇编即可</p>
<p>ida反汇编的图视图也是可以接受的,毕竟有了反汇编之后我们也可以轻松画出跳转关系和调用关系图,不妨让ida代劳了</p>
<p>ida-F5伪代码可以吗?</p>
<p>如果我能够轻松地将反汇编翻译成伪代码或者代码,那何乐而不为?但是我没这本事.</p>
<p>如果每个题上来就看伪代码对于从反汇编到伪代码的翻译是没有帮助的.</p>
<p>因此我觉得逆向分析应当基于反汇编和图视图,尽量少<del>沉迷美色</del>看伪代码</p>
<p>对于<code>no-strings-attached</code>这个ctf逆向题,前置知识:</p>
<p><code>x86</code>汇编语言(如果不看伪代码的话)</p>
<p>==宽字符==</p>
<p>置换加密算法</p>
<p>ida的使用</p>
<h3 id="main函数-1"><code>main</code>函数</h3>
<p>main函数下调用了四个函数</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220504202713613.png"
alt="image-20220504202713613" />
<figcaption aria-hidden="true">image-20220504202713613</figcaption>
</figure>
<p><code>_setlocale</code>是使用者的区域设定,比如时间,语言之类的,没有卵用</p>
<p><code>banner,prompt_authentication</code>都是打印一些语句作为提示,也没有锤子用</p>
<p><code>authenticate</code>关键在这里</p>
<h3 id="authenticate函数"><code>authenticate</code>函数</h3>
<p>粗略浏览该函数,发现有一个<code>call decrypt</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220504202933305.png"
alt="image-20220504202933305" />
<figcaption aria-hidden="true">image-20220504202933305</figcaption>
</figure>
<p>单就从<code>decrypt</code>,这种"解密"名字的函数就应该是关键函数,<code>authenticate</code>的其他部分先不管,直接看<code>decrypt</code>,</p>
<p>another(rename之后的名字)和s分别作为第二个和第一个参数传递给了<code>decrypt</code>函数</p>
<h3 id="decrypt函数"><code>decrypt</code>函数</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220504203108886.png"
alt="image-20220504203108886" />
<figcaption aria-hidden="true">image-20220504203108886</figcaption>
</figure>
<p>框框相连,转转不已,也不知道套了多少层循环了</p>
<p>首先按照CSAPP第三章的方法,将汇编翻译成带goto的c伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">decrypt</span><span class="params">(<span class="type">char</span> *s,<span class="type">char</span> *another)</span>&#123;</span><br><span class="line">    <span class="type">int</span> slength=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> anotherlength=<span class="built_in">strlen</span>(another);</span><br><span class="line">    <span class="type">char</span> *dest=(<span class="type">int</span> *)<span class="built_in">malloc</span>(slength+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dest,s);</span><br><span class="line">    <span class="keyword">goto</span> loc_80486F7;</span><br><span class="line">    loc_80486AF:</span><br><span class="line">        <span class="type">int</span> var_18=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> loc_80486E7;</span><br><span class="line"></span><br><span class="line">    loc_80486B8:</span><br><span class="line">        dest[var_1C]=dest[var_1C]-another[var_18];</span><br><span class="line">        ++var_1C;</span><br><span class="line">        ++var_18;</span><br><span class="line"></span><br><span class="line">    loc_80486E7:<span class="comment">//这一块的分析是比较繁琐的</span></span><br><span class="line">        <span class="keyword">if</span>(var_18&lt;anotherlength&amp;&amp;var_1C&lt;slength)&#123;</span><br><span class="line">            <span class="keyword">goto</span> loc_80486B8;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    loc_80486F7:</span><br><span class="line">        <span class="keyword">if</span>(var_1C&gt;=slength)&#123;</span><br><span class="line">            <span class="keyword">return</span> dest;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">goto</span> loc_80486AF;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>loc_80486E7的分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:080486B8 loc_80486B8:                            ; CODE XREF: decrypt+9D↓j</span><br><span class="line">.text:080486B8                 mov     eax, [ebp+var_1C] </span><br><span class="line">.text:080486BB                 shl     eax, 2          </span><br><span class="line">.text:080486BE                 add     eax, [ebp+dest]      ;dest+4*var_1C-&gt;eax</span><br><span class="line">.text:080486C1                 mov     edx, [ebp+var_1C]    </span><br><span class="line">.text:080486C4                 shl     edx, 2</span><br><span class="line">.text:080486C7                 add     edx, [ebp+dest]      ;dest+4*var_1C-&gt;edx</span><br><span class="line">.text:080486CA                 mov     ecx, [edx]           ;[dest+4*var_1C]-&gt;ecx</span><br><span class="line">.text:080486CC                 mov     edx, [ebp+var_18]</span><br><span class="line">.text:080486CF                 shl     edx, 2</span><br><span class="line">.text:080486D2                 add     edx, [ebp+another]   ;another+4*var_18-&gt;edx</span><br><span class="line">.text:080486D5                 mov     edx, [edx]           ;[another+4*var_18]-&gt;edx</span><br><span class="line">.text:080486D7                 mov     ebx, ecx             ;[dest+4*var_1C]-&gt;ebx</span><br><span class="line">.text:080486D9                 sub     ebx, edx             ;[dest+4*var_1C]-[another+4*var_18]-&gt;ebx</span><br><span class="line">.text:080486DB                 mov     edx, ebx             ;[dest+4*var_1C]-[another+4*var_18]-&gt;ebx-&gt;dex</span><br><span class="line">.text:080486DD                 mov     [eax], edx           ;[dest+4*var_1C]=[dest+4*var_1C]-[another+4*var_18]</span><br><span class="line">.text:080486DF                 add     [ebp+var_1C], 1      ;++var_1C</span><br><span class="line">.text:080486E3                 add     [ebp+var_18], 1      ;++var_18</span><br></pre></td></tr></table></figure>
<p>这么一长段用源代码表示就干了稀松的事情</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loc_80486B8:</span><br><span class="line">    dest[var_1C]=dest[var_1C]-another[var_18];</span><br><span class="line">    ++var_1C;</span><br><span class="line">    ++var_18;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后翻译成不带goto的c代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">decrypt</span><span class="params">(<span class="type">char</span> *s,<span class="type">char</span> *another)</span>&#123;</span><br><span class="line">    <span class="type">char</span> *dest=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dest,s);</span><br><span class="line">    <span class="type">int</span> var_18=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> var_1C=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var_1C&lt;<span class="built_in">strlen</span>(s))&#123;</span><br><span class="line">        var_18=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(var_18&lt;<span class="built_in">strlen</span>(another)&amp;&amp;var_1C&lt;<span class="built_in">strlen</span>(s))&#123;</span><br><span class="line">            dest[var_1C]=dest[var_1C]-another[var_18];</span><br><span class="line">            ++var_1C;</span><br><span class="line">            ++var_18;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里两层while循环到底干了一个什么事呢?再进一步精简一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">decrypt</span><span class="params">(<span class="type">char</span> *s,<span class="type">char</span> *key)</span>&#123;</span><br><span class="line">    <span class="type">char</span> *dest=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dest,s);</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);++i)&#123;</span><br><span class="line">        index=i%<span class="built_in">strlen</span>(key);<span class="comment">//计算s[i]应该减去的key数组中的哪一个元素</span></span><br><span class="line">        dest[i]-=another[index];<span class="comment">//位移密码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是一个位移密码解密,s是需要解密的字符串,算法是用s
的每一个字符去减key的相应位置的字符,如果key不够长则key循环使用</p>
<h3 id="回到authenticate函数">回到<code>authenticate</code>函数</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220504201120562.png"
alt="image-20220504201120562" />
<figcaption aria-hidden="true">image-20220504201120562</figcaption>
</figure>
<p>这个函数还怪长的,不看F5伪代码,应当如何解读呢?</p>
<p>首先,在分析完decrypt函数之后,我们大体上可以知道,<strong>密文和密钥都是在<code>.rodata</code>只读区存好的,然后通过decrypt解密算法得到加密前的明文,下面要做的应该是获取键盘输入,然后将刚才的明文和键盘输入进行对比</strong></p>
<p>至于为什么不直接存储明文然后和获取的键盘输入进行对比?这就好比给一个孩子一艘拼装好的乐高千年隼和一盒子千年隼零件的关系</p>
<p>考察孩子对加密算法的掌握,以及对加密算法汇编形式的掌握呗</p>
<p>然后,基于上述分析,可以推测authenticate函数要做的,大体可以分为四或者五个部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0.开端(任何函数都有,通常是压栈保存调用者函数的帧指针rbp,申请函数栈,rbp作为当前函数帧指针)</span><br><span class="line">1.解密</span><br><span class="line">2.输入</span><br><span class="line">3.处理输入(可以算是输入的一部分)</span><br><span class="line">4.字符串对比</span><br><span class="line">5.尾声(任何函数都有,通常是释放函数栈和退栈还原rbp为调用者函数的帧指针)</span><br></pre></td></tr></table></figure>
<p>顺序不一定,但是也就是这几件事了,想不出来还能干什么</p>
<p>实际分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">;0.开端</span><br><span class="line">.text:08048708                 push    ebp</span><br><span class="line">.text:08048709                 mov     ebp, esp</span><br><span class="line">.text:0804870B                 sub     esp, 8028h</span><br><span class="line"></span><br><span class="line">;1.解密获得字符串</span><br><span class="line">.text:08048711                 mov     dword ptr [esp+4], offset another ; another表示密钥,其地址压栈作为第二个参数</span><br><span class="line">.text:08048719                 mov     dword ptr [esp], offset s ; s     ; s表示需要解密的字符串,地址压栈作为参数</span><br><span class="line">.text:08048720                 call    decrypt                           ; 调用decrypt,他需要两个参数</span><br><span class="line">.text:08048725                 mov     [ebp+s2], eax                     ; decrypt返回值-&gt;eax-&gt;s2</span><br><span class="line"></span><br><span class="line">;2.键盘获得输入字符串</span><br><span class="line">.text:08048728                 mov     eax, ds:stdin@@GLIBC_2_0          ;标准键盘输入</span><br><span class="line">.text:0804872D                 mov     [esp+8], eax    ; stream          ;stdin-&gt;eax-&gt;[esp+8]作为第三个参数</span><br><span class="line">.text:08048731                 mov     dword ptr [esp+4], 2000h ; n      ;2000h-&gt;[esp+4]作为第二个参数</span><br><span class="line">.text:08048739                 lea     eax, [ebp+ws]                     ;ws-&gt;eax</span><br><span class="line">.text:0804873F                 mov     [esp], eax      ; ws              ;ws-&gt;eax-&gt;[esp]作为第一个参数</span><br><span class="line">.text:08048742                 call    _fgetws                           ;fgetws函数共需要三个参数,都已经妥善安置入栈</span><br><span class="line"></span><br><span class="line">;3.处理键盘输入</span><br><span class="line">.text:08048747                 test    eax, eax                          ;判断是否读取到至少一个字符</span><br><span class="line">;3.1如果没有获取到输入</span><br><span class="line">.text:08048749                 jz      short loc_804879C                 ;啥也没读到,跳转loc_804879C尾声</span><br><span class="line">;3.2如果获取到了输入</span><br><span class="line">.text:0804874B                 lea     eax, [ebp+ws]                     ;&amp;ws-&gt;eax</span><br><span class="line">.text:08048751                 mov     [esp], eax      ; s               ;&amp;ws-&gt;eax-&gt;[esp]压栈作为参数</span><br><span class="line">.text:08048754                 call    _wcslen                           ;&amp;ws作为参数压栈,传递给_wcslen</span><br><span class="line">.text:08048759                 sub     eax, 1                            ;strlen(ws)-1-&gt;eax</span><br><span class="line">.text:0804875C                 mov     [ebp+eax*4+ws], 0                 ;ws[strlen(ws)-1]=&#x27;\0&#x27;</span><br><span class="line"></span><br><span class="line">; 4.上述两个字符串比较</span><br><span class="line">.text:08048767                 mov     eax, [ebp+s2]                     ;decrypt返回值-&gt;s2-&gt;eax</span><br><span class="line">.text:0804876A                 mov     [esp+4], eax    ; s2              ;decrypt返回值压栈,作为第二个参数</span><br><span class="line">.text:0804876E                 lea     eax, [ebp+ws]                     ;&amp;ws-&gt;eax</span><br><span class="line">.text:08048774                 mov     [esp], eax      ; s1              ;&amp;ws-&gt;eax-&gt;[esp],作为第一个参数</span><br><span class="line">.text:08048777                 call    _wcscmp                           ;类似strcmp,输入字符串和解密后字符串比较</span><br><span class="line">.text:0804877C                 test    eax, eax                          ;判断strcmp是否返回0</span><br><span class="line">; 4.1如果不为0则两个字符串不相等</span><br><span class="line">.text:0804877E                 jnz     short loc_804878F                 ;如果不为0则跳转loc_804878F</span><br><span class="line">; 4.2否哦则即0表明两个字符串相等</span><br><span class="line">.text:08048780                 mov     eax, offset unk_8048B44           ;&amp;&quot;success welcome back&quot;-&gt;eax</span><br><span class="line">.text:08048785                 mov     [esp], eax                        ;&quot;success&quot;-&gt;[esp],作为参数</span><br><span class="line">.text:08048788                 call    _wprintf                          ;打印</span><br><span class="line">.text:0804878D                 jmp     short loc_804879C                 ;跳转尾声</span><br><span class="line">; 4.1续</span><br><span class="line">.text:0804878F ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0804878F</span><br><span class="line">.text:0804878F loc_804878F:                            ; CODE XREF: authenticate+76↑j</span><br><span class="line">.text:0804878F                 mov     eax, offset unk_8048BA4           ;&amp;&quot;Access denied&quot;-&gt;eax</span><br><span class="line">.text:08048794                 mov     [esp], eax                        ;eax-&gt;[esp]作为参数</span><br><span class="line">.text:08048797                 call    _wprintf                          ;打印</span><br><span class="line">.text:0804879C</span><br><span class="line"></span><br><span class="line">;尾声</span><br><span class="line">.text:0804879C loc_804879C:                            ; CODE XREF: authenticate+41↑j</span><br><span class="line">.text:0804879C                                         ; authenticate+85↑j</span><br><span class="line">.text:0804879C                 mov     eax, [ebp+s2]</span><br><span class="line">.text:0804879F                 mov     [esp], eax      ; ptr</span><br><span class="line">.text:080487A2                 call    _free</span><br><span class="line">.text:080487A7                 leave</span><br><span class="line">.text:080487A8                 retn</span><br><span class="line">.text:080487A8 ; &#125; // starts at 8048708</span><br><span class="line">.text:080487A8 authenticate    endp</span><br></pre></td></tr></table></figure>
<p>分析到此算是了解了authenticate的逻辑,但是有几点是我想继续研究的</p>
<h4 id="offset指令">1.<code>offset</code>指令?</h4>
<p><code>.text:08048711                 mov     dword ptr [esp+4], offset another ;</code>这里offset的作用是什么?</p>
<p>能问出这种问题来属实是我计组学的太虚了</p>
<p>首先参考了博客<a
target="_blank" rel="noopener" href="https://www.cnblogs.com/x54256/p/8097963.html">汇编语言——转移指令（offset，jmp，jcxz）
- 想54256 - 博客园 (cnblogs.com)</a></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220504204638327.png"
alt="image-20220504204638327" />
<figcaption aria-hidden="true">image-20220504204638327</figcaption>
</figure>
<p>又产生新问题,如果说<code>mov si,offset s</code>是将s的地址放到si寄存器中,那么为什么不用类似<code>lea si,[s]</code>的指令加载有效地址?</p>
<p>然后查阅了这篇博客<a
target="_blank" rel="noopener" href="https://blog.csdn.net/baoli1008/article/details/46691497">汇编语言LEA和OFFSET区别_Baoli1008的博客-CSDN博客_lea与offset的区别</a></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220504204837123.png"
alt="image-20220504204837123" />
<figcaption aria-hidden="true">image-20220504204837123</figcaption>
</figure>
<p>数据定义伪指令:</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/20191220121930628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94aW9uZzUzNS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70"
alt="数据定义伪指令" />
<figcaption aria-hidden="true">数据定义伪指令</figcaption>
</figure>
<h4
id="fgetwsfgets函数的区别">2.<code>fgetws,fgets</code>函数的区别?</h4>
<p>参考<a
target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/cpp/c-runtime-library/reference/fgets-fgetws?view=msvc-170">fgets、fgetws
| Microsoft Docs</a></p>
<p>相同点:</p>
<p>两个函数都有三个参数,从左向右分别为:数据存储位置,要读取的最大字符数,FILE结构体指针.</p>
<p>返回值都是实际读取到的字符数</p>
<p>不同点:</p>
<p><strong><code>fgetws</code></strong> 是
<strong><code>fgets</code></strong> 的宽字符版本。</p>
<h4 id="宽字符">宽字符?</h4>
<p>啥是宽字符?用多个<a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/字节/1096318">字节</a>来代表的字符称之为宽字符。</p>
<p>unicode是宽字符之一,但是已经实际上成为了宽字符的具体实现方法,windows上的c语言宽字符就是unicode,用两个字节表示一个字符</p>
<p>ASCII码表用一共字节表示一个字符,一个字节的值有<code>2^8=256</code>种即ASCII码最多有256个,对于键盘上出现的所有字符已经足够了</p>
<p>但是对于汉字,法语,日语等等各种语言,ASCII能表示的字符数真的太逊了,</p>
<p>而unicode码两个字节表示一个字符,两个字节的值有<code>2^16&gt;60000</code>,</p>
<p>而相对比较复杂的汉字,大约就3000常用汉字,因此unicode是有能力表示地球上的各种字符的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220504210716190.png"
alt="image-20220504210716190" />
<figcaption aria-hidden="true">image-20220504210716190</figcaption>
</figure>
<p>12345ABCDE一共10个字符,结尾还有一个'\0'字符,因此<code>char cstr</code>是11字节,<code>wchar_t wcstr</code>是22个字节</p>
<p>取<code>wchar_t</code>类型的数组长度的函数不是<code>strlen</code>,是<code>wcslen</code>,有多少个有意义的字符(不包括结尾'\0')wcslen函数就返回多少</p>
<p>宽字符类型的字符串字面量前需要有L修饰,不写会报错</p>
<p><code>[错误] cannot initialize array of 'wchar_t' 从 a string literal with type array of 'char'</code></p>
<p>unicode部分码表:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align: left;">编码(十进制)</th>
<th>编码(十六进制)</th>
</tr>
</thead>
<tbody>
<tr>
<td>小写字母(a~z)</td>
<td style="text-align: left;">97~122</td>
<td>61~7a</td>
</tr>
<tr>
<td>大写字母(A~Z)</td>
<td style="text-align: left;">65~90</td>
<td>41~5a</td>
</tr>
<tr>
<td>左右花括号{}</td>
<td style="text-align: left;">{123,125}</td>
<td>{7b,7d}</td>
</tr>
<tr>
<td>阿拉伯数字</td>
<td style="text-align: left;">48~57</td>
<td>30~39</td>
</tr>
</tbody>
</table>
<h4
id="事先存在的密文和密钥放在哪里access-denied等字样又放在那里">3.事先存在的密文和密钥放在哪里?<code>"Access denied"</code>等字样又放在那里?</h4>
<p>在authenticate函数里面双击s观察s的存储</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.rodata:08048AA8 ; const wchar_t s</span><br><span class="line">.rodata:08048AA8 s               db 3Ah                  ; DATA XREF: authenticate+11↑o</span><br><span class="line">.rodata:08048AA9                 db  14h</span><br><span class="line">.rodata:08048AAA                 db    0		;蜜汁0</span><br><span class="line">.rodata:08048AAB                 db    0		;蜜汁0</span><br><span class="line">.rodata:08048AAC                 dd 1436h</span><br><span class="line">.rodata:08048AB0                 db  37h ; 7</span><br><span class="line">.rodata:08048AB1                 db  14h</span><br><span class="line">.rodata:08048AB2                 db    0		;蜜汁0</span><br><span class="line">.rodata:08048AB3                 db    0</span><br><span class="line">.rodata:08048AB4                 db  3Bh ; ;</span><br><span class="line">.rodata:08048AB5                 db  14h</span><br><span class="line">.rodata:08048AB6                 db    0</span><br><span class="line">.rodata:08048AB7                 db    0</span><br><span class="line">.rodata:08048AB8                 db  80h</span><br><span class="line">.rodata:08048AB9                 db  14h</span><br><span class="line">.rodata:08048ABA                 db    0</span><br><span class="line">.rodata:08048ABB                 db    0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>.rodata</code>是常量区,在程序运行之前,在编译时就能确定</p>
<p>s是宽字符数组,每个元素都是<code>wchar_t</code>类型,占两个字节,小端存储的话就可以写为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x1434 0000 0x1436 0000 0x1437....</span><br></pre></td></tr></table></figure>
<p>奇怪的是为什么其中会有很多0?为什么字符不能够紧凑存放?</p>
<p>能问出这种问题来属实是我c基础太差了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220504235300627.png"
alt="image-20220504235300627" />
<figcaption aria-hidden="true">image-20220504235300627</figcaption>
</figure>
<p><code>sizeof('a')</code>和<code>sizeof(char)</code>的结果竟然不一样</p>
<p>查阅资料,<code>a</code>是<strong>字符常量</strong>,却以int四字节存储</p>
<p>因此对rodata段的s应该这样断句:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.rodata:08048AA8 s               db 3Ah                  ; DATA XREF: authenticate+11↑o</span><br><span class="line">.rodata:08048AA9                 db  14h</span><br><span class="line">.rodata:08048AAA                 db    0</span><br><span class="line">.rodata:08048AAB                 db    0</span><br><span class="line"></span><br><span class="line">.rodata:08048AAC                 db 36h</span><br><span class="line">.rodata:08048AAD                 db  14h</span><br><span class="line">.rodata:08048AAE                 db    0</span><br><span class="line">.rodata:08048AAF                 db    0</span><br><span class="line"></span><br><span class="line">.rodata:08048AB0                 db  37h ; 7</span><br><span class="line">.rodata:08048AB1                 db  14h</span><br><span class="line">.rodata:08048AB2                 db    0</span><br><span class="line">.rodata:08048AB3                 db    0</span><br><span class="line"></span><br><span class="line">.rodata:08048AB4                 db  3Bh ; ;</span><br><span class="line">.rodata:08048AB5                 db  14h</span><br><span class="line">.rodata:08048AB6                 db    0</span><br><span class="line">.rodata:08048AB7                 db    0</span><br><span class="line"></span><br><span class="line">.rodata:08048AB8                 db  80h</span><br><span class="line">.rodata:08048AB9                 db  14h</span><br><span class="line">.rodata:08048ABA                 db    0</span><br><span class="line">.rodata:08048ABB                 db    0</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在IDA View视图上选中s的元素然后convert to array(DWORD)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220504235955441.png"
alt="image-20220504235955441" />
<figcaption aria-hidden="true">image-20220504235955441</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[+] Dump <span class="number">0x8048AA8</span> - <span class="number">0x8048B43</span> (<span class="number">155</span> bytes) :</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> s[<span class="number">39</span>] = &#123;</span><br><span class="line">    <span class="number">0x0000143A</span>, <span class="number">0x00001436</span>, <span class="number">0x00001437</span>, <span class="number">0x0000143B</span>, <span class="number">0x00001480</span>, <span class="number">0x0000147A</span>, <span class="number">0x00001471</span>, <span class="number">0x00001478</span>, </span><br><span class="line">    <span class="number">0x00001463</span>, <span class="number">0x00001466</span>, <span class="number">0x00001473</span>, <span class="number">0x00001467</span>, <span class="number">0x00001462</span>, <span class="number">0x00001465</span>, <span class="number">0x00001473</span>, <span class="number">0x00001460</span>, </span><br><span class="line">    <span class="number">0x0000146B</span>, <span class="number">0x00001471</span>, <span class="number">0x00001478</span>, <span class="number">0x0000146A</span>, <span class="number">0x00001473</span>, <span class="number">0x00001470</span>, <span class="number">0x00001464</span>, <span class="number">0x00001478</span>, </span><br><span class="line">    <span class="number">0x0000146E</span>, <span class="number">0x00001470</span>, <span class="number">0x00001470</span>, <span class="number">0x00001464</span>, <span class="number">0x00001470</span>, <span class="number">0x00001464</span>, <span class="number">0x0000146E</span>, <span class="number">0x0000147B</span>, </span><br><span class="line">    <span class="number">0x00001476</span>, <span class="number">0x00001478</span>, <span class="number">0x0000146A</span>, <span class="number">0x00001473</span>, <span class="number">0x0000147B</span>, <span class="number">0x00001480</span>, <span class="number">0x00000000</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>就得到了s数组</p>
<p>同样的道理another字符数组也位于.rodata区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[+] Dump <span class="number">0x8048A90</span> - <span class="number">0x8048AA7</span> (<span class="number">23</span> bytes) :</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> another[<span class="number">6</span>] = &#123;</span><br><span class="line">    <span class="number">0x00001401</span>, <span class="number">0x00001402</span>, <span class="number">0x00001403</span>, <span class="number">0x00001404</span>, <span class="number">0x00001405</span>, <span class="number">0x00000000</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样的道理,"Success..."等字样也位于.rodata区</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220505000407437.png"
alt="image-20220505000407437" />
<figcaption aria-hidden="true">image-20220505000407437</figcaption>
</figure>
<h3 id="解密">解密</h3>
<p>用c程序解密</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> s[<span class="number">39</span>] = &#123;</span><br><span class="line">	<span class="number">0x0000143A</span>, <span class="number">0x00001436</span>, <span class="number">0x00001437</span>, <span class="number">0x0000143B</span>, <span class="number">0x00001480</span>, <span class="number">0x0000147A</span>, <span class="number">0x00001471</span>, <span class="number">0x00001478</span>,</span><br><span class="line">	<span class="number">0x00001463</span>, <span class="number">0x00001466</span>, <span class="number">0x00001473</span>, <span class="number">0x00001467</span>, <span class="number">0x00001462</span>, <span class="number">0x00001465</span>, <span class="number">0x00001473</span>, <span class="number">0x00001460</span>,</span><br><span class="line">	<span class="number">0x0000146B</span>, <span class="number">0x00001471</span>, <span class="number">0x00001478</span>, <span class="number">0x0000146A</span>, <span class="number">0x00001473</span>, <span class="number">0x00001470</span>, <span class="number">0x00001464</span>, <span class="number">0x00001478</span>,</span><br><span class="line">	<span class="number">0x0000146E</span>, <span class="number">0x00001470</span>, <span class="number">0x00001470</span>, <span class="number">0x00001464</span>, <span class="number">0x00001470</span>, <span class="number">0x00001464</span>, <span class="number">0x0000146E</span>, <span class="number">0x0000147B</span>,</span><br><span class="line">	<span class="number">0x00001476</span>, <span class="number">0x00001478</span>, <span class="number">0x0000146A</span>, <span class="number">0x00001473</span>, <span class="number">0x0000147B</span>, <span class="number">0x00001480</span>, <span class="number">0x00000000</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> another[<span class="number">6</span>] = &#123;</span><br><span class="line">	<span class="number">0x00001401</span>, <span class="number">0x00001402</span>, <span class="number">0x00001403</span>, <span class="number">0x00001404</span>, <span class="number">0x00001405</span>, <span class="number">0x00000000</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">wchar_t</span> ans[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">38</span>; i++) &#123;</span><br><span class="line">		index = i % <span class="number">5</span>;</span><br><span class="line">		s[i] -= another[index];</span><br><span class="line">		swprintf(&amp;ans[i], <span class="string">L&quot;%s&quot;</span>, &amp;s[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%ls&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9447&#123;you_are_an_international_mystery&#125;</span><br></pre></td></tr></table></figure>
<h2 id="csaw2013reversing2">011csaw2013reversing2</h2>
<h3 id="信息收集-3">信息收集</h3>
<p>运行程序之后直接弹窗,推测是一个win32API-messageBox</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506092936536.png"
alt="image-20220506092936536" />
<figcaption aria-hidden="true">image-20220506092936536</figcaption>
</figure>
<p>上面都是写的乱码,下面三个选择框都导致程序结束</p>
<h3 id="静态分析-2">静态分析</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/critical.png"
alt="critical" />
<figcaption aria-hidden="true">critical</figcaption>
</figure>
<p>正常运行时执行左侧逻辑,但是左侧逻辑就是用win32API-messageBox显示了一些乱码,没有卵用</p>
<p>因此应该审查调试运行时的逻辑,应该只要是调试运行就可以执行<code>sub_4001000</code>但是没有打印输出,估计调试器可以观察出某些变量的值,</p>
<p>但是我目前只会用gdb调试器,但是这个题给出的文件明显编译时没有-g选项,没有调试信息</p>
<p>还是从静态分析入手,分析解密函数<code>sub_401000</code></p>
<h3 id="解密函数sub_401000">解密函数<code>sub_401000</code></h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506095147714.png"
alt="image-20220506095147714" />
<figcaption aria-hidden="true">image-20220506095147714</figcaption>
</figure>
<p>解密算法就是把s字符数组四个字符按照小端规则看成一个双字去和双字类型的<code>key=0xDDCCAABB</code>按位异或,然后再将双字拆成四个ascii字符即得到flag</p>
<p>堆上的缓冲区s拷贝的是<code>unk_409B10</code>,将其转化为c双字数组</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506095859599.png"
alt="image-20220506095859599" />
<figcaption aria-hidden="true">image-20220506095859599</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> unk_409B10[<span class="number">9</span>] = &#123;</span><br><span class="line">    <span class="number">0xBCA0CCBB</span>, <span class="number">0xB8BED1DC</span>, <span class="number">0xAEBECFCD</span>, <span class="number">0x82ABC4D2</span>, <span class="number">0xB393D9D2</span>, <span class="number">0xA993DED4</span>, <span class="number">0x82B8CBD3</span>, <span class="number">0xB9BECBD3</span>, </span><br><span class="line">    <span class="number">0x00CCD79A</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>解密程序:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">IntAndChar4</span> &#123;</span></span><br><span class="line">protected:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> inInt;<span class="comment">//inInt和inChar[4]共用四个字节</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> inChar[<span class="number">4</span>];</span><br><span class="line">public:</span><br><span class="line">	<span class="type">void</span> <span class="title function_">setInt</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;i)</span> &#123;</span><br><span class="line">		inInt = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">getInt</span><span class="params">()</span><span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> inInt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> <span class="title function_">getString</span><span class="params">()</span><span class="type">const</span> &#123;</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">			s += inChar[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">	friend ostream &amp;operator&lt;&lt;(ostream &amp;os, <span class="type">const</span> IntAndChar4 &amp;iac4) &#123;</span><br><span class="line">		os &lt;&lt; iac4.getString();</span><br><span class="line">		<span class="keyword">return</span> os;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; iac4[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> key = <span class="number">0xDDCCAABB</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> encrypted[<span class="number">9</span>] = &#123;</span><br><span class="line">	<span class="number">0xBCA0CCBB</span>, <span class="number">0xB8BED1DC</span>, <span class="number">0xAEBECFCD</span>, <span class="number">0x82ABC4D2</span>, <span class="number">0xB393D9D2</span>, <span class="number">0xA993DED4</span>, <span class="number">0x82B8CBD3</span>, <span class="number">0xB9BECBD3</span>,</span><br><span class="line">	<span class="number">0x00CCD79A</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">		iac4[i].setInt(key ^ encrypted[i]);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; iac4[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	decrypt();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;reversing_is_not_that_hard!&#125;</span><br></pre></td></tr></table></figure>
<h2 id="maze">012maze</h2>
<p>尽量不看源代码,用CSAPP第三章的方法,将汇编语言首先转化为带goto和label的伪代码,然后转为不带goto和label的伪代码</p>
<p>这个题的名字<code>maze</code>很有意思,迷宫,既体现在反汇编翻译成伪代码时分支众多,又体现在最后使用走迷宫的方法获得flag</p>
<h3 id="main">main</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004006B0 ; int __fastcall main(int, char **, char **)</span><br><span class="line">;注意调用方式,所有局部变量的地址都基于栈顶指针rsp计算,不基于帧指针计算</span><br><span class="line">.text:00000000004006B0 main            proc near               ; DATA XREF: start+1D↑o</span><br><span class="line">.text:00000000004006B0</span><br><span class="line">.text:00000000004006B0 var_28          = dword ptr -28h</span><br><span class="line">.text:00000000004006B0 var_24          = dword ptr -24h</span><br><span class="line">.text:00000000004006B0</span><br><span class="line">.text:00000000004006B0 ; __unwind &#123;</span><br><span class="line"></span><br><span class="line">;开端,参数压栈,保存寄存器</span><br><span class="line">.text:00000000004006B0                 push    rbp</span><br><span class="line">.text:00000000004006B1                 push    r15</span><br><span class="line">.text:00000000004006B3                 push    r14</span><br><span class="line">.text:00000000004006B5                 push    rbx</span><br><span class="line">.text:00000000004006B6                 push    rax</span><br><span class="line"></span><br><span class="line">;栈上开了两个局部变量,var_24和var_28</span><br><span class="line">.text:00000000004006B7                 mov     [rsp+28h+var_24], 0</span><br><span class="line">.text:00000000004006BF                 mov     [rsp+28h+var_28], 0</span><br><span class="line"></span><br><span class="line">;提醒用户输入</span><br><span class="line">.text:00000000004006C6                 mov     edi, offset s   ; &quot;Input flag:&quot;</span><br><span class="line">.text:00000000004006CB                 call    _puts</span><br><span class="line"></span><br><span class="line">;获取用户输入</span><br><span class="line">.text:00000000004006D0                 mov     edi, offset format ; &quot;%s&quot;</span><br><span class="line">.text:00000000004006D5                 mov     esi, offset s1;s1作为第一个参数传递给_scanf,作为缓冲区承载输入</span><br><span class="line">.text:00000000004006DA                 xor     eax, eax</span><br><span class="line">.text:00000000004006DC                 call    _scanf</span><br><span class="line"></span><br><span class="line">;获取输入字符串的长度并与18h=24字节进行比较</span><br><span class="line">.text:00000000004006E1                 mov     edi, offset s1  ; s</span><br><span class="line">.text:00000000004006E6                 call    _strlen</span><br><span class="line">.text:00000000004006EB                 mov     rbx, rax</span><br><span class="line">.text:00000000004006EE                 cmp     rbx, 18h</span><br><span class="line"></span><br><span class="line">;如果长度不够则跳转loc_400822报告失败</span><br><span class="line">.text:00000000004006F2                 jnz     loc_400822</span><br><span class="line"></span><br><span class="line">;否则即输入长度为18h=24字节,验证前五个字符和最后一个字符是否是nctf&#123;balabala&#125;这种结构</span><br><span class="line">.text:00000000004006F8                 mov     edi, offset s1  ; s1</span><br><span class="line">.text:00000000004006FD                 mov     esi, offset s2  ; &quot;nctf&#123;&quot;</span><br><span class="line">.text:0000000000400702                 mov     edx, 5          ; n</span><br><span class="line">.text:0000000000400707                 call    _strncmp</span><br><span class="line">.text:000000000040070C                 test    eax, eax</span><br><span class="line">.text:000000000040070E                 jnz     loc_400822</span><br><span class="line">.text:0000000000400714                 movzx   eax, ds:byte_6010BF[rbx]</span><br><span class="line">.text:000000000040071B                 cmp     eax, 7Dh ; &#x27;&#125;&#x27;</span><br><span class="line">.text:000000000040071E                 jnz     loc_400822</span><br><span class="line"></span><br><span class="line">;设定循环变量初始值</span><br><span class="line">.text:0000000000400724                 mov     edi, offset s1  ; s</span><br><span class="line">.text:0000000000400729                 call    _strlen</span><br><span class="line">.text:000000000040072E                 dec     rax			;strlen(s1)-1-&gt;rax指向s1的最后一个非0字符的下标</span><br><span class="line">.text:0000000000400731                 mov     ebx, 5		;从5开始是由于0到4这前五个字符已经判断过是nctf&#123;了,ebx将会作为循环变量i</span><br><span class="line">.text:0000000000400736                 cmp     rax, 5		;判断strlen(s1)-1和5的大小,即判断s1串除了nctf&#123;&#125;之外有无其他字符</span><br><span class="line">.text:000000000040073A                 jbe     loc_4007EE</span><br><span class="line"></span><br><span class="line">;其他循环体变量初始化</span><br><span class="line">.text:0000000000400740                 lea     r14, [rsp+28h+var_28];r14=&amp;var_28,一定要分清r14里面放的是var_28的地址</span><br><span class="line">.text:0000000000400744                 lea     r15, [rsp+28h+var_24];r25=&amp;var_24</span><br><span class="line">.text:0000000000400749                 nop     dword ptr [rax+00000000h];nop指令什么也不干</span><br><span class="line">.text:0000000000400750</span><br><span class="line"></span><br><span class="line">;下面进入循环体</span><br><span class="line">;始终注意:</span><br><span class="line">;r14=&amp;var_28</span><br><span class="line">;r15=&amp;var_24</span><br><span class="line">;rbx中放的是循环变量i</span><br><span class="line">;s1是输入的字符串</span><br><span class="line">;后来会用到的asc_601060是data区的一个全局字符数组,&#x27;  *******   *  **** * ****  * ***  *#  *** *** ***     *********&#x27;</span><br><span class="line">;rbx作为循环变量,用来遍历s1字符数组,s1[rbx]相当于s1[i]</span><br><span class="line">;后面专门摘出循环体进行分析</span><br><span class="line">.text:0000000000400750 loc_400750:                             ; CODE XREF: main+133↓j</span><br><span class="line">.text:0000000000400750                 movsx   eax, ds:s1[rbx]</span><br><span class="line">.text:0000000000400757                 xor     ebp, ebp</span><br><span class="line">.text:0000000000400759                 cmp     eax, 4Eh ; &#x27;N&#x27;</span><br><span class="line">.text:000000000040075C                 jg      short loc_400780</span><br><span class="line">.text:000000000040075E                 movzx   eax, al</span><br><span class="line">.text:0000000000400761                 cmp     eax, 2Eh ; &#x27;.&#x27;</span><br><span class="line">.text:0000000000400764                 jz      short loc_4007A0</span><br><span class="line">.text:0000000000400766                 cmp     eax, 30h ; &#x27;0&#x27;</span><br><span class="line">.text:0000000000400769                 jnz     short loc_4007BB</span><br><span class="line">.text:000000000040076B                 mov     rdi, r14</span><br><span class="line">.text:000000000040076E                 call    sub_400680;小函数,作用是修改</span><br><span class="line">.text:0000000000400773                 jmp     short loc_4007B8</span><br><span class="line">.text:0000000000400773 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400775                 align 20h</span><br><span class="line">.text:0000000000400780</span><br><span class="line">.text:0000000000400780 loc_400780:                             ; CODE XREF: main+AC↑j</span><br><span class="line">.text:0000000000400780                 movzx   eax, al</span><br><span class="line">.text:0000000000400783                 cmp     eax, 4Fh ; &#x27;O&#x27;</span><br><span class="line">.text:0000000000400786                 jz      short loc_4007B0</span><br><span class="line">.text:0000000000400788                 cmp     eax, 6Fh ; &#x27;o&#x27;</span><br><span class="line">.text:000000000040078B                 jnz     short loc_4007BB</span><br><span class="line">.text:000000000040078D                 mov     rdi, r15</span><br><span class="line">.text:0000000000400790                 call    sub_400660</span><br><span class="line">.text:0000000000400795                 jmp     short loc_4007B8</span><br><span class="line">.text:0000000000400795 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400797                 align 20h</span><br><span class="line">.text:00000000004007A0</span><br><span class="line">.text:00000000004007A0 loc_4007A0:                             ; CODE XREF: main+B4↑j</span><br><span class="line">.text:00000000004007A0                 mov     rdi, r14</span><br><span class="line">.text:00000000004007A3                 call    sub_400670</span><br><span class="line">.text:00000000004007A8                 jmp     short loc_4007B8</span><br><span class="line">.text:00000000004007A8 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000004007AA                 align 10h</span><br><span class="line">.text:00000000004007B0</span><br><span class="line">.text:00000000004007B0 loc_4007B0:                             ; CODE XREF: main+D6↑j</span><br><span class="line">.text:00000000004007B0                 mov     rdi, r15</span><br><span class="line">.text:00000000004007B3                 call    sub_400650</span><br><span class="line">.text:00000000004007B8</span><br><span class="line">.text:00000000004007B8 loc_4007B8:                             ; CODE XREF: main+C3↑j</span><br><span class="line">.text:00000000004007B8                                         ; main+E5↑j ...</span><br><span class="line">.text:00000000004007B8                 mov     bpl, al</span><br><span class="line">.text:00000000004007BB</span><br><span class="line">.text:00000000004007BB loc_4007BB:                             ; CODE XREF: main+B9↑j</span><br><span class="line">.text:00000000004007BB                                         ; main+DB↑j</span><br><span class="line">.text:00000000004007BB                 mov     esi, [rsp+28h+var_24]</span><br><span class="line">.text:00000000004007BF                 mov     edx, [rsp+28h+var_28]</span><br><span class="line">.text:00000000004007C2                 mov     edi, offset asc_601060 ; &quot;  *******   *  **** * ****  * ***  *#  &quot;...</span><br><span class="line">.text:00000000004007C7                 call    sub_400690</span><br><span class="line">.text:00000000004007CC                 test    al, al</span><br><span class="line">.text:00000000004007CE                 jz      short loc_400822;此处也可能出循环,当al即sub_400690返回值为0则跳出循环</span><br><span class="line">.text:00000000004007D0                 inc     rbx</span><br><span class="line">.text:00000000004007D3                 mov     edi, offset s1  ; s</span><br><span class="line">.text:00000000004007D8                 call    _strlen</span><br><span class="line">.text:00000000004007DD                 dec     rax</span><br><span class="line">.text:00000000004007E0                 cmp     rbx, rax;判断rbx是否遍历完了s1字符串</span><br><span class="line">.text:00000000004007E3                 jb      loc_400750</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;出了循环体,下面判断bpl是否为0</span><br><span class="line">.text:00000000004007E9                 test    bpl, bpl</span><br><span class="line">.text:00000000004007EC                 jz      short loc_40080B</span><br><span class="line"></span><br><span class="line">;检查出循环时,var_24+8*var_28是否等于23h=35字节,如果是则报告成功</span><br><span class="line">.text:00000000004007EE</span><br><span class="line">.text:00000000004007EE loc_4007EE:                             ; CODE XREF: main+8A↑j</span><br><span class="line">.text:00000000004007EE                 movsxd  rax, [rsp+28h+var_24]</span><br><span class="line">.text:00000000004007F3                 movsxd  rcx, [rsp+28h+var_28]</span><br><span class="line">.text:00000000004007F7                 movzx   eax, byte ptr asc_601060[rax+rcx*8] ; &quot;  *******   *  **** * ****  * ***  *#  &quot;...</span><br><span class="line">.text:00000000004007FF                 cmp     eax, 23h ; &#x27;#&#x27;</span><br><span class="line">.text:0000000000400802                 jnz     short loc_40080B</span><br><span class="line"></span><br><span class="line">;置成功</span><br><span class="line">.text:0000000000400804                 mov     edi, offset aCongratulation ; &quot;Congratulations!&quot;</span><br><span class="line">.text:0000000000400809                 jmp     short loc_400810</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;置失败</span><br><span class="line">.text:000000000040080B ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040080B</span><br><span class="line">.text:000000000040080B loc_40080B:                             ; CODE XREF: main+13C↑j</span><br><span class="line">.text:000000000040080B                                         ; main+152↑j</span><br><span class="line">.text:000000000040080B                 mov     edi, offset aWrongFlag ; &quot;Wrong flag!&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:0000000000400810</span><br><span class="line">.text:0000000000400810 loc_400810:                             ; CODE XREF: main+159↑j</span><br><span class="line">.text:0000000000400810                 call    _puts;打印刚才存放在edi中的字符串地址指向的字符串,可能是失败或成功</span><br><span class="line"></span><br><span class="line">;函数尾声</span><br><span class="line">.text:0000000000400815                 xor     eax, eax</span><br><span class="line">.text:0000000000400817                 add     rsp, 8</span><br><span class="line">.text:000000000040081B                 pop     rbx</span><br><span class="line">.text:000000000040081C                 pop     r14</span><br><span class="line">.text:000000000040081E                 pop     r15</span><br><span class="line">.text:0000000000400820                 pop     rbp</span><br><span class="line">.text:0000000000400821                 retn</span><br><span class="line"></span><br><span class="line">;置失败</span><br><span class="line">.text:0000000000400822 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400822</span><br><span class="line">.text:0000000000400822 loc_400822:                             ; CODE XREF: main+42↑j</span><br><span class="line">.text:0000000000400822                                         ; main+5E↑j ...</span><br><span class="line">.text:0000000000400822                 mov     edi, offset aWrongFlag ; &quot;Wrong flag!&quot;</span><br><span class="line">.text:0000000000400827                 call    _puts</span><br><span class="line">.text:000000000040082C                 mov     edi, 0FFFFFFFFh ; status</span><br><span class="line">.text:0000000000400831                 call    _exit</span><br><span class="line">.text:0000000000400831 ; &#125; // starts at 4006B0</span><br><span class="line">.text:0000000000400831 main            endp</span><br><span class="line">.text:0000000000400831</span><br><span class="line">.text:0000000000400831 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400836                 align 20h</span><br></pre></td></tr></table></figure>
<h3 id="循环体分析-1">循环体分析</h3>
<p>循环体是本题关键</p>
<p>对于循环体,摘出来翻译成伪代码</p>
<p>其中一些sub_400680,sub_400670,sub_400660,sub_400650都是小函数,其作用是对var_24或var_28进行加一或者减一操作,然后根据他俩的值置bpl的值是否为0</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506084842338.png"
alt="image-20220506084842338" />
<figcaption aria-hidden="true">image-20220506084842338</figcaption>
</figure>
<p>如果想要得到congratulations的结果,必须满足:</p>
<p>1.循环体每执行一遍,最后的时候都要满足<code>asc_601060[var_24+var_28*8]==' '||asc_601060[var_24+var_28*8]=='#'</code></p>
<p>2.出循环的时候<code>asc_601060[var_24+8*var_28]='#'</code>即<code>var_24+8*var_28=36</code>,并且bpl不能为0</p>
<h3 id="问题转化">问题转化</h3>
<p>而<code>asc_601060="  *******   *  **** * ****  * ***  *#  *** *** ***     *********"</code></p>
<p>其中空格字符的下标为<code>0, 1, 9, 10, 11, 13, 14, 19, 21, 26, 27, 29, 33, 34, 36, 37, 38, 42, 46, 50, 51, 52, 53, 54</code></p>
<p>如果要满足1的话,<code>var_24+var_28*8=0, 1, 9, 10, 11, 13, 14, 19, 21, 26, 27, 29, 33, 34, 36, 37, 38, 42, 46, 50, 51, 52, 53, 54</code></p>
<p>要满足2的话,最终结果<code>var_24+var_28*8=36</code>,bpl是一个循环中附带计算的值,现在不方便讨论其取值,</p>
<p>但是可以确定的是,如果出循环的时候<code>var_24或者var_28</code>有小于0或者大于8,则bpl一定为0,</p>
<p>那么可以<strong>粗略</strong>的认为<code>var_24,var_28</code>取值都在<code>[0,8]</code>之间(说粗略是因为有可能var_24,var_28在循环中可以越界但是后来又退进了[0,8])</p>
<h3 id="转化成一维状态转移">转化成一维状态转移</h3>
<p>将上述两点分析转化成一个深度优先搜索或者说动态规划的问题</p>
<p>把<code>var_24,var_28</code>的值表示为<code>(var_24,var_28)</code>的数对<code>(x,y)</code>,比如<code>(1,2)</code>就表示<code>var_24=1,var_28=2</code>,</p>
<p>一个数对与一个整数
建立映射关系<code>(var_24,var_28)-&gt;var_24+8*var_28</code></p>
<p>初始时状态为<code>(0,0)-&gt;0</code></p>
<p>结束时状态为<code>(x,y)-&gt;36</code></p>
<p>中间的合法状态映射成的整数值有<code>0, 1, 9, 10, 11, 13, 14, 19, 21, 26, 27, 29, 33, 34, 36, 37, 38, 42, 46, 50, 51, 52, 53, 54</code></p>
<p>状态转移有四种情况: <span class="math display">\[
(x,y)\rightarrow\begin{cases}
(x-1,y)\\
(x+1,y)\\
(x,y-1)\\
(x,y+1)\\
\end{cases}
\]</span></p>
<p>下面就找一条路径,使得这个映射值从0转移到36,中途的任何数对的映射值都应当落在合法值域中</p>
<p>可以写一深度优先搜索实现该问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; legal = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">21</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">29</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">42</span>, <span class="number">46</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLegal</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;n)</span> </span>&#123;<span class="comment">//判断一个映射值是否输入legal合法映射值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : legal) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == n)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> visited[<span class="number">10</span>][<span class="number">10</span>];<span class="comment">//记忆化搜索</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Path</span> &#123;<span class="comment">//记录中途经过状态的结构体</span></span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	<span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Path &amp;p) &#123;</span><br><span class="line">		os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)=&quot;</span> &lt;&lt; p.x + p.y * <span class="number">8</span>;</span><br><span class="line">		<span class="keyword">return</span> os;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setCoordinate</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x, <span class="type">const</span> <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">		<span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; path[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> directors[<span class="number">20</span>];<span class="comment">//移动方向</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x, <span class="type">const</span> <span class="type">int</span> &amp;y, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; <span class="number">8</span> || y &lt; <span class="number">0</span> || y &gt; <span class="number">8</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//粗略条件剪枝</span></span><br><span class="line">	<span class="keyword">if</span> (visited[x][y])</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//记忆化搜索剪枝</span></span><br><span class="line">	visited[x][y] = <span class="literal">true</span>;<span class="comment">//设置访问过</span></span><br><span class="line">	<span class="type">int</span> sum = x + <span class="number">8</span> * y;<span class="comment">//计算映射值</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isLegal</span>(sum) == <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//不合法,剪枝</span></span><br><span class="line">	path[depth].<span class="built_in">setCoordinate</span>(x, y);<span class="comment">//合法,记录路径</span></span><br><span class="line">	<span class="keyword">if</span> (sum == <span class="number">36</span>) &#123;<span class="comment">//判断映射值是否已经为终点值36</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向其他状态转移</span></span><br><span class="line">	directors[depth + <span class="number">1</span>] = <span class="string">&#x27;o&#x27;</span>;<span class="comment">//方向数组,记录转义方向</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">DFS</span>(x + <span class="number">1</span>, y, depth + <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	directors[depth + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">DFS</span>(x, y + <span class="number">1</span>, depth + <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	directors[depth + <span class="number">1</span>] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">DFS</span>(x - <span class="number">1</span>, y, depth + <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	directors[depth + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">DFS</span>(x, y - <span class="number">1</span>, depth + <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">DFS</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;<span class="comment">//从x=0,y=0,深度depth=0开始</span></span><br><span class="line">	<span class="comment">//如果成功da则打印方向数组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">			cout &lt;&lt; directors[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o0oo00O000oooo..OO</span><br></pre></td></tr></table></figure>
<p>刚好18个字符,加上头尾的nctf{}之后</p>
<p><code>nctf&#123;o0oo00O000oooo..OO&#125;</code>刚好24个字符,满足所有限制条件,因此得到了flag</p>
<h3 id="转化为二维迷宫">转化为二维迷宫</h3>
<p>做完了看了别人的writeup才恍然大悟</p>
<p>考虑为什么<code>var_24+var_28*8</code>这里有一个*8?</p>
<p>如果将<code>asc_601060="  *******   *  **** * ****  * ***  *#  *** *** ***     *********"</code>以8字节为单位换行则得到:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  ******</span><br><span class="line">*   *  *</span><br><span class="line">*** * **</span><br><span class="line">**  * **</span><br><span class="line">*  *#  *</span><br><span class="line">** *** *</span><br><span class="line">**     *</span><br><span class="line">********</span><br></pre></td></tr></table></figure>
<p>星号,空格,井号的宽度不一样因此这里看上去对不齐</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506091352319.png"
alt="image-20220506091352319" />
<figcaption aria-hidden="true">image-20220506091352319</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220506091523194.png"
alt="image-20220506091523194" />
<figcaption aria-hidden="true">image-20220506091523194</figcaption>
</figure>
<p>右下右右下下左下下下右右右右上上左左</p>
<p>翻译成oO0.四个字符就是<code>o0oo00O000oooo..OO</code></p>
<p>同样可以得到flag</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/04/28/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/28/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/" class="post-title-link" itemprop="url">调用约定</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-28 16:27:00" itemprop="dateCreated datePublished" datetime="2022-04-28T16:27:00+08:00">2022-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-03-10 19:22:05" itemprop="dateModified" datetime="2025-03-10T19:22:05+08:00">2025-03-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="调用约定">调用约定</h1>
<p>为啥CSAPP第三章x86-64汇编学完了,但是看IDA的反汇编仍然是一头雾水?还得看一大堆东西,其中就有调用约定</p>
<p>为什么windows上和linux上,x86和x64上编译出来的代码有很多不同,为什么和CSAPP说的相差甚远?调用约定不同是一大原因</p>
<p>首先要说明的几点,也是实验中和查阅资料逐渐获得的几点</p>
<p>1.==各种调用约定是相对于x86而言的==,对x64无意义</p>
<blockquote>
<p>The keywords <code>_stdcall</code> and <code>_cdecl</code> specify
32-bit calling conventions. That's why they are not relevant for 64-bit
programs (i.e. x64). On x64, there is only the <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_x64_calling_convention">standard
calling convention</a> and the extended <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_vectorcall"><code>__vectorcall</code></a>
calling convenction.</p>
<p>来自stackoverflow</p>
</blockquote>
<p>关键词<code>_stdcall</code>和<code>_cdecl</code>特指32位的调用约定.64位上不一样,64位上只有标准调用约定,还有其拓展<code>__vectorcall</code></p>
<p>即使在64位的函数前面用<code>__cdecl</code>或者<code>__stdcall</code>修饰,编译结果也是一样的</p>
<p>2.x86和x64汇编有较大出入,windows上和linux上的同一约定也有些许区别</p>
<h2 id="x86上的调用约定">x86上的调用约定</h2>
<p>微软给出的==x86系统==上的调用约定:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220427184436835.png"
alt="image-20220427184436835" />
<figcaption aria-hidden="true">image-20220427184436835</figcaption>
</figure>
<p>一定注意是x86系统上的,而我们现在的笔记本大多数都是x64系统了,会有一些出入</p>
<h3 id="c调用约定__cdecl">c调用约定<code>__cdecl</code></h3>
<p>C Declaration</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;return_type&gt; __cdecl &lt;func_name&gt;(para1,para2,...,paran);</span><br></pre></td></tr></table></figure>
<p>对于x86系统,微软官方文档是这样写的:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220427184750211.png"
alt="x86" />
<figcaption aria-hidden="true">x86</figcaption>
</figure>
<p>维基百科这样写的:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220428152115878.png"
alt="image-20220428152115878" />
<figcaption aria-hidden="true">image-20220428152115878</figcaption>
</figure>
<p>在gcc编译的时候加入-m32选项即可使用32位编译,编译成x86系统的程序</p>
<p><code>test.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _cdecl <span class="title function_">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> d,<span class="type">int</span> e,<span class="type">int</span> f,<span class="type">int</span> g,<span class="type">int</span> h)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b+c+d+e+f+g+h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _cdecl <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _cdecl <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -O0 test.c -c -m32 -o test.o|objdump -d test.o &gt; test.s|code test.s</span><br></pre></td></tr></table></figure>
<p>使用-m32编译之后然后反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">test.o:     file format pe-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;_func&gt;:</span><br><span class="line">   0:	55                   	push   %ebp</span><br><span class="line">   1:	89 e5                	mov    %esp,%ebp			;蜜汁操作,有esp为啥还要获取一个ebp作为拷贝?</span><br><span class="line">   3:	8b 55 08             	mov    0x8(%ebp),%edx</span><br><span class="line">   6:	8b 45 0c             	mov    0xc(%ebp),%eax</span><br><span class="line">   9:	01 c2                	add    %eax,%edx</span><br><span class="line">   b:	8b 45 10             	mov    0x10(%ebp),%eax</span><br><span class="line">   e:	01 c2                	add    %eax,%edx</span><br><span class="line">  10:	8b 45 14             	mov    0x14(%ebp),%eax</span><br><span class="line">  13:	01 c2                	add    %eax,%edx</span><br><span class="line">  15:	8b 45 18             	mov    0x18(%ebp),%eax</span><br><span class="line">  18:	01 c2                	add    %eax,%edx</span><br><span class="line">  1a:	8b 45 1c             	mov    0x1c(%ebp),%eax</span><br><span class="line">  1d:	01 c2                	add    %eax,%edx</span><br><span class="line">  1f:	8b 45 20             	mov    0x20(%ebp),%eax</span><br><span class="line">  22:	01 c2                	add    %eax,%edx</span><br><span class="line">  24:	8b 45 24             	mov    0x24(%ebp),%eax</span><br><span class="line">  27:	01 d0                	add    %edx,%eax</span><br><span class="line">  29:	5d                   	pop    %ebp</span><br><span class="line">  2a:	c3                   	ret    </span><br><span class="line"></span><br><span class="line">0000002b &lt;_show&gt;:</span><br><span class="line">  2b:	55                   	push   %ebp</span><br><span class="line">  2c:	89 e5                	mov    %esp,%ebp</span><br><span class="line">  2e:	83 ec 20             	sub    $0x20,%esp			;申请0x20=32字节空间,刚好8个int参数×一个int是4个字节,但是蜜汁操作,为啥不用push逐次压栈,而是一次性申请空间</span><br><span class="line">  31:	c7 44 24 1c 08 00 00 	movl   $0x8,0x1c(%esp)		</span><br><span class="line">  38:	00 </span><br><span class="line">  39:	c7 44 24 18 07 00 00 	movl   $0x7,0x18(%esp)		;每个参数占用栈上4个字节,8个参数紧挨着</span><br><span class="line">  40:	00 </span><br><span class="line">  41:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)</span><br><span class="line">  48:	00 </span><br><span class="line">  49:	c7 44 24 10 05 00 00 	movl   $0x5,0x10(%esp)</span><br><span class="line">  50:	00 </span><br><span class="line">  51:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)</span><br><span class="line">  58:	00 </span><br><span class="line">  59:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)</span><br><span class="line">  60:	00 </span><br><span class="line">  61:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)</span><br><span class="line">  68:	00 </span><br><span class="line">  69:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)			;栈顶一定存放的是最左侧的参数</span><br><span class="line">  70:	e8 8b ff ff ff       	call   0 &lt;_func&gt;</span><br><span class="line">  75:	c9                   	leave  						;蜜汁指令,CSAPP上没有见过leave指令</span><br><span class="line">  76:	c3                   	ret    </span><br><span class="line"></span><br><span class="line">00000077 &lt;_main&gt;:</span><br><span class="line">  77:	55                   	push   %ebp</span><br><span class="line">  78:	89 e5                	mov    %esp,%ebp</span><br><span class="line">  7a:	83 e4 f0             	and    $0xfffffff0,%esp</span><br><span class="line">  7d:	e8 00 00 00 00       	call   82 &lt;_main+0xb&gt;</span><br><span class="line">  82:	e8 a4 ff ff ff       	call   2b &lt;_show&gt;</span><br><span class="line">  87:	b8 00 00 00 00       	mov    $0x0,%eax			;返回值放在eax,rax寄存器中</span><br><span class="line">  8c:	c9                   	leave  						</span><br><span class="line">  8d:	c3                   	ret    </span><br><span class="line">  8e:	90                   	nop</span><br><span class="line">  8f:	90                   	nop</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>32位系统必定不会用到r开头的4字64位寄存器比如<code>rax,rdx,rsp</code>等等,最大用到e开头的寄存器,比如<code>eax,esp</code></p>
<p>可以发现show函数在调用func函数,传参的时候没有用到一个寄存器,全都是用的堆栈,还可以发现函数名都是由下划线前缀的<code>&lt;_main&gt;,&lt;_func&gt;,&lt;_show&gt;</code></p>
<p>在为函数参数申请栈空间的时候是一次性完成的,即有8个参数则直接在栈上申请0x20=32字节,然后分别用movl指令向栈上刚才申请的空间写入数据.</p>
<blockquote>
<p><strong>关于蜜汁操作参数的压栈方式,是一次性申请足够的空间然后mov还是逐次push?</strong></p>
<p>stackoverflow上的说法:</p>
<blockquote>
<blockquote>
<ol type="1">
<li>Why does x64 use <code>mov</code> rather than <code>push</code>? I
assume it's just more efficient and wasn't available in x86.</li>
</ol>
</blockquote>
<p>That is not the reason. Both of these instructions also exist in x86
assembly language.</p>
<p>效率并且是否可实现不是原因.这两种指令(push和mov)在x86汇编语言中都存在</p>
<p>The reason why your compiler is not emitting a <code>push</code>
instruction for the x64 code is probably because it must adjust the
stack pointer directly anyway, in order to create 32 bytes of "shadow
space" for the called function. See <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_x64_calling_convention">this
link</a> (which was provided by <span class="citation"
data-cites="NateEldredge">@NateEldredge</span>) for further information
on "shadow space".</p>
<p>编译器对x64不使用push指令的原因是:他需要直接调整栈顶指针,给前四个参数的压栈预留"影子空间"</p>
<p>x86不需要寄存器传递参数但是x64需要寄存器并且在被调用函数的一开始会把寄存器中的参数也压栈,那么这些寄存器中的参数将会压入影子空间.具体见后文的实验</p>
</blockquote>
</blockquote>
<blockquote>
<p><strong>关于蜜汁操作ebp(rbp)寄存器的作用</strong>:</p>
<p>行为:在每个函数开始时都会被压入栈中然后拷贝栈顶指针,在有些函数快要结束的时候又会从栈中获取先前压入栈中的值</p>
<p>比如一个典型的结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2b:	55                   	push   %ebp</span><br><span class="line">2c:	89 e5                	mov    %esp,%ebp</span><br><span class="line">2e:	83 ec 20             	sub    $0x20,%esp</span><br></pre></td></tr></table></figure>
<p>查阅<a
target="_blank" rel="noopener" href="https://stackoverflow.com/questions/41912684/what-is-the-purpose-of-the-rbp-register-in-x86-64-assembler">stackoverflow</a></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220427195841367.png"
alt="image-20220427195841367" />
<figcaption aria-hidden="true">image-20220427195841367</figcaption>
</figure>
<blockquote>
<p><code>rbp</code> is the frame pointer on x86_64. In your generated
code, it gets a snapshot of the stack pointer (<code>rsp</code>) so that
when adjustments are made to <code>rsp</code> (i.e. reserving space for
local variables or <code>push</code>ing values on to the stack), local
variables and function parameters are still accessible from a constant
offset from <code>rbp</code>.</p>
<p>A lot of compilers offer frame pointer omission as an optimization
option; this will make the generated assembly code access variables
relative to <code>rsp</code> instead and free up <code>rbp</code> as
another general purpose register for use in functions.</p>
<p>In the case of GCC, which I'm guessing you're using from the AT&amp;T
assembler syntax, that switch is <code>-fomit-frame-pointer</code>. Try
compiling your code with that switch and see what assembly code you get.
You will probably notice that when accessing values relative to
<code>rsp</code> instead of <code>rbp</code>, the offset from the
pointer varies throughout the function.</p>
</blockquote>
<p>rbp是x86_64上的栈帧指针.在我们的代码中,rbp寄存器获取栈顶指针rsp的快照.</p>
<p>当rsp改变时(比如为局部变量预留空间或者通过push指令压栈),我们仍然可以通过使用rbp+偏移量这种方式调用上一个函数(或者说调用者)的局部变量或者函数参数.</p>
<p>很多编译器的优化,会不用上述方式(rbp+偏移量)调用上一个函数的局部变量或者函数参数,而是只用rsp+偏移量.然后省出rbp寄存器去干其他事.对于GCC编译器,使用<code>-fomit-frame-pointer</code>编译选项达到上述目的</p>
<p>按照我的理解,rbp的作用就是调用者的rsp副本,然后rsp为被调用者服务,rbp为调用者服务.</p>
<p>rbp只是在被调用者嗲用调用者的局部变量时,令寻址更方便,完全可以只用rsp达到目的</p>
<blockquote>
<p>后来的实践证明我一开始的理解是错误的</p>
<p>rbp指向函数栈帧的高地址,即栈底,rsp指向函数栈帧的低地址,即栈顶</p>
<p>二者都是为当前函数服务的</p>
<p>函数的开端时会将上一个函数的rbp指针压栈保存,然后指向当前函数栈帧的栈底.函数尾声时会将上一个函数的rbp指针退栈还给rbp</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -O0 -fomit-frame-pointer test.c -c -m64 -o test.o|objdump -d test.o &gt; test.s|code test.s</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000000000000d6 &lt;main&gt;:</span><br><span class="line">  d6:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  da:	e8 00 00 00 00       	callq  df &lt;main+0x9&gt;</span><br><span class="line">  df:	e8 ae ff ff ff       	callq  92 &lt;show&gt;</span><br><span class="line">  e4:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  e9:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  ed:	c3                   	retq   </span><br><span class="line">  ee:	90                   	nop</span><br><span class="line">  ef:	90                   	nop</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用<code>-fomit-frame-pointer</code>编译选项之后确实ebp不踪影了</p>
<p>现在再看这个结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2b:	55                   	push   %ebp				;将上一个函数对上上个函数的ebp保存</span><br><span class="line">2c:	89 e5                	mov    %esp,%ebp		;ebp获取上一个函数esp的副本</span><br><span class="line">2e:	83 ec 20             	sub    $0x20,%esp		;esp为当前函数服务</span><br></pre></td></tr></table></figure>
<p>最后将栈中刚才压入的ebp又还给ebp是还原上个函数对上上个函数的esp副本</p>
</blockquote>
<blockquote>
<p><strong>关于蜜汁指令leave</strong>:</p>
<p>百度百科给出的解释:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220427224030429.png"
alt="image-20220427224030429" />
<figcaption aria-hidden="true">image-20220427224030429</figcaption>
</figure>
<p>一定要注意,这里指令的源和目的操作数与我们通篇是相反的</p>
<p>这里百科给出的解释使用的是intel风格的汇编语言,<code>mov 目的操作数,源操作数</code></p>
<p>寄存器前面有百分号的是AT&amp;T风格的汇编语言,<code>movq 源操作数,目的操作数</code></p>
<p>leave指令在AT&amp;T风格下相当于:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl %ebp,%esp</span><br><span class="line">pop %ebp</span><br></pre></td></tr></table></figure>
<p>而这刚好和每个函数一开始的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push   %ebp</span><br><span class="line">mov    %esp,%ebp</span><br></pre></td></tr></table></figure>
<p>恰好相反</p>
<p>因此leave指令就是还原栈的一个过程</p>
</blockquote>
<h3 id="标准调用约定__stdcall">标准调用约定<code>__stdcall</code></h3>
<p>微软官方文档给出的解释:</p>
<blockquote>
<p>The <strong><code>__stdcall</code></strong> calling convention is
used to call Win32 API functions. The callee cleans the stack, so the
compiler makes <code>vararg</code> functions
<strong><code>__cdecl</code></strong>. Functions that use this calling
convention require a function prototype. The
<strong><code>__stdcall</code></strong> modifier is
Microsoft-specific.</p>
</blockquote>
<p><code>__stdcall</code>用于修饰==Win32
API函数==.被调用者负责情理自己的函数栈,(因此编译器会把变参函数修饰为<code>__cdecl</code>(调用者清理栈容易实现变参)).使用<code>__stdcall</code>的函数需要一个函数原型(即接口)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return-type __stdcall function-name[( argument-list )]</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Element</th>
<th style="text-align: left;">Implementation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Argument-passing
order<br />参数传递顺序</td>
<td style="text-align: left;">Right to left.<br />从右向左</td>
</tr>
<tr>
<td style="text-align: left;">Argument-passing
convention<br />参数传递规则(值传递/引用传递)</td>
<td style="text-align: left;">By value, unless a pointer or reference
type is passed.<br />除非参数是指针或者引用类型,否则采用值传递</td>
</tr>
<tr>
<td style="text-align: left;">Stack-maintenance
responsibility<br />栈维护</td>
<td style="text-align: left;">Called function pops its own arguments
from the stack.<br />被调用者自己清理自己用到的栈</td>
</tr>
<tr>
<td style="text-align: left;">Name-decoration
convention<br />命名修饰规则</td>
<td style="text-align: left;">An underscore (<code>_</code>) is prefixed
to the name. The name is followed by the at sign (<code>@</code>)
followed by the number of bytes (in decimal) in the argument list.
Therefore, the function declared as
<code>int func( int a, double b )</code> is decorated as follows:
<code>_func@12</code><br />下划线开头,然后@,然后是十进制表示的参数表字节大小.<br />因此<code>int func(int a,double b)</code>将会被修饰为<code>_func@12</code>(int四个字节+double八个字节)</td>
</tr>
<tr>
<td style="text-align: left;">Case-translation
convention<br />大小写转换规定</td>
<td style="text-align: left;">None<br />无</td>
</tr>
<tr>
<td style="text-align: left;">返回值位置</td>
<td style="text-align: left;">放在eax,rax寄存器中</td>
</tr>
</tbody>
</table>
<blockquote>
<p>用ida打开一个win32程序,其Winmain函数是这样分析的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)</span><br><span class="line">.text:00401000 __stdcall WinMain(x, x, x, x) proc near ; CODE XREF: start+C9↓p</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 hInstance       = dword ptr  4</span><br><span class="line">.text:00401000 hPrevInstance   = dword ptr  8</span><br><span class="line">.text:00401000 lpCmdLine       = dword ptr  0Ch</span><br><span class="line">.text:00401000 nShowCmd        = dword ptr  10h</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     eax, [esp+hInstance]</span><br><span class="line">.text:00401004                 push    0               ; dwInitParam</span><br><span class="line">.text:00401006                 push    offset DialogFunc ; lpDialogFunc</span><br><span class="line">.text:0040100B                 push    0               ; hWndParent</span><br><span class="line">.text:0040100D                 push    65h ; &#x27;e&#x27;       ; lpTemplateName</span><br><span class="line">.text:0040100F                 push    eax             ; hInstance</span><br><span class="line">.text:00401010                 mov     hInstance, eax</span><br><span class="line">.text:00401015                 call    ds:DialogBoxParamA</span><br><span class="line">.text:0040101B                 xor     eax, eax</span><br><span class="line">.text:0040101D                 retn    10h				;retn指令可以带参数</span><br><span class="line">.text:0040101D __stdcall WinMain(x, x, x, x) endp</span><br></pre></td></tr></table></figure>
<p>可以明显观察到,参数只使用栈传递,从右向左压栈,Winmain函数的栈帧:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220428092006441.png"
alt="image-20220428092006441" />
<figcaption aria-hidden="true">image-20220428092006441</figcaption>
</figure>
<p>有一点与<code>__cdecl</code>不同的是<code>retn 10h</code>,并且貌似与官方文档不同的是,被调用者没有自己清理自己的堆栈,比如Winmain到结束了也没有看见退栈指令.</p>
<p>实际上这就是<code>retn 10h</code>要做的事情</p>
<p><code>10h=16字节</code>然而四个参数刚好每个4字节,即<code>retn XXh</code>就是被调用者的退栈指令,和返回指令合并成一条指令了</p>
<p>如此减少了清理堆栈需要使用的指令</p>
</blockquote>
<p>还是<code>test.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _stdcall <span class="title function_">func</span><span class="params">(<span class="type">short</span> a,<span class="type">short</span> b,<span class="type">short</span> c,<span class="type">short</span> d,<span class="type">short</span> e,<span class="type">short</span> f,<span class="type">short</span> g,<span class="type">short</span> h)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a+b+c+d+e+f+g+h;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _stdcall <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _stdcall <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>gcc,objdump,vscode</code>素质三连</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\reverse\test_call&gt; gcc test.c -O0 -m32 -c -o test.o</span><br><span class="line">PS C:\Users\86135\Desktop\reverse\test_call&gt; objdump test.o -d &gt;test.s</span><br><span class="line">PS C:\Users\86135\Desktop\reverse\test_call&gt; code test.s</span><br></pre></td></tr></table></figure>
<p>反汇编如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">test.o:     file format pe-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;_func@32&gt;:										;函数名&lt;_func@32&gt;下划线,@,参数表大小(单位:字节)</span><br><span class="line">   0:	55                   	push   %ebp</span><br><span class="line">   1:	89 e5                	mov    %esp,%ebp</span><br><span class="line">   3:	57                   	push   %edi					;寄存器临时压栈保存,为后来的运算做准备,最后还要弹栈复原</span><br><span class="line">   4:	56                   	push   %esi</span><br><span class="line">   5:	53                   	push   %ebx</span><br><span class="line">   6:	83 ec 28             	sub    $0x28,%esp</span><br><span class="line">   9:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line">   c:	8b 4d 0c             	mov    0xc(%ebp),%ecx</span><br><span class="line">   f:	8b 5d 10             	mov    0x10(%ebp),%ebx</span><br><span class="line">  12:	89 5d d0             	mov    %ebx,-0x30(%ebp)</span><br><span class="line">  15:	8b 75 14             	mov    0x14(%ebp),%esi</span><br><span class="line">  18:	89 75 cc             	mov    %esi,-0x34(%ebp)</span><br><span class="line">  1b:	8b 7d 18             	mov    0x18(%ebp),%edi</span><br><span class="line">  1e:	8b 75 1c             	mov    0x1c(%ebp),%esi</span><br><span class="line">  21:	8b 5d 20             	mov    0x20(%ebp),%ebx</span><br><span class="line">  24:	8b 55 24             	mov    0x24(%ebp),%edx</span><br><span class="line">  27:	66 89 45 f0          	mov    %ax,-0x10(%ebp)</span><br><span class="line">  2b:	89 c8                	mov    %ecx,%eax</span><br><span class="line">  2d:	66 89 45 ec          	mov    %ax,-0x14(%ebp)</span><br><span class="line">  31:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax</span><br><span class="line">  35:	66 89 45 e8          	mov    %ax,-0x18(%ebp)</span><br><span class="line">  39:	0f b7 45 cc          	movzwl -0x34(%ebp),%eax</span><br><span class="line">  3d:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)</span><br><span class="line">  41:	89 f8                	mov    %edi,%eax</span><br><span class="line">  43:	66 89 45 e0          	mov    %ax,-0x20(%ebp)</span><br><span class="line">  47:	89 f0                	mov    %esi,%eax</span><br><span class="line">  49:	66 89 45 dc          	mov    %ax,-0x24(%ebp)</span><br><span class="line">  4d:	89 d8                	mov    %ebx,%eax</span><br><span class="line">  4f:	66 89 45 d8          	mov    %ax,-0x28(%ebp)</span><br><span class="line">  53:	89 d0                	mov    %edx,%eax</span><br><span class="line">  55:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)</span><br><span class="line">  59:	0f bf 55 f0          	movswl -0x10(%ebp),%edx</span><br><span class="line">  5d:	0f bf 45 ec          	movswl -0x14(%ebp),%eax</span><br><span class="line">  61:	01 c2                	add    %eax,%edx</span><br><span class="line">  63:	0f bf 45 e8          	movswl -0x18(%ebp),%eax</span><br><span class="line">  67:	01 c2                	add    %eax,%edx</span><br><span class="line">  69:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax</span><br><span class="line">  6d:	01 c2                	add    %eax,%edx</span><br><span class="line">  6f:	0f bf 45 e0          	movswl -0x20(%ebp),%eax</span><br><span class="line">  73:	01 c2                	add    %eax,%edx</span><br><span class="line">  75:	0f bf 45 dc          	movswl -0x24(%ebp),%eax</span><br><span class="line">  79:	01 c2                	add    %eax,%edx</span><br><span class="line">  7b:	0f bf 45 d8          	movswl -0x28(%ebp),%eax</span><br><span class="line">  7f:	01 c2                	add    %eax,%edx</span><br><span class="line">  81:	0f bf 45 d4          	movswl -0x2c(%ebp),%eax</span><br><span class="line">  85:	01 d0                	add    %edx,%eax</span><br><span class="line">  87:	83 c4 28             	add    $0x28,%esp</span><br><span class="line">  8a:	5b                   	pop    %ebx							;对应函数开始时将寄存器压栈保存,现在退栈复原</span><br><span class="line">  8b:	5e                   	pop    %esi</span><br><span class="line">  8c:	5f                   	pop    %edi</span><br><span class="line">  8d:	5d                   	pop    %ebp</span><br><span class="line">  8e:	c2 20 00             	ret    $0x20						;被调用者自行清理自己的栈</span><br><span class="line"></span><br><span class="line">00000091 &lt;_show@0&gt;:</span><br><span class="line">  91:	55                   	push   %ebp</span><br><span class="line">  92:	89 e5                	mov    %esp,%ebp</span><br><span class="line">  94:	83 ec 20             	sub    $0x20,%esp				;一次性分配0x20=32字节空间然后使用mov指令将参数压栈</span><br><span class="line">  97:	c7 44 24 1c 08 00 00 	movl   $0x8,0x1c(%esp)</span><br><span class="line">  9e:	00 </span><br><span class="line">  9f:	c7 44 24 18 07 00 00 	movl   $0x7,0x18(%esp)</span><br><span class="line">  a6:	00 </span><br><span class="line">  a7:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)</span><br><span class="line">  ae:	00 </span><br><span class="line">  af:	c7 44 24 10 05 00 00 	movl   $0x5,0x10(%esp)</span><br><span class="line">  b6:	00 </span><br><span class="line">  b7:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)</span><br><span class="line">  be:	00 </span><br><span class="line">  bf:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)</span><br><span class="line">  c6:	00 </span><br><span class="line">  c7:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)</span><br><span class="line">  ce:	00 </span><br><span class="line">  cf:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)</span><br><span class="line">  d6:	e8 25 ff ff ff       	call   0 &lt;_func@32&gt;</span><br><span class="line">  db:	83 ec 20             	sub    $0x20,%esp				</span><br><span class="line">  de:	c9                   	leave  </span><br><span class="line">  df:	c3                   	ret    </span><br><span class="line"></span><br><span class="line">000000e0 &lt;_main@0&gt;:</span><br><span class="line">  e0:	55                   	push   %ebp</span><br><span class="line">  e1:	89 e5                	mov    %esp,%ebp</span><br><span class="line">  e3:	83 e4 f0             	and    $0xfffffff0,%esp</span><br><span class="line">  e6:	e8 00 00 00 00       	call   eb &lt;_main@0+0xb&gt;</span><br><span class="line">  eb:	e8 a1 ff ff ff       	call   91 &lt;_show@0&gt;</span><br><span class="line">  f0:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  f5:	c9                   	leave  </span><br><span class="line">  f6:	c3                   	ret    </span><br><span class="line">  f7:	90                   	nop</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>&lt;<ida权威指南>&gt;上给出的建议</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220428092612932.png"
alt="image-20220428092612932" />
<figcaption aria-hidden="true">image-20220428092612932</figcaption>
</figure>
<h3 id="微软__fastcall">微软<code>__fastcall</code></h3>
<p>&lt;<ida权威指南>&gt;是这样写的:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220428154840944.png"
alt="image-20220428154840944" />
<figcaption aria-hidden="true">image-20220428154840944</figcaption>
</figure>
<p>微软官方文档:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220428155346372.png"
alt="image-20220428155346372" />
<figcaption aria-hidden="true">image-20220428155346372</figcaption>
</figure>
<p>同样的程序,除了main函数之外,其他函数都用<code>_fastcall</code>修饰</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _fastcall <span class="title function_">func</span><span class="params">(<span class="type">short</span> a,<span class="type">short</span> b,<span class="type">short</span> c,<span class="type">short</span> d,<span class="type">short</span> e,<span class="type">short</span> f,<span class="type">short</span> g,<span class="type">short</span> h)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a+b+c+d+e+f+g+h;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _fastcall <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span>&#123;<span class="comment">//如果main也用_fastcall修饰则报错没有入口点</span></span><br><span class="line">    show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用MSVC编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\86135\Desktop\reverse\test_call&gt;cl test.c</span><br><span class="line">用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.29.30139 版</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">test.c</span><br><span class="line">Microsoft (R) Incremental Linker Version 14.29.30139.0</span><br><span class="line">Copyright (C) Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line">/out:test.exe</span><br><span class="line">test.obj</span><br></pre></td></tr></table></figure>
<p>然后反编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump test.obj -d &gt;test.s</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">test.obj:     file format pe-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text$mn:</span><br><span class="line"></span><br><span class="line">00000000 &lt;@func@32&gt;:									;函数命名规则是@函数名@参数字节数</span><br><span class="line">   0:	55                   	push   %ebp</span><br><span class="line">   1:	8b ec                	mov    %esp,%ebp</span><br><span class="line">   3:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line">   6:	66 89 55 f8          	mov    %dx,-0x8(%ebp)</span><br><span class="line">   a:	66 89 4d fc          	mov    %cx,-0x4(%ebp)</span><br><span class="line">   e:	0f bf 45 fc          	movswl -0x4(%ebp),%eax</span><br><span class="line">  12:	0f bf 4d f8          	movswl -0x8(%ebp),%ecx</span><br><span class="line">  16:	03 c1                	add    %ecx,%eax</span><br><span class="line">  18:	0f bf 55 08          	movswl 0x8(%ebp),%edx</span><br><span class="line">  1c:	03 c2                	add    %edx,%eax</span><br><span class="line">  1e:	0f bf 4d 0c          	movswl 0xc(%ebp),%ecx</span><br><span class="line">  22:	03 c1                	add    %ecx,%eax</span><br><span class="line">  24:	0f bf 55 10          	movswl 0x10(%ebp),%edx</span><br><span class="line">  28:	03 c2                	add    %edx,%eax</span><br><span class="line">  2a:	0f bf 4d 14          	movswl 0x14(%ebp),%ecx</span><br><span class="line">  2e:	03 c1                	add    %ecx,%eax</span><br><span class="line">  30:	0f bf 55 18          	movswl 0x18(%ebp),%edx</span><br><span class="line">  34:	03 c2                	add    %edx,%eax</span><br><span class="line">  36:	0f bf 4d 1c          	movswl 0x1c(%ebp),%ecx</span><br><span class="line">  3a:	03 c1                	add    %ecx,%eax</span><br><span class="line">  3c:	8b e5                	mov    %ebp,%esp</span><br><span class="line">  3e:	5d                   	pop    %ebp</span><br><span class="line">  3f:	c2 18 00             	ret    $0x18				;被调用者清理自己的栈</span><br><span class="line">  42:	cc                   	int3   </span><br><span class="line">  43:	cc                   	int3   </span><br><span class="line">  44:	cc                   	int3   </span><br><span class="line">  45:	cc                   	int3   </span><br><span class="line">  46:	cc                   	int3   </span><br><span class="line">  47:	cc                   	int3   </span><br><span class="line">  48:	cc                   	int3   </span><br><span class="line">  49:	cc                   	int3   </span><br><span class="line">  4a:	cc                   	int3   </span><br><span class="line">  4b:	cc                   	int3   </span><br><span class="line">  4c:	cc                   	int3   </span><br><span class="line">  4d:	cc                   	int3   </span><br><span class="line">  4e:	cc                   	int3   </span><br><span class="line">  4f:	cc                   	int3   </span><br><span class="line"></span><br><span class="line">00000050 &lt;@show@0&gt;:</span><br><span class="line">  50:	55                   	push   %ebp</span><br><span class="line">  51:	8b ec                	mov    %esp,%ebp</span><br><span class="line">  53:	6a 08                	push   $0x8</span><br><span class="line">  55:	6a 07                	push   $0x7</span><br><span class="line">  57:	6a 06                	push   $0x6</span><br><span class="line">  59:	6a 05                	push   $0x5</span><br><span class="line">  5b:	6a 04                	push   $0x4</span><br><span class="line">  5d:	6a 03                	push   $0x3</span><br><span class="line">  5f:	ba 02 00 00 00       	mov    $0x2,%edx					;顶多有两个参数放在寄存器传递,其余都用栈</span><br><span class="line">  64:	b9 01 00 00 00       	mov    $0x1,%ecx</span><br><span class="line">  69:	e8 00 00 00 00       	call   6e &lt;@show@0+0x1e&gt;</span><br><span class="line">  6e:	5d                   	pop    %ebp</span><br><span class="line">  6f:	c3                   	ret    </span><br><span class="line"></span><br><span class="line">00000070 &lt;_main&gt;:</span><br><span class="line">  70:	55                   	push   %ebp</span><br><span class="line">  71:	8b ec                	mov    %esp,%ebp</span><br><span class="line">  73:	e8 00 00 00 00       	call   78 &lt;_main+0x8&gt;</span><br><span class="line">  78:	33 c0                	xor    %eax,%eax</span><br><span class="line">  7a:	5d                   	pop    %ebp</span><br><span class="line">  7b:	c3                   	ret    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="微软__thiscall">微软<code>__thiscall</code></h3>
<p>微软官方文档:</p>
<blockquote>
<p>The <strong>Microsoft-specific</strong>
<strong><code>__thiscall</code></strong> calling convention is used on
C++ class member functions on the x86 architecture. It's the default
calling convention used by member functions that don't use variable
arguments (<code>vararg</code> functions).</p>
<p>微软特有的<code>__thiscall</code>调用约定用于x86体系上C++的成员函数.定参函数默认使用该种调用约定</p>
<p>Under <strong><code>__thiscall</code></strong>, the callee cleans the
stack, which is impossible for <code>vararg</code> functions. Arguments
are pushed on the stack from right to left. The
<strong><code>this</code></strong> pointer is passed via register ECX,
and not on the stack.</p>
<p>如果函数有<code>__thiscall</code>修饰则被调用者清理自己的栈,因此变参函数难以实现.</p>
<p>函数参数从右向左压栈.this指针通过ECX寄存器传递</p>
<p>On ARM, ARM64, and x64 machines,
<strong><code>__thiscall</code></strong> is accepted and ignored by the
compiler. That's because they use a register-based calling convention by
default.</p>
<p>在ARM,ARM64还有x64机器上,<code>__thiscall</code>会被编译器直接忽略.因为编译器默认使用一种基于寄存器的调用约定</p>
</blockquote>
<p>&lt;<ida权威指南>&gt;</p>
<figure>
<img
src="../AppData/Roaming/Typora/typora-user-images/image-20220428161940071.png"
alt="image-20220428161940071" />
<figcaption aria-hidden="true">image-20220428161940071</figcaption>
</figure>
<h2 id="x64上的调用约定">x64上的调用约定</h2>
<h3 id="microsoft-x64-calling-convention">Microsoft x64 calling
convention</h3>
<p><a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_x64_calling_convention">微软x64调用约定</a></p>
<blockquote>
<p>The Microsoft x64 calling convention[<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#cite_note-ms-18">18]</a>[<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#cite_note-19">19]</a>
is followed on <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Windows_(operating_system)">Windows</a>
and pre-boot <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/UEFI">UEFI</a> (for
<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Long_mode">long mode</a> on <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86-64">x86-64</a>). The first four
arguments are placed onto the registers. That means RCX, RDX, R8, R9 for
integer, struct or pointer arguments (in that order), and XMM0, XMM1,
XMM2, XMM3 for floating point arguments. Additional arguments are pushed
onto the stack (right to left). Integer return values (similar to x86)
are returned in RAX if 64 bits or less. Floating point return values are
returned in XMM0. Parameters less than 64 bits long are not zero
extended; the high bits are not zeroed.</p>
<p>微软x64调用约定适用于Windows和UEFI.</p>
<p>前四个参数,如果是整数或者结构体或者指针类型,则放在寄存器RCX,RDX,R8,R9寄存器里,如果是浮点数则放在XMM0到XMM3里</p>
<p>额为的参数放在栈里(从右向左压栈)</p>
<p>返回值如果小于等于64位则放在RAX寄存器里(类似于x86的情形)</p>
<p>浮点返回值放在XMM0里</p>
<p>小于64位的参数进行有符号拓展</p>
<p>Structs and unions with sizes that match integers are passed and
returned as if they were integers. Otherwise they are replaced with a
pointer when used as an argument. When an oversized struct return is
needed, another pointer to a caller-provided space is prepended as the
first argument, shifting all other arguments to the right by one
place.[<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#cite_note-20">20]</a></p>
<p>结构体和联合体如果大小与整形匹配则被当作整形进行参数传递还有返回.否则,当他们作为参数时,会被一个指针替代</p>
<p>当需要一个超大的结构体需要返回时，指向调用方提供的空间的另一个指针将作为第一个参数，将所有其他参数向右移动一个位置</p>
<p>When compiling for the x64 architecture in a Windows context (whether
using Microsoft or non-Microsoft tools), stdcall, thiscall, cdecl, and
fastcall all resolve to using this convention.</p>
<p>不管使用的编译器是不是微软的工具,对于x64体系,stdcall,thiscall,cdecl,fastcall都会被忽略,然后使用上述方法处理</p>
<p>In the Microsoft x64 calling convention, it is the caller's
responsibility to allocate 32 bytes of "shadow space" on the stack right
before calling the function (regardless of the actual number of
parameters used), and to pop the stack after the call. The shadow space
is used to spill RCX, RDX, R8, and R9,[<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#cite_note-21">21]</a>
but must be made available to all functions, even those with fewer than
four parameters.</p>
<p>在微软x64调用约定中,调用者在调用其他函数之前,有义务在栈上分配32字节的"影子空间",并且忽略实际上参数占用的大小,并且在调用结束后由调用者清理被调用者的堆栈.</p>
<p>影子空间的作用是用于将来存放RCX,RDX,R8,R9中的前四个参数,但是即使是没有不够四个参数的函数,也会预留一个32字节的影子空间</p>
<p>The registers RAX, RCX, RDX, R8, R9, R10, R11 are considered volatile
(caller-saved).[<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#cite_note-Caller/Callee_Saved_Registers-22">22]</a></p>
<p>RAX, RCX, RDX, R8, R9, R10, R11这些寄存器都是volatile修饰的</p>
<figure>
<img
src="../AppData/Roaming/Typora/typora-user-images/image-20220428101247431.png"
alt="image-20220428101247431" />
<figcaption aria-hidden="true">image-20220428101247431</figcaption>
</figure>
<p>The registers RBX, RBP, RDI, RSI, RSP, R12, R13, R14, and R15 are
considered nonvolatile (callee-saved).[<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#cite_note-Caller/Callee_Saved_Registers-22">22]</a></p>
<p>RBX, RBP, RDI, RSI, RSP, R12, R13, R14, and R15不用volatile修饰</p>
<p>For example, a function taking 5 integer arguments will take the
first to fourth in registers, and the fifth will be pushed on top of the
shadow space. So when the called function is entered, the stack will be
composed of (in ascending order) the return address, followed by the
shadow space (32 bytes) followed by the fifth parameter.</p>
<p>举个例子,一个有5参数的
函数,其前四个参数将会被放在寄存器里然后第五个参数竟会别压入栈顶,并且在影子空间之上.</p>
<p>因此当进入被调用函数时,栈中的组成按照从栈顶到栈底将是:返回值,影子空间,第五个参数</p>
<p>这里影子空间就是给前四个参数腾空,前四个参数使用寄存器传递之后在被调用者中会被重新压栈,即压入这个预留的影子空间</p>
</blockquote>
<p>维基百科这样写的:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220428152348161.png"
alt="image-20220428152348161" />
<figcaption aria-hidden="true">image-20220428152348161</figcaption>
</figure>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Archimedes/p/15044277.html">x86
x64调用约定及传参顺序 - 一瓶怡宝 - 博客园 (cnblogs.com)</a></p>
<p>同样的程序<code>test.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="title function_">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> d,<span class="type">int</span> e,<span class="type">int</span> f,<span class="type">int</span> g,<span class="type">int</span> h)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b+c+d+e+f+g+h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如下命令<code>gcc -O0 test.c -c -o test.o|objdump -d test.o &gt; t.s|code t.s</code></p>
<p>首先不用编译优化,将<code>test.c</code>编译成目标文件<code>test.o</code>,</p>
<p>然后使用<code>objdump</code>反编译得到反汇编代码<code>t.s</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">test.o:     file format pe-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;func&gt;:</span><br><span class="line">   0:	55                   	push   %rbp</span><br><span class="line">   1:	48 89 e5             	mov    %rsp,%rbp			</span><br><span class="line">   4:	89 4d 10             	mov    %ecx,0x10(%rbp)		;蜜汁操作,将ecx中存放的参数也压入栈中</span><br><span class="line">   7:	89 55 18             	mov    %edx,0x18(%rbp)</span><br><span class="line">   a:	44 89 45 20          	mov    %r8d,0x20(%rbp)</span><br><span class="line">   e:	44 89 4d 28          	mov    %r9d,0x28(%rbp)</span><br><span class="line">  12:	8b 55 10             	mov    0x10(%rbp),%edx</span><br><span class="line">  15:	8b 45 18             	mov    0x18(%rbp),%eax</span><br><span class="line">  18:	01 c2                	add    %eax,%edx</span><br><span class="line">  1a:	8b 45 20             	mov    0x20(%rbp),%eax</span><br><span class="line">  1d:	01 c2                	add    %eax,%edx</span><br><span class="line">  1f:	8b 45 28             	mov    0x28(%rbp),%eax</span><br><span class="line">  22:	01 c2                	add    %eax,%edx</span><br><span class="line">  24:	8b 45 30             	mov    0x30(%rbp),%eax</span><br><span class="line">  27:	01 c2                	add    %eax,%edx</span><br><span class="line">  29:	8b 45 38             	mov    0x38(%rbp),%eax</span><br><span class="line">  2c:	01 c2                	add    %eax,%edx</span><br><span class="line">  2e:	8b 45 40             	mov    0x40(%rbp),%eax</span><br><span class="line">  31:	01 c2                	add    %eax,%edx</span><br><span class="line">  33:	8b 45 48             	mov    0x48(%rbp),%eax</span><br><span class="line">  36:	01 d0                	add    %edx,%eax</span><br><span class="line">  38:	5d                   	pop    %rbp</span><br><span class="line">  39:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000000003a &lt;show&gt;:</span><br><span class="line">  3a:	55                   	push   %rbp					</span><br><span class="line">  3b:	48 89 e5             	mov    %rsp,%rbp			</span><br><span class="line">  3e:	48 83 ec 40          	sub    $0x40,%rsp			;为子函数申请栈空间,但是蜜汁操作,8个int参数,一个int占4字节,理论上需要0x20=32字节空间,却申请了0x40=64字节的空间</span><br><span class="line">  42:	c7 44 24 38 08 00 00 	movl   $0x8,0x38(%rsp)		 ;将立即数8放在栈中rsp+0x38位置</span><br><span class="line">  49:	00 </span><br><span class="line">  4a:	c7 44 24 30 07 00 00 	movl   $0x7,0x30(%rsp)		;将7放在栈中rsp+0x30位置</span><br><span class="line">  51:	00 	</span><br><span class="line">  52:	c7 44 24 28 06 00 00 	movl   $0x6,0x28(%rsp)		;0x30-0x28=48-40=8,蜜汁操作,相邻两个参数在栈上距离8字节</span><br><span class="line">  59:	00 </span><br><span class="line">  5a:	c7 44 24 20 05 00 00 	movl   $0x5,0x20(%rsp)</span><br><span class="line">  61:	00 </span><br><span class="line">  62:	41 b9 04 00 00 00    	mov    $0x4,%r9d			;立即数4放在r9d寄存器中</span><br><span class="line">  68:	41 b8 03 00 00 00    	mov    $0x3,%r8d			</span><br><span class="line">  6e:	ba 02 00 00 00       	mov    $0x2,%edx</span><br><span class="line">  73:	b9 01 00 00 00       	mov    $0x1,%ecx			;立即数1放在ecx寄存器中</span><br><span class="line">  78:	e8 83 ff ff ff       	callq  0 &lt;func&gt;				</span><br><span class="line">  7d:	48 83 c4 40          	add    $0x40,%rsp</span><br><span class="line">  81:	5d                   	pop    %rbp</span><br><span class="line">  82:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000000083 &lt;main&gt;:</span><br><span class="line">  83:	55                   	push   %rbp</span><br><span class="line">  84:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">  87:	48 83 ec 20          	sub    $0x20,%rsp</span><br><span class="line">  8b:	e8 00 00 00 00       	callq  90 &lt;main+0xd&gt;		;蜜汁操作,90行就在下面,为啥要call一下</span><br><span class="line">  90:	e8 a5 ff ff ff       	callq  3a &lt;show&gt;</span><br><span class="line">  95:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  9a:	48 83 c4 20          	add    $0x20,%rsp</span><br><span class="line">  9e:	5d                   	pop    %rbp</span><br><span class="line">  9f:	c3                   	retq   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1.函数名没有下划线前缀</p>
<p>2.show和main函数都有固定的格式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">push %rbp			;rbp是被调用者保存的寄存器,当前函数可以使用,但是最后结束的时候要还原rbp的状态,因此压栈存储先前状态</span><br><span class="line">mov  %rsp,%rbp		 ;将先前的栈顶指针存放在刚刚腾出空闲的rbp寄存器中</span><br><span class="line">sub  %0x..,%rsp		 ;栈顶指针下降,在栈上为将要调用的子函数申请栈空间</span><br><span class="line">callq &lt;..&gt;			;调用函数</span><br><span class="line">..;处理返回值		;通常返回值在eax寄存器中,进行一些处理</span><br><span class="line">add  %0x..,%rsp		 ;子函数已经执行结束了,为其申请的栈帧不需要再存在了,复原栈顶指针位置 </span><br><span class="line">pop  %rbp			;将被调用者有义务保存的寄存器rbp还原</span><br><span class="line">retq				;本函数返回</span><br></pre></td></tr></table></figure>
<p>3.关于show函数在调用具有8个参数的func函数时,参数如何安排</p>
<blockquote>
<p><strong>关于蜜汁操作参数安排</strong></p>
<p>1.后面第5到8个参数使用栈传递,5位于0x20+rsp,8位于0x38+rsp,即约靠左的参数越靠近栈顶rsp</p>
<p>2.前面1到4个参数==使用寄存器传递==</p>
<p>3.在进入被调用者函数后,将刚才调用者通过寄存器传递的参数也放进栈里,</p>
<p>并且x64上调用者在为子函数申请栈空间的时候也会有意申请很大,为待会儿寄存器中的参数也压栈做准备</p>
<p>实际上这三条都完成之后和x86上的结果是相同的,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func(p1 ,p2 ,p3, p4 ,p5           ,...,plast	   );</span><br><span class="line">func(ecx,edx,r8d,r9d,远离栈顶的地方,...,靠近栈顶的地方);</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>关于蜜汁操作四字节的int在栈上分配8字节空间</strong>:</p>
<p>在64位不管是windows还是linux系统上int都是4字节的,long
long都是8字节的</p>
<p>上面这段程序中各个参数改成short,int,long,long
long类型之后反编译得到的汇编语言,在为子函数申请栈空间的时候都是0x40=64个字节</p>
<p>即参数不管什么类型都是以8字节传递的,这一点可以从使用r9d寄存器传递int参数看出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">62:	41 b9 04 00 00 00    	mov    $0x4,%r9d			;立即数4放在r9d寄存器中</span><br><span class="line">68:	41 b8 03 00 00 00    	mov    $0x3,%r8d	</span><br></pre></td></tr></table></figure>
<p>r开头的寄存器都是4字寄存器,理论上是放long long
的,但是这里int也用了r9d传递</p>
</blockquote>
<blockquote>
<p><strong>关于蜜汁操作就在下一行的指令还要call</strong></p>
<p>案发现场:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">8b:	e8 00 00 00 00       	callq  90 &lt;main+0xd&gt;		;蜜汁操作,90行就在下面,为啥要call一下</span><br><span class="line">90:	e8 a5 ff ff ff       	callq  3a &lt;show&gt;</span><br><span class="line">95:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>写一个更短的程序观察这个事</p>
<p><code>test.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">foo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -O0 -c -o test.o|objdump -d test.o &gt; test.s|code test.s</span><br><span class="line">不开任何编译优化,反汇编</span><br></pre></td></tr></table></figure>
<p>反编译得到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;foo&gt;:</span><br><span class="line">0:	55                   	push   %rbp</span><br><span class="line">1:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">4:	90                   	nop</span><br><span class="line">5:	5d                   	pop    %rbp</span><br><span class="line">6:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000000007 &lt;main&gt;:</span><br><span class="line">7:	55                   	push   %rbp</span><br><span class="line">8:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">b:	48 83 ec 20          	sub    <span class="variable">$0x20</span>,%rsp</span><br><span class="line">f:	e8 00 00 00 00       	callq  14 &lt;main+0xd&gt;	</span><br><span class="line">14:	e8 e7 ff ff ff       	callq  0 &lt;foo&gt;</span><br><span class="line">19:	b8 00 00 00 00       	mov    <span class="variable">$0x0</span>,%eax	</span><br><span class="line">1e:	48 83 c4 20          	add    <span class="variable">$0x20</span>,%rsp</span><br><span class="line">22:	5d                   	pop    %rbp</span><br><span class="line">23:	c3                   	retq   </span><br><span class="line">24:	90                   	nop</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>main+0xf</code>处的callq,将下一条指令也就是<code>main+0x14</code>压栈,然后修改程序计数器为<code>main+0xf</code>,即执行<code>jmp main+0xf</code></p>
<p><code>main+0x14</code>处的callq,将下一条指令地址也就是<code>main+0x19</code>压栈,然后修改程序计数器为<code>foo</code>地址,即执行<code>jmp foo</code></p>
<p><code>foo</code>执行到最后有一个<code>retq</code>作用是将栈顶刚才压入的<code>main+0x19</code>还给程序计数器rip,然后退栈,即<code>pop %rip</code></p>
<p>这样看起来程序已经出错了,栈顶还有一个<code>main+0xf</code>没有弹出,但是<code>main+0x22</code>处有一个退栈将位于栈顶<code>main+0xf</code>弹给了<code>%rbp</code>寄存器,然而实际上<code>%rbp</code>寄存器应当获取次栈顶的值,即在<code>main+0x7</code>压入的值</p>
<p>出错的原因是<code>main+0xf</code>处的call指令调用的不是一个函数,没有与该call指令相对应的<code>ret</code>指令,这导致了call前压栈但是call后不退栈.</p>
<p>下面正向编译观察这个事情</p>
<p>使用<code>gcc -S</code>选项正向编译成汇编语言</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.seh_pushreg	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.seh_setframe	%rbp, 0</span><br><span class="line">	subq	$32, %rsp</span><br><span class="line">	.seh_stackalloc	32</span><br><span class="line">	.seh_endprologue</span><br><span class="line">	call	__main</span><br><span class="line">	call	show</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	addq	$32, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	ret</span><br><span class="line">	.seh_endproc</span><br><span class="line">	.ident	&quot;GCC: (tdm64-1) 9.2.0&quot;</span><br></pre></td></tr></table></figure>
<p>第9行有一个<code>call __main</code></p>
<p>stackoverflow上的说法</p>
<blockquote>
<p>Calls the _<strong>main function which will do initializing stuff
that gcc needs. Call will push the current instruction pointer on the
stack and jump to the address of </strong>_main</p>
</blockquote>
<p>调用<code>__main</code>函数,初始化gcc需要的材料.该调用将当前程序计数器压栈然后跳转__main函数</p>
<p>显然我们<code>gcc -c</code>生成的目标文件.o是没有<code>__main</code>函数的
,该函数应当是链接阶段加上去的</p>
<p>那么我们编译成exe文件之后再反编译进行观察</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0000000000401633 &lt;main&gt;:</span><br><span class="line">  401633:	55                   	push   %rbp</span><br><span class="line">  401634:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">  401637:	48 83 ec 20          	sub    $0x20,%rsp</span><br><span class="line">  40163b:	e8 c0 00 00 00       	callq  401700 &lt;__main&gt;	;此call确实调用了__main函数</span><br><span class="line">  401640:	e8 a5 ff ff ff       	callq  4015ea &lt;show&gt;	;此call调用了show函数</span><br><span class="line">  401645:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40164a:	48 83 c4 20          	add    $0x20,%rsp</span><br><span class="line">  40164e:	5d                   	pop    %rbp</span><br><span class="line">  40164f:	c3                   	retq   </span><br><span class="line">0000000000401700 &lt;__main&gt;:</span><br><span class="line">  401700:	8b 05 2a 59 00 00    	mov    0x592a(%rip),%eax        # 407030 &lt;initialized&gt;</span><br><span class="line">  401706:	85 c0                	test   %eax,%eax</span><br><span class="line">  401708:	74 06                	je     401710 &lt;__main+0x10&gt;</span><br><span class="line">  40170a:	c3                   	retq   						;有ret语句</span><br><span class="line">  40170b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)</span><br><span class="line">  401710:	c7 05 16 59 00 00 01 	movl   $0x1,0x5916(%rip)        # 407030 &lt;initialized&gt;</span><br><span class="line">  401717:	00 00 00 </span><br><span class="line">  40171a:	e9 71 ff ff ff       	jmpq   401690 &lt;__do_global_ctors&gt;</span><br><span class="line">  40171f:	90                   	nop</span><br></pre></td></tr></table></figure>
<p>此时可以看到,两个call都是调用的函数,并且调用的函数都有ret语句与call匹配</p>
</blockquote>
<p>还要补充的是关于对齐:申请栈空间时要按照16字节对齐申请</p>
<h3 id="system-v-amd64-abi">System V AMD64 ABI</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220428152425649.png"
alt="image-20220428152425649" />
<figcaption aria-hidden="true">image-20220428152425649</figcaption>
</figure>
<p>CSAPP写道,参数传递时可以用到六个寄存器,多余的参数用栈传递,是指在64位linux环境下,</p>
<p>而windows上只能用四个寄存器传递参数,多余的用栈传递</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220427223059552.png"
alt="image-20220427223059552" />
<figcaption aria-hidden="true">image-20220427223059552</figcaption>
</figure>
<p>还是刚才的c程序,在ubuntu上的情况</p>
<p><code>main.c</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int _cdecl func(int a,int b,int c,int d,int e,int f,int g,int h)&#123;</span><br><span class="line">    return a+b+c+d+e+f+g+h;</span><br><span class="line">&#125;</span><br><span class="line">int _cdecl show()&#123;</span><br><span class="line">    return func(1,2,3,4,5,6,7,8);</span><br><span class="line">&#125;</span><br><span class="line">int _cdecl main()&#123;</span><br><span class="line">    show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其反汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">main.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;func&gt;:</span><br><span class="line">   0:   f3 0f 1e fa             endbr64						;蜜汁指令</span><br><span class="line">   4:   55                      push   %rbp</span><br><span class="line">   5:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   8:   89 7d fc                mov    %edi,-0x4(%rbp)		;寄存器传递的参数也压栈,这与windows上相同</span><br><span class="line">   b:   89 75 f8                mov    %esi,-0x8(%rbp)</span><br><span class="line">   e:   89 55 f4                mov    %edx,-0xc(%rbp)		</span><br><span class="line">  11:   89 4d f0                mov    %ecx,-0x10(%rbp)</span><br><span class="line">  14:   44 89 45 ec             mov    %r8d,-0x14(%rbp)</span><br><span class="line">  18:   44 89 4d e8             mov    %r9d,-0x18(%rbp)</span><br><span class="line">  1c:   8b 55 fc                mov    -0x4(%rbp),%edx</span><br><span class="line">  1f:   8b 45 f8                mov    -0x8(%rbp),%eax</span><br><span class="line">  22:   01 c2                   add    %eax,%edx</span><br><span class="line">  24:   8b 45 f4                mov    -0xc(%rbp),%eax</span><br><span class="line">  27:   01 c2                   add    %eax,%edx</span><br><span class="line">  29:   8b 45 f0                mov    -0x10(%rbp),%eax</span><br><span class="line">  2c:   01 c2                   add    %eax,%edx</span><br><span class="line">  2e:   8b 45 ec                mov    -0x14(%rbp),%eax</span><br><span class="line">  31:   01 c2                   add    %eax,%edx</span><br><span class="line">  33:   8b 45 e8                mov    -0x18(%rbp),%eax</span><br><span class="line">  36:   01 c2                   add    %eax,%edx</span><br><span class="line">  38:   8b 45 10                mov    0x10(%rbp),%eax</span><br><span class="line">  3b:   01 c2                   add    %eax,%edx</span><br><span class="line">  3d:   8b 45 18                mov    0x18(%rbp),%eax</span><br><span class="line">  40:   01 d0                   add    %edx,%eax</span><br><span class="line">  42:   5d                      pop    %rbp</span><br><span class="line">  43:   c3                      retq</span><br><span class="line"></span><br><span class="line">0000000000000044 &lt;show&gt;:</span><br><span class="line">  44:   f3 0f 1e fa             endbr64</span><br><span class="line">  48:   55                      push   %rbp</span><br><span class="line">  49:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  4c:   6a 08                   pushq  $0x8					</span><br><span class="line">  4e:   6a 07                   pushq  $0x7</span><br><span class="line">  50:   41 b9 06 00 00 00       mov    $0x6,%r9d			;确实使用了6个寄存器传递参数</span><br><span class="line">  56:   41 b8 05 00 00 00       mov    $0x5,%r8d</span><br><span class="line">  5c:   b9 04 00 00 00          mov    $0x4,%ecx</span><br><span class="line">  61:   ba 03 00 00 00          mov    $0x3,%edx</span><br><span class="line">  66:   be 02 00 00 00          mov    $0x2,%esi</span><br><span class="line">  6b:   bf 01 00 00 00          mov    $0x1,%edi</span><br><span class="line">  70:   e8 00 00 00 00          callq  75 &lt;show+0x31&gt;		</span><br><span class="line">  75:   48 83 c4 10             add    $0x10,%rsp</span><br><span class="line">  79:   c9                      leaveq						</span><br><span class="line">  7a:   c3                      retq</span><br><span class="line"></span><br><span class="line">000000000000007b &lt;main&gt;:</span><br><span class="line">  7b:   f3 0f 1e fa             endbr64</span><br><span class="line">  7f:   55                      push   %rbp</span><br><span class="line">  80:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  83:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  88:   e8 00 00 00 00          callq  8d &lt;main+0x12&gt;</span><br><span class="line">  8d:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  92:   5d                      pop    %rbp</span><br><span class="line">  93:   c3                      retq</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func(para1,para2,para3,para4,para5,para6,para7,...,paran)</span><br><span class="line">func(edi,esi,edx,ecx,r8d,r9d,栈上远离栈顶,...,栈上靠近栈顶)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/04/22/gdb%E8%B0%83%E8%AF%95%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/22/gdb%E8%B0%83%E8%AF%95%E5%99%A8/" class="post-title-link" itemprop="url">gbd调试器的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-22 19:57:20" itemprop="dateCreated datePublished" datetime="2022-04-22T19:57:20+08:00">2022-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-20 16:14:03" itemprop="dateModified" datetime="2023-09-20T16:14:03+08:00">2023-09-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="gbd调试器的使用">gbd调试器的使用</h1>
<p>环境:Win11+Kali子系统</p>
<h2 id="启动">启动</h2>
<h3 id="启动gdb">启动<code>gdb</code></h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# gdb</span><br><span class="line">GNU gdb (Debian 10.1-2+b1) 10.1.90.20210103-git</span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;x86_64-linux-gnu&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>看到命令提示符号变成<code>(gdb)</code>则启动成功</p>
<h3 id="安静启动gdb--q">安静启动<code>gdb -q</code></h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# gdb --silent</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--silent也可以写成-q,-quiet</span><br></pre></td></tr></table></figure>
<h3 id="分屏启动gdb--tui">分屏启动<code>gdb -tui</code></h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# gdb -tui</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220421202637748.png"
alt="image-20220421202637748" />
<figcaption aria-hidden="true">image-20220421202637748</figcaption>
</figure>
<p>上方窗口是源代码窗口,下方是gbd命令行窗口</p>
<p>这样启动不需要另开一个终端观察源代码</p>
<p>并且当程序在端点停下的时候上方窗口也会显示当前程序停止的位置</p>
<p>上方的源代码窗口使用上下箭头移动视野</p>
<h3
id="分屏安静指定调试程序gdb--tui--q-prog_name">分屏+安静+指定调试程序<code>gdb -tui -q &lt;prog_name&gt;</code></h3>
<p>注意使用gdb调试的文件必须是可执行文件(windows上的.exe或者linux上的.out等)</p>
<p>并且在编译该可执行文件的时候==必须加入-g选项==生成gbd调试信息</p>
<blockquote>
<p>如果不使用-g生成了.out文件然后使用gdb调试则</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# gcc main.c -Og -o  main.out</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# gdb --silent main.out</span><br><span class="line">Reading symbols from main.out...</span><br><span class="line">(No debugging symbols found <span class="keyword">in</span> main.out)			<span class="comment">#报告没有调试信息</span></span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>使用-tui打开,源代码都看不到</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220421203357054.png"
alt="image-20220421203357054" />
<figcaption aria-hidden="true">image-20220421203357054</figcaption>
</figure>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# gcc main.c -Og -g -o main.out				<span class="comment">#使用-g选项生成调试信息</span></span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# gdb -tui --silent main.out</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220421203550729.png"
alt="image-20220421203550729" />
<figcaption aria-hidden="true">image-20220421203550729</figcaption>
</figure>
<h4
id="带参数启动--args-程序-参数1-参数2...">带参数启动<code>--args  &lt;程序&gt; &lt;参数1&gt; &lt;参数2&gt;...</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# gdb -q -tui --args main.out 1 2 3 4</span><br></pre></td></tr></table></figure>
<p>这里指定的参数1 2 3
4将会作为<code>main.out</code>执行时的命令行参数</p>
<h2 id="启动后运行前">启动后运行前</h2>
<p>加载需要调试的程序</p>
<p>当在命令行直接使用gdb命令打开gdb调试器时,此时是没有指定需要调试的程序的</p>
<h3 id="工作目录pwd">工作目录<code>pwd</code></h3>
<p>默认工作目录是打开gdb的位置,gdb启动后也可以使用<code>pwd</code>命令观察当前工作目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# gdb -q</span><br><span class="line">(gdb) <span class="built_in">pwd</span></span><br><span class="line">Working directory /home/kali/mydir.</span><br></pre></td></tr></table></figure>
<h3
id="指定调试程序位置file-prog_name">指定调试程序位置<code>file &lt;prog_name&gt;</code></h3>
<p>对于当前目录下的程序可以直接使用程序名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# <span class="built_in">ls</span> -l|gdb -q</span><br><span class="line">(gdb) Undefined <span class="built_in">command</span>: <span class="string">&quot;total&quot;</span>.  Try <span class="string">&quot;help&quot;</span>.</span><br><span class="line">(gdb) Undefined <span class="built_in">command</span>: <span class="string">&quot;-rw-r--r--&quot;</span>.  Try <span class="string">&quot;help&quot;</span>.</span><br><span class="line">(gdb) Undefined <span class="built_in">command</span>: <span class="string">&quot;-rwxr-xr-x&quot;</span>.  Try <span class="string">&quot;help&quot;</span>.</span><br><span class="line">(gdb) Undefined <span class="built_in">command</span>: <span class="string">&quot;-rw-r--r--&quot;</span>.  Try <span class="string">&quot;help&quot;</span>.</span><br><span class="line">(gdb) quit</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# <span class="built_in">ls</span> -l</span><br><span class="line">total 28</span><br><span class="line">-rw-r--r-- 1 root root   139 Apr 21 20:23 main.c</span><br><span class="line">-rwxr-xr-x 1 root root 17672 Apr 21 20:35 main.out</span><br><span class="line">-rw-r--r-- 1 root root    25 Apr 21 20:38 r.txt</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# gdb -q</span><br><span class="line">(gdb) file main.out</span><br><span class="line">Reading symbols from main.out...</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>对于其他目录下的可以使用绝对或者相对位置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) file /home/kali/mydir/main.out</span><br><span class="line">Load new symbol table from <span class="string">&quot;/home/kali/mydir/main.out&quot;</span>? (y or n) y</span><br><span class="line">Reading symbols from /home/kali/mydir/main.out...</span><br></pre></td></tr></table></figure>
<h3 id="查看信息">查看信息</h3>
<h4 id="查看当前工作目录pwd">查看当前工作目录<code>pwd</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">pwd</span></span><br><span class="line">Working directory /home/kali/mydir.</span><br></pre></td></tr></table></figure>
<h4
id="查看是否找到目标程序文件list">查看是否找到目标程序文件<code>list</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list</span><br><span class="line">1       <span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line">2       <span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5       int main(int argc,char **argv)&#123;</span><br><span class="line">6               <span class="keyword">for</span>(int i=0;i&lt;argc;++i)&#123;</span><br><span class="line">7                       <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,argv[i]);</span><br><span class="line">8               &#125;</span><br><span class="line">9               <span class="built_in">return</span> 0;</span><br><span class="line">10      &#125;</span><br></pre></td></tr></table></figure>
<h4
id="查看调试程序语言show-language">查看调试程序语言<code>show language</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show language</span><br><span class="line">The current <span class="built_in">source</span> language is <span class="string">&quot;auto; currently c&quot;</span>.</span><br></pre></td></tr></table></figure>
<h4
id="查看源文件信息info-source">查看源文件信息<code>info source</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info <span class="built_in">source</span></span><br><span class="line">Current <span class="built_in">source</span> file is main.c</span><br><span class="line">Compilation directory is /home/kali/mydir</span><br><span class="line">Located <span class="keyword">in</span> /home/kali/mydir/main.c</span><br><span class="line">Contains 10 lines.</span><br><span class="line">Source language is c.</span><br><span class="line">Producer is GNU C17 11.2.0 -mtune=generic -march=x86-64 -g -Og -fasynchronous-unwind-tables.</span><br><span class="line">Compiled with DWARF 2 debugging format.</span><br><span class="line">Does not include preprocessor macro info.</span><br></pre></td></tr></table></figure>
<h4
id="查看可以设置的程序语言set-language">查看可以设置的程序语言<code>set language</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> language</span><br><span class="line">Requires an argument. Valid arguments are auto, <span class="built_in">local</span>, unknown, ada, asm, c, c++, d, fortran, go, minimal, modula-2, objective-c, opencl, pascal, rust.</span><br></pre></td></tr></table></figure>
<h4
id="查看程序运行状态info-program">查看程序运行状态<code>info program</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info prog</span><br><span class="line">The program being debugged is not being run.</span><br></pre></td></tr></table></figure>
<h3 id="设置信息">设置信息</h3>
<h4
id="设置命令行参数set-args-参数1-参数2...">设置命令行参数<code>set args &lt;参数1&gt; &lt;参数2&gt;...</code></h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args 1 2 3</span><br><span class="line">(gdb) show args</span><br><span class="line">Argument list to give program being debugged when it is started is &quot;1 2 3&quot;.</span><br></pre></td></tr></table></figure>
<p>如果在启动时有指定参数,此时再用set指定参数则会覆盖启动时设置的参数</p>
<h4 id="设置语言set-language">设置语言'set language <语言>'</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> language c</span><br></pre></td></tr></table></figure>
<h2 id="运行">运行</h2>
<h3 id="运行程序run">运行程序<code>run</code></h3>
<p>命令行参数使用启动时指定的参数或者set
args设置的参数,如果都没有给定则无参数执行</p>
<p>如果有断点则程序在第一个断点处停止,否则直接运行完.</p>
<h4
id="带参数运行run-参数1-参数2...">带参数运行<code>run &lt;参数1&gt; &lt;参数2&gt;...</code></h4>
<p>此参数将会直接作为运行参数,覆盖前面设置的参数</p>
<h3 id="main停止运行start">main停止运行<code>start</code></h3>
<p><code>start</code>相当于在main函数处下了断点然后<code>run</code>,自动在main开始前停下</p>
<h2 id="运行时">运行时</h2>
<h3 id="断点">断点</h3>
<h4 id="设置断点b-行号">设置断点<code>b &lt;行号&gt;</code></h4>
<p>断点可以运行前设置也可以运行时设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 6</span><br><span class="line">Breakpoint 6 at 0x555555555142: file main.c, line 6.</span><br></pre></td></tr></table></figure>
<p>如果以-tui分屏打开,则设置好的断点会显示在行号左侧,大写的B+&gt;意味当前程序暂停的断点</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220421213142314.png"
alt="image-20220421213142314" />
<figcaption aria-hidden="true">image-20220421213142314</figcaption>
</figure>
<h5
id="b-函数名直接给函数下断点"><code>b &lt;函数名&gt;</code>直接给函数下断点</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 10 at 0x555555555139: file main.c, line 5.</span><br></pre></td></tr></table></figure>
<h4 id="删除断点-delete-断点编号">删除断点
<code>delete &lt;断点编号&gt;</code></h4>
<p>注意端点编号不是行号</p>
<p>删除全部断点则不指定编号,直接<code>delete</code></p>
<h5
id="删除指定行上的断点clear-行号">删除指定行上的断点<code>clear &lt;行号&gt;</code></h5>
<h4 id="条件断点b-if-条件">条件断点<code>b if &lt;条件&gt;</code></h4>
<p>比如如果没有输入命令行参数时才给main函数下断点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main <span class="keyword">if</span> argc==1					<span class="comment">#用户没有输入时argc=1,第一个参数是当前程序位置</span></span><br><span class="line">Breakpoint 11 at 0x555555555139: file main.c, line 5.</span><br></pre></td></tr></table></figure>
<h4
id="查看断点信息info-b-断点号">查看断点信息<code>info b &lt;断点号&gt;</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 11 at 0x555555555139: file main.c, line 5.</span><br><span class="line">(gdb) info b 11</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">11      breakpoint     keep y   0x0000555555555139 <span class="keyword">in</span> main at main.c:5</span><br><span class="line">        stop only <span class="keyword">if</span> argc==1</span><br></pre></td></tr></table></figure>
<h5 id="info-b查看所有断点信息"><code>info b</code>查看所有断点信息</h5>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">11      breakpoint     keep y   0x0000555555555139 <span class="keyword">in</span> main at main.c:5</span><br><span class="line">        stop only <span class="keyword">if</span> argc==1</span><br><span class="line">12      breakpoint     keep y   0x0000555555555142 <span class="keyword">in</span> main at main.c:6</span><br><span class="line">13      breakpoint     keep y   0x0000555555555149 <span class="keyword">in</span> main at main.c:7</span><br></pre></td></tr></table></figure>
<h3 id="查看信息-1">查看信息</h3>
<h4 id="print命令">print命令</h4>
<h5
id="查看函数信息p-函数名">查看函数信息<code>p &lt;函数名&gt;</code></h5>
<p>函数信息也可以在运行前查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p main</span><br><span class="line"><span class="variable">$6</span> = &#123;int (int, char **)&#125; 0x555555555139 &lt;main&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;返回值类型(参数1类型,参数2类型)&#125; 函数地址 &lt;函数名&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) whatis main</span><br><span class="line">type = int (int, char **)</span><br><span class="line">(gdb) ptype main</span><br><span class="line">type = int (int, char **)</span><br></pre></td></tr></table></figure>
<h5
id="查看变量信息p-变量名">查看变量信息<code>p &lt;变量名&gt;</code></h5>
<p>查看变量信息必须是程序在该变量下文的断点处停下</p>
<p>即当前程序的运行位置必须已经经过变量,并且变量没有消亡</p>
<p>比如函数中的局部变量在函数返回之后就会消亡,只能在函数中断点然后查看断点之前的变量</p>
<p>如图调试一个用循环计算阶乘的函数,将断点下在第10行<code>result*=n</code>处</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422175357420.png"
alt="image-20220422175357420" />
<figcaption aria-hidden="true">image-20220422175357420</figcaption>
</figure>
<p>当程序第一次执行到次时会停在<code>result*=n</code>==执行前==的状态</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422175511240.png"
alt="image-20220422175511240" />
<figcaption aria-hidden="true">image-20220422175511240</figcaption>
</figure>
<p>如图第一次在第10行停下,打印result=1</p>
<h5
id="查看寄存器信息p-寄存器名">查看寄存器信息<code>p $&lt;寄存器名&gt;</code></h5>
<p>对于刚才的fact循环求阶乘函数,最后返回值是result,可想而知,该值是存放在rax寄存器中的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fact</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)<span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> result=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                result*=n;</span><br><span class="line">                --n;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面调试程序验证猜想</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422180106540.png"
alt="image-20220422180106540" />
<figcaption aria-hidden="true">image-20220422180106540</figcaption>
</figure>
<p>还是将断点下到第10行while循环中</p>
<p>逐次进行循环,观察rax寄存器中的值</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422180159934.png"
alt="image-20220422180159934" />
<figcaption aria-hidden="true">image-20220422180159934</figcaption>
</figure>
<p>与result的变化是一致的</p>
<p><strong>也可以查看程序计数器<code>rip</code>中的值,观察程序当前进行位置</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422180413841.png"
alt="image-20220422180413841" />
<figcaption aria-hidden="true">image-20220422180413841</figcaption>
</figure>
<p>用objdump反编译然后观察fact+13处的指令</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422180540637.png"
alt="image-20220422180540637" />
<figcaption aria-hidden="true">image-20220422180540637</figcaption>
</figure>
<p><code>fact+13=0x1139+0x13=0x114c</code>,该位置是一个<code>test %edi,%edi</code>指令,而n作为第一个参数是存放在edi寄存器中的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422180821161.png"
alt="image-20220422180821161" />
<figcaption aria-hidden="true">image-20220422180821161</figcaption>
</figure>
<p>紧接着114e处<code>jg 1146</code>意味如果<code>R[%edi]=n&gt;0</code>则跳转1146位置,</p>
<p>而1146位置在114e上方,相当于跳进了循环,</p>
<p>也就是说0x114c处相当于循环判断<code>while(n&gt;0)</code></p>
<p>即程序在第10行的断点停下时rip中是第9行中的条件判断指令</p>
<h4 id="x-检查字节或者字">x/<大小> <位置>检查字节或者字</h4>
<h5
id="x20b-fact检查fact函数的前20个字节"><code>x/20b fact</code>检查fact函数的前20个字节</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422181438589.png"
alt="image-20220422181438589" />
<figcaption aria-hidden="true">image-20220422181438589</figcaption>
</figure>
<p>与objdump得到的反汇编是一样的</p>
<h5 id="x2g-0x555555555139-检查从0x555555555139地址开始的双字">x/2g
0x555555555139 检查从0x555555555139地址开始的双字</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422181756825.png"
alt="image-20220422181756825" />
<figcaption aria-hidden="true">image-20220422181756825</figcaption>
</figure>
<h4 id="info命令">info命令</h4>
<h5
id="查看所有寄存器信息info-registers">查看所有寄存器信息<code>info registers</code></h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422181858252.png"
alt="image-20220422181858252" />
<figcaption aria-hidden="true">image-20220422181858252</figcaption>
</figure>
<p>其中<code>rax</code>存放result,<code>rdi</code>存放n</p>
<h5 id="查看栈帧info-frame">查看栈帧'info frame'</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422182024087.png"
alt="image-20220422182024087" />
<figcaption aria-hidden="true">image-20220422182024087</figcaption>
</figure>
<h4 id="disas命令">disas命令</h4>
<h5
id="反汇编当前程序暂停的函数disas">反汇编当前程序暂停的函数<code>disas</code></h5>
<p>首先要在函数里下断点,然后程序在该断点暂停时使用disas可以观察当前函数的反汇编信息</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422182255390.png"
alt="image-20220422182255390" />
<figcaption aria-hidden="true">image-20220422182255390</figcaption>
</figure>
<p>可见反汇编信息中也会有当前断点位置信息</p>
<p>如此就不用再开一个终端使用objdump观察了</p>
<h5
id="反汇编指定名称的函数disas-函数名">反汇编指定名称的函数<code>disas &lt;函数名&gt;</code></h5>
<p>此方法不需要在函数中下断点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas fact</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422182507141.png"
alt="image-20220422182507141" />
<figcaption aria-hidden="true">image-20220422182507141</figcaption>
</figure>
<h5
id="反汇编某个地址附近的函数disas-地址">反汇编某个地址附近的函数<code>disas &lt;地址&gt;</code></h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disas 0x000055555555514c</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422182706003.png"
alt="image-20220422182706003" />
<figcaption aria-hidden="true">image-20220422182706003</figcaption>
</figure>
<h3 id="继续执行">继续执行</h3>
<p>执行有多种情况,通常会与断点或者一些逻辑结构联合使用,</p>
<p>比如在断点处停下或者不停下</p>
<p>在循环处,在函数中都有特殊的命令决定如何执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">源代码层面</span><br><span class="line">next		单步执行,不进入函数,但是函数会执行然后返回值</span><br><span class="line">next n		单步执行n行,均不进入函数</span><br><span class="line"></span><br><span class="line">step		单步执行,进入函数</span><br><span class="line">step n		单步执行n行,均进入函数</span><br><span class="line"></span><br><span class="line"><span class="built_in">continue</span>	恢复执行,直到预见下一个断点</span><br><span class="line"><span class="built_in">continue</span> n	恢复执行,并忽略下面的n个断点</span><br><span class="line"></span><br><span class="line">finish		一直运行直到当前函数返回后停止,忽略断点</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span>		放弃后面的执行直接<span class="built_in">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">机器码层面(或者说汇编代码层面)</span><br><span class="line">stepi		单步执行一条指令,进入函数</span><br><span class="line">stepi n</span><br><span class="line"></span><br><span class="line">nexti		单步执行一条指令,不进入函数(不会call)</span><br><span class="line">nexti n</span><br><span class="line"></span><br><span class="line"><span class="keyword">until</span>		一直运行当前循环,在出循环之后的第一条语句停下,如果循环内有断点则在断点停下</span><br><span class="line">			实际上在机器码层面上,一直运行直到一个内存地址比当前更大的指令处停下</span><br></pre></td></tr></table></figure>
<h4 id="源代码层面">源代码层面</h4>
<p>以一个递归求阶乘的程序为例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# <span class="built_in">cat</span> main.c</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int fact(int n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;0)<span class="built_in">return</span> n;</span><br><span class="line">        <span class="keyword">if</span>(n==0)<span class="built_in">return</span> 1;</span><br><span class="line">        <span class="built_in">return</span> n*fact(n-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc,char **argv)&#123;</span><br><span class="line">        int ans=123456;</span><br><span class="line">        ans=fact(9);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="next单步步过">next单步步过</h5>
<p>在main函数处下断点,使得程序上来先停一下,让我们有机会一行一行地执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 3 at 0x55555555515a: file main.c, line 13.</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422185956239.png"
alt="image-20220422185956239" />
<figcaption aria-hidden="true">image-20220422185956239</figcaption>
</figure>
<p>第一个n命令使得程序断在<code>15:ans=fact(123456)</code></p>
<p>第二个n命令使得程序断在<code>16:printf("%d",ans)</code></p>
<p>此时使用print命令观察ans的值发现其确实是9的阶乘,即第15行是自动执行然后返回了值的,单步步过只是忽略了执行细节,只要函数的执行后果</p>
<h5 id="step单步步入">step单步步入</h5>
<p>还是在main函数处下断点,然后使用step</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422190333043.png"
alt="image-20220422190333043" />
<figcaption aria-hidden="true">image-20220422190333043</figcaption>
</figure>
<p>第一个step命令会让程序断在<code>15:ans=fact(9)</code>这与next是相同的</p>
<p>但是下一个step会进入step并在都5行停下</p>
<h5 id="continue执行到下一个断点">continue执行到下一个断点</h5>
<p>在main函数开始(line 13)和main函数中打印ans前(line16)各打一个断点</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422190554335.png"
alt="image-20220422190554335" />
<figcaption aria-hidden="true">image-20220422190554335</figcaption>
</figure>
<p>run运行之后会在13行停下,然后在输入c命令则会直接在16行停下</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422190646915.png"
alt="image-20220422190646915" />
<figcaption aria-hidden="true">image-20220422190646915</figcaption>
</figure>
<p>此时print命令打印ans值发现为362880确实是9的阶乘,即两个断点之间的所有程序都被执行过了</p>
<h5 id="finish一直运行到当前函数返回">finish一直运行到当前函数返回</h5>
<p>分两种情况,有没有进入函数</p>
<p>使用step命令让程序在第一层递归函数==入口前==停下,此时使用finish</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422191432439.png"
alt="image-20220422191432439" />
<figcaption aria-hidden="true">image-20220422191432439</figcaption>
</figure>
<p>发现程序直接返回到了main函数中,并且带着返回值<code>362880</code>恰好是9的阶乘,说明递归函数各层都执行了</p>
<p>现在让程序在第一层递归函数的==内部==停下</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422192218738.png"
alt="image-20220422192218738" />
<figcaption aria-hidden="true">image-20220422192218738</figcaption>
</figure>
<p>发现进入的递归函数的第二层</p>
<h5 id="return-放弃函数未执行的部分直接返回到调用者">return
放弃函数未执行的部分,直接返回到调用者</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422192641695.png"
alt="image-20220422192641695" />
<figcaption aria-hidden="true">image-20220422192641695</figcaption>
</figure>
<p>fact(6)返回到fact(7)</p>
<p>然后一直使用finish命令返回main函数</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422192818544.png"
alt="image-20220422192818544" />
<figcaption aria-hidden="true">image-20220422192818544</figcaption>
</figure>
<p>发现ans值并没有被正确地计算</p>
<p>即return会放弃下文</p>
<h4 id="机器码层面">机器码层面</h4>
<h5
id="until-在循环体的机器码的最高地址时挑出循环到第一条高于循环地址的指令">until
在循环体的机器码的最高地址时挑出循环到第一条高于循环地址的指令</h5>
<p>调试一个使用循环计算阶乘的函数fact</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─<span class="meta"># cat main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fact</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)<span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                result*=n;</span><br><span class="line">                --n;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">123456</span>;</span><br><span class="line">        ans=fact(<span class="number">9</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main函数打一个断点方便单步调试</p>
<p>一直使用step单步步入命令,直到第一次到达while条件判断的时候,使用disas观察反汇编代码</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422194448277.png"
alt="image-20220422194448277" />
<figcaption aria-hidden="true">image-20220422194448277</figcaption>
</figure>
<p>此时对应指令fact+19位置</p>
<p>此时再使用一次单步步入,进入循环,<code>line 12:result*=n</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422194622378.png"
alt="image-20220422194622378" />
<figcaption aria-hidden="true">image-20220422194622378</figcaption>
</figure>
<p>对应指令fact+13位置</p>
<p>即源代码的执行顺序和机器码相反</p>
<p>显然是由于刚才的fact+21的jg条件跳转满足,跳到了fact+13</p>
<p>此时使用until只是相当于step命令,因为until只会在循环的机器码层面的最大地址处才会有快速执行循环的作用</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422194902282.png"
alt="image-20220422194902282" />
<figcaption aria-hidden="true">image-20220422194902282</figcaption>
</figure>
<p>继续disas观察反汇编发现<code>line13:--n</code>对应反汇编的fact+16</p>
<p>此时再使用u</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422195028273.png"
alt="image-20220422195028273" />
<figcaption aria-hidden="true">image-20220422195028273</figcaption>
</figure>
<p>源代码层面进行循环条件判断,对应机器码层面test判断,而fact+19就是循环体在机器层面的最高地址</p>
<p>此时再使用u</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422195116698.png"
alt="image-20220422195116698" />
<figcaption aria-hidden="true">image-20220422195116698</figcaption>
</figure>
<p>直接返回了main函数,这是因为fact函数中while循环结束立刻就返回了,对应机器码</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220422195301219.png"
alt="image-20220422195301219" />
<figcaption aria-hidden="true">image-20220422195301219</figcaption>
</figure>
<p>第23行是循环外首条高于循环的地址,该条指令又是返回,因此返回了main函数</p>
<p>返回main后打印ans值发现是362880是9的阶乘,证明until指令会执行循环体剩下的部分</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/04/18/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/18/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/" class="post-title-link" itemprop="url">抽象代数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-18 16:27:20" itemprop="dateCreated datePublished" datetime="2022-04-18T16:27:20+08:00">2022-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-15 20:41:05" itemprop="dateModified" datetime="2024-01-15T20:41:05+08:00">2024-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="抽象代数">抽象代数</h1>
<p>参考教材:密码编码学与网络安全</p>
<p>AES加密的数学基础</p>
<p>第一遍读感觉教材上对数学基础(群环域,多项式运算)P72-P91给的莫名奇妙</p>
<p><a
target="_blank" rel="noopener" href="https://www.zhihu.com/question/22072020">然后参考了知乎回答</a>对群环域的解释</p>
<p>此时第二遍读教材,发现其实教材在讲每一部分的开始都写了为什么要讲.</p>
<p>学习这部分一定要明确目的,在陷入定理的证明时或者公式应用时时刻想想是在干什么</p>
<p>引入多项式构造<span
class="math inline">\(GF(p^n)\)</span>这一想法真的太神奇了,将整数上的数论定理应用于多项式也真的太神奇了</p>
<p>另,教材P74页的图4.2是有错误的</p>
<h2 id="抽象代数基础">抽象代数基础</h2>
<p>图片来自<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21583674">代数结构入门：群、环、域、向量空间
- 知乎 (zhihu.com)</a></p>
<figure>
<img
src="https://pica.zhimg.com/feb8dbb0222be967e7b04f81d69267cc_1440w.jpg?source=172ae18b"
alt="代数结构入门：群、环、域、向量空间" />
<figcaption
aria-hidden="true">代数结构入门：群、环、域、向量空间</figcaption>
</figure>
<h3 id="群">群</h3>
<h4 id="群-1">群</h4>
<p><span
class="math inline">\(&lt;G,·&gt;\)</span>表示一个定义了二元关系<span
class="math inline">\(·\)</span>的集合(注意这里<span
class="math inline">\(·\)</span>不一定是乘号,可以是所有二元关系的抽象表示)</p>
<p>如果G满足:</p>
<p>A1封闭性:<span class="math inline">\(\forall a,b\in G\rightarrow
a·b\in b\)</span></p>
<p>A2结合律:<span class="math inline">\(\forall a,b\in
G,a·(b·c)=(a·b)·c\)</span></p>
<p>A3单位元:<span class="math inline">\(\exist e\in G,\forall a\in
G,e·a=a·e=a\)</span></p>
<p>A4逆元:<span class="math inline">\(\forall a\in G,\exist
a^{-1},a·a^{-1}=a^{-1}·a=e\)</span></p>
<blockquote>
<p>这里<span
class="math inline">\(^{-1}\)</span>不是一定是-1次幂,只是逆元的表示形式</p>
</blockquote>
<p>集合G+A1+A2+A3+A4=群G</p>
<blockquote>
<p>&lt;Z,+&gt;就是一个群</p>
<p>&lt;N,+&gt;就不是一个群,因为如果定义单位元是0,那么1的逆元就是-1,但是-1不在自然数范围内,满足A1A2A3但是不满足A4的代数系统被称为幺半群</p>
</blockquote>
<h5 id="变换群">变换群</h5>
<p>设A是一非空集合,G是A到A的映射集合,如果G关于运算*构成一个群,则称<span
class="math inline">\(&lt;G,✳&gt;\)</span>是集合A上的一个变换群,简称变换群</p>
<h5 id="置换群">置换群</h5>
<p>设A是一非空有限集合,则A上的一个变换群就是A的一个置换群,简称置换群</p>
<h4 id="交换群">交换群</h4>
<p>A5交换律:<span class="math inline">\(\forall a,b\in
G,a·b=b·a\)</span></p>
<p>群G+A5=交换群G</p>
<p>l</p>
<h3 id="环">环</h3>
<h4 id="环-1">环</h4>
<p><span
class="math inline">\(&lt;R,+,\times&gt;\)</span>R是一个有两种二元运算的集合,这两种二元运算分别为加法<span
class="math inline">\(+\)</span>和乘法<span
class="math inline">\(\times\)</span></p>
<p>已知<span class="math inline">\(&lt;R,+&gt;\)</span>是交换群</p>
<p>如果R再满足</p>
<p>M1乘法封闭性:<span class="math inline">\(\forall a,b\in R,a\times
b\in R\)</span></p>
<p>M2乘法结合律:<span class="math inline">\(\forall a,b,c\in R,a\times
(b\times c)=(a\times b)\times c\)</span></p>
<p>M3乘法对加法的分配律:<span class="math inline">\(\forall a,b,c\in
R,\begin{cases}a\times (b+c)=a\times b+a\times c\\(a+b)\times c=a\times
c+b\times c\end{cases}\)</span></p>
<blockquote>
<p>注意这里没有写<span class="math inline">\(a \times (b+c)=(b+c)\times
a\)</span></p>
<p>因为这样写实际上是满足乘法交换律,而满足分配律不一定满足交换律,比如矩阵乘法</p>
<p>矩阵的左右乘结果一般是不一样的,但是矩阵乘法对矩阵加法是有结合律的</p>
</blockquote>
<p>则称R为环</p>
<h4 id="交换环">交换环</h4>
<p>如果环R再满足</p>
<p>M4乘法交换律:<span class="math inline">\(\forall a,b,c\in R,(a\times
b)\times c=a\times (b\times c)\)</span></p>
<blockquote>
<p>显然<span class="math inline">\(R_n(Q)\)</span>是环但不是交换环</p>
</blockquote>
<p>则称R为交换环</p>
<h4 id="整环">整环</h4>
<p>如果交换环R再满足</p>
<p>M5乘法单位元:<span class="math inline">\(\exist e,\forall a\in
R,e\times a=a\times e=a\)</span></p>
<blockquote>
<p>当<span class="math inline">\(R=S\)</span>为整数时,<span
class="math inline">\(e=1\)</span></p>
<p>当<span class="math inline">\(R=R_n(Q)\)</span>,n阶实数矩阵集合,<span
class="math inline">\(e=E(n)\)</span>n阶单位矩阵</p>
</blockquote>
<p>M6无零因子,:<span class="math inline">\(\forall a,b\in R,a\times
b=0\rightarrow a=0\ or\ b=0\)</span></p>
<p>则称R为整环</p>
<blockquote>
<p>怎么理解"无0因子"?</p>
<p>显然<span
class="math inline">\(R_n(Q)\)</span>不满足M6,因为两个矩阵<span
class="math inline">\(A,B\)</span>乘积是个0矩阵并不能说明<span
class="math inline">\(A\)</span>或者<span
class="math inline">\(B\)</span>矩阵有至少一个是零矩阵</p>
<p>比如</p>
<p><span class="math display">\[
A=\begin{bmatrix}
0\ 0\ 0\\
0\ 0\ 0\\
0\ 0\ 1\\
\end{bmatrix}\ \ \ \ \
B=\begin{bmatrix}
0\ 0\ 1\\
0\ 0\ 0\\
0\ 0\ 0\\
\end{bmatrix}
\]</span> 又如,</p>
<p>令<span class="math inline">\(Z_6=\{0,1,2,3,4,5\}\)</span>,</p>
<p>定义<span class="math inline">\(Z_6\)</span>上的乘法<span
class="math inline">\(\otimes\)</span>为<span
class="math inline">\(a\otimes b=(a\times b\ )mod\ 6\)</span></p>
<p>定义<span class="math inline">\(Z_6\)</span>上的加法<span
class="math inline">\(\oplus\)</span>为<span
class="math inline">\(a\oplus b=(a+b)mod\ 6\)</span></p>
<p>显然<span class="math inline">\(Z_6\)</span>满足<span
class="math inline">\(A_1-A_5,M_1-M_5\)</span></p>
<p>但是<span
class="math inline">\(&lt;Z_6,+,\times&gt;\)</span>不满足无零因子,比如</p>
<p><span class="math inline">\(2\otimes 3=(2\times 3)mod \ 6=6mod\
6=0\)</span></p>
<p>就是说,0这个元素一定也是在集合R中存在的,并且乘法运算结果为0一定和引入这个元素0有关</p>
</blockquote>
<h3 id="域">域</h3>
<p>设<span
class="math inline">\(&lt;R,+,\times&gt;\)</span>为一个整环,如果R再满足</p>
<p>M7乘法逆元:<span class="math inline">\(\forall a≠0\in R,\exist
a^{-1}\in R,a\times a^{-1}=1\)</span>则称<span
class="math inline">\(a^{-1}\)</span>为a的乘法逆元</p>
<blockquote>
<p>注意乘法逆元也是<span class="math inline">\(R\)</span>中的</p>
<p>定义乘法逆元的作用实际上是可以使用除法,除以一个数等于乘以该数的乘法逆元</p>
<p>比如对于<span
class="math inline">\(&lt;Z_7,+,\times&gt;\)</span>,由拓展欧几里得定理可知,由于模数为7是一个质数,因此0到6都存在<span
class="math inline">\(Z_7\)</span>上的mod 7意义下的乘法逆元</p>
<p>再比如全体整数就不是任何元素都有乘法逆元,只有1和-1有乘法逆元,任何绝对值大于1的整数其乘法逆元应该是分数,不属于整数.</p>
</blockquote>
<p>则称R为域F</p>
<h2 id="有限域gfp">有限域GF(p)</h2>
<p>符号意义:</p>
<p><span class="math inline">\(GF(p)=&lt;Z_p,\oplus,\otimes
&gt;\)</span></p>
<p><span class="math inline">\(GF:Galois Field\)</span>,伽罗华域</p>
<p><span class="math inline">\(p\)</span>:表示一个正素数</p>
<p><span class="math inline">\(\oplus:\forall a,b\in Z_p,a\oplus
b=(a+b)\ mod\ p\)</span>即模p加法</p>
<p><span class="math inline">\(\otimes : \forall a,b\in Z_p,a\otimes
b=(a\times b)\ mod\ p\)</span>即模屁乘法</p>
<blockquote>
<p>为什么一定要求是一个素数?</p>
<p>当N为一个合数的时候<span
class="math inline">\(Z_N=\{1,2,3,...,N-2,N-1\}\)</span>不满足<span
class="math inline">\(M_6\)</span>无零因子,不是整环,因此不是域</p>
<p>为什么不满足<span class="math inline">\(M_6\)</span>?</p>
<p>由已知,N是合数,则至少存在<span class="math inline">\(n\in
Z_N,1&lt;n&lt;N,n|N\)</span></p>
<p>如果<span class="math inline">\(n^2=N\)</span>,则有<span
class="math inline">\(n\otimes n=n\times n\ mod\ N=0\)</span></p>
<p>如果<span class="math inline">\(n^2!=N\)</span>,则<span
class="math inline">\(\exist n&#39;\in (1,N),nn&#39;=N\)</span>那么<span
class="math inline">\(n\otimes n&#39;=nn&#39;\ mod\ N=N\ mod \
N=0\)</span></p>
<p>故选取p为素数,就是为了保证<span
class="math inline">\(M_6\)</span>无零因子</p>
<p>同时,选取一个素数作为mod值,保证了<span
class="math inline">\(M_7\)</span>乘法逆元:</p>
<p><span class="math inline">\(\forall a\in Z_p,a\otimes
x=1\)</span>,即<span class="math inline">\(ax\equiv 1(mod\
p)\)</span>,显然当p为一个素数时有<span
class="math inline">\(gcd(a,p)=1\)</span>由2拓展欧几里得定理即可求出x的值</p>
<p>因此<span class="math inline">\(Z_p\)</span>就是一个有限域,用<span
class="math inline">\(GF(p)\)</span>表示</p>
</blockquote>
<h3 id="z_p上的数论定理"><span
class="math inline">\(Z_p\)</span>上的数论定理</h3>
<h4 id="拓展欧几里得定理求乘法逆元">拓展欧几里得定理求乘法逆元</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;<span class="comment">//拓展欧几里得算法ax+by=1=gcd(a,b)</span></span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">		x = <span class="number">1</span>;</span><br><span class="line">		y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> x2, y2;</span><br><span class="line">	<span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, x2, y2);</span><br><span class="line">	x = y2;</span><br><span class="line">	y = x2 - a / b * y2;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inverse</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;mod)</span> </span>&#123;<span class="comment">//求a在模mod下的逆元</span></span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	<span class="built_in">exgcd</span>(a, mod, x, y);</span><br><span class="line">	<span class="keyword">return</span> ((x % mod) + mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速幂">快速幂</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_pow</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;base, <span class="type">const</span> <span class="type">int</span> &amp;index, <span class="type">const</span> <span class="type">int</span> &amp;mod)</span> </span>&#123;<span class="comment">//bash^index(% mod)</span></span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> base % mod;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (index % <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">quick_pow</span>(base * base % mod, index &gt;&gt; <span class="number">1</span>, mod) % mod;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> base * <span class="built_in">quick_pow</span>(base * base % mod, index &gt;&gt; <span class="number">1</span>, mod) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多项式算术">多项式算术</h2>
<h3 id="为什么突然扯到多项式算数呢">为什么突然扯到"多项式算数"呢?</h3>
<p>前面我们证明了<strong>对于整数集<span
class="math inline">\(Z_N=\{0,1,2,3,...,N-1\}\)</span>,只有当<span
class="math inline">\(|Z_N|=N\)</span>为素数p时,<span
class="math inline">\(Z_p\)</span>才为一个域</strong></p>
<p>如果想要得到一个元素个数为<span
class="math inline">\(2^n\)</span>的域,显然<span
class="math inline">\(Z_p\)</span>做不到.</p>
<p>为什么要得到一个元素个数为<span
class="math inline">\(2^n\)</span>的域?计算机使用二进制编码,AES加密算法就用到了<span
class="math inline">\(GF(2^8)\)</span></p>
<p>一个3位二进制数可以表示8中状态,明文和密码就在这八种状态之中</p>
<table>
<thead>
<tr>
<th>模8乘法</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>2</td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>2</td>
<td>4</td>
<td>6</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>3</td>
<td>6</td>
<td>1</td>
<td>4</td>
<td>7</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>4</td>
<td>0</td>
<td>4</td>
<td>0</td>
<td>4</td>
<td>4</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>0</td>
<td>5</td>
<td>2</td>
<td>7</td>
<td>4</td>
<td>1</td>
<td>6</td>
<td>3</td>
</tr>
<tr>
<td>6</td>
<td>0</td>
<td>6</td>
<td>4</td>
<td>2</td>
<td>4</td>
<td>3</td>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>0</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>在<span
class="math inline">\(Z_8\)</span>中的数字乘法,其结果中个数字的出现次数显然是不均匀的,比如1出现了4次,2就出现了8次</p>
<p>而一个理想的密码是不能暴露词频信息的,显然用<span
class="math inline">\(Z_8\)</span>上的变换进行加密不理想,于是想一种乘法和除法的构造方法,
使得有8个元素的域其乘法或者加法的结果的频率相等</p>
<p>而使用多项式运算就可以解决这个问题,因此引入了多项式运算</p>
<p>首先要研究的是==如何构造一个有8个元素(<span
class="math inline">\(p^n\)</span>)的域==</p>
<h3 id="将数的性质拓展到多项式式上">==将数的性质拓展到多项式式上==</h3>
<p>我们使用的一般是<strong>代数基本规则的普通多项式运算</strong></p>
<p><strong>然后拓展到系数在<span
class="math inline">\(GF(p)\)</span>中的多项式运算</strong></p>
<p><strong>然后再拓展到系数在<span
class="math inline">\(GF(p)\)</span>,模一个<span
class="math inline">\(n\)</span>次多项式<span
class="math inline">\(m(x)\)</span>的多项式运算</strong></p>
<p>最终目标是理解并应用最后一种多项式</p>
<h3 id="普通多项式运算">普通多项式运算</h3>
<p>多项式次数:最高次项的次数</p>
<p>多项式的表示: <span class="math display">\[
f(x)=a_nx^n+a_{n-1}x^{n-1}+...+a_1x+a_0=\sum_{i=0}^na_ix^i,a_n≠0
\]</span> 如果<span class="math inline">\(\forall a_i\in
S\)</span>则称<span class="math inline">\(f(x)\)</span>是系数集<span
class="math inline">\(S\)</span>上的多项式,令<span
class="math inline">\(&lt;A,+,\times
&gt;\)</span>表示S上的所有多项式以及加法和乘法二元关系</p>
<blockquote>
<p>当<span
class="math inline">\(S=Z\)</span>表示整数集的时候,显然A是满足<span
class="math inline">\(A_1-A_5,M_1-M_6\)</span>,是个整环,</p>
<p>但是不满足乘法逆元,比如<span
class="math inline">\(x\)</span>的乘法逆元<span
class="math inline">\(x^{-1}\)</span>,是一个指数为负的多项式,显然不在<span
class="math inline">\(A\)</span></p>
</blockquote>
<p>设 <span class="math display">\[
f(x)=\sum_{i=0}^na_ix^i\\
g(x)=\sum_{i=0}^mb_ix^i\\
a_nb_m≠0,n\ge m
\]</span> 则普通多项式的加法运算 <span class="math display">\[
f(x)+g(x)=\sum_{i=0}^m(a_i+b_i)x^i+\sum_{i=m+1}^na_i x^i
\]</span> 普通多项式乘法 <span class="math display">\[
f(x)g(x)=\sum_{i=0}^{n+m}c_ix^i\\
c_i=a_0b_i+a_1b_{i-1}+...+a_ib_0
\]</span></p>
<h3 id="系数在z_p中的多项式运算">系数在<span
class="math inline">\(Z_p\)</span>中的多项式运算</h3>
<p>当系数集是全体整数的时候,由于系数不都有乘法逆元,因此无法进行多项式除法</p>
<p>当系数集是一个域的时候,系数都有了乘法逆元,可以对多项式引入除法(带余除法)</p>
<p>可以类比整数的除法,求余数用<span
class="math inline">\(\%\)</span>,求商用<span
class="math inline">\(/\)</span></p>
<p>那么在<span
class="math inline">\(Z_p\)</span>中的多项式,求余式用<span
class="math inline">\(\%\)</span>,求商式用<span
class="math inline">\(/\)</span></p>
<blockquote>
<p>比如对于<span class="math inline">\(Z_2\)</span>上的多项式<span
class="math inline">\(f(x)=x^4+1=(x+1)(x^3+x^2+x+1)\)</span>,则<span
class="math inline">\(f(x)/(x+1)=x^3+x^2+x+1\)</span></p>
</blockquote>
<p>设系数域为<span class="math inline">\(&lt;Z_p,\oplus,\otimes
&gt;\)</span></p>
<p>设<span class="math inline">\(Z_p\)</span>上的两个多项式 <span
class="math display">\[
f(x)=\sum_{i=0}^na_ix^i\\
g(x)=\sum_{i=0}^mb_ix^i\\
a_n,b_m≠0,n\ge m
\]</span></p>
<h4 id="z_p多项式的四则运算"><span
class="math inline">\(Z_p\)</span>多项式的四则运算</h4>
<p>则<span class="math inline">\(Z_p\)</span>上的多项式加法(减法类似)为
<span class="math display">\[
f(x)+g(x)=\sum_{i=0}^m(a_i\oplus b_i)x^i+\sum_{i=m+1}^na_i x^i\\
=\sum_{i=0}^m(a_i+ b_i)mod\ p\ \times x^i+\sum_{i=m+1}^na_i x^i
\]</span></p>
<p><span class="math inline">\(Z_p\)</span>上的多项式乘法为 <span
class="math display">\[
f(x)g(x)=\sum_{i=0}^{n+m}c_ix^i\\
c_i=(a_0b_i+a_1b_{i-1}+...+a_ib_0)mod\ p
\]</span> <span class="math inline">\(Z_p\)</span>上的带余式除法 <span
class="math display">\[
f(x)=q(x)g(x)+r(x)
\]</span> 意思是<span class="math inline">\(f(x)\div
g(x)=q(x)...r(x)\)</span></p>
<p>以<span
class="math inline">\(Degree(f)\)</span>表示多项式f的阶,并且<span
class="math inline">\(Degree(f)=n,\\
Degree(g)=m,\\\)</span>则有<span class="math inline">\(Degree(q)=n-m\\
Degree(r)\le m-1\)</span></p>
<h4 id="z_p多项式的欧几里得定理"><span
class="math inline">\(Z_p\)</span>多项式的欧几里得定理</h4>
<p>定义<span class="math inline">\(d(x)\)</span>是<span
class="math inline">\(a(x),b(x)\)</span>的最大公因式,即<span
class="math inline">\(d(x)\)</span>是能够整除<span
class="math inline">\(a(x),b(x)\)</span>的所有多项式中次数最高的 <span
class="math display">\[
gcd(a(x),b(x))=gcd[b(x),a(x)\%b(x)]
\]</span></p>
<h3 id="z_p上多项式再mod-n次素多项式"><span
class="math inline">\(Z_p\)</span>上多项式再mod n次素多项式</h3>
<p>对于<span
class="math inline">\(Z_p\)</span>上次数高于n-1的多项式<span
class="math inline">\(f(x)\)</span>,需要mod一个<span
class="math inline">\(Z_p\)</span>上的n次<strong>素多项式</strong><span
class="math inline">\(m(x)\)</span>,如此限制<span
class="math inline">\(f(x)\)</span>的次数在<span
class="math inline">\([0,n-1]\)</span></p>
<p>什么是"素多项式"?<span
class="math inline">\(Z_p\)</span>上的素多项式<span
class="math inline">\(m(x)\)</span>无法被<span
class="math inline">\(Z_p\)</span>上的任意多项式整除</p>
<p>当<span class="math inline">\(m(x)\)</span>的次数为n,则<span
class="math inline">\(Z_p\)</span>上的多项式<span
class="math inline">\(mod\
m(x)\)</span>都会落在次数小于等于n-1的多项式集<span
class="math inline">\(F\)</span>中</p>
<p>显然<span class="math inline">\(F\)</span>中的多项式都可以表示为
<span class="math display">\[
\forall f(x)\in F,f(x)=a_0+a_1x+...+a_{n-1}x^{n-1},\forall a_i\in Z_p
\]</span> 那么这样的多项式一共有<span
class="math inline">\(p^n\)</span>个(系数的乘法原理),即模<span
class="math inline">\(m(x)\)</span>构成的剩余类</p>
<p>现在类比<span class="math inline">\(Z_p\)</span>,<strong>证明<span
class="math inline">\(F\)</span>是一个域</strong></p>
<p>显然加减乘封闭且结合律分配律交换律均满足,<span
class="math inline">\(F\)</span>容易判定为交换环</p>
<p>由于1也是<span
class="math inline">\(F\)</span>中的多项式,因此存在乘法单位元1,</p>
<p><strong>下面证明M6无零因子</strong></p>
<p>由于k阶多项式的k次项系数不为零,假设有两个非零多项式,其最高次项分别为<span
class="math inline">\(a_ix^i,b_jx^j\)</span></p>
<p>乘积多项式的最高次项为<span
class="math inline">\(a_ib_jx^{i+j}\)</span>如果指数<span
class="math inline">\(i+j\ge n\)</span>则对<span
class="math inline">\(m(x)\)</span>取模,如果系数<span
class="math inline">\(a_ib_j\ge p\)</span>则对<span
class="math inline">\(p\)</span>取模</p>
<p>显然p是一个素数,<span class="math inline">\(a_ib_j=a_i\times
b_j\)</span>是一个合数,合数对素数取模显然不为0</p>
<p>因此任何两个非零多项式乘积一定非零,M6无零因子得证</p>
<p>到此F被证明是整环</p>
<blockquote>
<p>无零因子就是<span class="math inline">\(GF(2^3)\)</span>是域但是<span
class="math inline">\(Z_8\)</span>不是域的本质原因</p>
</blockquote>
<p><strong>下面证明任意F中的非0多项式都在F中有乘法逆元</strong></p>
<p><span class="math inline">\(f(x)g(x)\equiv 1(mod\ m(x))\)</span></p>
<p><span class="math inline">\(g(x)f(x)+k(x)m(x)=1\)</span></p>
<p>又<span
class="math inline">\(m(x)\)</span>为素因式,有欧几里得定理知上式有解</p>
<p>因此M7乘法逆元得证</p>
<p>因此<span class="math inline">\(F\)</span>是域</p>
<h3 id="f和z_p的不同"><span class="math inline">\(F\)</span>和<span
class="math inline">\(Z_p\)</span>的不同</h3>
<p>我们在证明<span
class="math inline">\(Z_p\)</span>是域的时候发现,对于整数集<span
class="math inline">\(Z_N=\{0,1,2,3,...,N-1\}\)</span>,只有当<span
class="math inline">\(|Z_N|=N\)</span>为素数p时,<span
class="math inline">\(Z_p\)</span>才为一个域</p>
<p>而现在<span class="math inline">\(|F|=p^n\)</span>显然当<span
class="math inline">\(n&gt;1\)</span>时是一个合数,但是<span
class="math inline">\(F\)</span>仍然是一个域</p>
<p>将<span class="math inline">\(F\)</span>记作<span
class="math inline">\(GF(p^n)\)</span>表示伽罗华域</p>
<h3 id="fgfpn上的乘法逆元"><span
class="math inline">\(F=GF(p^n)\)</span>上的乘法逆元</h3>
<p><span class="math display">\[
f(x)g(x)\equiv 1(mod \ m(x))\\
g(x)f(x)+k(x)m(x)=1\\
gcd(f(x),m(x))=1
\]</span></p>
<p>显然可以将整数上的拓展欧几里得推广到F上</p>
<h2 id="gf2n上构造结果分布均匀的二元运算"><span
class="math inline">\(GF(2^n)\)</span>上构造结果分布均匀的二元运算</h2>
<p><span
class="math inline">\(GF(2^n)\)</span>上的多项式各项的系数要么是0,要么是1,可以用二进制数表示</p>
<p>比如<span
class="math inline">\(x^3+x^2+1\)</span>就可以表示为1101</p>
<h3 id="加法">加法</h3>
<p>由于系数要么是0要么是1,即系数要自动对2取模</p>
<p>那么多项式的加法就是二进制数按位异或</p>
<p>比如<span
class="math inline">\((x^3+x^2+x)+(x^4+x+1)=x^4+x^3+x^2+2x+1=x^4+x^3+x^2+1\)</span></p>
<p><span class="math inline">\(01110\oplus 10011=11101\)</span></p>
<h3 id="乘法">乘法</h3>
<p>教材上一本正经地写了一堆用字母表示的多项式,看上去头大.</p>
<p>从一个例子入手可能比较容易理解:</p>
<p>考虑AES加密算法使用到的<span
class="math inline">\(GF(2^8)\)</span>,取<span
class="math inline">\(m(x)=x^8+x^4+x^3+x+1\)</span>为模.</p>
<p><span class="math inline">\(f(x)=x^6+x^4+x^2+x+1\)</span></p>
<p><span class="math inline">\(g(x)=x^7+x+1\)</span></p>
<p>求<span class="math inline">\(f(x)\otimes g(x)=f(x)\times g(x)\mod
m(x)\)</span></p>
<h4 id="拆分成项">拆分成项</h4>
<p>容易想到的是把<span
class="math inline">\(g(x)\)</span>按幂次拆分成项然后用f(x)与g(x)的各项相乘之后相加,而相加在"加法"中我们已经认识到可以通过两个多项式异或这种简洁的方式实现,因此我们现在把精力放在<span
class="math inline">\(f(x)\)</span>如何和一个<span
class="math inline">\(x^k\)</span>项相乘上 <span class="math display">\[
f(x)\times g(x)\mod m(x)\\
=f(x)\times(1+x+x^7)\mod m(x)\\
=f(x)\times 1\mod m(x)+f(x)\times x\mod m(x)+f(x)\times x^7\mod m(x)
\]</span> 问题转化为如何求<span class="math inline">\(f(x)\times x^k\mod
m(x)\)</span></p>
<h4 id="求fxtimes-xkmod-mx">求<span class="math inline">\(f(x)\times
x^k\mod m(x)\)</span></h4>
<p>由于 <span class="math display">\[
f(x)\times x^k\mod m(x)\\
=\{[(f(x)\times x\mod m(x))\times x\mod m(x)]\times ...\times x\mod
m(x)\}\times x\mod m(x)
\]</span> 因此问题又可以转换为怎么跨出求<span
class="math inline">\(f(x)\)</span>到<span
class="math inline">\(f(x)\times x\mod m(x)\)</span>这第一步</p>
<h4 id="求fxtimes-xmod-mx">求<span class="math inline">\(f(x)\times
x\mod m(x)\)</span></h4>
<p>假设<span
class="math inline">\(f(x)=a_7x^7+a_6x^6+...+a_1x+a_0\)</span>表示<span
class="math inline">\(GF(2^8)\)</span>上的任意多项式</p>
<p>则<span class="math inline">\(x\times
f(x)=a_7x^8+a_6x^7+...+a_0x\)</span></p>
<p>如果用二进制表示,那么 <span class="math display">\[
f(x)=&amp;a_7&amp;a_6&amp;a_5&amp;a_4&amp;a_3&amp;a_2&amp;a_1&amp;a_0\\
x\times
f(x)=a_7&amp;a_6&amp;a_5&amp;a_4&amp;a_3&amp;a_2&amp;a_1&amp;a_0&amp;0
\]</span> 在还没有取模时,我们可以发现<span
class="math inline">\(f(x)\)</span>到<span class="math inline">\(x\times
f(x)\)</span>只需要将<span
class="math inline">\(f(x)\)</span>的二进制表示左移一位,下面考虑如何取模</p>
<p>如果<span class="math inline">\(a_7=0\)</span>则<span
class="math inline">\(x\times
f(x)\)</span>顶多是一个7次多项式,如果有<span
class="math inline">\(a_6=0\)</span>则顶多是一个6次多项式,一个七次多项式<span
class="math inline">\(x\times f(x)\)</span>去mod一个8次多项式<span
class="math inline">\(m(x)\)</span>实乃以卵击石,直接被8次多项式劝返</p>
<p>如果<span class="math inline">\(a_7=1\)</span>则<span
class="math inline">\(x\times f(x)\)</span>与<span
class="math inline">\(m(x)\)</span>都是8次多项式,算是旗鼓相当,可以一战</p>
<p>此时<span class="math inline">\(x\times
f(x)\)</span>可以分成精锐的头部<span
class="math inline">\(x^8\)</span>与累赘的尾部<span
class="math inline">\(a_6x^7+a_5x^6+...+a_0x\)</span>,</p>
<p>这个尾部对<span
class="math inline">\(m(x)\)</span>取模还是被劝返,只留下精锐的头部<span
class="math inline">\(x^8\)</span>独自抗衡<span
class="math inline">\(m(x)\)</span></p>
<p>那么问题转化为<span class="math inline">\(x^8\)</span>对<span
class="math inline">\(m(x)=x^8+x^4+x^3+x+1\)</span>取模,考虑如何取模?</p>
<h4 id="求x8-mod-mx">求<span class="math inline">\(x^8 \mod
m(x)\)</span></h4>
<p><span class="math inline">\(x^8\)</span>形单影只,只能单挑<span
class="math inline">\(m(x)\)</span>的<span
class="math inline">\(x^8\)</span>项,无暇处理<span
class="math inline">\(m(x)\)</span>的一伙子小弟,</p>
<p>于是<span class="math inline">\(x^8\)</span>利用其系数都在<span
class="math inline">\(GF(2)\)</span>上,无中生有搬来了一伙子小弟: <span
class="math display">\[
x^8\equiv x^8+2x^7+2x^6+...+2x+2(系数mod 2)
\]</span> 此时用<span
class="math inline">\(x^8+2x^7+2x^6+...+2x+2\)</span>去<span
class="math inline">\(\mod
m(x)\)</span>终于可以大干一场了,还得是门当户对地干,次数相同的项单挑</p>
<p><span class="math inline">\(x^8\equiv x^8+2x^7+2x^6+...+2x+2(系数mod
2)\)</span>作为被除数,<span
class="math inline">\(m(x)\)</span>作为除数,余数即为所求结果</p>
<p>战争一开始,商1之后被除数减去除数得到<span
class="math inline">\(2x^7+2x^6+2x^5+x^4+x^3+2x^2+x+1\equiv
x^4+x^3+x+1(系数mod2)\)</span></p>
<p>立刻发现刚才"精锐的头部"那个<span
class="math inline">\(x^8\)</span>在和<span
class="math inline">\(m(x)\)</span>的8次项的决斗中阵亡了,剩下的小弟都是7次方以下的项,无力与<span
class="math inline">\(m(x)\)</span>抗衡,直接作为余数</p>
<p>即刚才的"战争"可以写为: <span class="math display">\[
x^8\equiv x^4+x^3+x+1 \mod m(x)\&amp;系数mod2\\
其中m(x)=x^8+x^4+x^3+x+1
\]</span> 突然发现<span class="math inline">\(x^8\mod
m(x)=m(x)-x^8=x^4+x^3+x+1\)</span></p>
<p>这是巧合吗?</p>
<p>这是系数mod2的必然结果,并且可以从8次推广到n次:</p>
<p><span class="math inline">\(m(x)\)</span>为n次多项式 <span
class="math display">\[
x^n\mod m(x)=m(x)-x^n(系数mod2)
\]</span> <span class="math inline">\(x^8\)</span>独自面对<span
class="math inline">\(m(x)\)</span>,最终壮烈牺牲但是换回<span
class="math inline">\(x^4+x^3+x+1\)</span>颇有"将军百战死,壮士十年归"的感觉</p>
<p>在战争之前我们把"累赘的尾部<span
class="math inline">\(a_6x^7+a_5x^6+...+a_0x\)</span>"留下不参战,原因是他们参战也会被敌人<span
class="math inline">\(m(x)\)</span>直接劝返</p>
<p>现在我们知道了精锐的头部<span
class="math inline">\(x^8\)</span>和累赘的尾部<span
class="math inline">\(a_6x^7+a_5x^6+...+a_0x\)</span>各自参战的结果了,此时可以总结一支部队<span
class="math inline">\(x\times
f(x)=x^8+a_6x^7+a_5x^6+...+a_0x\)</span>参战的结果了: <span
class="math display">\[
x\times f(x)\mod m(x)=[m(x)-x^8]+a_6x^7+a_5x^6+...+a_0x
\]</span> 比如当<span
class="math inline">\(f(x)=x^7+x^4+x^2+x+1,m(x)=x^8+x^4+x^3+x+1\)</span>时
<span class="math display">\[
\begin{aligned}
&amp;x\times f(x)\mod m(x)\\
&amp;=(x^8+x^5+x^3+x^2+x)\mod (x^8+x^4+x^3+x+1)\\
&amp;=[x^4+x^3+x+1]+[x^5+x^3+x^2+x]\\
&amp;=011011\oplus 101110\\
&amp;=110101
\end{aligned}
\]</span> 到此我们知道<span class="math inline">\(x\times f(x)\mod
m(x)\)</span>如何计算了,</p>
<p>那么<span class="math inline">\(x^2\times f(x)\mod m(x)=x\times
(x\times f(x)\mod m(x))\mod m(x)\)</span></p>
<p>以此类推可以得到<span class="math inline">\(x^k\times f(x)\mod
m(x)\)</span>如何计算了</p>
<h4 id="回到求fxtimes-gxmod-mx">回到求<span
class="math inline">\(f(x)\times g(x)\mod m(x)\)</span></h4>
<p>不管你<span
class="math inline">\(g(x)\)</span>长什么样,我先预处理出<span
class="math inline">\(f(x)\times x\mod x,f(x)\times x^2\mod
m(x),f(x)\times x^k\mod m(x)\)</span>等等情况</p>
<p>如果你<span class="math inline">\(g(x)=1+x+x^2\)</span>长得很虚,那么
<span class="math display">\[
f(x)\times g(x)\mod m(x)\\
=f(x)\times (1+x+x^2)\mod m(x)\\
=(f(x)+x\times f(x)+x^2\times f(x))\mod m(x)\\
=f(x)+x\times f(x)\mod m(x)+x^2\times f(x)\mod m(x)
\]</span> 直接利用预处理得出的结果,然后计算加法直接用二进制异或</p>
<h2 id="总结">总结</h2>
<p>到此我们构造出了<span
class="math inline">\(GF(2^n)\)</span>,即有<span
class="math inline">\(2^n\)</span>个元素的伽罗华域</p>
<p>怎么构造出的?由系数在<span
class="math inline">\(GF(2)\)</span>上的多项式模一个<span
class="math inline">\(2^n\)</span>次的素多项式拓展出的</p>
<p>多项式和这<span
class="math inline">\(2^n\)</span>个数怎么产生联系?每一个多项式都对应一个二进制数</p>
<p>这<span
class="math inline">\(2^n\)</span>个数的加减乘除运算怎么定义的?还是通过多项式的运算得到的</p>
<p>下一步可以向AES加密算法进军了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/02/07/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/07/MySQL/" class="post-title-link" itemprop="url">MYSQL命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-07 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-07T00:00:00+08:00">2022-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-19 09:16:16" itemprop="dateModified" datetime="2022-09-19T09:16:16+08:00">2022-09-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mysql命令">MySQL命令</h1>
<h2 id="登录">登录</h2>
<p>在linux终端上登录命令为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysql -u&lt;username&gt; -p&lt;password&gt;</span><br><span class="line">&gt;mysql -u&lt;username&gt; -p</span><br><span class="line">&gt;Enter password:&lt;password&gt;</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysql -uroot -psjh123456</span><br></pre></td></tr></table></figure>
<blockquote>
<p>登录成功之后:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/桌</span><br><span class="line">面# mysql -u root -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 31</span><br><span class="line">Server version: 8.0.27-0ubuntu0.20.04.1 (Ubuntu)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2021, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>或者:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysql -uroot -p</span><br><span class="line">&gt;Enter password: </span><br></pre></td></tr></table></figure>
<p>后面这种方法密码需要另起一行输入,并且输入的时候不会显示在屏幕上,类似于linux终端登录其他用户账号时的情形</p>
<p>退出登录:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;exit;</span><br></pre></td></tr></table></figure>
<p>==注意==</p>
<p>1.登录MySQL数据库之后,命令行自动带上<code>mysql&gt;</code>标志,表示此后执行的所有命令均是对MySQL数据库的操作.</p>
<p>2.MySQL命令也是末行模式,并且以分号";"结束命令</p>
<h2 id="查看用户名下所有数据库">查看用户名下所有数据库</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show databases;</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| earth              |</span><br><span class="line">| empire             |</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">6 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<h2 id="创建数据库">创建数据库</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysql create database &lt;dbname&gt;;</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create DATABASE newdb;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>如果已经存在同名数据库则会报告错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database newdb;</span><br><span class="line">ERROR 1007 (HY000): Can&#x27;t create database &#x27;newdb&#x27;; database exists</span><br></pre></td></tr></table></figure>
<h2 id="删除数据库">删除数据库</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;drop database &lt;dbname&gt;;</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; drop database newdb;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure>
<p>对一个不存在的数据库名使用drop命令会报错:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; drop database newdb;</span><br><span class="line">ERROR 1008 (HY000): Can&#x27;t drop database &#x27;newdb&#x27;; database doesn&#x27;t exist</span><br></pre></td></tr></table></figure>
<h2 id="选择数据库">选择数据库</h2>
<p>使用<code>show databases</code>命令之后可以看到一系列数据库列表,现在要对其中某个数据库进行操作,应当选中该数据库,类似于cd进入某个子目录进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;use &lt;dbname&gt;</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use empire;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure>
<p>企图使用不存在的数据库将会报错:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use noneexist;</span><br><span class="line">ERROR 1049 (42000): Unknown database &#x27;noneexist&#x27;</span><br></pre></td></tr></table></figure>
<p>注意此后对数据表的操作需要首先选中数据库</p>
<p>对于单个数据的操作需要首先选中数据表</p>
<h2 id="查看数据表状态">查看数据表状态</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLE STATUS LIKE &#x27;&lt;tablename&gt;&#x27;;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://gitee.com/deutschball/imperial-march/raw/master/status.png"
alt="status" />
<figcaption aria-hidden="true">status</figcaption>
</figure>
<h2 id="创建数据表">创建数据表</h2>
<p>如果没有事先选中数据库就创建数据表会报错:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create TABLE troop;</span><br><span class="line">ERROR 1046 (3D000): No database selected</span><br></pre></td></tr></table></figure>
<p>需要事先使用use命令确定数据库之后才能建立数据表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;CREATE TABLE &lt;tablename&gt;(</span><br><span class="line">	column_name1 data_type(size),</span><br><span class="line">	column_name2 data_type(size),</span><br><span class="line">	...</span><br><span class="line">	column_namen data_type(size)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>其中<table_name>后面的圆括号中包含若干对数据,分别是列名称和其数据类型(最大长度)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use empire;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; CREATE TABLE troop(</span><br><span class="line">    -&gt; id int,</span><br><span class="line">    -&gt; name varchar(255),</span><br><span class="line">    -&gt; age int</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure>
<p>在数据类型后面可以声明not
null,则新增记录时如果该项的值缺省则报错(不声明not
null的缺省值自动设为NULL)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE fleets(</span><br><span class="line">    -&gt; id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    -&gt; commander VARCHAR(100) NOT NULL,</span><br><span class="line">    -&gt; PRIMARY KEY(id)</span><br><span class="line">    -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.02 sec)</span><br><span class="line">mysql&gt; insert into fleets(id)values(2);</span><br><span class="line">ERROR 1364 (HY000): Field &#x27;commander&#x27; doesn&#x27;t have a default value</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="属性约束">属性约束</h3>
<p>主键约束</p>
<p>外键约束</p>
<p>空约束</p>
<p>去重约束</p>
<p>默认值约束</p>
<p>断言约束</p>
<p>检查约束</p>
<h2 id="删除数据表">删除数据表</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table &lt;tablename&gt;</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; drop table troop;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
<h2 id="插入数据">插入数据</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table_name ( field1, field2,...fieldN )VALUES( value1, value2,...valueN );</span><br></pre></td></tr></table></figure>
<p>前面括号中是列栏目名称,插入不是按照数据表创建时的列顺序插入的,而是value与field一一对应</p>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into fleets(commander)values(&#x27;vader&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fleets;</span><br><span class="line">+----+-----------+</span><br><span class="line">| id | commander |</span><br><span class="line">+----+-----------+</span><br><span class="line">|  1 | vader     |</span><br><span class="line">+----+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>id已设置自增</p>
</blockquote>
<h2 id="查询数据表">查询数据表</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name,column_name</span><br><span class="line">FROM table_name</span><br><span class="line">[WHERE Clause]</span><br><span class="line">[LIMIT N][ OFFSET M]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>select语句列明要查找的列栏目名称</p>
<p>column_name规定保留查询记录的列目,如果只写星号*,则保留完整记录</p>
<p>from语句指明从哪个数据表查询</p>
<p>where语句给出数据筛选条件</p>
<p>limit语句限定查询数据最大条数</p>
<p>offeset设置开始查询的数据偏移量</p>
</blockquote>
<p>例如现有数据库如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from fleets;</span><br><span class="line">+----+-----------+</span><br><span class="line">| id | commander |</span><br><span class="line">+----+-----------+</span><br><span class="line">|  1 | vader     |</span><br><span class="line">|  2 | soldier1  |</span><br><span class="line">|  3 | soldier2  |</span><br><span class="line">|  4 | soldier10 |</span><br><span class="line">|  5 | vader     |</span><br><span class="line">|  6 | vader     |</span><br><span class="line">|  7 | vader     |</span><br><span class="line">|  8 | vader     |</span><br><span class="line">|  9 | vader     |</span><br><span class="line">| 10 | vader     |</span><br><span class="line">| 11 | vader     |</span><br><span class="line">| 12 | vader     |</span><br><span class="line">+----+-----------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要查询所有commander=vader的飞船的id记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select id from fleets where commander=&#x27;vader&#x27;;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  1 |</span><br><span class="line">|  5 |</span><br><span class="line">|  6 |</span><br><span class="line">|  7 |</span><br><span class="line">|  8 |</span><br><span class="line">|  9 |</span><br><span class="line">| 10 |</span><br><span class="line">| 11 |</span><br><span class="line">| 12 |</span><br><span class="line">+----+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打印数据表前五个完整记录:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from fleets limit 5;</span><br><span class="line">+----+-----------+</span><br><span class="line">| id | commander |</span><br><span class="line">+----+-----------+</span><br><span class="line">|  1 | vader     |</span><br><span class="line">|  2 | soldier1  |</span><br><span class="line">|  3 | soldier2  |</span><br><span class="line">|  4 | soldier10 |</span><br><span class="line">|  5 | vader     |</span><br><span class="line">+----+-----------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="where">WHERE</h3>
<p>类似于if语句,用于限定查询,删除等操作的范围.</p>
<p>可以理解为:在满足某某条件的记录上进行某种操作</p>
<p>比如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select id from fleets where commander=&#x27;vader&#x27;;</span><br></pre></td></tr></table></figure>
<p>这句就可以翻译为:</p>
<p>从fleets数据表中查询所有commander列的值为'vader'的记录,返回满足条件的记录的id</p>
<h4 id="where条件为bool表达式">where条件为bool表达式</h4>
<blockquote>
<p>注意判断是否相等只需要使用单等号=,不需要使用双等号==</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from fleets where id%2=0;</span><br></pre></td></tr></table></figure>
<p>这句可以翻译为:</p>
<p>从fleets数据表中查询所有id为偶数的记录</p>
<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+----+-----------+</span><br><span class="line">| id | commander |</span><br><span class="line">+----+-----------+</span><br><span class="line">|  2 | soldier1  |</span><br><span class="line">|  4 | soldier10 |</span><br><span class="line">|  6 | vader     |</span><br><span class="line">|  8 | vader     |</span><br><span class="line">| 10 | vader     |</span><br><span class="line">| 12 | vader     |</span><br><span class="line">+----+-----------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h4 id="where中使用and指定多个条件">where中使用and指定多个条件</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from fleets where id%2=0 and id%3=0;</span><br><span class="line">+----+-----------+</span><br><span class="line">| id | commander |</span><br><span class="line">+----+-----------+</span><br><span class="line">|  6 | vader     |</span><br><span class="line">| 12 | vader     |</span><br><span class="line">+----+-----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从fleets数据表中查询所有id为2和3的公倍数的记录</p>
<h4
id="where使用binary开启大小写敏感">where使用binary开启大小写敏感</h4>
<p>现有数据表如下(注意第13条记录Vader有大写),要查询所有commander='vader'的记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from fleets;</span><br><span class="line">+----+-----------+</span><br><span class="line">| id | commander |</span><br><span class="line">+----+-----------+</span><br><span class="line">|  1 | vader     |</span><br><span class="line">|  2 | soldier1  |</span><br><span class="line">|  3 | soldier2  |</span><br><span class="line">|  4 | soldier10 |</span><br><span class="line">|  5 | vader     |</span><br><span class="line">|  6 | vader     |</span><br><span class="line">|  7 | vader     |</span><br><span class="line">|  8 | vader     |</span><br><span class="line">|  9 | vader     |</span><br><span class="line">| 10 | vader     |</span><br><span class="line">| 11 | vader     |</span><br><span class="line">| 12 | vader     |</span><br><span class="line">| 13 | Vader     |</span><br><span class="line">+----+-----------+</span><br><span class="line">13 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用binary关键字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from fleets where binary commander=&#x27;vader&#x27;;</span><br><span class="line">+----+-----------+</span><br><span class="line">| id | commander |</span><br><span class="line">+----+-----------+</span><br><span class="line">|  1 | vader     |</span><br><span class="line">|  5 | vader     |</span><br><span class="line">|  6 | vader     |</span><br><span class="line">|  7 | vader     |</span><br><span class="line">|  8 | vader     |</span><br><span class="line">|  9 | vader     |</span><br><span class="line">| 10 | vader     |</span><br><span class="line">| 11 | vader     |</span><br><span class="line">| 12 | vader     |</span><br><span class="line">+----+-----------+</span><br><span class="line">9 rows in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果不用binary:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from fleets where commander=&#x27;vader&#x27;;</span><br><span class="line">+----+-----------+</span><br><span class="line">| id | commander |</span><br><span class="line">+----+-----------+</span><br><span class="line">|  1 | vader     |</span><br><span class="line">|  5 | vader     |</span><br><span class="line">|  6 | vader     |</span><br><span class="line">|  7 | vader     |</span><br><span class="line">|  8 | vader     |</span><br><span class="line">|  9 | vader     |</span><br><span class="line">| 10 | vader     |</span><br><span class="line">| 11 | vader     |</span><br><span class="line">| 12 | vader     |</span><br><span class="line">| 13 | Vader     |</span><br><span class="line">+----+-----------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="数据表更新记录">数据表更新记录</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name SET field1=new-value1, field2=new-value2,...</span><br><span class="line">[WHERE Clause]</span><br></pre></td></tr></table></figure>
<p>将fleets数据表中id=5的记录的指挥官重新指派为anakin</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update fleets set commander=&#x27;anakin&#x27; where id=5;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select *from fleets;</span><br><span class="line">+----+-----------+</span><br><span class="line">| id | commander |</span><br><span class="line">+----+-----------+</span><br><span class="line">|  1 | vader     |</span><br><span class="line">|  2 | soldier1  |</span><br><span class="line">|  3 | soldier2  |</span><br><span class="line">|  4 | soldier10 |</span><br><span class="line">|  5 | anakin    |</span><br><span class="line">|  6 | vader     |</span><br><span class="line">|  7 | vader     |</span><br><span class="line">|  8 | vader     |</span><br><span class="line">|  9 | vader     |</span><br><span class="line">| 10 | vader     |</span><br><span class="line">| 11 | vader     |</span><br><span class="line">| 12 | vader     |</span><br><span class="line">| 13 | Vader     |</span><br><span class="line">+----+-----------+</span><br><span class="line">13 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="数据表删除记录">数据表删除记录</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name [WHERE Clause]</span><br></pre></td></tr></table></figure>
<p>从数据表fleets中删除编号id=1的记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete from fleets where id=1;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fleets;</span><br><span class="line">+----+-----------+</span><br><span class="line">| id | commander |</span><br><span class="line">+----+-----------+</span><br><span class="line">|  2 | soldier1  |</span><br><span class="line">|  3 | soldier2  |</span><br><span class="line">|  4 | soldier10 |</span><br><span class="line">|  5 | anakin    |</span><br><span class="line">|  6 | vader     |</span><br><span class="line">|  7 | vader     |</span><br><span class="line">|  8 | vader     |</span><br><span class="line">|  9 | vader     |</span><br><span class="line">| 10 | vader     |</span><br><span class="line">| 11 | vader     |</span><br><span class="line">| 12 | vader     |</span><br><span class="line">+----+-----------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>删除后打印数据表发现第一条记录的编号为2,表明id虽然自动增加,但是删除中间的某些记录后,后面的记录的id不会自动减小</p>
<p>如果不使用where子句则删除指定数据表中的所有记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete from fleets;</span><br><span class="line">Query OK, 11 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fleets;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="数据表模糊匹配操作">数据表模糊匹配操作</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN </span><br><span class="line">FROM table_name</span><br><span class="line">WHERE field1 LIKE condition1 [AND [OR]] filed2 = &#x27;somevalue&#x27;</span><br></pre></td></tr></table></figure>
<p>关键由LIKE子句实现,首先容易观察得到的是LIKE子句完全包含等号的作用</p>
<p>可以理解为:</p>
<p>从某数据表查询某键值==像==某个样子的记录</p>
<p>比如从动物园数据表中查询==狗样==的记录和从动物园查询所有==狗==的记录,前者为LIKE语句,后者为等号</p>
<p>比如现有数据表:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from fleets;</span><br><span class="line">+----+------------+</span><br><span class="line">| id | commander  |</span><br><span class="line">+----+------------+</span><br><span class="line">| 14 | soldier1   |</span><br><span class="line">| 15 | soldier2   |</span><br><span class="line">| 16 | soldier3   |</span><br><span class="line">| 17 | soldier20  |</span><br><span class="line">| 18 | soldier200 |</span><br><span class="line">| 19 | general    |</span><br><span class="line">| 20 | admiral    |</span><br><span class="line">| 21 | major      |</span><br><span class="line">+----+------------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在要查询所有commander为soldier==#==(这里#表示任意字符或者字符串)的记录,显然用等号的话只能用where和or进行枚举,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from fleets where commander=&#x27;soldier1&#x27; or commander=&#x27;soldier2&#x27; or commander=&#x27;soldier3&#x27;...</span><br></pre></td></tr></table></figure>
<p>可以翻译为:</p>
<p>从数据表fleets中查询所有指挥官为soldier1或者soldier2或者soldier3...的记录</p>
<p>但是用==like配合占位符%==进行模糊搜索</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from fleets where commander like &#x27;soldier%&#x27;;</span><br><span class="line">+----+------------+</span><br><span class="line">| id | commander  |</span><br><span class="line">+----+------------+</span><br><span class="line">| 14 | soldier1   |</span><br><span class="line">| 15 | soldier2   |</span><br><span class="line">| 16 | soldier3   |</span><br><span class="line">| 17 | soldier20  |</span><br><span class="line">| 18 | soldier200 |</span><br><span class="line">+----+------------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以翻译为:</p>
<p>从数据表fleets中查询所有指挥官为soldier后面加上一些东西(管他什么东西,甚至是没有东西)的记录</p>
<h2 id="数据表查找合并">数据表查找合并</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT expression1, expression2, ... expression_n</span><br><span class="line">FROM tables</span><br><span class="line">[WHERE conditions]</span><br><span class="line">UNION [ALL | DISTINCT]</span><br><span class="line">SELECT expression1, expression2, ... expression_n</span><br><span class="line">FROM tables</span><br><span class="line">[WHERE conditions];</span><br></pre></td></tr></table></figure>
<p>tables为数据表名</p>
<p>expression为要检索的列</p>
<p>distinct为去重合并,all为不去重合并</p>
<p>例如在empire数据库下有两个数据表:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from officers;</span><br><span class="line">+----+----------------+------------+</span><br><span class="line">| id | name           | title      |</span><br><span class="line">+----+----------------+------------+</span><br><span class="line">|  1 | Darth Vader    | executor   |</span><br><span class="line">|  2 | Darth Sidious  | emperor    |</span><br><span class="line">|  3 | Wilhuff Tarkin | Grand Moff |</span><br><span class="line">+----+----------------+------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select *from commanders;</span><br><span class="line">+----+---------------+---------+</span><br><span class="line">| id | name          | title   |</span><br><span class="line">+----+---------------+---------+</span><br><span class="line">|  1 | Rex           | captain |</span><br><span class="line">|  2 | Darth Vader   | general |</span><br><span class="line">|  3 | Darth Sidious | marshal |</span><br><span class="line">+----+---------------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1.现在统计所有政府官员和军队指挥官一共有多少人(考虑有些人可以集军政大权于一身,需要去重)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name from officers</span><br><span class="line">    -&gt; union </span><br><span class="line">    -&gt; select name from commanders;</span><br><span class="line">+----------------+</span><br><span class="line">| name           |</span><br><span class="line">+----------------+</span><br><span class="line">| Darth Vader    |</span><br><span class="line">| Darth Sidious  |</span><br><span class="line">| Wilhuff Tarkin |</span><br><span class="line">| Rex            |</span><br><span class="line">+----------------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.统计名叫Darth Vader的是否身兼数职</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from officers where name=&#x27;Darth Vader&#x27;</span><br><span class="line">    -&gt; union all</span><br><span class="line">    -&gt; select *from commanders where name=&#x27;Darth Vader&#x27;;</span><br><span class="line">+----+-------------+----------+</span><br><span class="line">| id | name        | title    |</span><br><span class="line">+----+-------------+----------+</span><br><span class="line">|  1 | Darth Vader | executor |</span><br><span class="line">|  2 | Darth Vader | general  |</span><br><span class="line">+----+-------------+----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.统计==肉眼可见的西斯==担任的职务:</p>
<p>肉眼可见的西斯即Darth开头</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from officers where name like &#x27;Darth%&#x27; </span><br><span class="line">    -&gt; union all</span><br><span class="line">    -&gt; select *from commanders where name like &#x27;Darth%&#x27;;</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">| id | name          | title    |</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">|  1 | Darth Vader   | executor |</span><br><span class="line">|  2 | Darth Sidious | emperor  |</span><br><span class="line">|  2 | Darth Vader   | general  |</span><br><span class="line">|  3 | Darth Sidious | marshal  |</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="排序">排序</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN FROM table_name1, table_name2...</span><br><span class="line">ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]]</span><br></pre></td></tr></table></figure>
<p>order
by语句中从前到后为关键字优先级,首先按照field1关键字的规则进行排序,然后field1关键字相同项再按照field2关键字进行排序,以此类推</p>
<p>ASC(ascend)升序,默认模式</p>
<p>DESC(descent)降序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from commanders order by id ASC;</span><br><span class="line">+----+---------------+---------+</span><br><span class="line">| id | name          | title   |</span><br><span class="line">+----+---------------+---------+</span><br><span class="line">|  1 | Rex           | captain |</span><br><span class="line">|  2 | Darth Vader   | general |</span><br><span class="line">|  3 | Darth Sidious | marshal |</span><br><span class="line">+----+---------------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select *from commanders order by id DESC;</span><br><span class="line">+----+---------------+---------+</span><br><span class="line">| id | name          | title   |</span><br><span class="line">+----+---------------+---------+</span><br><span class="line">|  3 | Darth Sidious | marshal |</span><br><span class="line">|  2 | Darth Vader   | general |</span><br><span class="line">|  1 | Rex           | captain |</span><br><span class="line">+----+---------------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="分组">分组</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name, function(column_name)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE column_name operator value</span><br><span class="line">GROUP BY column_name;</span><br></pre></td></tr></table></figure>
<p>从某个表中按照某些规则选取某些列,并且按照某列进行同名分组</p>
<p>现有数据库如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from </span><br><span class="line">    -&gt; popularity;</span><br><span class="line">+----+------+--------+</span><br><span class="line">| id | name | gender |</span><br><span class="line">+----+------+--------+</span><br><span class="line">|  1 | Tom  | male   |</span><br><span class="line">|  2 | Tom  | male   |</span><br><span class="line">|  3 | Tom  | male   |</span><br><span class="line">|  4 | Jack | male   |</span><br><span class="line">|  5 | Jon  | famal  |</span><br><span class="line">|  6 | Mike | male   |</span><br><span class="line">+----+------+--------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要调查人口统计表中人重名的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,count(*) from popularity group by name;</span><br><span class="line">+------+----------+</span><br><span class="line">| name | count(*) |</span><br><span class="line">+------+----------+</span><br><span class="line">| Tom  |        3 |</span><br><span class="line">| Jack |        1 |</span><br><span class="line">| Jon  |        1 |</span><br><span class="line">| Mike |        1 |</span><br><span class="line">+------+----------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="with-rollup">WITH ROLLUP</h3>
<p>现有彩票获奖名单如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from Winners;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | prize |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | Mike |    20 |</span><br><span class="line">|  2 | Mike |    30 |</span><br><span class="line">|  3 | Mike |    10 |</span><br><span class="line">|  4 | Mike |    15 |</span><br><span class="line">|  5 | Jack |    15 |</span><br><span class="line">|  6 | Jack |    18 |</span><br><span class="line">|  7 | John |    18 |</span><br><span class="line">|  8 | Jack |    19 |</span><br><span class="line">|  9 | Mike |     5 |</span><br><span class="line">+----+------+-------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1.查看每个人一共获奖多少次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,count(*) from Winners group by name;</span><br><span class="line">+------+----------+</span><br><span class="line">| name | count(*) |</span><br><span class="line">+------+----------+</span><br><span class="line">| Mike |        5 |</span><br><span class="line">| Jack |        3 |</span><br><span class="line">| John |        1 |</span><br><span class="line">+------+----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>2.查看每个人一共获奖多少钱</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,SUM(prize) as tot_prize from Winners group by name with rollup;</span><br><span class="line">+------+-----------+</span><br><span class="line">| name | tot_prize |</span><br><span class="line">+------+-----------+</span><br><span class="line">| Jack |        52 |</span><br><span class="line">| John |        18 |</span><br><span class="line">| Mike |        80 |</span><br><span class="line">| NULL |       150 |</span><br><span class="line">+------+-----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>其中SUM()为累加函数,类似的有AVG()平均数函数,COUNT()等</p>
<p>NULL为总计,即三个获奖者奖金总和</p>
<p>如果想让结果显示"prize_sum"字样而不是NULL则可以用select
coalesce(...)函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select coalesce(a,b,c);</span><br></pre></td></tr></table></figure>
<p>如果a=NULL则选择b,如果a,b=NULL则选择c,全空则为NULL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select coalesce(name,&#x27;sum_prize&#x27;),SUM(prize) as tot_prize from Winners group by name with rollup;</span><br><span class="line">+----------------------------+-----------+</span><br><span class="line">| coalesce(name,&#x27;sum_prize&#x27;) | tot_prize |</span><br><span class="line">+----------------------------+-----------+</span><br><span class="line">| Jack                       |        52 |</span><br><span class="line">| John                       |        18 |</span><br><span class="line">| Mike                       |        80 |</span><br><span class="line">| sum_prize                  |       150 |</span><br><span class="line">+----------------------------+-----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="连接">连接</h2>
<h3 id="inner-join">INNER JOIN</h3>
<figure>
<img
src="https://www.runoob.com/wp-content/uploads/2014/03/img_innerjoin.gif"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>==等值连接==,获取两张表中匹配的记录</p>
<p>现有帝国政府官员和军队指挥官的数据表如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from officers;</span><br><span class="line">+----+---------+-----------+</span><br><span class="line">| id | name    | title     |</span><br><span class="line">+----+---------+-----------+</span><br><span class="line">|  1 | Mike    | Mayor     |</span><br><span class="line">|  2 | Jack    | executor  |</span><br><span class="line">|  3 | Jackson | candidate |</span><br><span class="line">|  4 | John    | emperor   |</span><br><span class="line">|  5 | Tom     | minister  |</span><br><span class="line">+----+---------+-----------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from commanders;</span><br><span class="line">+----+-------+---------------+</span><br><span class="line">| id | name  | military_rank |</span><br><span class="line">+----+-------+---------------+</span><br><span class="line">|  1 | Vader | general       |</span><br><span class="line">|  2 | Rex   | captain       |</span><br><span class="line">|  3 | John  | marshal       |</span><br><span class="line">+----+-------+---------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在John皇帝不希望军队和政治耦合,希望调查有没有在军政上同时身居要职的大官,</p>
<p>即统计其中身兼数职(比如John既是帝国皇帝又是军队元帅)的人</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select a.name,a.title,b.military_rank from officers a inner join commanders b on a.name=b.name;</span><br><span class="line">+------+---------+---------------+</span><br><span class="line">| name | title   | military_rank |</span><br><span class="line">+------+---------+---------------+</span><br><span class="line">| John | emperor | marshal       |</span><br><span class="line">+------+---------+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>其中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select a.name,a.title,b.military_rank from officers a inner join commanders b on a.name=b.name;</span><br></pre></td></tr></table></figure>
<p>可以翻译为:</p>
<p>保留a表的name和title列,保留b表的military_rank列,</p>
<p>a表即officers表,b表即commanders表,</p>
<p>两表根据name列等值连接</p>
<p>调查完后John皇帝很开心</p>
<h3 id="left-join">LEFT JOIN</h3>
<p>左合并会保留左侧表的全部数据,不管右侧表有无匹配数据</p>
<figure>
<img
src="https://www.runoob.com/wp-content/uploads/2014/03/img_leftjoin.gif"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select a.name,a.title,b.military_rank from officers a left join commanders b on a.name=b.name;</span><br><span class="line">+---------+-----------+---------------+</span><br><span class="line">| name    | title     | military_rank |</span><br><span class="line">+---------+-----------+---------------+</span><br><span class="line">| Mike    | Mayor     | NULL          |</span><br><span class="line">| Jack    | executor  | NULL          |</span><br><span class="line">| Jackson | candidate | NULL          |</span><br><span class="line">| John    | emperor   | marshel       |</span><br><span class="line">| Tom     | minister  | NULL          |</span><br><span class="line">+---------+-----------+---------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以翻译为:</p>
<p>政府官员先都列在表里,然后军队指挥官如果有人也是政府官员则把其军衔也写在表里,否则写NULL</p>
<h3 id="right-join">RIGHT JOIN</h3>
<p>类比左合并,保留右侧表的全部数据,不管左侧表有无匹配数据</p>
<h2 id="null值处理">NULL值处理</h2>
<blockquote>
<p>null值与任何值的任何比较都是null</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from officers;</span><br><span class="line">+----+---------+-----------+</span><br><span class="line">| id | name    | title     |</span><br><span class="line">+----+---------+-----------+</span><br><span class="line">|  1 | Mike    | Mayor     |</span><br><span class="line">|  2 | Jack    | executor  |</span><br><span class="line">|  3 | Jackson | candidate |</span><br><span class="line">|  4 | John    | emperor   |</span><br><span class="line">|  5 | Tom     | minister  |</span><br><span class="line">+----+---------+-----------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from officers where null=null or null &gt;null or null&lt;null;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="判断null">判断NULL</h3>
<p>IS NULL,IS NOT NULL,&lt;=&gt;三种方法</p>
<p>现有数据表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from officers;</span><br><span class="line">+----+------+---------+</span><br><span class="line">| id | name | post    |</span><br><span class="line">+----+------+---------+</span><br><span class="line">|  1 | John | Mayor   |</span><br><span class="line">|  2 | Mike | NULL    |</span><br><span class="line">|  3 | Jack | NULL    |</span><br><span class="line">|  4 | Tom  | emperor |</span><br><span class="line">+----+------+---------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from officers where post is not null;</span><br><span class="line">+----+------+---------+</span><br><span class="line">| id | name | post    |</span><br><span class="line">+----+------+---------+</span><br><span class="line">|  1 | John | Mayor   |</span><br><span class="line">|  4 | Tom  | emperor |</span><br><span class="line">+----+------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from officers where post is null;</span><br><span class="line">+----+------+------+</span><br><span class="line">| id | name | post |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  2 | Mike | NULL |</span><br><span class="line">|  3 | Jack | NULL |</span><br><span class="line">+----+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from officers where post &lt;=&gt; null;</span><br><span class="line">+----+------+------+</span><br><span class="line">| id | name | post |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  2 | Mike | NULL |</span><br><span class="line">|  3 | Jack | NULL |</span><br><span class="line">+----+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="替换null">替换NULL</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifnull(a,b)</span><br></pre></td></tr></table></figure>
<p>如果a为NULL则返回b的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from officers where ifnull(post,&#x27;&#x27;)=&#x27;&#x27;;</span><br><span class="line">+----+------+------+</span><br><span class="line">| id | name | post |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  2 | Mike | NULL |</span><br><span class="line">|  3 | Jack | NULL |</span><br><span class="line">+----+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>一般用于int值替换成0参与计算</p>
<h2 id="正则">正则</h2>
<p>在where子句中使用正则表达式,类似于等号和LIKE语句:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where 键值 REGEXP &lt;pattern&gt;</span><br></pre></td></tr></table></figure>
<p>现有数据表如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from officers;</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">| id | name          | post     |</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">|  1 | John          | Mayor    |</span><br><span class="line">|  2 | Mike          | NULL     |</span><br><span class="line">|  3 | Jack          | NULL     |</span><br><span class="line">|  5 | Darth Vader   | executor |</span><br><span class="line">|  6 | Darth Sidious | emperor  |</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>要查询政府官员中肉眼可见的西斯</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from officers where name regexp &#x27;^Darth&#x27;;</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">| id | name          | post     |</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">|  5 | Darth Vader   | executor |</span><br><span class="line">|  6 | Darth Sidious | emperor  |</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>MySQL正则表达式规则与javaScript等脚本语言中的正则表达式规则相同</p>
<h2 id="事务">事务</h2>
<h3 id="意义">意义</h3>
<p>事务这种东西的存在我的理解是:</p>
<p>使用命令行操作数据库,很难保证输入没有拼写错误或者语法错误.</p>
<p>比如某个人口统计数据库里有一张基本统计表,一张学历统计表,一张收入统计表.</p>
<p>现在张三寿终正寝over了,需要在这三张表中都删除张三的记录.</p>
<p>如果没有事务,我们需要分别在三张表上各执行一次删除操作,如果在第二张表上删除时写成了张四那么张四就可能无缘无故地在某表上去世了,但是该走的张三没走.</p>
<p>更进一步,如果一口气要删除近一个月的死亡人口,需要输入多个名字,很难保证在三张表上准确地删除这些人名</p>
<p>这时引入事务,即规定一个事务开始,然后写入想要执行的命令,然后规定事务结束,此时确认事务内输入无误后再命令事务执行,可以有效减少错误.</p>
<p>如果肉眼没有检查出事务输入的错误,事务自动报错,并且从事务开始到错误的命令都会当作没有执行过</p>
<blockquote>
<ul>
<li>事务的好处用科学的语言表达为:</li>
<li><strong>原子性：</strong>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li><strong>一致性：</strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>
<li><strong>隔离性：</strong>数据库允许多个==并发==事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read
uncommitted）、读提交（read committed）、可重复读（repeatable
read）和串行化（Serializable）。</li>
<li><strong>持久性：</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
</blockquote>
<h3 id="控制语句">控制语句</h3>
<blockquote>
<ul>
<li><p>BEGIN 或 START TRANSACTION 显式地开启一个事务；</p></li>
<li><p>COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT
会提交事务，并使已对数据库进行的所有修改成为永久性的；</p></li>
<li><p>ROLLBACK 也可以使用 ROLLBACK
WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</p>
<blockquote>
<p>写着写着发现前面已经有语法错误或者达不到目的甚至偏离目的的语句时,使用回滚,如果运气好设置了savepoint就不至于回滚到从头开始</p>
</blockquote></li>
<li><p>SAVEPOINT identifier，SAVEPOINT
允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；</p>
<blockquote>
<p>可以理解为游戏的复活点(undertale里复活点好像就叫savepoint),从该复活点之后死亡可以回到该复活点,在MySQL中从某个savepoint之后出现错误可以回到该savepoint避免错误</p>
</blockquote></li>
<li><p>RELEASE SAVEPOINT identifier
删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</p></li>
<li><p>ROLLBACK TO identifier 把事务回滚到标记点；</p></li>
<li><p>SET TRANSACTION 用来设置事务的隔离级别。InnoDB
存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE
READ 和 SERIALIZABLE。</p></li>
</ul>
</blockquote>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from officers;</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">| id | name          | post     |</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">|  1 | John          | Mayor    |</span><br><span class="line">|  3 | Jack          | NULL     |</span><br><span class="line">|  5 | Darth Vader   | executor |</span><br><span class="line">|  6 | Darth Sidious | emperor  |</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delete from officers where name=&#x27;Jack&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; savepoint point1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delete from officers where name=&#x27;John&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback to point1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from officers;</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">| id | name          | post     |</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">|  1 | John          | Mayor    |</span><br><span class="line">|  5 | Darth Vader   | executor |</span><br><span class="line">|  6 | Darth Sidious | emperor  |</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第12行事务开始</span><br><span class="line">	第15行删除,删除名叫Jack的记录</span><br><span class="line">	第18行存档,存档名叫point1</span><br><span class="line">	第21行删除,删除名叫John的记录</span><br><span class="line">	第24行回滚,回滚到point1,刚才从point1到第24行之间输入的东西都不算数</span><br><span class="line">第27行提交事务</span><br></pre></td></tr></table></figure>
<p>实际执行了只有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete from officers where name=&#x27;Jack&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="alter修改表字段">ALTER修改表字段</h2>
<p>在学到这里之前,建表都是使用create命令,规定好列的各种属性以及有多少列,此后就只能对记录进行增删改查的操作了,但是如果想增删字段或者设置字段属性,除了drop了这个表然后新建表,没有其他方法.</p>
<p>现在有了ALTER方法修改字段</p>
<h3 id="修改表名">修改表名</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;old tablename&gt; RENAME TO &lt;new tablename&gt;;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> officers rename <span class="keyword">to</span> government_officers;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="查看表字段show-columns">查看表字段SHOW COLUMNS</h3>
<p>数据表字段及属性由show columns方法可以查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use empire;</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; show columns from officers;</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| id    | int         | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name  | varchar(20) | NO   |     | NULL    |                |</span><br><span class="line">| post  | varchar(20) | YES  |     | NULL    |                |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">3 rows in set (0.02 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>即officers数据表有三个字段,分别为id,name,post,其类型,是否可以为空,是否为主键,默认值,额外属性业已给出</p>
<h3 id="新增add">新增ADD</h3>
<p>现在希望增加一个军衔字段.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table officers add military_rank varchar(10) not null default &#x27;soldier&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; show columns from officers;</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field         | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">| id            | int         | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name          | varchar(20) | NO   |     | NULL    |                |</span><br><span class="line">| post          | varchar(20) | YES  |     | NULL    |                |</span><br><span class="line">| military_rank | varchar(10) | NO   |     | soldier |                |</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table officers add military_rank varchar(10) not null default &#x27;soldier&#x27;;</span><br></pre></td></tr></table></figure>
<p>可以翻译为:</p>
<p>改变officers这张表的字段值,新增一个military_rank字段,其类型为varchar,最长10个字符,不能为空,缺省值为'soldier';</p>
<p>现在希望在name后面,post前面新增一个字段salary,表示官员薪水,可以使用AFTER命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table officers add salary int(10) not null default 3000 after name;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.04 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 1</span><br><span class="line"></span><br><span class="line">mysql&gt; show columns from officers;</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field         | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">| id            | int         | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name          | varchar(20) | NO   |     | NULL    |                |</span><br><span class="line">| salary        | int         | NO   |     | 3000    |                |</span><br><span class="line">| post          | varchar(20) | YES  |     | NULL    |                |</span><br><span class="line">| military_rank | varchar(10) | NO   |     | soldier |                |</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="删除字段drop">删除字段DROP</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;tablename&gt; DROP &lt;key&gt;;</span><br></pre></td></tr></table></figure>
<p>现在希望删除salary字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table officers drop salary;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; show columns from officers;</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field         | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">| id            | int         | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name          | varchar(20) | NO   |     | NULL    |                |</span><br><span class="line">| post          | varchar(20) | YES  |     | NULL    |                |</span><br><span class="line">| military_rank | varchar(10) | NO   |     | soldier |                |</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="只修改字段属性modify">只修改字段属性MODIFY</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table officers modify post varchar(10);</span><br><span class="line">Query OK, 2 rows affected (0.03 sec)</span><br><span class="line">Records: 2  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>
<h3 id="修改字段名及属性change">修改字段名及属性CHANGE</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;tablename&gt; MODIFY &lt;old key&gt; &lt;new key&gt; &lt;type&gt; ...</span><br></pre></td></tr></table></figure>
<p>现在希望修改post字段为position</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table officers change post position varchar(10);</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; show columns from officers;</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field         | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">| id            | int         | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name          | varchar(20) | NO   |     | NULL    |                |</span><br><span class="line">| position      | varchar(10) | YES  |     | NULL    |                |</span><br><span class="line">| military_rank | varchar(10) | NO   |     | soldier |                |</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要注意的是,即使只想修改字段名,不改变字段类型等属性,也需要在change语句的新字段后面重写一遍属性</p>
<p>change子句只写旧新字段名会报错:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table officers change post position;</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;&#x27; at line 1</span><br></pre></td></tr></table></figure>
<h3 id="修改字段默认值">修改字段默认值</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;tablename&gt; ALTER &lt;key&gt; SET &lt;属性&gt; &lt;新属性值&gt;</span><br></pre></td></tr></table></figure>
<p>比如希望修改官员的默认职位为'大臣'</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table officers alter position set default &#x27;minister&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; show columns from officers;</span><br><span class="line">+---------------+-------------+------+-----+----------+----------------+</span><br><span class="line">| Field         | Type        | Null | Key | Default  | Extra          |</span><br><span class="line">+---------------+-------------+------+-----+----------+----------------+</span><br><span class="line">| id            | int         | NO   | PRI | NULL     | auto_increment |</span><br><span class="line">| name          | varchar(20) | NO   |     | NULL     |                |</span><br><span class="line">| position      | varchar(10) | YES  |     | minister |                |</span><br><span class="line">| military_rank | varchar(10) | NO   |     | soldier  |                |</span><br><span class="line">+---------------+-------------+------+-----+----------+----------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="修改约束">修改约束</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> UserId</span><br><span class="line">　　<span class="keyword">add</span> <span class="keyword">constraint</span> PK_UserId <span class="keyword">primary</span> key (UserId)</span><br></pre></td></tr></table></figure>
<h2 id="索引">索引</h2>
<p>普通索引没有任何限制,唯一索引要求==建立索引的列==没有重复数据</p>
<h3 id="显示索引">显示索引</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM &lt;tablename&gt;;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://gitee.com/deutschball/imperial-march/raw/master/index.png"
alt="index" />
<figcaption aria-hidden="true">index</figcaption>
</figure>
<h3 id="普通索引">普通索引</h3>
<p>建立普通索引的方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.CREATE INDEX &lt;indexname&gt; ON &lt;tablename&gt;(columnname);</span><br><span class="line">2.ALTER TABLE &lt;tablename&gt; ADD INDEX &lt;indexname&gt;(columnname);</span><br><span class="line">3.建表时指定</span><br><span class="line">mysql&gt; create table testIndex(</span><br><span class="line">    -&gt; id int not null,</span><br><span class="line">    -&gt; name varchar(20)not null,</span><br><span class="line">    -&gt; index myindex(name)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure>
<p>删除索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX &lt;indexname&gt; ON &lt;tablename&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; drop index myindex on testIndex;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>
<h3 id="唯一索引">唯一索引</h3>
<p>建立唯一索引的列不允许有重复数据</p>
<p>建立索引的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.CREATE UNIQUE INDEX &lt;indexname&gt; ON &lt;tablename&gt;(columnname);</span><br><span class="line">2.ALTER TABLEL &lt;tablename&gt; ADD UNIQUE &lt;indexname&gt;(columnname);</span><br><span class="line">3.建表时指定</span><br><span class="line">mysql&gt; create table mytable(</span><br><span class="line">    -&gt; id int(10)not null,</span><br><span class="line">    -&gt; name varchar(20)not null,</span><br><span class="line">    -&gt; unique myindex(name)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create unique index myindex on mytable(id);</span><br><span class="line">ERROR 1146 (42S02): Table &#x27;empire.mytable&#x27; doesn&#x27;t exist</span><br><span class="line">mysql&gt; create unique index myindex on testIndex(id);</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table testIndex add unique myindex2(name);</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意指定length长度</p>
<h2 id="表克隆">表克隆</h2>
<h3 id="假克隆">"假"克隆</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE &lt;tablename&gt;;</span><br></pre></td></tr></table></figure>
<p>该条指令的作用是显示创建当前表时的创建语句.那么使用相同的语句,稍微改动一下表名称就可以"克隆"一个新表了</p>
<p>但是命令行对与复制粘贴不友好,只能是对着给出的建表语句敲代码,显然这种方法不可取</p>
<h3 id="真克隆">"真"克隆</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &lt;target_table_name&gt; LIKE &lt;source_table_name&gt;;//克隆表结构</span><br><span class="line">INSERT INTO &lt;target_table_name&gt; SELECT * FROM &lt;source_table_name&gt;;//克隆表数据</span><br><span class="line">CREATE TABLE &lt;target_table_name&gt; SELECT * FROM &lt;source_table_name&gt;;//一步到位</span><br><span class="line">CREATE TABLE &lt;target_table_name&gt; SELECT * FROM &lt;source_table_name&gt; where 1=2;//克隆表结构</span><br></pre></td></tr></table></figure>
<p>现有数据表officers:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show columns from officers;</span><br><span class="line">+---------------+-------------+------+-----+----------+----------------+</span><br><span class="line">| Field         | Type        | Null | Key | Default  | Extra          |</span><br><span class="line">+---------------+-------------+------+-----+----------+----------------+</span><br><span class="line">| id            | int         | NO   | PRI | NULL     | auto_increment |</span><br><span class="line">| name          | varchar(20) | NO   |     | NULL     |                |</span><br><span class="line">| position      | varchar(10) | YES  | MUL | minister |                |</span><br><span class="line">| military_rank | varchar(10) | NO   | MUL | soldier  |                |</span><br><span class="line">+---------------+-------------+------+-----+----------+----------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from officers;</span><br><span class="line">+----+---------------+----------+---------------+</span><br><span class="line">| id | name          | position | military_rank |</span><br><span class="line">+----+---------------+----------+---------------+</span><br><span class="line">|  5 | Darth Vader   | executor | soldier       |</span><br><span class="line">|  6 | Darth Sidious | emperor  | soldier       |</span><br><span class="line">+----+---------------+----------+---------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>希望克隆一张新表newOfficers,其结构和内容与officers完全相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table newOfficers like officers;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show columns from newOfficers;</span><br><span class="line">+---------------+-------------+------+-----+----------+----------------+</span><br><span class="line">| Field         | Type        | Null | Key | Default  | Extra          |</span><br><span class="line">+---------------+-------------+------+-----+----------+----------------+</span><br><span class="line">| id            | int         | NO   | PRI | NULL     | auto_increment |</span><br><span class="line">| name          | varchar(20) | NO   |     | NULL     |                |</span><br><span class="line">| position      | varchar(10) | YES  | MUL | minister |                |</span><br><span class="line">| military_rank | varchar(10) | NO   | MUL | soldier  |                |</span><br><span class="line">+---------------+-------------+------+-----+----------+----------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from newOfficers;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过<code>show columns</code>和<code>select *</code>两个命令可以观察得到,新表目前只是克隆了结构,但是内容没有克隆</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into newOfficers select * from officers;</span><br><span class="line">Query OK, 2 rows affected (0.01 sec)</span><br><span class="line">Records: 2  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from officers;</span><br><span class="line">+----+---------------+----------+---------------+</span><br><span class="line">| id | name          | position | military_rank |</span><br><span class="line">+----+---------------+----------+---------------+</span><br><span class="line">|  5 | Darth Vader   | executor | soldier       |</span><br><span class="line">|  6 | Darth Sidious | emperor  | soldier       |</span><br><span class="line">+----+---------------+----------+---------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行了<code>mysql&gt; insert into newOfficers select * from officers;</code>之后才完成了内容的复制</p>
<p>一步到位:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table newtable select * from officers;</span><br><span class="line">Query OK, 2 rows affected (0.02 sec)</span><br><span class="line">Records: 2  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select *from newtable;</span><br><span class="line">+----+---------------+----------+---------------+</span><br><span class="line">| id | name          | position | military_rank |</span><br><span class="line">+----+---------------+----------+---------------+</span><br><span class="line">|  5 | Darth Vader   | executor | soldier       |</span><br><span class="line">|  6 | Darth Sidious | emperor  | soldier       |</span><br><span class="line">+----+---------------+----------+---------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/impossible/page/9/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/impossible/">1</a><span class="space">&hellip;</span><a class="page-number" href="/impossible/page/9/">9</a><span class="page-number current">10</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
