<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="dustland">
<meta property="og:type" content="website">
<meta property="og:title" content="dustland">
<meta property="og:url" content="http://deutschball.github.io/impossible/page/3/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="dustland">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="dustball">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://deutschball.github.io/impossible/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/10/26/malloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/26/malloc/" class="post-title-link" itemprop="url">glibc2.23 Ptmalloc2 源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-10-26 22:03:00 / Modified: 22:04:01" itemprop="dateCreated datePublished" datetime="2023-10-26T22:03:00+08:00">2023-10-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="dive-into-ptmalloc2">Dive Into Ptmalloc2</h1>
<p><del>基于glibc2.23的ptmalloc2源码分析</del></p>
<h2 id="datastructure">datastructure</h2>
<h3 id="malloc_chunk">malloc_chunk</h3>
<p>堆空间管理的最小单元</p>
<p>每个堆块由元数据和数据两部分组成</p>
<p>元数据记录了该堆块的物理前块大小,本块大小,分配区,前块使用,是否<code>mmap</code>块状态,以及空闲状态下的前驱后继指针</p>
<p>数据就是返回给用户的可用空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="字段意义">字段意义</h4>
<h5 id="prev_size">prev_size</h5>
<p>如果物理上紧挨着的一个<code>chunk</code>空闲的话,则该值为物理上前面紧挨着的那个<code>chunk</code>的大小.</p>
<p>如果物理上紧挨着的一个<code>chunk</code>占用的话,则该值可以被物理上紧挨着的那个<code>chunk</code>使用(空间复用)</p>
<h5 id="size">size</h5>
<p>本chunk的大小,包括chunk头和<code>chunk</code>数据</p>
<blockquote>
<p>其中chunk头就是<code>malloc_chunk</code>结构体,chunk数据就是返回给用户使用的内存空间</p>
</blockquote>
<p>每个<code>chunk</code>的大小都必须是<code>2*SIZE_SZ</code>整数倍</p>
<p>32位系统中size_sz=4,64位系统中size_sz=8</p>
<p>因此32位系统上chunk大小是8的倍数,64位上chunk是16的倍数</p>
<p>诚如是,则size的低3位永远用不到,为了节省空间,ptmalloc的实现中,这三个低位表示三个符号A,M,P</p>
<h5 id="fdbk">fd,bk</h5>
<p>当本chunk空闲并且挂在bin上,此时fd,bk分别是前向和后向chunk的指针,相当于双向链表.</p>
<p>注意是逻辑上相邻,也就是链表相连,不是物理上相邻</p>
<h5 id="fd_nextsizebk_nextsize">fd_nextsize,bk_nextsize</h5>
<p>当chunk空闲并且挂在large bin中时,用于查找最近匹配的空闲chunk</p>
<p>怎么个用法呢?</p>
<p>large
bin中挂着的chunk是按照大小排序的,一个chunk逻辑上相连的chunk可能大小相同,也可能不同,fd_nextsize,bk_nextsize就指向第一个<strong>大小不同</strong>的chunk</p>
<p>这样说比较抽象,具体见后面的largebin结构</p>
<h4 id="空间复用">空间复用</h4>
<h5 id="分配时状态">分配时状态</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, <span class="keyword">if</span> <span class="title function_">unallocated</span> <span class="params">(P clear)</span>  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             <span class="params">(malloc_usable_size() bytes)</span>                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             <span class="params">(size of chunk, but used <span class="keyword">for</span> application data)</span>    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<h5 id="空闲时状态">空闲时状态</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">      |             Size of previous chunk                            |</span><br><span class="line">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    `head:<span class="string">&#x27; |             Size of chunk, in bytes                         |P|</span></span><br><span class="line"><span class="string">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">      |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="string">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">      |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="string">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">      |             Unused space (may be 0 bytes long)                .</span></span><br><span class="line"><span class="string">      .                                                               .</span></span><br><span class="line"><span class="string">      .                                                               |</span></span><br><span class="line"><span class="string">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">    `foot:&#x27;</span> |             Size of chunk, in bytes                           |</span><br><span class="line">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<h4 id="宏定义">宏定义</h4>
<h5 id="指针转换">指针转换</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)((char *) (mem) -2 * SIZE_SZ))</span></span><br></pre></td></tr></table></figure>
<p>mem就是数据区,chunk就是malloc_chunk的基地址,两者的关系在图上表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, <span class="keyword">if</span> <span class="title function_">unallocated</span> <span class="params">(P clear)</span>  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             <span class="params">(malloc_usable_size() bytes)</span>                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             <span class="params">(size of chunk, but used <span class="keyword">for</span> application data)</span>    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>显然mem网上数两个成员就是chunk,这两个成员都是INTERNAL_SIZE_T类型的,在32位平台上分别长4字节,在64位平台上分别长8字节</p>
<h5 id="最小chunk大小">最小chunk大小</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br></pre></td></tr></table></figure>
<p><code>offsetof(struct,struct.member);</code>作用是计算member成员在其所在的结构体struct中的偏移量</p>
<p>这表明最小的chunk至少要包含前四个成员,prev_size,size,fd,bk,后面两个可以没有</p>
<h5 id="最小申请的堆内存大小">最小申请的堆内存大小</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE                                                                \</span></span><br><span class="line"><span class="meta">    (unsigned long) (((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp;                   \</span></span><br><span class="line"><span class="meta">                      ~MALLOC_ALIGN_MASK))</span></span><br></pre></td></tr></table></figure>
<h5 id="检查对齐">检查对齐</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"><span class="comment">// MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> misaligned_chunk(p)                                                    \</span></span><br><span class="line"><span class="meta">    ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \</span></span><br><span class="line"><span class="meta">     MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure>
<h5 id="判断用户请求是否离谱">判断用户请求是否离谱</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br></pre></td></tr></table></figure>
<h5 id="规范化请求大小">规范化请求大小</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \<span class="comment">//如果用户请求的太小则直接用MINSIZE</span></span></span><br><span class="line">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)<span class="comment">//否则向上取整到满足对齐要求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span></span><br><span class="line"><span class="meta">        __set_errno(ENOMEM);                                                   \</span></span><br><span class="line"><span class="meta">        return 0;                                                              \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">    (sz) = request2size(req);</span></span><br></pre></td></tr></table></figure>
<h5 id="设置size最低三位标志位">设置size最低三位标志位</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_inuse(p) ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for chunk from main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark a chunk as not being on the main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">   macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">   cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">   people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure>
<h5 id="获取本chunk-size">获取本chunk size</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure>
<p>如果想要获得纯真的size,最低三位应该忽略标志位的影响,因此chunksize中用SIZE_BITS取反得到第三位全是0然后按位与,确保获得的size低三位必为0</p>
<p>而chunksize_nomask就没有忽略,相当于直接区的malloc_struct的第二个成员</p>
<h5 id="使用状态">使用状态</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)                                                               \</span></span><br><span class="line"><span class="meta">    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse(p)                                                           \</span></span><br><span class="line"><span class="meta">    ((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size |= PREV_INUSE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse(p)                                                         \</span></span><br><span class="line"><span class="meta">    ((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span></span><br></pre></td></tr></table></figure>
<h5 id="size大小">size大小</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="comment">// SIZE_BITS = 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head_size(p, s)                                                    \</span></span><br><span class="line"><span class="meta">    ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s) ((p)-&gt;mchunk_size = (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_foot(p, s)                                                         \</span></span><br><span class="line"><span class="meta">    (((mchunkptr)((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span></span><br></pre></td></tr></table></figure>
<p>这里set_foot干了啥?</p>
<p>p是chunk指针,s是该chunk的大小,p+s就指向了本chunk的结尾,</p>
<p>也就是下一个chunk的基地址,也就是下一个chunk的prev_size成员,</p>
<p>于是p+s强转为一个malloc_chunk类型指针,</p>
<p>然后取其第一个成员也就是prev_size,写上本chunk的大小</p>
<h5 id="指定偏移处认为是一个chunk">指定偏移处认为是一个chunk</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure>
<p>p指针加上s偏移量的地址视为一个chunk的基地址,返回一个malloc_chunk*指针</p>
<h3 id="malloc_state">malloc_state</h3>
<p>分配区结构,一个进程只能有一个主分配区,可以可以有多个非主分配区</p>
<p>当某个线程试图用<code>malloc</code>动态申请内存时,会首先对一个分配区上锁,如果主分配区忙则沿着<code>malloc_state-&gt;next</code>寻找下一个分配区,直到找到一个闲的分配区上锁使用.如果转一圈没发现闲的分配区则创建新的非主分配区,然后将其加入到这个分配区环状链表中上锁使用.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;<span class="comment">//互斥锁,保证临界区只有一个线程访问</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr      fastbins[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr        top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr        last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr        bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>     binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中管理堆块的手段有fastbin,topchunk,unsortedbin,smallbins,largebins这么几种</p>
<p>只考虑单线程的情况,也就是说不会产生非主分配区,只使用主分配区</p>
<p>最初只有很大一块topchunk,刚开始的malloc申请都是直接在malloc上切割使用</p>
<p>free释放时,如果对应堆块落在fastbin范围内则放到fastbin对应的链表中</p>
<p>否则一律放到unsortedbin中,等后面再次malloc时切割或者合并或者分拣</p>
<h4 id="fastbins">fastbins</h4>
<p>只会使用fd指针的单向链表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">A[&quot;fastbin[x]&quot;]</span><br><span class="line">A--fd--&gt;a--fd--&gt;b--fd--&gt;c</span><br></pre></td></tr></table></figure>
<h5 id="max_fast">max_fast</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_max_fast(s) \</span></span><br><span class="line"><span class="meta">  global_max_fast = (((s) == 0)						      \</span></span><br><span class="line"><span class="meta">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_max_fast() global_max_fast</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> INTERNAL_SIZE_T global_max_fast;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ &lt; __alignof__ (long double)      \</span></span><br><span class="line"><span class="meta">                                  ? __alignof__ (long double) : 2 *SIZE_SZ)</span></span><br></pre></td></tr></table></figure>
<p>对于x64平台,SIZE_SZ=8,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MALLOC_ALIGNMENT=2*SIZE_SZ=16=0b 10000</span><br><span class="line">MALLOC_ALIGN_MASK=15=0b 1111</span><br><span class="line"> ~MALLOC_ALIGN_MASK=111...111 0000</span><br></pre></td></tr></table></figure>
<p>这个<code>global_max_fast</code>在<code>malloc_init_state</code>时期被初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (av == &amp;main_arena)</span><br><span class="line">  set_max_fast (DEFAULT_MXFAST);</span><br><span class="line">  </span><br><span class="line">#define DEFAULT_MXFAST     (64 * SIZE_SZ / 4)</span><br></pre></td></tr></table></figure>
<p>对于<code>x64</code>平台,<code>SIZE_SZ=8</code>,那么<code>DEFAULT_MXFAST=128</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_max_fast(128):</span><br><span class="line">	  global_max_fast = ((128 + 8) &amp; 111...111 0000))</span><br><span class="line">	  =0b10001000&amp;0b111...111 0000</span><br><span class="line">	  =0b10000000</span><br><span class="line">	  =128</span><br></pre></td></tr></table></figure>
<p>也就是说,<code>nb&lt;=128</code>才可能在fastbin中取堆块</p>
<h5 id="fastbin_index">fastbin_index</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz)  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br></pre></td></tr></table></figure>
<p>在x64平台上,<code>SIZE_SZ=8</code>,而在x86平台上<code>SIZE_SZ=4</code></p>
<p>如果在x64平台上,则将sz右移4位,相当于除以16,然后-2,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastbin_index(sz)</span><br><span class="line">	=sz &gt;&gt; 4 - 2</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>sz</th>
<th>fastbin_index(sz) on x64</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[0b100000,0b110000)=[32,48)</code></td>
<td>0</td>
</tr>
<tr>
<td><code>[0b110000,0b1000000)=[48,64)</code></td>
<td>1</td>
</tr>
<tr>
<td><code>[0b1000000,0b1010000)=[64,80)</code></td>
<td>2</td>
</tr>
</tbody>
</table>
<p>比如用户期望分配0x10大小的空间,那么实际上的堆块大小是32字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastbin_index(0b100000)</span><br><span class="line">	=0b100000&gt;&gt;4 -2</span><br><span class="line">	=0b10-2</span><br><span class="line">	=0</span><br></pre></td></tr></table></figure>
<h5 id="fastbinidx">fastbin[idx]</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>fastbins结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct malloc_chunk *mfastbinptr;</span><br><span class="line">...</span><br><span class="line">struct malloc_state&#123;</span><br><span class="line">	...</span><br><span class="line">mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fastbins是一个链栈,先释放的堆块也会先被再次分配</p>
</blockquote>
<p>也就是说<code>mfastbinptr *fb = &amp;fastbin (av, idx);</code></p>
<p>这栈中的指针变量fb指向桶子头的地址,桶子头指向该桶子中的第一个堆块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">A[&quot;fastbin[x] @malloc_state&quot;]</span><br><span class="line">a2[&quot;1st chunk @heap&quot;]</span><br><span class="line">a1[&quot;2nd chunk @heap&quot;]</span><br><span class="line">a0[&quot;3rd chunk @heap&quot;]</span><br><span class="line">fb[&quot;fb句柄 @stack&quot;]----&gt;A--fd--&gt;a2--fd--&gt;a1--fd--&gt;a0</span><br></pre></td></tr></table></figure>
<h5
id="catomic_compare_and_exchange_val_acq-fb-victim-fd-victim">catomic_compare_and_exchange_val_acq
(fb, victim-&gt;fd, victim)</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#  <span class="keyword">define</span> catomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">  atomic_compare_and_exchange_val_acq (mem, newval, oldval)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">  (&#123; __typeof (mem) __gmemp = (mem);				      \</span></span><br><span class="line"><span class="meta">     __typeof (*mem) __gret = *__gmemp;				      \</span></span><br><span class="line"><span class="meta">     __typeof (*mem) __gnewval = (newval);			      \</span></span><br><span class="line"><span class="meta">								      \</span></span><br><span class="line"><span class="meta">     <span class="keyword">if</span> (__gret == (oldval))					      \</span></span><br><span class="line"><span class="meta">       *__gmemp = __gnewval;					      \</span></span><br><span class="line"><span class="meta">     __gret; &#125;)</span></span><br></pre></td></tr></table></figure>
<p>这个宏的作用是,</p>
<p>原本mem指向的是oldval,现在将oldval作为返回值,然后将men指向newval</p>
<p>放在原文中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim = pp;<span class="comment">//首先执行一次,如果第一次victim为空,说明这个桶子就是空的,也就不能用fastbin进行分配</span></span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">while</span> (</span><br><span class="line">		(pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)</span><br><span class="line">      )!= victim</span><br><span class="line">    <span class="comment">//victim指向链栈顶堆块,把他取下来,把原来的次顶堆块,也就是victim的后继堆块,挂到fb指针上,返回值pp是victim</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>fb这个桶子头原本是指向victim这个堆块的,</p>
<p>现在要让fb指向victim的后继堆块,然后返回victim给pp</p>
<p>显然pp必然等于victim,也就是顶多拿出堆顶来,while就结束了,while只会执行一次</p>
<p>至于为啥要这样写呢?压行</p>
<h5 id="check_remalloced_chunkapn">check_remalloced_chunk(A,P,N)</h5>
<p>对本应该属于A分配区的大小位S的堆块P进行检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> check_remalloced_chunk(A, P, N) do_check_remalloced_chunk (A, P, N)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_check_remalloced_chunk</span> <span class="params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span></span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line"><span class="comment">//提取p堆块结构体中存放的size,由于低三位是标志复用,现在需要将其盖住</span></span><br><span class="line">  <span class="keyword">if</span> (!chunk_is_mmapped (p))<span class="comment">//如果是mmap分配的堆块</span></span><br><span class="line">      <span class="comment">//如果是mmap分配的堆块,则</span></span><br><span class="line">    &#123;</span><br><span class="line">      assert (av == arena_for_chunk (p));<span class="comment">//首先检查给定的av是否是预期的p的所属分配区</span></span><br><span class="line">      <span class="keyword">if</span> (chunk_non_main_arena (p))<span class="comment">//如果p不是主分配区的</span></span><br><span class="line">        assert (av != &amp;main_arena);<span class="comment">//检查av是不是主分配区</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        assert (av == &amp;main_arena);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  do_check_inuse_chunk (av, p);<span class="comment">//检查本堆块是否正在使用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Legal size ... */</span></span><br><span class="line">  assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);<span class="comment">//检查sz大小是否对齐</span></span><br><span class="line">  assert ((<span class="type">unsigned</span> <span class="type">long</span>) (sz) &gt;= MINSIZE);<span class="comment">//检查sz大小是否大于最小分配大小</span></span><br><span class="line">  <span class="comment">/* ... and alignment */</span></span><br><span class="line">  assert (aligned_OK (chunk2mem (p)));<span class="comment">//检查p指向的地址是否对齐</span></span><br><span class="line">  <span class="comment">/* chunk is less than MINSIZE more than request */</span></span><br><span class="line">  assert ((<span class="type">long</span>) (sz) - (<span class="type">long</span>) (s) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert ((<span class="type">long</span>) (sz) - (<span class="type">long</span>) (s + MINSIZE) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="unsortedbins">unsortedbins</h4>
<p><code>smallbins</code>和<code>unsortedbins</code>中堆块的连接方式相同,都是双向链表</p>
<p>两者不同的是,<code>unsortedbin</code>中堆块可以大小各异,但是<code>smallbin</code>中一个桶子里的堆块必须相同</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/smallbin2.png"
alt="smallbin2" />
<figcaption aria-hidden="true">smallbin2</figcaption>
</figure>
<p><code>unsortedbin</code>的双向链表没有长短限制,采用头插法</p>
<h5 id="unsorted_chunksm-bin_atm-1">unsorted_chunks(M) (bin_at(M,
1))</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span></span><br></pre></td></tr></table></figure>
<p>取unsortedbin桶子头</p>
<h4 id="smallbins">smallbins</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define NSMALLBINS 64</span><br></pre></td></tr></table></figure>
<p>bins的下标是从0到253,其中每个桶子占用两个bins,分别作为fd和bk指针</p>
<p>smallbins占用64个桶子,</p>
<p>其中第1个桶子是unsortedbin,第2个到第63个桶子是smallbins</p>
<p>从第64个及以后的桶子就是largebins</p>
<h5 id="next_bin">next_bin</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_bin(b) ((mbinptr)((char *)(b) + (sizeof(mchunkptr) &lt;&lt; 1)))</span></span><br></pre></td></tr></table></figure>
<p>下一个bin就是<strong>mchunkptr指针</strong>的大小,也就是8个字节(在x64上)</p>
<p>左移一位也就是乘以2,因为每个Bin占用两个bin,分别作为fd和bk指针</p>
<h5 id="in_smallbin_range">in_smallbin_range</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define in_smallbin_range(sz)  \</span><br><span class="line">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span><br><span class="line">  </span><br><span class="line">#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br><span class="line"></span><br><span class="line">#define NBINS             128</span><br><span class="line">#define NSMALLBINS         64</span><br><span class="line">#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span><br><span class="line">#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span><br><span class="line"></span><br><span class="line">///MALLOC_ALIGNMENT=16</span><br><span class="line">SMALLBIN_CORRECTION=FALSE=0</span><br><span class="line">MIN_LARGE_SIZE=(64-0)*16=1024</span><br></pre></td></tr></table></figure>
<p>smallbins有(64-2=62)个桶子,最大管理的堆块为1023Bytes</p>
<p>再大一个字节都得放到largebin中</p>
<p>也就是说fastbins管理的堆块大小也在smallbin范围内,也就是说,<strong>fastbin相当于前部分比较小的smallbins的缓存</strong></p>
<h5 id="smallbin_index">smallbin_index</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))+ SMALLBIN_CORRECTION)</span></span><br><span class="line">	SMALLBIN_WIDTH=MALLOC_ALIGNMENT=<span class="number">16</span>字节</span><br><span class="line">    SMALLBIN_CORRECTION=<span class="number">0</span></span><br><span class="line">    smallbin_index(sz)=(sz&gt;&gt;<span class="number">4</span>)+<span class="number">0</span>=sz/<span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>这里参数sz是将请求大小换算成对应堆块整体大小之后的值,也就是包括了元数据</p>
<p>最小是0x20(元数据prev_size和size占用0x10,剩下的0x10是最小分配要求)</p>
<table>
<thead>
<tr>
<th>堆块大小(sz)</th>
<th>index</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>unsortedbin</strong></td>
<td>1</td>
</tr>
<tr>
<td><strong>smallbins</strong></td>
<td>[1,63]</td>
</tr>
<tr>
<td><code>[0x20,0x30)</code></td>
<td>2</td>
</tr>
<tr>
<td><code>[0x30,0x40)</code></td>
<td>3</td>
</tr>
<tr>
<td>....</td>
<td></td>
</tr>
<tr>
<td><code>[0x3f0,0x400)</code></td>
<td>63</td>
</tr>
<tr>
<td>&gt;0x400</td>
<td>largebins</td>
</tr>
</tbody>
</table>
<h5 id="bin_at">bin_at</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr)(((char *)&amp;((m)-&gt;bins[((i)-1) * 2])) - offsetof(struct malloc_chunk, fd))</span></span><br><span class="line">	<span class="comment">//(m)-&gt;bins[((i)-1) * 2]-16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(s,m) ((size_t)&amp;(((s*)0)-&gt;m))</span></span><br></pre></td></tr></table></figure>
<p>这里m是malloc_state结构,i是使用smallbin_index宏计算出的堆块在smallbin中的下标,i从2开始,因为bins[0]和bins[1]是unsortedbin的地盘</p>
<p><code>m-&gt;bins[2*(i-1)]</code>指向的是下标为(2*(i-1))的桶子的桶子头,减去<code>fd</code>成员在一个堆块中的偏移量,得到的是该桶子头基址往前16字节的内存地址</p>
<p>显然这个地方是未知的,这是为啥呢?</p>
<p>最后将该地址又交给一个mbinptr也就是malloc_chunk*指针保管</p>
<p>那么此时,新指针+16的位置刚好是修正后的fd</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/9c28ec87e40a4ea615599a26bafa58c.png"
alt="9c28ec87e40a4ea615599a26bafa58c" />
<figcaption
aria-hidden="true">9c28ec87e40a4ea615599a26bafa58c</figcaption>
</figure>
<p>而每个桶子头节点虽然也是malloc_chunk类型,但是只需要fd和bk两个指针,其他成员不需要</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/smallbinhead.png"
alt="smallbinhead" />
<figcaption aria-hidden="true">smallbinhead</figcaption>
</figure>
<h5 id="set_inuse_bit_at_offset">set_inuse_bit_at_offset</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse_bit_at_offset(p, s) \</span></span><br><span class="line"><span class="meta">  (((mchunkptr)(((char *)(p)) + (s)))-&gt;size |= PREV_INUSE)</span></span><br></pre></td></tr></table></figure>
<p>将size字段的flag位设置上PREV_INUSE=1,表示前一个物理相邻块正在被占用</p>
<h5 id="do_check_malloced_chunk">do_check_malloced_chunk</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> check_malloced_chunk(A, P, N) do_check_malloced_chunk(A, P, N)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_check_malloced_chunk</span><span class="params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span></span><br><span class="line">&#123;</span><br><span class="line">  do_check_remalloced_chunk(av, p, s);</span><br><span class="line">  assert(prev_inuse(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="largebins">largebins</h4>
<p>smallbins中的每两个相邻的桶子,其中堆块的大小相差0x16字节(在x64上)</p>
<p>Bin Index就是bin_at的计算结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">实际上largebins和smallbins可以看成一个整体,前<span class="number">64</span>个桶子是smallbins</span><br><span class="line">    前<span class="number">64</span>个桶子相邻两个桶子之间大小差<span class="number">8</span>字节</span><br><span class="line">   	然后<span class="number">32</span>个桶子相邻两个桶子之间大小差<span class="number">64</span>字节</span><br><span class="line">    然后<span class="number">16</span>个桶子相邻两个桶子之间大小差<span class="number">512</span>字节</span><br><span class="line">    ...</span><br><span class="line">	<span class="number">64</span> bins of size       <span class="number">8</span></span><br><span class="line">    <span class="number">32</span> bins of size      <span class="number">64</span></span><br><span class="line">    <span class="number">16</span> bins of size     <span class="number">512</span></span><br><span class="line">     <span class="number">8</span> bins of size    <span class="number">4096</span></span><br><span class="line">     <span class="number">4</span> bins of size   <span class="number">32768</span></span><br><span class="line">     <span class="number">2</span> bins of size  <span class="number">262144</span></span><br><span class="line">     <span class="number">1</span> bin  of size what<span class="number">&#x27;</span>s left</span><br></pre></td></tr></table></figure>
<h5 id="largebin_range">largebin_range</h5>
<p>malloc函数在分配时,超过smallbin_range大小的堆块才可能被放到largebin</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz) \</span></span><br><span class="line"><span class="meta">  ((unsigned long)(sz) &lt; (unsigned long)MIN_LARGE_SIZE)</span></span><br></pre></td></tr></table></figure>
<p>在x64上,MIN_LARGE_SIZE=1024</p>
<p>也就是说,大于等于1024的堆块才可能进入largebin</p>
<h5 id="largebin_index">largebin_index</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz)                              \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8             ? largebin_index_64(sz)     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big(sz) \ <span class="comment">//size_sz!=8并且对齐是16位,调用largebin_index_32_big</span></span></span><br><span class="line">                            : largebin_index_32(sz))		<span class="comment">//size_sz!=8并且对齐是8位,调用largebin_index_32</span></span><br><span class="line">x64上SIZE_SZ=<span class="number">8</span>(一个指针的大小),因此调用largebin_index_64(sz) 这个宏</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                                                                                            \</span></span><br><span class="line"><span class="meta">  (((((unsigned long)(sz)) &gt;&gt; 6) <span class="string">&lt;= 48) ? 48 + (((unsigned long)(sz)) &gt;</span>&gt; 6) : ((((unsigned long)(sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ? 91 + (((unsigned long)(sz)) &gt;</span>&gt; 9)   \</span></span><br><span class="line"><span class="meta">                                                                          : ((((unsigned long)(sz)) &gt;&gt; 12) <span class="string">&lt;= 10)  ? 110 + (((unsigned long)(sz)) &gt;</span>&gt; 12) \</span></span><br><span class="line"><span class="meta">                                                                          : ((((unsigned long)(sz)) &gt;&gt; 15) <span class="string">&lt;= 4)   ? 119 + (((unsigned long)(sz)) &gt;</span>&gt; 15) \</span></span><br><span class="line"><span class="meta">                                                                          : ((((unsigned long)(sz)) &gt;&gt; 18) <span class="string">&lt;= 2)   ? 124 + (((unsigned long)(sz)) &gt;</span>&gt; 18) \</span></span><br><span class="line"><span class="meta">                                                                                                                   : 126)</span></span><br></pre></td></tr></table></figure>
<p>这里的参数sz是包括元数据的整个堆块大小</p>
<p>又落在largebin范围内的堆块,最小是1024字节,因此sz右移6位后,最小是16,那么第一组从16到48,堆块的大小也就是从1024到3072</p>
<p>这些堆块对应的桶下标计算方式为,将其大小右移6位然后加上48,</p>
<p>也就是说,一个桶子中的堆块一样大,同一组内相邻两个桶子中堆块相差64B</p>
<table>
<thead>
<tr>
<th>largebins堆块大小</th>
<th>下标</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>[1024,1087)</td>
<td>64</td>
<td></td>
</tr>
<tr>
<td>[1088,1151)</td>
<td>65</td>
<td></td>
</tr>
<tr>
<td>...</td>
<td></td>
<td></td>
</tr>
<tr>
<td>[3072,3135)</td>
<td>96</td>
<td>这块儿到底塞到哪里我也不知道</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">64</span> bins of size       <span class="number">8</span></span><br><span class="line">   <span class="number">32</span> bins of size      <span class="number">64</span></span><br><span class="line">   <span class="number">16</span> bins of size     <span class="number">512</span></span><br><span class="line">    <span class="number">8</span> bins of size    <span class="number">4096</span></span><br><span class="line">    <span class="number">4</span> bins of size   <span class="number">32768</span></span><br><span class="line">    <span class="number">2</span> bins of size  <span class="number">262144</span></span><br><span class="line">    <span class="number">1</span> bin  of size what<span class="number">&#x27;</span>s left</span><br></pre></td></tr></table></figure>
<p>整个largebin中有6组桶子,第一组占用32个Bins,相邻两个桶子之间的堆块相差64B</p>
<p>第二组占用16个Bins,相邻两个桶子之间的堆块相差16B</p>
<p>...</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(sz/64&lt;=48)&#123;</span><br><span class="line">	return 48+sz/64</span><br><span class="line">&#125;else if(sz/512&lt;=20)&#123;</span><br><span class="line">	return 91+sz/512</span><br><span class="line">&#125;else if(sz/4096&lt;=10)&#123;</span><br><span class="line">	return 110+sz/4096</span><br><span class="line">&#125;else if(sz/)</span><br></pre></td></tr></table></figure>
<h4 id="binmap">binmap</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSHIFT 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITSPERMAP (1U &lt;&lt; BINMAPSHIFT)  </span></span><br><span class="line">	BITSPERMAP=<span class="number">32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSIZE (NBINS / BITSPERMAP)</span></span><br><span class="line">	BINMAPSIZE=<span class="number">128</span>/<span class="number">32</span>=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> binmap[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>binmap是一个4个int的数组,共32位,不管是x64还是x86都是32位,用于标记32个largebin中是否有空闲的堆块</p>
<p>用于加快largebin中分配堆块时的最适寻找工作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)</span></span><br></pre></td></tr></table></figure>
<p>i是largebins下标,右移5位也就是除以32计算得到属于i下标的桶子属于map[0]还是map[1],map[2],map[3]哪一个管理</p>
<p>一个block也就是8个桶子归一个map管</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br></pre></td></tr></table></figure>
<p>计算i下标的largebins桶子属于其对应block的哪一位管</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define mark_bin(m, i) ((m)-&gt;binmap[idx2block(i)] |= idx2bit(i))			//改,标记i下标的largebins有空闲堆块</span><br><span class="line">#define unmark_bin(m, i) ((m)-&gt;binmap[idx2block(i)] &amp;= ~(idx2bit(i)))		//删</span><br><span class="line">#define get_binmap(m, i) ((m)-&gt;binmap[idx2block(i)] &amp; idx2bit(i))			//查</span><br></pre></td></tr></table></figure>
<h2 id="algorithm">algorithm</h2>
<h3 id="malloc">malloc</h3>
<p>用户空间的malloc函数,实际上调用的是<code>__libc_malloc@glibc</code>,别名罢了</p>
<h4 id="libc_malloc">__libc_malloc</h4>
<p>用户程序调用的malloc函数,实际上调用的是<code>__libc_malloc</code></p>
<p>在<code>glibc/malloc/malloc.c</code>中有这么一个<code>alias</code>声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, <span class="built_in">malloc</span>)</span><br></pre></td></tr></table></figure>
<p>而<code>__libc_malloc</code>实际上做的事情就两句话</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line"><span class="keyword">return</span> victim;</span><br></pre></td></tr></table></figure>
<p>其他内容都是多线程上下锁,各种检查,编译优化了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;<span class="comment">//堆块指针</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));<span class="comment">//在实际调用int_malloc函数之前,首先调用钩子函数hook,hook指向__malloc_hook</span></span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);<span class="comment">//获取分配区指针,返回值交给ar_ptr,传递参数bytes的作用是判断分配区空间是否足够</span></span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);<span class="comment">//int_malloc函数是实际进行内存分配的函数</span></span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)<span class="comment">//分配失败并且没有获取到分配区</span></span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);<span class="comment">//分配区获取失败,重试一次</span></span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);<span class="comment">//重新获取分配区之后再次尝试切割堆块给victim</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)<span class="comment">//解锁,因为int_malloc中会对分配区上锁,解锁后方便其他线程分配内存</span></span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));<span class="comment">//最后一次检查</span></span><br><span class="line">    <span class="comment">//检查内容包括:</span></span><br><span class="line">        <span class="comment">//victim指针是否真的指向一个堆块</span></span><br><span class="line">        <span class="comment">//victim对应的堆块是否已经在bitmap中被标记</span></span><br><span class="line">        <span class="comment">//ar_ptr指向的分配区,是否是victim堆块所在的分配区</span></span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="atomic_forced_read">atomic_forced_read</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> atomic_forced_read(x) \</span></span><br><span class="line"><span class="meta">  (&#123; __typeof (x) __x; __asm (<span class="string">&quot;&quot;</span> : <span class="string">&quot;=r&quot;</span> (__x) : <span class="string">&quot;0&quot;</span> (x)); __x; &#125;)</span></span><br></pre></td></tr></table></figure>
<p>原子读,这段内联汇编应该这样断句:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__asm (</span><br><span class="line"> 	&quot;&quot; </span><br><span class="line"> 	: &quot;=r&quot; (__x) </span><br><span class="line"> 	: &quot;0&quot; (x)</span><br><span class="line"> ); </span><br></pre></td></tr></table></figure>
<p>首先""意思是没有一条指令,本内联代码块只需要使用输入输出约束</p>
<p><code>"=r" (__x)</code>输出操作数约束,意思是将<code>__x</code>视为输出变量,放到通用寄存器里</p>
<p><code>: "0" (x)</code>输入操作数约束,意思是x使用和第一个输出操作数(也就是<code>__x</code>)相同的约束</p>
<p>整个内联汇编的作用是将变量x拷贝到<code>__x</code>中</p>
<p>看完了也不知道"原子"如何保证的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>编译器分支预测优化</p>
<p><code>long __builtin_expect(long exp, long c);</code>期望exp表达式的值等于c</p>
<h5 id="malloc_hook">__malloc_hook</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static void *malloc_hook_ini(size_t sz,const void *caller) __THROW;</span><br><span class="line">void *weak_variable (*__malloc_hook)(size_t __size, const void *) = malloc_hook_ini;</span><br></pre></td></tr></table></figure>
<p>分配前钩子,如果有注册钩子函数,则调用该钩子函数进行分配,直接返回钩子函数的返回值给句柄,不会再调用glibc自己实现的int_malloc</p>
<p>可以考虑篡改malloc_hook钩子劫持控制流</p>
<p><a
target="_blank" rel="noopener" href="https://seanachao.github.io/2020/07/13/hook劫持/">malloc_hook以及free_hook劫持原理
| S3cana's Blog (seanachao.github.io)</a></p>
<h4 id="int_malloc">_int_malloc</h4>
<p>这个函数很长,因为GNU向来要求函数嵌套不能太深,因此这个一个函数综合了从fastbin,smallbin,bin,unsortedbin等各种地方申请堆块的操作</p>
<p>glibc2.23/malloc/malloc.c 第3318行开始</p>
<p>函数签名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void *_int_malloc (mstate av, size_t bytes);</span><br></pre></td></tr></table></figure>
<p>static决定本函数只能在malloc模块中可见,用户程序无法越级调用</p>
<p>void*返回值类型</p>
<p>两个参数,<code>mstate av</code>是分配区指针</p>
<p><code>size_t bytes</code>是企图分配的内存大小</p>
<h4 id="算法流程">算法流程</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/malloc.png"
alt="malloc" />
<figcaption aria-hidden="true">malloc</figcaption>
</figure>
<h4 id="局部变量">局部变量</h4>
<p>首先定义了一众局部变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span><span class="comment">//本变量是用户希望大小size的计算值,也就是实际的堆块大小</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* associated bin index */</span><span class="comment">//本变量用于记录nb大小的堆块属于的桶子下标</span></span><br><span class="line">mbinptr bin;                      <span class="comment">/* associated bin */</span>;<span class="comment">//桶子头指针</span></span><br><span class="line"></span><br><span class="line">mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span><span class="comment">//命中堆块</span></span><br><span class="line">INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span>	<span class="comment">//victim命中堆块本来的大小</span></span><br><span class="line"><span class="type">int</span> victim_index;                 <span class="comment">/* its bin index */</span>	<span class="comment">//victim_index命中堆块属于的桶子下标</span></span><br><span class="line"></span><br><span class="line">mchunkptr remainder;              <span class="comment">/* remainder from a split */</span>	<span class="comment">//切割一个大块,剩下的部分被称为remainder</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* its size */</span>	<span class="comment">//剩余部分的大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* bit map traverser */</span>	<span class="comment">//binmap下标,用于记录一个桶子属于四个block之一的哪一个</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* bit map traverser */</span>		<span class="comment">//用于记录一共桶子属于其block中的哪一位	</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span>	<span class="comment">//binmap[map],作为binmap的下标,有0,1,2,3四个取值</span></span><br><span class="line"></span><br><span class="line">mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span>		<span class="comment">//取桶子头之后一般会让bck指向之前的第一个堆块,fwd指向桶子头,然后头插</span></span><br><span class="line">mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="计算实际大小">计算实际大小</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checked_request2size (bytes, nb);</span><br></pre></td></tr></table></figure>
<p>这个宏的作用是将请求的bytes,按照对齐等规则,转化为实际上要申请的大小nb</p>
<p>经过此宏之后,int_malloc中使用的都是nb,不再使用bytes作为分配大小</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define checked_request2size(req, sz)                             \</span><br><span class="line">  if (REQUEST_OUT_OF_RANGE (req)) &#123;					      \</span><br><span class="line">      __set_errno (ENOMEM);						      \</span><br><span class="line">      return 0;								      \</span><br><span class="line">    &#125;									      \</span><br><span class="line">  (sz) = request2size (req);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  #define request2size(req)                                         \</span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  #define MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span><br><span class="line">  #  define MALLOC_ALIGNMENT       (2 *SIZE_SZ &lt; __alignof__ (long double)      \</span><br><span class="line">                                  ? __alignof__ (long double) : 2 *SIZE_SZ)</span><br></pre></td></tr></table></figure>
<p>如果请求大小req+SIZE_SZ+对齐掩码小于最小分配大小,则按照最小分配大小来</p>
<p>否则将上述值和对齐掩码的补码按位与</p>
<p>在x64上</p>
<p>MALLOC_ALIGNMENT=2*SIZE_SZ=16</p>
<p>MALLOC_ALIGN_MASK=15</p>
<p>request2size(req) =(req+8+15 )&amp;11111110000</p>
<p>假设req=0x10,即用户希望得到一块至少有0x10个字节的堆块则</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request2size(req) </span><br><span class="line">    =(<span class="number">16</span>+<span class="number">8</span>+<span class="number">15</span> )&amp;<span class="number">11111110000</span></span><br><span class="line">    =(<span class="number">0b10000</span>+<span class="number">0b1000</span>+<span class="number">0b1111</span>)&amp;<span class="number">111111110000</span></span><br><span class="line">    =<span class="number">0b100111</span>&amp;<span class="number">0b110000</span></span><br><span class="line">    =<span class="number">0b100000</span></span><br><span class="line">    =<span class="number">32</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="检查当前是否有可用分配区">检查当前是否有可用分配区</h4>
<p>然后检查av分配区指针是否为空,显然这里的编译器优化是期望其不空的</p>
<p>但是如果真的av为空,没有可用分配区的画,则调用sysmalloc直接解决分配问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果果真为空则调用sysmalloc函数,</p>
<p>sysmalloc被调用的情况是这样的:</p>
<p>当av分配区的topchunk大小不足以满足用户需求,调用sysmalloc扩大topchunk大小或者更换topchunk</p>
<p>比如调用sbrk系统调用扩大topchunk的大小</p>
<p>sysmalloc如果能成功分配堆块,则p指向该堆块,然后<code>alloc_perturb</code>将p指向堆块的用户空间的前bytes个字节,初始化为<code>perturb_byte^0xff</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> perturb_byte;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">alloc_perturb</span> <span class="params">(<span class="type">char</span> *p, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte ^ <span class="number">0xff</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fastbins区分配">fastbins区分配</h4>
<p>经过两个检查之后,如果控制流执行至此,说明需要分配的堆块不是很离谱,起码不用麻烦sbrk额外分配大块内存</p>
<p>那么首先尝试使用fastbins进行分配</p>
<blockquote>
<p>在该区分配的主要流程:</p>
<p>1.根据实际堆块大小nb计算应该落在哪个桶子里</p>
<p>2.从该桶子顶取出一个堆块交给用户</p>
<p>3.将该桶子中剩余的部分重新挂到桶子头上</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">  &#123;<span class="comment">//首先判断,nb这个大小,是否落在fastbins管理的堆块大小范围内</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//控制流至此说明nb大小适合fastbins分配,下面需要判断fastbins里面有没有空闲堆块</span></span><br><span class="line"></span><br><span class="line">    idx = fastbin_index (nb);<span class="comment">//根据nb大小计算落在fastbin的哪个桶里面,返回值是数组下标</span></span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);<span class="comment">//&amp;fastbins[idx]就是对应桶的桶子头</span></span><br><span class="line">    mchunkptr pp = *fb;<span class="comment">//*解引用,也就是拿出fastbins[idx]指向的第一个堆块,pp拷贝堆块的指针</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim = pp;<span class="comment">//如果上来victim就为空,说明桶子头fastbins[idx]指向NULL,也就是这个桶是空的</span></span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">    		(pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)</span><br><span class="line">          )!= victim</span><br><span class="line">        <span class="comment">//victim指向链栈顶,然后把他取下来,把原来的次顶堆块挂到fb指针上,返回值pp是victim</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>)<span class="comment">//如果victim不为0说明对应桶中确实有堆块,并且已经交给victim保管</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">          &#123;<span class="comment">//victim获取到的fastbin堆块,再检查一下发现不应该属于其原本的桶中,说明有鬼</span></span><br><span class="line">            errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">          errout:</span><br><span class="line">            malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        check_remalloced_chunk (av, victim, nb);<span class="comment">//重新分配的堆块检查,这里指的是从topchunk割下来然后free进入各种bins然后又被重新利用的堆块</span></span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//</span></span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="smallbins区分配">smallbins区分配</h4>
<p>bins数组中维护的是桶子头的fd,bk指针,一个smallbin头需要两个bins数组元素存放,一个记录fd,一个记录bk,</p>
<p>看图一眼顶针</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/smallbin1.png"
alt="smallbin1" />
<figcaption aria-hidden="true">smallbin1</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = smallbin_index (nb);<span class="comment">//计算nb所在的smallbins下标</span></span><br><span class="line">    bin = bin_at (av, idx);<span class="comment">//取smallbin[idx]桶子头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last (bin)) != bin)<span class="comment">//last(bin)=bin-&gt;fd,如果bin的指针还是指向bin说明这个桶子是空的</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">          malloc_consolidate (av);<span class="comment">//堆块合并</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;<span class="comment">//下面要将victim从双向链表上摘下来</span></span><br><span class="line">            bck = victim-&gt;bk;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<span class="comment">//检查victim-&gt;bk指向的堆块,其fd指针是否是victim</span></span><br><span class="line">              &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">              &#125;</span><br><span class="line">            set_inuse_bit_at_offset (victim, nb);<span class="comment">//经过malloc_consolidate后,如果本块和物理相邻的前块都没使用,则会合并起来</span></span><br><span class="line">            <span class="comment">//把victim抠下来,然后把桶子头和victim-&gt;bk连起来</span></span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">              victim-&gt;size |= NON_MAIN_ARENA;<span class="comment">//标记非主分配区</span></span><br><span class="line">            check_malloced_chunk (av, victim, nb);</span><br><span class="line">            <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//获取data基地址指针</span></span><br><span class="line">            alloc_perturb (p, bytes);<span class="comment">//填充</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="fastbin合并">fastbin合并</h4>
<p>注意有两种到达此处的可能,要么是一个<code>smallbin</code>的申请,但是没在<code>smallbin</code>中找到对应堆块,要么是一个largebin的申请</p>
<p>前者<strong>不会</strong>引起<code>fastbin</code>的合并,后者会首先合并<code>fastbin</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line"> &#123;</span><br><span class="line">...</span><br><span class="line">   <span class="keyword">if</span> ((victim = last(bin)) != bin) <span class="comment">// bin桶子中的最后一个,如果不是bin这个头节点自己,那么说明这个桶子里至少有一个空闲堆块</span></span><br><span class="line">   &#123;</span><br><span class="line">   ...</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">   idx = largebin_index(nb);</span><br><span class="line">   <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">     malloc_consolidate(av);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>fastbin</code>合并之后的堆块,都会被放到<code>unsortedbin</code>中,其目的是给<code>unsortedbin</code>区的尝试分配增大可能性</p>
<p>看上去此时将<code>fastbin</code>进行合并,有损效率,但这是为了防止<code>fastbin</code>截留堆块导致堆空间碎片化(<code>fastbin</code>中的堆块依然保持使用状态,不会被其他临近堆块向前或者向后合并.因此需要对其进行主动合并释放)</p>
<p>并且经验表明,一个程序要么主要使用<code>smallbin</code>大小的堆块,要么主要使用<code>largebin</code>大小的堆块</p>
<p>因此对<code>fastbin</code>的合并操作不会被经常调用</p>
<p>具体的<code>fastbin</code>合并过程,在<code>malloc_consolidate</code>中</p>
<h5 id="malloc_consolidate">malloc_consolidate</h5>
<blockquote>
<p>用于<code>fastbin</code>区的合并</p>
<p>两层循环,外层循环遍历<code>fastbin</code>桶子头</p>
<p>内层循环遍历挂载一个桶子头上的堆块链表</p>
<p>对每个堆块,尝试进行向前合并和向后合并,注意只会分别执行一次</p>
<p>如果尝试向后合并时发现和<code>topchunk</code>相邻则并入<code>topchunk</code></p>
<p>如果尝试向前合并和向后合并之后,没有并入topchunk会被头插法链接到<code>unsortedbin</code>的双向链表上</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mfastbinptr *fb;          <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr *maxfb;       <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr p;              <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr nextp;          <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr unsorted_bin;   <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr first_unsorted; <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="type">int</span> nextinuse;</span><br><span class="line">  mchunkptr bck;</span><br><span class="line">  mchunkptr fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast() != <span class="number">0</span>)<span class="comment">//如果max_faxt值为空,则说明堆还没有初始化</span></span><br><span class="line">  &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    maxfb = &amp;fastbin(av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin(av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      p = atomic_exchange_acq(fb, <span class="number">0</span>); <span class="comment">// p=fb,fb++</span></span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123; <span class="comment">// 释放快桶子p上挂着的所有堆块</span></span><br><span class="line">          check_inuse_chunk(av, p);</span><br><span class="line">          nextp = p-&gt;fd; <span class="comment">// 先取后继</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">          size = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA); <span class="comment">// 撤销flag</span></span><br><span class="line">          nextchunk = chunk_at_offset(p, size);            <span class="comment">// 物理上相邻的下一个堆块</span></span><br><span class="line">          nextsize = chunksize(nextchunk);   </span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!prev_inuse(p))<span class="comment">//向前合并</span></span><br><span class="line">          &#123;</span><br><span class="line">            prevsize = p-&gt;prev_size;</span><br><span class="line">            size += prevsize;</span><br><span class="line">            p = chunk_at_offset(p, -((<span class="type">long</span>)prevsize));<span class="comment">//取物理上前一个相邻的堆块基址,作为合并堆块的基址</span></span><br><span class="line">            unlink(av, p, bck, fwd);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (nextchunk != av-&gt;top)<span class="comment">//如果后面和topchunk相邻则和topchunk合并,否则尝试向后合并</span></span><br><span class="line">          &#123;</span><br><span class="line">            nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!nextinuse)</span><br><span class="line">            &#123;</span><br><span class="line">              size += nextsize;</span><br><span class="line">              unlink(av, nextchunk, bck, fwd);<span class="comment">//如果物理上后面相邻的堆块没在使用则向后合并</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            first_unsorted = unsorted_bin-&gt;fd;<span class="comment">//取第一个unsorted_bin上悬挂的堆块</span></span><br><span class="line">            unsorted_bin-&gt;fd = p;<span class="comment">//头插法</span></span><br><span class="line">            first_unsorted-&gt;bk = p;<span class="comment">//将p链接到unsorted_bin和p之间</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range(size))<span class="comment">//如果这个合并堆块在largebin范围内则初始化其nextsize指针</span></span><br><span class="line">            &#123;</span><br><span class="line">              p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            p-&gt;bk = unsorted_bin;</span><br><span class="line">            p-&gt;fd = first_unsorted;</span><br><span class="line">            set_foot(p, size);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            size += nextsize;</span><br><span class="line">            set_head(p, size | PREV_INUSE);<span class="comment">//p后面就是topchunk,p合并到topchunk</span></span><br><span class="line">            av-&gt;top = p;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> ((p = nextp) != <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);<span class="comment">//遍历整个fastbin,直到fastbin桶子头哨兵maxfb</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    malloc_init_state(av);<span class="comment">//初始化堆</span></span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="unsortedbin区分配">unsortedbin区分配</h4>
<h5 id="unsortedbin尝试分配-与-归类">unsortedbin尝试分配 与 归类</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av))<span class="comment">//检查unsortedbin中是否确实有堆块,有则从unsortedbin中拿下第一个堆块</span></span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;<span class="comment">//后继</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect(victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                        chunk2mem(victim), av);</span><br><span class="line">      size = chunksize(victim);<span class="comment">//根据size字段获取victim的大小</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">         only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">         runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">         exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">         no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp;<span class="comment">//如果是一个smallbin的分配申请</span></span><br><span class="line">          bck == unsorted_chunks(av) &amp;&amp;<span class="comment">//bck=victim-&gt;bk如果这个判断通过,说明刚从unsortedbin中拆下的堆块victim是unsoreted中唯一的堆块</span></span><br><span class="line">          victim == av-&gt;last_remainder &amp;&amp;<span class="comment">//如果victim是最近一次分配过的堆块,最近使用的堆块页面可能还在内存中,因此有这种优化</span></span><br><span class="line">          (<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE))<span class="comment">//如果这个victim堆块满足大小要求</span></span><br><span class="line">      &#123;<span class="comment">//这个victim通过了考察,下面将其分割,将满足大小要求的部分给用户,剩下的部分再放回unsortedbin</span></span><br><span class="line">        <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">        remainder_size = size - nb;<span class="comment">//剩余大小</span></span><br><span class="line">        remainder = chunk_at_offset(victim, nb);<span class="comment">//victim的前半部分将要分出去给用户,后面的剩下,remainder是剩下部分的基地址</span></span><br><span class="line">        unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;<span class="comment">//更新unsortedbin中这个唯一堆块的剩余状态</span></span><br><span class="line">        av-&gt;last_remainder = remainder;<span class="comment">//剩余堆块记为最近使用</span></span><br><span class="line">        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);<span class="comment">//设置前后指针都为unsortedbin桶子</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(remainder_size))<span class="comment">//如果剩下的部分属于largebin范围,则初始化两个指针</span></span><br><span class="line">        &#123;</span><br><span class="line">          remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);<span class="comment">//因为前块被分配,因此remainder的prev_inuse置1</span></span><br><span class="line">        set_foot(remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);<span class="comment">//p=victim+0x10指向data区域</span></span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">      unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = unsorted_chunks(av);<span class="comment">//将bin从unsortedbin中拿出来,然后将其前后驱连接</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size == nb)<span class="comment">//如果尝试分配的大小,恰好和这个unsortedbin堆块一样大则分配之</span></span><br><span class="line">      &#123;</span><br><span class="line">        set_inuse_bit_at_offset(victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(size))<span class="comment">//如果这个刚摘下来的unsortedbin堆块属于smallbin范围,计算好新的前后邻居</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim_index = smallbin_index(size);</span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span><span class="comment">//否则说明这unsortedbin堆块属于largebin范围,计算好新的前后邻居</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim_index = largebin_index(size);</span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">        <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">          size |= PREV_INUSE;</span><br><span class="line">          <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">          assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(bck-&gt;bk-&gt;size))</span><br><span class="line">          &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>)size &lt; fwd-&gt;size)</span><br><span class="line">            &#123;</span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)size == (<span class="type">unsigned</span> <span class="type">long</span>)fwd-&gt;size)</span><br><span class="line">              <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//结算,前面不管是largebin还是smallbin,都已经计算好了前后邻居bck,fwd,在此将诸位连接</span></span><br><span class="line">      mark_bin(av, victim_index);<span class="comment">//标记binmap</span></span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS 10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)<span class="comment">//顶多合并10000次,太多次合并会导致本次请求响应太慢</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="largebin申请">largebin申请</h5>
<p>如果到此还没有返回,也就是还没有申请到堆块下面再尝试使用largebin申请</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!in_smallbin_range(nb))<span class="comment">//如果是一个largebin的请求</span></span><br><span class="line"> &#123;</span><br><span class="line">   bin = bin_at(av, idx);<span class="comment">//取桶子头</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">   <span class="keyword">if</span> ((victim = first(bin)) != bin &amp;&amp;</span><br><span class="line">       (<span class="type">unsigned</span> <span class="type">long</span>)(victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb))</span><br><span class="line">   &#123;<span class="comment">//first(bin)=bin-&gt;fd,可以看出bin-&gt;fd应该是该桶子中最大的一个堆块,然后顺着fd指针越来越小</span></span><br><span class="line">       <span class="comment">//如果最大的堆块都不满足nb的需求,显然再往后找更小的无意义,因此首先需要判断最大的堆块是否能满足要求,</span></span><br><span class="line"><span class="comment">//当这个前提条件满足时,再向后找最佳适配的堆块</span></span><br><span class="line">     victim = victim-&gt;bk_nextsize;<span class="comment">//bk_nextsize是下一个比当前victim小的堆块,victim-&gt;bk可能和victim一样大,但是victim-&gt;bk_nextsize要么是桶子头,要么一定比当前堆块小</span></span><br><span class="line">     <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>)(size = chunksize(victim)) &lt;</span><br><span class="line">             (<span class="type">unsigned</span> <span class="type">long</span>)(nb)))</span><br><span class="line">       victim = victim-&gt;bk_nextsize;<span class="comment">//从小开始遍历直到第一个大于等于nb大小的堆块</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">        list does not have to be rerouted.  */</span></span><br><span class="line">     <span class="keyword">if</span> (victim != last(bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">       victim = victim-&gt;fd;<span class="comment">//避免移除跳表的最开始一个导致变更指针,首先尝试寻找该大小的堆块是否有第二块,如果有则放过跳表头</span></span><br><span class="line">		</span><br><span class="line">     remainder_size = size - nb;<span class="comment">//victim块比较抠,只分配nb大小左右,多余的不给</span></span><br><span class="line">     unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Exhaust */</span></span><br><span class="line">     <span class="keyword">if</span> (remainder_size &lt; MINSIZE)<span class="comment">//如果发现victim分割后的剩余部分都是下脚料就不抠了</span></span><br><span class="line">     &#123;</span><br><span class="line">       set_inuse_bit_at_offset(victim, size);</span><br><span class="line">       <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">         victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* Split */</span></span><br><span class="line">     <span class="keyword">else</span><span class="comment">//否则victim剩余部分放到unsortedbin</span></span><br><span class="line">     &#123;</span><br><span class="line">       remainder = chunk_at_offset(victim, nb);<span class="comment">//取victim切割nb字节之后的剩余部分</span></span><br><span class="line">       <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">          have to perform a complete insert here.  */</span></span><br><span class="line">       bck = unsorted_chunks(av);</span><br><span class="line">       fwd = bck-&gt;fd;</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">       &#123;</span><br><span class="line">         errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">         <span class="keyword">goto</span> errout;</span><br><span class="line">       &#125;</span><br><span class="line">       remainder-&gt;bk = bck;<span class="comment">//头插法</span></span><br><span class="line">       remainder-&gt;fd = fwd;</span><br><span class="line">       bck-&gt;fd = remainder;</span><br><span class="line">       fwd-&gt;bk = remainder;</span><br><span class="line">       <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">       &#123;</span><br><span class="line">         remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;<span class="comment">//如果剩余大小还是largebin大小,则此时预先将指针清零</span></span><br><span class="line">         remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">       set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">       set_foot(remainder, remainder_size);</span><br><span class="line">     &#125;</span><br><span class="line">     check_malloced_chunk(av, victim, nb);</span><br><span class="line">     <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">     alloc_perturb(p, bytes);</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="后续largebin申请">后续largebin申请</h5>
<p>如果到此还没有分配,说明当前largebin里面没有找到何时的,那么向后面的largebin桶子中找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">   bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">   (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">   that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">   The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">   when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">++idx;					<span class="comment">//取下一个桶子的下标</span></span><br><span class="line">bin = bin_at(av, idx);	<span class="comment">//首先查binmap,看看下一个桶子是否确实有空闲堆块</span></span><br><span class="line">block = idx2block(idx);</span><br><span class="line"><span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">bit = idx2bit(idx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">  <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)<span class="comment">//如果bit&gt;map只可能是map=0,也就是当前block是空的</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">        <span class="keyword">goto</span> use_top;<span class="comment">//如果发现block遍历了4个block,全是空的,也就是largebin空了,直接使用top_chunk分配</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);<span class="comment">//跳过所有空的largebin</span></span><br><span class="line"></span><br><span class="line">    bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">    bit = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">  <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)<span class="comment">//尝试找一个map对应block中有堆块的桶子</span></span><br><span class="line">  &#123;</span><br><span class="line">    bin = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;<span class="comment">//左移也就是往largebin更大的方向找</span></span><br><span class="line">    assert(bit != <span class="number">0</span>);</span><br><span class="line">  &#125;<span class="comment">//退出循环时,bin对应的桶子中一定有堆块</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">  victim = last(bin);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">  <span class="keyword">if</span> (victim == bin)<span class="comment">//检查是否该bin中至少有一个堆块,这是因为map是懒修改的</span></span><br><span class="line">  &#123;<span class="comment">//也就是说,map中标记有的不一定有,但是map中标记没有的一定没有</span></span><br><span class="line">    av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">      <span class="comment">//本桶子中确实没有,但也不是没有功劳,起码可以修改map,下一次查找一定不会查本桶子</span></span><br><span class="line">    bin = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;<span class="comment">//继续向更大的largebin桶子寻找</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span><span class="comment">//本桶子中确实有至少一个堆块</span></span><br><span class="line">  &#123;</span><br><span class="line">    size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">    assert((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb));</span><br><span class="line"></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlink */</span></span><br><span class="line">    unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exhaust */</span></span><br><span class="line">    <span class="keyword">if</span> (remainder_size &lt; MINSIZE)<span class="comment">//下脚料一起送人</span></span><br><span class="line">    &#123;</span><br><span class="line">      set_inuse_bit_at_offset(victim, size);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split */</span></span><br><span class="line">    <span class="keyword">else</span>		<span class="comment">//切割指定大小的堆块,剩下的送给unsortedbin</span></span><br><span class="line">    &#123;</span><br><span class="line">      remainder = chunk_at_offset(victim, nb);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">         have to perform a complete insert here.  */</span></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      remainder-&gt;bk = bck;</span><br><span class="line">      remainder-&gt;fd = fwd;</span><br><span class="line">      bck-&gt;fd = remainder; </span><br><span class="line">      fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">      &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                           (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">      set_foot(remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="unlink">unlink</h6>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/unlink.png"
alt="unlink" />
<figcaption aria-hidden="true">unlink</figcaption>
</figure>
<p>从双向链表上摘下一个堆块<code>P</code>,把它的前后驱重新链接起来</p>
<p>针对<code>smallbin</code>和<code>unsortedbin</code>,有如下检查</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;bk-&gt;fd==P</span><br><span class="line">P-&gt;fd-&gt;bk==P</span><br></pre></td></tr></table></figure>
<p>如果是一个<code>largebin</code>的堆块,还会有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;fd_nextsize-&gt;bk_nextsize==P</span><br><span class="line">P-&gt;bk_nextsize-&gt;fd_nextsize==P</span><br></pre></td></tr></table></figure>
<p>对于<code>smallbin</code>和<code>unsortedbin</code>,如果检查通过,则执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD-&gt;bk = BK;                                                                                                          \</span><br><span class="line">BK-&gt;fd = FD;     </span><br></pre></td></tr></table></figure>
<p>将P的前后驱连接起来</p>
<p>对于<code>largebin</code>的堆块,还会执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>)                                                                                        \</span><br><span class="line">&#123;                                                                                                                   \</span><br><span class="line">  <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                                                                          \</span><br><span class="line">    FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                                                                         \</span><br><span class="line">  <span class="keyword">else</span>                                                                                                              \</span><br><span class="line">  &#123;                                                                                                                 \</span><br><span class="line">    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                                                                               \</span><br><span class="line">    FD-&gt;bk_nextsize </span><br><span class="line">    = P-&gt;bk_nextsize;                                                                               \</span><br><span class="line">    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                                                                               \</span><br><span class="line">    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                                                                               \</span><br><span class="line">  &#125;                                                                                                                 \</span><br><span class="line">&#125;                                                                                                                   \</span><br><span class="line"><span class="keyword">else</span>                                                                                                                \</span><br><span class="line">&#123;                                                                                                                   \</span><br><span class="line">  P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                                                                     \</span><br><span class="line">  P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                                                                     \</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>完整代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD)                                                                                               \</span></span><br><span class="line"><span class="meta">  &#123;                                                                                                                         \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;                                                                                                             \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;                                                                                                             \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, 0))                                                                    \</span></span><br><span class="line"><span class="meta">      <span class="comment">//检查后继的前驱指针以及前驱的后继指针</span></span></span><br><span class="line">      malloc_printerr(check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);                                                 \</span><br><span class="line">    <span class="keyword">else</span>                                                                                                                    \</span><br><span class="line">    &#123;                                                                                                                       \</span><br><span class="line">      FD-&gt;bk = BK;                                                                                                          \</span><br><span class="line">      <span class="comment">//将前后驱堆块连接,解放P</span></span><br><span class="line">      BK-&gt;fd = FD;                                                                                                          \</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(P-&gt;size) &amp;&amp; __builtin_expect(P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>))                                       \</span><br><span class="line">      &#123;                                                                                                                     \</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>) || __builtin_expect(P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>)) \</span><br><span class="line">          malloc_printerr(check_action,                                                                                     \</span><br><span class="line">                          <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,                                                       \</span><br><span class="line">                          P, AV);                                                                                           \</span><br><span class="line">        <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>)                                                                                        \</span><br><span class="line">        &#123;                                                                                                                   \</span><br><span class="line">          <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                                                                          \</span><br><span class="line">            FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                                                                         \</span><br><span class="line">          <span class="keyword">else</span>                                                                                                              \</span><br><span class="line">          &#123;                                                                                                                 \</span><br><span class="line">            FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                                                                               \</span><br><span class="line">            FD-&gt;bk_nextsize </span><br><span class="line">            = P-&gt;bk_nextsize;                                                                               \</span><br><span class="line">            P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                                                                               \</span><br><span class="line">            P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                                                                               \</span><br><span class="line">          &#125;                                                                                                                 \</span><br><span class="line">        &#125;                                                                                                                   \</span><br><span class="line">        <span class="keyword">else</span>                                                                                                                \</span><br><span class="line">        &#123;                                                                                                                   \</span><br><span class="line">          P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                                                                     \</span><br><span class="line">          P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                                                                     \</span><br><span class="line">        &#125;                                                                                                                   \</span><br><span class="line">      &#125;                                                                                                                     \</span><br><span class="line">    &#125;                                                                                                                       \</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="topchunk申请">topchunk申请</h5>
<p>如果还不行,尝试使用topchunk分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">     (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">     search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">     less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">     be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">     limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">     MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">     exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">     reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">     to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset(victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">     here for all block sizes.  */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">  &#123;</span><br><span class="line">    malloc_consolidate(av);</span><br><span class="line">    <span class="comment">/* restore original bin index */</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">      idx = smallbin_index(nb);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      idx = largebin_index(nb);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="sysmalloc申请">sysmalloc申请</h5>
<p>如果还不行,尝试sysmalloc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="free">free</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strong_alias(__libc_free, __free) strong_alias(__libc_free, free)</span><br></pre></td></tr></table></figure>
<h4 id="libc_free">__libc_free</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __libc_free(<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p; <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (*hook)(<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *) = atomic_forced_read(__free_hook);<span class="comment">//首先尝试调用hook函数(如果有注册的话)</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>) <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk(mem);<span class="comment">//p指向堆块基址,mem指向数据区,也就是p+0x10</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">    <span class="keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">      mp_.mmap_threshold = chunksize(p);</span><br><span class="line">      mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">      LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                 mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    munmap_chunk(p);<span class="comment">//如果p堆块是mmap分配的则调用munmap释放</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk(p);</span><br><span class="line">  _int_free(ar_ptr, p, <span class="number">0</span>);<span class="comment">//调用glibc实现的_int_free,这也是默认释放过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="free_hook">__free_hook</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">weak_variable</span> <span class="params">(*__free_hook)</span><span class="params">(<span class="type">void</span> *__ptr,<span class="type">const</span> <span class="type">void</span> *)</span> = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>与<code>__malloc_hook</code>同理,如果本钩子函数有注册过则调用之进行释放,不会再调用glibc自己实现的<code>_int_free</code></p>
<h4 id="int_free">_int_free</h4>
<p>实际上调用的释放函数</p>
<h4 id="算法流程-1">算法流程</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/free.png"
alt="free" />
<figcaption aria-hidden="true">free</figcaption>
</figure>
<p>整个流程要比分配<code>_int_malloc</code>简单点</p>
<h4 id="局部变量-1">局部变量</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INTERNAL_SIZE_T size;     <span class="comment">/* its size */</span>		<span class="comment">//用于保存请求堆块的整体大小(包括元数据)</span></span><br><span class="line">mfastbinptr *fb;          <span class="comment">/* associated fastbin */</span>		<span class="comment">//fastbin桶子</span></span><br><span class="line">mchunkptr nextchunk;      <span class="comment">/* next contiguous chunk */</span>		<span class="comment">//下一个堆块</span></span><br><span class="line">INTERNAL_SIZE_T nextsize; <span class="comment">/* its size */</span>					<span class="comment">//下一个堆块的大小</span></span><br><span class="line"><span class="type">int</span> nextinuse;            <span class="comment">/* true if nextchunk is used */</span>	<span class="comment">//下一个堆块是否在使用,合并堆块时用</span></span><br><span class="line">INTERNAL_SIZE_T prevsize; <span class="comment">/* size of previous contiguous chunk */</span>	<span class="comment">//前块大小</span></span><br><span class="line">mchunkptr bck;            <span class="comment">/* misc temp for linking */</span>		<span class="comment">//头插法前后邻居</span></span><br><span class="line">mchunkptr fwd;            <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> locked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">size = chunksize(p);		<span class="comment">//size当前要申请的堆块的大小(包括元数据)</span></span><br></pre></td></tr></table></figure>
<h4 id="释放前检查">释放前检查</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">   allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">   Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">   here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect((<span class="type">uintptr_t</span>)p &gt; (<span class="type">uintptr_t</span>)-size, <span class="number">0</span>) || __builtin_expect(misaligned_chunk(p), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">errout:</span><br><span class="line">  <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">  malloc_printerr(check_action, errstr, chunk2mem(p), av);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">   multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size)))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_inuse_chunk(av, p)</span><br></pre></td></tr></table></figure>
<p>检查锁和对齐,整个释放过程可以看成一个事务,由锁保证一致性</p>
<h4 id="fastbin区释放">fastbin区释放</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast())<span class="comment">//如果释放堆块大小落在fastbin范围内</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">  If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">  bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)<span class="comment">//检查后面是否和topchunk相邻,(如果相邻需要合并,不会进入fastbin)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  )</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    &#123;<span class="comment">//首先检查堆块大小是否比最小大小要大,并且是不是可以分配的范围内</span></span><br><span class="line">      <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">         of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">         after getting the lock.  */</span></span><br><span class="line">      <span class="keyword">if</span> (have_lock || (&#123;c</span><br><span class="line">            assert(locked == <span class="number">0</span>);</span><br><span class="line">            mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">            locked = <span class="number">1</span>;</span><br><span class="line">            chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ || chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">          &#125;))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      &#123;</span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//已获得锁</span></span><br><span class="line">    free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);<span class="comment">//堆块的mem数据区清零</span></span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);<span class="comment">//计算fastbin桶子下标</span></span><br><span class="line">    fb = &amp;fastbin(av, idx);<span class="comment">//获取fastbin桶子头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;<span class="comment">//old指向fastbin对应桶子的第一个堆块</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">         (i.e., double free).  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>))<span class="comment">//检查p是否已经被刚刚释放过一次</span></span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">         size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">         only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">         deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">      <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">        old_idx = fastbin_index(chunksize(old));</span><br><span class="line">      p-&gt;fd = old2 = old;<span class="comment">//把p挂到fastbin上(头插法),fastbin[idx]-&gt;p-&gt;old-&gt;...</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect(old_idx != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆块合并">堆块合并</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p))<span class="comment">//p不能是mmap映射的</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">    &#123;</span><br><span class="line">      (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);<span class="comment">//取物理上下一个相邻的堆块基地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(p == av-&gt;top))<span class="comment">//p不能是topchunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(contiguous(av) &amp;&amp; (<span class="type">char</span> *)nextchunk &gt;= ((<span class="type">char</span> *)av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">    &#123;<span class="comment">//如果下一个堆块溢出到topchunk内部了</span></span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk)))</span><br><span class="line">    &#123;<span class="comment">//如果物理上的后块没有记录本块的释放状态</span></span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);<span class="comment">//下一个堆块的大小</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    &#123;<span class="comment">//下一堆块的大小必须在合法范围(2*SIZE_SZ,av-&gt;system_mem)之内</span></span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);<span class="comment">//p数据区清零</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p))<span class="comment">//向前合并</span></span><br><span class="line">    &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>)prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top)<span class="comment">//如果后块时topchunk则合并到topchunk,否则尝试向后合并</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse)<span class="comment">//如果后一堆块空闲则向后合并</span></span><br><span class="line">      &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">  not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">  been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      bck = unsorted_chunks(av);<span class="comment">//释放的堆块放到unsortedbin中,下一次malloc才可能重新安排新去处</span></span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))<span class="comment">//如果是largebin的堆块则现在就把fd_nextsize和bk_nextsize清零</span></span><br><span class="line">      &#123;</span><br><span class="line">        p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span><span class="comment">//此else意味着向后与topchunk相邻,则合并到topchunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD)</span><br><span class="line">    &#123;<span class="comment">//如果size大于fastbin合并阈值65536</span></span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">        malloc_consolidate(av);<span class="comment">//清空fastbin,该合并合并,放到unsortedbin或者topchunk</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena)<span class="comment">//如果是主分配区</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))<span class="comment">//如果topchunk太大了就得修剪一下</span></span><br><span class="line">          systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span><span class="comment">//否则就是非主分配区的辅助堆</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">           large, because the corresponding heap might go away.  */</span></span><br><span class="line">        heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">        assert(heap-&gt;ar_ptr == av);</span><br><span class="line">        heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">    &#123;</span><br><span class="line">      assert(locked);<span class="comment">//保证事务完整性</span></span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="mmap映射区释放">mmap映射区释放</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  munmap_chunk(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/05/31/Antlr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/31/Antlr/" class="post-title-link" itemprop="url">Antlr4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-05-31 22:31:00" itemprop="dateCreated datePublished" datetime="2023-05-31T22:31:00+08:00">2023-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-04-24 22:10:17" itemprop="dateModified" datetime="2024-04-24T22:10:17+08:00">2024-04-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="antlr4">Antlr4</h1>
<p>项目地址<a
target="_blank" rel="noopener" href="https://github.com/DeutschBall/Interpreter-Antlr">DeutschBall/Interpreter-Antlr:
Antlr实现的函数绘图语言解释器 (github.com)</a></p>
<h2 id="环境配置">环境配置</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antlr Hello.g4</span><br></pre></td></tr></table></figure>
<p>这种生成命令,实际上这里的antlr执行的命令是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java org.antlr.v4.Tool ./Hello.g4</span><br></pre></td></tr></table></figure>
<p>也就是说,org.antlr.v4.Tool应该是在CLASSPATH中的</p>
<p>在windows中需要在变量CLASSPATH中加上jar包的地址</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230524151158485.png"
alt="image-20230524151158485" />
<figcaption aria-hidden="true">image-20230524151158485</figcaption>
</figure>
<p>任何一个Antlr源文件,比如Hello.g4,如果语法没有错误,执行antlr4
Hello.g4之后,都会生成六个文件</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>HelloParser.java</td>
<td>不想写</td>
<td></td>
</tr>
<tr>
<td>HelloLexer.java</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Hello.tokens</td>
<td></td>
<td></td>
</tr>
<tr>
<td>HelloLexer.tokens</td>
<td></td>
<td></td>
</tr>
<tr>
<td>HelloListener.java</td>
<td></td>
<td></td>
</tr>
<tr>
<td>HelloBaseListener.java</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="词法分析器">词法分析器</h2>
<p>词法分析器实现,继承自org.antlr.v4.runtime.Lexer</p>
<p>这个类干了啥呢?</p>
<p>首先,<code>*Lexer.java</code>文件中是没有main函数的,这就意味着,这个类只能作为其他类的组成,或者被其他函数调用</p>
<p>从名字上看,这个类应该得有一个DFA,不管是表驱动的还是有向图驱动的还是硬编码的,得有一个输入,然后从输入中获取符号流,然后在DFA上进行状态转移,每次调用它,都应返回一个识别出的记号token</p>
<p>举个例子,统计单词数量</p>
<p>antlr语法规则文件这样写:</p>
<p><code>Counter.g4</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lexer grammar Counter;</span><br><span class="line"></span><br><span class="line">WORD: [a-zA-Z0-9]+;</span><br><span class="line">SPACE: [ \t\n\r]-&gt;skip;</span><br></pre></td></tr></table></figure>
<p>然后执行命令<code>antlr4 ./Counter.g4</code></p>
<p>由于g4文件中只定义了词法规则 lexer
grammer,因此只会生成词法分析器相关的文件</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Counter.interp</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Counter.java</td>
<td>词法分析器类</td>
<td></td>
</tr>
<tr>
<td>Counter.tokens</td>
<td>定义符号与到整数的映射</td>
<td></td>
</tr>
</tbody>
</table>
<p>生成一堆文件,其中就包括Counter.java,也就是词法分析器文件</p>
<p>这里面就一个Counter类,它干了啥呢?</p>
<p>最主要的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">_serializedATN</span> <span class="operator">=</span></span><br><span class="line">	<span class="string">&quot;\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\2\4\20\b\1\4\2\t\2&quot;</span>+</span><br><span class="line">	<span class="string">&quot;\4\3\t\3\3\2\6\2\t\n\2\r\2\16\2\n\3\3\3\3\3\3\3\3\2\2\4\3\3\5\4\3\2\4&quot;</span>+</span><br><span class="line">	<span class="string">&quot;\5\2\62;C\\c|\5\2\13\f\17\17\&quot;\&quot;\2\20\2\3\3\2\2\2\2\5\3\2\2\2\3\b\3\2&quot;</span>+</span><br><span class="line">	<span class="string">&quot;\2\2\5\f\3\2\2\2\7\t\t\2\2\2\b\7\3\2\2\2\t\n\3\2\2\2\n\b\3\2\2\2\n\13&quot;</span>+</span><br><span class="line">	<span class="string">&quot;\3\2\2\2\13\4\3\2\2\2\f\r\t\3\2\2\r\16\3\2\2\2\16\17\b\3\2\2\17\6\3\2&quot;</span>+</span><br><span class="line">	<span class="string">&quot;\2\2\4\2\n\3\b\2\2&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ATN</span> <span class="variable">_ATN</span> <span class="operator">=</span></span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">ATNDeserializer</span>().deserialize(_serializedATN.toCharArray());</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	_decisionToDFA = <span class="keyword">new</span> <span class="title class_">DFA</span>[_ATN.getNumberOfDecisions()];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; _ATN.getNumberOfDecisions(); i++) &#123;</span><br><span class="line">		_decisionToDFA[i] = <span class="keyword">new</span> <span class="title class_">DFA</span>(_ATN.getDecisionState(i), i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中有一个硬编码的static字符串,其中存放了序列化的ATN,ATN是啥?状态转移网络</p>
<p>这里_ATN这个static成员在本类的加载时,就会反序列化_serializedATN,建立ATN网络,</p>
<p>然后static静态代码块中,以ATN网络为基础建立了DFA</p>
<p>至于这个序列化ATN字符串什么含义,我不想研究,相当于硬编码的DFA</p>
<p>本类中害保存了符号名称,比如WORD,SPACE</p>
<p>本类从org.antlr.v4.runtime.Lexer基类中继承了nextToken等函数,nextToken函数每次被调用会识别一个符号</p>
<p>如何使用该类呢?</p>
<p>可以写一个测试类TestLexer.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.CharStreams;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.Token;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLexer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt_words=<span class="number">0</span>;</span><br><span class="line">        <span class="type">CharStream</span> <span class="variable">input</span> <span class="operator">=</span> CharStreams.fromString(<span class="string">&quot;public static void main&quot;</span>);</span><br><span class="line">        Counter lexer=<span class="keyword">new</span> <span class="title class_">Counter</span>(input);</span><br><span class="line">        Token token;</span><br><span class="line">        <span class="keyword">while</span>((token=lexer.nextToken()).getType()!=Token.EOF)&#123;</span><br><span class="line">            String tokenName=Counter.VOCABULARY.getSymbolicName(token.getType());</span><br><span class="line">            String tokenText=token.getText();</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s: %s%n&quot;</span>,tokenName,tokenText);</span><br><span class="line">            <span class="keyword">if</span>(tokenName==<span class="string">&quot;WORD&quot;</span>)&#123;</span><br><span class="line">                ++cnt_words;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;total words=&quot;</span>+cnt_words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从字符串"public static void
main"创建一个字符输入流,然后将这个流作为Counter lexer的输入</p>
<p>此后每次调用lexer.nextToken(),lexer都会尝试从该字符输入流中获取一个符号,符号的类型是org.antlr.v4.runtime.Token</p>
<h2 id="语法分析器">语法分析器</h2>
<p>以计算器为例</p>
<p>Calculator.g4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">grammar Calculator;</span><br><span class="line"><span class="comment">// import LexerRule;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法定义</span></span><br><span class="line">prog: stat+;</span><br><span class="line"></span><br><span class="line">stat: expr NEWLINE      </span><br><span class="line">|ID <span class="string">&#x27;=&#x27;</span> expr NEWLINE    </span><br><span class="line">|NEWLINE                </span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr: expr (<span class="string">&#x27;*&#x27;</span>|<span class="string">&#x27;/&#x27;</span>) expr   </span><br><span class="line">|expr (<span class="string">&#x27;+&#x27;</span>|<span class="string">&#x27;-&#x27;</span>) expr        </span><br><span class="line">|INT                        </span><br><span class="line">|ID                         </span><br><span class="line">|<span class="string">&#x27;(&#x27;</span> expr <span class="string">&#x27;)&#x27;</span>               </span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ID: [a-zA-Z]+;</span><br><span class="line">INT:[<span class="number">0</span>-<span class="number">9</span>]+;</span><br><span class="line">WS:[ \t\n]+ -&gt;skip;<span class="comment">//多余的空格回车忽略</span></span><br><span class="line">NEWLINE: <span class="string">&#x27;\r&#x27;</span>? <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//\r\n是win上的换行符,\r是linux上的换行</span></span><br></pre></td></tr></table></figure>
<p>执行命令<code>antlr4 ./Calculator.g4</code>之后,会在本目录下生成</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>CalculatorLexer.java</td>
<td>词法分析器类</td>
<td></td>
</tr>
<tr>
<td>CalculatorParser.java</td>
<td>语法分析器类</td>
<td></td>
</tr>
<tr>
<td>CalculatorListener.java</td>
<td>监听器接口</td>
<td></td>
</tr>
<tr>
<td>Calculator.BaseListener.java</td>
<td>监听器基类</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>...</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>写一个测试类Test,测试语法分析器的作用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.antlr.runtime.ANTLRInputStream;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.CharStreams;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.Token;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.tool.ANTLRToolListener;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String inputFile=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            inputFile=args[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        CharStream input=<span class="literal">null</span>;</span><br><span class="line">        InputStream is=System.in;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(inputFile!=<span class="literal">null</span>)&#123;</span><br><span class="line">                is=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(inputFile);</span><br><span class="line">            &#125;</span><br><span class="line">            input=CharStreams.fromStream(is);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ANTLRInputStream input=new ANTLRInputStream(is);</span></span><br><span class="line">        CalculatorLexer lexer=<span class="keyword">new</span> <span class="title class_">CalculatorLexer</span>(input);</span><br><span class="line">        CommonTokenStream tokens=<span class="keyword">new</span> <span class="title class_">CommonTokenStream</span>(lexer);</span><br><span class="line">        CalculatorParser parser=<span class="keyword">new</span> <span class="title class_">CalculatorParser</span>(tokens);</span><br><span class="line">        ParseTree tree=parser.prog();</span><br><span class="line">        </span><br><span class="line">        System.out.println(tree.toStringTree(parser));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javac Calculator*.java Test.java</span><br><span class="line">java Test <span class="string">&quot;in.dat&quot;</span></span><br><span class="line">line 6:14 missing <span class="string">&#x27;)&#x27;</span> at <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">(prog (<span class="built_in">stat</span> (<span class="built_in">expr</span> 101) \r\n) (<span class="built_in">stat</span> a = (<span class="built_in">expr</span> 5) \r\n) (<span class="built_in">stat</span> b </span><br><span class="line">= (<span class="built_in">expr</span> 3) \r\n) (<span class="built_in">stat</span> (<span class="built_in">expr</span> (<span class="built_in">expr</span> a) + (<span class="built_in">expr</span> (<span class="built_in">expr</span> b) * (<span class="built_in">expr</span> 2))) \r\n) (<span class="built_in">stat</span> (<span class="built_in">expr</span> (<span class="built_in">expr</span> ( (<span class="built_in">expr</span> (<span class="built_in">expr</span> 1) + (<span class="built_in">expr</span> a)) )) </span><br><span class="line">/ (<span class="built_in">expr</span> 2)) \r\n) (<span class="built_in">stat</span> (<span class="built_in">expr</span> (<span class="built_in">expr</span> ( (<span class="built_in">expr</span> (<span class="built_in">expr</span> 5) + (<span class="built_in">expr</span> 6)) )) * (<span class="built_in">expr</span> ( (<span class="built_in">expr</span> (<span class="built_in">expr</span> 4) + (<span class="built_in">expr</span> ( (<span class="built_in">expr</span> (<span class="built_in">expr</span> 7) - (<span class="built_in">expr</span> 8)) ))) &lt;missing <span class="string">&#x27;)&#x27;</span>&gt;)) \r\n))</span><br></pre></td></tr></table></figure>
<p>也可以不写测试类,直接使用grun测试</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator\Desktop\antlr&gt; grun Calculator prog </span><br><span class="line">-gui in.dat</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator\Desktop\antlr&gt;java org.antlr.v4.gui.TestRig Calculator prog -gui in.dat</span><br><span class="line">line 6:14 missing <span class="string">&#x27;)&#x27;</span> at <span class="string">&#x27;\r\n&#x27;</span></span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230526154940220.png"
alt="image-20230526154940220" />
<figcaption aria-hidden="true">image-20230526154940220</figcaption>
</figure>
<p>antlr会自动检测语法错误,并且会自动从错误中恢复,继续进行语法分析</p>
<h2 id="访问器">访问器</h2>
<p>前面的语法分析器中,我们并没有定义语义规则,语法树是antlr自动帮我们生成的,现在需要定义语义动作,实现计算器功能</p>
<p>antlr不推荐在g4规则文件中定义语义动作,而是在本文件中定义标签,然后在Visitor类中实现标签相关的函数</p>
<h3 id="定义语义规则标签">定义语义规则标签</h3>
<p>比如Calculator.g4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">grammar Calculator;</span><br><span class="line">// import LexerRule;</span><br><span class="line"></span><br><span class="line">// 语法定义</span><br><span class="line">prog: stat+;</span><br><span class="line"></span><br><span class="line">stat: expr NEWLINE      #printExpr</span><br><span class="line">|ID &#x27;=&#x27; expr NEWLINE    #assign</span><br><span class="line">|NEWLINE                #blank</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr: expr (&#x27;*&#x27;|&#x27;/&#x27;) expr   #MulDiv</span><br><span class="line">|expr (&#x27;+&#x27;|&#x27;-&#x27;) expr        #AddSub</span><br><span class="line">|INT                        #int</span><br><span class="line">|ID                         #id</span><br><span class="line">|&#x27;(&#x27; expr &#x27;)&#x27;               #parens</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MUL: &#x27;*&#x27;;</span><br><span class="line">DIV: &#x27;/&#x27;;</span><br><span class="line">ADD: &#x27;+&#x27;;</span><br><span class="line">SUB: &#x27;-&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ID: [a-zA-Z]+;</span><br><span class="line">INT:[0-9]+;</span><br><span class="line">WS:[ \t\n]+ -&gt;skip;//多余的空格回车忽略</span><br><span class="line">NEWLINE: &#x27;\r&#x27;? &#x27;\n&#x27;;//\r\n是win上的换行符,\r是linux上的换行</span><br></pre></td></tr></table></figure>
<p>这里的#printExpr,#assign等就是标签</p>
<p>然后使用下述命令生成</p>
<h3 id="生成访问器基类">生成访问器基类</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antlr4 -visitor Calculator.g4</span><br></pre></td></tr></table></figure>
<p>额外生成了两个文件</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>CalculatorVisitor.java</td>
<td>访问器接口</td>
</tr>
<tr>
<td>CalculatorBaseVisitor.java</td>
<td>访问器基类</td>
</tr>
</tbody>
</table>
<p>这个访问器接口定义了一些函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generated from Calculator.g4 by ANTLR 4.7.2</span></span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.ParseTreeVisitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CalculatorVisitor</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ParseTreeVisitor</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">	T <span class="title function_">visitProg</span><span class="params">(CalculatorParser.ProgContext ctx)</span>;</span><br><span class="line"></span><br><span class="line">	T <span class="title function_">visitPrintExpr</span><span class="params">(CalculatorParser.PrintExprContext ctx)</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个Calculator.g4中的标签都会对应一个接口函数,比如#printExpr对应到visitPrintExpr</p>
<p>即使是没有写标签的文法,也会对应一个接口函数,比如prog对应到visitProg</p>
<p>既然这样,为啥还要定义标签?使用默认的文法名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prog: stat+;</span><br><span class="line"></span><br><span class="line">stat: expr NEWLINE      #printExpr</span><br><span class="line">|ID <span class="string">&#x27;=&#x27;</span> expr NEWLINE    #assign</span><br><span class="line">|NEWLINE                #blank</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>对比一下,prog只有一条规则,但是stat有三条规则,因此需要给每个规则定义一个标签,方便给该规则上语义动作</p>
<p>也就是说,每一个翻译规则对应一个标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stat -&gt; expr NEWLINE      #printExpr</span><br><span class="line">stat -&gt; ID &#x27;=&#x27; expr NEWLINE    #assign</span><br><span class="line">stat -&gt; NEWLINE                #blank</span><br></pre></td></tr></table></figure>
<p>要怎么用这个访问器呢?</p>
<h3 id="定制访问器">定制访问器</h3>
<p>只需要用一个EvalVisitor继承这个CalculatorBaseVisitor,然后在EvalVisitor中实现函数功能即可</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230526161920122.png"
alt="image-20230526161920122" />
<figcaption aria-hidden="true">image-20230526161920122</figcaption>
</figure>
<p>不需要全都实现,因为CalculatorBaseVisitor中已经帮我们实现了默认方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">visitPrintExpr</span><span class="params">(CalculatorParser.PrintExprContext ctx)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> visitChildren(ctx); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以visitAssign的实现为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer <span class="title function_">visitAssign</span><span class="params">(CalculatorParser.AssignContext ctx)</span> &#123;</span><br><span class="line">    String id=ctx.ID().getText();</span><br><span class="line">    <span class="type">int</span> value=visit(ctx.expr());</span><br><span class="line">    memory.put(id,value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CalculatorParser.AssignContext ctx</code>是个什么玩意儿,都有啥成员?</p>
<h4 id="visit函数干了啥">visit函数干了啥?</h4>
<p>首先,CalculatorParser是antlr4命令生成的语法分析器类,AssignContext是其内部类</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230526170129061.png"
alt="image-20230526170129061" />
<figcaption aria-hidden="true">image-20230526170129061</figcaption>
</figure>
<p>CalculatorParser中有众多内部类,每个标签分别对应一个内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AssignContext</span> <span class="keyword">extends</span> <span class="title class_">StatContext</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> TerminalNode <span class="title function_">ID</span><span class="params">()</span> &#123; <span class="keyword">return</span> getToken(CalculatorParser.ID, <span class="number">0</span>); &#125;</span><br><span class="line">	<span class="keyword">public</span> ExprContext <span class="title function_">expr</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> getRuleContext(ExprContext.class,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> TerminalNode <span class="title function_">NEWLINE</span><span class="params">()</span> &#123; <span class="keyword">return</span> getToken(CalculatorParser.NEWLINE, <span class="number">0</span>); &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AssignContext</span><span class="params">(StatContext ctx)</span> &#123; copyFrom(ctx); &#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; T <span class="title function_">accept</span><span class="params">(ParseTreeVisitor&lt;? extends T&gt; visitor)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ( visitor <span class="keyword">instanceof</span> CalculatorVisitor ) <span class="keyword">return</span> ((CalculatorVisitor&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt;)visitor).visitAssign(<span class="built_in">this</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> visitor.visitChildren(<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个这种<code>*Context</code>内部类的实例,都是语法树上的节点,这一点可以观察*Context的类体系验证</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230526210500945.png"
alt="image-20230526210500945" />
<figcaption aria-hidden="true">image-20230526210500945</figcaption>
</figure>
<p>任何<code>*Context</code>的直接父类都是<code>ParseRuleContext</code>类,该类中有一个<code>List&lt;ParseTree&gt; children</code>数组,用来存放子节点的句柄</p>
<p>无需置疑,这就是节点类</p>
<h5
id="evalvisitorcalculatorparserparsertree三者是如何交互的">EvalVisitor,CalculatorParser,ParserTree三者是如何交互的?</h5>
<p>跟随测试类的控制流观察</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ParseTree tree=parser.prog();</span><br><span class="line">EvalVisitor eval=<span class="keyword">new</span> <span class="title class_">EvalVisitor</span>();</span><br><span class="line">eval.visit(tree);</span><br></pre></td></tr></table></figure>
<p>ParserTree以parser.prog()入口,可以推测该函数应该是整个递归下降语法分析的入口,其返回值是一个
以prog节点为根的语法树,然后将该树根交给句柄tree</p>
<p>根据我们自己写的文法,整个程序确实只有一个prog,然后是<code>prog-&gt;stat+</code>,也就是推导成若干stat</p>
<p>下面验证一下这个prog函数是否如我们所料</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ProgContext <span class="title function_">prog</span><span class="params">()</span> <span class="keyword">throws</span> RecognitionException &#123;</span><br><span class="line">	<span class="type">ProgContext</span> <span class="variable">_localctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProgContext</span>(_ctx, getState());<span class="comment">//创建Context节点,ctx是context缩写,一般__ctx表示当前上下文信息,也就是父节点</span></span><br><span class="line">       </span><br><span class="line">	enterRule(_localctx, <span class="number">0</span>, RULE_prog);<span class="comment">//进入prog文法状态</span></span><br><span class="line">	<span class="type">int</span> _la;<span class="comment">//输入中的下一个词法符号的标识</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		enterOuterAlt(_localctx, <span class="number">1</span>);</span><br><span class="line">		&#123;</span><br><span class="line">		setState(<span class="number">7</span>); </span><br><span class="line">		_errHandler.sync(<span class="built_in">this</span>);</span><br><span class="line">		_la = _input.LA(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			&#123;</span><br><span class="line">			&#123;</span><br><span class="line">			setState(<span class="number">6</span>);</span><br><span class="line">			stat();</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			setState(<span class="number">9</span>); </span><br><span class="line">			_errHandler.sync(<span class="built_in">this</span>);</span><br><span class="line">			_la = _input.LA(<span class="number">1</span>);<span class="comment">//从输入流中取下一个符号</span></span><br><span class="line">		&#125; <span class="keyword">while</span> ( (((_la) &amp; ~<span class="number">0x3f</span>) == <span class="number">0</span> &amp;&amp; ((<span class="number">1L</span> &lt;&lt; _la) &amp; ((<span class="number">1L</span> &lt;&lt; T__1) | (<span class="number">1L</span> &lt;&lt; ID) | (<span class="number">1L</span> &lt;&lt; INT) | (<span class="number">1L</span> &lt;&lt; NEWLINE))) != <span class="number">0</span>) );</span><br><span class="line">               <span class="comment">//只要下一个待解析的词法符号的类型是 T__1、ID、INT 或 NEWLINE 中的任意一种，就执行循环体中的语句</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (RecognitionException re) &#123;</span><br><span class="line">		_localctx.exception = re;</span><br><span class="line">		_errHandler.reportError(<span class="built_in">this</span>, re);</span><br><span class="line">		_errHandler.recover(<span class="built_in">this</span>, re);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		exitRule();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _localctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如我们所料,prog函数的do-while循环中调用了stat函数</p>
<p>prog= stat stat stat...</p>
<p>这个prog函数中的do-while循环,每循环一次,递归下降分析一次stat</p>
<p>为啥do-while循环的继续条件是"下一个待解析的词法符号的类型是
T__1、ID、INT 或 NEWLINE 中的任意一种，就执行循环体中的语句"</p>
<p>所有的词法符号类型都被定义在CalculatorLexer.tokens中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">T__0=<span class="number">1</span></span><br><span class="line">T__1=<span class="number">2</span></span><br><span class="line">T__2=<span class="number">3</span></span><br><span class="line">MUL=<span class="number">4</span></span><br><span class="line">DIV=<span class="number">5</span></span><br><span class="line">ADD=<span class="number">6</span></span><br><span class="line">SUB=<span class="number">7</span></span><br><span class="line">ID=<span class="number">8</span></span><br><span class="line">INT=<span class="number">9</span></span><br><span class="line">WS=<span class="number">10</span></span><br><span class="line">NEWLINE=<span class="number">11</span></span><br><span class="line"><span class="string">&#x27;=&#x27;</span>=<span class="number">1</span></span><br><span class="line"><span class="string">&#x27;(&#x27;</span>=<span class="number">2</span></span><br><span class="line"><span class="string">&#x27;)&#x27;</span>=<span class="number">3</span></span><br><span class="line"><span class="string">&#x27;*&#x27;</span>=<span class="number">4</span></span><br><span class="line"><span class="string">&#x27;/&#x27;</span>=<span class="number">5</span></span><br><span class="line"><span class="string">&#x27;+&#x27;</span>=<span class="number">6</span></span><br><span class="line"><span class="string">&#x27;-&#x27;</span>=<span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>T__1=='('</p>
<p>也就是说,下一个符号必须得是'(',或者ID,INT,NEWLINE</p>
<p>然而再看我们的语法规则定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prog: stat+;</span><br><span class="line"></span><br><span class="line">stat: expr NEWLINE      #printExpr</span><br><span class="line">|ID <span class="string">&#x27;=&#x27;</span> expr NEWLINE    #assign</span><br><span class="line">|NEWLINE                #blank</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr: expr (<span class="string">&#x27;*&#x27;</span>|<span class="string">&#x27;/&#x27;</span>) expr   #MulDiv</span><br><span class="line">|expr (<span class="string">&#x27;+&#x27;</span>|<span class="string">&#x27;-&#x27;</span>) expr        #AddSub</span><br><span class="line">|INT                        #<span class="type">int</span></span><br><span class="line">|ID                         #id</span><br><span class="line">|<span class="string">&#x27;(&#x27;</span> expr <span class="string">&#x27;)&#x27;</span>               #parens</span><br><span class="line">;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对stat求一下First集合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first(stat)=first(expr)+&#123;ID&#125;+&#123;NEWLINE&#125;=&#123;&#x27;(&#x27;,INT,ID,NEWLINE&#125;</span><br></pre></td></tr></table></figure>
<p>正好就是do-while循环的条件</p>
<p>根据编译原理的理论,只有当下一个符号在当前文法的First集合中时,才会从当前文法开始进行递归下降语法分析</p>
<p>还有一个问题,prog节点是何时把诸多stat节点设为自己的字节点的,也就是说stat节点是何时挂到语法树上的?</p>
<h5
id="stat节点何时挂到prog树根上去的">Stat节点何时挂到Prog树根上去的?</h5>
<p>到stat函数中看一看,第一行就创建了stat节点,和prog的第一行结构几乎一样,StatContext构造函数的第一个参数_ctx,这是一个全局变量,时刻维护当前节点的父节点.这样创建出的节点就知道自己的父节点是谁了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> StatContext <span class="title function_">stat</span><span class="params">()</span> <span class="keyword">throws</span> RecognitionException &#123;</span><br><span class="line">	<span class="type">StatContext</span> <span class="variable">_localctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StatContext</span>(_ctx, getState());</span><br></pre></td></tr></table></figure>
<p>这一点也可以在StatContext的构造函数中验证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StatContext</span><span class="params">(ParserRuleContext parent, <span class="type">int</span> invokingState)</span> &#123;<span class="comment">//第一个参数就叫做parent,显然是当前节点的父节点</span></span><br><span class="line">	<span class="built_in">super</span>(parent, invokingState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么stat知道自己的父节点是谁了,prog又是如何知道自己的子节点是谁的呢?</p>
<p>动态调试发现,stat函数执行后,ProgContext的Chindren数组就会多一个StatContext节点,具体怎么知道的,不想深究</p>
<h3 id="回到正题visit函数干了啥">回到正题,visit函数干了啥</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ParseTree tree=parser.prog();</span><br><span class="line">EvalVisitor eval=<span class="keyword">new</span> <span class="title class_">EvalVisitor</span>();</span><br><span class="line">eval.visit(tree);</span><br></pre></td></tr></table></figure>
<p>到现在位置,这三条的第一条分析完毕,目前tree是一个ProgContext句柄,语法树的树根</p>
<p>下面分析eval.visit(tree)干了啥</p>
<p>这个visit是AbstractParseTreeVisitor实现的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230526214154072.png"
alt="image-20230526214154072" />
<figcaption aria-hidden="true">image-20230526214154072</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">visit</span><span class="params">(ParseTree tree)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tree.accept(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个tree.accept也是一个接口方法,每一个*Context类都有实现</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230526214634187.png"
alt="image-20230526214634187" />
<figcaption aria-hidden="true">image-20230526214634187</figcaption>
</figure>
<p>就以AssignContext.accept()为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">accept</span><span class="params">(ParseTreeVisitor&lt;? extends T&gt; visitor)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ( visitor <span class="keyword">instanceof</span> CalculatorVisitor ) </span><br><span class="line">              <span class="keyword">return</span> ((CalculatorVisitor&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt;)visitor).visitAssign(<span class="built_in">this</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> visitor.visitChildren(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前节点visitor是CalculatorVisitor接口的实例,则返回visitor.visitAssign(this),也就是assign标签对应的语义动作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer <span class="title function_">visitAssign</span><span class="params">(CalculatorParser.AssignContext ctx)</span> &#123;</span><br><span class="line">    String id=ctx.ID().getText();</span><br><span class="line">    <span class="type">int</span> value=visit(ctx.expr());</span><br><span class="line">    memory.put(id,value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在知道了A.visit函数会调用EvalVisitor中当前节点对应的visitA函数</p>
<p>但是我们没有给prog-&gt;stat+定义标号,在EvalParser中并没有找到一个visitProg这样的函数,那么<code>eval.visit(tree);</code>到底调用了谁?动态调试发现调用的是CalculatorBaseVisitor类中的vistProg函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Override public T visitProg(CalculatorParser.ProgContext ctx) &#123; return visitChildren(ctx); &#125;</span><br></pre></td></tr></table></figure>
<p>而在该类中的所有vist*函数,都只是简单的递归visitChildren,访问子节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitPrintExpr</span><span class="params">(CalculatorParser.PrintExprContext ctx)</span> &#123; <span class="keyword">return</span> visitChildren(ctx); &#125;</span><br><span class="line">	<span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitAssign</span><span class="params">(CalculatorParser.AssignContext ctx)</span> &#123; <span class="keyword">return</span> visitChildren(ctx); &#125;</span><br><span class="line">	<span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitBlank</span><span class="params">(CalculatorParser.BlankContext ctx)</span> &#123; <span class="keyword">return</span> visitChildren(ctx); &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中vistAssign等被我们在EvalVisitor重写,因此不会调用父类中的简单实现</p>
<p><strong>也就是说<code>eval.visit(tree);</code>就是中心开花了,递归访问树根ProgContext的每个子节点StatContext,然后每个stat都会再递归调用自己的子节点的visit函数,文法翻译的过程就对应了这个递归调用的过程,其中语义动作的翻译,被我们重写在EvalVisitor中,会执行我们自定义的函数.其中没有语义动作的翻译,直接调用基类中的默认实现,直接递归子节点</strong></p>
<p>到此理清了CalculatorParser,EvalVisitor,ParserTree等几个类之间的关系和控制流的流向</p>
<h3
id="总结用antlr访问器实现计算器的步骤">总结用antlr访问器实现计算器的步骤</h3>
<p>1.写Calculator.g4词法,语法规则文件,留标签为定义语法做准备</p>
<p>2.用antlr -visitor命令生成Calculator*.java一众文件</p>
<p>3.EvalVisitor类继承CalculatorBaseVisitor类</p>
<p>4.在EvalVisitor类中重写标签相对应的语义规则</p>
<p>5.编写测试类Test,于其中指定输入流,组装lexer,组装
parser,建立ParserTree,用EvalVisitor实例,访问语法树实例</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/02/12/%E7%BD%91%E7%BB%9C%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/12/%E7%BD%91%E7%BB%9C%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络-网络层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-12 18:29:00 / Modified: 18:29:10" itemprop="dateCreated datePublished" datetime="2023-02-12T18:29:00+08:00">2023-02-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络层">网络层</h2>
<h3 id="ipv4">IPv4</h3>
<h4 id="ipv4地址">IPv4地址</h4>
<h5 id="早期地址分类">早期地址分类</h5>
<p>最早的IP地址被划分为五类,ABCDE</p>
<p>根据前缀区分</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208190722568.png"
alt="image-20230208190722568" />
<figcaption aria-hidden="true">image-20230208190722568</figcaption>
</figure>
<p>A类地址的网络地址占一个字节</p>
<p>整个IP地址空间的一半都是A类地址</p>
<p>B类地址的网络地址占两个字节</p>
<p>整个IP地址空间的四分之一是B类地址</p>
<p>其中A,B,C类网络地址是私有地址</p>
<h5 id="特殊ip地址">特殊IP地址</h5>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 14%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th><strong>网络号</strong></th>
<th><strong>主机号</strong></th>
<th><strong>源地址使用</strong></th>
<th><strong>目的地址使用</strong></th>
<th><strong>意义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>可以</td>
<td>不可</td>
<td>默认路径地址0.0.0.0，<br />本网络上的本主机</td>
</tr>
<tr>
<td>0</td>
<td>host-id</td>
<td>可以</td>
<td>不可</td>
<td>本网络上的某个主机</td>
</tr>
<tr>
<td>全1</td>
<td>全1</td>
<td>不可</td>
<td>可以</td>
<td>广播地址255.255.255.255，<br />只在本网络上广播（路由器不转发）<br />范围局限在LAN中,即同一子网掩码的网段内</td>
</tr>
<tr>
<td>net-id</td>
<td>全1</td>
<td>不可</td>
<td>可以</td>
<td>特定子网的广播地址，<br />对net-id上所有主机广播</td>
</tr>
<tr>
<td>127</td>
<td>非全0或全1的数</td>
<td>可以</td>
<td>可以</td>
<td>用作本地软件环回测试</td>
</tr>
<tr>
<td>169.254</td>
<td>0</td>
<td>可以</td>
<td>可以</td>
<td>主机无法获取IP地址时<br />会自动配置地址169.254.x.x/16，<br />使其可以通信</td>
</tr>
</tbody>
</table>
<h5 id="多级ip地址">多级IP地址</h5>
<p>早期的网络地址=网络号+主机号</p>
<p>然而这种划分有很多浪费,于是引入三级IP地址</p>
<p>网络地址=网络号+子网号+主机号</p>
<p>只需要给大组织分配一个A或者B类地址,然后该组织自己划分子网号即可</p>
<p>只看IP地址是看不出有没有划分过子网的</p>
<p>这就是子网掩码的作用了</p>
<p>子网掩码"掩"住的是子网前缀,比如255.255.255.0这个子网掩码,它表明只有IP地址的最后一个字节才是主机号,前面的是网络号和子网号.</p>
<p><span class="math display">\[
网络地址(原网络地址+子网地址)=IP地址 按位与 子网掩码
\]</span></p>
<p>192.168.1.0这是网络地址</p>
<p>192.168.1.255这是子网的广播地址</p>
<p>192.168.1.[1,254]这是可以给主机分配的IP地址</p>
<h5 id="子网掩码和网关">子网掩码和网关</h5>
<p>一个计算机尝试访问另一个IP地址时,会进行如下计算:</p>
<p>自己的IP地址和自己的子网掩码按位与得到自己的网络地址</p>
<p>目标的IP地址和自己的子网掩码按位与,结果与自己的网络地址比较</p>
<p>如果相同说明目标计算机是"网上邻居",同处于一个子网内,则链路层帧的目的MAC地址就会填写该目标计算机的MAC地址.如果不知道邻居的MAC地址,会使用ARP协议,根据邻居的IP地址,查邻居的MAC地址</p>
<p>如果不同说明目标不在同一子网内,需要访问"外面的世界".这就需要网关转发,于是将链路层目的MAC地址填上网关的MAC地址.</p>
<blockquote>
<p>如何获取网关的MAC地址?</p>
<p>这台计算机是有网关的IP地址的,不管是手动填上的还是DHCP获取的,反正就是有</p>
<p>然后本计算机通过ARP协议,根据网关的IP地址询问网关的MAC地址</p>
</blockquote>
<p>这就存在一种单向通的情况:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208195437212.png"
alt="image-20230208195437212" />
<figcaption aria-hidden="true">image-20230208195437212</figcaption>
</figure>
<p>192.168.3.4/16可以往192.168.1.1/24发包,并且可以被收到</p>
<p>但是192.168.1.1/24无法向192.168.3.4/16发包,</p>
<p>因为PC1@192.168.1.1经过计算,192.168.3.4是一个外网地址,但是自己没有设置网关,因此不知道应该把包发给谁</p>
<h5 id="可变长子网掩码vlsm">可变长子网掩码VLSM</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208200108836.png"
alt="image-20230208200108836" />
<figcaption aria-hidden="true">image-20230208200108836</figcaption>
</figure>
<h5 id="地址划分举例">地址划分举例</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208200145777.png"
alt="image-20230208200145777" />
<figcaption aria-hidden="true">image-20230208200145777</figcaption>
</figure>
<blockquote>
<p>分配给某一小型组织机构一个地址块，我们已知块中一个地址是205.16.37.39/28，求该块的起始地址?</p>
<p>网络前缀有28位,这就意味着IP地址的前三个字节都是固定死的205.16.37,最后这个字节的高四位是固定死的</p>
<p>39=0010'0111b,那么起始地址应该是0010'0000b,也就是32</p>
<p>因此这个网络块的起始地址是205.16.37.32</p>
<p>块的起始地址一般不会分配,作为网络地址</p>
<p>块的最后地址也不会分配,作为本块的广播地址</p>
</blockquote>
<blockquote>
<p>已给一个组织分配了17.12.14.0/26的地址块，该组织有3个部门，需要划分为32、16和16个地址的子块。</p>
<p>17.12.14.0/26这个地址空间里有<span
class="math inline">\(2^{32-26}=64\)</span>个地址,恰好划分为32+16+16</p>
<p>因此可以这样划分:</p>
<p>172.12.14.00'100000/27,即172.12.14.32/27</p>
<p>172.12.14.00'010000/28,即172.12.14.16/28</p>
<p>172.12.14.00'000000/28,即172.12.14.0/28</p>
</blockquote>
<blockquote>
<p>某单位分配到一个 B 类 IP 地址，其net-id为129.250.0.0。</p>
<p>该单位有4000台机器，平均分布在16个不同的地点。</p>
<p>如选用子网掩码为255.255.255.0，试给每一地点分配一个子网号码，</p>
<p>并计算出每个地点主机号码的最小值和最大值。</p>
<p>4000台机器均分到16个地点,则每个地点有250台,一个/24子网中最多有256-2=254台</p>
<p>因此一个255.255.255.0子网可以容纳250台机器</p>
<p>只需要将129.250.0.0/16这样划分:</p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 21%" />
<col style="width: 21%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr>
<th>子网号(Binary)</th>
<th>子网号(Decimal)</th>
<th>网络地址</th>
<th>主机IP地址范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>00000000</td>
<td>0</td>
<td>129.250.0.0/16</td>
<td>129.250.0.1~129.250.0.254</td>
</tr>
<tr>
<td>00000001</td>
<td>1</td>
<td>129.250.1.0/16</td>
<td>129.250.1.1~129.250.1.254</td>
</tr>
<tr>
<td>00000010</td>
<td>2</td>
<td>129.250.2.0/16</td>
<td>129.250.2.1~129.250.2.254</td>
</tr>
<tr>
<td>00000011</td>
<td>3</td>
<td>129.250.3.0/16</td>
<td>129.250.3.1~129.250.3.254</td>
</tr>
<tr>
<td></td>
<td></td>
<td>...</td>
<td></td>
</tr>
<tr>
<td>00001111</td>
<td>15</td>
<td>129.250.15.0/16</td>
<td>129.250.15.1~129.250.15.254</td>
</tr>
</tbody>
</table>
</blockquote>
<h4 id="nat地址转换">NAT地址转换</h4>
<table>
<thead>
<tr>
<th>NAT类型</th>
<th>映射关系</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>静态NAT</td>
<td>一个内网地址对应一个公网地址</td>
<td></td>
</tr>
<tr>
<td>动态NAT</td>
<td>多个内网地址对应多个公网地址</td>
<td></td>
</tr>
<tr>
<td>PAT</td>
<td>多个内网地址对应一个公网地址的多个端口号</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="ipv4包">IPv4包</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031183937685.png"
alt="image-20221031183937685" />
<figcaption aria-hidden="true">image-20221031183937685</figcaption>
</figure>
<p>Data用于承载运输层的协议,比如TCP,UDP</p>
<p>Header是IPv4数据报首部,其中Option为可选项,除此之外的前20个字节是固定的</p>
<h5 id="ver">VER</h5>
<p>4bits</p>
<p>IP协议的版本号,目前只有4和6两种,代表IPv4,IPv6</p>
<p>两种IP协议的首部有区别,但是接收方只要是看到这个VER字段,就可以决定后面用IPv6还是IPv4协议来解释后面的数据报了</p>
<h5 id="hlen">HLEN</h5>
<p>4bits</p>
<p>由于存在Option这个变量,为了区分首部和数据,需要维护一个值,记录IPv4数据报的首部共有多少字节.这个值就放在HLEN字段,共4位,最大是15,单位是4字节,也就是说,IPv4首部最大可以是15*4=60字节,即Option最大是40字节</p>
<p>由于首部最小是20字节,因此HLEN这个值最小是5</p>
<h5 id="service">SERVICE</h5>
<p>8bits</p>
<p>要么表示服务类型</p>
<p>要么表示区分服务</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031185352059.png"
alt="image-20221031185352059" />
<figcaption aria-hidden="true">image-20221031185352059</figcaption>
</figure>
<h6 id="服务类型">服务类型</h6>
<p>用于获得更好的服务</p>
<blockquote>
<p>注意服务类型不是高层协议类型</p>
<p>运输层上使用的是TCP还是UDP等等,是由Protocol字段决定的</p>
</blockquote>
<p>用于描述上层(运输层)的服务类型,</p>
<p>前3bits用于描述优先级</p>
<p>后1bits不使用</p>
<p>中间4bits,DTRC,用于描述服务类型</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212153218410.png"
alt="image-20230212153218410" />
<figcaption aria-hidden="true">image-20230212153218410</figcaption>
</figure>
<h6 id="差分服务">差分服务</h6>
<p>前6bits是码点子字段,后面2bits不用</p>
<p>其中码点的不同组合有不同的意义</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031185950842.png"
alt="image-20221031185950842" />
<figcaption aria-hidden="true">image-20221031185950842</figcaption>
</figure>
<h5 id="total-length">Total Length</h5>
<p>16bits</p>
<p>总长度,len(header + data),单位,字节</p>
<p>最大长度不超过<span
class="math inline">\(2^{16}=65536bytes\)</span></p>
<p>又总长度不能超过链路层规定的最大传送单元MTU,以太网(正在使用的局域网规范)该值默认是1500字节</p>
<p>以太网链路层帧限制上层的数据报长度在46~1500字节之间,不够46字节需要填充</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031194233356.png"
alt="MTU" />
<figcaption aria-hidden="true">MTU</figcaption>
</figure>
<p>也就是说链路层的协议,其Header到Trailer之间的空间有限,最大是MTU规定的大小,IP数据报必须尊重地域差异,入乡随俗</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212153927371.png"
alt="image-20230212153927371" />
<figcaption aria-hidden="true">image-20230212153927371</figcaption>
</figure>
<h5 id="identification">Identification</h5>
<p>16bits</p>
<p>一段数据由于MTU的限制,可能要分成多个包发送,本字段用来表明哪些包是同一个文件的.</p>
<h5 id="flags">Flags</h5>
<p>3bits</p>
<p>标志,用于标识该数据报是否可以分片,如果分片,是不是最后一片</p>
<p>最前面一个bit不用</p>
<p>中间一个bit是MF位,表征是否还有分片,1则还有分片,0则表明该数据报是最后一个分片</p>
<p>最后一个bit是DF位,表征是否可以分片,1不能分片,0允许分片</p>
<table>
<thead>
<tr>
<th>reserved</th>
<th>MF</th>
<th>DF</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h5 id="fragmentation-offset">Fragmentation Offset</h5>
<p>13bits</p>
<p>分片偏移,对于同一个包的分片,</p>
<p>指出较长的分组在分片后,其中一片在原分组中的编号.单位:8字节 <span
class="math display">\[
分片偏移=IP数据的第一个字节编号/8
\]</span></p>
<p><span class="math inline">\(8\times
2^{13}=2^{16}=65536bytes\)</span></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031194849825.png"
alt="image-20221031194849825" />
<figcaption aria-hidden="true">image-20221031194849825</figcaption>
</figure>
<blockquote>
<p>本机在10.177.148.9,使用ICMP协议给61.150.43.78发送3500个字节的数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;ping www.xidian.edu.cn -l 3500</span><br></pre></td></tr></table></figure>
<p>其中一组ping-pong应答:</p>
<p>去的包有三个,分别长1514,1514,587字节</p>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031201439099.png" /></p>
<p>为啥可以比mtu=1500多?因为这是整个数据报的总长度,包括了链路层的头</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031201739441.png"
alt="image-20221031201739441" />
<figcaption aria-hidden="true">image-20221031201739441</figcaption>
</figure>
<p>前两个总长度1514字节的包,实际上IPv4数据报就是1500字节,其中IPv4首部占用了20字节</p>
</blockquote>
<h5 id="time-to-live">Time to live</h5>
<p>8bits</p>
<p>生存时间TTL,用于表示最大跳数,即该包还可以通过多少个路由器转发</p>
<p>为了防止数据报在网络上无休止地被转发而占用资源.路由器在转发每个数据报之前,都会首先将其TTL减一,如果降为0,则丢弃该数据报,不再转发</p>
<h5 id="protocol">Protocol</h5>
<p>8bits</p>
<p>协议类型,用于表示上层使用的协议,也就是data中存放的是啥协议的数据报</p>
<p>常用的协议编号如下</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031192637226.png"
alt="image-20221031192637226" />
<figcaption aria-hidden="true">image-20221031192637226</figcaption>
</figure>
<h5 id="header-checksum">Header checksum</h5>
<p>16bits</p>
<p>首部检校和,咋算的呢?</p>
<p>这里的首部包含Option字段,并且首部一定是4字节对齐的,Option如果不是4字节的倍数则向上取整到4字节的倍数</p>
<p>计算方式:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031193058326.png"
alt="image-20221031193058326" />
<figcaption aria-hidden="true">image-20221031193058326</figcaption>
</figure>
<p>需要注意的是发送方最终填写的Check Sum是校验和计算值的反码</p>
<p>接收方也是将校验和计算结果取反检查是否是全零</p>
<p>比如</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031193231527.png"
alt="image-20221031193231527" />
<figcaption aria-hidden="true">image-20221031193231527</figcaption>
</figure>
<h5 id="sourcedestination-ip-address">Source/Destination IP address</h5>
<p>分别是32bits,源和目的主机的IP地址</p>
<h5 id="option">Option</h5>
<p>可以没有,最大40字节</p>
<p>首部附加选项</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031202035076.png"
alt="image-20221031202035076" />
<figcaption aria-hidden="true">image-20221031202035076</figcaption>
</figure>
<h3 id="ipv6">IPv6</h3>
<h4 id="ipv6地址">IPv6地址</h4>
<p>长128位</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208205753221.png"
alt="image-20230208205753221" />
<figcaption aria-hidden="true">image-20230208205753221</figcaption>
</figure>
<p>懒人表示法:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208210147178.png"
alt="image-20230208210147178" />
<figcaption aria-hidden="true">image-20230208210147178</figcaption>
</figure>
<p>全零的段可以只写一个0</p>
<p>连续的全零段可以用一个Gap代替,全零段之间的冒号可以省去了.但是一个IPv6地址中<strong>只能有一个Gap</strong></p>
<blockquote>
<p>为啥只能有一个GAP?看看如何还原</p>
</blockquote>
<p>带有Gap的地址如何还原?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208210408867.png"
alt="image-20230208210408867" />
<figcaption aria-hidden="true">image-20230208210408867</figcaption>
</figure>
<h4 id="ipv6包">IPv6包</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212154305058.png"
alt="image-20230212154305058" />
<figcaption aria-hidden="true">image-20230212154305058</figcaption>
</figure>
<p>IPv6头部包括固定40个字节的基础头部和可变长度的拓展头部,拓展头部的长度会在基础头部中给出</p>
<h5 id="base-header">Base Header</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212154406661.png"
alt="image-20230212154406661" />
<figcaption aria-hidden="true">image-20230212154406661</figcaption>
</figure>
<table>
<colgroup>
<col style="width: 37%" />
<col style="width: 51%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr>
<th>字段</th>
<th>作用</th>
<th>长度(bit)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Version</td>
<td>IPv6版本</td>
<td>4</td>
</tr>
<tr>
<td>Traffic Class</td>
<td>优先级,发生拥塞时分组的优先级</td>
<td>4</td>
</tr>
<tr>
<td>Flow Label</td>
<td>流标号,类似于之前的Identification</td>
<td>24</td>
</tr>
<tr>
<td>Payload Length</td>
<td>有效载荷长度,即拓展头+IP数据的长度,单位:字节</td>
<td>16</td>
</tr>
<tr>
<td>Next Header</td>
<td>指明上层协议,类似于Protocol</td>
<td>8</td>
</tr>
<tr>
<td>Hop Limit</td>
<td>TTL</td>
<td></td>
</tr>
<tr>
<td>Source/<br />Destination Address</td>
<td>源/目的地址</td>
<td>128/128</td>
</tr>
</tbody>
</table>
<h4 id="ipv4向ipv6过渡">IPv4向IPv6过渡</h4>
<p>三种过渡方法:</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr>
<th>过渡方法</th>
<th>原理</th>
</tr>
</thead>
<tbody>
<tr>
<td>双协议栈</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212155148399.png" alt="image-20230212155148399" style="zoom:25%;" /></td>
</tr>
<tr>
<td>隧道</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212155201345.png" alt="image-20230212155201345" style="zoom:25%;" /></td>
</tr>
<tr>
<td>头转换</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212155229167.png" alt="image-20230212155229167" style="zoom:25%;" /></td>
</tr>
</tbody>
</table>
<h3 id="arp">ARP</h3>
<h4 id="数据报">数据报</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101171944341.png"
alt="image-20221101171944341" />
<figcaption aria-hidden="true">image-20221101171944341</figcaption>
</figure>
<h5 id="hardware-type">Hardware Type</h5>
<p>16bits</p>
<p>链路层协议类型,以太网为1</p>
<h5 id="protocol-type">Protocol Type</h5>
<p>16bits</p>
<p>网络层协议类型,IP协议为0x0800</p>
<h5 id="hardware-length">Hardware length</h5>
<p>8bits</p>
<p>物理地址长度,比如以太网的物理地址,即MAC地址的长度就是6字节</p>
<h5 id="protocol-length">Protocol length</h5>
<p>8bits</p>
<p>逻辑地址长度,比如IPv4地址的长度就是4字节</p>
<h5 id="operation">Operation</h5>
<p>16bits</p>
<p>ARP分组类型,有两种,Request请求或者Reply应答</p>
<h5 id="四个地址">四个地址</h5>
<p>接下来是四个地址,依次是发送方的物理地址,发送方逻辑地址,接收方硬件地址,接收方逻辑地址</p>
<h4 id="抓包观察">抓包观察</h4>
<p>如图拓扑中</p>
<p>A@192.168.1.251试图ping B@192.168.1.250</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101172908748.png"
alt="image-20221101172908748" />
<figcaption aria-hidden="true">image-20221101172908748</figcaption>
</figure>
<p>在A的Ethernet0网卡上抓包</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101173100332.png"
alt="image-20221101173100332" />
<figcaption aria-hidden="true">image-20221101173100332</figcaption>
</figure>
<p>会发现首先发送和接受的并不是ICMP报文,而是arp报文,因为此时A计算机并不知道B@192.168.1.250的物理地址是多少.因此首先要问一下</p>
<p>第20帧,A向子网发送ARP广播,其报文中包括自己的物理地址,逻辑地址,目的地的逻辑地址,但是目的地址的物理地址是一个假值</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101173242804.png"
alt="image-20221101173242804" />
<figcaption aria-hidden="true">image-20221101173242804</figcaption>
</figure>
<p>第21帧,A接收到了B的单播回答</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101173435707.png"
alt="image-20221101173435707" />
<figcaption aria-hidden="true">image-20221101173435707</figcaption>
</figure>
<p>此时两个主机的物理地址,逻辑地址都已经填好了</p>
<h3 id="icmp">ICMP</h3>
<p>internet control message protocol 因特网控制协议,网络层协议</p>
<p>ICMP是<strong>网络层的协议</strong>,但是其在数据帧中的位置类似于TCP数据报的位置,都是在IPv4的data位置</p>
<h4 id="报文格式">报文格式</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101234511301.png"
alt="image-20221101234511301" />
<figcaption aria-hidden="true">image-20221101234511301</figcaption>
</figure>
<h5 id="type">Type</h5>
<p>ICMP报文分成差错报告和查询两种,体现在Type上</p>
<p>对于差错报告报文:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101234922337.png"
alt="差错报告类型" />
<figcaption aria-hidden="true">差错报告类型</figcaption>
</figure>
<p>对于查询报文:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101234949153.png"
alt="查询类型" />
<figcaption aria-hidden="true">查询类型</figcaption>
</figure>
<h5 id="code">Code</h5>
<p>代码要视报文类型决定</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101235149110.png"
alt="image-20221101235149110" />
<figcaption aria-hidden="true">image-20221101235149110</figcaption>
</figure>
<h5 id="checksum">Checksum</h5>
<p>校验和</p>
<h4 id="差错报告报文">差错报告报文</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❏  对于携带ICMP差错报文的数据报，不再生产ICMP差错报文。</span><br><span class="line">❏  对分段的数据报文，只对第一个分段产生ICMP差错报文。</span><br><span class="line">❏  对于多播地址的数据报文，不产生ICMP差错报文。</span><br><span class="line">❏ 具有特殊地址的数据报文，如127.0.0.0或者0.0.0.0，不产生ICMP差错报文。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>差错报文数据字段:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212160806776.png"
alt="image-20230212160806776" />
<figcaption aria-hidden="true">image-20230212160806776</figcaption>
</figure>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 78%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr>
<th>差错报告类型</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>目的端不可达</td>
<td>路由器无法路由或者目的主机无法传递数据时,报告目的端不可达</td>
<td></td>
</tr>
<tr>
<td>源端抑制</td>
<td>配合流量控制使用<br />路由器或者目的主机发生拥塞时,丢弃数据包,发送源端抑制</td>
<td></td>
</tr>
<tr>
<td>时间超时</td>
<td>TTL减为0时,路由器丢弃<br />或者报文的部分分片没有在有限时间抵达目的主机,由目的主机发送</td>
<td></td>
</tr>
<tr>
<td>参数问题</td>
<td>IP分组首部错误<br />路由器或者目的主机丢弃分组并发送参数问题报文</td>
<td></td>
</tr>
<tr>
<td>重定向</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212161420556.png" alt="image-20230212161420556" style="zoom:25%;" /><br />向源端报告更好的路由</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="查询报文">查询报文</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212161525556.png"
alt="image-20230212161525556" />
<figcaption aria-hidden="true">image-20230212161525556</figcaption>
</figure>
<table>
<thead>
<tr>
<th>查询报文类型</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>回送请求和回答</td>
<td>诊断网络</td>
<td>ping</td>
</tr>
<tr>
<td>时间戳请求和回答</td>
<td>确定数据报往返时间,同步</td>
<td></td>
</tr>
<tr>
<td>地址掩码请求和回答</td>
<td>获取地址对应掩码</td>
<td></td>
</tr>
<tr>
<td>路由器询问和通告</td>
<td>询问路由器是否正常工作</td>
<td>tracert</td>
</tr>
</tbody>
</table>
<h5 id="tracert">tracert</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/5337919-d1900102224993c8.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="dhcp协议">DHCP协议</h3>
<p>DHCP,Dynamic Host Configuration Protocol,动态主机地址分配协议</p>
<p>其前身是BOOTP(bootrap prottocol),引导程序协议,DHCP兼容BOOTP的功能</p>
<p>DHCP服务器有一个地址池,存放DHCP服务器可以动态分配的所有地址</p>
<h4 id="dhcp工作过程">DHCP工作过程</h4>
<p>DHCP握手分为四步,主机要离开子网的时候,只有一步</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101233453767.png"
alt="前四帧握手,最后一帧离开" />
<figcaption aria-hidden="true">前四帧握手,最后一帧离开</figcaption>
</figure>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 25%" />
<col style="width: 23%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr>
<th>DHCP报文类型</th>
<th>时机</th>
<th>方向</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Discover</td>
<td>client刚加入子网,试图索要一个ip地址</td>
<td>DHCP client--广播-&gt;DHCP servers</td>
<td>向所有DHCP server索要ip地址</td>
</tr>
<tr>
<td>Offer</td>
<td>DHCP server收到了DIscover之后</td>
<td>DHCP server--单播--&gt;DHCP client</td>
<td>所有DHCP服务器都会尝试给出一个可用的ip地址</td>
</tr>
<tr>
<td>Request</td>
<td>client收到Offer之后</td>
<td>DHCP client--广播--&gt;DHCP servers</td>
<td>client接受其中一个offer,谢绝其他offer</td>
</tr>
<tr>
<td>ACK</td>
<td>被接受offer的server收到Request之后</td>
<td>DHCP server--单播--&gt;DHCP client</td>
<td>被接受offer的server回复收到</td>
</tr>
<tr>
<td>Release</td>
<td>client将要离开子网之时</td>
<td>DHCP client--广播--&gt;DHCP servers</td>
<td>通知所有DHCP server,本client要放弃ip地址了,可以收回到ip地址池</td>
</tr>
</tbody>
</table>
<p>其中四次握手同属于一个Transaction</p>
<h3 id="路由协议">路由协议</h3>
<h4 id="路由">路由</h4>
<p>路由:从某一网络设备发出,去往某个目的地,经过的路径</p>
<p>终端计算机,路由器,三层交换机上存在路由表</p>
<p>二层交换机上只有arp表</p>
<p>根据路由的发现方式,路由可以分成三种</p>
<p>直连路由:路由器自主发现相连端口的网络的路由</p>
<p>静态路由:人工维护路由表</p>
<p>动态路由:可周期性更新</p>
<h4 id="路由表">路由表</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221107110756489.png"
alt="image-20221107110756489" />
<figcaption aria-hidden="true">image-20221107110756489</figcaption>
</figure>
<p>子网掩码</p>
<p>网络地址</p>
<p>下一跳地址</p>
<p>朝向下一跳的端口</p>
<blockquote>
<p>比如网络拓扑长这样</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212162804137.png"
alt="image-20230212162804137" />
<figcaption aria-hidden="true">image-20230212162804137</figcaption>
</figure>
<p>其中R1路由表长这样</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212162818521.png"
alt="image-20230212162818521" />
<figcaption aria-hidden="true">image-20230212162818521</figcaption>
</figure>
<p>如果图22.6中的一个目的地址为180.70.65.140的分组到达路由器R1，说明其转发过程。</p>
<p>180.70.65.140这个地址属于180.70.65.128/25网段,因此应该从m0口出去</p>
<p>首先路由器会在180.70.65.128/25网段中使用ARP协议获得下一跳的MAC地址,然后将IP分组转发给下一跳</p>
</blockquote>
<h5 id="netstat--r">netstat -r</h5>
<p>在win或者linux主机上使用netstat -r命令即可查看本机的路由表</p>
<p>比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135]</span><br><span class="line">└─# netstat -r</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line">default         Executor        0.0.0.0         UG        0 0          0 eth0</span><br><span class="line">172.29.112.0    0.0.0.0         255.255.240.0   U         0 0          0 eth0</span><br></pre></td></tr></table></figure>
<table style="width:100%;">
<colgroup>
<col style="width: 6%" />
<col style="width: 18%" />
<col style="width: 11%" />
<col style="width: 19%" />
<col style="width: 8%" />
<col style="width: 16%" />
<col style="width: 6%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr>
<th>栏目</th>
<th>Destination</th>
<th>Gateway</th>
<th>Genmask</th>
<th>Flags</th>
<th>MSS Window</th>
<th>irtt</th>
<th>Iface</th>
</tr>
</thead>
<tbody>
<tr>
<td>意义</td>
<td>目的地址</td>
<td>网关</td>
<td>目的地址掩码</td>
<td></td>
<td></td>
<td></td>
<td>目标端口</td>
</tr>
</tbody>
</table>
<p>在eNSP路由器上用display ip
routing-table也可以查看该路由器的路由表</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Huawei]display ip routing-table</span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 2        Routes : 2        </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br></pre></td></tr></table></figure>
<p>两者的主要区别就是这个NextHop</p>
<p>主机的网卡不需要下一跳地址,只需要维护一个网关的地址</p>
<p>路由器需要维护下一条的地址</p>
<h5 id="最长掩码匹配">最长掩码匹配</h5>
<p>从路由表中选择具有最长掩码的路由</p>
<p>掩码越长,地址块越小,路由越具体</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212163420071.png"
alt="image-20230212163420071" />
<figcaption aria-hidden="true">image-20230212163420071</figcaption>
</figure>
<p>假如R2路由器收到了一个目的地址为140.24.7.192的地址,</p>
<p>该目的地址即属于140.24.7.192/26网段,</p>
<p>又属于140.24.7.0/24网段,</p>
<p>应该发往最长具有掩码的网段,即140.24.7.192/26</p>
<h5 id="地址聚合">地址聚合</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212163621450.png"
alt="image-20230212163621450" />
<figcaption aria-hidden="true">image-20230212163621450</figcaption>
</figure>
<h5 id="默认路由">默认路由</h5>
<p>默认路由就这种</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221107113423289.png"
alt="image-20221107113423289" />
<figcaption aria-hidden="true">image-20221107113423289</figcaption>
</figure>
<p>子网掩码是0,意味着默认路由在路由表中排在最后,也就是最后的选择.</p>
<p>只要是前面都失配的包都会从默认路由这里匹配成功.该条记录只需要记录从本路由器中的哪个端口出去,下一条是谁</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221107113605164.png"
alt="image-20221107113605164" />
<figcaption aria-hidden="true">image-20221107113605164</figcaption>
</figure>
<p>比如这里的B路由器,除了10.1.0.0/24,其他的包只能发往C路由器,于是B-&gt;C这条路由就是B的默认路由</p>
<h4 id="路由协议优先级">路由协议优先级</h4>
<p>直连路由的优先级最高,因为 其最可靠</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221107112300287.png"
alt="image-20221107112300287" />
<figcaption aria-hidden="true">image-20221107112300287</figcaption>
</figure>
<p>IP路由表为路由器实际工作时使用的路由表</p>
<p>建立该表的过程中可能考虑了很多路由协议,比如RIP,OSPF,对于同一个Destination的路由记录,优先使用高优先级路由协议给出的路由记录</p>
<p>比如之类对于24.10.0/24这个地址,RIP和OSPF两种协议给出了不同的下一跳,必然有优劣.由于OSPF协议的优先级高,最终写入IP路由表的,来自OSPF协议</p>
<h4 id="路由算法">路由算法</h4>
<h5 id="dijkstra">dijkstra</h5>
<p>边权是链路代价,两节点不连接时链路代价为无穷大</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212163803322.png"
alt="image-20230212163803322" />
<figcaption aria-hidden="true">image-20230212163803322</figcaption>
</figure>
<p>符号约定:</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>已经"拓展"的节点集合</td>
</tr>
<tr>
<td>N</td>
<td>网络中的节点集合</td>
</tr>
<tr>
<td>s</td>
<td>源点</td>
</tr>
<tr>
<td>w(i,j)</td>
<td>从i到j节点的链路代价</td>
</tr>
<tr>
<td>L(i)</td>
<td>目前从源点s到i节点的最小代价</td>
</tr>
</tbody>
</table>
<p>以1号节点为起点,计算其与其他所有点的最短距离</p>
<p>计算过程:</p>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 22%" />
<col style="width: 7%" />
<col style="width: 5%" />
<col style="width: 7%" />
<col style="width: 8%" />
<col style="width: 7%" />
<col style="width: 5%" />
<col style="width: 7%" />
<col style="width: 6%" />
<col style="width: 7%" />
<col style="width: 8%" />
</colgroup>
<thead>
<tr>
<th>Iter</th>
<th><em>T</em></th>
<th><em>L</em>(2)</th>
<th>Path</th>
<th><em>L</em>(3)</th>
<th>Path</th>
<th><em>L</em>(4)</th>
<th>Path</th>
<th><em>L</em>(5)</th>
<th>Path</th>
<th><em>L</em>(6)</th>
<th>Path</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>{1}</td>
<td>2</td>
<td>1-2</td>
<td>5</td>
<td>1-3</td>
<td>1</td>
<td>1-4</td>
<td>∞</td>
<td>-</td>
<td>∞</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>{1,4}</td>
<td>2</td>
<td>1-2</td>
<td>4</td>
<td>1-4-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>∞</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>{1, 2, 4}</td>
<td>2</td>
<td>1-2</td>
<td>4</td>
<td>1-4-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>∞</td>
<td>-</td>
</tr>
<tr>
<td>4</td>
<td>{1, 2, 4, 5}</td>
<td>2</td>
<td>1-2</td>
<td>3</td>
<td>1-4-5-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>4</td>
<td>1-4-5-6</td>
</tr>
<tr>
<td>5</td>
<td>{1, 2, 3, 4, 5}</td>
<td>2</td>
<td>1-2</td>
<td>3</td>
<td>1-4-5-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>4</td>
<td>1-4-5-6</td>
</tr>
<tr>
<td>6</td>
<td>{1, 2, 3, 4, 5, 6}</td>
<td>2</td>
<td>1-2</td>
<td>3</td>
<td>1-4-5-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>4</td>
<td>1-4-5-6</td>
</tr>
</tbody>
</table>
<h5 id="bellmanford">bellmanford</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212163803322.png"
alt="image-20230212163803322" />
<figcaption aria-hidden="true">image-20230212163803322</figcaption>
</figure>
<p><span
class="math inline">\(L_h(i)\)</span>从源点到i点,最多经过h条链路时,最小链路代价和</p>
<p>计算过程</p>
<table style="width:100%;">
<colgroup>
<col style="width: 5%" />
<col style="width: 11%" />
<col style="width: 5%" />
<col style="width: 11%" />
<col style="width: 9%" />
<col style="width: 11%" />
<col style="width: 5%" />
<col style="width: 11%" />
<col style="width: 7%" />
<col style="width: 11%" />
<col style="width: 9%" />
</colgroup>
<thead>
<tr>
<th><em>h</em></th>
<th><span class="math inline">\(L_h(2)\)</span></th>
<th>Path</th>
<th><span class="math inline">\(L_h(3)\)</span></th>
<th>Path</th>
<th><span class="math inline">\(L_h(4)\)</span></th>
<th>Path</th>
<th><span class="math inline">\(L_h(5)\)</span></th>
<th>Path</th>
<th><span class="math inline">\(L_h(6)\)</span></th>
<th>Path</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>∞</td>
<td>-</td>
<td>∞</td>
<td>-</td>
<td>∞</td>
<td>-</td>
<td>∞</td>
<td>-</td>
<td>∞</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>1-2</td>
<td>5</td>
<td>1-3</td>
<td>1</td>
<td>1-4</td>
<td>∞</td>
<td>-</td>
<td>∞</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>1-2</td>
<td>4</td>
<td>1-4-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>10</td>
<td>1-3-6</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>1-2</td>
<td>3</td>
<td>1-4-5-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>4</td>
<td>1-4-5-6</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>1-2</td>
<td>3</td>
<td>1-4-5-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>4</td>
<td>1-4-5-6</td>
</tr>
</tbody>
</table>
<h4 id="动态路由协议">动态路由协议</h4>
<p>动态路由协议的目的:</p>
<p>知道有哪些邻居路由器；</p>
<p>能够学习到网络中有哪些网段；</p>
<p>能够学习到至某个网段的所有路径；</p>
<p>能够从众多的路径中选择最佳的路径；</p>
<p>能够维护和更新路由信息。</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221114110756904.png"
alt="image-20221114110756904" />
<figcaption aria-hidden="true">image-20221114110756904</figcaption>
</figure>
<h5 id="自治系统">自治系统</h5>
<p>每个自治系统内部使用一套相同的路由协议,同级的自治系统使用同一套路由协议,自治系统可以嵌套自治系统</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212170909097.png"
alt="image-20230212170909097" />
<figcaption aria-hidden="true">image-20230212170909097</figcaption>
</figure>
<p>每个自治系统都要分配一个AS号,用于路由</p>
<p>本级自治系统只负责将本级的IP分组发往本级目标自治系统,剩下具体发往目标AS中的哪一台主机,<strong>由该AS内部的路由协议自己决定</strong></p>
<h5 id="rip-on-距离向量算法">RIP on 距离向量算法</h5>
<p>RIP协议基于距离向量协议</p>
<p>RIP协议中的距离或者说代价,就是跳数</p>
<p>Distance vector,距离向量算法</p>
<p>每个节点都有一个</p>
<h6 id="初始化">初始化</h6>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221114110945325.png"
alt="image-20221114110945325" />
<figcaption aria-hidden="true">image-20221114110945325</figcaption>
</figure>
<p>最初的拓扑中,每个路由器都只知道与自己直连的路由器.其路由表中只有这些路由器的信息</p>
<p>比如D实际上式不知道B的存在的,它只知道A的存在.上图中的D的路由表中画出
BCE,但是距离是<span
class="math inline">\(\infin\)</span>,就相当于不知道它的存在</p>
<h6 id="共享路由信息距离向量更新">共享路由信息&amp;距离向量更新</h6>
<p>周期共享</p>
<p>每个结点都会将自己知道的所有都告诉邻居</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221114111341938.png"
alt="image-20221114111341938" />
<figcaption aria-hidden="true">image-20221114111341938</figcaption>
</figure>
<p>这里C共享给A的所有信息都要代价+2,这是AC之间的边权</p>
<p>C发往A的所有信息,其Next都是C,意思是,如果A需要使用该表中的一些信息,一定是C的贡献,届时A会以C作为下一跳发送相应数据包</p>
<p>A的老路由表和加上AC边权代价之后的C共享表进行比较,每一条路由都取Cost最小值,得到新路由表</p>
<h6 id="缺点">缺点:</h6>
<p>两个节点的不稳定性</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221114111751153.png"
alt="image-20221114111751153" />
<figcaption aria-hidden="true">image-20221114111751153</figcaption>
</figure>
<p>当A与X之间的链路断开后,A到X的距离成为无穷大,如果因为丢包等原因,A没有及时通知B,X已经断开了,那么B就一直认为B-&gt;A-&gt;X这条链路正常.当B给A交换路由信息的时候,A又认为B还有其他通路到X(实际上就是之前的链路).于是A有到X的包就会发往B,B又发往A,A又发往B...</p>
<p>三个节点的不确定性:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212172241217.png"
alt="image-20230212172241217" />
<figcaption aria-hidden="true">image-20230212172241217</figcaption>
</figure>
<p>X已经不和ABC连接了,A一开始也是知道X已经离开的,但是经过共享后,ABC都糊涂了</p>
<h6 id="基于距离向量的rip协议">基于距离向量的RIP协议</h6>
<p>就是将链路代价换成跳数</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212173742433.png"
alt="image-20230212173742433" />
<figcaption aria-hidden="true">image-20230212173742433</figcaption>
</figure>
<h5 id="ospf-on-链路状态路由选择算法">OSPF on 链路状态路由选择算法</h5>
<p>链路状态:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212182013525.png"
alt="image-20230212182013525" />
<figcaption aria-hidden="true">image-20230212182013525</figcaption>
</figure>
<p>每个节点都知道一些链路信息,比如链路代价,连接状态</p>
<p>每个节点都会字节建立一张路由表,通过洪范向其他节点广播状态</p>
<p>每个节点自己构建一个最短路径树,并以此构建路由表</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212182406755.png"
alt="image-20230212182406755" />
<figcaption aria-hidden="true">image-20230212182406755</figcaption>
</figure>
<p>最短路径树:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212182518356.png"
alt="image-20230212182518356" />
<figcaption aria-hidden="true">image-20230212182518356</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/02/12/%E5%BA%94%E7%94%A8%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/12/%E5%BA%94%E7%94%A8%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络-应用层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-12 18:28:00 / Modified: 18:29:11" itemprop="dateCreated datePublished" datetime="2023-02-12T18:28:00+08:00">2023-02-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="应用层">应用层</h1>
<p>[TOC]</p>
<h2 id="应用层概览">应用层概览:</h2>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/3b83510e49c73908a1d9433b7e14bccc.png"
alt="image-20220115220640203" />
<figcaption aria-hidden="true">image-20220115220640203</figcaption>
</figure>
<p><strong>熟知端口号:应用层协议在服务端的==默认==端口号,客户端端口号随意</strong></p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/8cbd969af94815b2a77969b48c049707.png" /></p>
<h2 id="网络应用模型">网络应用模型</h2>
<h3 id="客户服务器模型">客户/服务器模型</h3>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/32549a6e2bec5e8e8adbb7c6c645d055.png"
alt="image-20220115215144534" />
<figcaption aria-hidden="true">image-20220115215144534</figcaption>
</figure>
<h4 id="工作流程">工作流程:</h4>
<p>1.服务器处于接收请求的状态</p>
<p>2.客户机发出服务请求,等待接收结果</p>
<p>3.服务器收到请求后分析请求,进行必要的处理,返回给客户端</p>
<p>客户端必须事先直到服务端的IP地址,这通过DNS解析完成</p>
<p>服务端处于被动状态,谁来了给谁服务,不来的不管</p>
<h4 id="特点">特点:</h4>
<p>1.计算机第位不对等,服务器可以限制用户权限,比如ftp协议中ftp服务器可以设置管理员Administrator拥有读写的权力,但是匿名用户只有读的权力</p>
<p>2.客户机之间不直接通信</p>
<p>3.可拓展性差,服务器性能决定一切,服务器能力有限,想要服务更多的用户需要更强的服务器</p>
<h3 id="p2p模型">P2P模型</h3>
<p>peer to peer</p>
<p>这个2的英语是two与to同音</p>
<p>(曾经)比较流行的p2p应用有 电驴 等等</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/9781d4260d4e18bd79619b14134d7389.png"
alt="image-20220115215157997" />
<figcaption aria-hidden="true">image-20220115215157997</figcaption>
</figure>
<h4 id="特点-1">特点</h4>
<p>1.计算机第位对等,任意一对计算机可以直接通信,减轻了服务器的压力,提高了效率和资源利用率</p>
<blockquote>
<p>P2P模型实质上依然是C/S方式,A与B通信时A发送消息,B接收消息,A就是客户端,B就是服务端.</p>
<p>只不过没有了专门的服务器一说</p>
</blockquote>
<p>2.可拓展性好</p>
<p>3.网络健壮性强,单个节点失效一般不会影响其他部分</p>
<p>4.拥塞网络等缺点导致目前ISP(Internet Server
Provider互联网服务供应商)对P2P模式持反对态度</p>
<h2 id="域名系统dns">域名系统(DNS)</h2>
<p>domain name system</p>
<p>采用客户/服务器模型,协议运行在UDP之上,采用53号端口</p>
<h3 id="层次域名空间">层次域名空间</h3>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/0523696b731624567596ee5ee0e43614.png" /></p>
<blockquote>
<p>域名命名规则</p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/5c5251f0e93aaed372842f55a4ccd2ba.png" /></p>
</blockquote>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/682ab6339aec5c26d7dff29abc2e0285.png" /></p>
<h3 id="域名服务器">域名服务器</h3>
<p>域名系统实际上是一个联机分布的数据库系统,采用C/S模型</p>
<p>域名到IP地址的解析实在域名服务器完成的</p>
<p>一个域名服务器所管辖的域名范围称为区,同一个区中的各个节点一定联通</p>
<p>每个区设置相应的权限域名服务器,保存该区中所有计算机域名到IP地址的映射</p>
<p>每个域名服务器还应当有连向其他域名服务器的信息,当某个域名不在自己的管辖范围内时本域名服务器应当知道去哪里解析</p>
<h3 id="域名服务器的组织方式">域名服务器的组织方式</h3>
<p>域名服务器以层次方式组织</p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/8c08cd3b1c1fbb14a0ab547cb765e8fb.png" /></p>
<h4 id="根域名服务器">根域名服务器</h4>
<p>最高层次的域名服务器,根域名服务器知道所有顶级域名服务器的IP地址</p>
<p>当本地域名服务器无法解析时首先询问根域名服务器</p>
<p>根域名服务器告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询</p>
<h4 id="顶级域名服务器">顶级域名服务器</h4>
<p>管辖在该顶级域名服务器下注册的所有二级域名</p>
<p>当收到其他服务器的DNS查询请求时返回当前域名或者下一级域名服务器的IP地址</p>
<h4 id="授权域名服务器">授权域名服务器</h4>
<p>==每台主机==都必须在授权域名服务器处登记</p>
<p>为了可靠性,一台主机最好有两个以上的授权域名服务器(类似于留多个联系方式,方便找你)</p>
<p>许多域名服务器同时充当本地域名服务器和授权域名服务器</p>
<blockquote>
<p>这句话我的理解是==路由器==</p>
<p>即充当本地主机向外网发起DNS查询请求的本地域名服务器的功能,</p>
<p>又起到了外网查询本机IP的授权域名服务器的功能</p>
</blockquote>
<h4 id="本地域名服务器">本地域名服务器</h4>
<blockquote>
<p>个人感觉类似局域网的域名服务器</p>
</blockquote>
<p>任何主机发出DNS查询请求时都需要首先送到本地域名服务器</p>
<p>本地链接填写的IP地址就是本地域名服务器地址</p>
<p>本地域名服务器记录根域名服务器的地址</p>
<h3 id="解析器">解析器</h3>
<p>域名解析是把域名映射为IP地址或者把IP地址映射为域名的过程.</p>
<p>当客户端需要域名解析时,本地DNS客户端构造一个DNS请求报文以UDP数据包方式发往本地域名服务器</p>
<p>正向解析:域名映射为IP地址</p>
<p>反向解析:IP地址映射为域名</p>
<p>解析方式有两种:递归查询和递归与迭代相结合的查询</p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/8c026d23dfadc4803f73767aead7b400.png" /></p>
<h4
id="递归解析过程解析y.abc.com的ip地址">递归解析过程解析y.abc.com的IP地址</h4>
<p>1.主机首先查询本机的高速缓存,没有找到y.abc.com的查询记录,于是将DNS解析请求报文发送给本地域名服务器.</p>
<p>2.本地域名服务器首先检查高速缓存,没有找到y.abc.com的查询记录,于是将DNS解析请求报文发送给根域名服务器</p>
<p>3.根域名服务器首先检查高速缓存,没有找到y.abc.com的查询记录,于是将DNS解析请求报文发送给.com顶级域名服务器</p>
<p>4..com顶级域名服务器高速缓存也没有,于是将DNS解析请求报文发送给.abc.com权限域名服务器</p>
<p>5..abc.com权限域名服务器下恰好有一个注册域名为y.abc.com的主机,于是返回该主机的IP地址给上级.com顶级域名服务器</p>
<p>6..com顶级域名服务器收到.abc.com权限域名服务器的返回IP之后将该IP再返回给根域名服务器,同时在高速缓存中记录该查询记录,方便下次查询时避免递归</p>
<p>7.根域名服务器将.com返回的IP地址再返回给本地域名服务器,同时在高速缓存中记录该查询</p>
<p>8.本地域名服务器收到根域名服务器返回的IP地址,将该IP地址返回给发起请求的主机,并在高速缓存中记录该查询</p>
<p>9.发起请求的主机最终得到了y.abc.com的IP地址,并在本机的高速缓存中记录该查询</p>
<blockquote>
<p>高速缓存的作用?</p>
<p>如果主机刚才已经查询过y.abc.com的IP地址并且存储于高速缓存中,那么==不久后==的再次查询就可以直接从高速缓存中取记录,而不用再递归一大圈去找这个IP地址</p>
<p>为什么每一级服务器都需要高速缓存?</p>
<p>类似于记忆化搜索,本地域名服务器不一定只服务于一台主机,如果主机A,B都由本地域名服务器S提供服务,假设A解析了主机C,S会将C的IP地址存在高速缓存中,那么当B也需要查询C时本地域名服务器只需要返回刚才的记录</p>
</blockquote>
<p>缺点:</p>
<p>不考虑高速缓存的作用,每一次跨本地域名服务器的DNS查询都需要根域名服务器的介入,而世界上只有13台根服务器,但是却要面对上亿的主机和查询,根服务器将会不堪重负</p>
<p>改进方法:递归+迭代</p>
<h4
id="递归与迭代相结合的解析过程解析y.abc.com的ip地址">递归与迭代相结合的解析过程解析y.abc.com的IP地址</h4>
<p>本地主机还是以解析y.abc.com的IP地址为例子,假设路径上服务器的高速缓存都没有存储该查询记录</p>
<p>1.本机向本地域名服务器发起DNS查询报文</p>
<p>2.本地域名服务器发现该DNS不在局域网内,需要向外网寻找,于是直接向根域名服务器发出请求</p>
<p>3.根服务器返回.com顶级服务器的IP地址</p>
<p>4.本地域名服务器收到.com的IP地址后向该.com顶级域名服务器发送请求</p>
<p>5..com顶级域名服务器返回.abc.com授权域名服务器地址</p>
<p>6.本地域名服务器收到.abc.com的IP地址后向该授权域名服务器发送请求</p>
<p>7..abc.com授权域名服务器返回y.abc.com的IP地址</p>
<p>8.本地域名服务器已经获得了y.abc.com的IP地址"我滴任务完成辣!啊哈哈哈哈",然后将该IP地址返回给发起请求的本机</p>
<p>相对于递归方式,递归+迭代的方式中,根服务器,顶级域名服务器等被询问的服务器都没法在高速缓存上记录这次查询,因为他们都是的==指路人==而不是==带路人==的作用.</p>
<h2 id="文本传输协议ftp">文本传输协议FTP</h2>
<p>File Transfer Protocol,因特网上使用最广泛的文件传输协议</p>
<p>功能:</p>
<p>1.兼容:不同种类(包括硬件软件)主机系统之间传输文件</p>
<p>2.权限:以用户权限管理的方式提供用户对远程FTP服务器上的文件管理能力</p>
<p>3.匿名共享:匿名FTP方式提供公用文件共享的negligence</p>
<h3 id="ftp工作原理">FTP工作原理</h3>
<p>采用C/S工作方式,使用TCP可靠的传输服务.</p>
<p>一个FTP服务器进程可以同时为多个客户进程提供服务(分时系统?)</p>
<p>FTP服务器进程分两大部分:</p>
<p>主进程:接受新的请求,处于一直监听的状态,只要有新的进程就立刻开一个从属进程来啊处理该请求</p>
<p>从属进程:处理单个请求</p>
<p>以主机A下载<code>ftp://ftp.abc.edu.cn/file</code>为例子描述工作过程</p>
<p>1.服务端开放21号端口,并监听这个端口,等待客户连接.</p>
<p>2.客户端开放随意端口连接到服务端的21号端口,建立控制连接</p>
<p>3.客户端通过控制连接发送下载文件的请求</p>
<blockquote>
<p>控制信息时7位ASCII码格式</p>
<p>控制连接只用来控制,不用来传输</p>
<p>数据连接和控制连接并行,即使是传输过程中也可以通过控制连接发送停止请求中止数据传输</p>
</blockquote>
<p>4.服务端接收到文件传输请求后,创建"数据传输进程"和"数据连接",在20号端口与客户端的任意端口(区别于客户端刚才开放的控制连接端口)建立数据连接并且传输客户端请求的文件</p>
<p>5.当客户端的一次数据传输请求被满足时,服务端立刻关闭20端口,断开数据连接.控制连接继续接收用户的传输请求</p>
<h3 id="ftp服务特点">FTP服务特点:</h3>
<p>1.提供不同种类的主机系统之间的文件传输能力</p>
<p>2.以用户权限管理的方式提供用户对远程FTP服务器上的文件的管理能力</p>
<p>3.以匿名FTP方式提供公用文件共享的能力.匿名用户只能从FTP服务器拷贝文件,不能上传或者修改文件,即只读模式</p>
<p>4.使用TCP协议.</p>
<p>5.一个FTP服务器进程可以同时为多个客户进程提供服务</p>
<p>6.带外传送,使用两种连接,控制连接和数据连接.分别占用21和20端口,其中数据连接传送完毕之后立刻断开,控制连接一直持续</p>
<p>7.服务器必须追踪用户在远程目录树上的当前位置</p>
<h2 id="电子邮件">电子邮件</h2>
<h3 id="组成结构">组成结构</h3>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/ac055e43baff6eafbde1f574ff0b617f.png" /></p>
<p>异步通信方式,通信时双方都不需要在场</p>
<p>发送和接收实际是由邮件服务器完成的</p>
<p>用户的工作是通过用户代理命令邮件服务器完成工作</p>
<h4 id="用户代理">用户代理:</h4>
<p>User Agent</p>
<p><strong>"用户与电子邮件系统的接口"</strong></p>
<p>说人话就是电子邮箱,比如qq邮箱.</p>
<blockquote>
<p>用户发送邮件时在网络上的形象</p>
<p>人类在工作时的形象是工人,人类在教书时的形象是老师,人类在发送邮件时的形象是邮箱</p>
</blockquote>
<p>显然这个用户代理能够实现人类希望的,最起码的写信,显示,处理信的功能</p>
<h4 id="邮件服务器">邮件服务器</h4>
<blockquote>
<p>电子邮件系统中的工具人儿,是用户代理的奴仆</p>
</blockquote>
<p>作用是:</p>
<p>1.收发邮件</p>
<p>2.向用户代理报告邮件传送情况</p>
<p>采用C/S方式工作</p>
<p>一个邮件服务器本身是双料高级特工,在它==发送邮件时他是客户端C,==在它==接收邮件的时候,它是服务端S==</p>
<blockquote>
<p>用实际生活中收发邮件做一个类比</p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/082dfb6a4adc8633ff832af17b26042c.png" /></p>
<p>实际生活中接收邮件是比较类似于网上这一套的,每天早上我们起床之后出门检查一下私人邮箱里面是否有东西,从家里走出来到邮箱取邮件这一段是我们亲历亲为的,没法生动地解释用户代理这个概念</p>
<p>并且对于发送邮件,实际生活中我们需要跑好远到邮局或者偶遇邮递员送信,但是网络上我们却用的与收信相同的邮箱.这是天壤之别.</p>
<p>为了方便理解这件事,我们虚构一个"现实":</p>
<p>1.我家有矿,收发邮件这种琐事怎么可能由我自己跑腿?雇一个管家专门代替我从屋门到邮箱这两三步的距离.</p>
<p>并且我不识字儿,写信也是我口述,管家代笔,我说错了要改,管家也不会烦,无条件服从我的命令.</p>
<p>收信我也不自己看,管家念给我听.</p>
<p>附近邻居家的情况与我相同</p>
<p>这个管家就比较类似与用户代理了</p>
<p>2.邮箱是==公共的==,并且这个邮箱好大,为每个用户都留了存放信件的地方,周围的邻居收发信件都通过这个邮箱,</p>
<p>每个邮箱都是邮局的功能,我发邮件不需要到邮局发,我只需要让管家写好信放在邮箱里.</p>
<p>每隔一段时间邮箱就会自己检查有没有待发送的邮件,</p>
<p>如果有,则召唤邮递员,让邮递员先不送信,屁颠屁颠地跑到目的地看看沿路能不能通,对方的邮箱能不能接收邮件</p>
<p>邮递员逛一圈回来报告都没有问题,邮箱就让邮递员正式送信</p>
<p>邮递员不管送信成功失败都会回来报告给邮箱,并且说明原因</p>
<p>3.邮箱有关于我的消息,比如新的邮件到达或者我发送的邮件成功或者失败等,==不会提醒我==.</p>
<p>只有当我想要了解邮箱有关我的状态时才会吩咐==管家==去邮箱看看==我的那一部分==,回来把消息说给我</p>
<p>这个邮箱就比较类似于邮件服务器了</p>
</blockquote>
<p><strong>记发送端邮件服务器为"客户端"</strong></p>
<p><strong>记接收端邮件服务器为"服务端"</strong></p>
<p>==这两句很重要==</p>
<h4 id="邮件发送协议smtp">邮件发送协议SMTP</h4>
<p>Simple Mail Transfer Protocol简单邮件传输协议</p>
<p>使用C/S方式,发送方为客户端,接收方为服务端.</p>
<p>使用TCP连接,接收方服务器开放端口号25</p>
<blockquote>
<p>浏览器与基于万维网的邮件服务器(Gmail等)之间的邮件发送使用的是HTTP,相同的邮件服务器之间也是HTTP</p>
<p>只有不同邮件服务器之间传送邮件的时候才使用SMTP协议</p>
</blockquote>
<h5 id="多用途国际邮件扩充mime">多用途国际邮件扩充(MIME)</h5>
<p>SMTP只能传送ASCII码,无法实现"添加附件"的功能,于是就有了MIME(Multipurpose
Internet Mail Extensions)</p>
<p>MIME是基于SMTP的,本质上是将用户要发送的"附件"转化为7位ASCII码然后套用SMTP协议,接收方再将ASCII码翻译过来</p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/dbf93412a69704437e261e04cbc7f9e9.png" /></p>
<p>MIME主要包括:</p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/5e9e57fdd27d2dd2d0a8cb6820567b4c.png" /></p>
<p><strong>"推"</strong></p>
<p>推的意思是发送方主动,接收方被动</p>
<p>用户代理向==客户端==发送邮件采用的是SMTP协议</p>
<p>客户端向服务端发送邮件采用的也是SMTP协议</p>
<h4 id="邮件读取协议pop3">邮件读取协议POP3</h4>
<p>post office protocol邮局协议,邮件读取协议</p>
<p>3是指第三个版本</p>
<p>使用C/S方式,使用TCP连接,端口号110</p>
<p>拉的意思是发送方被动,接收方主动</p>
<p><strong>"拉"</strong></p>
<h3 id="邮件发送过程">邮件发送过程:</h3>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/82a80e4ad4965a681ce5d1f29bce204d.png" /></p>
<p>1.用户通过用户代理写好信之后使用SMTP协议将邮件发送给==发送端邮件服务器==(后面称为==客户端==),客户端将该邮件放入自己的邮件缓存队列中等待发送</p>
<p>2.客户端定时检查邮件缓存队列,如果有邮件待发送,则向==接收端邮件服务器==(后面称==服务端==)发送TCP连接请求</p>
<p>3.TCP连接建立后SMTP客户端向SMTP服务端发送邮件,当SMTP客户端邮件缓存队列清空时,SMTP关闭TCP连接</p>
<p>4.服务端接收到邮件之后将邮件放入用户信箱</p>
<p>5.收信用户打算收信时,让用户代理去邮件服务器的用户信箱拉取邮件</p>
<h3 id="电子邮件格式">电子邮件格式</h3>
<p><span class="math display">\[
电子邮件
    \begin{cases}
        信封\\
        内容
            \begin{cases}
                首部\\
                主体
            \end{cases}
    \end{cases}
\]</span></p>
<p>信封完全不用用户操心,信封是从信的内容首部提取信息填写的</p>
<h4 id="内容首部">内容首部</h4>
<p>首部由首部行组成</p>
<p>首部行的格式是:<code>键:值</code></p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/5b04141ab6b1e30c79cda318b2348026.png" /></p>
<p>发件人地址From,收件人地址To等是必须内容</p>
<p>主题Subject等是非必须内容</p>
<p>其中收件人地址,主题这种信息由用户手动填写,发件人地址和发件时间自动填写</p>
<blockquote>
<p>From和To都是用户地址</p>
<p>hoopdog@hust.edu.cn</p>
<p>即 hoopdog at hust.edu.cn</p>
<p>即 位于hust.edu.cn的hoopdog</p>
<p>其中@后面的是邮件服务器地址,<span class="citation"
data-cites="前面的是用户名">@前面的是用户名</span></p>
<p>需要确保的是,同一个邮件服务器管理的用户名不能有重名(这容易理解,班上有俩个张三的时候课代表也不知道把张三的作业本给哪个张三)</p>
<p>由此可见balabala@qq.com这个地址就是qq.com邮件服务器管理的balabala用户</p>
<p>==qq.com是邮件服务器==</p>
</blockquote>
<h2 id="万维网">万维网</h2>
<p>万维网是无数网络站点和页面的集合,是因特网最主要的部分</p>
<p>因特网还包括电子邮件等</p>
<h3 id="万维网的组成">万维网的组成</h3>
<p>world wide web:资料空间</p>
<p>万维网中有用的事物称为"资源" <span class="math display">\[
万维网内核
\begin{cases}
同一资源定位符(URL)\\
超文本传输协议(HTTP)\\
超文本标记语言(HTML)
\end{cases}
\]</span>
万维网以C/S的方式工作,浏览器是万维网的客户端.万维网上资源文档所在的计算机时服务端</p>
<p>两者通信的流程:</p>
<p>1.万维网用户希望使用浏览器访问某个URL,与该URL所在的服务器建立连接,发送浏览请求</p>
<p>2.服务器把URL转换为文件路径,返回信息给客户端</p>
<p>3.通信完毕,关闭连接</p>
<h3 id="统一资源定位符url">统一资源定位符(URL)</h3>
<p>负责标识万维网上的各种文档,使每个文档有唯一的标识符(链接地址)</p>
<p>一般形式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</span><br></pre></td></tr></table></figure>
<p>其中端口和路径可以略去不写,整个URL不区分大小写</p>
<blockquote>
<p>比如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/</span><br></pre></td></tr></table></figure>
<p>https是协议</p>
<p>www.baidu.com是主机的DNS地址,实际上映射到220.181.38.251</p>
</blockquote>
<p>常见的协议有http,ftp,https等</p>
<h3 id="超文本传输协议http">超文本传输协议HTTP</h3>
<p>协议规定了</p>
<p>1.浏览器怎样想万维网服务器请求资源</p>
<p>2.服务器怎样把文档传给浏览器</p>
<p>即规定了怎么去和怎么回来</p>
<h4 id="http操作过程">HTTP操作过程</h4>
<p>1.客户端(浏览器)对要访问的www服务器请求DNS域名解析,获得该服务器IP地址</p>
<p>2.客户端通过TCP向服务器发起建立连接的请求,这是第一次握手</p>
<p>3.服务器在TCP的80端口监听到客户端发出的请求,与客户端建立连接,这是第二次握手</p>
<p>4.在客户端与服务器的第三次握手时客户端发送获取==服务器拥有的某个文件==的请求报文</p>
<p>5.服务器返回==该文件web页面的必须信息==(注意此时还没有完全返回该页面,只是返回了基本的框架,很多元素比如jpeg图片等需要后续继续请求才能发送)</p>
<p>6.客户端浏览器收到资源并解释,及时显示给用户</p>
<p>7.客户端一直发送请求直到页面加载完成,此时TCP连接断开</p>
<p>客户端向服务端发出的是请求,服务端向客户端发出的是响应</p>
<p>没有请求就没有响应,请求时客户端主动发出的,服务端不会多管闲事</p>
<p>请求和响应必须遵循规定的规则和格式,即HTTP</p>
<h4 id="http特点">HTTP特点</h4>
<p>1.本身无状态</p>
<p>服务器不会记录客户信息,任何客户不管第几次访问同一个页面时显示的内容都是相同的.这样设计的目的是减轻服务器的压力,使其支持大量并发的HTTP请求</p>
<blockquote>
<p>Cookie+数据库获取用户历史浏览信息</p>
<p>后来引入Cookie技术之后,服务器只需要记录客户端的身份信息,客户自己的喜好,密码等等信息都存储在客户机器上,当客户端第一次访问某个服务器时,服务器在数据库中记录该客户端的身份信息.客户端自己记录自己的个人喜好和隐私信息.</p>
<p>当客户端下一次访问这个服务器时,服务器就能从数据库记录中知道这个客户曾经来过,然后可以根据客户cookie获得客户喜好了</p>
<p>这时状态是来自cookie的辅助,与http本身无状态不矛盾</p>
</blockquote>
<p>2.传输层协议使用TCP</p>
<p><strong>3.既可以使用非持久连接,也可以使用持久连接</strong></p>
<p>非持久连接:对于客户端的每一个请求,服务器返回响应后立刻断开TCP连接</p>
<p>持久连接:服务器对于客户端的请求返回响应之后并不立刻断开TCP连接,而是等待下一次请求,直到客户端发出停止连接的要求或者连接失败</p>
<blockquote>
<p>持久连接的两种方式:</p>
<p>流水线方式:请求是串行的,客户端发出A请求,必须收到服务端的响应之后才可以发出下一个B请求</p>
<p>非流水线方式:请求是并行的,客户端一股脑发出多个请求,剩下的任务就是接收服务端的多个响应</p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/d6672322cb5522779a9cadb20b0b726e.png" /></p>
</blockquote>
<h4 id="http报文结构">HTTP报文结构</h4>
<p>HTTP面向文本,报文由ASCII码字符串组成</p>
<p>报文由两类:请求报文和响应报文</p>
<p>两种报文都是由三部分组成:</p>
<p>开始行,首部行,实体主题</p>
<p>区别在于开始行不同</p>
<p>请求报文的开始行是请求行</p>
<p>响应报文的开始行是状态行</p>
<h5 id="请求报文">请求报文</h5>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/9402acb15d554bc0a90012bffb10fa56.png" /></p>
<p>请求行=请求用到的方法+space+请求资源的URL+space+HTTP版本号+回车换行</p>
<blockquote>
<p>请求方法作用于请求对象</p>
<p>请求常用方法:</p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/85915b69c67049cf59593f06dc430591.png" /></p>
</blockquote>
<h5 id="响应报文">响应报文</h5>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/72e019bbb1ce7edd8c5f7bc9d0eaf6c7.png" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/02/12/%E7%89%A9%E7%90%86%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/12/%E7%89%A9%E7%90%86%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络-物理层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-12 15:23:00 / Modified: 17:17:15" itemprop="dateCreated datePublished" datetime="2023-02-12T15:23:00+08:00">2023-02-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络-物理层">计算机网络-物理层</h1>
<h2 id="物理层">物理层</h2>
<p>比特率:一秒内发送的位数,bps,b/s</p>
<p>比特长度=传播速度*传播时间,即一个比特在传输介质上的距离</p>
<p>复合信号:简单正弦信号的叠加信号</p>
<p>带宽:符合信号的组成成分中,最高频率与最低频率的差</p>
<p>模拟信号:用连续变化的物理量表示信息</p>
<p>数字信号:用离散的物理量表示信息</p>
<blockquote>
<p>模拟信号和数字信号的关系</p>
<p>实际上数字信号是带宽无穷大的复合的模拟信号</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205092343687.png"
alt="image-20230205092343687" />
<figcaption aria-hidden="true">image-20230205092343687</figcaption>
</figure>
<figure>
<img
src="https://picx.zhimg.com/50/v2-71d923f79ccd06cbec2be71698bf9923_720w.webp?source=1940ef5c"
alt="拟合方波的过程" />
<figcaption aria-hidden="true">拟合方波的过程</figcaption>
</figure>
<p>至于为啥非周期性的数字信号,其频率是连续的,而周期性的数字信号,其频率是离散的呢?</p>
<p>也就是说,为什么周期性的数字信号做傅里叶变换之后,在频域得到的是频率离散的正弦波呢?</p>
<p><strong>首先证明,离散的正弦波叠加一定能够得到周期性复合波形</strong></p>
<p>直接取这些正弦波周期的最小公倍数,一定是该复合波形的周期</p>
<p>对于<span class="math inline">\(f(x)=Asin(\omega
x+\phi)\)</span>设T为其周期,则有<span
class="math inline">\(f(x+T)=f(x)\)</span></p>
<p>不妨设这些正弦波的最小公倍数为nT</p>
<p>那么 <span class="math display">\[
f(x+nT)=f((x+(n-1)T)+T)=f(x+(n-1)T)=...=f(x)
\]</span> 对于<span class="math inline">\(F(x)=\sum_{i=0}^n
A_isin(\omega_ix+\phi_i)=\sum_{i=0}^n f(x)\)</span></p>
<p>自然有<span class="math inline">\(F(x+nT)=F(x)\)</span></p>
<p><strong>然后证明,连续频率的正弦波叠加,无法形成周期性信号</strong></p>
<p>假设<span class="math inline">\(f(x)=Asin(\omega
x+\phi)\)</span>,其中<span class="math inline">\(\omega\)</span>在<span
class="math inline">\([a,b]\)</span>上连续</p>
<p>则 <span class="math display">\[
F(x)=\int_{a}^bA(\omega) sin(\omega x+\phi(\omega)) d\omega
\]</span> 即证明<span
class="math inline">\(F(x)\)</span>不是周期函数</p>
<p>假设<span
class="math inline">\(F(x)\)</span>是周期函数,设T为其一个周期,则有F(0)=F(T),那么就得有
<span class="math display">\[
\int_{a}^bA(\omega) sin(\phi(\omega)) d\omega=\int_{a}^bA(\omega)
sin(\omega T+\phi(\omega)) d\omega
\]</span></p>
<p>即 <span class="math display">\[
\int_{a}^b A(\omega)[sin(\phi(\omega)) - sin(\omega T+\phi(\omega))]
d\omega=0
\]</span> 其中 <span class="math display">\[
sin(\phi(\omega)) - sin(\omega
T+\phi(\omega))=2cos\frac{2\phi(\omega)+wT}{2}sin\frac{-\omega T}{2}
\]</span>
然而这个式子无法证明成立,倒是可以举反例证明不成立,比如令A=1,<span
class="math inline">\(\phi=0\)</span></p>
<p>则<span class="math inline">\(-\int_{a}^b sin\omega \
d\omega=0\)</span>显然不正确,因为a,b可能不够一个周期</p>
<p><strong>为什么说数字信号是带宽无穷大的复合模拟信号?</strong></p>
<p>先说为啥数字信号是一个模拟信号</p>
<p>根据傅里叶变换,非周期数字信号是连续频率的正弦波的叠加</p>
<p>周期数字信号是离散频率的正弦波的叠加</p>
<p>这个频率的上下界是多少?下界是0,上界是无穷大,为啥是无穷大?</p>
<figure>
<img
src="https://picx.zhimg.com/50/v2-71d923f79ccd06cbec2be71698bf9923_720w.webp?source=1940ef5c"
alt="拟合方波的过程" />
<figcaption aria-hidden="true">拟合方波的过程</figcaption>
</figure>
<p>N越大,也就是谐波越多,波形越接近方波,拐弯的时候越接近直角</p>
<p>当N趋向无穷大时,才可以认为波形是方波</p>
<p><strong>振幅体现成什么?</strong></p>
<p>在频域图上观察更加明显</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/v2-99884a566f11393b11c1a597a0fabe09_r.jpg"
alt="6. 傅里叶变换与图像的频域处理 - 知乎" />
<figcaption aria-hidden="true">6. 傅里叶变换与图像的频域处理 -
知乎</figcaption>
</figure>
<p>振幅越大的分量,代表这个分量信号在复合信号中的影响更大.</p>
<p>可以这样理解:</p>
<p>三个人一起说话,我们从远处只能听见说话声音大的那个一,几乎听不到其他人说话,但是实际上我们听到的是三人声音的复合信号,只不过另外两个人的劲太小,发出的信号振幅小,能量小,我们听不清</p>
</blockquote>
<h3 id="传输方式">传输方式</h3>
<h4 id="基带传输">基带传输</h4>
<p>直接传输数字信号,要求该信号的最低频率成分,其频率是0.</p>
<p>理想情况下,传递1101110这么一串信息,可能就是高高低高高高低电平的变换.</p>
<p>但是实际上由于基带传输需要无穷大的带宽,而实际的信道带宽有限</p>
<p>这就意味着,要噶掉一些频率过高或者过低的谐波.</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205101233925.png"
alt="image-20230205101233925" />
<figcaption aria-hidden="true">image-20230205101233925</figcaption>
</figure>
<p>这就会造成波形失真</p>
<blockquote>
<p>为什么噶掉一些谐波就会造成波形失真?</p>
<figure>
<img
src="https://picx.zhimg.com/50/v2-71d923f79ccd06cbec2be71698bf9923_720w.webp?source=1940ef5c"
alt="拟合方波的过程" />
<figcaption aria-hidden="true">拟合方波的过程</figcaption>
</figure>
<p>还是这个图,如果只保留N=1,也就是噶掉了其他所有频率的分量,那么图像就是只一个正弦波,根本看不出方波了</p>
</blockquote>
<p>如果被噶掉的部分,有些频率的分量,其振幅很大,也就是在符合信号中的话语权比较重,那么被噶掉之后,波形失真就会很厉害</p>
<blockquote>
<p>这就好比一场音乐会,去掉一些和声,普通人可能也察觉不出来</p>
<p>但是去掉劲最大的主唱,傻子也能听出来,怎么开始放伴奏了?</p>
</blockquote>
<p>但是只要能够保持波形的大概就可以了,接收方会复原信号</p>
<p>因此使用有限频率的分量就可以了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205101834194.png"
alt="image-20230205101834194" />
<figcaption aria-hidden="true">image-20230205101834194</figcaption>
</figure>
<p>一个例题说明这个事情</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205102120566.png"
alt="image-20230205102120566" />
<figcaption aria-hidden="true">image-20230205102120566</figcaption>
</figure>
<p>也就是说,更高的带宽是为了容纳更多谐波,使得波形更接近方波,使得分辨更清晰</p>
<p><strong>比特率和带宽的关系:正比</strong></p>
<p>比特率是单位时间内发送的位数</p>
<p>为啥说单位时间内发送的位越多,要求的带宽就越大呢?</p>
<p>下图可以从直观上说明这个事情</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205102250459.png"
alt="image-20230205102250459" />
<figcaption aria-hidden="true">image-20230205102250459</figcaption>
</figure>
<p>相同时间(1s)内,有四种电平的方波,可以发送16个比特位,比特率就是16bps</p>
<p>而只有两种电平的方波,只能发送8位,比特率就是8bps</p>
<p>也就是,要证明电平种类数越多,需要的带宽就越大</p>
<p><strong>直观上</strong>,要拟合一个只有两种电平的数字信号,需要的谐波要少点.</p>
<p>也就是说这个方波越复杂,拟合时需要的谐波就要更多</p>
<p>但是怎么证明我不会</p>
<h4 id="宽带传输">宽带传输</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205102704785.png"
alt="image-20230205102704785" />
<figcaption aria-hidden="true">image-20230205102704785</figcaption>
</figure>
<p>宽带传输允许的频率不是从0开始的,是从某一个正数f1开始的</p>
<p>"这就导致不能直接发送数字信号"为啥呢?</p>
<p>推测其原因是</p>
<p>1,是数字信号的主要分量(主要也就是振幅比较大,权重比较大的那些分量),其频率较低,在f1之下,会被噶掉,造成严重的失真</p>
<p>2,就算被噶掉的无关紧要,但是考虑衰减问题</p>
<p>可能发出时的信号很强,01分明,但是百前公里之后信号就会衰减,届时可能辱下图所示</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205104236117.png"
alt="image-20230205104236117" />
<figcaption aria-hidden="true">image-20230205104236117</figcaption>
</figure>
<p>原来的高电位也变得低趴,被接收方识别为0</p>
<p>但是可以采取中继措施啊(<del>比如红石中继器</del>),上述推测2也不是问题啊</p>
<p>然而实际上也没有对数字信号采取中继,数字信号被应用于芯片比如CPU,计算机主板这种东西上,或者以太网这种局域网(曼切斯特编码等等)</p>
<p>那么为啥远距离传输一定要模拟信号呢</p>
<p>知乎的解答:</p>
<p>"以电话线为例子,电话线主要用来传语音（300到3400赫兹），不适合直接传输频带很宽<strong>能量比较集中在低频段</strong>的数字基带信号，所以这里需要一个modem做频带调制解调."</p>
<p><strong>也就是推测1</strong></p>
<p>那么为啥不能让电话线的最低频率再低一点,低到0?或者说,一根电线,其允许传播的电信号频率范围是多少?这个可以人为改变吗?</p>
<p>也就是说,计算机只会收发数字信号,两个modem之间才会使用模拟信号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">C1((C1))</span><br><span class="line">C2((C2))</span><br><span class="line">subgraph 远距离通信</span><br><span class="line">	Modem1(Modem1)</span><br><span class="line">	Modem2(Modem2)</span><br><span class="line">end</span><br><span class="line">C1--&quot;数字信号&quot;---Modem1</span><br><span class="line">Modem1--&quot;模拟信号&quot;---Modem2</span><br><span class="line">Modem2--&quot;数字信号&quot;---C2</span><br></pre></td></tr></table></figure>
<p>在两个计算机看来,他俩是直接数字信号通信的,他俩不知道中间有个猫干了啥</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">C1((C1))</span><br><span class="line">C2((C2))</span><br><span class="line">C1--数字信号----C2</span><br></pre></td></tr></table></figure>
<h5 id="传输减损">传输减损</h5>
<p>三种类型的减损:衰减,失真,噪声</p>
<h5 id="衰减">衰减</h5>
<p>衰减:远距离传输信息肯定有衰减,就比如在泰安说句话在西安听不见,可能十步之外就听不见了,这就是衰减</p>
<p>衰减的原因是介质震动将能量传递给其他物质了,比如空气</p>
<p>衰减只会让能量减弱,不会改变信号的频率相位,而能量直接提现到振幅上,因此画在图上,衰减就是信号变得低趴</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205214605628.png"
alt="image-20230205214605628" />
<figcaption aria-hidden="true">image-20230205214605628</figcaption>
</figure>
<p>使用分贝作为单位衡量衰减程度 <span class="math display">\[
dB=10\lg{\frac{P_2}{P_1}}
\]</span> 其中P1是衰减前的功率,P2是衰减之后的功率</p>
<p>假设功率衰减为之前的一半,<span
class="math inline">\(10\lg\frac{1}{2}\approx-3dB\)</span></p>
<h5 id="失真">失真</h5>
<p>失真就是信号波形发生了变化,相位,频率都可能变化</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205215029546.png"
alt="image-20230205215029546" />
<figcaption aria-hidden="true">image-20230205215029546</figcaption>
</figure>
<p>发生失真可能是电子元件本身导致,比如三极管就有失真区</p>
<h5 id="噪声">噪声</h5>
<p>噪声就是杂音,就比如上课时老师讲话是有效信息,学生嘀咕就是噪音</p>
<p>噪音能量大了,就会淹没有效信息,如下图所示</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205215750791.png"
alt="image-20230205215750791" />
<figcaption aria-hidden="true">image-20230205215750791</figcaption>
</figure>
<blockquote>
<p>信号中的噪音可能来自</p>
<p>热噪音:导体中电子热震动造成</p>
<p>串扰:两条信号线之间的<a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/耦合/2821124?fromModule=lemma_inlink">耦合</a>、信号线之间的<a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/互感/1016820?fromModule=lemma_inlink">互感</a>和互容引起线上的噪声。</p>
<p>脉冲噪声:磁暴就可以导致</p>
</blockquote>
<p>噪声程度用信噪比衡量 <span class="math display">\[
信噪比SNR=\frac{平均信号功率P_{信号}}{平均噪声功率P_{噪声}}
\]</span> 单位是分贝</p>
<h3 id="无噪声信道数据速率">无噪声信道数据速率</h3>
<p>数据速率(比特率):一秒内传送的比特数</p>
<p>三个影响因素:有效带宽,使用的信号电平数,通道质量</p>
<p>理论最大比特率(无噪声信道): <span class="math display">\[
理论上的最大比特率 = 2 × 带宽 ×  log_2 L，  L是电平数
\]</span> 如果只有两个电平,只能一个电平表示一位,</p>
<p>有四个电平,则每个电平可以编码两位</p>
<p>依此类推</p>
<p>但是,为啥带宽和比特率会发生关系呢?</p>
<p>参考<a
target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44586473/article/details/104372110">深入理解奈奎斯特第一准则与码间串扰</a></p>
<h4 id="奈奎斯特第一准则直观理解">奈奎斯特第一准则直观理解</h4>
<p>考虑这么一个问题</p>
<p>同样一秒时间内,我让电平变化越快,岂不是传递的信息越多吗?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205220410948.png"
alt="image-20230205220410948" />
<figcaption aria-hidden="true">image-20230205220410948</figcaption>
</figure>
<p>那么我让一个bit位持续时间只有1皮秒,那么1秒内直接传输1e9
个bit,岂不美哉?</p>
<p>这就是带宽的限制的作用了</p>
<p>单位时间内电位变化越快,说明信号的频率越大,显然信号的最大频率不能超过信道的频率上限.比这个上限再高的分量会被直接噶掉</p>
<p>最大比特率也就是说,在一秒内能够传递$ 2 × 带宽 × log_2
L$这么多bit,为啥不能比这再高了呢?为啥会和带宽挂钩,而不是和最高频率挂钩?</p>
<p>因为当比特率大于这个值时,会发生<strong>码间串扰</strong></p>
<p>啥是码间串扰呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205222514271.png"
alt="image-20230205222514271" />
<figcaption aria-hidden="true">image-20230205222514271</figcaption>
</figure>
<p>怎么发生的码间串扰?我有一个直观的理解了</p>
<p>发生器在产生一个码元之后,应立刻变换模式生成下一个模式,这里不应该存在码间串扰</p>
<p><strong>为什么说前一个码元在后续时刻有残留呢?</strong>这个残留是怎么来的呢?</p>
<p>百度百科是这样解答的:</p>
<blockquote>
<p>直方脉冲的波形在时域内比较尖锐，因而在频域内占用的带宽是无限的。</p>
<blockquote>
<p>直观上,拟合一个尖锐变化的信号,需要无限多高频的分量</p>
</blockquote>
<p>如果让这个脉冲经过一个低通滤波器，即让它的频率变窄，那么它在时域内就一定会变宽。</p>
<blockquote>
<p><strong>这是关键</strong></p>
<p>首先,为啥信号频率变窄,时域就得展宽?</p>
<p>这是傅里叶变换的展缩特性<a
target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44252933/article/details/123654783">展缩特性的推导</a></p>
<p>我没学过傅里叶变换的细节,找到一个直观的理解</p>
<blockquote>
<p>因为脉冲信号是由不同频率的正弦波组合而成，通过低通滤波器，只剩下些低频正弦波，所以波形看起来更接近正弦波，像被展宽了一样。</p>
</blockquote>
<p>也就是说,频率上噶掉高频和低频之后,再进行傅里叶逆变换,时域图像会变,变宽</p>
<p>此前是一个码元完毕立刻跟着下一个码元,现在每个码元都宽了,把脚伸到下一个码元怀里了,也就是"拖尾"</p>
</blockquote>
<p>因为脉冲是一个序列，这样相邻的脉冲间就会相互干扰。这种现象被称为码间串扰（InterSymbol
Interference，ISI）。</p>
</blockquote>
<p>最后一个问题,为啥比特率超过这个最大值$ 2 × 带宽 × log_2
L$就会造成码间串扰?</p>
<p>实际上这个<span
class="math inline">\(log_2L\)</span>就是波特率,也就是码元率,也就是单位时间内传送的码元个数</p>
<p>这实际上是奈奎斯特第一准则</p>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44586473/article/details/104372110">深入理解奈奎斯特第一准则与码间串扰</a></p>
<p>这篇博客完美解答了</p>
<p>写太好了写太好了写太好了</p>
<p>博主用一个实验证明了不遵守奈一准则的后果,实验是这样设计的:</p>
<p>首先,要发射方波,但是理想的方波的频率无限大,显然真实的信道做不到</p>
<p>于是用sinc脉冲函数作为近似拟合,该函数的带宽是2B,也就是说,该信号包括了2B带宽范围内的各种强度的连续频率的简谐信号分量,也就模拟了无噪声信道</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20200218130601438.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>用这个最高的尖作为方波</p>
<p>要发送比特序列00010110,用正高电位表示0,负高电位表示0</p>
<p>对应电位处放上函数的尖儿</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20200218132828290.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>实际上发出的信号是这几个sinc函数的叠加</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20200218133151349.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>接收方收到后进行采样,决定某个时刻是哪一个码元</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20200218133727575.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>采样结果</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200218140840404.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>和发送时一模一样</p>
<p>好,下面要缩短码元的时间,也就是相同时间内企图发送更多的码元</p>
<p>之前是1秒内两个bit,现在是1秒内4个比特</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200218141233915.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>叠加之后</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200218141556530.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>接收方采样</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200218142043666.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>已经无法在整1和-1处采到信息了</p>
<p>如果以大于0的作为1,小于0的作为0</p>
<p>接收方得到的序列就是111101001,失真了</p>
<h3 id="有噪声信道数据速率">有噪声信道数据速率</h3>
<p>定义通道容量:单位时间内通道传输的比特数</p>
<h4 id="香农定理">香农定理</h4>
<p><span class="math display">\[
通道容量C=带宽B\times \log_2(1+SNR)\\
\]</span></p>
<p>其中<span
class="math inline">\(SNR=\frac{P_{信号}}{P_{噪声}}\)</span></p>
<p>如果SNR很大,可以认为<span class="math inline">\(SNR\sim
SNR+1\)</span>,则有 <span class="math display">\[
C=B\times \log_2 SNR=B\times \frac{SNR_{dB}}{3}
\]</span> 香农定理规定了真实信道的最大传输速率</p>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/shulianghan/article/details/108002782">物理层
: 香农定理</a></p>
<p>然而香农定律中没有涉及电平数量,实际中也正好利用这一点,结合奈奎斯特准则计算信号电平数</p>
<blockquote>
<p><strong>有一个 1MHz带宽的通道。通道的信噪比是
63，合适的比特率以及信号电平是多少？</strong></p>
<p>根据香农定律,理论上最高的通道容量为 <span class="math display">\[
C=B\times \log_2(1+SNR)=1M\times \log_2(64)=6Mbits/s
\]</span>
实际上的比特速率肯定比这要小,为了获取更好的<strong>性能</strong>,可以使用<span
class="math inline">\(N=4Mbits/s\)</span>为合适的比特率</p>
<p>根据奈奎斯特第一准则 <span class="math display">\[
N=2B\log_2L
\]</span> 得到<span class="math inline">\(L=2\)</span></p>
<p>这里的"性能"指什么呢?</p>
</blockquote>
<h3 id="性能">性能</h3>
<h4 id="吞吐量">吞吐量</h4>
<p>单位时间内成功传送的数据量.</p>
<p>单位:bit/s,bps,同带宽相同</p>
<p>吞吐量和带宽的区别:</p>
<p>带宽只需要考虑信道的速率,不管两头的计算机,发射装置</p>
<p>而吞吐量需要考虑所有因素,包括计算机的速度,调制速度,带宽等</p>
<p>可以理解为,带宽用来衡量一段高速公路满载时的流量</p>
<p>但是吞吐量需要考虑高速公路两头的收费站减速</p>
<p>因此吞吐量一定是小于等于带宽的</p>
<h4 id="延迟">延迟</h4>
<p>延迟 = 传播延迟 + 传输时间 + 排队时间 + 处理延迟</p>
<p>传输时间就是发送方计算机将信息从本机发到信道上的时间</p>
<blockquote>
<p>取决于发送方CPU速度,总线,网络适配器等硬件的速度 <span
class="math display">\[
传输时间=\frac{报文长度}{传输速度}
\]</span></p>
</blockquote>
<p><strong>传播延迟就是信号从信道中传递的时间</strong></p>
<blockquote>
<p>传播延迟取决于信号在信道中的传播速度,比如电信号在导线中的速度就是光速<span
class="math inline">\(3\times 10^8\)</span> <span
class="math display">\[
传播延迟=\frac{距离}{传播速度}
\]</span></p>
</blockquote>
<p>排队时间就是该信号在接收方消息队列中等待被处理的时间</p>
<blockquote>
<p>该时间取决于前面有多少个排队等待处理的消息以及这些消息的处理时间</p>
</blockquote>
<p>处理延迟就是接收方执行本信号处理程序花费的时间</p>
<blockquote>
<p>取决于接收方硬件速度,以及处理算法复杂度</p>
</blockquote>
<h5 id="带宽延迟积">带宽延迟积</h5>
<p>定义了能够充满链路的位数</p>
<p>啥意思呢?</p>
<p>假如接收方在大洋彼岸,发送方传输一个bit,需要50ms才能抵达</p>
<p>而这50ms之内,发送方已经传输了成千上万个bit.</p>
<p>发送方一直传输,直到第一个bit到达接收方时,此时整个信道排满了bit</p>
<p>此时信道中的bit数量就是带宽延迟积</p>
<p>这一路上有多少辆车呢? <span class="math display">\[
带宽延迟积=延迟\times 比特率
\]</span></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206153701581.png"
alt="image-20230206153701581" />
<figcaption aria-hidden="true">image-20230206153701581</figcaption>
</figure>
<p>图中的带宽实际上描述的是数据速率,单位是bit/s</p>
<h3 id="数字传输">数字传输</h3>
<h4 id="线路编码">线路编码</h4>
<h5 id="基本概念">基本概念</h5>
<p>将数字数据转换为数字信号的过程</p>
<p>数据元素:信息的最小单元,一个位bit</p>
<p>信号元素(码元):数字信号的最小单元,是数据元素的载体</p>
<p>比率r:每个信号元素承载的bit数量</p>
<blockquote>
<p>把人比作数据元素,一个人相当于1bit</p>
<p>把车比作信号元素,一辆车是一个数据元素</p>
<p>比率为2,意思是一个信号元素承载两个bit,也就是一辆车可以坐俩人</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206163519913.png"
alt="image-20230206163519913" />
<figcaption aria-hidden="true">image-20230206163519913</figcaption>
</figure>
<p>波形的每一个方格是一个信号元素,这个元素能够承载啥数据元素,承载几个,这是人为规定的</p>
<p>数据速率(比特率):一秒内发送的bit数</p>
<p>信号速率(波特率):一秒内发送的码元个数</p>
<p>两者关系: <span class="math display">\[
S=c\times N\times \frac{1}{r},\\
\]</span></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S,信号速率</span><br><span class="line">N,数据速率</span><br><span class="line">c,情形因子,通常取值<span class="number">1</span>/<span class="number">2</span></span><br><span class="line">r,比率</span><br></pre></td></tr></table></figure>
<p>理想的数字信号,其带宽应该是无限大的,但是实际上信道的带宽有限,于是就有了奈奎斯特第一准则,对带宽的限制
<span class="math display">\[
理论上的最比特率 = 2 × 带宽×  log_2 L，  L是电平数
\]</span> 也就是 <span class="math display">\[
B_{min}=\frac{N_{max}}{2\times \log_2L}=\frac{cN}{r}=S
\]</span></p>
<blockquote>
<p>这里数据元素和信号元素的关系体现在电平数量上<span
class="math inline">\(r=\log_2 L\)</span></p>
</blockquote>
<h5 id="线路编码需要解决的问题">线路编码需要解决的问题</h5>
<p><strong>基线偏移</strong></p>
<p>接收方需要观察信号一段时间,才能计算出信号的平均功率,然后根据信号的瞬时功率决定当前信号是高电位还是低电位</p>
<blockquote>
<p>假如使用高电位编码1,低电位编码0</p>
<p>然后发送方故意找茬发了一亿个1,接收方认为平均功率就是10V电压对应的功率.如果后来的1,其电位稍微低了点,成了8V,接收方就会把它解码为0</p>
</blockquote>
<p>尽量避免基线偏移就得选择正负电位出现几率相同的编码方式</p>
<p><strong>直流分量</strong></p>
<p>一个信号可能会有变化很剧烈的地方,也可能会有变化比较缓慢的地方</p>
<p>比如如果发送方连续发送一亿个1,那么信号就可能是持续1秒的高电位,几乎成为了直流电</p>
<p>直流电无法通过电容这种器件.会被过滤掉</p>
<p>尽量避免直流分量,就得选择变化剧烈的编码方式</p>
<p><strong>自同步</strong></p>
<p>就是"对表",接收方得和发送方时钟差不多一致</p>
<p>否则可能出现下图情况</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206165153188.png"
alt="image-20230206165153188" />
<figcaption aria-hidden="true">image-20230206165153188</figcaption>
</figure>
<p><strong>差错检测</strong></p>
<p><strong>抗噪声,抗干扰</strong></p>
<p><strong>实现的复杂性</strong></p>
<h4 id="线性编码方案">线性编码方案</h4>
<table style="width:100%;">
<colgroup>
<col style="width: 21%" />
<col style="width: 17%" />
<col style="width: 21%" />
<col style="width: 21%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr>
<th>性质</th>
<th>编码方案</th>
<th>图像</th>
<th>特点</th>
<th>带宽和数据速率</th>
</tr>
</thead>
<tbody>
<tr>
<td>单极性</td>
<td>不归零(NRZ)</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206165544099.png" alt="image-20230206165544099" style="zoom:25%;" /></td>
<td>1高0低</td>
<td><span class="math inline">\(B=\frac{N}{2}\)</span></td>
</tr>
<tr>
<td>极性</td>
<td>不归零(NRZ)</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206165603612.png" alt="image-20230206165603612" style="zoom:25%;" /></td>
<td>NRZ-L:0正1负<br />NRZ-I:遇1则拐</td>
<td><span class="math inline">\(B=\frac{N}{2}\)</span></td>
</tr>
<tr>
<td>极性</td>
<td>归零码(Polar RZ)</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206165727587.png" alt="image-20230206165727587" style="zoom:25%;" /></td>
<td>0先负后0<br />1先正后0</td>
<td><span class="math inline">\(B=\frac{N}{2}\)</span></td>
</tr>
<tr>
<td>极性</td>
<td>双向码<br />曼彻斯特编码<br />差分曼彻斯特编码</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206165747839.png" alt="image-20230206165747839" style="zoom:25%;" /></td>
<td>曼彻斯特:0先负后正,1先正后负<br />差分曼彻斯特:1先保持,0立刻转</td>
<td><span class="math inline">\(B=\frac{N}{2}\)</span></td>
</tr>
<tr>
<td>双极性</td>
<td>交替传号反码(AMI)<br />伪三元编码(Pseudoternary)</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206165817455.png" alt="image-20230206165817455" style="zoom:25%;" /></td>
<td>AMI:1正负交替,0就是0<br />Pseudotemary:0正负交替,1为0</td>
<td><span class="math inline">\(B=N\)</span></td>
</tr>
<tr>
<td>多电平mBnL<br />m个数据元素编码成n个信号元素<br />也就是n个码元承载m个bit</td>
<td>2B1Q(L=4=Q)</td>
<td>2B1Q:<br /><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206165942113.png" alt="2B1Q" style="zoom:28%;" /><br />8B6T:<br /><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206172529742.png" alt="8B6T" style="zoom:25%;" /></td>
<td>多个电位,可以用连续的几个电位编码连续的几个bit<br />比如2B1Q意思是,每两个bit为一个组,有4种电位,一组使用一个信号单元(码元),也就是<span
class="math inline">\(r=2\)</span><br />比如8B6T意思是,每8个bit为一组,有3种电位,一个组使用连续的6个信号单元(码元),也就是<span
class="math inline">\(r=8/6=4/3\)</span></td>
<td>2B1Q:<span
class="math inline">\(B=\frac{N}{2}\)</span><br />8B6T:<span
class="math inline">\(B=\frac{3N}{4}\)</span></td>
</tr>
<tr>
<td>多电平并发</td>
<td>4D-PAM5<br />四线路并发的8B1Q</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206173348090.png" alt="image-20230206173348090" style="zoom: 33%;" /></td>
<td>00对应-2电位<br />01对应1电位<br />11对应2电位<br />10对应-1电位<br />从四根铜线上并发传送<br />如果只有一根线,则相当于8B1Q<br /></td>
<td><span class="math inline">\(B=\frac{N}{8}\)</span></td>
</tr>
<tr>
<td>多线路</td>
<td>MLT-3<br />三电平多线路传输</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206173729253.png" alt="image-20230206173729253" style="zoom: 33%;" /></td>
<td>跳变方式多于两种,之前的极性非极性编码都只有两种跳变方式.而MLT-3中的跳变多余两种<br /><br />跳变规则:<br />如果下一位是0，没有跳变<br />如果下一位是1且当前电平是0，下一个电平是最后一个非零电平的相反值<br />如果下一位是1且当前电平不是0，下一个电平是0</td>
<td><span class="math inline">\(B=\frac{N}{3}\)</span></td>
</tr>
</tbody>
</table>
<h4 id="块编码">块编码</h4>
<p>块编码,mB/nB编码,将m个bit加上额外的位组成nbit(n&gt;m)</p>
<p>其目的是加上冗余信息,确保同步,并获得差错控制能力</p>
<p>或者说有一定的加密能力</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206174741944.png"
alt="image-20230206174741944" />
<figcaption aria-hidden="true">image-20230206174741944</figcaption>
</figure>
<p>计算机发出的和接收到的仍然是裸数据,mB/nB编码和解码器屏蔽了这个添加/去掉冗余的过程</p>
<p>具体如何编码呢?以4B/5B为例</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206174931435.png" alt="麻了,没看出编码算法来" style="zoom:25%;" /></p>
<p>冗余组:使用了5位,实际上只有4位满编,也就是说,有<span
class="math inline">\(2^4\)</span>个编码是有实际意义的</p>
<p>剩下的<span
class="math inline">\(2^5-2^4=16\)</span>个编码就是冗余组,可以另外定义意义</p>
<h4 id="扰码">扰码</h4>
<p>扰码用于解决什么问题?</p>
<p>先说之前的编码方式的缺点</p>
<blockquote>
<p>双相码适用于LAN中间站的专用链路，不适用于长距离通信；</p>
<p>块编码和NRZ编码的组合有DC分量，也不适合于长距离通信；</p>
<p>双极性AMI带宽窄且没有DC分量，但连续0的长序列会失去同步。B8ZS和HDB3</p>
</blockquote>
<p>扰码就是为了解决这些问题</p>
<p>咋解决呢?避免出现连续多个相同的电位</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 45%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr>
<th>扰码编码方式</th>
<th>图像</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>B8ZS</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206185948688.png" alt="image-20230206185948688" style="zoom:25%;" /></td>
<td>连续的八个0会被替换为000VB0VB<br /></td>
</tr>
<tr>
<td>HDB3</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206190003629.png" alt="image-20230206190003629" style="zoom:25%;" /></td>
<td>4个连续0电平被置换成000V或B00V；<br />两个不同的置换是由于为了维持每次置换后非零脉冲为偶数；<br />如果最后一次置换后的非零脉冲数是奇数，置换为000V，使得非零脉冲总数为偶数；<br />如果最后一次置换后的非零脉冲数是偶数，置换为B00V，使得非零脉冲总数为偶数。</td>
</tr>
</tbody>
</table>
<h3 id="模拟信号调成数字信号">模拟信号调成数字信号</h3>
<p>两种方式:PCM或者Delta</p>
<h4 id="pcm">PCM</h4>
<p>模拟信号调制成数字信号</p>
<p>没看错,就是模拟信号调制成数字信号,不是解调</p>
<p>这就奇怪了,远距离传送信号的时候都是在发送端先把数字信号调制成模拟信号,然后接收端模拟信号再解调成数字信号.但是PCM里是故意把模拟信号调制成数字信号的</p>
<p>实际应用?比如要研究星球脉冲的规律.由于这个星球每时每刻都在发射信号,在时域上是连续无限的.计算机首先需要存储了数据然后才能分析.</p>
<p>怎么存储就是问题了,如果保留半小时内的观测数据,也是有无穷多的时间点的.</p>
<p>可以选择每1分钟记录一次,或者每一秒,每一毫秒记录一次.</p>
<p>这样就把一个连续的模拟信号采样成离散的数字信号了</p>
<p>这个过程如图所示</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206191918320.png"
alt="image-20230206191918320" />
<figcaption aria-hidden="true">image-20230206191918320</figcaption>
</figure>
<h5 id="采样">采样</h5>
<p>采样率:单位时间内采取的离散信号的个数,单位,Hz</p>
<p>根据奈奎斯特定律,采样率必须是信号最高频率的两倍</p>
<p>为啥呢?下图意思意思</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206192614340.png"
alt="image-20230206192614340" />
<figcaption aria-hidden="true">image-20230206192614340</figcaption>
</figure>
<h5 id="量化">量化</h5>
<p>采样之后,离散的信号振幅也是一个不规整的值,现在规定几个固定的"合法振幅",让这些离散信号振幅舍入到最近的"合法振幅"</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206194038088.png"
alt="image-20230206194038088" />
<figcaption aria-hidden="true">image-20230206194038088</figcaption>
</figure>
<p>怎么选取"合法振幅"呢?</p>
<p>假设要分成L=10个区间(<span
class="math inline">\(-5\Delta,-4\Delta,-3\Delta,....,0,\Delta,2\Delta,5\Delta\)</span>),</p>
<p>设离散信号振幅值的最大和最小值分别为<span
class="math inline">\(V_{max},V_{min}\)</span></p>
<p>那么一个delta的高度就是 <span class="math display">\[
\Delta =\frac{V_{max}-V_{min}}{L}
\]</span> 然后原来的各点就近似为各自最近的"合法振幅"</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206194500351.png"
alt="image-20230206194500351" />
<figcaption aria-hidden="true">image-20230206194500351</figcaption>
</figure>
<h5 id="量化误差">量化误差</h5>
<p>L越大,每个Delta越小,分的阶层越多,近似就越少,误差就越小 <span
class="math display">\[
SNR_{dB}=6.02n_b+1.76dB
\]</span></p>
<p>这里<span
class="math inline">\(n_b\)</span>是每个样本需要多少位表示</p>
<p>在[-4D,4D]中有8个"合法振幅"等级,那么要编码一个合法振幅就得用<span
class="math inline">\(\log_28=3\)</span>个bit</p>
<p>因此在这里<span class="math inline">\(n_b=3\)</span></p>
<p>分层越多,也就是<span
class="math inline">\(n_b\)</span>越大,信噪比越大,也就是噪声的影响越小,也就是越准确.</p>
<h5 id="编码">编码</h5>
<p>量化等级L,也就是分层个数越多,表示一个采样数据所需要的bit位数就越多
<span class="math display">\[
n_b=\log_2 L
\]</span></p>
<p>因此可以得到</p>
<p><span class="math display">\[
比特率N=采样速率f_s \times 每个样本的位数n_b
\]</span></p>
<blockquote>
<p>人语音的频率范围是<span
class="math inline">\([0,4k]Hz\)</span>,假设要数字化人的语音,每个样本有8位,比特率是多少?</p>
<p>根据奈奎斯特定律,采样速率得是最高频率的两倍,也就是说<span
class="math inline">\(f_s=4kHz\times2=8kHz\)</span></p>
<p>那么比特率就是: <span class="math display">\[
N=f_s\times n_b=8k\times 8=64kbps
\]</span> 电子包浆音乐应该就是量化等级太低导致的</p>
</blockquote>
<h5 id="带宽">带宽</h5>
<p><span class="math display">\[
B_{min}=cN\frac{1}{r}
\]</span></p>
<p>c,情形因子,取1/2</p>
<p>r,码元和携带比特位的比例,在NRZ或者双极性编码信号中r=1</p>
<p>N,传输速率,比特率<span class="math inline">\(N=f_s\times
n_b\)</span></p>
<p><span
class="math inline">\(f_s=2f_{max}\)</span>采样率,信号最大频率的二倍</p>
<p><span class="math inline">\(n_b=\log_2 L\)</span>,每个样本的位数</p>
<p>带入得到 <span class="math display">\[
B_{min}=\frac{1}{2}\times 2f_{max}\times n_b=f_{max}\times n_b
\]</span></p>
<h4 id="传输方式-1">传输方式</h4>
<p>并行</p>
<p>串行,包括同步,异步,等时</p>
<h5 id="并行">并行</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206205143862.png"
alt="image-20230206205143862" />
<figcaption aria-hidden="true">image-20230206205143862</figcaption>
</figure>
<p>同时传送nbit,就需要n根线</p>
<h5 id="串行">串行</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206205224898.png"
alt="image-20230206205224898" />
<figcaption aria-hidden="true">image-20230206205224898</figcaption>
</figure>
<h6 id="异步传输">异步传输</h6>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206205415315.png"
alt="image-20230206205415315" />
<figcaption aria-hidden="true">image-20230206205415315</figcaption>
</figure>
<p>数据可以字节为单位,在任何时候抵达,双方都不需要时钟</p>
<p>因此需要在字节两头加上起始和结束的标志位,用以同步</p>
<h6 id="同步传输">同步传输</h6>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206205500359.png"
alt="image-20230206205500359" />
<figcaption aria-hidden="true">image-20230206205500359</figcaption>
</figure>
<p>数据以帧为单位,双方需要有公共时钟,帧上没有起始结束标志,双方需要对拍</p>
<h6 id="等时传输">等时传输</h6>
<p>数据以规定速率到达</p>
<p>比如实时音视频中,帧间的延迟应该相同且小,避免造成卡顿</p>
<h3 id="模拟传输">模拟传输</h3>
<h4 id="概念区分">概念区分</h4>
<p>低通,带通,基带,宽带的关系:</p>
<p>基带通信使用低通信道</p>
<p>宽带通信使用带通信道</p>
<p><strong>调频FM和频移键位FSK</strong>的关系?一个东西</p>
<h4 id="数转模方法">数转模方法</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206211028412.png"
alt="image-20230206211028412" />
<figcaption aria-hidden="true">image-20230206211028412</figcaption>
</figure>
<p>载波信号:发送设备产生高频信号作为基波承载信息</p>
<p>接收设备的收听频率和载波信号相同</p>
<p>数字信息通过改变载波信号的特性来将自身信息加到载波上去.称为调制或者移动键控</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 30%" />
<col style="width: 30%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr>
<th>调制方法</th>
<th>调制图像</th>
<th>实现原理</th>
<th>带宽</th>
</tr>
</thead>
<tbody>
<tr>
<td>二进制幅移键控BASK</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206211425111.png" alt="image-20230206211425111" style="zoom:25%;" /></td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206211328384.png" alt="image-20230206211328384" style="zoom:25%;" /></td>
<td><span class="math inline">\(B=(1+d)\times S\)</span></td>
</tr>
<tr>
<td>二进制频移键控BFSK</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206211626226.png" alt="image-20230206211626226" style="zoom:25%;" /></td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206211736958.png" alt="image-20230206211736958" style="zoom:25%;" /></td>
<td><span class="math inline">\(B=(1+d)\times S+2\Delta
f\)</span><br />多电平时:<br />$B = (1+d ) ×S + ( L -1 )2Δf $</td>
</tr>
<tr>
<td>二进制相移键控BPSK</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206211835623.png" alt="image-20230206211835623" style="zoom:25%;" /></td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206211840285.png" alt="image-20230206211840285" style="zoom:25%;" /></td>
<td><span class="math inline">\(B=(1+d)\times S\)</span></td>
</tr>
<tr>
<td>正交相移键控QPSK</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206212108468.png" alt="image-20230206212108468" style="zoom:25%;" /></td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206212156094.png" alt="image-20230206212156094" style="zoom:25%;" /></td>
<td></td>
</tr>
</tbody>
</table>
<p>这个正交相移键控是啥意思呢?</p>
<p>使用同一个信号,里面有两个大的正交分量载波信号</p>
<p>两个分量并行传送</p>
<p>假设要传输信号00'10'01'11</p>
<p>两个一组取前一个扔给一个载波分量</p>
<p>取后一个扔给另一个垂直的载波分量</p>
<p>不用两根导线就可以同时传输两路信息,这就是QPSK的目的</p>
<p>实际上就是两个BPSK的正交</p>
<h4 id="模转模方法">模转模方法</h4>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 46%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr>
<th>模转模方法</th>
<th>图像及原理</th>
<th>带宽<br />B为原始模拟信号带宽</th>
</tr>
</thead>
<tbody>
<tr>
<td>调幅AM</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206213909043.png" alt="image-20230206213909043" style="zoom:25%;" /></td>
<td><span class="math inline">\(B_{AM} = 2B\)</span></td>
</tr>
<tr>
<td>调频FM</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206213914303.png" alt="image-20230206213914303" style="zoom:25%;" /></td>
<td>$ B_{FM} = 2(1 + β)B<span class="math inline">\(&lt;br
/&gt;其中\)</span>$为调制因子,通常设置为4</td>
</tr>
<tr>
<td>调相PM</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/phase.jpg" alt="phase" style="zoom: 67%;" /></td>
<td><span class="math inline">\(B_{PM} = 2(1 + β)B\)</span></td>
</tr>
</tbody>
</table>
<h3 id="带宽利用">带宽利用</h3>
<p>这部分没看懂</p>
<h4 id="复用">复用</h4>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 44%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr>
<th>复用技术</th>
<th>原理</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>频分多路复用FDM</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212145609855.png" alt="image-20230212145609855" style="zoom:25%;" /></td>
<td>合并模拟信号</td>
</tr>
<tr>
<td>波分多路复用WDM</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212145843612.png" alt="image-20230212145843612" style="zoom:25%;" /></td>
<td>合并光信号</td>
</tr>
<tr>
<td>时分多路复用TDM</td>
<td>同步时分复用和统计时分复用的区别<br /><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212150226755.png" style="zoom:25%;" /></td>
<td>同步时分复用中,每一帧的最开始有一帧指示位用于同步,然后就是E,D,C,B,A每一路的数据,即使这一路上没有数据,也得用空时隙填充<br />统计时分复用中是哪一路有数据才传输哪一路,在数据之前标注这是哪一路的数据</td>
</tr>
</tbody>
</table>
<p>复用:允许使用一条数据链路传输多个信号的技术</p>
<h4 id="扩频">扩频</h4>
<p>麻了,啥玩意儿</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/02/08/%E4%BC%A0%E8%BE%93%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/08/%E4%BC%A0%E8%BE%93%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络-传输层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-08 18:08:00" itemprop="dateCreated datePublished" datetime="2023-02-08T18:08:00+08:00">2023-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-05-05 15:57:07" itemprop="dateModified" datetime="2024-05-05T15:57:07+08:00">2024-05-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络-传输层">计算机网络-传输层</h1>
<h2 id="传输层">传输层</h2>
<h3 id="概念">概念</h3>
<p>网络层提供点到点服务,也就是主机到主机的服务</p>
<p>传输层提供端到端服务,也就是进程到进程的服务</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221128103802707.png"
alt="image-20221128103802707" />
<figcaption aria-hidden="true">image-20221128103802707</figcaption>
</figure>
<h4 id="端口号">端口号</h4>
<table>
<thead>
<tr>
<th>层</th>
<th>寻址方式</th>
<th>寻址范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>链路层</td>
<td>MAC地址</td>
<td></td>
</tr>
<tr>
<td>网络层</td>
<td>ip地址</td>
<td>ipv4地址32位</td>
</tr>
<tr>
<td>传输层</td>
<td>端口号</td>
<td>端口号16位</td>
</tr>
</tbody>
</table>
<p><strong>服务端</strong>端口号规定</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221128104113012.png"
alt="image-20221128104113012" />
<figcaption aria-hidden="true">image-20221128104113012</figcaption>
</figure>
<p>客户端都是临时端口,不用管到底用的哪个端口</p>
<h4 id="套接字">套接字</h4>
<p>socket=IP地址+端口号</p>
<p>一个套接字唯一标识了一个进程</p>
<p>一个TCP连接两头是两个套接字,即一个TCP连接被一对套接字决定</p>
<h4 id="差错控制">差错控制</h4>
<p>可靠传输:不错,不丢,不乱</p>
<p>每一层的校验都只校验本层数据</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 66%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr>
<th>层</th>
<th>差错控制的目的</th>
<th>是否可靠</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据链路层</td>
<td>通过CRC校验,保证一个帧中没有比特差错,但不能保证丢不丢帧</td>
<td>否,只能保证不错</td>
</tr>
<tr>
<td>网络层IP协议</td>
<td>只针对网络层包的头部进行CRC校验</td>
<td>否</td>
</tr>
<tr>
<td>传输层TCP协议</td>
<td>保证做到无传输差错</td>
<td>是</td>
</tr>
</tbody>
</table>
<h4 id="应用场景">应用场景</h4>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr>
<th>传输层协议</th>
<th>应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>客户端和服务端多次交互入访问页面HTTP<br />传输文件FTP<br />电子邮件POP3,SMTP</td>
</tr>
<tr>
<td>UDP</td>
<td>实时聊天通信,DNS,多播,广播<br />对等网络技术P2P<br />部分路由协议RIP<br />网络时间管理NTP<br />简单网络管理SNTP</td>
</tr>
</tbody>
</table>
<h3 id="udp">UDP</h3>
<h4 id="udp首部">UDP首部</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221128105608481.png"
alt="UDP首部" />
<figcaption aria-hidden="true">UDP首部</figcaption>
</figure>
<p>源端口,目的端口各16位,总长度16位,校验和16位</p>
<h4 id="校验和">校验和</h4>
<p>UDP的校验和=UDP伪首部+UDP首部+数据</p>
<p>这个伪首部指，源地址、目的地址、协议类型（0x11）,一个字节的全0,一个字节的<strong>UDP数据长度</strong>，对齐填充2字节的0，整个伪首部共12个字节。</p>
<blockquote>
<p><strong>UDP伪首部是为了计算校验和而临时存在的,在计算之前由主机加上,计算之后立刻扔掉,不会参与传输</strong></p>
<p>UDP伪首部和IP首部无关,<strong>不能理解为</strong>借用的IP首部</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/v2-86bb22904619c1bd318996b26b7825c2_720w.webp"
alt="UDP伪首部不是IP首部" />
<figcaption aria-hidden="true">UDP伪首部不是IP首部</figcaption>
</figure>
<p>伪首部中的UDP长度就是UDP首部+UDP数据的长度,不需要考虑对齐填充,是多少就是多少</p>
</blockquote>
<p>伪首部+UDP首部+数据一起计算校验和。</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221128110006207.png"
alt="image-20221128110006207" />
<figcaption aria-hidden="true">image-20221128110006207</figcaption>
</figure>
<p>具体计算方法:</p>
<p><strong>16位一组相加,最高位进位回卷,和Sum取反得到CheckSum</strong></p>
<p>在计算校验和时,此时UDP首部的校验和字段先置零,伪首部中的UDP长度就是实际的UDP长度,15,不用考虑对齐填充</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221128110218290.png"
alt="image-20221128110218290" />
<figcaption aria-hidden="true">image-20221128110218290</figcaption>
</figure>
<h4 id="udpの特点">UDPの特点</h4>
<p>1.报文在发送方这里不会拆分,发送方一次交付一个完整报文.</p>
<blockquote>
<p>注意强调了发送方,因为网络层才不会管你拆不拆,大于MTU的报必须拆</p>
<p>比如如果发送方不管三七二十一发了一个巨大的上万字节的UDP报文</p>
<p>如果数据链路层使用以太网,那么每个以太网帧最大是1500字节,也就是说网络层的MTU=1500(Maximum
Transmission Unit).</p>
<p>显然一个上万字节的UDP数据报无法直接发送,因此路由器会进行报文分割,把该UDP数据报拆分成若干不大于1500字节的包,分开发送</p>
<p>最终在接收方还是需要组装的</p>
</blockquote>
<p>2.无流量控制,无差错控制,无拥塞控制</p>
<blockquote>
<p>差错控制要求发现错误时要求重传,但是UDP数据报的校验和如果发现错误,直接被路由器或者主机丢弃,不会要求重传</p>
</blockquote>
<h3 id="tcp">TCP</h3>
<p>分段传输:虚电路建立之后,看上去TCP协议直接发送和接收字节流,就像访问硬盘一样,但是下层实际上还是数据报实现的</p>
<p>一个图是需要切成好多段,扔给网络层以报文形式交付</p>
<h4 id="tcp协议的熟知端口号">TCP协议的熟知端口号</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230203162222069.png"
alt="image-20230203162222069" />
<figcaption aria-hidden="true">image-20230203162222069</figcaption>
</figure>
<p>特别注意</p>
<p>20-FTP.Data</p>
<p>21-FTP.Control</p>
<p>53-DNS</p>
<h4 id="字节流">字节流</h4>
<p>啥玩意叫字节流?</p>
<p>啥玩意叫流?Stream,在计算机里就是顺序读取或者写入的字节序列.</p>
<p>包括从硬盘读取的文件,从键盘输入的字符序列,从网络获取的字符序列.都叫流</p>
<p>叫做字节流,是因为还有一个字符流</p>
<p>两者的区别是,字节流使用8位一个字节为信息单元,一个字节传输一个信息,比如一个字母</p>
<p>而字符流使用16位两个字节作为信息单元,使用unicode编码传输信息</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221128111751747.png"
alt="image-20221128111751747" />
<figcaption aria-hidden="true">image-20221128111751747</figcaption>
</figure>
<p>"流"是<strong>针对应用层上的应用程序而言</strong>的,在应用程序看来,他调用read函数从硬盘读取字节流和调用recv函数从套接字获取字节流没有区别.</p>
<p>反正就是得用<code>while(!read.eof())&#123;read(buf,n,file);...&#125;</code>这样不停地从缓冲区取出字节,因为一个文件的传输,是像水流一样,源源不断地抵达缓冲区的,不可以一下子全部获取</p>
<p>传输层只管给应用程序的缓冲区写入数据,不管应用程序拿着数据干了啥</p>
<p>应用程序只管从缓冲区读取数据,不管传输层从哪里搞来的数据</p>
<p>因此,传输层单蹦个地顺序传送比特位,还是单蹦个顺序传送字节,抑或是分段每次传送成千个字节即分段,应用程序不关心,全靠传输层自由发挥了</p>
<p>显然传输层应该选择分段发送,这样效率高</p>
<blockquote>
<p>为什么效率高?</p>
<p>对于网络来说头部长度固定,数据部分越长有效信息比例越高,需要发送的数据报越少,网络负载也就轻</p>
<p>对于主机来说,每个字节就发送一次,需要频繁地系统调用(显然访问网络这种外设需要系统调用),开销太大</p>
</blockquote>
<h4 id="首部格式">首部格式</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221128111530489.png"
alt="image-20221128111530489" />
<figcaption aria-hidden="true">image-20221128111530489</figcaption>
</figure>
<h5 id="sourcedestination-port-address">Source/Destination port
address</h5>
<p>源/目的端口地址</p>
<h5 id="sequence-number">sequence number</h5>
<p>字节序列号,一个TCP包可以发送若干数据字节,每一个数据字节都编一个字节序列号,</p>
<p>在首部中sequence
number表明本TCP报文中<strong>第一个数据字节的编号</strong></p>
<p>本字段用于分段系统</p>
<h5 id="acknowledgment-number">acknowledgment number</h5>
<p>确认号字段,<strong>期望收到的,对方下一个报文段数据的,第一个字节的序号</strong></p>
<p>本字段用于分段系统</p>
<h5 id="hlen">HLEN</h5>
<p>header length首部长度,<strong>其单位是4字节</strong></p>
<p>比如HLEN=5=0101b,表示首部长度为5*4=20字节</p>
<h5 id="reserved">Reserved</h5>
<p>保留字段,6位,目前全置零</p>
<h5 id="控制字段">控制字段</h5>
<p>6位</p>
<p>用于TCP连接的流量控制,连接建立终止,连接失败和数据传送方式</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221128113731360.png"
alt="image-20221128113731360" />
<figcaption aria-hidden="true">image-20221128113731360</figcaption>
</figure>
<p>当URG=1时,紧急指针Urgent pointer才有效</p>
<blockquote>
<p>如何体现紧急?</p>
<p>正常情况下一个TCP报文段会拆分重组</p>
<p>整个重组利索之后才会交付给应用程序</p>
<p>而紧急数据无需等待重组,直接交给应用程序</p>
</blockquote>
<p>ACK,确认,1代表acknoledgment number字段有效</p>
<p>PSH,请求急迫,发送端不需等待窗口填满才发送</p>
<blockquote>
<p>PSH用于什么情况?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20210317143111661.png"
alt="缓冲区与PSH" />
<figcaption aria-hidden="true">缓冲区与PSH</figcaption>
</figure>
<p>进程A向socket写东西,实际上就是写到发送缓冲区中,此时并没有实际往网络上发送,啥时候发送呢?得等到缓冲区满了才发,这就像是机场包车的包不满不走一样</p>
<p>而PSH位就是要强迫发送,即使车没有坐满人,也把枪夹到司机头上给我立刻发车</p>
<p>有意义吗?急着发车干啥?还真有意义</p>
<p>有的乘客不在乎自己坐车多花的开销,他急着办事.</p>
<p>正如有些服务的及时性比效率更优先</p>
<p>比如ssh服务</p>
<p>客户端这会急着想看服务端根目录下有啥,于是客户端想发送一个ls命令,如果不加psh位,好吧你等着吧,啥时候缓冲区满了才发送.实际上ssh服务是psh=1的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230203172915324.png"
alt="image-20230203172915324" />
<figcaption aria-hidden="true">image-20230203172915324</figcaption>
</figure>
</blockquote>
<p>RST,重置连接</p>
<p>SYN,同步信号,建立连接时使用</p>
<p>FIN,结束</p>
<h5 id="window-size">window size</h5>
<p>窗口大小,单位字节</p>
<p>用于<strong>控制对方发送的数据量</strong></p>
<p>根据自身缓冲区剩余空间大小,决定接收窗口大小,通知对方发送窗口上限</p>
<h5 id="checksum">checksum</h5>
<p>检验和</p>
<p>TCP检验和=TCP伪首部+TCP首部+TCP数据</p>
<p>其中TCP伪首部和UDP伪首部一模一样</p>
<h5 id="urgent-pointer">urgent pointer</h5>
<p>紧急指针字段,</p>
<p>如果有紧急数据,则一定放在TCP数据的最开始</p>
<p>紧急指针表明紧急数据的大小,单位字节</p>
<h5 id="option">option</h5>
<p>选项字段,长度可变</p>
<p>通常不用这个字段</p>
<p>TCP之规定一种选项,MSS,最大报文段长度,即TCP数据的最大长度</p>
<h4 id="序号系统">序号系统</h4>
<p>由于TCP报文需要分段,因此需要引入一套编号机制,让分段和重组有序</p>
<p>TCP首部的sequence number,acknowledgment
number两个字段和ACK,SYN两个标志位就是为序号系统服务的</p>
<p>需要牢记的是:</p>
<p><strong>编号是给每个字节的编号,不是给分段的编号!</strong></p>
<p><strong>编号是给每个字节的编号,不是给分段的编号!</strong></p>
<p><strong>编号是给每个字节的编号,不是给分段的编号!</strong></p>
<p>所有数据的第一个字节是一个<span
class="math inline">\([0,2^{32})\)</span>内的随机数</p>
<p>sequence number,该TCP报文段段第一个数据字节的编号</p>
<p>acknowledgment
number,希望接收的下一个报文段的第一个数据字节的编号.也表明接收方已经正确接收该编号-1之前的所有字节</p>
<p>比如这么一个问题</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230203173943002.png"
alt="image-20230203173943002" />
<figcaption aria-hidden="true">image-20230203173943002</figcaption>
</figure>
<p>显然第一问是100-70=30</p>
<p>第二问,主机B接收到的字节序列应该是<span
class="math inline">\([70,99]\)</span>,因此ack
number=100,表明希望接收编号为100的字节,并且告知发送方,编号为99及之前的所有字节都已经正确接收了</p>
<h4 id="连接建立终止">连接建立&amp;终止</h4>
<p>三次握手建立连接</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230203224344990.png"
alt="image-20230203224344990" />
<figcaption aria-hidden="true">image-20230203224344990</figcaption>
</figure>
<p>服务端是被动打开的,而客户端是主动打开的</p>
<p>三次握手建立连接的目的是,证明通信双方的收发都正常</p>
<p>第一次握手,客户端啥也不知道,但是服务端知道客户端不哑,自己不聋</p>
<p>第二次握手,客户端知道了服务端收到了自己的消息,证明自己不哑,这次收到消息证明自己不聋.</p>
<p>此时只剩最后一步,此时服务端不知道自己是否哑巴</p>
<p>第三次握手,服务端收到客户端对第二次握手的确认,因此证明服务端不哑</p>
<p>第三次握手时,实际上客户端已经可以在TCP数据中,写上对服务端请求什么了</p>
<p>然而实际上HTTP协议中,三次握手不涉及任何有效数据传输,三次握手建立之后,客户端会另外发送GET请求</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230203225616420.png"
alt="image-20230203225616420" />
<figcaption aria-hidden="true">image-20230203225616420</figcaption>
</figure>
<p>四次挥手断开连接的目的是:</p>
<p>首先客户端主动提出FIN分手,表明客户端没有要求了</p>
<p>服务端收到客户端的分手请求后,立刻回复ACK收到,但是如果服务端还有没说完的话,还可以继续说.</p>
<p>这个阶段叫做半关闭阶段,客户端只能回复收到,不会再有新的请求</p>
<p>如果服务端也说完了,没有其他话要说了,就发送FIN</p>
<p>然后客户端收到FINI之后知道服务端也没得说了,回复收到</p>
<p>到此整个连接关闭</p>
<h4 id="流量控制">流量控制</h4>
<blockquote>
<p>区分流量控制和拥塞控制:</p>
<p>流量控制是避免接收方来不及接收,缓冲区溢出</p>
<p>拥塞控制是避免网络拥塞</p>
</blockquote>
<p>为啥要进行流量控制?</p>
<p>接收方的缓冲区大小有限,要保证接收方来得及接收消息并腾出缓冲区</p>
<p>如果发送方发的过快,接收方处理慢,缓冲区满了,那么后来的消息就会被直接丢弃</p>
<p>如何进行流量控制?滑动窗口算法</p>
<h5 id="滑动窗口算法">滑动窗口算法</h5>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230204190749379.png"
alt="image-20230204190749379" /> <span class="math display">\[
发送方滑动窗口大小swnd=min(接收方滑动窗口大小rwnd,拥塞窗口大小cwnd)
\]</span> 其中rwnd是接收方缓冲区剩余空间大小</p>
<p>比如接收方缓冲区本身4KB,发送方发了一个1K的报文,填到接收方缓冲区中,此时接收方rwnd=3000,接收方就得在ACK报文中报告自己的rwnd大小,让发送方心里有数,后面该法多少</p>
<p>cwnd是发送方自己维护的,发送方根据接收方的回应报文丢失情况,推测网络的拥塞程度,动态调整cwnd的大小</p>
<blockquote>
<p>TCP滑动窗口和数据链路层滑动窗口的区别:</p>
<p>TCP滑动窗口的单位是字节,而数据链路层滑动窗口的单位是帧</p>
<p>数据链路层的滑动窗口大小是固定的,而TCP滑动窗口大小根据实时情况改变</p>
</blockquote>
<p>如图所示的滑动窗口(只是一个例子,实际上一个滑动窗口有成百上千字节)中,cwnd=20,rwnd=9,</p>
<p>这就意味着接收方此时的缓冲区只有9个字节的空间了,发送方顶多再发送9字节</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208173522440.png"
alt="image-20230208173522440" />
<figcaption aria-hidden="true">image-20230208173522440</figcaption>
</figure>
<p>此时发送方啥状态呢?目前滑动窗口中的200,201,202三个字节都已经发送,可能是一个报文同时发走的,也可能是分批发走的,但是这不重要,重要的是,目前尚未得到接收方的ACK回复.发送方现在还可以接着发送203~208这6个字节.</p>
<p>如果发完了这6个字节仍热没有收到回复,就不能发了,得等等</p>
<p>时序图</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208174029314.png"
alt="image-20230208174029314" />
<figcaption aria-hidden="true">image-20230208174029314</figcaption>
</figure>
<p>首先发送方得等接收方告知自己的接收窗口大小</p>
<p>拿到这个数之后,发送方就可以在这个接收窗口大小和拥塞窗口大小中娶一个最小值,然后放心地发送这么多字节</p>
<p>这些字节不必是一个报文发走的,这要看链路层对一个数据帧的限制,比如以太网帧中的数据不能超过1500字节.因此,即使swnd=min(cwnd,rwnd)=2400,也得分成多个报文发送</p>
<p>接收方会对发送方的每一个报文都进行回复,回复内容包括:</p>
<p>1.期待接收的下一个字节编号</p>
<p>2.当前接收方窗口剩余大小</p>
<p>当接收方的回复报文中,swnd=0时,发送方就得停下等接收方消化消化.</p>
<p>接收方消化一阵子之后,缓冲区有比较大的空间,能够容纳一个大帧时,才会主动发送更新报文.告知发送方,可以继续灌输了</p>
<blockquote>
<p>等待缓冲区有较大空间的目的是,防止糊涂窗口综合征</p>
</blockquote>
<p>这个更新报文的内容包括:</p>
<p>1.期待接收的下一个字节编号</p>
<p>2.当前接收方窗口剩余大小</p>
<p>为了防止这个更新报文丢包,发送方有一个坚持计时器.当发送方接到swnd=0的回复报文就开始了.如果在到时之前收到更新报文自然最好.如果没有收到,则发送方认为更新报文在路上丢了,于是发送方发送一个1字节的探测报文,提醒接收方更新报文丢失了.</p>
<h4 id="差错控制-1">差错控制</h4>
<p>TCP的差错控制有三个手段</p>
<p>1.校验和,接收方收到坏段,丢弃并要求重传,通过ACK+坏段序号 要求重传</p>
<p>2.确认</p>
<p>发送方发出的每一个数据段都需要ACK确认</p>
<p>不携带数据但是占用序号的控制段也需要确认</p>
<p><strong>ACK段不需要确认</strong>,因为ACK本身就是确认用的</p>
<p>3.重传</p>
<p>当段损坏,丢失或者超时,需要重传</p>
<p><strong>ACK段不需要重传</strong></p>
<blockquote>
<p>重传的情形:</p>
<p>1.丢失段</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208175609900.png"
alt="image-20230208175609900" />
<figcaption aria-hidden="true">image-20230208175609900</figcaption>
</figure>
<p>2.3ACK快速重传</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208175633242.png"
alt="image-20230208175633242" />
<figcaption aria-hidden="true">image-20230208175633242</figcaption>
</figure>
</blockquote>
<h4 id="拥塞控制">拥塞控制</h4>
<p>拥塞控制可以理解为网络流问题</p>
<p>一条主干道的带宽是1000Mbps,其支线的带宽和是1500Mbps,如果所有支线都满载传输,则骨干路由器就得缓存支线的数据报文,满满地往主干道发.</p>
<p>如果骨干路由器缓冲区溢出,就有数据丢包了</p>
<p>拥塞控制还是滑动窗口算法,并且和流量控制兼容,体现在 <span
class="math display">\[
swnd=min(cwnd,rwnd)
\]</span></p>
<h5 id="慢启动和拥塞避免">慢启动和拥塞避免</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208180115427.png"
alt="image-20230208180115427" />
<figcaption aria-hidden="true">image-20230208180115427</figcaption>
</figure>
<p>最初慢启动阶段,cwnd=1,发一个报文,收到ACK,这就意味着一次发一个包,网络可以承受,于是蹬鼻子上脸,cwnd=2,发俩报文,等俩ACK,如果又都受到了,那就更加猖狂</p>
<p>一直到慢启动阈sstresh,之后就不能指数扩大cwnd了,需要加性增大,也就是发一个包收到ACK就cwnd扩大1,一直这样直到计时器超时,说明达到网络流量上限了,</p>
<p>此时立刻回到慢启动阶段,cwnd=1,并重新设置ssthresh阈值为超时cwnd的一半</p>
<p>之后重复上述过程</p>
<h5 id="ack快速恢复">3ACK快速恢复</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208180505456.png"
alt="image-20230208180505456" />
<figcaption aria-hidden="true">image-20230208180505456</figcaption>
</figure>
<p>能够收到3ACK说明网络只是轻度拥塞</p>
<p>此时直接ssthresh降为收到3ACK时cwnd的一半,然后设置cwnd=ssthresh,然后重复加性增大阶段</p>
<h5 id="状态转移图">状态转移图</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208180715552.png"
alt="image-20230208180715552" />
<figcaption aria-hidden="true">image-20230208180715552</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/02/08/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/08/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络-数据链路层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-08 15:22:00" itemprop="dateCreated datePublished" datetime="2023-02-08T15:22:00+08:00">2023-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-12 18:43:43" itemprop="dateModified" datetime="2023-02-12T18:43:43+08:00">2023-02-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络-数据链路层">计算机网络-数据链路层</h1>
<h2 id="数据链路层">数据链路层</h2>
<h3 id="数据链路层的任务">数据链路层的任务</h3>
<p>数据链路层的功能:成帧,流量控制,差错控制,通信</p>
<p>成帧:多个数据帧之间如何区分?添加标志位,比如011111,如果接收方发现一个0后面连着5个1,就认为这和刚才接收到的数据不是一个帧的.</p>
<p>流量控制用于,限制发送方在等到确认之前发送的数据数量</p>
<p>差错控制指望重发,说官话就是"自动重复请求"(ARQ,Automatic Repeat
Request)</p>
<h3 id="冗余编码">冗余编码</h3>
<p>冗余:Redundancy</p>
<p>冗余本是多余的意思,在计算机中,冗余量和业务逻辑无关,没有冗余照样执行业务</p>
<p>但是冗余可以增强非业务性能,比如信息论上的冗余可以提高发现错误和纠正错误的能力</p>
<blockquote>
<p>考虑8个工件有一个坏件,质量和其他的不同(具体重了还是清了不知道)</p>
<p>最快多少次找到?这实际上就是尽量减少冗余,尽最大可能利用信息熵的问题</p>
<p>采用二分需要单调性,即知道这个坏件轻了还是重了,现在不知道,没法二分</p>
<p>三分?3v3v2,还是那个问题,3v3不知道哪个是标准</p>
<p>四分?(2v2)v(2v2).其中必有一组2v2都是标准件,天平平衡</p>
<p>不妨设前一个2v2平等,说明坏件一定在后面的2v2中,并且前面四个都是标准件,可以用来参考</p>
<p>后面的2v2就不用称了,每个2直接和两个标准件比较</p>
<p>必然有一组不平衡,这就意味着另一组必定平衡,从不平衡组任意拿出一个,和标准件对比</p>
<p>如果是坏件则天平不平衡,否则如果是好件,则同组另一件必定坏件</p>
</blockquote>
<h4 id="块编码">块编码</h4>
<blockquote>
<p>数据字+冗余=码字</p>
<p>什么思想呢?</p>
<p>假如原来要传输一个比特,要么是0要么是1</p>
<p>但是路上可能发生各种变故导致1变成0.但是接收方不知道发生了变故,它认为人家就是发送的0,于是错误接收了0</p>
<p>为了增加检错能力</p>
<p>添加一位冗余,比如数据字为0,码字就为00.数据字为1,码字就为11</p>
<p>这样如果有一位发生突变(认为两位同突变的概率低),会形成01或者10这种无效码字,发现错误</p>
<p>那么问题又来了,如果接到01,怎么确定它是00还是11变来的?两者都只需要突变一位就能形成01,因而只添加一位冗余无法纠错</p>
<p>于是再添加一位冗余,只有000和111合法</p>
<p>那么接到100,认为它是000突变来的,这个概率要比他是从111突变来的大.</p>
<p>于是就有了纠错能力.</p>
</blockquote>
<p>实际上的块编码,是多位为一个数据字</p>
<p>整个报文划分为弱干块,每块k位,称为数据字</p>
<p>每块中假如r个冗余位,块长度变为n=k+r,形成这个n位的块叫做码字</p>
<p>码字有<span
class="math inline">\(2^n\)</span>种,但是其中实际承载数据字的只有<span
class="math inline">\(2^k\)</span>种</p>
<p>如果一个承载数据的码字,其中的一位或者几位发生突变,突变之后的码字:</p>
<p>如果如果不承载数据,则可以被检错</p>
<p>如果也是承载数据的码字,则无法检错</p>
<p>比如4B/5B编码(部分)中:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208093738919.png"
alt="image-20230208093738919" />
<figcaption aria-hidden="true">image-20230208093738919</figcaption>
</figure>
<p>如果0100的编码01010最后一位发生突变,编程了01011,这是0101的编码.那么错误就检查不出来了,接收方会认为发送方一开始就是发的0101</p>
<p>下面推导,检错能力和纠错能力的条件是什么</p>
<h5 id="汉明距离">汉明距离</h5>
<p>假设只有一位突变</p>
<p>如果两个有效码字只有一位不同,这样不具备检错能力</p>
<p>如果任何两个有效码字至少有两位不同.这样才具备检错能力,但是不具备纠错能力</p>
<p>如果任何两个有效码字至少有三位不同.这样才具备纠错一位的能力,也可以检错两位</p>
<p>定义两个长度相同的字x,y的汉明距离是对应位不同的数量,记作<span
class="math inline">\(d(x,y)\)</span> <span class="math display">\[
d(x,y)=x\oplus y 结果中1的数量
\]</span> 最小汉明距离:一组字所有对中最小的汉明距离</p>
<h5 id="编码方案">编码方案</h5>
<p>块编码方案记为<span class="math inline">\(C(n,k)\ with\
d_{min}=x\)</span></p>
<p>其中n是码字长度,k是数据字长度.<span
class="math inline">\(d_{min}\)</span>是<strong>有效</strong>码字的最小汉明距离</p>
<p>当可以检错<span class="math inline">\(s\)</span>个错误时,要求<span
class="math inline">\(d_{min}=s+1\)</span></p>
<p>当可以纠错<span class="math inline">\(s\)</span>个错误时,要求<span
class="math inline">\(d_{min}&gt; 2s\)</span>,也就是<span
class="math inline">\(d_{min}=2s+1\)</span></p>
<blockquote>
<p>因此最好采用奇数长度的码字</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208100459337.png"
alt="image-20230208100459337" />
<figcaption aria-hidden="true">image-20230208100459337</figcaption>
</figure>
<p>x和y两个有效码字,有相同的概率突变为同一个错误码字,因而无法纠错</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208101051053.png"
alt="image-20230208101051053" />
<figcaption aria-hidden="true">image-20230208101051053</figcaption>
</figure>
<p>x突变s位之后依然落在半径为s的圈里,而任意两个圈相离,也就是说一个错误码字一定有一个概率最大的突变来源.</p>
<p>这就有了纠错能力</p>
<h4 id="线性块编码">线性块编码</h4>
<p>线性块编码:任何两个有效码字的异或生成另一个有效码字.比如:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208101612648.png"
alt="image-20230208101612648" />
<figcaption aria-hidden="true">image-20230208101612648</figcaption>
</figure>
<h5 id="最小汉明距离">最小汉明距离</h5>
<p>线性快编码的最小汉明距离:1的个数最少的非零有效码字中的1的个数</p>
<p>还是以上图为例</p>
<table>
<thead>
<tr>
<th>非零码字</th>
<th>1的个数</th>
</tr>
</thead>
<tbody>
<tr>
<td>01011</td>
<td>3</td>
</tr>
<tr>
<td>10101</td>
<td>3</td>
</tr>
<tr>
<td>11110</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>因此<span class="math inline">\(d_{min}=3\)</span></p>
<h5 id="简单奇偶校验编码">简单奇偶校验编码</h5>
<p><span class="math inline">\(n=k+1,d_{min}=2\)</span></p>
<p>只有一位校验位</p>
<p>比如<span class="math inline">\(C(5,4)\)</span></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208102201761.png"
alt="image-20230208102201761" />
<figcaption aria-hidden="true">image-20230208102201761</figcaption>
</figure>
<p>突变奇数位可以被检查出</p>
<p>突变偶数位不可以</p>
<h5 id="二维奇偶校验">二维奇偶校验</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208102627543.png"
alt="image-20230208102627543" />
<figcaption aria-hidden="true">image-20230208102627543</figcaption>
</figure>
<p>两维奇偶校验能检测出所有3位或3位以下的错误（因为此时至少在某一行或某一列上有一位错）、奇数位错以及很大一部分偶数位错。</p>
<h4 id="汉明编码">汉明编码</h4>
<p>对于汉明编码<span
class="math inline">\(C(n,k),d_{min}=3\)</span>,有如下关系: <span
class="math display">\[
\begin{cases}
n=2^m-1\\
k=n-m\\
r=m
\end{cases}
\]</span> 比如<span class="math inline">\(C(7,4)\)</span>中,<span
class="math inline">\(n=7=2^m-1\)</span>得到m=3</p>
<p><span class="math inline">\(k=n-m=7-3=4\)</span>即数据字位数</p>
<p><span class="math inline">\(r=m=3\)</span>即冗余位数</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208103155013.png"
alt="image-20230208103155013" />
<figcaption aria-hidden="true">image-20230208103155013</figcaption>
</figure>
<p>如何检错?</p>
比如数据字0111,计算冗余校验位: $$
<span class="math display">\[\begin{cases}
r_0=a_2+a_1+a_0=1+1+1=1\\
r_1=a_3+a_2+a_1=0+1+1=0\\
r_2=a_1+a_0+a_3=1+1+0=0

\end{cases}\]</span>
<p>$$ 得到码字<span class="math inline">\(0111001\)</span></p>
<p>如果码字没有错误,那么接收方计算得到的q2q1q0应该全零</p>
<p>如果码字有一位出现错误,变成<span
class="math inline">\(0110001\)</span></p>
<p>在接收方(接收方认为顶多有一位发生错误): <span class="math display">\[
q_0=b_2+b_1+b_0+q_0=1+1+0+1=1
\]</span>
此时已经发现错误了,但是不能确认是b2,b1,b0,q0这四位中的哪一位出现的差错</p>
<p>然后又算得 <span class="math display">\[
q_1=b_3+b_2+b_1+q_1=0+1+1+0=0
\]</span> 说明b3b2b1q1都没错误,那么只有b0,q0中有错误</p>
<p>然后又算得 <span class="math display">\[
q_2=b_1+b_0+b_3+q_2=1+0+0+0=1
\]</span> 可以肯定是<span class="math inline">\(b_0\)</span>的错误了</p>
<blockquote>
<p>如果数据字至少是7位,计算满足一位检错条件的汉明编码方案 <span
class="math display">\[
\begin{cases}
n=2^m-1\\
k=n-m\\
r=m
\end{cases}
\]</span></p>
<p><span class="math display">\[
k=n-m=2^m-1-m\ge7
\]</span></p>
<p>解得</p>
<p><span class="math inline">\(m=4,n=15,k=11\)</span></p>
<p>因此满足条件的编码方案是<span
class="math inline">\(C(15,11)\)</span></p>
</blockquote>
<h4 id="循环冗余编码">循环冗余编码</h4>
<p>Cyclic Redundancy Check,CRC</p>
<p><span class="math inline">\(C(n,k)\)</span></p>
<p>n位的码字,其中k位数据字,最右边加上n-k个0作为校正子的初始值,这样n位传递给生成器</p>
<p>生成器用长度n-k+1的除数去除码字</p>
<p>得到n-k位余数,填到校正子上</p>
<p>真码字(数据字:校正子)就计算完毕了,然后传输,然后被接收</p>
<p>接收方校验器用相同除数除码字</p>
<p>如果得到n-k位余数是0则无误,码字前k位就是数据字</p>
<p>否则丢弃</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208110416498.png"
alt="image-20230208110416498" />
<figcaption aria-hidden="true">image-20230208110416498</figcaption>
</figure>
<p>计算过程</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208111036131.png"
alt="image-20230208111036131" />
<figcaption aria-hidden="true">image-20230208111036131</figcaption>
</figure>
<h5 id="多项式">多项式</h5>
<p>CRC的除数称为生成多项式,简称生成子或者生成器<span
class="math inline">\(g(x)\)</span></p>
<p>码字<span
class="math inline">\(c(x)=d(x):s(x)\)</span>,码字就是数据字和校正子的增广</p>
<p>差错<span class="math inline">\(e(x)\)</span></p>
<p>校验原理:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208111438640.png"
alt="image-20230208111438640" />
<figcaption aria-hidden="true">image-20230208111438640</figcaption>
</figure>
<p>在发送端计算完的真码字一定满足<span
class="math inline">\(\frac{c(x)}{g(x)}=0\)</span></p>
<p>因此对接收方的码字除以<span
class="math inline">\(g(x)\)</span>,如果不为零,说明一定存在<span
class="math inline">\(\frac{e(x)}{g(x)}\)</span>这一项,也就是说分子不为零,即存在<span
class="math inline">\(e(x)\)</span>这一项,即存在差错</p>
<p>生成多项式的形式决定了检错能力</p>
<h5 id="单个位差错">单个位差错</h5>
<p>单个位差错是指<span class="math inline">\(e(x)=x^i\)</span>的情形</p>
<p>检测单个位差错需要保证<span
class="math inline">\(e(x)\)</span>不能被<span
class="math inline">\(g(x)\)</span>整除</p>
<p>比如如果设置<span
class="math inline">\(g(x)=1\)</span>,则任何多项式都被<span
class="math inline">\(g(x)\)</span>整除,这就查不出任何错误来</p>
<p>如果生成多项式至少有两项,并且有1这一项(也就是<span
class="math inline">\(x^0\)</span>这一项),那么所有单比特错误都可以检出</p>
<p><strong>也就是说,<span
class="math inline">\(g(x)\)</span>的作用是,出现差错时,<span
class="math inline">\(e(x)\)</span>无法被<span
class="math inline">\(g(x)\)</span>整除</strong></p>
<h5 id="两独立位差错">两独立位差错</h5>
<p>两独立位差错指<span class="math inline">\(e(x)=x^i+x^j\)</span>的情形
<span class="math display">\[
e(x)=x^i+x^j=x^i(x^{j-i}+1)=x^i(x^t+1)
\]</span> 如果生成多项式<span
class="math inline">\(g(x)\)</span>无法整除<span
class="math inline">\(x^t+1\)</span>则所有独立两位错误都可以检查出来</p>
<p>比如<span
class="math inline">\(x+1\)</span>不能检查出两个相邻位的错误</p>
<p><span
class="math inline">\(x^4+1\)</span>无法检查出两个相隔4位的错误</p>
<p><span
class="math inline">\(x^3+x^2+1\)</span>就可以检查所有两个独立位错误</p>
<h5 id="奇数个位差错">奇数个位差错</h5>
<p>奇数个位错误指: <span class="math display">\[
e(x)=x^{i1}+x^{i2}+...+x^{ik}
\]</span> 其中k是奇数</p>
<p>只要是<span class="math inline">\(g(x)\)</span>包含<span
class="math inline">\(x+1\)</span>因式,就可以检查出<span
class="math inline">\(e(x)\)</span>,证明:</p>
<p>假设检查不出来,即<span class="math inline">\(g(x)|e(x)\)</span> <span
class="math display">\[
g(x)|e(x),x+1|g(x)\rightarrow x+1|e(x)
\]</span> 只需要证明<span
class="math inline">\(x+1|e(x)\)</span>不能成立</p>
<p>如果任何一个偶数项多项式都可以被<span
class="math inline">\(x+1\)</span>整除,那么任何奇数项多项式,就可以拆成一个偶数项多项式加一个单独的多项式.那么问题转化为单个比特错误</p>
<p>于是只需要证明任何偶数项多项式可以被<span
class="math inline">\(x+1\)</span>整除</p>
<p>由于任何偶数项多项式,都可以转化为若干个这种形式的和 <span
class="math display">\[
x^a(x^t+1)
\]</span></p>
<p>由于多项式系数在<strong>模2域上,</strong>因此上式又可以写为 <span
class="math display">\[
x^n(1-x+x^2-x^3+...)=x^n\frac{1-(-x)^t}{1-(-x)}
\]</span> 当t是奇数时由上式得到 <span class="math display">\[
x^t+1=(x+1)(x^{t-1}-x^{t-2}+x^{t-3}-...)
\]</span> 当t不是奇数,是偶数比如<span
class="math inline">\(e(x)=x^2+1\)</span>,此时t=2是偶数</p>
<p>这就可以利用系数在模2域上的性质了</p>
<p>此时<span
class="math inline">\(e(x)=x^2+1=x^2+2x+1=(x+1)^2\)</span></p>
<p>推广一下,可以得到<span
class="math inline">\(x^t+1=(x+1)^t\)</span>其中t是偶数,并且系数在模2域上</p>
<p>这就证明了<span
class="math inline">\(x+1\)</span>整除任何偶数项多项式</p>
<h5 id="突发性错误">突发性错误</h5>
<p>突发恶疾指接连几个bit位都可能发生错误 <span class="math display">\[
e(x)=x^j+...x^i=x^j(1+...+x^{i-j})
\]</span> 令<span
class="math inline">\(e&#39;(x)=1+...+x^{i-j}\)</span></p>
<p>意思时,起码两头的i,j两位是有错误的,中间的位可能有错误也可能无误,但是无所谓</p>
<p>设<span
class="math inline">\(L=i-j+1\)</span>,意思是突发性错误的长度</p>
<p>这L位中,提出公因式<span
class="math inline">\(x^j\)</span>之后,最低次项是1,最高次项是<span
class="math inline">\(x^{i-j}\)</span>,这两项肯定得有</p>
<p>设<span
class="math inline">\(g(x)=x^r+...+1\)</span>表示生成多项式,它至少包含<span
class="math inline">\(x^r+1\)</span>两项,这保证了可以检测任何单比特错误.其他比r低次的项可有可无.</p>
<p><strong>如果<span class="math inline">\(g(x)\)</span>阶比<span
class="math inline">\(e&#39;(x)\)</span>大</strong>,即r&gt;L-1,显然<span
class="math inline">\(\frac{e&#39;(x)}{g(x)}\)</span>是有余数的,此时任何差错都可以检查出来</p>
<p><strong>如果<span class="math inline">\(g(x)\)</span>和<span
class="math inline">\(e&#39;(x)\)</span>同阶</strong>,即r=L-1,</p>
<p>此时只有<span
class="math inline">\(e&#39;(x)=g(x)\)</span>只有这种情况没有余数,这个概率是多大呢?</p>
<p>要求<span class="math inline">\(g(x)\)</span>和<span
class="math inline">\(e&#39;(x)\)</span>的每一项系数都相同,根据概率论独立事件乘法原则,这个概率是
<span class="math display">\[
P(g(x)=e&#39;(x))=(\frac{1}{2})^{L-2}=(\frac{1}{2})^{r-1}
\]</span></p>
<blockquote>
<p>这里L-2的原因是,<span
class="math inline">\(g(x),e&#39;(x)\)</span>最高次项和常数项1都已经是相同的了,只需要考虑中间各项的情况</p>
</blockquote>
<p>因此r=L-1时,能够检查出错误的概率是<span
class="math inline">\(1-(\frac{1}{2})^{r-1}\)</span></p>
<p><strong>如果<span class="math inline">\(g(x)\)</span>比<span
class="math inline">\(e&#39;(x)\)</span>阶小</strong>,即L&gt;r+1时,考虑啥情况检查不出错误?</p>
<p>比如<span class="math inline">\(e(x)=x^6+x^5+x+1\)</span>,<span
class="math inline">\(g(x)=x^5+1\)</span></p>
<p>此时<span
class="math inline">\(\frac{e(x)}{g(x)}=x+1\)</span>可以被整除,无法检查出错误</p>
<p>考虑对于任意一个<span
class="math inline">\(g(x)\)</span>,只要是其阶比<span
class="math inline">\(e&#39;(x)\)</span>小,一定存在<span
class="math inline">\(e&#39;(x)\)</span>,使得<span
class="math inline">\(g(x)|e&#39;(x)\)</span>吗?</p>
<p>确实如此,只需要构造<span
class="math inline">\(e&#39;(x)=x^{L-1-r}g(x)+g(x)=(x^{L-1-r}+1)g(x)\)</span></p>
<p>这是一个临界条件,保证了阶是L-1并且存在常数项1</p>
<p>还可以往里随便加<span
class="math inline">\(x^kg(x),k\in(0,L-1-r)\)</span>项</p>
<p>这样满足条件的构造共有<span
class="math inline">\(2^{L-2-r}\)</span>种</p>
<p>而L-1阶含常数项1的多项式共有<span
class="math inline">\(2^{L-2}\)</span>个</p>
<p>因此构造的出现概率就是<span
class="math inline">\(\frac{2^{L-2-r}}{2^{L-2}}=(\frac{1}{2})^r\)</span>,也就是检不出错误的概率</p>
<p>那么能够检查出错误的概率就是<span
class="math inline">\(1-(\frac{1}{2})^r\)</span></p>
<p>总结:</p>
<p>所有$L ≤ r $的突发性差错均可被检测到。</p>
<p>所有$L = r + 1 $的突发性差错有$1 – (1/2)r–1 $的概率被检测到。</p>
<p>所有$L &gt; r + 1 $的突发性差错有$1 – (1/2)r $ 的概率被检测到。</p>
<h5 id="高性能多项式特性">高性能多项式特性</h5>
<ol type="1">
<li>至少有两项,要有常数项1,保证检查一位错误</li>
<li>不能整除 <span class="math inline">\(x^t + 1(2 ≤ t ≤ n −
1)\)</span>,保证检查两个独立位错误</li>
<li>应当有因子 <span class="math inline">\(x +
1\)</span>,保证检查所有奇数位数错误</li>
</ol>
<h4 id="校验和">校验和</h4>
<p>脚丫子都知道怎么算,注意结果要取反</p>
<h3 id="数据链路层协议">数据链路层协议:</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230204191849501.png"
alt="image-20230204191849501" />
<figcaption aria-hidden="true">image-20230204191849501</figcaption>
</figure>
<p>只要带上ARQ的肯定有差错控制功能</p>
<p>noiseless
channel是没有噪声,不会丢包,不会重复,无损坏帧的理想信道,最简单协议和停止等待协议只是最初的一厢情愿</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 42%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr>
<th>协议</th>
<th>特点</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>simplest</td>
<td>纯纯理想环境,<br />发送方不需要考虑丢包坏帧的情况,要说啥只说一遍,不多废话<br />接收方就洗耳恭听,也不需要回复收到</td>
<td></td>
</tr>
<tr>
<td>stop-and-wait</td>
<td>发送方发<strong>一个</strong>帧,就等着接收方回复收到<br />如果没有收到回复,那么可能是网络阻塞或者接收方死球了<br />长时间没有收到回复就认为超时了,重发该帧<br />啥时候收到回复确认,啥时候发下一帧</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Stop-and-wait ARQ</td>
<td>停等ARQ协议中,每个帧要么编号1要么编号0(原序号模2得到)<br />如果收到0号帧,则下一个期望的就是1号帧<br />如果接收方接收到的帧不是期望帧,回复自己期望的那一帧<br />已发送的帧会被保留副本,如果超时没有收到该帧的确认(或者说下一帧的期待)<br />则重发超时帧</td>
<td><img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230204193901028.png"
alt="image-20230204193901028" /></td>
</tr>
<tr>
<td>Go-Back-N ARQ</td>
<td>实际上是Stop-and-wait ARQ的增强版<br />Stop-and-wait
ARQ协议中没发一个包都要确认一下<br />现在可以<strong>发一组</strong>包然后确认一下<br />让确认这种控制信息比重更少</td>
<td></td>
</tr>
<tr>
<td>Selective Repeat ARQ</td>
<td>Go-Back-N ARQ的增强版<br />Go-Back-N
ARQ中接收方窗口为1,<br />本算法中将接收方窗口增强到和发送方窗口一样大<br />但是窗口大小更小了,为<span
class="math inline">\(2^{m-1}\)</span><br />(Go-Back-N
ARQ中发送方窗口是<span class="math inline">\(2^m-1\)</span>)</td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="回退n帧自动重发请求">回退N帧自动重发请求</h5>
<p>Go-Back-N Automatic Repeat Request</p>
<p>在帧头部设置一个帧序号字段,假设这个字段使用m位,那么可以编号<span
class="math inline">\([0,2^m)\)</span>,即帧序号是模<span
class="math inline">\(2^m\)</span>的</p>
<p>发送窗口:</p>
<p>发送方的发送窗口大小就设置为<span
class="math inline">\(S_{size}=2^m-1\)</span>,</p>
<blockquote>
<p>为什么要设置成这个值呢?为什么不设置成<span
class="math inline">\(2^m\)</span>?留作后话</p>
</blockquote>
<p>比如帧序号字段占用4bit,那么发送方滑动窗口大小就是16-1=15</p>
<p>两个指针,</p>
<p>其中<span
class="math inline">\(S_f\)</span>永远指向最早没有被确认的窗口</p>
<p><span
class="math inline">\(S_n\)</span>指向当前发送方应该发送的窗口位置</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230204195038189.png"
alt="发送窗口" />
<figcaption aria-hidden="true">发送窗口</figcaption>
</figure>
<p>接收窗口:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230204195932727.png"
alt="image-20230204195932727" />
<figcaption aria-hidden="true">image-20230204195932727</figcaption>
</figure>
<p>接收方只需要一个指针即可,只需要记录下一个期待接收的窗口</p>
<p><strong>两个窗口如何交互?</strong></p>
<p>假设发送方连续发了0到14帧,这几个帧是陆续到达的,接收方收到第n帧就会回复期待n+1帧.也可能一股脑收到了n,n+1,n+2这三帧,此时接收方直接回复一个累计确认,期望第n+3帧</p>
<p>考虑有丢包,可能接收方对0到5帧的确认都丢了,但是对第6帧的确认没丢,被发送方收到了,这时发送方Sf指针直接移动到第7帧,也就是发送方窗口右移,此时发送方就可以继续发送第15,16,17等等帧了</p>
<p>也可能发送方第0帧就在路上丢包了,第1,2,等等帧都到了,但是接收方不要,就要第一帧,于是接收方直接丢弃并保持沉默,</p>
<p>发送方发现从第0帧往后,一直长时间没有收到回应,就要从第0帧这里开始重发0到14帧</p>
<p><strong>发送方滑动窗口大小设为<span
class="math inline">\(2^m-1\)</span></strong>的目的</p>
<blockquote>
<p>假设m=4,即帧的编号<span class="math inline">\(\in[0,15]\)</span></p>
<p>并且假设滑动窗口大小大于等于<span
class="math inline">\(2^m=16\)</span>,不妨就设置为16</p>
<p>好,现在一个大文件成帧之后</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0 1 2 3 4 5 6 7 8 9 10 11 12 13
14 15...</p>
<p>滑动窗口要是16就会包含[0,15],假设发送方这16帧全都发出去了,但是网络太垃圾了,没有收到任何回复,而接收方实际上全都回复了,并且接收方已经准备接收下一个0号帧了</p>
<p>此时发送方认为接收方本次[0,15]全都没有收到,于是从0开始重发,但是接收方期望的是下一个0号帧</p>
<p>但是两个帧都是编号0,接收方无法发现错误,于是就错误地接受了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230204201039834.png"
alt="image-20230204201039834" />
<figcaption aria-hidden="true">image-20230204201039834</figcaption>
</figure>
</blockquote>
<h5 id="选择性重传">选择性重传</h5>
<p>在回退N帧自动重发中只有发送方会累计确认</p>
<p>在选择性重传中,发送方和接收方都会累计确认</p>
<p>解决了啥问题呢?</p>
<p>发送方如果发送了<span
class="math inline">\([0,14]\)</span>这些帧,接收方可能就得发送15个确认回复,回复太多这是其一</p>
<p>其二是,如果发送方已经接到了[1,14],唯独0号帧路上丢包了,在回退N帧自动重发中,发送方就得从0开始重发[0,14]</p>
<p>而实际上只需要重发一个0就足够了,但是接收方脑子太小了,只认一个数,[1,14]已经忘记了.</p>
<p>于是就改进成<strong>选择性重传算法</strong></p>
<p>接收方加上了窗口,就有了缓存的能力</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206220446089.png"
alt="image-20230206220446089" />
<figcaption aria-hidden="true">image-20230206220446089</figcaption>
</figure>
<p>关键注意1号帧在发送途中丢包,但是2号帧顺利抵达,此时接收方回复NAK1,意思是期望1.然而在发送方针对NAK1的回应到达之前,3号帧也顺利抵达了,此时接收方默默收下,但是啥回复都没有</p>
<p>然后发送方的针对NAK1的回复1号帧到了,</p>
<p>此时接收方回复的是ACK4,通知发送方,3之前已经都接收到了,可以发送4及之后的帧了,</p>
<p>发送方接收到ACK4之后会调整自己的发送窗口,然后继续发送4,5,...号帧</p>
<p><strong>为啥发送方和接收方的窗口都得是<span
class="math inline">\(2^{m-1}\)</span></strong>呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230204204344648.png"
alt="image-20230204204344648" />
<figcaption aria-hidden="true">image-20230204204344648</figcaption>
</figure>
<p>假设m=2,那么帧编号就是<span
class="math inline">\([0,3]\)</span>此时窗口大小最大为2,否则,假设是3</p>
<p>发送方发送0,1,2三帧之后,都被接收方收到,但是所有回复都丢包了</p>
<p>此时接收方已经后移了接收窗口,此时接收方窗口内的期待0号帧是下一个0号帧.</p>
<p>但是发送方超时重发了刚才的0号帧</p>
<p>于是接收方就把刚才的0号帧当成下一个0号帧错误接收了</p>
<h5 id="带捎带的n步返回nrq">带捎带的N步返回NRQ</h5>
<p>捎带:将控制报文,比如NAK,ACK等等,附带到数据报文中一起发送</p>
<h4 id="带宽利用率">带宽利用率</h4>
<p>首先计算整个链路充满数据,能放开多少数据,也就是带宽时延积</p>
<p>然后使用的协议在传播时间内最多能有多少帧,多少bit上到信道上传输</p>
<p>做比即可</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206221303181.png"
alt="image-20230206221303181" />
<figcaption aria-hidden="true">image-20230206221303181</figcaption>
</figure>
<h3 id="多路访问">多路访问</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206222507328.png"
alt="image-20230206222507328" />
<figcaption aria-hidden="true">image-20230206222507328</figcaption>
</figure>
<h4 id="随机访问协议">随机访问协议</h4>
<p>所有站点低位相同,任何站点都不能组织其他站点说话</p>
<p>有话要说就根据自己的协议说</p>
<h5 id="aloha">AlOHA</h5>
<p>任何站点,在任何时间,想说啥就说啥</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207093146683.png"
alt="image-20230207093146683" />
<figcaption aria-hidden="true">image-20230207093146683</figcaption>
</figure>
<p>只要同一时间在信道上有两个帧,就会造成冲突,发生冲突的帧都会废掉</p>
<p>ALOHA协议流程:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207093619308.png"
alt="image-20230207093619308" />
<figcaption aria-hidden="true">image-20230207093619308</figcaption>
</figure>
<p>最多重发<span
class="math inline">\(K_{max}\)</span>次,如果一直没有收到ACK回复则放弃</p>
<p>每次发送之后等待<span class="math inline">\(2\times
T_{p}\)</span>,这是接收ACK的窗口期</p>
<p>如果没有收到,则等待一个随机数的时间<span class="math inline">\(T_{B}=
T_{p}\times R,r\in[0,2^k)\)</span>.然后再重发</p>
<h6 id="传输和传播">传输和传播</h6>
<p>传输,transmission,又可以翻译为发射,是发送方将信号全放到信道上用的时间
<span class="math display">\[
传输时间=\frac{帧长}{带宽}
\]</span></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207093935960.png"
alt="image-20230207093935960" />
<figcaption aria-hidden="true">image-20230207093935960</figcaption>
</figure>
<p>传播,propagation,信号的一位经过信道用时 <span class="math display">\[
传播时间=\frac{电缆长度}{信号速度(一般是光速)}
\]</span></p>
<h6 id="冲突时间">冲突时间:</h6>
<p>假设各帧长度相同,ALOHA的冲突时间是传输时间的两倍</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207094413864.png"
alt="image-20230207094413864" />
<figcaption aria-hidden="true">image-20230207094413864</figcaption>
</figure>
<p>即在<span
class="math inline">\([t-T_{fr},t+T_{fr}]\)</span>这期间,不允许有第二个帧</p>
<h6 id="吞吐量">吞吐量</h6>
<p><span class="math display">\[
S=G\times e^{-2G}
\]</span></p>
<p>单位:帧</p>
<blockquote>
<p>注意这里的吞吐量单位不是bps</p>
</blockquote>
<p>当且仅当<span class="math inline">\(G=\frac{1}{2}\)</span>,<span
class="math inline">\(S_{max}=0.184\)</span></p>
<p>G是帧传输时间内系统平均产生帧的数量</p>
<p>对于<span
class="math inline">\(G=\frac{1}{2}\)</span>也好立即,因为冲突时间就是两个帧传输时间,如果整个系统在一个传输时间内产生的帧数均值是<span
class="math inline">\(G=\frac{1}{2}\)</span>,则冲突事件内产生的帧数均值就是1</p>
<p>如果<span
class="math inline">\(G&gt;\frac{1}{2}\)</span>则冲突的概率增大,一旦发生冲突,两个帧都是废物</p>
<p>而吞吐量的定义是:单位时间内<strong>成功</strong>传送的数据量.</p>
<p>两个废物帧都不是成功传送,因此导致了吞吐量降低</p>
<blockquote>
<p>推导<span class="math inline">\(S=G\times e^{-2G}\)</span></p>
<p>假设传输时间是T,当一个帧发射之后,在T时间内,系统中又发送帧数均值是G</p>
<p>也就是说,T时间内系统又发送一帧的概率为<span
class="math inline">\(G\)</span></p>
<p>首先考虑吞吐量怎么计算</p>
<p>定义吞吐量:传输时间内,能够成功传输的帧数,则有: <span
class="math display">\[
S=GP_0
\]</span> 其中<span
class="math inline">\(P_0\)</span>为一帧发送成功的概率,也就是冲突时间内没有第二个帧的概率.</p>
<p><span
class="math inline">\(G\)</span>是T时间内系统发送帧数的<strong>均值</strong></p>
<p><span class="math inline">\(P_0\)</span>是成功率</p>
<p>那么<span
class="math inline">\(S=GP_0\)</span>就计算了T时间内发送成功的帧数的<strong>均值</strong></p>
<p>下面考虑<span class="math inline">\(P_0\)</span>怎么算</p>
<p>计算一帧成功传输的概率,也就是发送一帧之后2T时间内没有其他帧的概率</p>
<p>假设T时间内有其他X个帧发射.显然<span class="math inline">\(X\sim
P(G)\)</span>泊松分布,则分布律为 <span class="math display">\[
P(X=k)=\frac{G ^k}{k!}e^{-G}
\]</span></p>
<p>在2T时间即冲突时间内,不发生冲突,意味着没有其他帧发送,其概率是 <span
class="math display">\[
P(X=0)\times P(X=0)=(\frac{G^0}{0!}e^{-G})^2=e^{-2G}
\]</span></p>
<p>带入<span class="math inline">\(P_0=P(X=0)\times
P(X=0)=e^{-2G}\)</span>得到 <span class="math display">\[
S=GP_0=Ge^{-2G}
\]</span></p>
<p>如果定义吞吐量为:传输时间内成功传输的帧数.那么算到这里就结束了</p>
<p>如果定义吞吐量为:单位时间内成功传输的帧数.那么<span
class="math inline">\(S=\frac{G{e^{-2G}}}{T}\)</span></p>
<p>如果定义吞吐量为:单位时间内成功传输的bit数.那么<span
class="math inline">\(S=\frac{G{e^{-2G}}}{T}\times 帧大小\)</span></p>
</blockquote>
<h5 id="时隙aloha">时隙ALOHA</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207102708453.png"
alt="image-20230207102708453" />
<figcaption aria-hidden="true">image-20230207102708453</figcaption>
</figure>
<p>规定只能在每个Slotn一开始发送,每个帧顶多占用一个Slot,不会影响其他Slot</p>
<p>那么冲突只会发生在一个Slot之内,并且一旦发生冲突,一定是两个帧在时间上完全重合</p>
<h6 id="吞吐量-1">吞吐量</h6>
<p>假设每个Slot开始时,系统中传输帧的均值为G帧,则Slot时间内又发送的帧数还是满足泊松分布</p>
<p>只不过冲突时间降为一个Slot,成功发送一帧的概率变为 <span
class="math display">\[
P_0=P(X=0)=e^{-G}
\]</span> 吞吐量就是<span
class="math inline">\(S=GP_0=Ge^{-G}\)</span></p>
<h5 id="csma">CSMA</h5>
<p>Carrier Sense Multiple Access</p>
<p>载波侦听 多路访问</p>
<p>发送前首先侦听,看看有没有其他帧在发送,可以缓解冲突,但是不能解决冲突</p>
<p>因为一个站点侦听时,可能另一个站点已经传输了信号,但是由于<strong>传播</strong>延迟,没有被本站点侦听到,如图所示:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207103600938.png"
alt="image-20230207103600938" />
<figcaption aria-hidden="true">image-20230207103600938</figcaption>
</figure>
<p>B站点在t1时刻传输一个信号,C在t2时刻要发送一个信号,但是t2时刻信号尚未传播到C处,因此C在t2传输一个信号,就会和B传输的信号发生冲突</p>
<h6 id="冲突时间-1">冲突时间</h6>
<p>在B开始传输消息,到消息传播到其他站点之前,这段时间是不能有第二个消息传播的</p>
<p>因此冲突时间就等于传播时间</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207104138197.png"
alt="image-20230207104138197" />
<figcaption aria-hidden="true">image-20230207104138197</figcaption>
</figure>
<h6 id="冲突缓解方法">冲突缓解方法</h6>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207104446245.png"
alt="image-20230207104446245" />
<figcaption aria-hidden="true">image-20230207104446245</figcaption>
</figure>
<h5 id="csmacd">CSMA/CD</h5>
<p>Carrier Sense Multiple Access with Collision
Detection,带冲突检测的载波侦听多路访问</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207105245273.png"
alt="image-20230207105245273" />
<figcaption aria-hidden="true">image-20230207105245273</figcaption>
</figure>
<p>之前CSMA协议中,一个站点只会在发送前进行检查,如果信道空闲就发送</p>
<p>现在CSMA/CD在CSMA的基础上,一个站点会在发送时同时检查,如果侦测到信道中有其他信号,立刻终止发送</p>
<p>因为起码顺着该信号的传播方向上,如果再发送信号肯定是冲突了,那就不如立刻闭嘴不发了</p>
<h6 id="冲突检测时间">冲突检测时间</h6>
<p>首先考虑如图所示情况</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207110344621.png"
alt="image-20230207110344621" />
<figcaption aria-hidden="true">image-20230207110344621</figcaption>
</figure>
<p>如果传输时间很短但是传播延迟很长,可能就存在双方均检测不到冲突或者只有一方能够检测到冲突的情形</p>
<p>此时冲突废帧会被错误交付</p>
<p>为了避免这种情况,就需要传输时间和传播时间有约束关系</p>
<p>直接考虑距离最远的两个站点A,B的情况即可</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207111015408.png"
alt="image-20230207111015408" />
<figcaption aria-hidden="true">image-20230207111015408</figcaption>
</figure>
<p>如果B在A的信号马上就要发到时才开始发送,直到B的信号被A侦听到时,A必须仍在发送</p>
<p>也就是说<strong>最小传输时间应为最大传播时间的两倍</strong>,如下图</p>
<blockquote>
<p>因为A,B是两个距离最远的站点,因此是最大传播时间</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207111728369.png"
alt="image-20230207111728369" />
<figcaption aria-hidden="true">image-20230207111728369</figcaption>
</figure>
<blockquote>
<p>CSMA/CD网络中，带宽10Mbps，最大传播时间为25.6us，那么最小帧长度是多少？</p>
<p>假设帧长是x,则传输时间是<span
class="math inline">\(T_{fr}=\frac{x}{10M}\)</span></p>
<p>由<span class="math inline">\(T_{fr}\ge 2T_p\)</span>得到 <span
class="math display">\[
\frac{x}{10\times 10^6}\ge 25.6\times 10^{-6}\times 2
\]</span> 即<span class="math inline">\(x\ge 512bit\)</span></p>
<p>因此帧长最小为512比特</p>
</blockquote>
<h6 id="csmacd算法流程">CSMA/CD算法流程</h6>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207112317356.png"
alt="image-20230207112317356" />
<figcaption aria-hidden="true">image-20230207112317356</figcaption>
</figure>
<h5 id="csmaca">CSMA/CA</h5>
<p>Carrier Sense Multiple Access with Collision
Avoidance,带冲突避免的载波侦听多路访问</p>
<p>这个协议挺有意思</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207151754370.png"
alt="image-20230207151754370" />
<figcaption aria-hidden="true">image-20230207151754370</figcaption>
</figure>
<p>IFS:Interframe Space,IFS 帧间间隔</p>
<blockquote>
<p>IFS用于定义一个站点的优先权,优先权高的站点,其IFS就短</p>
<p>为啥IFS短了就意味着优先权高呢?这就需要了解协议如何工作的</p>
</blockquote>
<p>Contention Window 竞争窗口</p>
<p>工作流程:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207151820663.png" alt="CSMA/CA" style="zoom:25%;" /></p>
<p>1.首先检查信道是否空闲,如果不是,重新检查</p>
<p>2.如果信道空闲,等待IFS时间</p>
<p>3.等完了再检查一下信道是否空闲,如果忙,退回1.</p>
<p>4.挑一个随机数<span
class="math inline">\(R\in[0,2^K)\)</span>,也就是在竞争窗口中抓阄</p>
<p>5.等R个时间片,然后检查信道是否忙,如果忙,就等会不忙了再发送.如果不忙就发送</p>
<p>6.发完了设置窗口期等待ACK回复,如果收到,则通信成功,否则K++,回头从1开始,如果K&gt;15则不再尝试,通信事变</p>
<h3 id="以太网">以太网</h3>
<p>低层协议的组成</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207155541312.png"
alt="image-20230207155541312" />
<figcaption aria-hidden="true">image-20230207155541312</figcaption>
</figure>
<p>OSI规定的数据链路层分成两个子层,一个是LLC层,一个是MAC层.前者承上后者启下</p>
<p>以太网是MAC的一种实现方式,并且是目前最成功的实现方式</p>
<h4 id="mac地址">MAC地址</h4>
<h5 id="mac地址规定">MAC地址规定</h5>
<p>以太网地址是一个6字节数,每个网卡都有一个固定的MAC地址</p>
<p>一个计算机可能由多张网卡,因此计算机可以有多个MAC地址</p>
<p><code>ipconfig /all</code>即可查看</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">以太网适配器 以太网:</span><br><span class="line"></span><br><span class="line">   媒体状态  . . . . . . . . . . . . : 媒体已断开连接</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   描述. . . . . . . . . . . . . . . : Realtek PCIe GbE Family Controller</span><br><span class="line">   物理地址. . . . . . . . . . . . . : 84-A9-38-F4-9B-69</span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line">无线局域网适配器 WLAN:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   描述. . . . . . . . . . . . . . . : Intel(R) Wi-Fi 6 AX201 160MHz</span><br><span class="line">   物理地址. . . . . . . . . . . . . : 2C-6D-C1-98-7D-03</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>以<code>2C-6D-C1-98-7D-03</code>为例子,最左边是最高位,</p>
<p>称"第一个字节"为最左边的0x2C,第二个就是0x6D</p>
<h5 id="特殊地址">特殊地址</h5>
<p>如果一个MAC地址第一个字节的最低为是0,则该地址是一个单播地址,是1则为多播地址</p>
<p>特殊的,如果MAC addr=FF:FF:FF:FF:FF:FF,则该地址是一个广播地址</p>
<p>0x2C=00101100b,显然所有的物理网卡地址必然是一个单播地址</p>
<p>怎么观察广播地址呢?可以观察ARP协议需要在以太网中广播寻找目标IP地址的主机</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207160905292.png"
alt="image-20230207160905292" />
<figcaption aria-hidden="true">image-20230207160905292</figcaption>
</figure>
<p>源地址就是本机WLAN网卡的地址2C-6D-C1-98-7D-03,目的地址12个F,显然是一个广播</p>
<p>wireshark已经自动根据本机WLAN网卡的<strong>前三个字节</strong>判断出本网卡产自Intel公司</p>
<p>再一查好家伙made in 马来西亚</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207161145923.png"
alt="image-20230207161145923" />
<figcaption aria-hidden="true">image-20230207161145923</figcaption>
</figure>
<p>同理华为公司也会买下前三个字节用来标志自己公司的网卡</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207161443085.png"
alt="image-20230207161443085" />
<figcaption aria-hidden="true">image-20230207161443085</figcaption>
</figure>
<p>如果前三个字节是公司编号</p>
<p>那么一个公司编号最多能够产<span
class="math inline">\(2^{24}\approx400万\)</span>张网卡</p>
<p>如果一部手机使用一个wifi网卡,光中国就有13亿人,假设有1亿人用华为手机,显然一个公司编号是不够用的</p>
<h5 id="网络序">网络序</h5>
<p>字节序不变,但是每个字节内的比特位分别调转(不是取反,是前后调转)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207161313727.png"
alt="image-20230207161313727" />
<figcaption aria-hidden="true">image-20230207161313727</figcaption>
</figure>
<h4 id="mac帧格式">MAC帧格式</h4>
<p>MAC帧有两种格式,</p>
<p>不常用的802.2LLC帧,这是IEEE802工作组制定的答辩</p>
<p>最常用的EthernetV2帧</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207162023980.png"
alt="image-20230207162023980" />
<figcaption aria-hidden="true">image-20230207162023980</figcaption>
</figure>
<p>MAC帧=MAC头+MAC数据+FCS</p>
<p>其中MAC头包括目的地址,源地址,MAC数据类型</p>
<p>FCS就是校验和</p>
<p>MAC数据一般是IP数据报,包括IPv4包或者IPv6数据包</p>
<h5 id="不合法的mac帧">不合法的MAC帧</h5>
<p>以下有一则为不合法MAC帧</p>
<p>数据字段的长度与长度字段的值不一致；</p>
<p>帧的长度不是整数个字节；</p>
<p>用收到的帧检验序列 FCS 查出有差错；</p>
<p><strong>数据字段的长度不在 46 ~ 1500 字节之间；</strong></p>
<p><strong>MAC 帧长度不在64 ~ 1518 字节之间；</strong></p>
<p>对于检查出的无效 MAC
帧就简单地丢弃，以太网<strong>不负责重传丢弃的帧。</strong></p>
<p>这里对帧长度有一个规定,[64,1518]为啥会有这两头的限制呢?</p>
<h5 id="合法帧长度">合法帧长度</h5>
<p>[64,1518]bytes</p>
<p>由于有限以太网使用CSMA/CD协议,因此需要保证最小传输时间大于等于两倍的最大传播时间</p>
<p>而这两个时间的关系,关乎帧长度啥事呢?</p>
<p>显然帧长越长,传输时间就越长,可以推测帧长为64bytes时达到临界值</p>
<p>根据802.3规定,以太网最长2500米,带宽10Mbps,四个中继器,最坏情况下,往返时间(也就是两倍的最长传播时间)大约是50μs.</p>
<p>那么传输速度应该大于50μs.</p>
<p>又带宽是10Mbps,在50微妙内能够发送<span class="math inline">\(50\times
10^{-6}s\times 10\times 10^6bps=500bit\)</span></p>
<p>增加安全边际,往上取整到512bit=64byte</p>
<p>因此规定最小帧长就是64byte</p>
<p>那么又为啥限制最长帧长为1500呢?</p>
<p>因为网络是多台计算机共享的,如果一台主机一直喋喋不休地说,其他主机就得等着,因此一句话不能说太长</p>
<p>于是人为规定为最长1518byte</p>
<p>那么在以太网上的IP包长度就跟着被限制到[48,1500]字节</p>
<p>这个1500字节也就是MTU,最大传输单元</p>
<h3 id="网络连接">网络连接</h3>
<h4 id="数据链路层设备">数据链路层设备</h4>
<p>网桥,集线器,二层交换机都是链路层设备</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 47%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr>
<th>一层设备</th>
<th>结构</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>中继器</td>
<td><img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207210513001.png"
alt="image-20230207210513001" /></td>
<td>再生信号(不是放大信号),延长通信距离</td>
</tr>
<tr>
<td>集线器</td>
<td><img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207210909500.png"
alt="image-20230207210909500" /><br />所有计算机同处于一个冲突域<br />集线器从一个端口进来的包会被无脑拷贝到所有的出端口</td>
<td>只是把多个主机联通,<br />相当于多通水管<br />多端口的中继器</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 46%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr>
<th>二层设备</th>
<th>结构</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>网桥</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207211056989.png" alt="image-20230207211056989" style="zoom:25%;" /><br />网桥可以检查目标地址,根据自己学习建立的转发表,决定从哪个端口转发,相对集线器聪明了不少</td>
<td>减小冲突域,网桥的一个接口是一个冲突域<br />但是所有达到接口都在同一个广播域</td>
</tr>
<tr>
<td>二层交换机</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207163904317.png" alt="image-20230207163904317" style="zoom:25%;" /></td>
<td>消除冲突域,从此不再有冲突<br />相当于带阀门的多通水管<br />但是所有接口都在同一广播域</td>
</tr>
</tbody>
</table>
<p>区分两个术语:广播域,冲突域</p>
<p>广播域:能够接收广播帧的所有设备的集合</p>
<p>冲突域:所有共享介质(比如电缆)都是冲突域</p>
<p>显然广播域的范围要大于等于冲突域</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207213901157.png"
alt="image-20230207213901157" />
<figcaption aria-hidden="true">image-20230207213901157</figcaption>
</figure>
<p>以太网:有线局域网的一种实现,链路层使用CSMA/CD技术</p>
<h5 id="网桥">网桥</h5>
<h6 id="爱学习の网桥">爱学习の网桥</h6>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207211927143.png"
alt="image-20230207211927143" />
<figcaption aria-hidden="true">image-20230207211927143</figcaption>
</figure>
<p>刚接入局域网的网桥是个傻子,啥也不知道,但是他很快就会知道</p>
<p>一开始他的MAC:Port映射表是空的</p>
<p>当A@LAN1 向
D@LAN2发送一个数据帧之后,这个帧显然必须从网桥的1号端口进入.网桥从帧中得知,源地址A在1端口对应的LAN上,于是将A:1写入映射表</p>
<p>如果D回复A收到,立刻就会把D的MAC暴露给网桥,网桥就会记录D:2</p>
<p>D不回复也没关系,反正D只要一说话立刻就会被网桥学会</p>
<h6 id="环路问题">环路问题</h6>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207212358099.png"
alt="image-20230207212358099" />
<figcaption aria-hidden="true">image-20230207212358099</figcaption>
</figure>
<p>如果有两个网桥同时连接了两个LAN</p>
<p>那么一个LAN发出的帧会同时被两个网桥转发,导致另一个LAN中出现两次该帧</p>
<h6 id="生成树算法">生成树算法</h6>
<p>生成树算法用于建立多个LAN的最优联通路径</p>
<p>这里的最优可能是最小跳数,最小延迟,最大带宽等等</p>
<p>假设从网桥到LAN跳数为1，从LAN到网桥跳数为0。</p>
<blockquote>
<p>为啥要这样假设呢?</p>
<p>因为网桥不会主动向一个LAN发送帧,除非该帧的目的在这个LAN中</p>
<p>而一个LAN的帧要想传送到另一个LAN,必须要经过网桥</p>
<p>也就是说,网桥转发帧需要一定的代价,应该尽量减少转发量</p>
<p>而LAN向网桥发送帧这是不可阻阻挡的,几乎没有代价</p>
<p>因此有这么一个假设</p>
</blockquote>
<p>首先将网桥和LAN进行有向图建模,并标注边权</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207212859184.png"
alt="image-20230207212859184" />
<figcaption aria-hidden="true">image-20230207212859184</figcaption>
</figure>
<blockquote>
<p>为啥没有两个网桥直接连接?或者两个LAN直接连接?</p>
<p>这不废话吗</p>
<p>两个网桥连接和只用一个网桥不一样吗?</p>
<p>两个LAN连接就是一个LAN</p>
<blockquote>
<p>两个LAN连接也得使用网桥啊(</p>
</blockquote>
</blockquote>
<p>生成树算法:</p>
<p>spanning tree algorithm:</p>
<p>1.每个网桥广播ID,选择最小的ID作为根网桥</p>
<p><strong>2.找出从根网桥到其它网桥或LAN的最短路径</strong></p>
<p>3.最短路径组合生成最短的树</p>
<p>4.标记转发端口和阻塞端口</p>
<p>注意生成树算法目的是,找出从根网桥到其他网桥和LAN的最短路,</p>
<p>而不是为每个LAN找出到其他各个LAN的最短路</p>
<p>使用生成树算法之后,阻塞端口不再使用,转发端口活跃</p>
<h5 id="交换机">交换机</h5>
<p>交换机相对于集线器的优点:</p>
<p>1.每个端口是一个冲突域</p>
<p>2.根据目标MAC地址查转发表,决定发往哪个端口</p>
<p>3.全双工,由于没有冲突域,不需要CSMA/CD协议</p>
<p>4.有缓存,各个接口的带宽可以不同</p>
<h4 id="网络层设备">网络层设备</h4>
<p>链路层设备关心帧的MAC地址</p>
<p>网络层设备关心包的IP地址</p>
<p>三层设备就一个三层交换机和一个路由器</p>
<p>这个三层交换机不伦不类,它既有二层交换机那个交换转发的功能,也有路由器的路由功能</p>
<p>两者本身上的区别是,三层交换机主要是硬件驱动的,但是路由器是CPU+操作系统软件驱动的.这就导致三层交换机的效率远快于路由器</p>
<p>两者功能上的区别是,三层交换机用于连接相同性质的网络,比如连接两个LAN:192.168.2.1/24和192.168.1.1/24</p>
<p>但是路由器主要用于不同类型的网络连接,比如因特网和局域网的连接,入户网线可能给一个互联网的公网地址,需要使用一个路由器NAT转化为一个LAN.并且实际上的路由选择,负荷分担,链路备份,和其他网络交换路由信息,都是路由器实现的</p>
<p>路由功能:当IP报文抵达路由器时,决定转发给哪一个下一跳路由器</p>
<p>这个决策是基于路由器的路由表做出的</p>
<p>路由表可以人工填写静态的,也可以让路由器自己学,就跟网桥交换机的转发表差不多</p>
<h4 id="网关">网关</h4>
<p>比较特殊的路由器</p>
<p>一个LAN内的主机如果想要跨LAN访问另一个主机,只通过二层交换机是做不到的,因为二层交换机是连IP地址都不知道的傻子.网关就是一个LAN和外部网络连接的关口.LAN内的主机只要是想和外部通信,无脑往网关发包就可以了,网关负责决定这个包如何路由</p>
<h4 id="虚拟局域网">虚拟局域网</h4>
<p>交换机可以隔离冲突域但是无法隔离广播域</p>
<p>划分虚拟局域网之后可以隔离冲突域和广播域</p>
<p>在一个交换机上划分了VLAN,实际上相当于虚拟出多个交换机,每个交换机都分别连接到路由器上,形成多个LAN,并且这几个LAN互不连通.这个路由器就是各个LAN的网关</p>
<h5 id="等效结构">等效结构</h5>
<p>如图所示</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207220800643.png"
alt="image-20230207220800643" />
<figcaption aria-hidden="true">image-20230207220800643</figcaption>
</figure>
<p>这实际上就相当于</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207220913692.png"
alt="image-20230207220913692" />
<figcaption aria-hidden="true">image-20230207220913692</figcaption>
</figure>
<h5 id="如何实现">如何实现</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207221014728.png"
alt="image-20230207221014728" />
<figcaption aria-hidden="true">image-20230207221014728</figcaption>
</figure>
<p>如果一个VLAN跨越了两个交换机,那么这个VLAN中两个计算机通过交换机通信时,交换机在发往另一个交换机之前,检查A计算机所处VLAN,然后在链路层帧后面加上VLAN标志,这样另一个交换机就知道把改帧转发给哪一个目标VLAN了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207223219150.png"
alt="image-20230207223219150" />
<figcaption aria-hidden="true">image-20230207223219150</figcaption>
</figure>
<p>如图所示的拓扑中,经过实验,PC9@192.168.10.1 ping
PC13@192.168.10.3时,ICMP报文会被LSW5交换机准确地从GE0/0/4口转发到GE0/0/2端口,报文中也没有体现VLAN</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207223605022.png"
alt="image-20230207223605022" />
<figcaption aria-hidden="true">image-20230207223605022</figcaption>
</figure>
<p>PC13@192.168.10.3 ping
PC11@192.168.10.2时会经过两个路由器的Trunk端口,其报文中,以太网头和IP头之间加上了VLAN编号,占用四个字节,这个玩意叫做tag(标签)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207223506096.png"
alt="image-20230207223506096" />
<figcaption aria-hidden="true">image-20230207223506096</figcaption>
</figure>
<h5 id="交换机端口类型">交换机端口类型</h5>
<p>access类型,只属于一个VLAN,用于连接计算机</p>
<p>trunk类型,主干道,可以设置允许哪些VLAN通过,用于连接交换机</p>
<p>hybrid类型,类似于trunk,但是hybrid允许通过改接口的帧不带VLAN
tag,而trunk要求必须带VLAN tag(除了缺省VLAN,默认是VLAN
1,的帧不需要带tag)</p>
<p>当端口接收到不带VLAN
Tag的报文后，则将报文转发到<strong>属于缺省VLAN的端口</strong>(如果设置了端口的缺省VLAN
ID,默认是VLAN 1)。</p>
<p>当端口发送带有VLAN Tag的报文时，如果该报文的VLAN ID与端口缺省的VLAN
ID相同，则系统将去掉报文的VLAN Tag，然后再发送该报文。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/01/30/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/30/Spring/" class="post-title-link" itemprop="url">Spring Core</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-01-30 16:15:00 / Modified: 16:15:28" itemprop="dateCreated datePublished" datetime="2023-01-30T16:15:00+08:00">2023-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="spring-core">Spring Core</h1>
<h2 id="spring-ioc容器">Spring Ioc容器</h2>
<h3 id="容器配置文件">容器配置文件</h3>
<p>maven管理的Spring项目中,spring配置文件一半放在/src/main/java/resources目录下,比如</p>
<p>/src/main/java/resources/beans.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    一个java bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dustball&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.User&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dustball&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sjh123456&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;114514&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    别名--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置Spring容器对象</p>
<p>总共有五种标签</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>意义</th>
<th>属性</th>
<th>元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>beans</td>
<td>bean组</td>
<td></td>
<td></td>
</tr>
<tr>
<td>bean</td>
<td>一个pojo对象</td>
<td></td>
<td></td>
</tr>
<tr>
<td>alias</td>
<td>bean的别名</td>
<td></td>
<td></td>
</tr>
<tr>
<td>description</td>
<td>描述,相当于注释</td>
<td></td>
<td></td>
</tr>
<tr>
<td>import</td>
<td>导入其他xml配置</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="为什么要控制反转">为什么要控制反转?</h3>
<p>参考<a
target="_blank" rel="noopener" href="https://www.cnblogs.com/zwh0910/p/14609021.html">为什么要用IOC:inversion
of controll反转控制（把创建对象的权利交给框架） - 周文豪 - 博客园
(cnblogs.com)</a></p>
<p>之前在学javaweb时,每次高层访问底层,比如Service访问Dao层,高层上都要持有底层对象的句柄,并且掌握合适释放底层对象</p>
<p>实际上很麻烦,也没必要</p>
<p>这就好比去饭店吃饭,客人非要管着厨师怎么做饭.而实际上只需要管好点菜就行了</p>
<p>于是考虑使用设计模式中的单例模式,而引入设计模式又会造成代码的复杂性</p>
<p>反正不就是要一个对象,并且好管理吗?让Spring框架干这个事情</p>
<p>这就是Spring容器干的事情</p>
<p>将所有beans扔进Spring容器,让他管理,对于程序来说,Spring容器在全局位置,程序员可以自由调用</p>
<p>然后用BeanFactory等等工厂,对程序员提供接口,这个BeanFactory干了个啥?意思意思:</p>
<figure>
<img
src="https://img2020.cnblogs.com/blog/2138872/202104/2138872-20210402084150177-2053605761.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>类域里面有一个静态代码块,其用意是,当BeanFactory对象创建时仅执行一次,也就是单例模式.</p>
<p>静态代码块中读取了bean.properties,根据xml文件的配置,实例化bean放到Map&lt;String,Object&gt;
beans容器中</p>
<p>这个容器实际上是一个Map字典,例子中使用HashMap实现之</p>
<p>此后要使用容器中的对象时,只需要调用工厂的getBean方法,传入的对象id作为键去查beans哈希表,查到就返回对象引用</p>
<p>所谓"依赖注入",就是指把java bean放到Spring容器中去</p>
<blockquote>
<p>害tm注入,牛逼哄哄的,害什么控制反转,纯纯吓唬人</p>
</blockquote>
<figure>
<img
src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/container-magic.png"
alt="container magic" />
<figcaption aria-hidden="true">container magic</figcaption>
</figure>
<h3 id="bean在何时创建">bean在何时创建</h3>
<figure>
<img
src="https://atts.w3cschool.cn/attachments/image/20201030/1604037368126454.png"
alt="Spring Bean" />
<figcaption aria-hidden="true">Spring Bean</figcaption>
</figure>
<p>从配置文件实例化Spring容器时创建</p>
<p>也就是说</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这玩意执行之后,beans.xml中的所有Bean都会创建,并放置在Bean缓存池中</p>
<p>这一点可以下断点观察</p>
<p>但是,如果beans.xml中,一个bean如果带上了懒加载的属性,则啥时候用这个bean时,它才不得不加载</p>
<p>比如</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dustball&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.User&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dustball&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sjh123456&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;114514&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个dustball就不会跟随context的实例化而同时创建,如果从来不调用dustball,它就不会被创建</p>
<h3 id="bean属性">bean属性</h3>
<h4 id="idclass">id&amp;class</h4>
<p>最基本的属性就是id和class</p>
<p>id是这个bean在容器中的键,值就是bean的对象引用</p>
<p>class是这个bean的类</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dustball&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dustball&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sjh123456&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;114514&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="scope">scope</h4>
<p>规定bean的作用域,</p>
<p>singleton,单例模式,每次getBean调用,返回同一个实例.默认的作用域.</p>
<p>如果没有懒加载属性,则该bean会随容器一起创建,随容器一起销毁</p>
<p>prototype,原型模式,每次getBean调用,都会返回一个新的实例.</p>
<p>啥时候getBean,啥时候才会创建</p>
<h4 id="init-method">init-method</h4>
<p><strong>不建议使用</strong></p>
<p><strong>不建议使用</strong></p>
<p><strong>不建议使用</strong></p>
<p>初始化回调函数</p>
<p>创建bean使用无参构造函数,可以在其中进行初始化</p>
<p>也可以另外指定初始化函数,该函数必须无参数无返回值</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dustball&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.User&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dustball&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sjh123456&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;114514&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>指定User类的init函数为初始化函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball.pojo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@NoArgsConstructor</span></span><br><span class="line"><span class="comment">//@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User ctor called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name, String pwd)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User 3arg ctor called&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init method called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy method called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="spring依赖注入">Spring依赖注入</h2>
<h3 id="基于ctor的依赖注入">基于ctor的依赖注入</h3>
<p>通过自定义的有参构造函数进行实例化就是基于ctor的依赖注入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dustball&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.User&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dustball&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sjh&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里使用键决定参数对应关系,也可以使用index下标对应ctor的参数</p>
<p>这个配置届时会调用User的三参数ctor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name, String pwd)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;User 3arg ctor called&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.pwd = pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于setter的依赖注入">基于setter的依赖注入</h3>
<p>之前用property元素配置bean时,之所以能够成功,是因为lombok的@Data注解,自动帮我们加上了setter方法</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;deutschball&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.User&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;deutschball&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sjh&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;property name="id" value="2"/&gt;</code>这句要求User类要有setID方法,对其传递参数2</p>
<h3 id="注入成员对象">注入成员对象</h3>
<p>之前的User类有三个成员变量,一个基本数据类型int,两个String类型</p>
<p>现在UserProxy{User user;String
seviceID};类型包括了一个User成员对象和一个String成员变量</p>
<p>如何注入这么一个UserProxy类型的bean呢?</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;vader&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.User&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;vader&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sjh&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;vader_proxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.UserProxy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;vader&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceID&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0x00001&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;property name="user" ref="vader"/&gt;</code>这里的ref应为一个bean的id标识</p>
<h3 id="注入内部bean">注入内部bean</h3>
<p>bean里面可以包含一个bean作为成员对象</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;proxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.UserProxy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.User&quot;</span> <span class="attr">id</span>=<span class="string">&quot;proxyUser&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;puppet&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sjh&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">value</span>=<span class="string">&quot;0x00001&quot;</span> <span class="attr">name</span>=<span class="string">&quot;serviceID&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中UserProxy类长这样:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball.pojo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">    User user;</span><br><span class="line">    String serviceID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="注入集合">注入集合</h3>
<p>啥时候用到啥时候回来学</p>
<h2 id="自动装配">自动装配</h2>
<p>自动装配是为了简化注入成员对象的情形</p>
<p>不使用自动装配:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;vader&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.User&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;vader&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sjh&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;vader_proxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.UserProxy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;vader&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceID&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0x00001&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关键在于<code>&lt;property name="user" ref="vader"/&gt;</code>这一句,表明了本bean引用了哪一个bean</p>
<p>使用自动装配之后可以省去这句,由Spring(具体是谁我也不知道)自动决定引用哪一个bean</p>
<p>默认情况下是不会自动装配的,需要手动设置装配哪一个bean.</p>
<p>感觉上显示写明装配哪一个bean,代码更加清晰,并且也不会多复杂.自动装配反而降低可读性</p>
<h3 id="byname">byName</h3>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.User&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;vader&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sjh&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;vader_proxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.UserProxy&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;user&quot; ref=&quot;vader&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceID&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0x00001&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>UserProxy中不需要显式指定user成员引用哪一个bean,因为其bean属性中有<code>autowire="byName"</code>,根据名称自动装配</p>
<p>啥叫"根据名称自动装配?"</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">    User user;</span><br><span class="line">    String serviceID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里成员对象user,其键名就是"user",因此Spring会根据这个"user"去找id="user"的bean,也就是</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.User&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>
<p>如果找到了,则使用该bean,否则使用null值</p>
<h3 id="bytype">byType</h3>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;vader&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sjh&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;vader_proxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.UserProxy&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;user&quot; ref=&quot;vader&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceID&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0x00001&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>byType,根据类型自动专配,user成员是一个User类型,beans.xml中的user类型的bean自动作为成员进行装配</p>
<p>如果有两个以上的user
bean,则会报错<code>expected single matching bean but found 2: dustball,user</code></p>
<h3 id="constructor">constructor</h3>
<p>构造函数参数匹配</p>
<p>比较类似于byType,</p>
<p>区别就是constructor-arg和property的区别</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;vader&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sjh&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;vader_proxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.UserProxy&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;constructor&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;user&quot; ref=&quot;vader&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;serviceID&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0x0001&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;serviceID&quot; value=&quot;0x00001&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用注解开发">使用注解开发</h2>
<p>在beans.xml中加上注解配置和自动扫描</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;top.dustball.pojo&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意此时自动扫描主机范围是<code>top.dustball.pojo</code>这个包下,可以扩大范围</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;top.dustball&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="component"><span class="citation"
data-cites="Component">@Component</span></h3>
<p>作用于类上</p>
<p>自动给类创建一个pojo</p>
<p>比如top.dustball.pojo.User类这样写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Component(&quot;dustball&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Component("dustball")</code>将会自动创建一个bean,其id就是dustball</p>
<p>在测试类中就可以通过<code>context.getBean("dustball")</code>调用之</p>
<p>Component注解只能创建对象,但是无法设置对象的属性值,可以通过@Value注解设置属性值</p>
<p>如果只写<code>@Component</code>,不显示指定id,则默认bean使用类名的首字母小写作为id,即User类对应user
bean</p>
<h4 id="衍生注解">衍生注解</h4>
<table>
<thead>
<tr>
<th>衍生注解</th>
<th>作用于</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="citation"
data-cites="Respository">@Respository</span></td>
<td>UserDao</td>
</tr>
<tr>
<td><span class="citation" data-cites="Service">@Service</span></td>
<td>UserService</td>
</tr>
<tr>
<td><span class="citation"
data-cites="Controller">@Controller</span></td>
<td>UserController</td>
</tr>
</tbody>
</table>
<p>需要注意的是,beans.xml中指定要扫描的位置,</p>
<p>原来的位置是pojo包下的所有Dao层的类</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;top.dustball.pojo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在要拓展范围,扫描所有Dao,Service,Controller层的类</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;top.dustball&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="value"><span class="citation"
data-cites="Value">@Value</span></h3>
<p>作用于属性或者setter上,配合@Component使用,初始化bean的各个属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@NoArgsConstructor</span></span><br><span class="line"><span class="comment">//@AllArgsConstructor</span></span><br><span class="line"><span class="comment">//@Data</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Component(&quot;dustball&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="meta">@Value(&quot;dustball&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value(&quot;sjh&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时Spring容器中自动创建的id=dustball的bean,三个属性均已初始化</p>
<h3 id="autowired"><span class="citation"
data-cites="Autowired">@Autowired</span></h3>
<p>作用于成员对象或者其setter方法上</p>
<p>自动装配成员对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    User user;<span class="comment">//此处由Spring容器自动寻找user类型的bean,找到则自动装配</span></span><br><span class="line">    <span class="meta">@Value(&quot;0x10000&quot;)</span></span><br><span class="line">    String serviceID;<span class="comment">//此处默认初始化为0x10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上是<strong>byType</strong>实现的</p>
<p>因此beans.xml中应该有一个id为user的bean,或者User类上带有Component注解或者其衍生注解</p>
<p>Autowired和Required的关系:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下required=true,这意味着user这个成员对象必须被一个bean装配,如果SpringIoc容器中找不到合适的bean则报错</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No qualifying bean of <span class="built_in">type</span> <span class="string">&#x27;top.dustball.pojo.User&#x27;</span> available</span><br></pre></td></tr></table></figure>
<p>如果required=false,则该成员对象可以为null,SpringIoc容器中找不到合适的bean就直接摆烂不找了,赋值为null</p>
<h3 id="qualifier"><span class="citation"
data-cites="Qualifier">@Qualifier</span></h3>
<p>配合@Autowired一起使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = true)</span></span><br><span class="line">            <span class="meta">@Qualifier(value = &quot;dustball&quot;)</span></span><br><span class="line">    User user;</span><br><span class="line">    <span class="meta">@Value(&quot;0x10000&quot;)</span></span><br><span class="line">    String serviceID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本来只用@Autowired相当于byType自动装配bean,现在希望装配一个指定id的bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Qualifier(value = &quot;dustball&quot;)</span></span><br></pre></td></tr></table></figure>
<p>这就限定了必须使用id=dustball的这个bean</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dustball&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;vader&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sjh&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="scope-1"><span class="citation"
data-cites="Scope">@Scope</span></h3>
<p>作用于类上,配合@Component以及其衍生注解一起使用</p>
<p>用于指定该bean的作用域,要么是singleton要么是prototype</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = true)</span></span><br><span class="line">            <span class="meta">@Qualifier(value = &quot;dustball&quot;)</span></span><br><span class="line">    User user;</span><br><span class="line">    <span class="meta">@Value(&quot;0x10000&quot;)</span></span><br><span class="line">    String serviceID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="xml给爬">xml给👴爬</h2>
<p>之前不管是纯xml配置还是使用注解简化的xml配置,都离不开xml</p>
<blockquote>
<p>即使是注解开发,也需要一个这种的xml文件:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;top.dustball&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实际上注解贡献的bean和xml中注册的bean地位是完全相同的</p>
</blockquote>
<p>"基于java的配置",就是指,使用一个java类作为bean的注册来源,而不再使用任何xml文件</p>
<p>比如top.dustball.pojo.UserConfig这个类,作为bean的来源,可以这样写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;)</span></span><br><span class="line">    <span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">deutschball</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">100</span>,<span class="string">&quot;deutschball&quot;</span>,<span class="string">&quot;sjh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserProxy <span class="title function_">deutschproxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserProxy</span>(deutschball(),<span class="string">&quot;0x1000&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="citation"
data-cites="Configuration注解作用于类上">@Configuration注解作用于类上</span>,表明本类作为bean的注册来源</p>
<p>被@Bean注解修饰的成员函数将会生成一个id为函数名的bean</p>
<p>可以结合@Scope修饰该bean的作用域</p>
<p>如果有成员对象依赖,可以使用其他函数的返回值,只要将对应函数修饰为单例模式,就可以保证每次返回同一个对象</p>
<p>需要注意的是,基于java类的配置,<strong>会与直接在User,UserProxy类上写的@Component注解打架</strong>,并且有可能创建两个bean</p>
<p>因此要么 使用java类的配置,要么使用xml+注解,不要混用</p>
<table>
<thead>
<tr>
<th>基于java类的配置</th>
<th>基于xml文件的配置</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>方法名</td>
<td>bean id</td>
<td></td>
</tr>
<tr>
<td>方法返回值</td>
<td>bean class</td>
<td></td>
</tr>
<tr>
<td><span class="citation"
data-cites="Bean修饰方法">@Bean修饰方法</span></td>
<td>注册一个bean</td>
<td></td>
</tr>
</tbody>
</table>
<p>还要注意的是,实例化容器时有变动</p>
<p>从xml构建容器要这样写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>从java类构建容器要这样写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context=<span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(UserConfig.class);</span><br></pre></td></tr></table></figure>
<h2 id="代理模式">代理模式</h2>
<p>为啥要学代理模式呢?</p>
<p>因为Spring AOP由动态代理实现,学动态代理是为了知道其原理</p>
<p>为啥要先学静态代理呢?因为动态代理和静态代理的目的相同</p>
<p><strong>在不改变已有代码的基础上,增加新功能</strong></p>
<p>至于为啥不能改变原有代码,<del>是主人的变态任务罢了</del></p>
<p>比如第三方jar包提供的类或者函数,要增强其功能,就可以通过代理模式实现</p>
<p>十五斤,三十块,满意了吧?</p>
<h3 id="静态代理">静态代理</h3>
<p>静态代理通过组合实现</p>
<p>也就是被代理对象作为代理类的成员对象.</p>
<p>类图表示为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">classDiagram </span><br><span class="line">    class NotePad&#123;</span><br><span class="line">    	+void print();</span><br><span class="line">    	+void insert(row,col,text)</span><br><span class="line">    	+void delete(row,col,length)</span><br><span class="line">    &#125;</span><br><span class="line">    class RealNotePad&#123;</span><br><span class="line">    	-filename:string</span><br><span class="line">    	+void print();</span><br><span class="line">    	+void insert(int index,string text)</span><br><span class="line">    	+void delete(int begin,int end)</span><br><span class="line">        +void open(string filename)</span><br><span class="line">    &#125;</span><br><span class="line">    class ProxyNotePad&#123;</span><br><span class="line">    	-realnotepad:RealNotePad</span><br><span class="line">    	-filename:string</span><br><span class="line">    	-buffer:string</span><br><span class="line">    	+void print();</span><br><span class="line">    	+void insert(row,col,text)</span><br><span class="line">    	+void delete(row,col,length)</span><br><span class="line">    &#125;</span><br><span class="line">	NotePad&lt;|..RealNotePad</span><br><span class="line">	NotePad&lt;|..ProxyNotePad</span><br><span class="line">	class Main&#123;</span><br><span class="line">		void main();</span><br><span class="line">	&#125;</span><br><span class="line">	ProxyNotePad&lt;..Main</span><br><span class="line">	RealNotePad &lt;..ProxyNotePad</span><br><span class="line">	ProxyNotePad o..RealNotePad</span><br></pre></td></tr></table></figure>
<h3 id="动态代理">动态代理</h3>
<p>动态体现在:没有实际存在的代理类,在运行时用反射创建临时代理类,实例化代理对象之后返回这个代理对象,交由被代理的接口管理句柄</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="built_in">this</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(method.getName()+<span class="string">&quot; method called&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用代理:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UserDaoImpl userDao=<span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line"><span class="type">ProxyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyInvocationHandler</span>(userDao);</span><br><span class="line">UserDao proxy=(UserDao)handler.getProxy();</span><br><span class="line">proxy.delete(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>1.<code>UserDaoImpl userDao=new UserDaoImpl();</code></p>
<p>实例化了一个普通的UserDao实现类对象userDao,这跟之前没有用代理的情形没有区别</p>
<p>2.<code>ProxyInvocationHandler handler = new ProxyInvocationHandler(userDao);</code></p>
<p>userDao作为被代理对象,其引用传递给handler.target保管,便于handler成员方法调用</p>
<p>ProxyInvocationHandler类中实现了两个方法,getProxy和invoke,(忽略lombok自动实现的方法),</p>
<p>其中InvocationHandler接口实际上只要求必须实现invoke方法</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span><br></pre></td></tr></table></figure>
<p>其中proxy是被代理的对象,method是proxy对象要被增强的方法,args是本来应该传递给该方法的参数</p>
</blockquote>
<p>getProxy纯粹是我们为了省事才写到ProxyInvocationHandler类中的方法</p>
<p>到此为止只调用过ProxyInvocationHandler的全参数构造函数(lombok注解@AllArgsConstructor),也就是说,只做了target引用赋值这么一件事</p>
<p>大的要来了</p>
<p>3.<code>UserDao proxy=(UserDao)handler.getProxy();</code></p>
<p>获取了一个代理对象,怎么说获取就获取了?为什么从handler那里获取?关键在于handler.getProxy函数</p>
<p>这个函数干了啥?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterfaces(),</span><br><span class="line">            <span class="built_in">this</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java.lang.reflect.Proxy</code>这个类用于动态生成代理类，只需传入目标接口、目标接口的类加载器以及InvocationHandler便可为目标接口生成代理类及代理对象。具体函数干了啥,需要反射的知识,现在不会</p>
<p>三个参数,</p>
<p>第一个是被代理类的类加载器,也就是<code>target.getClass().getClassLoader()</code>,也就是UserDaoImpl类的类加载器,</p>
<blockquote>
<p>然而视频教程里这里写的是<code>this.getClass().getClassLoader()</code>,也就是ProxyInvocationHandler类的类加载器</p>
<p>弹幕的说法是,这两个类都是我们自己写的自定义类,所以类加载器是一个</p>
<p>打印观察发现确实如此</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UserDaoImpl userDao=<span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">System.out.println(userDao.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="type">ProxyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyInvocationHandler</span>(userDao);</span><br><span class="line">System.out.println(handler.getClass().getClassLoader());</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdk.internal.loader.ClassLoaders<span class="variable">$AppClassLoader</span>@78308db1</span><br><span class="line">jdk.internal.loader.ClassLoaders<span class="variable">$AppClassLoader</span>@78308db1</span><br></pre></td></tr></table></figure>
<p>都是使用应用类加载器(实际上一共就三个类加载器)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20200426185027299.png"
alt="在这里插入图片描述" />
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>也就是说,这三个参数传递给<code>Proxy.newProxyInstance</code>之后,该函数并不知道要代理哪一个对象,只知道需要代理哪些接口,增强方法在this.invoke,那么代理对象执行的业务,是如何作用到原对象上的呢?</p>
<p>通过invoke函数作用到原对象userDao上</p>
</blockquote>
<p>第二个是需要代理的接口,因为被代理类可以implements多个接口,因此这里可以有选择地代理其接口</p>
<p>第三个是本对象(一个实现InvocationHanler接口的对象,目的是绑定本对象的invoke函数,增强代理接口的功能)</p>
<p>三个参数传入<code>Proxy.newProxyInstance</code>之后,返回一个代理对象,交给左值<code>UserDao proxy</code>保管</p>
<p>这个代理对象具有哪些函数呢?这个由第二个参数决定,传入的接口中有啥函数,这个代理对象就有啥函数</p>
<p>并且代理对象每次调用这些函数,(不管哪一个)都会首先调用invoke方法,可以在invoke函数中增强函数功能</p>
<p>4.<code>proxy.delete(10);</code></p>
<p>代理对象调用接口中的delete函数,然而是否真的能够调用到UserDaoImpl.delete()函数,得看ProxyInvocationHandler.invoke函数的脸色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(method.getName()+<span class="string">&quot; method called&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> method.invoke(target,args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invoke拦截proxy.delete这次调用,然后打印<code>delete method called</code></p>
<p>然后才会将调用转发给<code>target.delete(args)</code></p>
<p>具体底层怎么实现,学了反射再说</p>
<h2 id="spring-aop">Spring AOP</h2>
<p>之前学了动态代理,并不是让我们直接用动态代理写代码,SpringAOP已经帮我们实现了,我们只需要调用其接口</p>
<h3 id="官方の废话">官方の废话</h3>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr>
<th>概念</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>横切关注点</td>
<td>跨越应用程序多个模块的方法或者功能,与业务逻辑无关但是需要关注,比如日志,安全,缓存,事务</td>
</tr>
<tr>
<td>切面</td>
<td>横切关注点被模块化的特殊对象,切面是一个类</td>
</tr>
<tr>
<td>通知</td>
<td>切面要完成的工作,通知是切面类的一个方法</td>
</tr>
<tr>
<td>目标</td>
<td>被通知的对象(目标对象)</td>
</tr>
<tr>
<td>代理</td>
<td>代理对象</td>
</tr>
<tr>
<td>切入点</td>
<td>可以被通知的函数,每个成员函数都可以作为切入点</td>
</tr>
<tr>
<td>连接点</td>
<td>实际被通知的函数,只有感兴趣的切入点才会被作为连接点</td>
</tr>
</tbody>
</table>
<h3 id="aop过滤器钩子">AOP/过滤器/钩子</h3>
<p>比较类似的几个东西</p>
<p>AOP用于拦截函数调用</p>
<p>过滤器用于拦截用户请求</p>
<p>钩子是回调性质的,用钩子也可以改变程序控制流</p>
<p>AOP和钩子的区别在于,钩子必须给每个函数分别设置,但是AOP可以直接给多个函数上钩子</p>
<h3 id="spring-aop-1">Spring AOP</h3>
<p>Spring AOP是AOP的实现</p>
<p>Spring
AOP可以劫持一个方法,在方法执行之前/之后,或者抛出异常时添加额外功能</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230129091802544.png"
alt="image-20230129091802544" />
<figcaption aria-hidden="true">image-20230129091802544</figcaption>
</figure>
<p>当代理对象执行一个业务,比如add时:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">代理对象.add()&#123;</span><br><span class="line">	验证参数();</span><br><span class="line">	前置日志();</span><br><span class="line">	目标对象.add();</span><br><span class="line">	后置日志();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样看来目标对象的所有业务逻辑都被劫持了,并且在代理对象中加上了相同的前置和后置业务</p>
<p>能否有选择的劫持,不同的函数调用劫持后不同对待呢?</p>
<blockquote>
<p>如果是我们自己实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">             <span class="built_in">this</span>.getClass().getClassLoader(),</span><br><span class="line">             target.getClass().getInterfaces(),</span><br><span class="line">             <span class="built_in">this</span></span><br><span class="line">     );</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">     <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;add&quot;</span>))&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;add hijacked&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//劫持add方法不予执行</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;select&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> method.invoke(target,args);<span class="comment">//直接放行</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         System.out.println(method.getName()+<span class="string">&quot; method called&quot;</span>);<span class="comment">//其他方法打印前置日志后放行</span></span><br><span class="line">         <span class="keyword">return</span> method.invoke(target,args);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代理对象的所有方法调用都会首先被劫持到invoke方法,invoke方法决定下一步如何</p>
</blockquote>
<p>在SpringAOP中,不需要自己写动态代理的逻辑,只需要写好配置文件</p>
<h3 id="方法1xml配置">方法1:XML配置</h3>
<p>首先在Service层有一个UserServiceImpl下面用SpringAOP代理之</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball.service.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserService add calleda&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在log包下有一个日志类LogBefore实现了MethodBeforeAdvice接口,这个类将会被作为切面,其before函数将会作为通知作用于UserServiceImpl的成员函数调用之前</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodBeforeAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogBefore</span> <span class="keyword">implements</span> <span class="title class_">MethodBeforeAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;log before &quot;</span>+method.getName()+<span class="string">&quot; is called&quot;</span>);</span><br><span class="line">        method.invoke(target,args);<span class="comment">//此处存在错误,留作伏笔</span></span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面就是xml文件的配置了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;top.dustball&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.service.User.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logBefore&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.log.LogBefore&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logAfter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.log.LogAfter&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        定义切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;cutBefore&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* top.dustball.service.User.UserServiceImpl.* (..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;cutAfterAdd&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* top.dustball.service.User.UserServiceImpl.add())&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        切入点和哪个切面通知挂钩--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;logBefore&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;cutBefore&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;logAfter&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;cutAfterAdd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先注册三个bean,其中userService是目标对象</p>
<p>另外两个bean都是日志类,作为切面</p>
<p>然后是aop配置,其中expression表达式是关键,它决定本切入点作用于被代理对象的哪一个函数</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;cutBefore&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* top.dustball.service.User.UserServiceImpl.* (..))&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这句话干了个什么事呢?给UserServieImpl类的任何函数都带上cutBefore切入点</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">execution(</span><br><span class="line">	modifiers-pattern</span><br><span class="line">	ret-type-pattern </span><br><span class="line">	declaring-type-pattern</span><br><span class="line">	name-pattern(param-pattern)</span><br><span class="line">	throws-pattern</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>returning type pattern,name pattern, and parameters
pattern是必须的.</p>
<p>ret-type-pattern:可以为*表示任何返回值,全路径的类名等.</p>
<p>name-pattern:指定方法名, <em>代表所有</em></p>
<p>set代表以set开头的所有方法.</p>
<p>parameters pattern:指定方法参数(声明的类型),</p>
<p>(..)代表所有参数,(<code>*</code>)代表一个参数</p>
<p>(<code>*</code>,String)代表第一个参数为任何值,第二个为String类型.</p>
</blockquote>
<p>到现在位置是只定义了切入点,并没有往里切入东西,此时调用userService对象,看不出被代理的作用</p>
<p>下面给切入点插入通知就体现代理的作用了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;logBefore&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;cutBefore&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>给cutBefore切入点加上logBefore通知</p>
<p>测试类这样写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.dustball.service.User.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span> before add is called</span><br><span class="line">UserService add called</span><br><span class="line">UserService add called</span><br><span class="line"><span class="built_in">log</span> after add is called with <span class="built_in">return</span> value = null</span><br></pre></td></tr></table></figure>
<p>表明userService已经被代理了</p>
<p>然而奇怪的是,我们并没有显式调用代理对象,而是从容器context中拿出目标对象userService直接使用</p>
<p>程序逻辑却没有根据userService.add本来的样子走,而是执行了logBefore.before切面通知之后,然后才执行userService.add</p>
<p><strong>也就是说,在Test类看来,他不知道userService.add到底怎么实现的,他也看不到存在AOP,他只管调用就可以了</strong></p>
<p>奇怪的是,测试类中只调用了一次userService.add,结果中却打印了两次<code>UserService add called</code></p>
<p>这是因为在LogBefore.before切面通知函数中,我们画蛇添足了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogBefore</span> <span class="keyword">implements</span> <span class="title class_">MethodBeforeAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;log before &quot;</span>+method.getName()+<span class="string">&quot; is called&quot;</span>);</span><br><span class="line">        method.invoke(target,args);<span class="comment">//画蛇添足</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>method.invoke(target,args);</code>这句会在before函数执行完毕之后,被自动执行,不需要我们手动调用</p>
<p>手动调用了就会再执行一次,去掉即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodBeforeAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogBefore</span> <span class="keyword">implements</span> <span class="title class_">MethodBeforeAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;log before &quot;</span>+method.getName()+<span class="string">&quot; is called&quot;</span>);</span><br><span class="line"><span class="comment">//        method.invoke(target,args);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="遗留问题">遗留问题</h4>
<p>既然Test中调用的仍然是userService这个bean,那么把他作为UserServiceImpl可以不</p>
<p>也就是说</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserServiceImpl</span> <span class="variable">userServiceimp</span> <span class="operator">=</span> (UserServiceImpl) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这两种写法哪个对?</p>
<p>结果证明<code>UserService userService = (UserService) context.getBean("userService");</code>这个是对的</p>
<p>一定要注意左值是UserService接口类型,不是UserServiceImpl类型</p>
<p>那么为啥userService这个bean一开始是一个UserServiceImpl的对象,后来就不是了?</p>
<p>如果不加aop:config这一段,两种写法是都可以的</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        定义切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;cutBefore&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* top.dustball.service.User.UserServiceImpl.* (..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;cutAfterAdd&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* top.dustball.service.User.UserServiceImpl.add())&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        切入点和哪个切面通知挂钩--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;logBefore&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;cutBefore&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;logAfter&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;cutAfterAdd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>加上aop:config之前,<code>userService.getClass()="class top.dustball.service.User.UserServiceImpl"</code></p>
<p>加上aop:config之后,<code>userService.getClass()="class jdk.proxy2.$Proxy7"</code>,已经是代理对象了</p>
<p>至于到底发生了什么让userService被狸猫换太子,现在不想管</p>
<h3 id="方法2使用自定义类实现aop">方法2:使用自定义类实现AOP</h3>
<p>基本都使用方法1,啥时候用到这个法再来学吧</p>
<h3 id="方法3使用注解开发">方法3:使用注解开发</h3>
<p>首先要有一个切面类</p>
<p><span class="citation"
data-cites="Aspect注解作用到的类就作为切面类">@Aspect注解作用到的类就作为切面类</span>,</p>
<p>其方法中被@Before或者<span class="citation"
data-cites="After或者">@After或者</span><span class="citation"
data-cites="Around注解的">@Around注解的</span>,成为通知</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball.AOP;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.Signature;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationPointCut</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//before和after注解的方法,在执行之后,控制流会自动执行目标对象的函数,不需要手动执行,因此没有参数</span></span><br><span class="line"><span class="comment">//    @Before(&quot;execution(* top.dustball.service.User.UserServiceImpl.* (..))&quot;)</span></span><br><span class="line"><span class="comment">//    public void before()&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;log before method is called&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    @After(&quot;execution(* top.dustball.service.User.UserServiceImpl.* (..))&quot;)</span></span><br><span class="line"><span class="comment">//    public void after()&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;log after method is called&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* top.dustball.service.User.UserServiceImpl.* (..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> proceedingJoinPoint.getSignature();<span class="comment">//获取函数签名</span></span><br><span class="line">        System.out.println(signature);</span><br><span class="line">        proceedingJoinPoint.proceed();<span class="comment">//真正调用目标对象的add方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将该切面类注册到Spring容器中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;top.dustball&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;annotationPointCut&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.AOP.AnnotationPointCut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实现的功能和方法1相同</p>
<p>测试类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.dustball.service.User.UserService;</span><br><span class="line"><span class="keyword">import</span> top.dustball.service.User.UserServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">void top.dustball.service.User.UserService.add()</span><br><span class="line">UserService add called</span><br><span class="line">after</span><br></pre></td></tr></table></figure>
<h2 id="springmybatis">Spring+MyBatis</h2>
<h3 id="maven依赖">maven依赖</h3>
<p>一定要注意spring的各个组件版本号一致</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.mysql/mysql-connector-j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="回顾javaweb中使用mybatis">回顾javaweb中使用mybatis</h3>
<p>之前javaweb中如何使用mybatis的?</p>
<h4 id="mybatis-config.xml配置">mybatis-config.xml配置</h4>
<p>在resources目录下有一个mybatis-config.xml文件,其作用主要是配置数据源和映射mapper映射关系</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    top.dustball.pojo下面的类在本文件中均可以只是用非全限制类名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;top.dustball.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--    environments目录下面可以配置多个environment环境,在environments标签的default属性中设置使用哪一个即可--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sjh123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--    注册映射关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;top/dustball/mapper/UserMapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4
id="top.dustball.mapper.usermapper包">top.dustball.mapper.UserMapper包</h4>
<p>一个UserMapper接口,一个UserMapper.xml映射配置文件</p>
<p>其中UserMapper.xml必须绑定UserMapper接口,</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;top.dustball.mapper.UserMapper.UserMapper&quot;</span>&gt;</span>  <span class="comment">&lt;!--绑定接口--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    在UserMapper接口中使用注解开发--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后可以在UserMapper.xml中写CRUD标签,比如<code>&lt;select&gt;</code></p>
<p>也可以在UserMapper接口中直接使用注解开发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball.mapper.UserMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> top.dustball.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"><span class="comment">//    使用注解之后,就不需要在UserMapper.xml中写&lt;select&gt;这种增删改查的标签了</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM user WHERE id= #&#123;userID&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="type">int</span> userID)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4
id="top.dustball.utils下创建mybatisutil工具类">top.dustball.utils下创建MyBatisUtil工具类</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisUtil</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;<span class="comment">//类变量,只会被静态代码块初始化一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;<span class="comment">//静态代码块,只会在类加载时执行一次</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;<span class="comment">//配置文件位置</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);<span class="comment">//xml文件转化为文件输入流</span></span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<span class="comment">//根据文件创建sqlSessionFactory工厂</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">()</span>&#123;<span class="comment">//获取一个数据库会话连接</span></span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试">测试</h4>
<p>此后就可以在测试类中MyBatisUtil.getSqlSession了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.InputStreamResource;</span><br><span class="line"><span class="keyword">import</span> top.dustball.mapper.UserMapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> top.dustball.pojo.User;</span><br><span class="line"><span class="keyword">import</span> top.dustball.utils.MyBatisUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtil.getSqlSession();</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);<span class="comment">//获取UserMapper.class的映射器</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.getUser(<span class="number">2</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="spring中使用mybatis">Spring中使用mybatis</h3>
<h4 id="配置spring-dao.xml">配置spring-dao.xml</h4>
<p>(mybatis-config.xml可以保留也可以直接扬了,spring完全可以覆盖mybatis的配置,这里选择保留)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--    注册数据源,使用第三方类DriverManagerDataSource--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;datasource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sjh123456&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注册工厂类,此处可以导入mybatis-config.xml--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--也可以直接在本sqlSessionFactory中配置,不使用mybatis-config.xml--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--教程的做法是,mybatis-config.xml只保留typeAilas作用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;datasource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        可以在此处注册映射器,也可以在mybatis-config.xml中注册映射器,由于mybatis-config.xml已经注册过,这里不再重复--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;mapperLocations&quot; value=&quot;top/dustball/mapper/UserMapper/UserMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;typeAliases&quot; value=&quot;top.dustball.pojo&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    创建数据库会话实例,本bean的作用与之前的MyBatisUtil.getSqlSession相同--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        本bean只可以只用构造函数注入,因其不含setter方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>  <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    实例化映射器,关于user表的业务可以直接从userMapper上进行操作,相当于sqlSession.getMapper(UserMapper.class)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userMapper&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.mapper.UserMapper.UserMapperImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSession&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一是注意sqlSession的类型是SqlSessionTemplate,不再是SelSession(实际上是相同的作用)</p>
<p>二是注意最后创建的映射器实例,是UserMapperImpl类的实例,(显然UserMapper接口不能实例化)</p>
<p>这是区别于javaweb中使用mybatis的地方,之前只需要UserMapper接口和UserMapper.xml即可</p>
<p>现在还需要加一个UserMapperImpl,因为Spring
bean是实例,只有类才可以实例化</p>
<p>总结一下就是</p>
<p>实例化数据源</p>
<p>实例化工厂</p>
<p>实例化会话</p>
<p>实例化映射器</p>
<h4
id="top.dustball.mapper.usermapper包下再创建usermapperimpl类">top.dustball.mapper.UserMapper包下再创建UserMapperImpl类</h4>
<p>现在UserMapper包下有三个文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\sprint-01\Demo2\src\main\java\top\dustball\mapper\UserMapper&gt; <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">    Directory: C:\Users\86135\Desktop\sprint-01\Demo2\src\main\java\top\dustball\mapper\UserMapper</span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">-a---           2023/1/30    11:22            352 UserMapper.java</span><br><span class="line">-a---           2023/1/30    10:47            316 UserMapper.xml</span><br><span class="line">-a---           2023/1/30    11:24            668 UserMapperImpl.java</span><br></pre></td></tr></table></figure>
<p>其中UserMapperImpl是新增的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball.mapper.UserMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionTemplate;</span><br><span class="line"><span class="keyword">import</span> top.dustball.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMapperImpl</span> <span class="keyword">implements</span> <span class="title class_">UserMapper</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionTemplate sqlSession;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlSession</span><span class="params">(SqlSessionTemplate sqlSession)</span> &#123;</span><br><span class="line"><span class="comment">//设置setter方法,方便注入</span></span><br><span class="line">        <span class="built_in">this</span>.sqlSession = sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="type">int</span> userID)</span> &#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;getUser called&quot;);</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="keyword">return</span> mapper.getUser(userID);<span class="comment">//实际上还是调用了UserMapper接口中被@Select注解的getUser方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>原本获取mapper映射器是用户(程序员)的任务,需要在测试类中完成</p>
<p>现在mapper直接被封装到UserMapperImpl中</p>
<p>程序员只需要在测试类中调用userMapper.getUser(2);</p>
<h4 id="测试-1">测试</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> top.dustball.mapper.UserMapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> top.dustball.pojo.User;</span><br><span class="line"><span class="keyword">import</span> top.dustball.utils.MyBatisUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建SpringIoc容器</span></span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-dao.xml&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取userMapper映射器bean</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> (UserMapper) context.getBean(<span class="string">&quot;userMapper&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行dao业务</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.getUser(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="springmybatis简化用法">spring+mybatis简化用法</h3>
<p>之前在UserMapperImpl中我们需要维护一个成员对象sqlSession,如果让UserMapperImpl继承SqlSessionDaoSupport类,则不再需要</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball.mapper.UserMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionTemplate;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.support.SqlSessionDaoSupport;</span><br><span class="line"><span class="keyword">import</span> top.dustball.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMapperImpl</span> <span class="keyword">extends</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title class_">UserMapper</span>&#123;</span><br><span class="line"><span class="comment">//    private SqlSessionTemplate sqlSession;</span></span><br><span class="line"><span class="comment">//    public void setSqlSession(SqlSessionTemplate sqlSession) &#123;</span></span><br><span class="line"><span class="comment">////设置setter方法,方便注入</span></span><br><span class="line"><span class="comment">//        this.sqlSession = sqlSession;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="type">int</span> userID)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getSqlSession().getMapper(UserMapper.class).getUser(userID);</span><br><span class="line">        <span class="comment">//实际上还是调用了UserMapper接口中被@Select注解的getUser方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个类已经帮我们实现了getSqlSession方法</p>
<p>需要注意的是,在spring-dao.xml中稍有变化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   之前:</span><br><span class="line">&lt;bean id=<span class="string">&quot;userMapper&quot;</span> class=<span class="string">&quot;top.dustball.mapper.UserMapper.UserMapperImpl&quot;</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">&quot;sqlSession&quot;</span> ref=<span class="string">&quot;sqlSession&quot;</span>/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   之后:</span><br><span class="line">   &lt;bean id=<span class="string">&quot;userMapper&quot;</span> class=<span class="string">&quot;top.dustball.mapper.UserMapper.UserMapperImpl&quot;</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">&quot;sqlSessionTemplate&quot;</span> ref=<span class="string">&quot;sqlSession&quot;</span>/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>之前我们手动维护的成员对象叫做sqlSession,而之后继承自SqlSessionDaoSupport的是sqlSessionTemplate对象,实际上两个作用相同,就是property中的键名要改一下而已</p>
<h3 id="使用事务">使用事务</h3>
<h4 id="aop实现事务织入">AOP实现事务织入</h4>
<p>只需要在spring-dao.xml中增加配置,不需要修改任何源代码</p>
<p>spring-dao.xml这样写:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/util</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/util/spring-util.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    注册数据源,使用第三方类DriverManagerDataSource--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;datasource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sjh123456&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注册工厂类,此处可以导入mybatis-config.xml--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--也可以直接在本sqlSessionFactory中配置,不使用mybatis-config.xml--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--教程的做法是,mybatis-config.xml只保留typeAilas作用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;datasource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        可以在此处注册映射器,也可以在mybatis-config.xml中注册映射器,由于mybatis-config.xml已经注册过,这里不再重复--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;mapperLocations&quot; value=&quot;top/dustball/mapper/UserMapper/UserMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;typeAliases&quot; value=&quot;top.dustball.pojo&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    创建数据库会话实例,本bean的作用与之前的MyBatisUtil.getSqlSession相同--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        本bean只可以只用构造函数注入,因其不含setter方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>  <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    实例化映射器,关于user表的业务可以直接从userMapper上进行操作,相当于sqlSession.getMapper(UserMapper.class)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userMapper&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.dustball.mapper.UserMapper.UserMapperImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionTemplate&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSession&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;datasource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    tx是事务标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        给哪些方法上事务--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        配置事务的传播特性--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        一般设计数据库的业务都需要事务,查询除外,因此可以简单粗暴全上事务--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;select&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        mapper下面的所有类的所有方法都作为切点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* top.dustball.mapper.*.*.* (..) )&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--txAdivce作为通知应用于pointcut切点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>增加了一个transactionManager,一个txAdvice,一个aop</p>
<p>其中事务管理器可以有多种,JDBC,Druid等等</p>
<p>关键在于<code>&lt;tx:advice&gt;</code>标签,即事务通知,该标签用于说明给哪些方法上事务,只是针对方法名,此时还不会针对类名</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里propagation属性用于设置事务的传播属性,一般都是用REQUIRED,其他的有需要再查</p>
<blockquote>
<p>事务的七种传播特性</p>
<p><strong>默认值是required</strong></p>
<p><strong>默认值是required</strong></p>
<p><strong>默认值是required</strong></p>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr>
<th>传播特性</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>required</code></td>
<td>如果存在当前事务，那么加入该事务，<br />如果不存在事务，就创建一个事务。这是<code>propagation</code>的默认值</td>
</tr>
<tr>
<td><code>supports</code></td>
<td>如果当前已经存在事务，那么加入该事务，<br />否则创建一个所谓的空事务。</td>
</tr>
<tr>
<td><code>mandatory</code></td>
<td>当前必须存在一个事务，否则抛出异常</td>
</tr>
<tr>
<td><code>requires-new</code></td>
<td>如果当前存在事务，先把当前事务相关内容封装到一个实体，<br />然后重新创建一个新事务，并接受这个实体作为参数，用于事务恢复。</td>
</tr>
<tr>
<td><code>not-supported</code></td>
<td>如果当前存在事务，挂起当前事务，然后新的方法在没有事务的环境中执行。<br />没有spring事务的环境下，sql的提交完全依赖于<code>defaultAutoCommit</code>属性值</td>
</tr>
<tr>
<td><code>never</code></td>
<td>如果当前存在事务，则抛出异常。<br />否则在无事务的环境上执行代码</td>
</tr>
<tr>
<td><code>nested</code></td>
<td>如果当前存在事务，则使用<code>savepoint</code>技术将当前事务状态进行保存，&lt;br
/然后底层公用一个链接，<br />当nested内部出现错误的时候，自行回滚到<code>save point</code>的状态。<br />只要外部捕获到了异常，就可以继续进行外部事务的提交，而不会受到内嵌事务的干扰。<br />但是，如果外部事物抛出了异常，整个大事务都会回滚。</td>
</tr>
</tbody>
</table>
</blockquote>
<p>最后aop:config标签的作用是,将tx:advice通知作用与mapper包下的所有类的所有方法</p>
<p>之后所有的Dao层操作都是事务操作.</p>
<p>此前和此后在测试类中调用没有区别.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/01/27/Crack%20jar/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/27/Crack%20jar/" class="post-title-link" itemprop="url">jar包是什么</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-01-27 08:55:00 / Modified: 09:42:55" itemprop="dateCreated datePublished" datetime="2023-01-27T08:55:00+08:00">2023-01-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="crack-jar">Crack jar</h1>
<h2 id="jar包是啥">jar包是啥</h2>
<p>jar(java archieve file),java归档文件</p>
<h2 id="与zip比较">与zip比较</h2>
<p>其内容和zip文件非常相似,甚至可以直接使用360压缩这种软件解压</p>
<p>唯一的区别就是,jar中有一个META-INF目录,这里面有一个MANIFEST.MF文件,该文件可能长这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Implementation-Title: challenge</span><br><span class="line">Implementation-Version: 0.0.1-SNAPSHOT</span><br><span class="line">Built-By: shiyu</span><br><span class="line">Implementation-Vendor-Id: io.tricking</span><br><span class="line">Spring-Boot-Version: 2.1.0.RELEASE</span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher</span><br><span class="line">Start-Class: io.tricking.challenge.ChallengeApplication</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/</span><br><span class="line">Created-By: Apache Maven 3.5.3</span><br><span class="line">Build-Jdk: 1.8.0_102</span><br><span class="line">Implementation-URL: https://projects.spring.io/spring-boot/#/spring-bo</span><br><span class="line"> ot-starter-parent/challenge</span><br></pre></td></tr></table></figure>
<p>其中最关键的是Main-Class信息,即jar包的入口点</p>
<p>有些jar包可以通过<code>java -jar a.jar</code>这种命令被执行,此时Main-Class就指定从哪个类的Main函数开始执行</p>
<p>可以理解为,这个META-INF/MANIFEST.MF就是一个清单,表明该jar包的概要信息.</p>
<p>jar包其他文件主就是class字节码文件等</p>
<h2 id="打包目的">打包目的</h2>
<p>打jar包的目的,实际上和c/c++中制作.lib静态库或者.dll动态库一样,就一个文件,方便别人拷贝使用</p>
<p>模块化,标准化</p>
<p>只要写好文档,告诉别人如何调用jar包中的类和函数即可</p>
<p>maven管理的第三方库,都是使用jar包的形式提供的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230126155922111.png"
alt="image-20230126155922111" />
<figcaption aria-hidden="true">image-20230126155922111</figcaption>
</figure>
<h2 id="jar-vs-war">jar vs war</h2>
<p>war包是Sun公司提出的web应用程序格式</p>
<p>两者相同点,都是一个压缩包</p>
<p>不同点,目录结构有区别</p>
<p>凡是能打war包的东西,必然能够打jar包</p>
<h2 id="如何打包">如何打包</h2>
<h3 id="源代码">源代码</h3>
<p>源代码结构</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree]</span><br><span class="line">└─# tree src -f</span><br><span class="line">src</span><br><span class="line">└── src/top</span><br><span class="line">    └── src/top/dustball</span><br><span class="line">        ├── src/top/dustball/Dao</span><br><span class="line">        │   └── src/top/dustball/Dao/User.java</span><br><span class="line">        └── src/top/dustball/Main.java</span><br><span class="line"></span><br><span class="line">3 directories, 2 files</span><br></pre></td></tr></table></figure>
<p>其中User.java是一个pojo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball.Dao;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String username;</span><br><span class="line">    String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String username,String password)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.username=username;</span><br><span class="line">        <span class="built_in">this</span>.password=password;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span>+username+<span class="string">&quot;,&quot;</span>+password+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main.java是程序入口,依赖User类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball;</span><br><span class="line"><span class="keyword">import</span> top.dustball.Dao.User;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;vader&quot;</span>, <span class="string">&quot;sjh&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="javac编译">javac编译</h3>
<p>打入jar包的都是class字节码文件,没有java源文件,因此首先需要javac编译</p>
<p>可以使用<code>javac &lt;sourcefile&gt; -d out</code>将所有字节码文件打包到out目录下</p>
<p>这里sourcefile没有找到一个一劳永逸的方法</p>
<p>每个javac命令最多只能编译一个目录下的所有java文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">top.dustball/</span><br><span class="line">	Dao/</span><br><span class="line">		User.java</span><br><span class="line">	Main.java</span><br></pre></td></tr></table></figure>
<p>这里Dao/User.java和Main.java在不同的目录下,并且Main.java中依赖User.java,因此需要写一个很长的编译命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree]</span><br><span class="line">└─# javac src/top/dustball/Dao/*.java src/top/dustball/*.java -d out</span><br></pre></td></tr></table></figure>
<p>更好的方法是将所有需要编译的源代码文件写到一份清单中,然后让javac根据清单工作,比如在根目录下写一个JavaList.txt</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src/top/dustball/Dao/User.java</span><br><span class="line">src/top/dustball/Main.java</span><br></pre></td></tr></table></figure>
<p>此时在此处执行javac,就是javac的当前工作目录</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree]</span><br><span class="line">└─# javac @JavaList.txt -d out</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree]</span><br><span class="line">└─# <span class="built_in">ls</span></span><br><span class="line">bin  JavaList.txt  lib  out  README.md  src</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree]</span><br><span class="line">└─# tree -f out</span><br><span class="line">out</span><br><span class="line">└── out/top</span><br><span class="line">    └── out/top/dustball</span><br><span class="line">        ├── out/top/dustball/Dao</span><br><span class="line">        │   └── out/top/dustball/Dao/User.class</span><br><span class="line">        └── out/top/dustball/Main.class</span><br><span class="line"></span><br><span class="line">3 directories, 2 files</span><br></pre></td></tr></table></figure>
<p>此时在根目录下已经生成了out目录,保留了包结构和所有class文件,下一步就是打jar包了</p>
<h3 id="jar打包">jar打包</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree]</span><br><span class="line">└─# jar -cvf Main.jar out/top/dustball/Main.class out/top/dustball/Dao/User.class</span><br><span class="line">added manifest</span><br><span class="line">adding: out/top/dustball/Main.class(<span class="keyword">in</span> = 523) (out= 341)(deflated 34%)</span><br><span class="line">adding: out/top/dustball/Dao/User.class(<span class="keyword">in</span> = 897) (out= 485)(deflated 45%)</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree]</span><br><span class="line">└─# <span class="built_in">ls</span> *.jar</span><br><span class="line">Main.jar</span><br></pre></td></tr></table></figure>
<p>此时在jar工作目录,也就是跟目录下,生成了Main.jar其中都有啥呢?</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree]</span><br><span class="line">└─# jar -tf Main.jar</span><br><span class="line">META-INF/</span><br><span class="line">META-INF/MANIFEST.MF</span><br><span class="line">out/top/dustball/Main.class</span><br><span class="line">out/top/dustball/Dao/User.class</span><br></pre></td></tr></table></figure>
<p>两个class都已经打包进入了Main.jar</p>
<p>关键在这个<code>META-INF/MANIFEST.MF</code></p>
<p>提取Main.jar之后,该文件长这样</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Created-By: 11.0.17 (Debian)</span><br></pre></td></tr></table></figure>
<p>唯一的有效信息是jdk版本11.0.17,Debian操作系统</p>
<p>没有Main-Class入口点信息,显然直接java -jar是不可以执行的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree]</span><br><span class="line">└─# java -jar Main.jar</span><br><span class="line">no main manifest attribute, <span class="keyword">in</span> Main.jar</span><br></pre></td></tr></table></figure>
<p>没有主属性清单</p>
<p>怎么改呢?</p>
<p><strong>写到这里发现一个重大错误,包名不统一了</strong></p>
<p>啥意思呢?</p>
<p>之前javac,jar的工作目录都是根目录,而包在src路径之下,是根目录的子目录</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree]</span><br><span class="line">└─# jar -tf Main.jar</span><br><span class="line">META-INF/</span><br><span class="line">META-INF/MANIFEST.MF</span><br><span class="line">out/top/dustball/Main.class</span><br><span class="line">out/top/dustball/Dao/User.class</span><br></pre></td></tr></table></figure>
<p>此处out路径被当作了包的最外层,</p>
<p>可能是jar打包认为out也是包路径,但是class自己认为out不是包路径,此后就出错了</p>
<p>而实际上应该让包从top开始,如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree]</span><br><span class="line">└─# jar -tf Main.jar</span><br><span class="line">META-INF/</span><br><span class="line">META-INF/MANIFEST.MF</span><br><span class="line">top/dustball/Main.class</span><br><span class="line">top/dustball/Dao/User.class</span><br></pre></td></tr></table></figure>
<p>按照这样修改之后,在<code>META-INF/MANIFEST.MF</code>中这样写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Created-By: <span class="number">11.0</span><span class="number">.17</span> (Debian)</span><br><span class="line">Main-Class: top.dustball.Main</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这就指定好了入口类</p>
<p>然后重新打包,这一次需要-m指定<code>META-INF/MANIFEST.MF</code>文件,作为jar包清单</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire]</span><br><span class="line">└─# jar -cvfm Main.jar META-INF/MANIFEST.MF top/dustball/Main.class top/dustball/Dao</span><br><span class="line">added manifest</span><br><span class="line">adding: top/dustball/Main.class(<span class="keyword">in</span> = 523) (out= 341)(deflated 34%)</span><br><span class="line">adding: top/dustball/Dao/(<span class="keyword">in</span> = 0) (out= 0)(stored 0%)</span><br><span class="line">adding: top/dustball/Dao/User.class(<span class="keyword">in</span> = 897) (out= 485)(deflated 45%)</span><br></pre></td></tr></table></figure>
<h3 id="执行">执行</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire]</span><br><span class="line">└─# java -jar Main.jar</span><br><span class="line">[vader,sjh]</span><br></pre></td></tr></table></figure>
<h3 id="更灵活的打包方式">更灵活的打包方式</h3>
<p>javac编译时,使用清单列出需要编译的源文件是一个好办法</p>
<p>jar打包时有没有更方便的方法呢?</p>
<p>刚才我们有两个打jar包的方式,其一是直接指定所有class文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf Main.jar out/top/dustball/Main.class out/top/dustball/Dao/User.class</span><br></pre></td></tr></table></figure>
<p>此时Manifest文件是自动生成的,不包含入口点等信息</p>
<p>需要编写Manifest文件之后重新打包</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvfm Main.jar META-INF/MANIFEST.MF top/dustball/Main.class top/dustball/Dao</span><br></pre></td></tr></table></figure>
<p>奇怪的是,当时Dao/User.class没有敲上,敲到Dao就停了,也成功打包了</p>
<p>现在把修改后的META-INF/MANIFEST.MF整体拷贝到out目录下,现在的out目录:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree/out]</span><br><span class="line">└─# tree -f</span><br><span class="line">.</span><br><span class="line">├── ./META-INF</span><br><span class="line">│   └── ./META-INF/MANIFEST.MF</span><br><span class="line">└── ./top</span><br><span class="line">    └── ./top/dustball</span><br><span class="line">        ├── ./top/dustball/Dao</span><br><span class="line">        │   └── ./top/dustball/Dao/User.class</span><br><span class="line">        └── ./top/dustball/Main.class</span><br><span class="line"></span><br><span class="line">4 directories, 3 files</span><br></pre></td></tr></table></figure>
<p>在此处指定META-INF/MANIFEST.MF并打包</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree/out]</span><br><span class="line">└─# jar -cvfm Main.jar META-INF/MANIFEST.MF *</span><br><span class="line">added manifest</span><br><span class="line">ignoring entry META-INF/</span><br><span class="line">ignoring entry META-INF/MANIFEST.MF</span><br><span class="line">adding: top/(<span class="keyword">in</span> = 0) (out= 0)(stored 0%)</span><br><span class="line">adding: top/dustball/(<span class="keyword">in</span> = 0) (out= 0)(stored 0%)</span><br><span class="line">adding: top/dustball/Dao/(<span class="keyword">in</span> = 0) (out= 0)(stored 0%)</span><br><span class="line">adding: top/dustball/Dao/User.class(<span class="keyword">in</span> = 897) (out= 485)(deflated 45%)</span><br><span class="line">adding: top/dustball/Main.class(<span class="keyword">in</span> = 523) (out= 341)(deflated 34%)</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree/out]</span><br><span class="line">└─# <span class="built_in">ls</span></span><br><span class="line">Main.jar  META-INF  top</span><br></pre></td></tr></table></figure>
<p>执行jar包</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree/out]</span><br><span class="line">└─# java -jar Main.jar</span><br><span class="line">[vader,sjh]</span><br></pre></td></tr></table></figure>
<h3 id="更更灵活的打包方式">更更灵活的打包方式</h3>
<p>在打包的时候不指定入口点而在执行的时候指定入口点</p>
<p>out目录状态:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree/out]</span><br><span class="line">└─# tree -f</span><br><span class="line">.</span><br><span class="line">└── ./top</span><br><span class="line">    └── ./top/dustball</span><br><span class="line">        ├── ./top/dustball/Dao</span><br><span class="line">        │   └── ./top/dustball/Dao/User.class</span><br><span class="line">        └── ./top/dustball/Main.class</span><br><span class="line"></span><br><span class="line">3 directories, 2 files</span><br></pre></td></tr></table></figure>
<p>直接再次处打jar包</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree/out]</span><br><span class="line">└─# jar -cvf Main.jar *</span><br><span class="line">added manifest</span><br><span class="line">adding: top/(<span class="keyword">in</span> = 0) (out= 0)(stored 0%)</span><br><span class="line">adding: top/dustball/(<span class="keyword">in</span> = 0) (out= 0)(stored 0%)</span><br><span class="line">adding: top/dustball/Dao/(<span class="keyword">in</span> = 0) (out= 0)(stored 0%)</span><br><span class="line">adding: top/dustball/Dao/User.class(<span class="keyword">in</span> = 897) (out= 485)(deflated 45%)</span><br><span class="line">adding: top/dustball/Main.class(<span class="keyword">in</span> = 523) (out= 341)(deflated 34%)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行时指定入口点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree/out]</span><br><span class="line">└─# java -<span class="built_in">cp</span> Main.jar top.dustball.Main</span><br><span class="line">[vader,sjh]</span><br></pre></td></tr></table></figure>
<h2 id="依赖jar包">依赖jar包</h2>
<p>现在jar包中有一个top.dustball.User类,在Test类中调用之</p>
<p>在Test路径下有一个Main.jar这个包,还有测试类Test</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/Test]</span><br><span class="line">└─# <span class="built_in">ls</span></span><br><span class="line">Main.jar  Test.java</span><br></pre></td></tr></table></figure>
<p>其中Test.java试图调用User类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.dustball.Dao.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;vader&quot;</span>, <span class="string">&quot;sjh&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译链接要加上-cp选项,指定依赖项</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--class-path &lt;path&gt;, -classpath &lt;path&gt;, -cp &lt;path&gt;</span><br><span class="line">       Specify where to find user class files and annotation processors</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\empire\Test&gt; javac Test.java -<span class="built_in">cp</span> Main.jar</span><br></pre></td></tr></table></figure>
<p>由于Test.java有一个包Test,因此需要退到上级目录执行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\empire\Test&gt; <span class="built_in">cd</span> ..</span><br><span class="line">PS C:\Users\86135\Desktop\empire&gt; java Test/Test</span><br><span class="line">[vader,sjh]</span><br></pre></td></tr></table></figure>
<h2 id="命令">命令</h2>
<h3 id="jar命令">jar命令</h3>
<p>jar命令是jdk的工具,该exe文件在jdk/bin目录下,需要将该bin目录添加到系统环境变量path,也就是配置jdk环境变量</p>
<h4 id="jar--tf">jar -tf</h4>
<p>列表列出jar包结构</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -tf a.jar</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree]</span><br><span class="line">└─# jar -tf Main.jar</span><br><span class="line">META-INF/</span><br><span class="line">META-INF/MANIFEST.MF</span><br><span class="line">out/top/dustball/Main.class</span><br><span class="line">out/top/dustball/Dao/User.class</span><br></pre></td></tr></table></figure>
<h4 id="jar--xf">jar -xf</h4>
<p>提取jar包文件,效果等同于解压</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\javacon&gt; jar -xf challange.jar</span><br><span class="line">PS C:\Users\86135\Desktop\javacon&gt; <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">    Directory: C:\Users\86135\Desktop\javacon</span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d----           2018/11/6    13:34                BOOT-INF</span><br><span class="line">d----           2018/11/6    13:34                META-INF</span><br><span class="line">d----           2018/11/6    13:34                org</span><br><span class="line">-a---           2023/1/26    15:21       18134425 challange.jar</span><br></pre></td></tr></table></figure>
<h3 id="javac命令">javac命令</h3>
<p>javac java编译器,用于将源代码java文件编译为class字节码文件</p>
<p>javac可以类比为gcc或者g++</p>
<h4 id="javac--d">javac -d</h4>
<p>指定class文件输出位置,保留包结构</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree]</span><br><span class="line">└─# tree src -f</span><br><span class="line">src</span><br><span class="line">└── src/top</span><br><span class="line">    └── src/top/dustball</span><br><span class="line">        ├── src/top/dustball/Dao</span><br><span class="line">        │   └── src/top/dustball/Dao/User.java</span><br><span class="line">        └── src/top/dustball/Main.java</span><br><span class="line"></span><br><span class="line">3 directories, 2 files</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree]</span><br><span class="line">└─# javac src/top/dustball/Dao/*.java src/top/dustball/*.java -d out</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree]</span><br><span class="line">└─# <span class="built_in">ls</span></span><br><span class="line">bin  lib  out  README.md  src</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree]</span><br><span class="line">└─# tree out -f</span><br><span class="line">out</span><br><span class="line">└── out/top</span><br><span class="line">    └── out/top/dustball</span><br><span class="line">        ├── out/top/dustball/Dao</span><br><span class="line">        │   └── out/top/dustball/Dao/User.class</span><br><span class="line">        └── out/top/dustball/Main.class</span><br><span class="line"></span><br><span class="line">3 directories, 2 files</span><br></pre></td></tr></table></figure>
<h4 id="javac--cp">javac -cp</h4>
<p>链接外部依赖</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\empire\Test&gt; javac Test.java -<span class="built_in">cp</span> Main.jar</span><br></pre></td></tr></table></figure>
<h3 id="java命令">java命令</h3>
<h4 id="java--jar">java -jar</h4>
<p>执行自带入口点的jar包</p>
<h4 id="java--cp">java -cp</h4>
<p>运行时指定jar包入口点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/empire/empiree/out]</span><br><span class="line">└─# java -<span class="built_in">cp</span> Main.jar top.dustball.Main</span><br><span class="line">[vader,sjh]</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/01/04/Class%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/04/Class%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">class字节码文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-01-04 22:55:00" itemprop="dateCreated datePublished" datetime="2023-01-04T22:55:00+08:00">2023-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-27 17:35:38" itemprop="dateModified" datetime="2023-01-27T17:35:38+08:00">2023-01-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="class字节码文件">Class字节码文件</h1>
<p>javac编译.java源文件之后生成的 class字节码文件</p>
<p>class文件其中都包含了什么?</p>
<p>java是如何编译链接的?</p>
<p>jar包和class的关系?</p>
<p>class文件能否理解为c语言编译生成的可重定位目标模块.o?</p>
<p>每个interface,每个类,都会编译生成一个class文件.即使两个类写到同一个java文件里了,编译后也会生成两个class文件</p>
<p>Point.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dustball;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Measurable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getDistance</span><span class="params">(Point p)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> <span class="keyword">implements</span> <span class="title class_">Measurable</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="type">double</span> __x;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">double</span> __y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">double</span> _x, <span class="type">double</span> _y)</span> &#123;</span><br><span class="line">    __x = _x;</span><br><span class="line">    __y = _y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + Double.toString(__x) + <span class="string">&quot;,&quot;</span> + Double.toString(__y) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getDistance</span><span class="params">(Point p)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">dist</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    dist = (__x - p.__x) * (__x - p.__x) + (__y - p.__y) * (__y - p.__y);</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(dist);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Point A=<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    System.out.println(A.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaggedPoint</span> <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"></span><br><span class="line">  String __t;</span><br><span class="line"></span><br><span class="line">  TaggedPoint(String _t, <span class="type">double</span> _x, <span class="type">double</span> _y) &#123;</span><br><span class="line">    <span class="built_in">super</span>(_x, _y);</span><br><span class="line">    __t = _t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Line</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Point __A;</span><br><span class="line">  <span class="keyword">public</span> Point __B;</span><br><span class="line"></span><br><span class="line">  Line(Point _A, Point _B) &#123;</span><br><span class="line">    __A = _A;</span><br><span class="line">    __B = _B;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里面有一个接口Measurable,一个Point类及其子类TaggedPoint,一个final类Line</p>
<p>编译后生成了四个文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\java\cmd\target\classes\com\dustball&gt; <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">    Directory: C:\Users\86135\Desktop\java\cmd\target\classes\com\dustball</span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">-a---          2022/12/30    20:02            467 Line.class</span><br><span class="line">-a---          2022/12/30    20:02            191 Measurable.class</span><br><span class="line">-a---          2022/12/30    20:02           1004 Point.class</span><br><span class="line">-a---          2022/12/30    20:02            456 TaggedPoint.class</span><br><span class="line"></span><br><span class="line">PS C:\Users\86135\Desktop\java\cmd\target\classes\com\dustball&gt; 010editor *.class</span><br></pre></td></tr></table></figure>
<p>直接<code>010editor *.class</code>全部打开观察</p>
<h2 id="class文件结构">class文件结构</h2>
<p>整个class文件大体上线性地排列者以下几部分</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221230194129578.png"
alt="image-20221230194129578" />
<figcaption aria-hidden="true">image-20221230194129578</figcaption>
</figure>
<h3 id="magic">magic</h3>
<p>文件魔术0xCAFEBABE</p>
<h3 id="minor_versionmajor_version">minor_version/major_version</h3>
<p>副/主 版本号</p>
<p>描述本class文件可以被java几执行</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221230173614375.png"
alt="image-20221230173614375" />
<figcaption aria-hidden="true">image-20221230173614375</figcaption>
</figure>
<p>但是这个52是怎么来的?主版本号何曾到过52?</p>
<p>这是因为java的最初版本号是45,不是从0开始的</p>
<p>52是jdk1.8?然而我也不知道怎么换算的,可以从010editor模板代码中看出这一点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">ClassFileOnComment</span><span class="params">(ClassFile &amp;obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(obj.major_version)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">45</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;JDK 1.0 or JDK 1.1&quot;</span>; </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">46</span>:</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;JDK 1.2&quot;</span>; </span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">47</span>:</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;JDK 1.3&quot;</span>; </span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">48</span>:</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;JDK 1.4&quot;</span>;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">49</span>:</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;JDK 1.5&quot;</span>;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">50</span>:</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;JDK 1.6&quot;</span>;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">51</span>:</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;JDK 1.7&quot;</span>;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">52</span>:</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;JDK 1.8&quot;</span>;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">53</span>:</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;JDK 1.9&quot;</span>;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;JDK ?.?&quot;</span>;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="constant_pool_count">constant_pool_count</h3>
<p>常量池容量计数值,该值决定了紧接着的constant_pool[]数组的元素个数</p>
<h3 id="constant_pool常量池">constant_pool[]常量池</h3>
<p>可以理解为可重定位目标模块中的符号表.symtab</p>
<p>这个数组的0下标位置是空出来不使用的,从1下标开始使用</p>
<p>0下标可以作为"空引用",也就是说其他元素引用0号元素意味着引用个寂寞</p>
<p>奇怪的是,这个数组的每个元素可以不一样大</p>
<p>正常c语言的结构体数组,每个元素都是相同大小的结构体,即使有些域用不到也得空着占位</p>
<p>而对于constant_pool:</p>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221230175137853.png" /></p>
<p>每个元素最开始必然有一个tag成员,表明该元素是何种类型,也就确定了其占地大小,</p>
<p>常量池中主要存放两大类常量:字面量Literal和符号引用Symbolic
References</p>
<h3 id="access_flags">access_flags</h3>
<p>访问标志</p>
<p>两个字节表示的访问标志,用于描述本类的信息,多个属性按位或</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221230195212243.png"
alt="image-20221230195212243" />
<figcaption aria-hidden="true">image-20221230195212243</figcaption>
</figure>
<table>
<thead>
<tr>
<th>类型</th>
<th>类名</th>
<th>继承</th>
<th>access_flag</th>
</tr>
</thead>
<tbody>
<tr>
<td>interface</td>
<td>Measurable</td>
<td>Object</td>
<td>0x0600(抽象|接口)</td>
</tr>
<tr>
<td>public class</td>
<td>Point</td>
<td>Object</td>
<td>0x0021(公共|子类)</td>
</tr>
<tr>
<td>class</td>
<td>TaggedPoint</td>
<td>Point</td>
<td>0x0020(子类)</td>
</tr>
<tr>
<td>final class</td>
<td>Line</td>
<td>Object</td>
<td>0x0030(final|子类)</td>
</tr>
</tbody>
</table>
<h3 id="索引集合">索引集合</h3>
<p>紧跟在访问标志之后,是</p>
<p>本类索引,</p>
<p>父类索引,</p>
<p>接口索引集合</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221230202234391.png"
alt="image-20221230202234391" />
<figcaption aria-hidden="true">image-20221230202234391</figcaption>
</figure>
<p>只有接口是一个集合,是因为java中只允许单继承,父类只能有一个,但是接口可以实现多个</p>
<p>索引值是一个下标,比如this_class=1,意思是去常量池中找1号常量</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221230202532520.png"
alt="image-20221230202532520" />
<figcaption aria-hidden="true">image-20221230202532520</figcaption>
</figure>
<p>tag=1表示utf8_info,即一个字符串</p>
<p>正好就是本类类名</p>
<p>又如super_class=3,意思是去常量池找3号常量</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221230202946050.png"
alt="image-20221230202946050" />
<figcaption aria-hidden="true">image-20221230202946050</figcaption>
</figure>
<p>也是一个tag=1,utf8字符串,正好是Object类名</p>
<p>this_class和super_class之后是interfaces_count,一个整数表示本类实现了几个接口,有一个算一个都要列在后面的interfaces索引数组中</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221230203155953.png"
alt="image-20221230203155953" />
<figcaption aria-hidden="true">image-20221230203155953</figcaption>
</figure>
<p>Point类只实现了一个Measurable接口他的索引号是5</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221230203241579.png"
alt="image-20221230203241579" />
<figcaption aria-hidden="true">image-20221230203241579</figcaption>
</figure>
<h3 id="字段表集合">字段表集合</h3>
<p>用于描述接口或者类中声明的变量</p>
<p>首先是一个整数fields_count描述类有几个字段</p>
<p>紧跟着就是对每个字段的描述</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221230205132151.png"
alt="image-20221230205132151" />
<figcaption aria-hidden="true">image-20221230205132151</figcaption>
</figure>
<p>这些描述包括:</p>
<p>access_flags,访问标志,包括static,public,final,volatile等等</p>
<p>name_index,符号名自己在常量池中的下标,也就是<code>__x</code>的下标</p>
<p>descriptor_index,类型名在常量池中的下标,也就是double的下标</p>
<p>attributes_count</p>
<h4 id="access_flags-1">access_flags</h4>
<p>每一种属性占用一位,该位为0表示没有这种属性,为1表示有</p>
<p>共有16位,只用到9位</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221230205606249.png"
alt="image-20221230205606249" />
<figcaption aria-hidden="true">image-20221230205606249</figcaption>
</figure>
<p>对于<code>double __x;</code>,其属性是0x0004(protected)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221230210219778.png"
alt="image-20221230210219778" />
<figcaption aria-hidden="true">image-20221230210219778</figcaption>
</figure>
<h4 id="name_index">name_index</h4>
<p>字段的简单名称</p>
<p>"简单名称"意思是没有加上类名前缀,</p>
<p><code>__x</code>的完整名称应该是<code>com/dustball/Point.__x</code></p>
<p>但是当前文件就是在描述Point类,显然没有必要再给其成员存放完整名称了</p>
<h4 id="descriptor_index">descriptor_index</h4>
<p>描述符在符号表中的下标</p>
<p>描述符就是double,int等等的类型</p>
<p>只需要一个字符D就可以表明double类型</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221230211059690.png"
alt="image-20221230211059690" />
<figcaption aria-hidden="true">image-20221230211059690</figcaption>
</figure>
<h4 id="额外属性">额外属性</h4>
<p>额外属性可能有多个,因此首先一个attributes_count整数,表明有多少个额外属性</p>
<p>有多少个就在后面列明多少个</p>
<p>这里<code>__x</code>没有额外属性</p>
<h3 id="方法表集合">方法表集合</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221230211542677.png"
alt="image-20221230211542677" />
<figcaption aria-hidden="true">image-20221230211542677</figcaption>
</figure>
<p>方法表和字段表的结构比较相似</p>
<p>首先还是访问修饰</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221230211704703.png"
alt="image-20221230211704703" />
<figcaption aria-hidden="true">image-20221230211704703</figcaption>
</figure>
<p>然后是简单名称引用和描述符引用</p>
<p>这两个合起来就正这样</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221230212018387.png"
alt="image-20221230212018387" />
<figcaption aria-hidden="true">image-20221230212018387</figcaption>
</figure>
<p><code>&lt;init&gt;(DD)V</code>这里<code>&lt;init&gt;</code>是构造函数名,<code>(DD)</code>表明两个double类型的参数,V表明无返回值</p>
<p><code>main([Ljava/lang/String;)V</code>,这里<code>main</code>是主函数名<code>([Ljava/lang/String;)</code>注意这里中括号没有对齐,只有左中括号表明参数是一个数组类型</p>
<p>然后是attributes_count属性个数和attributes属性表</p>
<p>字段,方法都可以有属性表</p>
<p>方法编译成的opcode就放在其属性表中</p>
<h3 id="属性表">属性表</h3>
<h4 id="code属性">Code属性</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221230212736701.png"
alt="image-20221230212736701" />
<figcaption aria-hidden="true">image-20221230212736701</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221230212754406.png"
alt="image-20221230212754406" />
<figcaption aria-hidden="true">image-20221230212754406</figcaption>
</figure>
<h5 id="attribute_name_indexcode">attribute_name_index=Code</h5>
<p>表明这是Code属性</p>
<h5 id="attribute_length">attribute_length</h5>
<p>本属性的长度</p>
<h5 id="max_stack">max_stack</h5>
<p>操作数栈深度最大值</p>
<h5 id="max_locals">max_locals</h5>
<p>局部变量最大存储空间(单位:槽)</p>
<p>32位及以下数据用一个槽</p>
<p>64位及以上用两个槽</p>
<p>槽可以复用,函数中用完死了的变量给后面的新局部变量腾空</p>
<p>max_stack和max_locals两者共同决定了函数栈帧的大小</p>
<h5 id="code_length">code_length</h5>
<p>指令长度</p>
<h5 id="code">code</h5>
<p>指令码,可以类比作x86机器码</p>
<p>只不过这个指令是给JVM看的,x86机器码是给x86机器看的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221230213315763.png"
alt="image-20221230213315763" />
<figcaption aria-hidden="true">image-20221230213315763</figcaption>
</figure>
<p>用javap 反编译也可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public com.dustball.Point(double, double);</span><br><span class="line">  descriptor: (DD)V</span><br><span class="line">  flags: (0x0001) ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=3, locals=5, args_size=3</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #13                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: aload_0</span><br><span class="line">       5: dload_1</span><br><span class="line">       6: putfield      #16                 // Field __x:D</span><br><span class="line">       9: aload_0</span><br><span class="line">      10: dload_3</span><br><span class="line">      11: putfield      #18                 // Field __y:D</span><br><span class="line">      14: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 14: 0</span><br><span class="line">      line 15: 4</span><br><span class="line">      line 16: 9</span><br><span class="line">      line 17: 14</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0      15     0  this   Lcom/dustball/Point;</span><br><span class="line">          0      15     1    _x   D</span><br><span class="line">          0      15     3    _y   D</span><br><span class="line">  MethodParameters:</span><br><span class="line">    Name                           Flags</span><br><span class="line">    _x</span><br><span class="line">    _y</span><br></pre></td></tr></table></figure>
<p>至于java自己造的给虚拟机看的那些指令,现在不想研究</p>
<p>关于jvm多重要多重要,感觉都是大量java码农吹出来的.不如看先看明白CSAPP</p>
<h2 id="java编译链接">java编译链接</h2>
<p>同一包下有两个文件,存在依赖关系</p>
<p>App.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball;</span><br><span class="line"><span class="keyword">import</span> top.dustball.Point;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Point p=<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">        System.out.println(p.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Point.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.x=x;</span><br><span class="line">        <span class="built_in">this</span>.y=y;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span>+x+<span class="string">&quot;,&quot;</span>+y+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中App.java中,Main函数引用Point构造函数和toString函数</p>
<p>如果只编译App.java会报告找不到符号出错误</p>
<p>需要同时编译App.java和Point.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac App.java Point.java </span><br></pre></td></tr></table></figure>
<p>在同一目录下生成Point.class和App.class文件</p>
<p>如果要用java执行App.class文件,需要推到包路径下<code>java top/dustball/App</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\vsJava\empire\src\main\java\top\dustball&gt; javac App.java Point.java </span><br><span class="line">PS C:\Users\86135\Desktop\vsJava\empire\src\main\java\top\dustball&gt; java App</span><br><span class="line">错误: 找不到或无法加载主类 App</span><br><span class="line">原因: java.lang.NoClassDefFoundError: top/dustball/App (wrong name: App)</span><br><span class="line">PS C:\Users\86135\Desktop\vsJava\empire\src\main\java\top\dustball&gt; <span class="built_in">cd</span> ../../</span><br><span class="line">PS C:\Users\86135\Desktop\vsJava\empire\src\main\java&gt; java top/dustball/App</span><br><span class="line">(2.0,5.0)</span><br></pre></td></tr></table></figure>
<p>这两个class文件都有用,如果把Point.class搬走,只执行App.class会报告链接错误</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\vsJava\empire\src\main\java&gt; java top/dustball/App</span><br><span class="line">(2.0,5.0)</span><br><span class="line">PS C:\Users\86135\Desktop\vsJava\empire\src\main\java&gt; java top/dustball/App       </span><br><span class="line">错误: 加载主类 top.dustball.App 时出现 LinkageError</span><br><span class="line">        java.lang.ClassFormatError: Incompatible magic value 1347093252 <span class="keyword">in</span> class file top/dustball/App</span><br></pre></td></tr></table></figure>
<p>这个Point.class的位置在导入类的时候就决定了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.dustball;</span><br><span class="line"><span class="keyword">import</span> top.dustball.Point;</span><br></pre></td></tr></table></figure>
<p>也就是说必须得和App同一路径下</p>
<h2 id="jar包">jar包</h2>
<p>java archieve</p>
<p>文件魔数是504B0304,和zip压缩包是相同的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230104214655752.png"
alt="image-20230104214655752" />
<figcaption aria-hidden="true">image-20230104214655752</figcaption>
</figure>
<p>解压缩或者jar -xf 命令均可以拆jar包</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\jar&gt; jar <span class="literal">-xf</span> junit<span class="literal">-4</span>.<span class="number">13.2</span>.jar</span><br><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\jar&gt; <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">    Directory: C:\Users\<span class="number">86135</span>\Desktop\jar</span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line"><span class="literal">----</span>                 <span class="literal">-------------</span>         <span class="literal">------</span> <span class="literal">----</span></span><br><span class="line">d<span class="literal">----</span>           <span class="number">2021</span>/<span class="number">2</span>/<span class="number">13</span>    <span class="number">17</span>:<span class="number">31</span>                junit</span><br><span class="line">d<span class="literal">----</span>           <span class="number">2021</span>/<span class="number">2</span>/<span class="number">13</span>    <span class="number">17</span>:<span class="number">31</span>                META<span class="literal">-INF</span></span><br><span class="line">d<span class="literal">----</span>           <span class="number">2021</span>/<span class="number">2</span>/<span class="number">13</span>    <span class="number">17</span>:<span class="number">31</span>                org</span><br><span class="line"><span class="literal">-a---</span>            <span class="number">2023</span>/<span class="number">1</span>/<span class="number">3</span>    <span class="number">21</span>:<span class="number">30</span>         <span class="number">384581</span> junit<span class="literal">-4</span>.<span class="number">13.2</span>.jar</span><br><span class="line"><span class="literal">-a---</span>           <span class="number">2021</span>/<span class="number">2</span>/<span class="number">13</span>    <span class="number">17</span>:<span class="number">31</span>          <span class="number">11376</span> LICENSE<span class="literal">-junit</span>.txt</span><br></pre></td></tr></table></figure>
<p>解出来/org/junit和/junit两个目录下面都是class文件</p>
<p>因此实际上jar包可以理解为静态库,里面的class文件可以理解为可重定位目标模块</p>
<p>麻了麻了怎么用jar包,jar包如何自己运行,用到时候再看吧,全是答辩</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/impossible/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/impossible/">1</a><a class="page-number" href="/impossible/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/impossible/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/impossible/page/10/">10</a><a class="extend next" rel="next" href="/impossible/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
