<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","width":500,"display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="dustland">
<meta property="og:type" content="website">
<meta property="og:title" content="dustland">
<meta property="og:url" content="http://deutschball.github.io/impossible/page/7/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="dustland">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="dustball">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://deutschball.github.io/impossible/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/08/29/mermaid/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/29/mermaid/" class="post-title-link" itemprop="url">mermaid</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-29 00:00:00 / Modified: 10:39:40" itemprop="dateCreated datePublished" datetime="2022-08-29T00:00:00+08:00">2022-08-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mermaid制图"><a href="#mermaid制图" class="headerlink" title="mermaid制图"></a>mermaid制图</h1><h2 id="mermaid-in-typora"><a href="#mermaid-in-typora" class="headerlink" title="mermaid in typora"></a>mermaid in typora</h2><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220621095136061.png" alt="image-20220621095136061"></p>
<p>在代码块的代码类型处声明为<code>mermaid</code>就可以使用<code>mermaid</code>制图了</p>
<p><strong>代码块首行</strong><code>classDiagram</code>表明本代码块要绘制一个类图</p>
<blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220621105215969.png" alt="image-20220621105215969"></p>
</blockquote>
<h2 id="journey"><a href="#journey" class="headerlink" title="journey"></a>journey</h2><p>旅程图(或者说游记图,随便爱咋咋叫)</p>
<p>源代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">journey		#首行表明本图类型为游记</span><br><span class="line">    title 摆烂周记	#标题,整个图表只能有一个title,最终显示的时候以最后出现的title为准</span><br><span class="line">    section <span class="number">6.15</span><span class="number">-6.17</span>		<span class="meta">#section声明了一个章节,在下一个section之前的部分为该章节的组成</span></span><br><span class="line">    	上午摆烂 :<span class="number">5</span>		#章节组成用 事情:心情指数	表示,中间的冒号是解析器的判断标志.	心情从<span class="number">0</span>到<span class="number">6</span>(实际上范围更大)</span><br><span class="line">    下午摆烂 :<span class="number">6</span>		#缩进不会影响显示,但是规范起见还是缩进对齐		</span><br><span class="line">	section <span class="number">6.18</span></span><br><span class="line">    	上午摆烂 :<span class="number">4</span></span><br><span class="line">    	下午摆烂 :<span class="number">4</span></span><br><span class="line">    	事情貌似不太对劲 :<span class="number">3</span>		#一个章节下面可以有任意个部分</span><br><span class="line">        晚上继续摆烂 :<span class="number">5</span></span><br><span class="line">	section <span class="number">6.19</span></span><br><span class="line">        上午摆烂 :<span class="number">4</span></span><br><span class="line">    	下午摆烂 :<span class="number">5</span></span><br><span class="line">    section <span class="number">6.20</span></span><br><span class="line">        复习毛概 :<span class="number">1</span></span><br><span class="line">    	考毛概	:<span class="number">0</span></span><br><span class="line">    section <span class="number">6.21</span></span><br><span class="line">    	复习软概 :<span class="number">1</span></span><br><span class="line">    	背软概 :<span class="number">0</span></span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<p>效果图:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">journey		#首行表明本图类型为游记</span><br><span class="line">    title 摆烂周记	#标题,整个图表只能有一个title,最终显示的时候以最后出现的title为准</span><br><span class="line">    section 6.15-6.17		#section声明了一个章节,在下一个section之前的部分为该章节的组成</span><br><span class="line">    	上午摆烂 :5		#章节组成用 事情:心情指数	表示,中间的冒号是解析器的判断标志.	心情从0到6(实际上范围更大)</span><br><span class="line">    下午摆烂 :6		#缩进不会影响显示,但是规范起见还是缩进对齐		</span><br><span class="line">	section 6.18</span><br><span class="line">    	上午摆烂 :4</span><br><span class="line">    	下午摆烂 :4</span><br><span class="line">    	事情貌似不太对劲 :3		#一个章节下面可以有任意个部分</span><br><span class="line">        晚上继续摆烂 :5</span><br><span class="line">	section 6.19</span><br><span class="line">        上午摆烂 :4</span><br><span class="line">    	下午摆烂 :5</span><br><span class="line">    section 6.20</span><br><span class="line">        复习毛概 :1</span><br><span class="line">    	考毛概	:0</span><br><span class="line">    section 6.21</span><br><span class="line">    	复习软概 :1</span><br><span class="line">    	背软概 :0</span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<h2 id="flowchart"><a href="#flowchart" class="headerlink" title="flowchart"></a>flowchart</h2><p>流程图</p>
<h3 id="定义节点"><a href="#定义节点" class="headerlink" title="定义节点"></a>定义节点</h3><p>定义节点的格式:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">节点句柄&lt;节点内容&gt; %%尖括号表示节点类型</span><br></pre></td></tr></table></figure>

<p>节点句柄纯粹是为了下一次使用该节点的时候方便索引同一个节点,</p>
<p>节点类型有多种,比如</p>
<p>方形(缺省值,即只写节点句柄时默认使用的形状),圆角,菱形,平行四边形等等</p>
<blockquote>
<p>只写句柄的节点又叫做一次性节点,因为这时句柄还起节点内容的作用,不方便被再次索引</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR;</span><br><span class="line">	A(圆角节点) </span><br><span class="line">	B[方形节点]</span><br><span class="line">	C([跑道节点])</span><br><span class="line">    D[[子程序节点]]</span><br><span class="line">	E[(数据库节点)]</span><br><span class="line">	F((圆圆圈圈))</span><br><span class="line">    G&gt;旗帜节点]</span><br><span class="line">    H&#123;菱形判断框&#125;</span><br><span class="line">    I&#123;&#123;六边形节点&#125;&#125;</span><br><span class="line">    J[/平行四边形节点/]</span><br><span class="line">	K[\反平行四边形节点\]</span><br><span class="line">    L[/体形节点\]</span><br><span class="line">    M[\倒梯形节点/]</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">	A(圆角节点) </span><br><span class="line">	B[方形节点]</span><br><span class="line">	C([跑道节点])</span><br><span class="line">    D[[子程序节点]]</span><br><span class="line">	E[(数据库节点)]</span><br><span class="line">	F((圆圆圈圈))</span><br><span class="line">    G&gt;旗帜节点]</span><br><span class="line">    H&#123;菱形判断框&#125;</span><br><span class="line">    I&#123;&#123;六边形节点&#125;&#125;</span><br><span class="line">    J[/平行四边形节点/]</span><br><span class="line">	K[\反平行四边形节点\]</span><br><span class="line">    L[/体形节点\]</span><br><span class="line">    M[\倒梯形节点/]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h3><blockquote>
<p>类比CS Academy</p>
<p>学图论时,用过<a target="_blank" rel="noopener" href="https://csacademy.com/app/graph_editor/">CS Academy</a></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220621195316039.png" alt="image-20220621195316039"></p>
<p>规范的写法是在Node Count这一行给出节点数量n</p>
<p>然后接着在Graph Data的前n行分别给出每个节点的句柄</p>
<p>然后接下来的任意多行给出这几个节点的关系,</p>
<p>比如<code>1 2</code>就是在1和2节点之间连一条边,如果是directed有向图则方向从左向右,即<code>1-&gt;2</code></p>
<p>如果边有边权,则按照<code>A B dist</code>这种格式输入给定</p>
</blockquote>
<p>在mermaid中,使用方法和CS Academy类似</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">flowchart </span><br><span class="line">	<span class="title function_">A</span><span class="params">((<span class="number">0</span>))</span>%%首先声明一下节点句柄,类型,内容</span><br><span class="line">	<span class="title function_">B</span><span class="params">((<span class="number">1</span>))</span></span><br><span class="line">	<span class="title function_">C</span><span class="params">((<span class="number">2</span>))</span></span><br><span class="line">	<span class="title function_">D</span><span class="params">((<span class="number">3</span>))</span></span><br><span class="line">	<span class="title function_">E</span><span class="params">((<span class="number">4</span>))</span></span><br><span class="line">	<span class="title function_">F</span><span class="params">((<span class="number">5</span>))</span></span><br><span class="line">	A--10--&gt;C%%带有权值的有向边类型</span><br><span class="line">	A--5--&gt;E</span><br><span class="line">	B--11--&gt;C</span><br><span class="line">	C--18--&gt;E</span><br><span class="line">	F--20--&gt;A</span><br><span class="line">	D--15--&gt;F</span><br><span class="line">	A--5---&gt;F</span><br><span class="line">	</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">flowchart</span><br><span class="line">	A((0))</span><br><span class="line">	B((1))</span><br><span class="line">	C((2))</span><br><span class="line">	D((3))</span><br><span class="line">	E((4))</span><br><span class="line">	F((5))</span><br><span class="line">	A--10--&gt;C</span><br><span class="line">	A--5--&gt;E</span><br><span class="line">	B--11--&gt;C</span><br><span class="line">	C--18--&gt;E</span><br><span class="line">	F--20--&gt;A</span><br><span class="line">	D--15--&gt;F</span><br><span class="line">	A--5---&gt;F</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>边的长度和类型也是可以改变的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR		</span><br><span class="line">	I---J	%%中间的横杠越多,线越长,如果两个点之间有多条连线,此时多加横杠有可能不起作用</span><br><span class="line">	I--&gt;J</span><br><span class="line">	I--文本--&gt;J</span><br><span class="line">	I-.-&gt;J</span><br><span class="line">	I-.文本.-&gt;J</span><br><span class="line">	I ==粗线===J</span><br><span class="line">	I ==粗箭头线==&gt;J</span><br><span class="line">	<span class="number">1</span> &amp; <span class="number">2</span> &amp; <span class="number">3</span>--&gt; <span class="number">4</span> &amp; <span class="number">5</span></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR		</span><br><span class="line">	I---J</span><br><span class="line">	I--&gt;J</span><br><span class="line">	I--文本--&gt;J</span><br><span class="line">	I-.-&gt;J</span><br><span class="line">	I-.文本.-&gt;J</span><br><span class="line">	I ==粗线===J</span><br><span class="line">	I ==粗箭头线==&gt;J</span><br><span class="line">	1 &amp; 2 &amp; 3--&gt; 4 &amp; 5</span><br></pre></td></tr></table></figure>

<p>箭头也有多种类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    <span class="title function_">A</span><span class="params">((<span class="number">1</span>))</span></span><br><span class="line"> 	<span class="title function_">B</span><span class="params">((<span class="number">2</span>))</span></span><br><span class="line">    A ----o B	%%圈结尾</span><br><span class="line">    A ----x B	%%x结尾</span><br><span class="line">    A &lt;---&gt; B	%%双向箭头</span><br><span class="line">    A ----&gt; B	%%单项箭头</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    A((1))</span><br><span class="line"> 	B((2))</span><br><span class="line">    A ----o B	%%圈结尾</span><br><span class="line">    A ----x B	%%x结尾</span><br><span class="line">    A &lt;---&gt; B	%%双向箭头</span><br><span class="line">    A ----&gt; B	%%单项箭头</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p>声明子图用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subgraph	&lt;子图句柄&gt; &lt;[子图名]&gt;</span><br><span class="line">	...#中间的内容为子图</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">flowchart</span><br><span class="line">	<span class="title function_">A</span><span class="params">((<span class="number">0</span>))</span></span><br><span class="line">	<span class="title function_">B</span><span class="params">((<span class="number">1</span>))</span></span><br><span class="line">	</span><br><span class="line">	subgraph sub1 [点子图]</span><br><span class="line">		<span class="title function_">C</span><span class="params">((<span class="number">2</span>))</span></span><br><span class="line">		<span class="title function_">D</span><span class="params">((<span class="number">3</span>))</span></span><br><span class="line">	end</span><br><span class="line">	</span><br><span class="line">	<span class="title function_">E</span><span class="params">((<span class="number">4</span>))</span></span><br><span class="line">	<span class="title function_">F</span><span class="params">((<span class="number">5</span>))</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	A--10--&gt;C</span><br><span class="line">	</span><br><span class="line">	subgraph sub2 [边子图]</span><br><span class="line"></span><br><span class="line">		A--5--&gt;E</span><br><span class="line">	end</span><br><span class="line">	</span><br><span class="line">	B--11--&gt;C</span><br><span class="line">	C--18--&gt;E</span><br><span class="line">	F--20--&gt;A</span><br><span class="line">	D--15--&gt;F</span><br><span class="line">	A--5---&gt;F</span><br><span class="line">	</span><br><span class="line">	G---&gt;sub1		%%点指向子图</span><br><span class="line">	sub1--&gt;sub2		%%子图之间互相指</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">flowchart</span><br><span class="line"></span><br><span class="line">	A((0))</span><br><span class="line">	B((1))</span><br><span class="line">	</span><br><span class="line">	subgraph sub1 [点子图]</span><br><span class="line">		C((2))</span><br><span class="line">		D((3))</span><br><span class="line">	end</span><br><span class="line">	</span><br><span class="line">	E((4))</span><br><span class="line">	F((5))</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	A--10--&gt;C</span><br><span class="line">	</span><br><span class="line">	subgraph sub2 [边子图]</span><br><span class="line"></span><br><span class="line">		A--5--&gt;E</span><br><span class="line">	end</span><br><span class="line">	</span><br><span class="line">	B--11--&gt;C</span><br><span class="line">	C--18--&gt;E</span><br><span class="line">	F--20--&gt;A</span><br><span class="line">	D--15--&gt;F</span><br><span class="line">	A--5---&gt;F</span><br><span class="line">	</span><br><span class="line">	G---&gt;sub1		%%点指向子图</span><br><span class="line">	sub1--&gt;sub2		%%子图之间互相指</span><br></pre></td></tr></table></figure>

<p>子图也可以嵌套子图</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart</span><br><span class="line">	A %%声明三个节点</span><br><span class="line">	B</span><br><span class="line">	G</span><br><span class="line">	click B <span class="string">&quot;https://www.baidu.com/&quot;</span> <span class="string">&quot;linkage to baidu&quot;</span> %%给B节点上一个到百度的链接,点击跳转</span><br><span class="line">	click G <span class="string">&quot;http://www.github.com&quot;</span> <span class="string">&quot;linkage to github&quot;</span>	%%给G上一个到github的链接</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flowchart </span><br><span class="line">	A </span><br><span class="line">	B</span><br><span class="line">	G</span><br><span class="line">	click B &quot;https://www.baidu.com/&quot; &quot;linkage to baidu&quot;</span><br><span class="line">	click G &quot;http://www.github.com&quot; &quot;linkage to github&quot;</span><br></pre></td></tr></table></figure>

<h3 id="节点样式"><a href="#节点样式" class="headerlink" title="节点样式"></a>节点样式</h3><h4 id="css样式"><a href="#css样式" class="headerlink" title="css样式"></a>css样式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style &lt;节点句柄&gt; 键1:值1,键2:值2...</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    <span class="title function_">id1</span><span class="params">(Start)</span>--&gt;<span class="title function_">id2</span><span class="params">(End)</span></span><br><span class="line">    style id1 fill:#0A0,stroke:#ff4,stroke-width:16px</span><br><span class="line">    style id2 fill:<span class="meta">#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5</span></span><br></pre></td></tr></table></figure>

<p>实际上已经是层叠样式表css的范畴了</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>属性值</th>
</tr>
</thead>
<tbody><tr>
<td>fill</td>
<td>节点内容的底色</td>
</tr>
<tr>
<td>stroke</td>
<td>外边框颜色</td>
</tr>
<tr>
<td>stroke-width</td>
<td>外边框宽度,单位像素</td>
</tr>
<tr>
<td>color</td>
<td>节点内容字体颜色</td>
</tr>
<tr>
<td>stroke-dasharray</td>
<td>外边框的边框虚实线</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    id1(Start)--&gt;id2(End)</span><br><span class="line">    style id1 fill:#0A0,stroke:#ff4,stroke-width:16px</span><br><span class="line">    style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5</span><br></pre></td></tr></table></figure>



<h4 id="样式类"><a href="#样式类" class="headerlink" title="样式类:"></a>样式类:</h4><p>相当于设定一个固定的样式模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classDef &lt;样式类名&gt; 键1:值1,键2:值2...;</span><br></pre></td></tr></table></figure>

<p>使用时将该模板应用于某个节点(子图也可以)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class &lt;节点索引1&gt;&lt;节点索引2&gt;... &lt;样式类名&gt;;</span><br><span class="line">or</span><br><span class="line">&lt;节点索引&gt;:::&lt;样式类名&gt;  %%注意中间有四个冒号</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart</span><br><span class="line">	classDef 黄圈绿底黑字 fill:#<span class="number">0</span>A0,stroke:#ff4,stroke-width:<span class="number">16</span>px;%%声明一个样式类型</span><br><span class="line">	A((节点A));%%声明一个圆圈节点</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">A</span> 黄圈绿底黑字;</span>%%将刚才的样式类型应用于A</span><br><span class="line">	B[(数据库)];</span><br><span class="line">	classDef 数据库专用 fill:<span class="meta">#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5;</span></span><br><span class="line">	B:::数据库专用</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart</span><br><span class="line">	classDef 黄圈绿底黑字 fill:#0A0,stroke:#ff4,stroke-width:16px;%%声明一个样式类型</span><br><span class="line">	A((节点A));%%声明一个圆圈节点</span><br><span class="line">	class A 黄圈绿底黑字;%%将刚才的样式类型应用于A</span><br><span class="line">	B[(数据库)];</span><br><span class="line">	classDef 数据库专用 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5;</span><br><span class="line">	B:::数据库专用</span><br></pre></td></tr></table></figure>

<p>甚至多套上几圈可以造一个靶</p>
<h4 id="默认类"><a href="#默认类" class="headerlink" title="默认类"></a>默认类</h4><p>如果声明一个叫做<code>default</code>的样式类,则所有没有手动分配样式类的节点都会自动使用default样式,子图也是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart</span><br><span class="line">	classDef <span class="keyword">default</span> fill:#<span class="number">0</span>A0,stroke:#ff4,stroke-width:<span class="number">16</span>px;%%声明一个样式类型</span><br><span class="line">	A(( ))</span><br><span class="line">	subgraph sub [子图]</span><br><span class="line">		B((dot))</span><br><span class="line">	end</span><br><span class="line">	C[/绿的/]</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart</span><br><span class="line">	classDef default fill:#0A0,stroke:#ff4,stroke-width:16px;%%声明一个样式类型</span><br><span class="line">	A(( ))</span><br><span class="line">	subgraph sub [子图]</span><br><span class="line">		B((dot))</span><br><span class="line">	end</span><br><span class="line">	C[/绿的/]</span><br></pre></td></tr></table></figure>

<h4 id="fontawesome"><a href="#fontawesome" class="headerlink" title="fontawesome"></a>fontawesome</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fa:#&lt;图表类名&gt;#</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">     E[<span class="string">&quot;fa:fa-ge&quot;</span> Imperial March!]</span><br><span class="line">     R[<span class="string">&quot;fa:fa-ra may the force be with you!&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>星战的帝国和叛军竟然也被收录进了字体库,pornhub都没有这荣幸(可能是它图标太长了)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">     E[&quot;fa:fa-ge&quot; Imperial March!]</span><br><span class="line">     R[&quot;fa:fa-ra may the force be with you!&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">	L[&quot;fa:fa-linux&quot; linux]</span><br><span class="line">	W[&quot;fa:fa-windows&quot; windows]</span><br></pre></td></tr></table></figure>

<h2 id="erDiagram"><a href="#erDiagram" class="headerlink" title="erDiagram"></a>erDiagram</h2><h3 id="信息世界基本概念"><a href="#信息世界基本概念" class="headerlink" title="信息世界基本概念"></a>信息世界基本概念</h3><p>实体关系模型:(ER模型)由实体类型及其之间的关系组成</p>
<p>实体:客观存在并且可相互区分的事物</p>
<blockquote>
<p>比如具体的人,或者抽象的一次订货</p>
</blockquote>
<p>属性:实体的某一特性</p>
<blockquote>
<p>比如人的年龄,一次订货中的订货数量</p>
<p>比如学生,学生的姓名学号年龄等都是学生实体的属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">erDiagram</span><br><span class="line">STUDENT&#123;</span><br><span class="line">	string name</span><br><span class="line">	int ID</span><br><span class="line">	char gender</span><br><span class="line">	int grade</span><br><span class="line">	int class</span><br><span class="line">	string TEL</span><br><span class="line">	int age</span><br><span class="line">&#125;	</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</blockquote>
<p>码:(key,键):唯一标识实体的属性集</p>
<blockquote>
<p>比如人的学号,一次订货的订单号</p>
</blockquote>
<p>实体型:用实体名及其属性名集合来抽象和刻画同类实体</p>
<blockquote>
<p>比如 用户(用户名,密码,VIP等级,账号等级)</p>
</blockquote>
<p>实体集:同一类型实体的集合</p>
<blockquote>
<p>比如全体用户</p>
</blockquote>
<p>联系:</p>
<p>实体内部联系:一个实体的不同属性之间的关系</p>
<p>实体间联系:不同实体集之间的联系</p>
<h3 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h3><p>Entity-Relationship digram</p>
<p>用来描述现实世界的概念模型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">erDiagram</span><br><span class="line">    CUSTOMER ||--o&#123; ORDER : places</span><br><span class="line">    ORDER ||--|&#123; LINE-ITEM : contains</span><br><span class="line">    CUSTOMER &#125;|..|&#123; DELIVERY-ADDRESS : uses</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>实体名约定俗成要大写</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;first-entity&gt; [&lt;relationship&gt; &lt;second-entity&gt; : &lt;relationship-label&gt;]</span><br></pre></td></tr></table></figure>

<p>比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROPERTY ||--|&#123; ROOM : contains</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">erDiagram</span><br><span class="line">PROPERTY ||--|&#123; ROOM : contains</span><br></pre></td></tr></table></figure>

<p>mermaid将first-entity和second-entity都画成矩形框,表示实体,框里是实体名</p>
<p>实体关系用<code>&lt;relationship&gt; </code>指定,在图上表现为关系连线上的字</p>
<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>这里的关系指的是ER图中实体间的外关系,不是一个实体的不同属性的内关系</p>
<p>传统的ER图用菱形框表示关系</p>
<p>比如这样表示学生和选课的多对多关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR;</span><br><span class="line">	S[学生]</span><br><span class="line">	C[课程]</span><br><span class="line">	R&#123;选课&#125;</span><br><span class="line">	S --n--- R --m--- C</span><br></pre></td></tr></table></figure>

<p>在mermaid ER图中,不再使用菱形表示关系,而是用鱼尾纹连线</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;first-entity&gt; [&lt;relationship&gt; &lt;second-entity&gt; : &lt;relationship-label&gt;]</span><br></pre></td></tr></table></figure>

<p>这里relationship就是关系,相当于传统模型的菱形框,</p>
<p>relationship-label是关系描述,相当于原传统模型菱形框中的文字,如果多于一个单词则整个字符串用双引号包括,如果空则双引号空</p>
<p>relationship可以细分成三部分,第一个实体相对于第二个实体的数量,第二个实体相对于第一个实体的数量,是否是子关系</p>
<p>关于数量关系</p>
<table>
<thead>
<tr>
<th>Value (left)</th>
<th>Value (right)</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>&#96;</td>
<td>o&#96;</td>
<td align="left">&#96;o</td>
</tr>
<tr>
<td>&#96;</td>
<td></td>
<td align="left">&#96;</td>
</tr>
<tr>
<td><code>&#125;o</code></td>
<td><code>o&#123;</code></td>
<td align="left">Zero or more (no upper limit)</td>
</tr>
<tr>
<td>&#96;}</td>
<td>&#96;</td>
<td align="left">&#96;</td>
</tr>
</tbody></table>
<p>比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A||--|&#123;B</span><br></pre></td></tr></table></figure>

<p>这就表示A对B是一对多关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">erDiagram</span><br><span class="line">CAR &#125;|--|&#123; DRIVER : DRIVE</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">erDiagram</span><br><span class="line">CAR &#125;|--|&#123; DRIVER : DRIVE</span><br></pre></td></tr></table></figure>

<p>这个图就可以翻译为,一辆车可以被不同司机驾驶,一个司机可以驾驶不同车辆</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">erDiagram</span><br><span class="line">DRIVER ||--|&#123; CAR : possess</span><br></pre></td></tr></table></figure>

<p>这个图就可以翻译为,一个司机可以拥有多辆车,但是一辆车只能有一个主人</p>
<p>如果在一个关系中,一个实体必须依附于其他实体才能存在,则这两个实体之间需要用实线连接</p>
<p>如果在一个关系中,两个实体可以相互独立存在,则用虚线连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">erDiagram</span><br><span class="line">CAR &#125;|--|&#123; DRIVER : DRIVE</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">erDiagram</span><br><span class="line">CAR &#125;|--|&#123; DRIVER : DRIVE</span><br></pre></td></tr></table></figure>

<p>没有驾驶员车也是存在的,车报废了驾驶员也是活着的</p>
<p>但是对于驾驶证,没有驾驶员就没有他的证,没有证人就不是驾驶员</p>
<p>一个驾驶员可以有多个驾驶证,A证B证C证</p>
<p>一个普通人(比驾驶员限制宽松)就不一定需要有驾驶证</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">erDiagram</span><br><span class="line">DRIVER ||--|&#123; LICENSE : have</span><br><span class="line">PERSON |o..o&#123; LICENSE : have</span><br></pre></td></tr></table></figure>



<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>传统的实体图,实体的属性使用椭圆表示的,用一根线连接到实体上</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/v2-8826929ae43cabf4f2525cc9392d719a_1440w.jpg" alt="img"></p>
<p>而mermaid画的实体,规定属性的方式类似于类图</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">erDiagram</span><br><span class="line">STUDENT &#123;</span><br><span class="line">	<span class="built_in">string</span> name</span><br><span class="line">	<span class="type">int</span> ID</span><br><span class="line">	<span class="type">char</span> gender</span><br><span class="line">	<span class="type">int</span> grade</span><br><span class="line">	<span class="type">int</span> <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class">	<span class="title">string</span> <span class="title">TEL</span></span></span><br><span class="line"><span class="class">	<span class="title">int</span> <span class="title">age</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">erDiagram</span><br><span class="line">LICENSE&#123;</span><br><span class="line">	string LicenseID</span><br><span class="line">	string LicenseIssueDate</span><br><span class="line">	string DriverName</span><br><span class="line">	string DriverID</span><br><span class="line">	image Driveravatar</span><br><span class="line">&#125;</span><br><span class="line">DRIVER ||--|&#123; LICENSE : have</span><br><span class="line">PERSON |o..o&#123; LICENSE : have</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/08/27/x86-%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/27/x86-%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">x86汇编语言 chapter 5 主引导记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-27 17:23:00" itemprop="dateCreated datePublished" datetime="2022-08-27T17:23:00+08:00">2022-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-30 00:31:02" itemprop="dateModified" datetime="2022-08-30T00:31:02+08:00">2022-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="主引导记录"><a href="#主引导记录" class="headerlink" title="主引导记录"></a>主引导记录</h1><p>书上借助主引导扇区的例子,讲解了实模式下分段机制,显存的使用等等基本原理</p>
<p>为啥要借助主引导扇区呢?</p>
<p>因为虚拟机开机之后BIOS自动将磁盘的前512字节作为主引导记录装载进入内存的0x7c00位置并从0x7c00处开始执行.</p>
<p>我们的代码直接写到主引导记录中就可以顺理成章地执行了</p>
<h2 id="自举过程"><a href="#自举过程" class="headerlink" title="自举过程"></a>自举过程</h2><p>计算机上电之后,如果设置硬盘位首选的启动设备,则ROM-BIOS将视图读取硬盘的逻辑0号扇区,即物理上的0面0道1扇区.这里就是主引导扇区的位置</p>
<p>ROM-BIOS会把这个扇区的512字节搬到内存的0x7c00处,后面就是对内存中的拷贝进行的一系列操作</p>
<p>ROM-BIOS检查这512字节的最后两个字节是否是0x55,0xAA,这是主引导扇区魔数</p>
<p>如果主引导扇区有效则跳转打0x7c00继续执行</p>
<p>主引导扇区的内容一般是检测操作系统在硬盘上的位置,把grub代码加载道内存,跳转grub举起操作系统来</p>
<h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><h3 id="显卡与显示器"><a href="#显卡与显示器" class="headerlink" title="显卡与显示器"></a>显卡与显示器</h3><p>显卡负责给显示器提供内容</p>
<p>显示器负责显式</p>
<p>显示器接到显卡上,显卡接到主板上</p>
<p>显卡控制显示器的最小单位是像素,每个像素点需要24比特存储颜色(RGB各8比特).显卡使用字节的显式存储器(显存,video RAM,VRAM)存放像素点的颜色.要显式啥就把啥信息放到显存里.</p>
<p>显示器是一个二维平面,儿显存就是一个内存条子的存储器,它是线性的,这就涉及到一维数组到二维数组的映射关系了</p>
<p>显存相当于一个缓冲区,CPU把想要输出到屏幕的东西放到显存里.显卡周期性地从显存拿出来按顺序显式到屏幕上.</p>
<h3 id="显卡工作模式"><a href="#显卡工作模式" class="headerlink" title="显卡工作模式"></a>显卡工作模式</h3><p>显卡的工作模式分为文本模式和图形模式</p>
<p>图形模式下操作的确实是像素点</p>
<p>文本模式下只需要在显存中写入指定的字符的ASCII码,显卡内部经过字符发生器,就可以翻译成一些像素点的组合输出到屏幕上,也就是代替人干了计算每个像素点位置的事,人只需要指定第几行第几列写哪个字符就可以了</p>
<p>一般个人电脑显卡加电自检之后都会把自己初始化为80×25的文本模式</p>
<p>每行可以显示80个字符,一共可以显示25行.满屏是2000个字符</p>
<h3 id="端口映射内存"><a href="#端口映射内存" class="headerlink" title="端口映射内存"></a>端口映射内存</h3><p>如果正儿八经地论起来,除了内存条子,其他的设备都是IO外设,CPU和内存条子打交道的速度得是外设的成千上万倍,如果想要实现细致流畅的游戏画面体验,经过IO访问显存是办不到的.于是把显存也和内存统一编址,这就绕开了IO直接让CPU像访问内存一样访问显存.</p>
<p>对于8086来说,其CPU宽20位,可以寻址1M的内存空间0x0到0x9FFFF,</p>
<p>那从0xA0000到0xFFFFF就不是内存条子的事了,比如</p>
<p>0xB8000到0xBFFFF这32KB的地址空间映射给显存</p>
<p>0xF0000到0xFFFFF这64K的地址空间映射给ROM-BIOS</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220825153008702.png" alt="image-20220825153008702"></p>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>显存入乡随俗,怎么访问内存就得怎么访问显存</p>
<p>访问内存使用段地址:偏移量,</p>
<p>物理地址&#x3D;段地址×16+偏移量</p>
<p>那么如果要访问显存,就得根据显存的起始地址设置段地址,由于显存起始地址是0xB8000,因此段地址就是0xB800,寻址的时候CPU会自动把0xB800乘16的</p>
<p>怎样让段寄存器等于0xB800呢?</p>
<p><code>mov es,0xB800</code>这样写吗?不可以,Intel的处理器规定不允许将立即数传递给段寄存器,必须使用通用寄存器或者内存单元中转一下,也就是说</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,<span class="number">0xb800</span>                 ;指向文本模式的显示缓冲区</span><br><span class="line">mov es,ax</span><br></pre></td></tr></table></figure>



<h3 id="字符模式下一个表示字符"><a href="#字符模式下一个表示字符" class="headerlink" title="字符模式下一个表示字符"></a>字符模式下一个表示字符</h3><p>字符模式下每个字符需要占据连续的两个字节,低字节是该字符的ASCII代码,高字节是该字符的颜色特征</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220825162813158.png" alt="image-20220825162813158"></p>
<p>比如这里0xB8000开始的连续两个字节,</p>
<p>低字节0x48是’H’的ASCII码,</p>
<p>高字节0x07&#x3D;00000111B表示黑背景色不闪烁,白前景色</p>
<h3 id="显示字符"><a href="#显示字符" class="headerlink" title="显示字符"></a>显示字符</h3><p>例子中想要显示一串字符串”Label offset:”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">      mov ax,<span class="number">0xb800</span>                 <span class="comment">//es段设置为显存地址起始位置</span></span><br><span class="line">      mov es,ax	</span><br><span class="line">mov byte [es:<span class="number">0x00</span>],<span class="string">&#x27;L&#x27;</span></span><br><span class="line">      mov byte [es:<span class="number">0x01</span>],<span class="number">0x07</span></span><br><span class="line">      mov byte [es:<span class="number">0x02</span>],<span class="string">&#x27;a&#x27;</span></span><br><span class="line">      mov byte [es:<span class="number">0x03</span>],<span class="number">0x07</span></span><br><span class="line">      mov byte [es:<span class="number">0x04</span>],<span class="string">&#x27;b&#x27;</span></span><br><span class="line">      mov byte [es:<span class="number">0x05</span>],<span class="number">0x07</span></span><br><span class="line">      mov byte [es:<span class="number">0x06</span>],<span class="string">&#x27;e&#x27;</span></span><br><span class="line">      mov byte [es:<span class="number">0x07</span>],<span class="number">0x07</span></span><br><span class="line">      mov byte [es:<span class="number">0x08</span>],<span class="string">&#x27;l&#x27;</span></span><br><span class="line">      mov byte [es:<span class="number">0x09</span>],<span class="number">0x07</span></span><br><span class="line">      mov byte [es:<span class="number">0x0a</span>],<span class="string">&#x27; &#x27;</span></span><br><span class="line">      mov byte [es:<span class="number">0x0b</span>],<span class="number">0x07</span></span><br><span class="line">      mov byte [es:<span class="number">0x0c</span>],<span class="string">&quot;o&quot;</span></span><br><span class="line">      mov byte [es:<span class="number">0x0d</span>],<span class="number">0x07</span></span><br><span class="line">      mov byte [es:<span class="number">0x0e</span>],<span class="string">&#x27;f&#x27;</span></span><br><span class="line">      mov byte [es:<span class="number">0x0f</span>],<span class="number">0x07</span></span><br><span class="line">      mov byte [es:<span class="number">0x10</span>],<span class="string">&#x27;f&#x27;</span></span><br><span class="line">      mov byte [es:<span class="number">0x11</span>],<span class="number">0x07</span></span><br><span class="line">      mov byte [es:<span class="number">0x12</span>],<span class="string">&#x27;s&#x27;</span></span><br><span class="line">      mov byte [es:<span class="number">0x13</span>],<span class="number">0x07</span></span><br><span class="line">      mov byte [es:<span class="number">0x14</span>],<span class="string">&#x27;e&#x27;</span></span><br><span class="line">      mov byte [es:<span class="number">0x15</span>],<span class="number">0x07</span></span><br><span class="line">      mov byte [es:<span class="number">0x16</span>],<span class="string">&#x27;t&#x27;</span></span><br><span class="line">      mov byte [es:<span class="number">0x17</span>],<span class="number">0x07</span></span><br><span class="line">      mov byte [es:<span class="number">0x18</span>],<span class="string">&#x27;:&#x27;</span></span><br><span class="line">      mov byte [es:<span class="number">0x19</span>],<span class="number">0x07</span></span><br></pre></td></tr></table></figure>

<p>每两个相邻字节的低字节放字符ASCII代码,高字节调制颜色,都是不闪烁的黑背景,白前景</p>
<p>寻址的时候使用的是<code>[es:0x00]</code>,转换成物理地址就是</p>
<p><code>es*16+0x00</code>,为啥要写es呢?因为段寄存器默认是ds,这里需要段超越前缀指定使用es段</p>
<p>而es&#x3D;0x8b00,乘以16之后恰好就是显存映射地址的起始位置</p>
<p>用byte关键字来修饰操作数的范围</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov byte [es:<span class="number">0x00</span>],<span class="string">&#x27;L&#x27;</span></span><br></pre></td></tr></table></figure>

<p>意思是’L’顶多占用一个字节,不能再多了,这条指令只会把0x4C放到es:00上</p>
<blockquote>
<p>如果这样写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov word [es:0x00],&#x27;L&#x27;</span><br></pre></td></tr></table></figure>

<p>则把0x4C放到es:0x00,把0x00放到es:0x01</p>
</blockquote>
<p>如果是把寄存器的值放到内存上则不用byte或者word修饰操作数的范围,因为寄存器已经自带宽度了</p>
<h2 id="指令地址"><a href="#指令地址" class="headerlink" title="指令地址"></a>指令地址</h2><h3 id="汇编地址"><a href="#汇编地址" class="headerlink" title="汇编地址"></a>汇编地址</h3><p>前面字句过程中也已经提到过,BIOS会把MBR这个512个字节放到内存条的0x7c00上.也就是说代码是从0x7c00开始的</p>
<blockquote>
<p>刚才显存扯了一大堆,但是都是相当于往数据段放东西,这个数据段位于0xB8000</p>
</blockquote>
<p>汇编地址:</p>
<p>编译器会把0x7c00开始的MBR代码作为一个独立的段处理</p>
<p>这样每条指令相对于段地址都有一个汇编地址(段内),在lst文件中可以看到这个汇编地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 行号 段内偏移 指令								汇编                                    </span><br><span class="line"> <span class="number">6</span> <span class="number">00000000</span> B800B8                           mov ax,<span class="number">0xb800</span>                 ;指向文本模式的显示缓冲区</span><br><span class="line"> <span class="number">7</span> <span class="number">00000003</span> <span class="number">8</span>EC0                             mov es,ax</span><br><span class="line"> <span class="number">8</span>                                  </span><br><span class="line"> <span class="number">9</span>                                           ;以下显示字符串<span class="string">&quot;Label offset:&quot;</span></span><br><span class="line"><span class="number">10</span> <span class="number">00000005</span> <span class="number">26</span>C60600004C                     mov byte [es:<span class="number">0x00</span>],<span class="string">&#x27;L&#x27;</span></span><br><span class="line"><span class="number">11</span> <span class="number">0000000B</span> <span class="number">26</span>C606010007                     mov byte [es:<span class="number">0x01</span>],<span class="number">0x07</span></span><br><span class="line"><span class="number">12</span> <span class="number">00000011</span> <span class="number">26</span>C606020061                     mov byte [es:<span class="number">0x02</span>],<span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<p>第一条有意义的指令是在第6行,段内偏移量为0,指令内容是0xB800B8,翻译成汇编语言就是<code>mov ax,0xb800</code>,由于这条指令长3字节,因此可以计算得到下一条指令的段内偏移量就是3</p>
<p>第七行指令的段内偏移量就是3</p>
<h3 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h3><p>如果要在汇编语言中写出跳转功能,就得从一个地址转到另一个地址.</p>
<p>怎么指定目标地址呢?让人手工计算目标地址然后写到jmp后面吗?显然人工计算指令地址不显示,比如一段千八行的汇编语言,有好多指令都是跳转或者调用指令,现在第一行的指令发现错了要改,假设原来两个字节的指令改成了一个字节,那么后面的所有指令地址就都减1,这就需要所有的跳转和调用指令重定位.让人手工一行一行改太慢了</p>
<p>于是就发明了标号这种东西,类似于一个变量符号,作用是记录一个地址,编译器会自动计算该标号的地址,在生成二进制码的时候自动把标号翻译成地址,根宏定义展开一样</p>
<p>比如主引导记录中有这么一句:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infi: jmp near infi                 ;无限循环</span><br></pre></td></tr></table></figure>

<p>infi标号的这条指令要跳转到infi标号处的指令,也就是自己跳转到自己的开始,这就形成了无线循环</p>
<p>标号还可以直接写到汇编指令里:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dividnd dw 0x3f0</span><br><span class="line">divisor db 0x3f</span><br><span class="line">mov ax,[dividnd]</span><br><span class="line">div byte [divisor]</span><br></pre></td></tr></table></figure>

<p>这里dividnd标号是0x3f0的地址,divisor是0x3f的地址</p>
<p>在编译时就像宏定义展开一样,mov ax,[dividnd]这里的标号就会自动转化成地址</p>
<h2 id="声明并初始化数据"><a href="#声明并初始化数据" class="headerlink" title="声明并初始化数据"></a>声明并初始化数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number db <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这里number是标号,db是定义字节的伪指令,后面定义了五个字节,都初始化为0,相邻两个字节之间用逗号隔开.6</p>
<blockquote>
<p>这里定义的五个字节就在当前代码段中</p>
<p>但是标注的做法应该是代码数据分离,数据专门放在数据段中,使用段超越方法寻址</p>
<p>byte [ds:00]就表示数据段的最开始的字节</p>
</blockquote>
<p>意思是从number开始的五个字节都是0</p>
<p>dw声明字,dd声明双字,dq声明四字</p>
<p>db,dw,dd,dq都是伪指令,当编译完成时就找不到影子了</p>
<blockquote>
<p>编译完成后的样子,就是5个0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> <span class="number">0000012</span>E <span class="number">0000000000</span>                number db <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>用db声明的变量就必须在字节大小范围内,最小是0x00,最大是0xFF,如果比这还大就会截断高位</p>
<p>比如db 0xFF00,编译之后保留低字节0x00</p>
<h2 id="段超越前缀"><a href="#段超越前缀" class="headerlink" title="段超越前缀"></a>段超越前缀</h2><p>如果这样写mov al,[0x00]</p>
<p>意思是把内存中0x00位置的数据搬到al寄存器中,问题是,这个0x00是相对于哪个段的偏移量呢?</p>
<p>DS?CS?</p>
<p>默认的数据段是DS,因此如果不指明段超越前缀,就是访问的数据段</p>
<p>但是如果要访问ES段寄存器指向的段,应该怎么写呢?</p>
<p>mov al,[es:0x00]</p>
<p>这里es:就是段超越前缀</p>
<h2 id="除法指令"><a href="#除法指令" class="headerlink" title="除法指令"></a>除法指令</h2><p>除法指令div只有一个操作数作为除数</p>
<p>被除数默认是AX寄存器</p>
<p>8086允许两种类型的整数除法,</p>
<p>其一是16位被除数除以8位除数由于8086的寄存器宽度为8,因此一个AX就可以放开被除数.除完了商放到AL,余数放到AH</p>
<p>其二是32位被除数除以16位除数</p>
<p>此时除数刚好占用一个寄存器,但是被除数就需要放到两个寄存器中了,即DX放高16位,AX放低16位,除完了商放在AX,余数放在DX</p>
<p>处理器怎么区分两种除法应该用哪种呢?看除数的格式,如果除数是一个字寄存器,比如div cx,就得是32位除被数除以16位除数.如果是div cl,就是16位被除数除以8位除数</p>
<p>在主引导扇区代码的第37到47行是这样写的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax,number ;这里number是一个地址标号</span><br><span class="line">mov bx,10	;被除数置为10</span><br><span class="line"></span><br><span class="line">mov cx,cs		</span><br><span class="line">mov ds,cx		;ds寄存器指向当前cx寄存器的段地址</span><br><span class="line"></span><br><span class="line">mov dx,0	;被除数高位置0</span><br><span class="line">div bx	;DX:AX/BX</span><br><span class="line">       </span><br><span class="line">mov [0x7c00+number+0x00],dl		;dl放的是余数的低字节,也就是number这个地址的个位数字,放到0x7c00+number+0x00这个位置上</span><br></pre></td></tr></table></figure>





<p>主引导记录中一直重复该过程,意思是十进制分解被除数number标号地址的各位,放到0x7c00+number开始的五个字节上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mov ax,number                 ;?????number???????</span><br><span class="line">mov bx,<span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov cx,cs</span><br><span class="line">mov ds,cx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov dx,<span class="number">0</span></span><br><span class="line">div bx</span><br><span class="line">mov [<span class="number">0x7c00</span>+number+<span class="number">0x00</span>],dl   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xor dx,dx</span><br><span class="line">div bx</span><br><span class="line">mov [<span class="number">0x7c00</span>+number+<span class="number">0x01</span>],dl  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xor dx,dx</span><br><span class="line">div bx</span><br><span class="line">mov [<span class="number">0x7c00</span>+number+<span class="number">0x02</span>],dl   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xor dx,dx</span><br><span class="line">div bx</span><br><span class="line">mov [<span class="number">0x7c00</span>+number+<span class="number">0x03</span>],dl   </span><br><span class="line"></span><br><span class="line">;????位??????? </span><br><span class="line">xor dx,dx</span><br><span class="line">div bx</span><br><span class="line">mov [<span class="number">0x7c00</span>+number+<span class="number">0x04</span>],dl  </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>mov [0x7c00+number+0x00],dl</code>这就很诡异了,0x7c00是怎么来的?</p>
<h3 id="偏移量换算"><a href="#偏移量换算" class="headerlink" title="偏移量换算"></a>偏移量换算</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [<span class="number">0x7c00</span>+number+<span class="number">0x00</span>],dl</span><br></pre></td></tr></table></figure>

<p>这里多了一个0x7c00,而不是直接mov [number+0x00],dl</p>
<p>这是因为,主引导扇区会被bios装载到内存的0x7c00处</p>
<p>此时CS&#x3D;0x0000,IP&#x3D;0x7c00</p>
<p>number是相对于mbr.asm这个文件的偏移量12E.</p>
<p>如果写mov [number+0x00],dl.实际上就是mov [0x12E],dl</p>
<p>放到了内存条上的0x12E位置,直接出了主引导区了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220827151725554.png" alt="image-20220827151725554"></p>
<p>mbr.asm程序自始至终没有修改过cs的值,那么这个值就是BIOS设置的,一直是0x0000不变</p>
<h2 id="显示分解出来的各个数位"><a href="#显示分解出来的各个数位" class="headerlink" title="显示分解出来的各个数位"></a>显示分解出来的各个数位</h2><p>分解的各个数位按照个十百千万的顺序放到0x7c00+number+0x00到0x7c00+number+0x04的五个字节中</p>
<p>对于万位上的数字,mbr程序是这样写的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,[<span class="number">0x7c00</span>+number+<span class="number">0x04</span>]</span><br><span class="line">add al,<span class="number">0x30</span></span><br><span class="line">mov [es:<span class="number">0x1a</span>],al</span><br><span class="line">mov byte [es:<span class="number">0x1b</span>],<span class="number">0x04</span></span><br></pre></td></tr></table></figure>

<p>把万位数字拿出来放到al里,加上0x30转化成这个数字的ASCII码,然后放到es:0x1a位置,由于es早已设置为0xb800,即显存的起始位置,因此es:0x1a就是第一行的第1a个字符</p>
<p>在es:0x1b位置设置的是该字符的显示样式,设置为0x04意思是无背景不闪烁,红色前景</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220825162813158.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mov al,[0x7c00+number+0x04]</span><br><span class="line">add al,0x30</span><br><span class="line">mov [es:0x1a],al</span><br><span class="line">mov byte [es:0x1b],0x04</span><br><span class="line"></span><br><span class="line">mov al,[0x7c00+number+0x03]</span><br><span class="line">add al,0x30</span><br><span class="line">mov [es:0x1c],al</span><br><span class="line">mov byte [es:0x1d],0x04</span><br><span class="line"></span><br><span class="line">mov al,[0x7c00+number+0x02]</span><br><span class="line">add al,0x30</span><br><span class="line">mov [es:0x1e],al</span><br><span class="line">mov byte [es:0x1f],0x04</span><br><span class="line"></span><br><span class="line">mov al,[0x7c00+number+0x01]</span><br><span class="line">add al,0x30</span><br><span class="line">mov [es:0x20],al</span><br><span class="line">mov byte [es:0x21],0x04</span><br><span class="line"></span><br><span class="line">mov al,[0x7c00+number+0x00]</span><br><span class="line">add al,0x30</span><br><span class="line">mov [es:0x22],al</span><br><span class="line">mov byte [es:0x23],0x04</span><br><span class="line"></span><br><span class="line">mov byte [es:0x24],&#x27;D&#x27;</span><br><span class="line">mov byte [es:0x25],0x07</span><br></pre></td></tr></table></figure>

<p>最后另外放了一个黑底不闪烁白字’D’,意思是十进制的缩写(Decimal)</p>
<p>因此打印效果为</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220827154928612.png" alt="image-20220827154928612"></p>
<h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>在主引导记录中打印了number的数位分解之后,立刻进入无线循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infi: jmp near infi  </span><br></pre></td></tr></table></figure>

<p>为啥要这样写呢?</p>
<p>因为如果不写无线循环,那么虚拟机就直接寄了,主引导记录并没有抛砖引玉地加载操作系统,这512个字节跑完之后,后面就全是0了,不存在指令了</p>
<h3 id="段内跳转near"><a href="#段内跳转near" class="headerlink" title="段内跳转near"></a>段内跳转near</h3><p>jmp near意思是跳转到当前段内的一个地址,也就是不改变CS段寄存器地址,只改变ip的地址,因此操作数只是infi这个标号,不需要cs:infi指定跳转到哪个段的infi</p>
<h2 id="填充与魔数"><a href="#填充与魔数" class="headerlink" title="填充与魔数"></a>填充与魔数</h2><p>前面的代码和数据都写完了也远远达不到512个字节,主引导记录需要最后两个字符是0xAA55才有效.因此中间的字节需要说一些废话填充</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">times <span class="number">203</span> db <span class="number">0</span></span><br><span class="line">          db <span class="number">0x55</span>,<span class="number">0xaa</span></span><br></pre></td></tr></table></figure>

<p>连着定义了203个字节都置0,最后两个字节是0xAA55魔数</p>
<p>到此主引导记录才有效</p>
<h2 id="Bochs调试"><a href="#Bochs调试" class="headerlink" title="Bochs调试"></a>Bochs调试</h2><p>之前我们一直使用的都是virtualBox虚拟机,只能运行不能调试,唯一能够调试运行的虚拟机就是Bochs</p>
<h3 id="bochs配置"><a href="#bochs配置" class="headerlink" title="bochs配置"></a>bochs配置</h3><p>将主引导记录写入虚拟磁盘vhd文件之后启动bochs,需要在开始菜单上进行一些设置</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220827161343625.png" alt="image-20220827161343625"></p>
<h4 id="Disk-Boot"><a href="#Disk-Boot" class="headerlink" title="Disk&amp;Boot"></a>Disk&amp;Boot</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220827161537279.png" alt="image-20220827161537279"></p>
<p>都2202年了,不会还有人用软盘吧</p>
<p>ATA,硬盘接口标准,PATA是以前的IDE接口,SATA是当前使用的接口标准</p>
<p>每个计算机有多个ATA通道,允许加多块磁盘</p>
<p>ATA channel 0 是必须的,将nobody.vhd挂到ATA channel0上即可</p>
<h4 id="ATA-channel-0"><a href="#ATA-channel-0" class="headerlink" title="ATA channel 0"></a>ATA channel 0</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220827162047232.png" alt="image-20220827162047232"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220827162545217.png" alt="image-20220827162545217"></p>
<p>这里Cylinders,Heads等参数不是乱写的,需要填虚拟磁盘的实际情况,可以手工分析最后512个字节的几何参数,也可以使用教材配套软件fixvhdwr.exe</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220827162429565.png" alt="image-20220827162429565"></p>
<h4 id="Boot-Options"><a href="#Boot-Options" class="headerlink" title="Boot Options"></a>Boot Options</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220827162851643.png" alt="image-20220827162851643"></p>
<h4 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220827162908917.png" alt="image-20220827162908917"></p>
<p>前面两个设置完毕之后Save保存设置,下一次开Bochs的时候就不用重新设置了</p>
<p>保存一个bochsrc.bxrc文件,找一个牢稳的地方保存,比如bochs的根目录,或者虚拟机根目录,反正就是下一次启动bochs需要手动load该文件,能找到就行</p>
<h3 id="bochs运行主引导记录"><a href="#bochs运行主引导记录" class="headerlink" title="bochs运行主引导记录"></a>bochs运行主引导记录</h3><p>设置好之后就可以从bochs启动了</p>
<p>可以看到第一行打印出了”Label offset:00302D”</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220827163212152.png" alt="image-20220827163212152"></p>
<h3 id="bochs调试"><a href="#bochs调试" class="headerlink" title="bochs调试"></a>bochs调试</h3><p>使用bochsdbg启动虚拟机,此时除了模拟虚拟机屏幕窗口之外,还有一个终端窗口用于调试</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220827163659611.png" alt="image-20220827163659611"></p>
<p>bochs在执行第一条指令前停下来等待调试命令</p>
<p>此时第一条指令位于f000:fff0,指令内容是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp far 0xf000:e05b</span><br></pre></td></tr></table></figure>

<p>这个cs:ip指向的地址翻译成物理地址就是0xfe05b</p>
<p>而BIOS映射到内存的地址是[0xF0000,0xFFFFF],显然第一条指令跳转到了BIOS中</p>
<p>此后在这个调试终端中就可以输入命令进行调试了</p>
<h4 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h4><p>如果想在主引导记录开始下断点,由于主引导记录将被bios装载进入内存的0x7c00位置,</p>
<p>因此可以在调试终端中这样写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b 0x7c00</span><br></pre></td></tr></table></figure>

<p>这样就在0x7c00出下拉一个断点,处理器将在执行0x7c00的指令之前停下</p>
<h4 id="执行到断点"><a href="#执行到断点" class="headerlink" title="执行到断点"></a>执行到断点</h4><p>在0x7c00下断点后,命令c,一直执行直到遇到断点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>) [<span class="number">0x000000007c00</span>] <span class="number">0000</span>:<span class="number">7</span>c00 (unk. ctxt): mov ax, <span class="number">0xb800</span>            ; b800b8</span><br></pre></td></tr></table></figure>

<p>确实是主引导记录的第一条指令,将要通过ax中转设置es为显存基地址</p>
<p>分号后面的十六进制数是该条指令的机器码</p>
<h4 id="查看寄存器"><a href="#查看寄存器" class="headerlink" title="查看寄存器"></a>查看寄存器</h4><p>使用r命令查看所有通用寄存器内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:<span class="number">5</span>&gt; r</span><br><span class="line">rax: <span class="number">00000000</span>_0000aa55</span><br><span class="line">rbx: <span class="number">00000000</span>_00000000</span><br><span class="line">rcx: <span class="number">00000000</span>_00090000</span><br><span class="line">rdx: <span class="number">00000000</span>_00000080</span><br><span class="line">rsp: <span class="number">00000000</span>_0000ffd6</span><br><span class="line">rbp: <span class="number">00000000</span>_00000000</span><br><span class="line">rsi: <span class="number">00000000</span>_000e0000</span><br><span class="line">rdi: <span class="number">00000000</span>_0000ffac</span><br><span class="line">r8 : <span class="number">00000000</span>_00000000</span><br><span class="line">r9 : <span class="number">00000000</span>_00000000</span><br><span class="line">r10: <span class="number">00000000</span>_00000000</span><br><span class="line">r11: <span class="number">00000000</span>_00000000</span><br><span class="line">r12: <span class="number">00000000</span>_00000000</span><br><span class="line">r13: <span class="number">00000000</span>_00000000</span><br><span class="line">r14: <span class="number">00000000</span>_00000000</span><br><span class="line">r15: <span class="number">00000000</span>_00000000</span><br><span class="line">rip: <span class="number">00000000</span>_00007c00</span><br><span class="line">eflags <span class="number">0x00000082</span>: id vip vif ac vm rf nt IOPL=<span class="number">0</span> of df <span class="keyword">if</span> tf SF zf af pf cf</span><br></pre></td></tr></table></figure>

<p>此时rax存放的是0xAA55,估计是BIOS检查主引导记录有效性时留下的</p>
<p>rip程序计数器此时指向0x7c00</p>
<h4 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h4><p>单步执行之后,程序停在0x7c03位置,此处的指令是mov es,ax.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:<span class="number">6</span>&gt; s</span><br><span class="line">Next at t=<span class="number">17178999</span></span><br><span class="line">(<span class="number">0</span>) [<span class="number">0x000000007c03</span>] <span class="number">0000</span>:<span class="number">7</span>c03 (unk. ctxt): mov es, ax                ; <span class="number">8</span>ec0</span><br></pre></td></tr></table></figure>

<p>那么此时第一条指令已经执行完毕了,ax的值应该是0xb800,r打印一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:<span class="number">7</span>&gt; r</span><br><span class="line">rax: <span class="number">00000000</span>_0000b800</span><br></pre></td></tr></table></figure>

<p>确实如此</p>
<h4 id="查看段寄存器"><a href="#查看段寄存器" class="headerlink" title="查看段寄存器"></a>查看段寄存器</h4><p>单步执行第二条指令mov es,ax.</p>
<p>之后es应该被赋值为0xb800</p>
<p>使用sreg打印所有段寄存器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:<span class="number">17</span>&gt; sreg</span><br><span class="line">es:<span class="number">0xb800</span>, dh=<span class="number">0x0000930b</span>, dl=<span class="number">0x8000ffff</span>, valid=<span class="number">1</span></span><br><span class="line">        Data segment, base=<span class="number">0x000b8000</span>, limit=<span class="number">0x0000ffff</span>, Read/Write, Accessed</span><br><span class="line">cs:<span class="number">0x0000</span>, dh=<span class="number">0x00009300</span>, dl=<span class="number">0x0000ffff</span>, valid=<span class="number">1</span></span><br><span class="line">        Data segment, base=<span class="number">0x00000000</span>, limit=<span class="number">0x0000ffff</span>, Read/Write, Accessed</span><br><span class="line">ss:<span class="number">0x0000</span>, dh=<span class="number">0x00009300</span>, dl=<span class="number">0x0000ffff</span>, valid=<span class="number">7</span></span><br><span class="line">        Data segment, base=<span class="number">0x00000000</span>, limit=<span class="number">0x0000ffff</span>, Read/Write, Accessed</span><br><span class="line">ds:<span class="number">0x0000</span>, dh=<span class="number">0x00009300</span>, dl=<span class="number">0x0000ffff</span>, valid=<span class="number">1</span></span><br><span class="line">        Data segment, base=<span class="number">0x00000000</span>, limit=<span class="number">0x0000ffff</span>, Read/Write, Accessed</span><br><span class="line">fs:<span class="number">0x0000</span>, dh=<span class="number">0x00009300</span>, dl=<span class="number">0x0000ffff</span>, valid=<span class="number">1</span></span><br><span class="line">        Data segment, base=<span class="number">0x00000000</span>, limit=<span class="number">0x0000ffff</span>, Read/Write, Accessed</span><br><span class="line">gs:<span class="number">0x0000</span>, dh=<span class="number">0x00009300</span>, dl=<span class="number">0x0000ffff</span>, valid=<span class="number">1</span></span><br><span class="line">        Data segment, base=<span class="number">0x00000000</span>, limit=<span class="number">0x0000ffff</span>, Read/Write, Accessed</span><br><span class="line">ldtr:<span class="number">0x0000</span>, dh=<span class="number">0x00008200</span>, dl=<span class="number">0x0000ffff</span>, valid=<span class="number">1</span></span><br><span class="line">tr:<span class="number">0x0000</span>, dh=<span class="number">0x00008b00</span>, dl=<span class="number">0x0000ffff</span>, valid=<span class="number">1</span></span><br><span class="line">gdtr:base=<span class="number">0x00000000000f9ad7</span>, limit=<span class="number">0x30</span></span><br><span class="line">idtr:base=<span class="number">0x0000000000000000</span>, limit=<span class="number">0x3ff</span></span><br></pre></td></tr></table></figure>

<p>sreg不但打印了段寄存器内容,还打印了段寄存器隐藏的高速缓存器的内容,这是ollydbg做不到的</p>
<p>高速缓存器还有ldtr,gdtr等寄存器都是在保护模式才会用到,现在不管</p>
<h4 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h4><p>再连续执行两步,写入显存映射区域</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>) [<span class="number">0x000000007c05</span>] <span class="number">0000</span>:<span class="number">7</span>c05 (unk. ctxt): mov byte ptr es:<span class="number">0x0000</span>, <span class="number">0x4c</span> ; <span class="number">26</span>c60600004c</span><br><span class="line">&lt;bochs:<span class="number">18</span>&gt; s</span><br><span class="line">Next at t=<span class="number">17179001</span></span><br><span class="line">(<span class="number">0</span>) [<span class="number">0x000000007c0b</span>] <span class="number">0000</span>:<span class="number">7</span>c0b (unk. ctxt): mov byte ptr es:<span class="number">0x0001</span>, <span class="number">0x07</span> ; <span class="number">26</span>c606010007</span><br><span class="line">&lt;bochs:<span class="number">19</span>&gt; s</span><br><span class="line">Next at t=<span class="number">17179002</span></span><br><span class="line">(<span class="number">0</span>) [<span class="number">0x000000007c11</span>] <span class="number">0000</span>:<span class="number">7</span>c11 (unk. ctxt): mov byte ptr es:<span class="number">0x0002</span>, <span class="number">0x61</span> ; <span class="number">26</span>c606020061</span><br></pre></td></tr></table></figure>

<p>使用xp(examine memory at physical address),显示指定物理内存处内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xp (/数量) &lt;物理地址&gt;</span><br></pre></td></tr></table></figure>

<p>xp默认情况下一次显示一个双字,xp &#x2F;n就是显示n个双字</p>
<p>使用xp命令观察0xb8000开始的第一个双字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:24&gt; xp 0xb8000</span><br><span class="line">[bochs]:</span><br><span class="line">0x00000000000b8000 &lt;bogus+       0&gt;:    0x0b6f074c</span><br></pre></td></tr></table></figure>

<p>低两个字节是0x074c,正好对应</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov byte ptr es:0x0000, 0x4c</span><br><span class="line">mov byte ptr es:0x0001, 0x07</span><br></pre></td></tr></table></figure>



<h4 id="退出调试"><a href="#退出调试" class="headerlink" title="退出调试"></a>退出调试</h4><p>命令q退出</p>
<h2 id="初始化段地址"><a href="#初始化段地址" class="headerlink" title="初始化段地址"></a>初始化段地址</h2><p>汇编地址和物理地址</p>
<p>汇编地址就是文件偏移量</p>
<p>实际加载到内存中时的地址不一定是汇编地址,有可能需要重定位基地址</p>
<p>mbr.asm被BIOS加载到内存的0x7c00处时,所有的汇编地址都需要再加上0x7c00才是其准确的物理地址,这是因为,此时的段寄存器是0,</p>
<p>如果想要在寻址的时候不写这个看上去很奇怪的0x7c00,可以将段寄存器改成0x7c0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,<span class="number">0x7c0</span>                  ;设置数据段基地址 </span><br><span class="line">mov ds,ax</span><br></pre></td></tr></table></figure>

<p>此后任何汇编地址A就代表了物理地址<code>A+0x7c0*16</code>也就是准确的物理地址</p>
<p>实际上就是从0000:A+0x7c00转变成0x7c00:A</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220829151300719.png" alt="image-20220829151300719"></p>
<h2 id="段间数据传送"><a href="#段间数据传送" class="headerlink" title="段间数据传送"></a>段间数据传送</h2><p>在机组课本上这叫做”串操作指令”</p>
<p>movs&#x2F;movsb&#x2F;movsw</p>
<p>数据流DS:SI-&gt;ES:DI</p>
<p>由cld和std两条指令置正方向还是反方向</p>
<p>cld之后DF&#x3D;0,正向拷贝,movsb每次si和di加一,movsw每次si和di加二</p>
<p>std之后DF&#x3D;1,反向拷贝,movsw每次si和di减一,movsw每次si和di减二</p>
<p>rep 重复执行,每次cx-1直到cx减为0,cx相当于循环变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">       jmp near start;跳过数据区</span><br><span class="line">       </span><br><span class="line">mytext db &#x27;L&#x27;,0x07,&#x27;a&#x27;,0x07,&#x27;b&#x27;,0x07,&#x27;e&#x27;,0x07,&#x27;l&#x27;,0x07,&#x27; &#x27;,0x07,&#x27;o&#x27;,0x07,\</span><br><span class="line">          &#x27;f&#x27;,0x07,&#x27;f&#x27;,0x07,&#x27;s&#x27;,0x07,&#x27;e&#x27;,0x07,&#x27;t&#x27;,0x07,&#x27;:&#x27;,0x07</span><br><span class="line">number db 0,0,0,0,0</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">       mov ax,0x7c0                  ;设置数据段基地址 </span><br><span class="line">       mov ds,ax</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       mov ax,0xb800                 ;设置附加段基地址 </span><br><span class="line">       mov es,ax</span><br><span class="line">       </span><br><span class="line">       cld  ;拷贝方向标志清零,正向传送</span><br><span class="line">       mov si,mytext                 </span><br><span class="line">       mov di,0</span><br><span class="line">       mov cx,(number-mytext)/2      ;实际上等于 13</span><br><span class="line">       rep movsw   ;重复cx次,每次重复cx-1,直到为0</span><br></pre></td></tr></table></figure>

<p>将当前数据段的mytext标号开始处的(number-mytext)&#x2F;2个字,正方向拷贝到0xb800:0000开始的内存区域中,</p>
<p>这恰好把mytext完全拷贝到显存区域</p>
<h2 id="使用循环"><a href="#使用循环" class="headerlink" title="使用循环"></a>使用循环</h2><h3 id="loop循环"><a href="#loop循环" class="headerlink" title="loop循环"></a>loop循环</h3><p>loop 标号,重复执行标号开始的代码,每次cx-1,如果cx降为0则跳出循环</p>
<p>由于loop指令位于循环的末尾,标号开始的代码无论如何和都要执行至少一次,因此实际上相当于do-while循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">       ;得到标号所代表的偏移地址</span><br><span class="line">       mov ax,number</span><br><span class="line">       </span><br><span class="line">       ;计算各个数位</span><br><span class="line">       mov bx,ax				</span><br><span class="line">       mov cx,5                      ;循环次数5次 </span><br><span class="line">       mov si,10                     ;除数 </span><br><span class="line">digit: </span><br><span class="line">       xor dx,dx</span><br><span class="line">       div si						;dx:ax/si</span><br><span class="line">       mov [bx],dl                ;保存数位,就写入number标号的内存区域</span><br><span class="line">       inc bx 					;下一次要写入的位置</span><br><span class="line">       loop digit</span><br></pre></td></tr></table></figure>



<h3 id="条件跳转循环"><a href="#条件跳转循环" class="headerlink" title="条件跳转循环"></a>条件跳转循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">      ;显示各个数位</span><br><span class="line">      mov bx,number </span><br><span class="line">      mov si,4                      </span><br><span class="line">show:</span><br><span class="line">      mov al,[bx+si]</span><br><span class="line">      add al,0x30</span><br><span class="line">      mov ah,0x04</span><br><span class="line">      mov [es:di],ax</span><br><span class="line">      add di,2</span><br><span class="line">      dec si</span><br><span class="line">      jns show</span><br><span class="line">      </span><br><span class="line">     mov word [es:di],0x0744</span><br></pre></td></tr></table></figure>

<p>把number标号地址放到bx上,也就是分解number地址的十位得到的数字的地址</p>
<p>si作为偏移量,实际上bx[si]就构成了一个数组,si每次减1,直到0.</p>
<p>每次将[bx+si]放到al再加上0x30成为该数字的ASCII码,ah放上0x04即显示样式</p>
<p>然后ax整个两个字节被放到es:di上,就放到了显存中</p>
<p>然后di-2给下一个字符腾地方</p>
<p>每次si-1,直到减为-1是jns不满足跳转条件,跳出循环,执行下一条,即mov指令</p>
<p>跳出循环后的第一条指令是把0x0744这个字放到es:di上,即把’D’及其显示样式放到显存上</p>
<h2 id="美元标记"><a href="#美元标记" class="headerlink" title="美元标记"></a>美元标记</h2><p>NASM提供两个想美元符号的标记</p>
<p><code>$</code>:单个美元符号,表示当前行的行首汇编地址</p>
<p><code>$$</code>:双美元符号,表示当前段的起始汇编地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">       jmp near $;当前行首隐藏标号</span><br><span class="line"></span><br><span class="line">times 510-($-$$) db 0;当前行首隐藏标号减去从头到次的字节数,</span><br><span class="line">;510是去掉0xAA55之后的字节数</span><br><span class="line">;再去掉前面已经占用的字节数,就是还需要填充的字节数</span><br><span class="line">                 db 0x55,0xaa</span><br></pre></td></tr></table></figure>

<p><code>jmp near $</code>就是跳转到本行行首,陷入死循环</p>
<p><code>times 510-($-$$) db 0</code>重复db 0这条指令若干次,</p>
<p>具体次数是510-程序到本指令之前已经有的字节数</p>
<p>也就是空闲的地方填满0</p>
<p>最后两个字节放0x55,0xaa,有效魔数</p>
<h2 id="调试运行"><a href="#调试运行" class="headerlink" title="调试运行"></a>调试运行</h2><p>还是在0x7c00下断点,然后c一直运行到该断点处停下</p>
<p>然后一直s单步执行到rep movsw指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:<span class="number">11</span>&gt; s</span><br><span class="line">Next at t=<span class="number">17179007</span></span><br><span class="line">(<span class="number">0</span>) [<span class="number">0x000000007c36</span>] <span class="number">0000</span>:<span class="number">7</span>c36 (unk. ctxt): rep movsw word ptr es:[di], word ptr ds:[si] ; f3a5</span><br></pre></td></tr></table></figure>

<p>此时用r命令观察一下各个寄存器的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:12&gt; r</span><br><span class="line">rax: 00000000_0000b800</span><br><span class="line">rbx: 00000000_00000000</span><br><span class="line">rcx: 00000000_0009000d</span><br><span class="line">rdx: 00000000_00000080</span><br><span class="line">rsp: 00000000_0000ffd6</span><br><span class="line">rbp: 00000000_00000000</span><br><span class="line">rsi: 00000000_000e0003</span><br><span class="line">rdi: 00000000_00000000</span><br><span class="line">r8 : 00000000_00000000</span><br><span class="line">r9 : 00000000_00000000</span><br><span class="line">r10: 00000000_00000000</span><br><span class="line">r11: 00000000_00000000</span><br><span class="line">r12: 00000000_00000000</span><br><span class="line">r13: 00000000_00000000</span><br><span class="line">r14: 00000000_00000000</span><br><span class="line">r15: 00000000_00000000</span><br><span class="line">rip: 00000000_00007c36</span><br><span class="line">eflags 0x00000082: id vip vif ac vm rf nt IOPL=0 of df if tf SF zf af pf cf</span><br></pre></td></tr></table></figure>

<p>rcx&#x3D;0x9000d,cx&#x3D;0x000d,实模式下只用到cx寄存器,高位这个9没有作用</p>
<p>用sreg观察一下段寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:13&gt; sreg</span><br><span class="line">es:0xb800, dh=0x0000930b, dl=0x8000ffff, valid=1</span><br><span class="line">        Data segment, base=0x000b8000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">cs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1</span><br><span class="line">        Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ss:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7</span><br><span class="line">        Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ds:0x07c0, dh=0x00009300, dl=0x7c00ffff, valid=1</span><br><span class="line">        Data segment, base=0x00007c00, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">fs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1</span><br><span class="line">        Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">gs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1</span><br><span class="line">        Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1</span><br><span class="line">tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1</span><br><span class="line">gdtr:base=0x00000000000f9ad7, limit=0x30</span><br><span class="line">idtr:base=0x0000000000000000, limit=0x3ff</span><br></pre></td></tr></table></figure>

<p>es和ds已经设置好了</p>
<h3 id="跳出rep-loop循环n"><a href="#跳出rep-loop循环n" class="headerlink" title="跳出rep,loop循环n"></a>跳出rep,loop循环n</h3><p>现在马上要执行rep movsw指令了</p>
<p>如果使用s则会进入循环,如果想步过循环到循环外面的第一条指令,使用n指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:14&gt; n</span><br><span class="line">Next at t=17179020</span><br><span class="line">(0) [0x000000007c38] 0000:7c38 (unk. ctxt): mov ax, 0x001d            ; b81d00</span><br></pre></td></tr></table></figure>

<p>此时使用xp指令观察显存区域是否已经获得拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:15&gt; xp /4 0xb8000</span><br><span class="line">[bochs]:</span><br><span class="line">0x00000000000b8000 &lt;bogus+       0&gt;:    0x0761074c      0x07650762      0x0720076c    0x0766076f</span><br></pre></td></tr></table></figure>

<p>能够使用n跳出的循环有个特点,就是cx作为循环变量,啥时候跳出循环是很清晰的</p>
<p>如果是跳出循环的条件判断在循环体中,比如一个if条件判断,则n指令就行不通了,此时可以使用u+b+c三种指令实现</p>
<h3 id="反汇编u"><a href="#反汇编u" class="headerlink" title="反汇编u"></a>反汇编u</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u/&lt;行数&gt;</span><br></pre></td></tr></table></figure>

<p>从当前行开始反汇编若干行指令</p>
<p>在需要跳出条件循环时,可以反汇编若干行,然后在循环外面设置一个断点,然后使用c一直执行到断点停下</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/08/25/%E8%99%9A%E6%8B%9F%E7%A1%AC%E7%9B%98vhd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/25/%E8%99%9A%E6%8B%9F%E7%A1%AC%E7%9B%98vhd/" class="post-title-link" itemprop="url">x86汇编语言 chapter 4 虚拟磁盘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-25 14:54:00" itemprop="dateCreated datePublished" datetime="2022-08-25T14:54:00+08:00">2022-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-20 09:17:11" itemprop="dateModified" datetime="2022-09-20T09:17:11+08:00">2022-09-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="虚拟硬盘vhd"><a href="#虚拟硬盘vhd" class="headerlink" title="虚拟硬盘vhd"></a>虚拟硬盘vhd</h1><p>virtual hard disk</p>
<p>用virtualbox新建的没有操作系统的虚拟电脑,选择VHD格式虚拟硬盘,固定大小2G.</p>
<p>刚建立的vhd虚拟硬盘文件的最后512字节是有意义的,前面其他字节都是空的</p>
<p>这最后512个字节是啥呢?</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220825094005879.png" alt="image-20220825094005879"></p>
<h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hd_ftr</span> &#123;</span> <span class="comment">//harddisk_footer</span></span><br><span class="line">  <span class="type">char</span>   cookie[<span class="number">8</span>];       <span class="comment">/* Identifies original creator of the disk      */</span> <span class="comment">//魔数</span></span><br><span class="line">  u32    features;        <span class="comment">/* Feature Support -- see below                 */</span> </span><br><span class="line">  u32    ff_version;      <span class="comment">/* (major,minor) version of disk file           */</span> </span><br><span class="line">  u64    data_offset;     <span class="comment">/* Abs. offset from SOF to next structure       */</span> </span><br><span class="line">  u32    timestamp;       <span class="comment">/* Creation time.  secs since 1/1/2000GMT       */</span> </span><br><span class="line">  <span class="type">char</span>   crtr_app[<span class="number">4</span>];     <span class="comment">/* Creator application                          */</span> </span><br><span class="line">  u32    crtr_ver;        <span class="comment">/* Creator version (major,minor)                */</span> </span><br><span class="line">  u32    crtr_os;         <span class="comment">/* Creator host OS                              */</span> </span><br><span class="line">  u64    orig_size;       <span class="comment">/* Size at creation (bytes)                     */</span> </span><br><span class="line">  u64    curr_size;       <span class="comment">/* Current size of disk (bytes)                 */</span> </span><br><span class="line">  u32    geometry;        <span class="comment">/* Disk geometry                                */</span> </span><br><span class="line">  u32    type;            <span class="comment">/* Disk type                                    */</span> </span><br><span class="line">  u32    checksum;        <span class="comment">/* 1&#x27;s comp sum of this struct.                 */</span> </span><br><span class="line">  <span class="type">vhd_uuid_t</span> uuid;        <span class="comment">/* Unique disk ID, used for naming parents      */</span> </span><br><span class="line">  <span class="type">char</span>   saved;           <span class="comment">/* one-bit -- is this disk/VM in a saved state? */</span> </span><br><span class="line">  <span class="type">char</span>   hidden;          <span class="comment">/* tapdisk-specific field: is this vdi hidden?  */</span> </span><br><span class="line">  <span class="type">char</span>   reserved[<span class="number">426</span>];   <span class="comment">/* padding                                      */</span> </span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>可以理解为文件魔数,通过检查cookie值是否是”conectix”,判断该VHD是否有效</p>
<p>conectix是connectix公司的名称缩写,这个技术是connectix发明的</p>
<h3 id="features"><a href="#features" class="headerlink" title="features"></a>features</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HD_NO_FEATURES     0x00000000 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HD_TEMPORARY       0x00000001 <span class="comment">/* disk can be deleted on shutdown */</span> <span class="comment">//只要关机就删除硬盘</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HD_RESERVED        0x00000002 <span class="comment">/* <span class="doctag">NOTE:</span> must always be set        */</span> </span></span><br></pre></td></tr></table></figure>



<h3 id="ff-version"><a href="#ff-version" class="headerlink" title="ff_version"></a>ff_version</h3><p>VHD版本</p>
<h3 id="data-offset"><a href="#data-offset" class="headerlink" title="data_offset"></a>data_offset</h3><p>对固定磁盘来说,该值总是0xFFFFFFFF,不重要</p>
<p>对于动态磁盘来说,该值是dd_hdr的文件偏移量</p>
<h3 id="timestamp"><a href="#timestamp" class="headerlink" title="timestamp"></a>timestamp</h3><p>VHD文件的创建时间,不重要</p>
<h3 id="crtr-app"><a href="#crtr-app" class="headerlink" title="crtr_app"></a>crtr_app</h3><p>创建该VHD文件使用的应用程序,如果是virtualbox创建的则为”vbox”</p>
<h3 id="crtr-ver"><a href="#crtr-ver" class="headerlink" title="crtr_ver"></a>crtr_ver</h3><p>创建版本,不同磁盘版本管理方法不同</p>
<h3 id="crtr-os"><a href="#crtr-os" class="headerlink" title="crtr_os"></a>crtr_os</h3><p>操作系统枚举值</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220825094803757.png" alt="image-20220825094803757"></p>
<h3 id="orig-size"><a href="#orig-size" class="headerlink" title="orig_size"></a>orig_size</h3><p>创建时该虚拟磁盘的可用寻址空间,大小等于整个vhd文件大小减去该尾部扇区512字节</p>
<p>该nobody.vhd文件在创建时我们选择的大小是整2G,用010editor打开观察,发现除了最后一个扇区正好2G,全空.</p>
<p>加上最后一个扇区则为2GB+512B</p>
<h3 id="curr-size"><a href="#curr-size" class="headerlink" title="curr_size"></a>curr_size</h3><p>当前大小,可能是扩容后的可用寻址空间</p>
<h3 id="geometry"><a href="#geometry" class="headerlink" title="geometry"></a>geometry</h3><p>几何参数,即柱面数C,磁头数H,扇区数S</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220825102119209.png" alt="image-20220825102119209"></p>
<p>VHD规范中,每个扇区sector大小是512B</p>
<p>刚建立的2G的虚拟硬盘,有4161个柱面</p>
<p>16个磁头,即16个盘面</p>
<p>每个柱面上有63个扇区</p>
<p>VHD文件最开始的512字节,就对磁盘的0面0道1扇区,也就是主引导扇区</p>
<p>接下来是0面0道2扇区</p>
<p>0面0道3扇区</p>
<p>…</p>
<p>0面0道63扇区</p>
<p>1面0道1扇区</p>
<p>1面0道2扇区</p>
<p>…</p>
<p>1面0道63扇区</p>
<p>…</p>
<p>15面0道0扇区</p>
<p>15面0道1扇区</p>
<p>15面0道63扇区</p>
<p>0面1道0扇区</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>VHD类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HD_TYPE_NONE       0 <span class="comment">//无类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HD_TYPE_FIXED      2 <span class="comment">//固定大小 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HD_TYPE_DYNAMIC    3 <span class="comment">//动态大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HD_TYPE_DIFF       4 <span class="comment">//差分磁盘</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>前三个容易理解,第四个差分磁盘是什么呢?</p>
<p>差分盘分成母盘和子盘,一个母盘可以带好几个子盘,母盘存放这几个子盘共有的东西,比如操作系统代码,就跟so动态库似的可以复用</p>
<p>每个子盘中单独存放自己的数据</p>
<p>假如原来要装四个虚拟机,每个虚拟机操作系统在磁盘中占8g,剩下2g磁盘存放数据.</p>
<p>如果不使用差分磁盘,则四个虚拟机就实打实地需要40G的物理磁盘</p>
<p>然而每个虚拟机中占据8G磁盘的操作系统实际上是搞重复建设</p>
<p>因此可以用母盘放8G的操作系统,四个子盘每个2G存放各自的数据.</p>
<p>这样总共占用物理磁盘16G</p>
</blockquote>
<h3 id="checksum"><a href="#checksum" class="headerlink" title="checksum"></a>checksum</h3><p>检校和</p>
<p>最后这个扇区的所有字节相加得到的32位数按位取反</p>
<h3 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h3><p>VHD识别号,决定VHD主从关系</p>
<h3 id="saved"><a href="#saved" class="headerlink" title="saved"></a>saved</h3><p>动态磁盘才会使用,不重要</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="reserved"><a href="#reserved" class="headerlink" title="reserved"></a>reserved</h3><p>保留关键字,尚未使用</p>
<h2 id="物理磁盘"><a href="#物理磁盘" class="headerlink" title="物理磁盘"></a>物理磁盘</h2><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><h4 id="结构总览"><a href="#结构总览" class="headerlink" title="结构总览"></a>结构总览</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/2843224-46fb935cd31addbd.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220825105415000.png" alt="image-20220825105415000"></p>
<p>面0,面1,实际上就是磁头0,磁头1</p>
<p>因为每个面上都会有一个磁头负责读写该面的数据</p>
<h4 id="扇区和磁道的关系"><a href="#扇区和磁道的关系" class="headerlink" title="扇区和磁道的关系"></a>扇区和磁道的关系</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/2843224-56f2056f0b36009f.png" alt="img"></p>
<p>一个盘面从里向外有多个同心圆磁道,每个磁道上有多个扇区,但是任意两个磁道的扇区数是相同的,</p>
<p>可以想象,越往外的磁道,一个扇区约长,数据约稀疏</p>
<h4 id="磁头和柱面"><a href="#磁头和柱面" class="headerlink" title="磁头和柱面"></a>磁头和柱面</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/2843224-e0854f19c817c83c.png" alt="img"></p>
<p>柱面和磁头都是从0开始编号,但是扇区是从1开始编号的</p>
<p>一个盘片就像一个烧饼一样有两面,每面上都有磁道,一个柱面就是所有等半径的磁道集合</p>
<p>比如有三个盘片就有6个盘面,那么半径为2厘米的磁道就有6条,半径为2厘米的柱面就包含了这6条磁道</p>
<p>有多少个盘面就得有多少个磁头,每个磁头负责一个盘面的读写</p>
<p>所有磁头的动作都是同步的,就算是要读写最顶上这个盘的上面,所有的磁头都得跟着最上面这个磁头动,从顶向下看所有磁头是重叠的.但是只有上面这个磁头可以读写数据.控制哪个磁头也是硬盘控制器要做的工作</p>
<h3 id="读写速度"><a href="#读写速度" class="headerlink" title="读写速度"></a>读写速度</h3><p>磁盘的读写速度有三个方面组成</p>
<p>寻道时间,旋转时间,传送时间</p>
<h4 id="寻道时间"><a href="#寻道时间" class="headerlink" title="寻道时间"></a>寻道时间</h4><p>假如一开始磁头都趴在最外环上,现在需要往最内环的扇区读写数据,那么传动臂就得跟个塔吊一样把磁头吊过去</p>
<p>这是肉眼可见的,显然速度非常慢</p>
<h4 id="旋转时间"><a href="#旋转时间" class="headerlink" title="旋转时间"></a>旋转时间</h4><p>现在磁头已经到达了最内环,要读写该环上的第一个扇区,但是不巧,磁头刚过来时,第一个扇区刚转过去,磁头就得等到盘子转一整圈才能盼来第一个扇区,而CPU早已望眼欲穿了</p>
<h4 id="传送时间"><a href="#传送时间" class="headerlink" title="传送时间"></a>传送时间</h4><p>扇区也到位了,磁头赶紧趴下看看扇区上写了啥</p>
<p>这个过程肉眼几乎不可见,是最快的</p>
<p>这三个过程前面两个都是毫秒量级的,并且差不多.最后的传送时间稀松了了,相对于前面俩可以忽略</p>
<h2 id="访问模式"><a href="#访问模式" class="headerlink" title="访问模式"></a>访问模式</h2><p>访问模式有两种,老古董CHS模式,即通过指定柱面,磁头,扇区三个坐标访问一个扇区</p>
<p>现代LBA(logical block address)模式,不考虑柱面,磁头数了,所有扇区统一编号,将逻辑扇区号翻译成CHS的工作交给硬盘控制器干</p>
<h3 id="LBA和CHS的映射关系"><a href="#LBA和CHS的映射关系" class="headerlink" title="LBA和CHS的映射关系"></a>LBA和CHS的映射关系</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220825111708551.png" alt="image-20220825111708551"></p>
<p>逻辑扇区从0开始编号</p>
<p>假设某个硬盘有h个磁头,c个柱面,每个磁道上有s个扇区,给定一个逻辑扇区号g,求改扇区落在哪个盘子的哪个磁道上</p>
<blockquote>
<p>这三个单位的权重是c&gt;h&gt;s</p>
<p>因为寻道时间&gt;旋转时间&gt;传送时间,因此最忌讳动传动臂,磁头最好老实在固定的一环上趴着,等这个柱面上的所有磁道都满了,才迫不得已动一下传动臂换个圈转</p>
<p>这就是为啥权重c&gt;h</p>
</blockquote>
<p>每个柱面上有<code>h*s</code>个扇区,每个磁道上有s个扇区</p>
<p><code>n*h*s&lt;=g&lt;(n+1)*h*s</code></p>
<p>n就是第几个柱面,也就是哪个磁道,至于哪个盘子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k*s&lt;=(g-n*h*s)&lt;(k+1)*s</span><br></pre></td></tr></table></figure>

<p>k就是哪个盘子</p>
<h2 id="瞎写主引导记录"><a href="#瞎写主引导记录" class="headerlink" title="瞎写主引导记录"></a>瞎写主引导记录</h2><p>程序来自教材x86汇编语言从实模式到保护模式</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220825113210639.png" alt="image-20220825113210639"></p>
<p>他这段程序用nasm编会报错,因为<code>mov [0x00],&#39;a&#39;</code>只指定了目的地址,但是没有说明大小</p>
<p>我是把’a’搬到0x00这个位置上一个字节?还是<code>0x00~0x01</code>这个字还是<code>0x00~0x03</code>这个双字?没有说清.</p>
<blockquote>
<p>假:’a’不是一个字节吗?自然搬过去还是一个字节喽!</p>
</blockquote>
<p>这里’a’实际上就是一个立即数,就是’a’的ASCII码.而一个立即数是不能决定占用几个字节的</p>
<p>如果写<code>mov [0x00],al</code>这样就可以,把al这个字节寄存器的东西搬到内存0x00位置上,这时候就不用指定多大的内存了,因为al自己隐含就是一个字节寄存器了</p>
<p>并且这一点儿代码根本凑不够一个扇区,需要写一些废话填满一个扇区才有效</p>
<p>应该这样写:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; <span class="number">4</span><span class="number">-2.</span><span class="keyword">asm</span></span><br><span class="line">mov ax,<span class="number">0xb800</span>                 </span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov byte [<span class="number">0x00</span>],<span class="string">&#x27;a&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x02</span>],<span class="string">&#x27;s&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x04</span>],<span class="string">&#x27;m&#x27;</span>     </span><br><span class="line"></span><br><span class="line">jmp $</span><br><span class="line">times <span class="number">510</span>-($-$$) db <span class="number">0</span></span><br><span class="line">db <span class="number">0x55</span>,<span class="number">0xaa</span></span><br></pre></td></tr></table></figure>

<p>编译:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm main.asm -o main.bin</span><br></pre></td></tr></table></figure>

<p>然后使用fixvhdw2把main.bin写到虚拟磁盘nobody.vhd中</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220825115728499.png" alt="image-20220825115728499"></p>
<p>现在就可以开启虚拟机了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220825115716225.png" alt="image-20220825115716225"></p>
<p>asm三个字已经打印在最左上角</p>
<h3 id="如果不够512字节"><a href="#如果不够512字节" class="headerlink" title="如果不够512字节"></a>如果不够512字节</h3><p>如果main.asm没写废话</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,<span class="number">0xb800</span>                 </span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov byte [<span class="number">0x00</span>],<span class="string">&#x27;a&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x02</span>],<span class="string">&#x27;s&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x04</span>],<span class="string">&#x27;m&#x27;</span>     </span><br></pre></td></tr></table></figure>

<p>编译成main.bin之后是远没有512个字节的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220825115945064.png" alt="image-20220825115945064"></p>
<p>不够512个字节的主引导记录作废了,写到磁盘里然后尝试启动会说<del>找不到靴子</del></p>
<p>至于怎么凑够的512字节,以及为啥可以在屏幕上输出asm,那是后话了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/08/24/windows%20SDK%20chapter%2011%20%E5%AF%B9%E8%AF%9D%E6%A1%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/24/windows%20SDK%20chapter%2011%20%E5%AF%B9%E8%AF%9D%E6%A1%86/" class="post-title-link" itemprop="url">win32程序设计-chapter11 对话框</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-24 17:00:00 / Modified: 17:54:27" itemprop="dateCreated datePublished" datetime="2022-08-24T17:00:00+08:00">2022-08-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="windows-SDK-chapter-11-对话框"><a href="#windows-SDK-chapter-11-对话框" class="headerlink" title="windows SDK chapter 11 对话框"></a>windows SDK chapter 11 对话框</h1><h2 id="模态对话框"><a href="#模态对话框" class="headerlink" title="模态对话框"></a>模态对话框</h2><p>模态对话框指对话框存在时不能操作父窗口,必须关闭模态对话框才能和父窗口进行交互</p>
<p>如果是普通的模态对话框,此时还可以到其他应用程序.</p>
<p>如果是系统的模态对话框,则整个操作系统都会被这一个模态对话框锁住,必须关了系统模态对话框才可以干别的</p>
<p>因为父窗口过程直接将控制转移给了对话框函数,啥时候对话框函数返回即对话框关闭,控制才能还给父窗口</p>
<h3 id="About1"><a href="#About1" class="headerlink" title="About1"></a>About1</h3><p>主窗口过程WndProc在处理菜单消息时有一个创建对话框的情况,即点选ID_APP_ABOUT对应的菜单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_COMMAND :</span><br><span class="line">     <span class="keyword">switch</span> (LOWORD (wParam))</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">case</span> IDM_APP_ABOUT :</span><br><span class="line">          DialogBox (hInstance, TEXT (<span class="string">&quot;AboutBox&quot;</span>), hwnd, AboutDlgProc) ;<span class="comment">//创建对话框,使用AboutBox资源</span></span><br><span class="line">          <span class="keyword">break</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DialogBoxA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional]  hInstance,<span class="comment">//exe句柄</span></span></span><br><span class="line"><span class="params">  [in]            lpTemplate,<span class="comment">//对话框模板,可以加载资源</span></span></span><br><span class="line"><span class="params">  [in, optional]  hWndParent,<span class="comment">//父窗口句柄</span></span></span><br><span class="line"><span class="params">  [in, optional]  lpDialogFunc<span class="comment">//对话框过程函数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数会一直等到lpDialogFunc回调函数中调用EndDialog才会结束执行,将控制还给WndProc,</p>
<p>这意味在对话框起来之后,主窗口啥也干不了,除非把对话框扬了.</p>
<p>创建对话框的过程:</p>
<blockquote>
<p>DialogBox宏用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/CreateWindowEx/6376090">CreateWindowEx</a>函数创建对话框。DialogBox函数然后把一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/WM_INITDIALOG/1904851">WM_INITDIALOG</a>消息（和一个WM_SETFONT消息，如果模板指定DS_SETFONT类型）传递到对话框过程。不管模板是否指定WS_VISIBLE类型，函数显示对话框，并且使拥有该对话框的窗口（也称属主窗口）失效，且为对话框启动它本身的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF">消息循环</a>来检索和传递消息。</p>
<p>当对话框应用程序调用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/EndDialog/6370746">EndDialog</a>函数时，DialogBox函数清除对话框户止消息循环，使属主窗口生效（如果以前有效），且返回函数EndDialog调用中的nReSUlt参数。</p>
</blockquote>
<p>对话框过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BOOL CALLBACK <span class="title function_">AboutDlgProc</span> <span class="params">(HWND hDlg, UINT message, </span></span><br><span class="line"><span class="params">                            WPARAM wParam, LPARAM lParam)</span><span class="comment">//hDlg持有自己的对话框句柄</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">switch</span> (message)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">case</span> WM_INITDIALOG :</span><br><span class="line">          <span class="keyword">return</span> TRUE ;</span><br><span class="line">          </span><br><span class="line">     <span class="keyword">case</span> WM_COMMAND :</span><br><span class="line">          <span class="keyword">switch</span> (LOWORD (wParam))</span><br><span class="line">          &#123;</span><br><span class="line">          <span class="keyword">case</span> IDOK :</span><br><span class="line">          <span class="keyword">case</span> IDCANCEL :<span class="comment">//然而该对话框没有取消按钮,只有一个OK按钮,可以使用Esc键触发IDCANCLE</span></span><br><span class="line">               EndDialog (hDlg, <span class="number">0</span>) ;<span class="comment">//结束对话框</span></span><br><span class="line">               <span class="keyword">return</span> TRUE ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> FALSE ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">EndDialog</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HWND    hDlg,<span class="comment">//需要结束的对话框句柄</span></span></span><br><span class="line"><span class="params">  [in] INT_PTR nResult<span class="comment">//返回值,主窗口可以根据该值与对话框进行交互</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>使用DialogBox创建的对话框必须使用EndDialog制死</p>
<p>EndDialog函数是在对话框窗口过程中调用的,并且只能用于结束对话框过程</p>
<p>EndDialog中指定的返回值就是DialogBox函数的返回值</p>
<h4 id="设计对话框"><a href="#设计对话框" class="headerlink" title="设计对话框"></a>设计对话框</h4><p>visual studio添加对话框资源,可以交互式设计对话框</p>
<p>rc文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ABOUTBOX DIALOGEX <span class="number">32</span>, <span class="number">32</span>, <span class="number">180</span>, <span class="number">102</span>		<span class="comment">//名字(用于索引该对话框) 对话框类型 左上角横坐标,左上角纵坐标,宽度,高度</span></span><br><span class="line">STYLE DS_SETFONT | WS_POPUP | WS_THICKFRAME		<span class="comment">//风格	对话框有字,弹出,薄框架</span></span><br><span class="line">FONT <span class="number">8</span>, <span class="string">&quot;MS Sans Serif&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0</span>	<span class="comment">//字号8	字体	,balabala</span></span><br><span class="line">BEGIN	<span class="comment">//对话框主题开始</span></span><br><span class="line">    DEFPUSHBUTTON   <span class="string">&quot;OK&quot;</span>,IDOK,<span class="number">66</span>,<span class="number">81</span>,<span class="number">50</span>,<span class="number">14</span>	<span class="comment">//一个默认按钮,ID是IDOK,上有字样&quot;OK&quot; 左上角(66,81) 宽50,高14</span></span><br><span class="line">    ICON            <span class="string">&quot;ABOUT1&quot;</span>,IDC_STATIC,<span class="number">7</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">20</span>	<span class="comment">//图标,名称&quot;ABOUT1&quot; ID是IDC_STATIC,左上角(7,7),宽高20(对于ICON来说该宽高无意义)</span></span><br><span class="line">    CTEXT           <span class="string">&quot;dialog&quot;</span>,IDC_STATIC,<span class="number">40</span>,<span class="number">12</span>,<span class="number">100</span>,<span class="number">8</span>	<span class="comment">//文字</span></span><br><span class="line">    CTEXT           <span class="string">&quot;dustball&quot;</span>,IDC_STATIC,<span class="number">7</span>,<span class="number">40</span>,<span class="number">166</span>,<span class="number">8</span></span><br><span class="line">    CTEXT           <span class="string">&quot;(c) dustball, 2022&quot;</span>,IDC_STATIC,<span class="number">7</span>,<span class="number">52</span>,<span class="number">166</span>,<span class="number">8</span></span><br><span class="line">END		<span class="comment">//对话框主题结束</span></span><br></pre></td></tr></table></figure>

<p>这里所有数值的单位都不是像素,而是对话框所用字体的宽的四分之一高的八分之一,具体怎么算的不重要,交互式设计不需要闷头算他娘的</p>
<p>BEGIN和END之间是对话框子窗口控件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">控件类型 &quot;文本&quot;,id,左坐标,上坐标,宽度,高度,控件风格</span><br></pre></td></tr></table></figure>

<p>控件风格比如WS_CHILD,SS_CENTER,WS_VISIBLE</p>
<h4 id="对话框过程"><a href="#对话框过程" class="headerlink" title="对话框过程"></a>对话框过程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL CALLBACK <span class="title function_">AboutDlgProc</span> <span class="params">(HWND hDlg, UINT message,WPARAM wParam, LPARAM lParam)</span>;</span><br></pre></td></tr></table></figure>

<p>一个返回真假的回调函数,有四个参数,对话框句柄,消息,w参和l参</p>
<p>对比窗口过程和对话框过程</p>
<table>
<thead>
<tr>
<th></th>
<th>对话框过程</th>
<th>窗口过程</th>
</tr>
</thead>
<tbody><tr>
<td>返回值</td>
<td>BOOL</td>
<td>LRESULT</td>
</tr>
<tr>
<td>DefWindowProc</td>
<td>不会调用,只会返回TRUE</td>
<td>处理不了的消息调用DefWindowProc</td>
</tr>
<tr>
<td>处理消息</td>
<td>不需要处理WM_PAINT,WM_DESTORY<br />不会收到WM_CREATE,<br />有专门消息WM_INITDIALOG<br />只需要处理WM_COMMAND</td>
<td></td>
</tr>
</tbody></table>
<p>当对话框中按下按钮时,这个按钮回向它的父窗口,也就是这个对话框,发送WM_COMMAND消息,wParam是控件ID</p>
<h3 id="About2"><a href="#About2" class="headerlink" title="About2"></a>About2</h3><h4 id="资源脚本"><a href="#资源脚本" class="headerlink" title="资源脚本"></a>资源脚本</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ABOUTBOX DIALOG DISCARDABLE  <span class="number">32</span>, <span class="number">32</span>, <span class="number">200</span>, <span class="number">234</span>	<span class="comment">//名叫ABOUTBOX</span></span><br><span class="line">STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION</span><br><span class="line">FONT <span class="number">8</span>, <span class="string">&quot;MS Sans Serif&quot;</span></span><br><span class="line">BEGIN</span><br><span class="line">    ICON            <span class="string">&quot;ABOUT2&quot;</span>,IDC_STATIC,<span class="number">7</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">20</span></span><br><span class="line">    CTEXT           <span class="string">&quot;About2&quot;</span>,IDC_STATIC,<span class="number">57</span>,<span class="number">12</span>,<span class="number">86</span>,<span class="number">8</span></span><br><span class="line">    CTEXT           <span class="string">&quot;About Box Demo Program&quot;</span>,IDC_STATIC,<span class="number">7</span>,<span class="number">40</span>,<span class="number">186</span>,<span class="number">8</span></span><br><span class="line">    LTEXT           <span class="string">&quot;&quot;</span>,IDC_PAINT,<span class="number">114</span>,<span class="number">67</span>,<span class="number">72</span>,<span class="number">72</span>			<span class="comment">//预览块</span></span><br><span class="line">    GROUPBOX        <span class="string">&quot;&amp;Color&quot;</span>,IDC_STATIC,<span class="number">7</span>,<span class="number">60</span>,<span class="number">84</span>,<span class="number">143</span></span><br><span class="line">    RADIOBUTTON     <span class="string">&quot;&amp;Black&quot;</span>,IDC_BLACK,<span class="number">16</span>,<span class="number">76</span>,<span class="number">64</span>,<span class="number">8</span>,WS_GROUP | WS_TABSTOP<span class="comment">//单选组开始,tab键停留位置,使用tab键可以更换当前对话框内的焦点.同一组内按钮可以使用上下左右键调整选择</span></span><br><span class="line">    RADIOBUTTON     <span class="string">&quot;B&amp;lue&quot;</span>,IDC_BLUE,<span class="number">16</span>,<span class="number">92</span>,<span class="number">64</span>,<span class="number">8</span></span><br><span class="line">    RADIOBUTTON     <span class="string">&quot;&amp;Green&quot;</span>,IDC_GREEN,<span class="number">16</span>,<span class="number">108</span>,<span class="number">64</span>,<span class="number">8</span></span><br><span class="line">    RADIOBUTTON     <span class="string">&quot;Cya&amp;n&quot;</span>,IDC_CYAN,<span class="number">16</span>,<span class="number">124</span>,<span class="number">64</span>,<span class="number">8</span></span><br><span class="line">    RADIOBUTTON     <span class="string">&quot;&amp;Red&quot;</span>,IDC_RED,<span class="number">16</span>,<span class="number">140</span>,<span class="number">64</span>,<span class="number">8</span></span><br><span class="line">    RADIOBUTTON     <span class="string">&quot;&amp;Magenta&quot;</span>,IDC_MAGENTA,<span class="number">16</span>,<span class="number">156</span>,<span class="number">64</span>,<span class="number">8</span></span><br><span class="line">    RADIOBUTTON     <span class="string">&quot;&amp;Yellow&quot;</span>,IDC_YELLOW,<span class="number">16</span>,<span class="number">172</span>,<span class="number">64</span>,<span class="number">8</span></span><br><span class="line">    RADIOBUTTON     <span class="string">&quot;&amp;White&quot;</span>,IDC_WHITE,<span class="number">16</span>,<span class="number">188</span>,<span class="number">64</span>,<span class="number">8</span></span><br><span class="line">    GROUPBOX        <span class="string">&quot;&amp;Figure&quot;</span>,IDC_STATIC,<span class="number">109</span>,<span class="number">156</span>,<span class="number">84</span>,<span class="number">46</span>,WS_GROUP</span><br><span class="line">    RADIOBUTTON     <span class="string">&quot;Rec&amp;tangle&quot;</span>,IDC_RECT,<span class="number">116</span>,<span class="number">172</span>,<span class="number">65</span>,<span class="number">8</span>,WS_GROUP | WS_TABSTOP</span><br><span class="line">    RADIOBUTTON     <span class="string">&quot;&amp;Ellipse&quot;</span>,IDC_ELLIPSE,<span class="number">116</span>,<span class="number">188</span>,<span class="number">64</span>,<span class="number">8</span></span><br><span class="line">    DEFPUSHBUTTON   <span class="string">&quot;OK&quot;</span>,IDOK,<span class="number">35</span>,<span class="number">212</span>,<span class="number">50</span>,<span class="number">14</span>,WS_GROUP</span><br><span class="line">    PUSHBUTTON      <span class="string">&quot;Cancel&quot;</span>,IDCANCEL,<span class="number">113</span>,<span class="number">212</span>,<span class="number">50</span>,<span class="number">14</span>,WS_GROUP</span><br><span class="line">END</span><br></pre></td></tr></table></figure>



<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> iCurrentColor = IDC_BLACK;  <span class="comment">//当前颜色</span></span><br><span class="line"><span class="type">int</span>    iCurrentFigure = IDC_RECT ;<span class="comment">//当前形状</span></span><br></pre></td></tr></table></figure>

<p>这两个变量决定着预览框和主窗口如何绘制.</p>
<p>通过对话框修改</p>
<h4 id="父窗口过程"><a href="#父窗口过程" class="headerlink" title="父窗口过程"></a>父窗口过程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span> <span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">static</span> HINSTANCE hInstance ;</span><br><span class="line">     PAINTSTRUCT      ps ;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">switch</span> (message)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">          hInstance = ((LPCREATESTRUCT) lParam)-&gt;hInstance ;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">          </span><br><span class="line">     <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">          <span class="keyword">switch</span> (LOWORD (wParam))</span><br><span class="line">          &#123;</span><br><span class="line">          <span class="keyword">case</span> IDM_APP_ABOUT:</span><br><span class="line">               <span class="keyword">if</span> (DialogBox (hInstance, TEXT (<span class="string">&quot;AboutBox&quot;</span>), hwnd, AboutDlgProc))</span><br><span class="line">                    InvalidateRect (hwnd, <span class="literal">NULL</span>, TRUE) ;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span> ;</span><br><span class="line">          </span><br><span class="line">     <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">          BeginPaint (hwnd, &amp;ps) ;</span><br><span class="line">          EndPaint (hwnd, &amp;ps) ;</span><br><span class="line">               </span><br><span class="line">          PaintWindow (hwnd, iCurrentColor, iCurrentFigure) ;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">               </span><br><span class="line">     <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">          PostQuitMessage (<span class="number">0</span>) ;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> DefWindowProc (hwnd, message, wParam, lParam) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PaintWindow"><a href="#PaintWindow" class="headerlink" title="PaintWindow"></a>PaintWindow</h4><p>使用iColor颜色和iFigure形状绘制hwnd指向的窗口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PaintWindow</span> <span class="params">(HWND hwnd, <span class="type">int</span> iColor, <span class="type">int</span> iFigure)</span><span class="comment">//根据指定颜色和形状绘制窗口</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">static</span> COLORREF crColor[<span class="number">8</span>] = &#123; RGB (  <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>), RGB (  <span class="number">0</span>,   <span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                                    RGB (  <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), RGB (  <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>),</span><br><span class="line">                                    RGB (<span class="number">255</span>,   <span class="number">0</span>, <span class="number">0</span>), RGB (<span class="number">255</span>,   <span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                                    RGB (<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), RGB (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>) &#125; ;<span class="comment">//颜色列表</span></span><br><span class="line"></span><br><span class="line">     HBRUSH          hBrush ;</span><br><span class="line">     HDC             hdc ;</span><br><span class="line">     RECT            rect ;</span><br><span class="line">     </span><br><span class="line">     hdc = GetDC (hwnd) ;</span><br><span class="line">     GetClientRect (hwnd, &amp;rect) ;</span><br><span class="line">     hBrush = CreateSolidBrush (crColor[iColor - IDC_BLACK]) ;<span class="comment">//iColor是当前正在使用的颜色</span></span><br><span class="line">     hBrush = (HBRUSH) SelectObject (hdc, hBrush) ;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> (iFigure == IDC_RECT)<span class="comment">//绘制矩形</span></span><br><span class="line">          Rectangle (hdc, rect.left, rect.top, rect.right, rect.bottom) ;</span><br><span class="line">     <span class="keyword">else</span><span class="comment">//绘制扁瓜蛋</span></span><br><span class="line">          Ellipse   (hdc, rect.left, rect.top, rect.right, rect.bottom) ;</span><br><span class="line">     </span><br><span class="line">     DeleteObject (SelectObject (hdc, hBrush)) ;</span><br><span class="line">     ReleaseDC (hwnd, hdc) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对话框过程-1"><a href="#对话框过程-1" class="headerlink" title="对话框过程"></a>对话框过程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BOOL CALLBACK <span class="title function_">AboutDlgProc</span> <span class="params">(HWND hDlg, UINT message, </span></span><br><span class="line"><span class="params">                            WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">static</span> HWND hCtrlBlock ;<span class="comment">//预览块句柄</span></span><br><span class="line">     <span class="type">static</span> <span class="type">int</span>  iColor, iFigure ;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">switch</span> (message)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">          iColor  = iCurrentColor ;<span class="comment">//获取当前颜色</span></span><br><span class="line">          iFigure = iCurrentFigure ;</span><br><span class="line">          </span><br><span class="line">          CheckRadioButton (hDlg, IDC_BLACK, IDC_WHITE,   iColor) ;<span class="comment">//第一个颜色和最后一个颜色,其间的宏定义都算,这一些选项中有且只有一个处于被选中状态</span></span><br><span class="line">          CheckRadioButton (hDlg, IDC_RECT,  IDC_ELLIPSE, iFigure) ;</span><br><span class="line">          </span><br><span class="line">          hCtrlBlock = GetDlgItem (hDlg, IDC_PAINT) ;<span class="comment">//获取预览块句柄</span></span><br><span class="line">          </span><br><span class="line">          SetFocus (GetDlgItem (hDlg, iColor)) ;<span class="comment">//iColor就是选中颜色按钮的句柄,将焦点让给该按钮</span></span><br><span class="line">          <span class="keyword">return</span> FALSE ;</span><br><span class="line">          </span><br><span class="line">     <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">          <span class="keyword">switch</span> (LOWORD (wParam))</span><br><span class="line">          &#123;</span><br><span class="line">          <span class="keyword">case</span> IDOK:<span class="comment">//点选了确认键,需要修改设置了</span></span><br><span class="line">               iCurrentColor  = iColor ;</span><br><span class="line">               iCurrentFigure = iFigure ;<span class="comment">//修改当前设置</span></span><br><span class="line">               EndDialog (hDlg, TRUE) ;</span><br><span class="line">               <span class="keyword">return</span> TRUE ;</span><br><span class="line">               </span><br><span class="line">          <span class="keyword">case</span> IDCANCEL:</span><br><span class="line">               EndDialog (hDlg, FALSE) ;</span><br><span class="line">               <span class="keyword">return</span> TRUE ;</span><br><span class="line">               </span><br><span class="line">          <span class="keyword">case</span> IDC_BLACK:</span><br><span class="line">          <span class="keyword">case</span> IDC_RED:</span><br><span class="line">          <span class="keyword">case</span> IDC_GREEN:</span><br><span class="line">          <span class="keyword">case</span> IDC_YELLOW:</span><br><span class="line">          <span class="keyword">case</span> IDC_BLUE:</span><br><span class="line">          <span class="keyword">case</span> IDC_MAGENTA:</span><br><span class="line">          <span class="keyword">case</span> IDC_CYAN:</span><br><span class="line">          <span class="keyword">case</span> IDC_WHITE:</span><br><span class="line">               iColor = LOWORD (wParam) ;<span class="comment">//LOWORD(wParam)携带控件ID</span></span><br><span class="line">               CheckRadioButton (hDlg, IDC_BLACK, IDC_WHITE, LOWORD (wParam)) ;<span class="comment">//根据鼠标点选改变单选按钮状态</span></span><br><span class="line">               PaintTheBlock (hCtrlBlock, iColor, iFigure) ;<span class="comment">//Block是预览块,实时根据选择改变,提供预览功能</span></span><br><span class="line">               <span class="keyword">return</span> TRUE ;</span><br><span class="line">               </span><br><span class="line">          <span class="keyword">case</span> IDC_RECT:</span><br><span class="line">          <span class="keyword">case</span> IDC_ELLIPSE:</span><br><span class="line">               iFigure = LOWORD (wParam) ;<span class="comment">//更新图形状态</span></span><br><span class="line">               CheckRadioButton (hDlg, IDC_RECT, IDC_ELLIPSE, LOWORD (wParam)) ;</span><br><span class="line">               PaintTheBlock (hCtrlBlock, iColor, iFigure) ;<span class="comment">//立刻重绘预览块</span></span><br><span class="line">               <span class="keyword">return</span> TRUE ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span> ;</span><br><span class="line">          </span><br><span class="line">     <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">          PaintTheBlock (hCtrlBlock, iColor, iFigure) ;<span class="comment">//重绘时只需要关注预览块</span></span><br><span class="line">          <span class="keyword">break</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> FALSE ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="PaintTheBlock"><a href="#PaintTheBlock" class="headerlink" title="PaintTheBlock"></a>PaintTheBlock</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PaintTheBlock</span> <span class="params">(HWND hCtrl, <span class="type">int</span> iColor, <span class="type">int</span> iFigure)</span></span><br><span class="line">&#123;</span><br><span class="line">     InvalidateRect (hCtrl, <span class="literal">NULL</span>, TRUE) ;<span class="comment">//hCtrl句柄控制的客户去全都失效</span></span><br><span class="line">     UpdateWindow (hCtrl) ;<span class="comment">//重绘hCtrl</span></span><br><span class="line">     PaintWindow (hCtrl, iColor, iFigure) ;<span class="comment">//根据hCtrl和iColor指定的风格重绘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="回顾父子通信方式"><a href="#回顾父子通信方式" class="headerlink" title="回顾父子通信方式"></a>回顾父子通信方式</h4><p>父窗口就只负责主窗口客户区的颜色和图形绘制,对话框负责调这个颜色和图形</p>
<p>父窗口和对话框如何进行通信的?或者说对话框是如何通知父窗口用新样式绘图的呢?</p>
<p>关键在于两个对父过程和对话框过程都可见的全局变量,对话框使用这两个变量间接通知父窗口</p>
<p>并且在对话框关闭之后,父窗口会立刻重绘,这就使得颜色样式更新显得没有延迟</p>
<p>父窗口中,关闭对话框之后的立刻更新:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IDM_APP_ABOUT:</span><br><span class="line">     <span class="keyword">if</span> (DialogBox (hInstance, TEXT (<span class="string">&quot;AboutBox&quot;</span>), hwnd, AboutDlgProc))<span class="comment">//如果DialogBox返回值1说明确实有修改,需要重绘,否则不需要重绘</span></span><br><span class="line">          InvalidateRect (hwnd, <span class="literal">NULL</span>, TRUE) ;</span><br></pre></td></tr></table></figure>

<h4 id="避免使用全局变量"><a href="#避免使用全局变量" class="headerlink" title="避免使用全局变量"></a>避免使用全局变量</h4><p>正当我感觉使用全局变量间接实现父子通信,这个设计合情合理,甚至有点巧妙时,人家又说,这是low B方法.</p>
<p>书上给的方法是,定义一个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> iColor, iFigure;</span><br><span class="line">&#125;ABOUTBOX_DATA;</span><br></pre></td></tr></table></figure>

<p>这个结构体就记录了对话框能够使用的变量</p>
<p>在WndProc中用这样一个结构体指针传递给DialogBoxParam,即带参数的对话框函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">INT_PTR <span class="title function_">DialogBoxParamA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional] HINSTANCE hInstance,<span class="comment">//应用程序实例句柄</span></span></span><br><span class="line"><span class="params">  [in]           LPCSTR    lpTemplateName,<span class="comment">//对话框id</span></span></span><br><span class="line"><span class="params">  [in, optional] HWND      hWndParent,<span class="comment">//父窗口</span></span></span><br><span class="line"><span class="params">  [in, optional] DLGPROC   lpDialogFunc,<span class="comment">//对话框过程</span></span></span><br><span class="line"><span class="params">  [in]           LPARAM    dwInitParam<span class="comment">//参数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>dwInitParam这个参数将会作为对话框WM_INITDIALOG消息的lParam参数传递给对话框过程,也就是把WndProc函数栈变量的地址交给了对话框过程AboutDlgProc,使得对话框过程函数可以操作WndProc的函数栈</p>
<p>AboutDlgProc中有两个关于ABOUTBOX_DATA结构体的变量,一个是指针类型,保管WndProc用WM_INITDIALOG消息的lParam参数指定的指针,用于向WndProc打报告</p>
<p>另一个是AboutDlgProc函数栈下的局部变量,这个是对话框过程自娱自乐用的,打报告的时候只需要拷贝该局部变量的情况</p>
<p>修改后的About2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------------------------------------------</span></span><br><span class="line"><span class="comment">   ABOUT2.C -- About Box Demo Program No. 2</span></span><br><span class="line"><span class="comment">               (c) Charles Petzold, 1998</span></span><br><span class="line"><span class="comment">  ------------------------------------------*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">//结构体定义</span></span><br><span class="line">    <span class="type">int</span> iColor, iFigure;</span><br><span class="line">&#125;ABOUTBOX_DATA;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span>      <span class="params">(HWND, UINT, WPARAM, LPARAM)</span> ;</span><br><span class="line">BOOL    CALLBACK <span class="title function_">AboutDlgProc</span> <span class="params">(HWND, UINT, WPARAM, LPARAM)</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">WinMain</span> <span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance,</span></span><br><span class="line"><span class="params">                    PSTR szCmdLine, <span class="type">int</span> iCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">static</span> TCHAR szAppName[] = TEXT (<span class="string">&quot;About2&quot;</span>) ;</span><br><span class="line">     MSG          msg ;</span><br><span class="line">     HWND         hwnd ;</span><br><span class="line">     WNDCLASS     wndclass ;</span><br><span class="line">     </span><br><span class="line">     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;</span><br><span class="line">     wndclass.lpfnWndProc   = WndProc ;</span><br><span class="line">     wndclass.cbClsExtra    = <span class="number">0</span> ;</span><br><span class="line">     wndclass.cbWndExtra    = <span class="number">0</span> ;</span><br><span class="line">     wndclass.hInstance     = hInstance ;</span><br><span class="line">     wndclass.hIcon         = LoadIcon (hInstance, szAppName) ;</span><br><span class="line">     wndclass.hCursor       = LoadCursor (<span class="literal">NULL</span>, IDC_ARROW) ;</span><br><span class="line">     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;</span><br><span class="line">     wndclass.lpszMenuName  = szAppName ;</span><br><span class="line">     wndclass.lpszClassName = szAppName ;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> (!RegisterClass (&amp;wndclass))</span><br><span class="line">     &#123;</span><br><span class="line">          MessageBox (<span class="literal">NULL</span>, TEXT (<span class="string">&quot;This program requires Windows NT!&quot;</span>),</span><br><span class="line">                      szAppName, MB_ICONERROR) ;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     hwnd = CreateWindow (szAppName, TEXT (<span class="string">&quot;About Box Demo Program&quot;</span>),</span><br><span class="line">                          WS_OVERLAPPEDWINDOW,</span><br><span class="line">                          CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">                          CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">                          <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>) ;</span><br><span class="line">     </span><br><span class="line">     ShowWindow (hwnd, iCmdShow) ;</span><br><span class="line">     UpdateWindow (hwnd) ; </span><br><span class="line">     </span><br><span class="line">     <span class="keyword">while</span> (GetMessage (&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">          TranslateMessage (&amp;msg) ;</span><br><span class="line">          DispatchMessage (&amp;msg) ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> msg.wParam ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PaintWindow</span> <span class="params">(HWND hwnd, <span class="type">int</span> iColor, <span class="type">int</span> iFigure)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">static</span> COLORREF crColor[<span class="number">8</span>] = &#123; RGB (  <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>), RGB (  <span class="number">0</span>,   <span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                                    RGB (  <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), RGB (  <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>),</span><br><span class="line">                                    RGB (<span class="number">255</span>,   <span class="number">0</span>, <span class="number">0</span>), RGB (<span class="number">255</span>,   <span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                                    RGB (<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), RGB (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>) &#125; ;</span><br><span class="line"></span><br><span class="line">     HBRUSH          hBrush ;</span><br><span class="line">     HDC             hdc ;</span><br><span class="line">     RECT            rect ;</span><br><span class="line">     </span><br><span class="line">     hdc = GetDC (hwnd) ;</span><br><span class="line">     GetClientRect (hwnd, &amp;rect) ;</span><br><span class="line">     hBrush = CreateSolidBrush (crColor[iColor - IDC_BLACK]) ;</span><br><span class="line">     hBrush = (HBRUSH) SelectObject (hdc, hBrush) ;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> (iFigure == IDC_RECT)</span><br><span class="line">          Rectangle (hdc, rect.left, rect.top, rect.right, rect.bottom) ;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">          Ellipse   (hdc, rect.left, rect.top, rect.right, rect.bottom) ;</span><br><span class="line">     </span><br><span class="line">     DeleteObject (SelectObject (hdc, hBrush)) ;</span><br><span class="line">     ReleaseDC (hwnd, hdc) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PaintTheBlock</span> <span class="params">(HWND hCtrl, <span class="type">int</span> iColor, <span class="type">int</span> iFigure)</span></span><br><span class="line">&#123;</span><br><span class="line">     InvalidateRect (hCtrl, <span class="literal">NULL</span>, TRUE) ;</span><br><span class="line">     UpdateWindow (hCtrl) ;</span><br><span class="line">     PaintWindow (hCtrl, iColor, iFigure) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span> <span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">static</span> HINSTANCE hInstance ;<span class="comment">//应用程序实例句柄</span></span><br><span class="line">     <span class="type">static</span> PAINTSTRUCT      ps ;</span><br><span class="line">     <span class="type">static</span> ABOUTBOX_DATA ad;<span class="comment">//父窗口绘图依据</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">switch</span> (message)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">          hInstance = ((LPCREATESTRUCT) lParam)-&gt;hInstance ;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">          </span><br><span class="line">     <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">          <span class="keyword">switch</span> (LOWORD (wParam))</span><br><span class="line">          &#123;</span><br><span class="line">          <span class="keyword">case</span> IDM_APP_ABOUT:</span><br><span class="line">               <span class="keyword">if</span> (DialogBoxParam (hInstance, TEXT (<span class="string">&quot;AboutBox&quot;</span>), hwnd, AboutDlgProc,&amp;ad))<span class="comment">//ad地址交给子窗口,使其可以跨函数栈帧修改ad值</span></span><br><span class="line">                    InvalidateRect (hwnd, <span class="literal">NULL</span>, TRUE) ;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span> ;</span><br><span class="line">          </span><br><span class="line">     <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">          BeginPaint (hwnd, &amp;ps) ;</span><br><span class="line">          EndPaint (hwnd, &amp;ps) ;</span><br><span class="line">               </span><br><span class="line">          PaintWindow (hwnd, ad.iColor, ad.iFigure) ;<span class="comment">//根据当前颜色当前形状绘图</span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">               </span><br><span class="line">     <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">          PostQuitMessage (<span class="number">0</span>) ;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> DefWindowProc (hwnd, message, wParam, lParam) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL CALLBACK <span class="title function_">AboutDlgProc</span> <span class="params">(HWND hDlg, UINT message, </span></span><br><span class="line"><span class="params">                            WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">static</span> HWND hCtrlBlock ;</span><br><span class="line">     <span class="type">static</span> ABOUTBOX_DATA ad,*pad;</span><br><span class="line">     <span class="keyword">switch</span> (message)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">         pad = (ABOUTBOX_DATA*)lParam;<span class="comment">//pad用于承接父窗口传递的指针</span></span><br><span class="line">         ad = *pad;<span class="comment">//ad是本函数绘图依据,不到万不得已不使用*pad指针</span></span><br><span class="line"></span><br><span class="line">          </span><br><span class="line">          CheckRadioButton (hDlg, IDC_BLACK, IDC_WHITE,   ad.iColor) ;<span class="comment">//第一个颜色和最后一个颜色,其间的宏定义都算,这一些选项中有且只有一个处于被选中状态</span></span><br><span class="line">          CheckRadioButton (hDlg, IDC_RECT,  IDC_ELLIPSE, ad.iFigure) ;</span><br><span class="line">          </span><br><span class="line">          hCtrlBlock = GetDlgItem (hDlg, IDC_PAINT) ;<span class="comment">//预览块矿建</span></span><br><span class="line">          </span><br><span class="line">          SetFocus (GetDlgItem (hDlg, ad.iColor)) ;</span><br><span class="line">          <span class="keyword">return</span> FALSE ;</span><br><span class="line">          </span><br><span class="line">     <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">          <span class="keyword">switch</span> (LOWORD (wParam))</span><br><span class="line">          &#123;</span><br><span class="line">          <span class="keyword">case</span> IDOK:<span class="comment">//点选了确认键,需要修改设置了</span></span><br><span class="line">              *pad = ad;</span><br><span class="line">               EndDialog (hDlg, TRUE) ;</span><br><span class="line">               <span class="keyword">return</span> TRUE ;</span><br><span class="line">               </span><br><span class="line">          <span class="keyword">case</span> IDCANCEL:</span><br><span class="line">               EndDialog (hDlg, FALSE) ;</span><br><span class="line">               <span class="keyword">return</span> TRUE ;</span><br><span class="line">               </span><br><span class="line">          <span class="keyword">case</span> IDC_BLACK:</span><br><span class="line">          <span class="keyword">case</span> IDC_RED:</span><br><span class="line">          <span class="keyword">case</span> IDC_GREEN:</span><br><span class="line">          <span class="keyword">case</span> IDC_YELLOW:</span><br><span class="line">          <span class="keyword">case</span> IDC_BLUE:</span><br><span class="line">          <span class="keyword">case</span> IDC_MAGENTA:</span><br><span class="line">          <span class="keyword">case</span> IDC_CYAN:</span><br><span class="line">          <span class="keyword">case</span> IDC_WHITE:</span><br><span class="line">               ad.iColor = LOWORD (wParam) ;<span class="comment">//LOWORD(wParam)携带控件ID</span></span><br><span class="line">               CheckRadioButton (hDlg, IDC_BLACK, IDC_WHITE, LOWORD (wParam)) ;</span><br><span class="line">               PaintTheBlock (hCtrlBlock, ad.iColor,ad.iFigure ) ;<span class="comment">//Block是预览块,实时根据选择改变,提供预览功能</span></span><br><span class="line">               <span class="keyword">return</span> TRUE ;</span><br><span class="line">               </span><br><span class="line">          <span class="keyword">case</span> IDC_RECT:</span><br><span class="line">          <span class="keyword">case</span> IDC_ELLIPSE:</span><br><span class="line">               ad.iFigure = LOWORD (wParam) ;</span><br><span class="line">               CheckRadioButton (hDlg, IDC_RECT, IDC_ELLIPSE, LOWORD (wParam)) ;</span><br><span class="line">               PaintTheBlock (hCtrlBlock, ad.iColor, ad.iFigure) ;</span><br><span class="line">               <span class="keyword">return</span> TRUE ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span> ;</span><br><span class="line">          </span><br><span class="line">     <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">          PaintTheBlock (hCtrlBlock, ad.iColor, ad.iFigure) ;</span><br><span class="line">          <span class="keyword">break</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> FALSE ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="回顾单选互斥的实现"><a href="#回顾单选互斥的实现" class="headerlink" title="回顾单选互斥的实现"></a>回顾单选互斥的实现</h4><p>之前实现单选互斥,需要维护一组按钮的状态,当新按钮按下之前,先得把原来按下的按钮扣起来,在按下新按钮.</p>
<p>而现在只需要</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CheckRadioButton(hDlg,idFirst,idLast,idCheck);</span><br></pre></td></tr></table></figure>

<p>意思是,在hDlg对话框中,编号属于<code>[idFirst,idLast]</code>这个范围的单选按钮都是互斥的,idCheck决定按下哪一个.</p>
<p>这就要求从idFirst到idLast是连号的,idCheck属于这个范围</p>
<h3 id="About3"><a href="#About3" class="headerlink" title="About3"></a>About3</h3><p>自定义对话框控件</p>
<h4 id="资源脚本-1"><a href="#资源脚本-1" class="headerlink" title="资源脚本"></a>资源脚本</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ABOUTBOX DIALOG DISCARDABLE  <span class="number">32</span>, <span class="number">32</span>, <span class="number">180</span>, <span class="number">100</span></span><br><span class="line">STYLE DS_MODALFRAME | WS_POPUP</span><br><span class="line">FONT <span class="number">8</span>, <span class="string">&quot;MS Sans Serif&quot;</span></span><br><span class="line">BEGIN</span><br><span class="line">    CONTROL         <span class="string">&quot;OK&quot;</span>,IDOK,<span class="string">&quot;EllipPush&quot;</span>,WS_GROUP | WS_TABSTOP,<span class="number">73</span>,<span class="number">79</span>,<span class="number">32</span>,<span class="number">14</span><span class="comment">//自定义控件,ID=IDOK,类名=&quot;EllipPush&quot;</span></span><br><span class="line">    ICON            <span class="string">&quot;ABOUT3&quot;</span>,IDC_STATIC,<span class="number">7</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">20</span></span><br><span class="line">    CTEXT           <span class="string">&quot;About3&quot;</span>,IDC_STATIC,<span class="number">40</span>,<span class="number">12</span>,<span class="number">100</span>,<span class="number">8</span></span><br><span class="line">    CTEXT           <span class="string">&quot;About Box Demo Program&quot;</span>,IDC_STATIC,<span class="number">7</span>,<span class="number">40</span>,<span class="number">166</span>,<span class="number">8</span></span><br><span class="line">    CTEXT           <span class="string">&quot;(c) Charles Petzold, 1998&quot;</span>,IDC_STATIC,<span class="number">7</span>,<span class="number">52</span>,<span class="number">166</span>,<span class="number">8</span></span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>这里的类名就是注册窗口类时的类名,决定从该类创建的实例的属性</p>
<h4 id="自定义控件过程函数"><a href="#自定义控件过程函数" class="headerlink" title="自定义控件过程函数"></a>自定义控件过程函数</h4><p>创建自定义控件类的时候需要注册其过程函数,其中WM_PAINT决定了该自定义控件类的外观</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">EllipPushWndProc</span> <span class="params">(HWND hwnd, UINT message, <span class="comment">//自定义按钮类行为</span></span></span><br><span class="line"><span class="params">                                   WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">     TCHAR       szText[<span class="number">40</span>] ;</span><br><span class="line">     HBRUSH      hBrush ;</span><br><span class="line">     HDC         hdc ;</span><br><span class="line">     PAINTSTRUCT ps ;</span><br><span class="line">     RECT        rect ;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">switch</span> (message)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">case</span> WM_PAINT :<span class="comment">//绘图行为</span></span><br><span class="line">          GetClientRect (hwnd, &amp;rect) ;</span><br><span class="line">          GetWindowText (hwnd, szText, lstrlen(szText)) ;<span class="comment">//获取本子窗口的描述文字,写到szText数组里,即&quot;OK&quot;字样</span></span><br><span class="line">          </span><br><span class="line">          hdc = BeginPaint (hwnd, &amp;ps) ;</span><br><span class="line">          </span><br><span class="line">          hBrush = CreateSolidBrush (GetSysColor (COLOR_WINDOW)) ;</span><br><span class="line">          hBrush = (HBRUSH) SelectObject (hdc, hBrush) ;</span><br><span class="line">          SetBkColor (hdc, GetSysColor (COLOR_WINDOW)) ;</span><br><span class="line">          SetTextColor (hdc, GetSysColor (COLOR_WINDOWTEXT)) ;</span><br><span class="line">          </span><br><span class="line">          Ellipse (hdc, rect.left, rect.top, rect.right, rect.bottom) ;<span class="comment">//绘制椭圆</span></span><br><span class="line">          DrawText (hdc, szText, <span class="number">-1</span>, &amp;rect,<span class="comment">//椭圆中心写字</span></span><br><span class="line">                    DT_SINGLELINE | DT_CENTER | DT_VCENTER) ;</span><br><span class="line">          </span><br><span class="line">          DeleteObject (SelectObject (hdc, hBrush)) ;</span><br><span class="line">          </span><br><span class="line">          EndPaint (hwnd, &amp;ps) ;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">          </span><br><span class="line">     <span class="keyword">case</span> WM_KEYUP :</span><br><span class="line">          <span class="keyword">if</span> (wParam != VK_SPACE)<span class="comment">//按下空格键相当于按下鼠标左键,其他键忽略,交给DefWindowProc处理</span></span><br><span class="line">               <span class="keyword">break</span> ;</span><br><span class="line">                                             <span class="comment">// fall through</span></span><br><span class="line">     <span class="keyword">case</span> WM_LBUTTONUP :</span><br><span class="line">          SendMessage (GetParent (hwnd), WM_COMMAND,<span class="comment">//向父窗口即对话框发送WM_COMMAND消息,消息内容是本按钮的id</span></span><br><span class="line">               GetWindowLong (hwnd, GWL_ID), (LPARAM) hwnd) ;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> DefWindowProc (hwnd, message, wParam, lParam) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="非模态对话框"><a href="#非模态对话框" class="headerlink" title="非模态对话框"></a>非模态对话框</h2><p>非模态对话框就是可以不理会对话框内容继续和父窗口交互</p>
<p>一般Ctrl+F召唤的查找框就是非模态的</p>
<p>使用CreateDialogA函数创建非模态对话框</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateDialogA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional]  hInstance,</span></span><br><span class="line"><span class="params">  [in]            lpName,<span class="comment">//对话框类名,或者类句柄</span></span></span><br><span class="line"><span class="params">  [in, optional]  hWndParent,<span class="comment">//父窗口句柄</span></span></span><br><span class="line"><span class="params">  [in, optional]  lpDialogFunc<span class="comment">//对话框回调函数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="COLORS"><a href="#COLORS" class="headerlink" title="COLORS"></a>COLORS</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span>;</span><br><span class="line">BOOL    CALLBACK <span class="title function_">ColorScrDlg</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span>;</span><br><span class="line"></span><br><span class="line">HWND hDlgModeless;	<span class="comment">//非模态对话框的全局句柄,对任意函数可见,</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance,</span></span><br><span class="line"><span class="params">	PSTR szCmdLine, <span class="type">int</span> iCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> TCHAR szAppName[] = TEXT(<span class="string">&quot;Colors2&quot;</span>);</span><br><span class="line">	HWND         hwnd;</span><br><span class="line">	MSG          msg;</span><br><span class="line">	WNDCLASS     wndclass;</span><br><span class="line"></span><br><span class="line">	wndclass.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">	wndclass.lpfnWndProc = WndProc;</span><br><span class="line">	wndclass.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">	wndclass.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">	wndclass.hInstance = hInstance;</span><br><span class="line">	wndclass.hIcon = LoadIcon(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line">	wndclass.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">	wndclass.hbrBackground = CreateSolidBrush(<span class="number">0L</span>);</span><br><span class="line">	wndclass.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">	wndclass.lpszClassName = szAppName;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!RegisterClass(&amp;wndclass))</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;This program requires Windows NT!&quot;</span>),</span><br><span class="line">			szAppName, MB_ICONERROR);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hwnd = CreateWindow(</span><br><span class="line">		szAppName, TEXT(<span class="string">&quot;Color Scroll&quot;</span>),</span><br><span class="line">		WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,<span class="comment">//不擦除子窗口的情况下,重绘父窗口</span></span><br><span class="line">		CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">		CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">		<span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	ShowWindow(hwnd, iCmdShow);</span><br><span class="line">	UpdateWindow(hwnd);</span><br><span class="line"></span><br><span class="line">	hDlgModeless = CreateDialog(hInstance, TEXT(<span class="string">&quot;ColorScrDlg&quot;</span>), hwnd, ColorScrDlg);<span class="comment">//在winMain中创建非模态对话框,使用字符串索引资源,注册非模态对话框过程ColorScrDlg</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (hDlgModeless == <span class="number">0</span> || !IsDialogMessage(hDlgModeless, &amp;msg))</span><br><span class="line">		&#123;</span><br><span class="line">			TranslateMessage(&amp;msg);</span><br><span class="line">			DispatchMessage(&amp;msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (message)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">		DeleteObject((HGDIOBJ)SetClassLong(hwnd, GCL_HBRBACKGROUND,(LONG)GetStockObject(WHITE_BRUSH)));<span class="comment">//删除注册窗口类时创建的逻辑画刷,避免内存泄漏</span></span><br><span class="line">		PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL CALLBACK <span class="title function_">ColorScrDlg</span><span class="params">(HWND hDlg, UINT message,</span></span><br><span class="line"><span class="params">	WPARAM wParam, LPARAM lParam)</span><span class="comment">//对话框过程回调</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> iColor[<span class="number">3</span>];</span><br><span class="line">	HWND       hwndParent, hCtrl;</span><br><span class="line">	<span class="type">int</span>        iCtrlID, iIndex;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (message)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_INITDIALOG:<span class="comment">//初始化对话框</span></span><br><span class="line">		<span class="keyword">for</span> (iCtrlID = <span class="number">10</span>; iCtrlID &lt; <span class="number">13</span>; iCtrlID++)<span class="comment">//三个滚动条的ID分别是10,11,12</span></span><br><span class="line">		&#123;</span><br><span class="line">			hCtrl = GetDlgItem(hDlg, iCtrlID);<span class="comment">//获取hDlg句柄对应的对话框上,ID是iCtrlID的控件的句柄,即滚动条控件的句柄</span></span><br><span class="line">			SetScrollRange(hCtrl, SB_CTL, <span class="number">0</span>, <span class="number">255</span>, FALSE);<span class="comment">//设置滚动条范围0到255,恰好是RGB值的范围</span></span><br><span class="line">			SetScrollPos(hCtrl, SB_CTL, <span class="number">0</span>, FALSE);<span class="comment">//设置滑块初始位置在0上</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_VSCROLL:</span><br><span class="line">		hCtrl = (HWND)lParam;<span class="comment">//是三个滚动条中的哪一个产生的消息</span></span><br><span class="line">		iCtrlID = GetWindowLong(hCtrl, GWL_ID);<span class="comment">//获取id</span></span><br><span class="line">		iIndex = iCtrlID - <span class="number">10</span>;<span class="comment">//转换成0,1,2下标//该下标用于索引iColor数组,iColor[0]表示红色色度条//同时iColor[0]值也表示了该条上的滑块位置</span></span><br><span class="line">		hwndParent = GetParent(hDlg);<span class="comment">//获取父窗口也就是主窗口句柄</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (LOWORD(wParam))</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> SB_PAGEDOWN:</span><br><span class="line">			iColor[iIndex] += <span class="number">15</span>;        <span class="comment">// fall through//一页是滚动15+1个单位,但是最大不能超过255个单位</span></span><br><span class="line">		<span class="keyword">case</span> SB_LINEDOWN:</span><br><span class="line">			iColor[iIndex] = min(<span class="number">255</span>, iColor[iIndex] + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_PAGEUP:</span><br><span class="line">			iColor[iIndex] -= <span class="number">15</span>;        <span class="comment">// fall through</span></span><br><span class="line">		<span class="keyword">case</span> SB_LINEUP:</span><br><span class="line">			iColor[iIndex] = max(<span class="number">0</span>, iColor[iIndex] - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_TOP:</span><br><span class="line">			iColor[iIndex] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_BOTTOM:</span><br><span class="line">			iColor[iIndex] = <span class="number">255</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_THUMBPOSITION:</span><br><span class="line">		<span class="keyword">case</span> SB_THUMBTRACK:<span class="comment">//拖动滑块</span></span><br><span class="line">			iColor[iIndex] = HIWORD(wParam);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">		SetScrollPos(hCtrl, SB_CTL, iColor[iIndex], TRUE);<span class="comment">//设置滑块位置</span></span><br><span class="line">		SetDlgItemInt(hDlg, iCtrlID + <span class="number">3</span>, iColor[iIndex], FALSE);<span class="comment">//设置对话框控件文本,也就是表明当前色度的数值</span></span><br><span class="line">							<span class="comment">//+3是将滚动条号转化为其上的解释性文字的id</span></span><br><span class="line"></span><br><span class="line">		DeleteObject((HGDIOBJ)SetClassLong(hwndParent, GCL_HBRBACKGROUND,<span class="comment">//删除旧背景颜色</span></span><br><span class="line">			(LONG)CreateSolidBrush(RGB(iColor[<span class="number">0</span>], iColor[<span class="number">1</span>], iColor[<span class="number">2</span>]))));<span class="comment">//更新新背景颜色</span></span><br><span class="line"></span><br><span class="line">		InvalidateRect(hwndParent, <span class="literal">NULL</span>, TRUE);<span class="comment">//父窗口全部失效,立刻通知重绘</span></span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="对话框资源"><a href="#对话框资源" class="headerlink" title="对话框资源"></a>对话框资源</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">COLORSCRDLG DIALOG DISCARDABLE  <span class="number">16</span>, <span class="number">16</span>, <span class="number">120</span>, <span class="number">141</span>	<span class="comment">//对话框名叫&quot;COLORSCRDLG&quot;</span></span><br><span class="line">STYLE DS_MODALFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION	<span class="comment">//非模态,弹出,可见,有标题</span></span><br><span class="line">CAPTION <span class="string">&quot;Color Scroll Scrollbars&quot;</span>		<span class="comment">//对话框标题</span></span><br><span class="line">FONT <span class="number">8</span>, <span class="string">&quot;MS Sans Serif&quot;</span>	<span class="comment">//字号字体</span></span><br><span class="line">BEGIN</span><br><span class="line">    CTEXT           <span class="string">&quot;&amp;Red&quot;</span>,IDC_STATIC,<span class="number">8</span>,<span class="number">8</span>,<span class="number">24</span>,<span class="number">8</span>,NOT WS_GROUP	<span class="comment">//滚动条两头的解释性文字,没有逻辑作用</span></span><br><span class="line">    SCROLLBAR       <span class="number">10</span>,<span class="number">8</span>,<span class="number">20</span>,<span class="number">24</span>,<span class="number">100</span>,SBS_VERT | WS_TABSTOP	<span class="comment">//滚动条,	数值方向滚动,制表停留</span></span><br><span class="line">    CTEXT           <span class="string">&quot;0&quot;</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">124</span>,<span class="number">24</span>,<span class="number">8</span>,NOT WS_GROUP</span><br><span class="line">    CTEXT           <span class="string">&quot;&amp;Green&quot;</span>,IDC_STATIC,<span class="number">48</span>,<span class="number">8</span>,<span class="number">24</span>,<span class="number">8</span>,NOT WS_GROUP</span><br><span class="line">    SCROLLBAR       <span class="number">11</span>,<span class="number">48</span>,<span class="number">20</span>,<span class="number">24</span>,<span class="number">100</span>,SBS_VERT | WS_TABSTOP</span><br><span class="line">    CTEXT           <span class="string">&quot;0&quot;</span>,<span class="number">14</span>,<span class="number">48</span>,<span class="number">124</span>,<span class="number">24</span>,<span class="number">8</span>,NOT WS_GROUP</span><br><span class="line">    CTEXT           <span class="string">&quot;&amp;Blue&quot;</span>,IDC_STATIC,<span class="number">89</span>,<span class="number">8</span>,<span class="number">24</span>,<span class="number">8</span>,NOT WS_GROUP</span><br><span class="line">    SCROLLBAR       <span class="number">12</span>,<span class="number">89</span>,<span class="number">20</span>,<span class="number">24</span>,<span class="number">100</span>,SBS_VERT | WS_TABSTOP</span><br><span class="line">    CTEXT           <span class="string">&quot;0&quot;</span>,<span class="number">15</span>,<span class="number">89</span>,<span class="number">124</span>,<span class="number">24</span>,<span class="number">8</span>,NOT WS_GROUP</span><br><span class="line">END</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="CreateDialog和DialogBox"><a href="#CreateDialog和DialogBox" class="headerlink" title="CreateDialog和DialogBox"></a>CreateDialog和DialogBox</h4><p>CreateDialog创建非模态对话框的参数和DialogBox创建模态对话框的参数一模一样</p>
<p>两个函数的区别是是否持有控制</p>
<p>DialogBox调用之后控制会从父窗口过程函数转移给对话框过程函数,返回值是一个数</p>
<p>但是CreateDialog会立刻返回对话框的句柄,不会持有控制.</p>
<p>之所以CreateDialog需要返回句柄,是因为非模态对话框的父窗口是可以动的,它可能需要使用对话框句柄</p>
<h4 id="新消息循环"><a href="#新消息循环" class="headerlink" title="新消息循环"></a>新消息循环</h4><p>非模态对话框的消息要进入WinMain中的消息循环,相当于一个子窗口,需要WinMain消息循环分拣派发消息</p>
<blockquote>
<p>但是模态对话框的消息不需要,因为当模态对话框或者的时候,本程序的消息指定都是发往模态对话框的</p>
</blockquote>
<p>考虑非模态对话框的WinMain消息循环就应该:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (GetMessage (&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (hDlgModeless == <span class="number">0</span> || !IsDialogMessage (hDlgModeless, &amp;msg))<span class="comment">//如果没有非模态对话框句柄或者该消息不是非模态对话框的才往下走</span></span><br><span class="line">     &#123;</span><br><span class="line">          TranslateMessage (&amp;msg) ;</span><br><span class="line">          DispatchMessage  (&amp;msg) ;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>IsDialogMessage不止会判断该消息是不是非模态对话框的,并且会把是非模态对话框的消息发送</p>
<p>hDlgModeless是一个对WinMain和对话框过程都可见的全局变量,为啥要对WndProc也可见呢?</p>
<p>得想办法该关闭非模态对话框的时候就得关上吧,这个关闭怎么才能让WinMain知道?</p>
<p>修改hDlgModeless值为NULL,</p>
<p>谁来修改?WndProc吗?WndProc只负责父窗口的逻辑,关于非模态对话框它不管</p>
<p>因此需要非模态对话框自己决定关闭hDlgModeless</p>
<h3 id="COLORS3-但是摆大烂"><a href="#COLORS3-但是摆大烂" class="headerlink" title="COLORS3,但是摆大烂"></a>COLORS3,但是摆大烂</h3><p>windows甚至把专门调色的对话框都准备好了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;commdlg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">WinMain</span> <span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance,</span></span><br><span class="line"><span class="params">                    PSTR szCmdLine, <span class="type">int</span> iCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">static</span> CHOOSECOLOR cc ;</span><br><span class="line">     <span class="type">static</span> COLORREF    crCustColors[<span class="number">16</span>] ;</span><br><span class="line">     cc.lStructSize    = <span class="keyword">sizeof</span> (CHOOSECOLOR) ;</span><br><span class="line">     cc.hwndOwner      = <span class="literal">NULL</span> ;</span><br><span class="line">     cc.hInstance      = <span class="literal">NULL</span> ;</span><br><span class="line">     cc.rgbResult      = RGB (<span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x80</span>) ;</span><br><span class="line">     cc.lpCustColors   = crCustColors ;</span><br><span class="line">     cc.Flags          = CC_RGBINIT | CC_FULLOPEN ;</span><br><span class="line">     cc.lCustData      = <span class="number">0</span> ;</span><br><span class="line">     cc.lpfnHook       = <span class="literal">NULL</span> ;</span><br><span class="line">     cc.lpTemplateName = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> ChooseColor(&amp;cc) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就这么几行实现了一个调色的功能</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220824160618978.png" alt="image-20220824160618978"></p>
<p>在老版本的windows绘图上,就是用的这个调色板,比如windows7上的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220824160851851.png" alt="这不win7调色板吗,几天没见,这么拉了"></p>
<p>实际上是调用<code>ChooseColor(&amp;cc)</code>函数完成的,只需要给这个函数传递一个CHOOSECOLOR指针,就可以使用面板交互方式调制颜色了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagCHOOSECOLORW</span> &#123;</span></span><br><span class="line">  DWORD        lStructSize;<span class="comment">//本结构体大小,冗余量</span></span><br><span class="line">  HWND         hwndOwner;<span class="comment">//调用ChooseColor函数产生的对话框的父窗口</span></span><br><span class="line">  HWND         hInstance;<span class="comment">//应用程序实例</span></span><br><span class="line">  COLORREF     rgbResult;<span class="comment">//RGB值,初始化一开始显式的颜色值</span></span><br><span class="line">  COLORREF     *lpCustColors;<span class="comment">//16色值,灰度,用于LowB电脑</span></span><br><span class="line">  DWORD        Flags;<span class="comment">//样式</span></span><br><span class="line">  LPARAM       lCustData;<span class="comment">//钩子过程参数</span></span><br><span class="line">  LPCCHOOKPROC lpfnHook;<span class="comment">//钩子回调函数,需要Flags上置起CC_ENABLEHOOK标志</span></span><br><span class="line">  LPCWSTR      lpTemplateName;<span class="comment">//类名称或者ID</span></span><br><span class="line">  LPEDITMENU   lpEditInfo;</span><br><span class="line">&#125; CHOOSECOLORW, *LPCHOOSECOLORW;</span><br></pre></td></tr></table></figure>



<h3 id="HEXCALC"><a href="#HEXCALC" class="headerlink" title="HEXCALC"></a>HEXCALC</h3><p>不到150行源代码实现一个16进制计算器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span> <span class="params">(HWND, UINT, WPARAM, LPARAM)</span> ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">WinMain</span> <span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance,</span></span><br><span class="line"><span class="params">                    PSTR szCmdLine, <span class="type">int</span> iCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">static</span> TCHAR szAppName[] = TEXT (<span class="string">&quot;HexCalc&quot;</span>) ;</span><br><span class="line">     HWND         hwnd ;</span><br><span class="line">     MSG          msg ;</span><br><span class="line">     WNDCLASS     wndclass ;</span><br><span class="line">     </span><br><span class="line">     wndclass.style         = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">     wndclass.lpfnWndProc   = WndProc ;</span><br><span class="line">     wndclass.cbClsExtra    = <span class="number">0</span> ;</span><br><span class="line">     wndclass.cbWndExtra    = DLGWINDOWEXTRA ;    <span class="comment">// Note!//30bytes</span></span><br><span class="line">     wndclass.hInstance     = hInstance ;</span><br><span class="line">     wndclass.hIcon         = LoadIcon (hInstance, szAppName) ;</span><br><span class="line">     wndclass.hCursor       = LoadCursor (<span class="literal">NULL</span>, IDC_ARROW) ;</span><br><span class="line">     wndclass.hbrBackground = (HBRUSH) (COLOR_BTNFACE + <span class="number">1</span>) ;</span><br><span class="line">     wndclass.lpszMenuName  = <span class="literal">NULL</span> ;</span><br><span class="line">     wndclass.lpszClassName = szAppName ;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> (!RegisterClass (&amp;wndclass))</span><br><span class="line">     &#123;</span><br><span class="line">          MessageBox (<span class="literal">NULL</span>, TEXT (<span class="string">&quot;This program requires Windows NT!&quot;</span>),</span><br><span class="line">                      szAppName, MB_ICONERROR) ;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     hwnd = CreateDialog (hInstance, szAppName, <span class="number">0</span>, <span class="literal">NULL</span>) ;<span class="comment">//创建非模态对话框</span></span><br><span class="line">     </span><br><span class="line">     ShowWindow (hwnd, iCmdShow) ;<span class="comment">//把对话框作为窗口</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">while</span> (GetMessage (&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">          TranslateMessage (&amp;msg) ;</span><br><span class="line">          DispatchMessage (&amp;msg) ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> msg.wParam ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowNumber</span> <span class="params">(HWND hwnd, UINT iNumber)</span></span><br><span class="line">&#123;</span><br><span class="line">     TCHAR szBuffer[<span class="number">20</span>] ;</span><br><span class="line"></span><br><span class="line">     wsprintf (szBuffer, TEXT (<span class="string">&quot;%X&quot;</span>), iNumber) ;</span><br><span class="line">     SetDlgItemText (hwnd, VK_ESCAPE, szBuffer) ;<span class="comment">//设置VK_ESCAPE控件的描述字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD <span class="title function_">CalcIt</span> <span class="params">(UINT iFirstNum, <span class="type">int</span> iOperation, UINT iNum)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">switch</span> (iOperation)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>: <span class="keyword">return</span> iNum ;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> iFirstNum +  iNum ;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> iFirstNum -  iNum ;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> iFirstNum *  iNum ;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>: <span class="keyword">return</span> iFirstNum &amp;  iNum ;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>: <span class="keyword">return</span> iFirstNum |  iNum ;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>: <span class="keyword">return</span> iFirstNum ^  iNum ;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>: <span class="keyword">return</span> iFirstNum &lt;&lt; iNum ;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>: <span class="keyword">return</span> iFirstNum &gt;&gt; iNum ;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> iNum ? iFirstNum / iNum: MAXDWORD ;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>: <span class="keyword">return</span> iNum ? iFirstNum % iNum: MAXDWORD ;</span><br><span class="line">     <span class="keyword">default</span> : <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span> <span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">static</span> BOOL  bNewNumber = TRUE ;</span><br><span class="line">     <span class="type">static</span> <span class="type">int</span>   iOperation = <span class="string">&#x27;=&#x27;</span> ;</span><br><span class="line">     <span class="type">static</span> UINT  iNumber, iFirstNum ;</span><br><span class="line">     HWND         hButton ;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">switch</span> (message)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">case</span> WM_KEYDOWN:                   <span class="comment">// left arrow --&gt; backspace</span></span><br><span class="line">          <span class="keyword">if</span> (wParam != VK_LEFT)</span><br><span class="line">               <span class="keyword">break</span> ;</span><br><span class="line">          wParam = VK_BACK ;</span><br><span class="line">                                        <span class="comment">// fall through</span></span><br><span class="line">     <span class="keyword">case</span> WM_CHAR:</span><br><span class="line">          <span class="keyword">if</span> ((wParam = (WPARAM) CharUpper ((TCHAR *) wParam)) == VK_RETURN)</span><br><span class="line">               wParam = <span class="string">&#x27;=&#x27;</span> ;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span> (hButton = GetDlgItem (hwnd, wParam))<span class="comment">//字符消息的wParam就是字符的ASCII码,而对话框脚本中我们也把按钮的ID设置成了对应字符的ASCII码</span></span><br><span class="line">          &#123;</span><br><span class="line">               SendMessage (hButton, BM_SETSTATE, <span class="number">1</span>, <span class="number">0</span>) ;<span class="comment">//按下状态</span></span><br><span class="line">               Sleep (<span class="number">100</span>) ;<span class="comment">//按下状态持续0.1秒,让人能看见</span></span><br><span class="line">               SendMessage (hButton, BM_SETSTATE, <span class="number">0</span>, <span class="number">0</span>) ;<span class="comment">//起来</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">               MessageBeep (<span class="number">0</span>) ;<span class="comment">//没点到按钮就叫唤</span></span><br><span class="line">               <span class="keyword">break</span> ;</span><br><span class="line">          &#125;</span><br><span class="line">                                        <span class="comment">// fall through</span></span><br><span class="line">     <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">          SetFocus (hwnd) ;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span> (LOWORD (wParam) == VK_BACK)         <span class="comment">// backspace</span></span><br><span class="line">               ShowNumber (hwnd, iNumber /= <span class="number">16</span>) ;<span class="comment">//16进制数右移一位</span></span><br><span class="line">          </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (LOWORD (wParam) == VK_ESCAPE)  <span class="comment">// escape</span></span><br><span class="line">               ShowNumber (hwnd, iNumber = <span class="number">0</span>) ;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isxdigit</span> (LOWORD (wParam)))    <span class="comment">// hex digit//判断是否是16进制数,0-9,A-F</span></span><br><span class="line">          &#123;</span><br><span class="line">               <span class="keyword">if</span> (bNewNumber)<span class="comment">//如果是新的计算局面</span></span><br><span class="line">               &#123;</span><br><span class="line">                    iFirstNum = iNumber ;<span class="comment">//第一个操作数置为iNumber</span></span><br><span class="line">                    iNumber = <span class="number">0</span> ;<span class="comment">//第二个操作数尚未到来,虚位以待</span></span><br><span class="line">               &#125;</span><br><span class="line">               bNewNumber = FALSE ;<span class="comment">//置局面混乱</span></span><br><span class="line">               </span><br><span class="line">               <span class="keyword">if</span> (iNumber &lt;= MAXDWORD &gt;&gt; <span class="number">4</span>)</span><br><span class="line">                    ShowNumber (hwnd, iNumber = <span class="number">16</span> * iNumber + wParam -</span><br><span class="line">                    (<span class="built_in">isdigit</span> (wParam) ? <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;A&#x27;</span> - <span class="number">10</span>)) ;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                    MessageBeep (<span class="number">0</span>) ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span>                                    <span class="comment">// operation</span></span><br><span class="line">          &#123;</span><br><span class="line">               <span class="keyword">if</span> (!bNewNumber)<span class="comment">//如果不是16进制数,即不是操作数,那就是操作符了</span></span><br><span class="line">                    ShowNumber (hwnd, iNumber =CalcIt (iFirstNum, iOperation, iNumber)) ;</span><br><span class="line">               bNewNumber = TRUE ;</span><br><span class="line">               iOperation = LOWORD (wParam) ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">          </span><br><span class="line">     <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">          PostQuitMessage (<span class="number">0</span>) ;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> DefWindowProc (hwnd, message, wParam, lParam) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="窗口额外"><a href="#窗口额外" class="headerlink" title="窗口额外"></a>窗口额外</h4><p>cbClsExtra ：windows程序为每一个窗口设计类管理一个WNDCLASS结构。在应用程序注册一个窗口类的时候，可以让windows分配一定字节空间的内存，这部分内存成为类的附件内存，有属于这个窗口类的所有窗口共享，类附件内存信息用于存储窗口类的附加信息。windows系统将这部分内存初始化为0，因此我们经常设置此参数为0.</p>
<p>cbWndExtra :windows程序为每一个窗口管理一个内部数据结构，在注册窗口类的时候，系统可以为每一个窗口分配一定的字节数的附加内存空间，称为窗口附件内存。应用程序可使用这部分内存存储窗口特有的数据，windows系统把这部分内存初始化为0.</p>
<h4 id="HEXCALC-DLG"><a href="#HEXCALC-DLG" class="headerlink" title="HEXCALC.DLG"></a>HEXCALC.DLG</h4><p>这个文件不在rc文件中,而是独立成文件,然后被包含进入RC文件</p>
<p>为啥不能直接放到RC里呢?因为visual studio没有添加对话框资源的选项</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220824165419486.png" alt="image-20220824165419486"></p>
<p>这个对话框脚本是手打的,然后在资源脚本RC中导入:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> TEXTINCLUDE DISCARDABLE </span><br><span class="line">BEGIN</span><br><span class="line">    <span class="string">&quot;#include &quot;</span><span class="string">&quot;hexcalc.dlg&quot;</span><span class="string">&quot;\r\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\0&quot;</span></span><br><span class="line">END</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------</span></span><br><span class="line"><span class="comment">   HEXCALC.DLG dialog script</span></span><br><span class="line"><span class="comment">  ---------------------------*/</span></span><br><span class="line"></span><br><span class="line">HexCalc DIALOG <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">102</span>, <span class="number">122</span></span><br><span class="line">STYLE WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX<span class="comment">//层叠,标题,系统菜单,最小方框</span></span><br><span class="line">CLASS <span class="string">&quot;HexCalc&quot;</span><span class="comment">//类名HexCalc</span></span><br><span class="line">CAPTION <span class="string">&quot;Hex Calculator&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">     PUSHBUTTON <span class="string">&quot;D&quot;</span>,       <span class="number">68</span>,  <span class="number">8</span>,  <span class="number">24</span>, <span class="number">14</span>, <span class="number">14</span><span class="comment">//按钮 &quot;D&quot;,字符68位置(8,24)宽高14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;A&quot;</span>,       <span class="number">65</span>,  <span class="number">8</span>,  <span class="number">40</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;7&quot;</span>,       <span class="number">55</span>,  <span class="number">8</span>,  <span class="number">56</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;4&quot;</span>,       <span class="number">52</span>,  <span class="number">8</span>,  <span class="number">72</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;1&quot;</span>,       <span class="number">49</span>,  <span class="number">8</span>,  <span class="number">88</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;0&quot;</span>,       <span class="number">48</span>,  <span class="number">8</span>, <span class="number">104</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;0&quot;</span>,       <span class="number">27</span>, <span class="number">26</span>,   <span class="number">4</span>, <span class="number">50</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;E&quot;</span>,       <span class="number">69</span>, <span class="number">26</span>,  <span class="number">24</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;B&quot;</span>,       <span class="number">66</span>, <span class="number">26</span>,  <span class="number">40</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;8&quot;</span>,       <span class="number">56</span>, <span class="number">26</span>,  <span class="number">56</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;5&quot;</span>,       <span class="number">53</span>, <span class="number">26</span>,  <span class="number">72</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;2&quot;</span>,       <span class="number">50</span>, <span class="number">26</span>,  <span class="number">88</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;Back&quot;</span>,     <span class="number">8</span>, <span class="number">26</span>, <span class="number">104</span>, <span class="number">32</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;C&quot;</span>,       <span class="number">67</span>, <span class="number">44</span>,  <span class="number">40</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;F&quot;</span>,       <span class="number">70</span>, <span class="number">44</span>,  <span class="number">24</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;9&quot;</span>,       <span class="number">57</span>, <span class="number">44</span>,  <span class="number">56</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;6&quot;</span>,       <span class="number">54</span>, <span class="number">44</span>,  <span class="number">72</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;3&quot;</span>,       <span class="number">51</span>, <span class="number">44</span>,  <span class="number">88</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;+&quot;</span>,       <span class="number">43</span>, <span class="number">62</span>,  <span class="number">24</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;-&quot;</span>,       <span class="number">45</span>, <span class="number">62</span>,  <span class="number">40</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;*&quot;</span>,       <span class="number">42</span>, <span class="number">62</span>,  <span class="number">56</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;/&quot;</span>,       <span class="number">47</span>, <span class="number">62</span>,  <span class="number">72</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;%&quot;</span>,       <span class="number">37</span>, <span class="number">62</span>,  <span class="number">88</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;Equals&quot;</span>,  <span class="number">61</span>, <span class="number">62</span>, <span class="number">104</span>, <span class="number">32</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;&amp;&amp;&quot;</span>,      <span class="number">38</span>, <span class="number">80</span>,  <span class="number">24</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;|&quot;</span>,      <span class="number">124</span>, <span class="number">80</span>,  <span class="number">40</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;^&quot;</span>,       <span class="number">94</span>, <span class="number">80</span>,  <span class="number">56</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;&lt;&quot;</span>,       <span class="number">60</span>, <span class="number">80</span>,  <span class="number">72</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">     PUSHBUTTON <span class="string">&quot;&gt;&quot;</span>,       <span class="number">62</span>, <span class="number">80</span>,  <span class="number">88</span>, <span class="number">14</span>, <span class="number">14</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>全是按钮的对话框,但是没有定义动作,我们需要给每个按钮按下之后的效果编程</p>
<p>这个怎么实现的呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CHAR:</span><br><span class="line">     <span class="keyword">if</span> ((wParam = (WPARAM) CharUpper ((TCHAR *) wParam)) == VK_RETURN)</span><br><span class="line">          wParam = <span class="string">&#x27;=&#x27;</span> ;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> (hButton = GetDlgItem (hwnd, wParam))<span class="comment">//字符消息的wParam就是字符的ASCII码,而对话框脚本中我们也把按钮的ID设置成了对应字符的ASCII码</span></span><br><span class="line">     &#123;</span><br><span class="line">          SendMessage (hButton, BM_SETSTATE, <span class="number">1</span>, <span class="number">0</span>) ;<span class="comment">//按下状态</span></span><br><span class="line">          Sleep (<span class="number">100</span>) ;<span class="comment">//按下状态持续0.1秒,让人能看见,知道自己按下去了</span></span><br><span class="line">          SendMessage (hButton, BM_SETSTATE, <span class="number">0</span>, <span class="number">0</span>) ;<span class="comment">//起来</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          MessageBeep (<span class="number">0</span>) ;<span class="comment">//没点到按钮就叫唤</span></span><br><span class="line">          <span class="keyword">break</span> ;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>对话框脚本中故意设置按钮id和ASCII字符编码相同,因此非常方便</p>
<h2 id="对话框模板"><a href="#对话框模板" class="headerlink" title="对话框模板"></a>对话框模板</h2><p>在COLORS3中,我们已经看到摆烂的力量,像调色板这种对话框模板再来一万个也不多</p>
<p>比如查找替换对话框</p>
<p>这些预定义好的对话框模板,都是以一个函数传递一个结构体指针创建的,这些结构体在commdlg.h中</p>
<p>用啥查啥的文档吧</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/08/23/windows%20SDK%20chapter%2010%20%E8%8F%9C%E5%8D%95%E4%B8%8E%E8%B5%84%E6%BA%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/23/windows%20SDK%20chapter%2010%20%E8%8F%9C%E5%8D%95%E4%B8%8E%E8%B5%84%E6%BA%90/" class="post-title-link" itemprop="url">win32程序设计-chapter10 菜单</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-23 16:09:00 / Modified: 16:09:30" itemprop="dateCreated datePublished" datetime="2022-08-23T16:09:00+08:00">2022-08-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="windows-SDK-chapter-10-菜单与资源"><a href="#windows-SDK-chapter-10-菜单与资源" class="headerlink" title="windows SDK chapter 10 菜单与资源"></a>windows SDK chapter 10 菜单与资源</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>图标光标等资源不是重点,重点在菜单</p>
<p>图标,光标,菜单,对话框都是资源类型.<strong>保存在.exe或者.dll等文件中</strong>.程序使用函数显式或者隐式地将资源加载进入内存使用,比如LoadIcon和LoadCursor</p>
<p>注意到资源是保存在exe或者dll文件中的,这意味着,不需要另外保存bmp或者ico等文件格式了,要啥直接放到到exe文件中,万事不求人了</p>
<h3 id="资源脚本"><a href="#资源脚本" class="headerlink" title="资源脚本"></a>资源脚本</h3><p>资源脚本以.RC为后缀</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220821171827617.png" alt="image-20220821171827617"></p>
<p>在visual studio解决方案视图下,它是这样的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220821171915530.png" alt="image-20220821171915530"></p>
<p>如果用其他文本编辑器比如vscode打开ICONDEMO.rc,他实际上时类似于头文件的代码</p>
<p>它不存放任何资源文件,但是指出这些文件的路径还有ID编号</p>
<p>其中菜单的结构最明显</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Microsoft Visual C++ 生成的资源脚本。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APSTUDIO_READONLY_SYMBOLS</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 从 TEXTINCLUDE 资源生成。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> APSTUDIO_INVOKED</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;targetver.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APSTUDIO_HIDDEN_SYMBOLS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> APSTUDIO_HIDDEN_SYMBOLS</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> APSTUDIO_READONLY_SYMBOLS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)</span></span><br><span class="line">LANGUAGE <span class="number">4</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 图标</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID 值最低的图标放在最前面，以确保应用程序图标</span></span><br><span class="line"><span class="comment">// 在所有系统中保持一致。</span></span><br><span class="line"></span><br><span class="line">IDI_ICONDEMO       ICON         <span class="string">&quot;ICONDEMO.ico&quot;</span></span><br><span class="line">IDI_SMALL               ICON         <span class="string">&quot;small.ico&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 菜单</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">IDC_ICONDEMO MENU</span><br><span class="line">BEGIN</span><br><span class="line">    POPUP <span class="string">&quot;文件(&amp;F)&quot;</span></span><br><span class="line">    BEGIN</span><br><span class="line">        MENUITEM <span class="string">&quot;退出(&amp;X)&quot;</span>,                IDM_EXIT</span><br><span class="line">    END</span><br><span class="line">    POPUP <span class="string">&quot;帮助(&amp;H)&quot;</span></span><br><span class="line">    BEGIN</span><br><span class="line">        MENUITEM <span class="string">&quot;关于(&amp;A) ...&quot;</span>,           IDM_ABOUT</span><br><span class="line">    END</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>资源脚本.rc文件引用了<code>Resource.h</code>头文件,which是给资源编号的,每个资源有唯一的编号方便过程函数按图索骥</p>
<p>Resource.h允许c源程序和.rc资源描述文件引用相同的符号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&#123;&#123;NO_DEPENDENCIES&#125;&#125;</span></span><br><span class="line"><span class="comment">// Microsoft Visual C++ 生成的包含文件。</span></span><br><span class="line"><span class="comment">// 使用者 ICONDEMO.rc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDS_APP_TITLE			103</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDR_MAINFRAME			128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDD_ICONDEMO_DIALOG	102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDD_ABOUTBOX			103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDM_ABOUT				104</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDM_EXIT				105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDI_ICONDEMO			107</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDI_SMALL				108</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDC_ICONDEMO			109</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDC_MYICON				2</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> IDC_STATIC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDC_STATIC				-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// 新对象的下一组默认值</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> APSTUDIO_INVOKED</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> APSTUDIO_READONLY_SYMBOLS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _APS_NO_MFC					130</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _APS_NEXT_RESOURCE_VALUE	129</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _APS_NEXT_COMMAND_VALUE		32771</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _APS_NEXT_CONTROL_VALUE		1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _APS_NEXT_SYMED_VALUE		110</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>书上给出的忠告是,不要直接修改资源描述文件和资源头文件,让visual studio维护这些东西</p>
<p>visual studio使用RC.EXE工具编译资源在编译阶段把ICONDEMO.rc编译,然后在连接阶段随obj和lib进入exe文件</p>
<h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3><p>怎么绘制图标无所谓,只要是.ico格式的都能当成图标,关键看程序怎么用这个图标</p>
<p>在程序中使用自定义图标,不再使用Load(NULL,IDI_APPLICATION)指定的系统默认图标</p>
<p>应该这样写:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wndclass.hIcon = LoadIcon (hInstance, MAKEINTRESOURCE (IDI_ICON)) ;</span><br></pre></td></tr></table></figure>

<p>意思是往本应用程序实例中加载一个编号为IDI_ICON的图标</p>
<p>在visualstudio项目中可以添加资源</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220821173846421.png" alt="image-20220821173846421"></p>
<p>添加Icon图标资源</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220821173911820.png" alt="image-20220821173911820"></p>
<p>选择<code>32*32</code>,32位色,然后就可以在<code>32*32</code>的格格矩阵上画画了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220821173956694.png" alt="image-20220821173956694"></p>
<p>visual studio顶部会有工具栏</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220821174601043.png" alt="image-20220821174601043"></p>
<p>画完了还得把以前的图标删了,让自己的图标顶置</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220822085630711.png" alt="image-20220822085630711"></p>
<p>然后去资源视图改ID,在画画这里找一年也找不到</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220821175726126.png" alt="image-20220821175726126"></p>
<p>给他改成ID&#x3D;IDI_ICON1,visual studio会自动在rc文件和资源头文件中修改变化的,此时在资源头文件Resource.h中可以看到IDI_ICON1的宏定义了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IDI_ICON1                       129</span></span><br></pre></td></tr></table></figure>

<p>此时在创建窗口类的时候再写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wndclass.hIcon = LoadIcon (hInstance, MAKEINTRESOURCE (IDI_ICON1)) ;</span><br></pre></td></tr></table></figure>

<p>就可以加载图标了</p>
<p>这个图标是放在项目根目录下的,如果删了他,对运行已经编译链接好的程序没有影响,但是再编译时会报错找不到文件</p>
<h3 id="LoadIcon"><a href="#LoadIcon" class="headerlink" title="LoadIcon"></a>LoadIcon</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HICON <span class="title function_">LoadIconA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional] HINSTANCE hInstance,</span></span><br><span class="line"><span class="params">  [in]           LPCSTR    lpIconName</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>hInstance指定图标的文件来源,</p>
<p>NULL则为系统图标</p>
<p>本应用程序实例句柄则为本exe文件中包含的图标</p>
<p>lpIconName指定要加载的图标名.</p>
<p>可以使用字符串,也可以使用MAKEINTERESOURCE宏指定图标的宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAKEINTRESOURCEA(i) ((LPSTR)((ULONG_PTR)((WORD)(i))))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAKEINTRESOURCEW(i) ((LPWSTR)((ULONG_PTR)((WORD)(i))))</span></span><br></pre></td></tr></table></figure>

<p>i先强制转化为WORD类型,这意味着i的有效范围是16位,更高位直接扬了</p>
<p>资源就到此为止吧,再学就不礼貌了,该点菜了</p>
<h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><p>一开始我还想直接看菜单不看前面的图标光标这种资源,看到资源脚本直接蒙蔽了</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>主菜单,顶级菜单:标题栏下面,客户区顶的常驻菜单</p>
<p>子菜单,下拉菜单,弹出菜单:主菜单点击后下拉的菜单.这种菜单可以嵌套多层</p>
<p>状态:菜单有启用,禁用状态,启用时有选中和非选中状态.</p>
<h3 id="菜单结构"><a href="#菜单结构" class="headerlink" title="菜单结构"></a>菜单结构</h3><p>每个菜单项有三个特征定义,分别是菜单显式什么,菜单ID或者句柄,属性</p>
<h3 id="定义菜单"><a href="#定义菜单" class="headerlink" title="定义菜单"></a>定义菜单</h3><p>visual studio中可以向项目添加资源,其中就包括菜单</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220821163145869.png" alt="image-20220821163145869"></p>
<p>编辑菜单的方式是交互式的,右侧的菜单编辑器可以调制菜单属性(幸好一个菜单的属性稀松)</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220821163233880.png" alt="image-20220821163233880"></p>
<h4 id="菜单属性"><a href="#菜单属性" class="headerlink" title="菜单属性"></a>菜单属性</h4><p>能够编辑的菜单属性有12个(实际11个,最下边那个提示是MFC编程用的)</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220821163420651.png" alt="image-20220821163420651"></p>
<p>弹出菜单为TRUE则本菜单可以弹出子菜单</p>
<p>灰显指菜单栏变灰且不活动,即禁用了,点击不会产生WM_COMMAND消息</p>
<p>描述文字就是菜单键上的文字</p>
<blockquote>
<p>如果描述文字前面加上一个&amp;符号,则该菜单项第一个字符会带上下划线,方便Alt更改菜单时索引他就像这样<br><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220821165229684.png" alt="image-20220821165229684"></p>
</blockquote>
<p>已勾选为TRUE则该菜单左侧有一个对号,这是复选标记</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220821163918622.png" alt="image-20220821163918622"></p>
<p>已启用和灰显作用类似,但是只是点了没反应,字体不会变灰</p>
<p>分隔就是把该菜单作为分割线,比如1123和3菜单中间这个杠</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220821164249794.png" alt="image-20220821164249794"></p>
<p>关键是ID,这是窗口过程给该菜单设置逻辑的唯一凭证</p>
<p>这里的ID是宏定义,实际上的数值visualstudio给我们放到Resource.h中了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Microsoft Visual C++ 生成的包含文件。</span></span><br><span class="line"><span class="comment">// 供 chapter10.rc 使用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDC_MYICON                      2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDD_CHAPTER10_DIALOG            102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDS_APP_TITLE                   103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDD_ABOUTBOX                    103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDM_ABOUT                       104</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDM_EXIT                        105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDI_CHAPTER10                   107</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDI_SMALL                       108</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDC_CHAPTER10                   109</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDR_MAINFRAME                   128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDR_MENU1                       129</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ID_32771                        32771</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ID_32772                        32772</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ID_32773                        32773</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ID_32774                        32774</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ID_32775                        32775</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ID_32776                        32776</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ID_32777                        32777</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ID_32778                        32778</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDC_STATIC                      -1</span></span><br></pre></td></tr></table></figure>

<p>如果需要更多的资源则自己添加宏定义</p>
<h3 id="程序中使用菜单"><a href="#程序中使用菜单" class="headerlink" title="程序中使用菜单"></a>程序中使用菜单</h3><p>有多个可以指定菜单的地方,</p>
<p>最初可以指定菜单是在注册窗口类时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wndclass.lpszMenuName   = MAKEINTRESOURCEW(IDC_ICONDEMO);</span><br></pre></td></tr></table></figure>

<p>然后在从创建窗口实例的时候可以指定菜单覆盖窗口类的菜单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,</span><br><span class="line">   CW_USEDEFAULT, <span class="number">0</span>, CW_USEDEFAULT, <span class="number">0</span>, nullptr, hMenu, hInstance, nullptr);</span><br></pre></td></tr></table></figure>

<p>这里hMenu句柄可以是LoadMenu打开的菜单资源</p>
<p>如果CreateWindow这里不指定菜单, 则默认使用窗口类的菜单.否则覆盖之</p>
<p>窗口实例创建之后还有改变菜单的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetMenu(hwnd,hMenu)</span><br></pre></td></tr></table></figure>

<h3 id="菜单和消息"><a href="#菜单和消息" class="headerlink" title="菜单和消息"></a>菜单和消息</h3><h4 id="WM-MENUSELECT"><a href="#WM-MENUSELECT" class="headerlink" title="WM_MENUSELECT"></a>WM_MENUSELECT</h4><p>当鼠标在菜单上移动时产生</p>
<h5 id="LOWORD-wParam-弹出菜单索引或者菜单ID"><a href="#LOWORD-wParam-弹出菜单索引或者菜单ID" class="headerlink" title="LOWORD(wParam) 弹出菜单索引或者菜单ID"></a>LOWORD(wParam) 弹出菜单索引或者菜单ID</h5><h5 id="HIWORD-wParam-选择标记"><a href="#HIWORD-wParam-选择标记" class="headerlink" title="HIWORD(wParam) 选择标记"></a>HIWORD(wParam) 选择标记</h5><table>
<thead>
<tr>
<th align="left">Value</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>MF_BITMAP</strong>0x00000004L</td>
<td align="left">Item displays a bitmap.</td>
</tr>
<tr>
<td align="left"><strong>MF_CHECKED</strong>0x00000008L</td>
<td align="left">Item is checked.</td>
</tr>
<tr>
<td align="left"><strong>MF_DISABLED</strong>0x00000002L</td>
<td align="left">Item is disabled.</td>
</tr>
<tr>
<td align="left"><strong>MF_GRAYED</strong>0x00000001L</td>
<td align="left">Item is grayed.</td>
</tr>
<tr>
<td align="left"><strong>MF_HILITE</strong>0x00000080L</td>
<td align="left">Item is highlighted.</td>
</tr>
<tr>
<td align="left"><strong>MF_MOUSESELECT</strong>0x00008000L</td>
<td align="left">Item is selected with the mouse.</td>
</tr>
<tr>
<td align="left"><strong>MF_OWNERDRAW</strong>0x00000100L</td>
<td align="left">Item is an owner-drawn item.</td>
</tr>
<tr>
<td align="left"><strong>MF_POPUP</strong>0x00000010L</td>
<td align="left">Item opens a drop-down menu or submenu.</td>
</tr>
<tr>
<td align="left"><strong>MF_SYSMENU</strong>0x00002000L</td>
<td align="left">Item is contained in the window menu. The <em>lParam</em> parameter contains a handle to the menu associated with the message.</td>
</tr>
</tbody></table>
<h5 id="lParam-包含所选项的菜单句柄"><a href="#lParam-包含所选项的菜单句柄" class="headerlink" title="lParam 包含所选项的菜单句柄"></a>lParam 包含所选项的菜单句柄</h5><p>该消息用于暂时高亮菜单,显式完整文本描述</p>
<h4 id="WM-COMMAND"><a href="#WM-COMMAND" class="headerlink" title="WM_COMMAND"></a>WM_COMMAND</h4><p>最重要</p>
<p>表示点击了某个启用的菜单</p>
<p>LOWORD(wParam)菜单ID</p>
<p>下面的三个消息几乎用不到</p>
<h4 id="WM-INITMENUPOPUP"><a href="#WM-INITMENUPOPUP" class="headerlink" title="WM_INITMENUPOPUP"></a>WM_INITMENUPOPUP</h4><p>要显示弹出菜单时的消息</p>
<p>wParam弹出菜单的句柄</p>
<p>LOWORD(lParam)弹出菜单的索引</p>
<p>HIWORD(lParam)1系统菜单,0其他菜单</p>
<h4 id="WM-SYSCOMMAND"><a href="#WM-SYSCOMMAND" class="headerlink" title="WM_SYSCOMMAND"></a>WM_SYSCOMMAND</h4><p>点击了系统菜单某个启用的菜单项</p>
<p>LWORD(wParam)菜单ID</p>
<p>LOWORD(lParam)鼠标x坐标,屏幕坐标</p>
<p>HIWORD(lParam)鼠标y坐标</p>
<h4 id="WM-MENUCHAR"><a href="#WM-MENUCHAR" class="headerlink" title="WM_MENUCHAR"></a>WM_MENUCHAR</h4><p>用户按下了Alt和不对应任何菜单项字符键.</p>
<p>或者弹出菜单时按下不对应任何菜单项的字符键</p>
<p>用于程序捕获并提醒快捷键不存在</p>
<p>LOWORD(wParam) 字符码</p>
<p>HIWORD(wParam) 选择吗</p>
<p>lParam 菜单句柄</p>
<p>该消息直接发送给DefWindowProc会导致操作系统MessageBeep</p>
<h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><h4 id="菜单结构-1"><a href="#菜单结构-1" class="headerlink" title="菜单结构"></a>菜单结构</h4><p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220823105251663.png" alt="visual studio中编辑菜单"></p>
<p>使用文本编辑器打开MENUDEMO.rc文件,其菜单结构是按照BEGIN,END分块的</p>
<p>BEGIN,END块可以嵌套,约外层的菜单嵌套层数越低</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">IDC_MENUDEMO MENU</span><br><span class="line">BEGIN</span><br><span class="line">    POPUP <span class="string">&quot;文件(&amp;F)&quot;</span></span><br><span class="line">    BEGIN</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;New&quot;</span>,                        IDM_FILE_NEW</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;Open&quot;</span>,                       IDM_FILE_OPEN</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;Save&quot;</span>,                       IDM_FILE_SAVE</span><br><span class="line">        MENUITEM <span class="string">&quot;Save &amp;As&quot;</span>,                    IDM_FILE_SAVE_AS</span><br><span class="line">        MENUITEM <span class="string">&quot;E&amp;xit&quot;</span>,                       IDM_APP_EXIT</span><br><span class="line">        MENUITEM SEPARATOR</span><br><span class="line">    END</span><br><span class="line">    POPUP <span class="string">&quot;编辑(&amp;E)&quot;</span></span><br><span class="line">    BEGIN</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;Undo&quot;</span>,                       IDM_EDIT_UNDO</span><br><span class="line">        MENUITEM SEPARATOR</span><br><span class="line">        MENUITEM <span class="string">&quot;C&amp;ut&quot;</span>,                        IDM_EDIT_CUT</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;Copy&quot;</span>,                       IDM_EDIT_COPY</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;Paste&quot;</span>,                      IDM_EDIT_PASTE</span><br><span class="line">        MENUITEM <span class="string">&quot;De&amp;lete&quot;</span>,                     IDM_EDIT_CLEAR</span><br><span class="line">    END</span><br><span class="line">    POPUP <span class="string">&quot;背景(&amp;B)&quot;</span></span><br><span class="line">    BEGIN</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;White&quot;</span>,                      IDM_BKGND_WHITE, CHECKED</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;Light Gray&quot;</span>,                 IDM_BKGND_LTGRAY</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;Gray&quot;</span>,                       IDM_BKGND_GRAY</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;Dark Gray&quot;</span>,                  IDM_BKGND_DKGRAY</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;Black&quot;</span>,                      IDM_BKGND_BLACK</span><br><span class="line">    END</span><br><span class="line">    POPUP <span class="string">&quot;计时(&amp;T)&quot;</span></span><br><span class="line">    BEGIN</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;Start&quot;</span>,                      IDM_TIMER_START</span><br><span class="line">        MENUITEM <span class="string">&quot;S&amp;top&quot;</span>,                       IDM_TIMER_STOP, GRAYED</span><br><span class="line">    END</span><br><span class="line">    POPUP <span class="string">&quot;帮助(&amp;H)&quot;</span></span><br><span class="line">    BEGIN</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;Help...&quot;</span>,                    IDM_APP_HELP</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;About MenuDmo...&quot;</span>,           IDM_APP_ABOUT</span><br><span class="line">    END</span><br><span class="line">END</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>菜单项前面加&amp;,是为了加下划线,方便使用快捷键</p>
<p>整个菜单的ID表示在一开始列出了,是IDC_MENUDEMO,该值供注册窗口类或者实例化窗口时引用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IDC_MENUDEMO MENU</span><br><span class="line">    <span class="comment">//标识符	资源类型</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个ID是多少不重要,只要保证每个资源有唯一的ID就可以了,我们只管给资源ID规定宏定义,visualstudio会自动帮我们分配一个正整数的</p>
</blockquote>
<p>此后顶级菜单,即弹出菜单,都会有POPUP声明,然后跟着BEGIN,END作用块</p>
<p>比如<code>POPUP &quot;文件(&amp;F)&quot;</code>,这就声明了一个文件弹出菜单.其后面紧跟着的BEGIN,END包裹的块就是它的弹出菜单项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  POPUP <span class="string">&quot;文件(&amp;F)&quot;</span><span class="comment">//弹出菜单</span></span><br><span class="line">  BEGIN</span><br><span class="line">...弹出菜单项</span><br><span class="line">  END</span><br></pre></td></tr></table></figure>

<p>所有弹出菜单都不能有ID标识,只能是普通菜单项MENUITEM可以有ID标识,比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MENUITEM <span class="string">&quot;&amp;New&quot;</span>,                        IDM_FILE_NEW</span><br></pre></td></tr></table></figure>

<p>因为弹出菜单只负责展示其菜单项,不能安排其他行为</p>
<h4 id="程序中使用菜单-1"><a href="#程序中使用菜单-1" class="headerlink" title="程序中使用菜单"></a>程序中使用菜单</h4><p>visual studio默认建立的资源都是使用ID索引的,没有使用字符串</p>
<p>刚才建立的菜单其ID为<code>IDC_MENUDEMO</code>,怎样才能让窗口使用这个菜单呢?</p>
<p>可以在创建窗口类的时候使用MAKEINTRESOURCE宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wndclass.lpszMenuName = MAKEINTRESOURCE(IDC_MENUDEMO);</span><br></pre></td></tr></table></figure>

<p>也可以在创建窗口实例的时候才指定菜单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wndclass.lpszMenuName = <span class="literal">NULL</span>;<span class="comment">//创建窗口类的时候不指定菜单</span></span><br><span class="line">...</span><br><span class="line">HMENU hMenu = LoadMenu(hInstance, MAKEINTRESOURCE(IDC_MENUDEMO));<span class="comment">//加载菜单句柄</span></span><br><span class="line">hwnd = CreateWindow(szAppName, TEXT(<span class="string">&quot;Menu Demonstration&quot;</span>),</span><br><span class="line">	WS_OVERLAPPEDWINDOW,</span><br><span class="line">	CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">	CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">	<span class="literal">NULL</span>, hMenu, hInstance, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h4 id="菜单消息"><a href="#菜单消息" class="headerlink" title="菜单消息"></a>菜单消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (message)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">	hMenu = GetMenu(hwnd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (LOWORD(wParam))</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> IDM_FILE_NEW:</span><br><span class="line">	<span class="keyword">case</span> IDM_FILE_OPEN:</span><br><span class="line">	<span class="keyword">case</span> IDM_FILE_SAVE:</span><br><span class="line">	<span class="keyword">case</span> IDM_FILE_SAVE_AS:</span><br><span class="line"></span><br><span class="line">		MessageBeep(<span class="number">0</span>);<span class="comment">//蜂鸣</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> IDM_APP_EXIT:</span><br><span class="line">		SendMessage(hwnd, WM_CLOSE, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//发送程序退出关闭消息</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> IDM_EDIT_UNDO:</span><br><span class="line">	<span class="keyword">case</span> IDM_EDIT_CUT:</span><br><span class="line">	<span class="keyword">case</span> IDM_EDIT_COPY:</span><br><span class="line">	<span class="keyword">case</span> IDM_EDIT_PASTE:</span><br><span class="line">	<span class="keyword">case</span> IDM_EDIT_CLEAR:</span><br><span class="line">		MessageBeep(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> IDM_BKGND_WHITE: <span class="comment">// Note: Logic below //各种颜色背景是互斥关系,只能使用一个</span></span><br><span class="line">	<span class="keyword">case</span> IDM_BKGND_LTGRAY: <span class="comment">// assumes that IDM_WHITE </span></span><br><span class="line">	<span class="keyword">case</span> IDM_BKGND_GRAY: <span class="comment">// through IDM_BLACK are </span></span><br><span class="line">	<span class="keyword">case</span> IDM_BKGND_DKGRAY: <span class="comment">// consecutive numbers in </span></span><br><span class="line">	<span class="keyword">case</span> IDM_BKGND_BLACK: <span class="comment">// the order shown here. </span></span><br><span class="line"></span><br><span class="line">		CheckMenuItem(hMenu, iSelection, MF_UNCHECKED);<span class="comment">//原来的选择弃选</span></span><br><span class="line">		iSelection = LOWORD(wParam);<span class="comment">//对于WM_COMMAND消息来说,LOWORD(wParam)=点选菜单ID,这里获取新的点选背景ID</span></span><br><span class="line">		CheckMenuItem(hMenu, iSelection, MF_CHECKED);<span class="comment">//修改新的背景色</span></span><br><span class="line"></span><br><span class="line">		SetClassLong(hwnd, GCL_HBRBACKGROUND, (LONG)GetStockObject(idColor[LOWORD(wParam) - IDM_BKGND_WHITE]));<span class="comment">//修改系统属性,画刷颜色修改为新选中的颜色</span></span><br><span class="line"></span><br><span class="line">		InvalidateRect(hwnd, <span class="literal">NULL</span>, TRUE);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> IDM_TIMER_START:</span><br><span class="line">		<span class="keyword">if</span> (SetTimer(hwnd, ID_TIMER, <span class="number">1000</span>, <span class="literal">NULL</span>))<span class="comment">//开始计时,时钟编号ID_TIMER(1)</span></span><br><span class="line">		&#123;</span><br><span class="line">			EnableMenuItem(hMenu, IDM_TIMER_START, MF_GRAYED);<span class="comment">//禁用</span></span><br><span class="line">			EnableMenuItem(hMenu, IDM_TIMER_STOP, MF_ENABLED);<span class="comment">//启用计时结束实践</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> IDM_TIMER_STOP:</span><br><span class="line">		KillTimer(hwnd, ID_TIMER);<span class="comment">//销毁时钟</span></span><br><span class="line">		EnableMenuItem(hMenu, IDM_TIMER_START, MF_ENABLED);</span><br><span class="line">		EnableMenuItem(hMenu, IDM_TIMER_STOP, MF_GRAYED);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> IDM_APP_HELP:</span><br><span class="line">		MessageBox(hwnd, TEXT(<span class="string">&quot;Help not yet implemented!&quot;</span>),<span class="comment">//摆烂</span></span><br><span class="line">			szAppName, MB_ICONEXCLAMATION | MB_OK);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> IDM_APP_ABOUT:</span><br><span class="line">		MessageBox(hwnd, TEXT(<span class="string">&quot;Menu Demonstration Program\n&quot;</span>)</span><br><span class="line">			TEXT(<span class="string">&quot;(c) Charles Petzold, 1998&quot;</span>),</span><br><span class="line">			szAppName, MB_ICONINFORMATION | MB_OK);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<p>所有点击活动菜单的消息都有一个WM_COMMAND命令</p>
<p>此时其LOWORD(lParam)保存的是击中菜单的ID,如果击中的是弹出菜单则系统负载该逻辑,自动展开菜单,不需要我们指定弹出菜单的行为(事实上弹出菜单不允许拥有ID,这就意味着在程序中无法索引到它,无法安排行为)</p>
<h5 id="复用关闭消息"><a href="#复用关闭消息" class="headerlink" title="复用关闭消息"></a>复用关闭消息</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IDM_APP_EXIT:</span><br><span class="line">	SendMessage(hwnd, WM_CLOSE, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//发送程序退出关闭消息</span></span><br></pre></td></tr></table></figure>

<p>当点击菜单项项时,直接发送一体哦啊WM_CLOSE消息即可借助已有代码完成功能</p>
<h5 id="改变勾选状态"><a href="#改变勾选状态" class="headerlink" title="改变勾选状态"></a>改变勾选状态</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">CheckMenuItem</span><span class="params">(</span></span><br><span class="line"><span class="params">	HMENU hMenu,<span class="comment">//菜单句柄,使用GetMenu(hwnd)获得</span></span></span><br><span class="line"><span class="params">	UINT uIDCheckItem,<span class="comment">//需要修改状态的菜单项ID</span></span></span><br><span class="line"><span class="params">	UINT uCheck<span class="comment">//修改后的状态</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CheckMenuItem(hMenu, iSelection, MF_UNCHECKED);<span class="comment">//原来的选择弃选</span></span><br><span class="line">iSelection = LOWORD(wParam);<span class="comment">//对于WM_COMMAND消息来说,LOWORD(wParam)=点选菜单ID,这里获取新的点选背景ID</span></span><br><span class="line">CheckMenuItem(hMenu, iSelection, MF_CHECKED);<span class="comment">//修改新的背景色</span></span><br><span class="line">SetClassLong(hwnd, GCL_HBRBACKGROUND, (LONG)GetStockObject(idColor[LOWORD(wParam) - IDM_BKGND_WHITE]));<span class="comment">//修改系统属性,画刷颜色修改为新选中的颜色</span></span><br></pre></td></tr></table></figure>

<p>点选新的背景颜色之后,首先弃选先前的背景颜色,然后修改为新的背景颜色</p>
<p>之后修使用SetClassLong改程序的背景颜色</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">SetClassLongA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HWND hWnd,<span class="comment">//需要修改属性的窗口句柄</span></span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>  nIndex,<span class="comment">//需要修改的属性</span></span></span><br><span class="line"><span class="params">  [in] LONG dwNewLong<span class="comment">//该属性的新值</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>





<h2 id="菜单快捷键"><a href="#菜单快捷键" class="headerlink" title="菜单快捷键"></a>菜单快捷键</h2><h3 id="右键菜单"><a href="#右键菜单" class="headerlink" title="右键菜单"></a>右键菜单</h3><p>在处理右键消息的时候可以安排上右键快捷菜单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">TrackPopupMenu</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]           HMENU      hMenu,<span class="comment">//需要显式的菜单句柄</span></span></span><br><span class="line"><span class="params">  [in]           UINT       uFlags,<span class="comment">//点选菜单的方式</span></span></span><br><span class="line"><span class="params">  [in]           <span class="type">int</span>        x,</span></span><br><span class="line"><span class="params">  [in]           <span class="type">int</span>        y,</span></span><br><span class="line"><span class="params">  [in]           <span class="type">int</span>        nReserved,</span></span><br><span class="line"><span class="params">  [in]           HWND       hWnd,</span></span><br><span class="line"><span class="params">  [in, optional] <span class="type">const</span> RECT *prcRect</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>在指定的位置展示一个快捷菜单,并且追踪在该菜单上的选择.</p>
<p>该快捷菜单可以出现在任何地方</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Displays a shortcut menu at the specified location and tracks the selection of items on the menu. The shortcut menu can appear anywhere on the screen.</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line">	hMenu = LoadMenu(hInst, MAKEINTRESOURCE(IDC_MENUDEMO));<span class="comment">//hMenu获取整个菜单句柄</span></span><br><span class="line">	hMenu = GetSubMenu(hMenu, <span class="number">0</span>);<span class="comment">//此时hMenu句柄是第一个顶级菜单的句柄,不是整个菜单的句柄,即文件弹出菜单,如果这里写1则为编辑弹出菜单</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> WM_RBUTTONUP:</span><br><span class="line">	point.x = LOWORD(lParam);</span><br><span class="line">	point.y = HIWORD(lParam);</span><br><span class="line">	ClientToScreen(hwnd, &amp;point);</span><br><span class="line">	TrackPopupMenu(hMenu, TPM_RIGHTBUTTON, point.x, point.y, <span class="number">0</span>, hwnd, <span class="literal">NULL</span>);<span class="comment">//允许使用左键和右键,在本菜单上作用相同</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="键盘加速键"><a href="#键盘加速键" class="headerlink" title="键盘加速键"></a>键盘加速键</h3><p>键盘加速键不是处理WM_KEYDOWN或者WM_CHAR复制键盘功能,当然这样写也能达到相同的目标</p>
<p>但是键盘加速键可以省去其逻辑</p>
<p>此处略去一大堆优点,因为有些优点现在我也体会不到</p>
<p>键盘加速键应当是Shift,Ctrl,Alt带领的跨界见,避免使用Tab,Enter,Esc,Space作键盘加速键</p>
<p>比如Ctrl+Z 撤销,Ctrl+X剪切,Del删除</p>
<h3 id="加速键表"><a href="#加速键表" class="headerlink" title="加速键表"></a>加速键表</h3><p>加速键表也是资源的一种,可以在visual studio中添加Accelerator资源</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220823114008382.png" alt="一方通行"></p>
<p>加速键表长这样</p>
<p>ID就是该加速键的编号,键对应键盘动作,类型要么是虚拟键VIRTKEY,要么是字符CHAR</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220823114110566.png" alt="image-20220823114110566"></p>
<p>如果键盘加速键想要和菜单关联起来,那么一个键盘加速键的ID需要设置成一个菜单项的ID</p>
<p>整个加速键表类似菜单一样,也有自己的一个ID标识,这个可以在资源视图看到</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220823145812581.png" alt="image-20220823145812581"></p>
<p>通常方便使用,加速键表名和程序名,菜单名都相同</p>
<p>有了这个加速键表ID我们就可以在表的层面上和程序打交道,而不是需要负责每个加速键的逻辑.在程序中使用LoadAccelerators函数加载加速键表并获得句柄</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hAccel=LoadAccelerators(hInstance,MAKEINTRESOURCE(IDC_MENUDEMO));</span><br></pre></td></tr></table></figure>

<p>现在程序中就有加速键表句柄了,下面就是如何使用该句柄了</p>
<p>在消息循环翻译分派消息之前先尝试翻译成加速键消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!TranslateAccelerator(hwnd, hAccel, &amp;msg)) &#123;<span class="comment">//此处使用了加速键表句柄hAccel</span></span><br><span class="line">		TranslateMessage(&amp;msg);</span><br><span class="line">		DispatchMessageW(&amp;msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个消息都会先经过一个加速键翻译,TranslateAccelerator函数确定保存在msg中的消息是否是键盘消息(包括虚拟键消息和字符消息),如果是,并且hAccel是一个有效的加速键表句柄,下面就调用hwnd指向窗口的窗口过程,向其发送同键盘加速键ID对应的菜单项按下的WM_COMMAND或者WM_SYSCOMMAND消息</p>
<p>显然这个翻译后的消息还会进入消息队列,但是翻译后的消息是WM_COMMAND消息,不是WM_KEYDOWN,WM_CHAR消息,不会再被TranslateAccelerator翻译,因此通过条件判断,正式进入消息循环处理</p>
<p>注意到<code>TranslateAccelerator(hwnd, hAccel, &amp;msg)</code>这里指定了一个主窗口句柄,但是一个程序可以有多个窗口,这就会导致所有加速键消息发往主窗口.</p>
<p>如果想让一个消息发往现在的焦点窗口,则可以使用msg.hwnd,这个hwnd是目前消息的窗口句柄</p>
<h3 id="处理WM-COMMAND消息"><a href="#处理WM-COMMAND消息" class="headerlink" title="处理WM_COMMAND消息"></a>处理WM_COMMAND消息</h3><p>在处理WM_COMMAND消息时,加速键,菜单,控件消息的参数含义:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220823151633079.png" alt="image-20220823151633079"></p>
<p>如此看来,如果加速键ID和功能表ID故意设置成相同值,就不用大费周折了</p>
<h3 id="例程-1"><a href="#例程-1" class="headerlink" title="例程"></a>例程</h3><h4 id="MENUDEMO2-rc"><a href="#MENUDEMO2-rc" class="headerlink" title="MENUDEMO2.rc"></a>MENUDEMO2.rc</h4><h5 id="菜单表"><a href="#菜单表" class="headerlink" title="菜单表"></a>菜单表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">IDC_MENUDEMO2 MENU</span><br><span class="line">BEGIN</span><br><span class="line">    POPUP <span class="string">&quot;&amp;File&quot;</span></span><br><span class="line">    BEGIN</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;New&quot;</span>,                        IDM_FILE_NEW</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;Open&quot;</span>,                       IDM_FILE_OPEN</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;Save&quot;</span>,                       IDM_FILE_SAVE</span><br><span class="line">        MENUITEM <span class="string">&quot;Save &amp;As&quot;</span>,                    IDM_FILE_SAVE_AS</span><br><span class="line">        MENUITEM SEPARATOR</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;Print&quot;</span>,                      IDM_FILE_PRINT</span><br><span class="line">        MENUITEM SEPARATOR</span><br><span class="line">        MENUITEM <span class="string">&quot;E&amp;xit&quot;</span>,                       IDM_APP_EXIT</span><br><span class="line">    END</span><br><span class="line">    POPUP <span class="string">&quot;&amp;Edit&quot;</span></span><br><span class="line">    BEGIN</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;Undo\tCtrl+Z&quot;</span>,               IDM_EDIT_UNDO</span><br><span class="line">        MENUITEM SEPARATOR</span><br><span class="line">        MENUITEM <span class="string">&quot;Cu&amp;t\tCtrl+X&quot;</span>,                IDM_EDIT_CUT</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;Copy\tCtrl+C&quot;</span>,               IDM_EDIT_COPY</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;Paste\tCtrl+V&quot;</span>,              IDM_EDIT_PASTE</span><br><span class="line">        MENUITEM <span class="string">&quot;De&amp;lete\tDel&quot;</span>,                IDM_EDIT_DELETE</span><br><span class="line">        MENUITEM SEPARATOR</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;Select All&quot;</span>,                 IDM_EDIT_SELECT_ALL</span><br><span class="line">    END</span><br><span class="line">    POPUP <span class="string">&quot;&amp;Help&quot;</span></span><br><span class="line">    BEGIN</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;Help...\tF1&quot;</span>,                IDM_HELP_HELP</span><br><span class="line">        MENUITEM <span class="string">&quot;&amp;About...&quot;</span>,                   IDM_APP_ABOUT</span><br><span class="line">    END</span><br><span class="line">END</span><br></pre></td></tr></table></figure>



<h5 id="加速键表-1"><a href="#加速键表-1" class="headerlink" title="加速键表"></a>加速键表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">IDC_MENUDEMO2 ACCELERATORS</span><br><span class="line">BEGIN</span><br><span class="line">    <span class="string">&quot;8&quot;</span>,            IDM_UNDO,               VIRTKEY, ALT, NOINVERT</span><br><span class="line">    VK_DELETE,      IDM_EDIT_CLEAR,         VIRTKEY, NOINVERT</span><br><span class="line">    VK_DELETE,      IDM_EDIT_CUT,           VIRTKEY, SHIFT, NOINVERT</span><br><span class="line">    VK_F1,          IDM_HELP_HELP,          VIRTKEY, NOINVERT</span><br><span class="line">    VK_INSERT,      IDM_EDIT_COPY,          VIRTKEY, CONTROL, NOINVERT</span><br><span class="line">    VK_INSERT,      IDM_EDIT_PASTE,         VIRTKEY, SHIFT, NOINVERT</span><br><span class="line">    <span class="string">&quot;^C&quot;</span>,           IDM_EDIT_COPY,          ASCII,  NOINVERT</span><br><span class="line">    <span class="string">&quot;^V&quot;</span>,           IDM_EDIT_PASTE,         ASCII,  NOINVERT</span><br><span class="line">    <span class="string">&quot;^X&quot;</span>,           IDM_EDIT_CUT,           ASCII,  NOINVERT</span><br><span class="line">    <span class="string">&quot;^Z&quot;</span>,           IDM_EDIT_UNDO,          ASCII,  NOINVERT</span><br><span class="line">    <span class="string">&quot;^A&quot;</span>,           IDM_EDIT_SELECT_ALL,    ASCII,  NOINVERT</span><br><span class="line">END</span><br></pre></td></tr></table></figure>



<p>菜单名和加速键表ID都是IDC_MENUDEMO2,可以使用MAKEINTRESOURCE宏加载资源</p>
<h4 id="MENUDEMO2-cpp"><a href="#MENUDEMO2-cpp" class="headerlink" title="MENUDEMO2.cpp"></a>MENUDEMO2.cpp</h4><p>使用父窗口控制编辑控件子窗口,大大减轻自己写编辑逻辑的工作量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MENUDEMO2.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ID_EDIT 1 </span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span>;</span><br><span class="line">TCHAR szAppName[] = TEXT(<span class="string">&quot;PopPad2&quot;</span>);</span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, <span class="type">int</span> iCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">	HACCEL hAccel;</span><br><span class="line">	HWND hwnd;</span><br><span class="line">	MSG msg;</span><br><span class="line">	WNDCLASS wndclass;</span><br><span class="line">	wndclass.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">	wndclass.lpfnWndProc = WndProc;</span><br><span class="line">	wndclass.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">	wndclass.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">	wndclass.hInstance = hInstance;</span><br><span class="line">	wndclass.hIcon = LoadIcon(hInstance,szAppName);</span><br><span class="line">	wndclass.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">	wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);</span><br><span class="line">	wndclass.lpszMenuName = MAKEINTRESOURCE(IDC_MENUDEMO2);</span><br><span class="line">	wndclass.lpszClassName = szAppName;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!RegisterClass(&amp;wndclass))</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;This program requires Windows NT!&quot;</span>), szAppName, MB_ICONERROR);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hwnd = CreateWindow(<span class="comment">//创建父窗口</span></span><br><span class="line">		szAppName, szAppName,</span><br><span class="line">		WS_OVERLAPPEDWINDOW,</span><br><span class="line">		GetSystemMetrics(SM_CXSCREEN) / <span class="number">4</span>,</span><br><span class="line">		GetSystemMetrics(SM_CYSCREEN) / <span class="number">4</span>,</span><br><span class="line">		GetSystemMetrics(SM_CXSCREEN) / <span class="number">2</span>,</span><br><span class="line">		GetSystemMetrics(SM_CYSCREEN) / <span class="number">2</span>,</span><br><span class="line">		<span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	ShowWindow(hwnd, iCmdShow);</span><br><span class="line">	UpdateWindow(hwnd);</span><br><span class="line"></span><br><span class="line">	hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MENUDEMO2));<span class="comment">//加载加速键表资源</span></span><br><span class="line">	<span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!TranslateAccelerator(hwnd, hAccel, &amp;msg))<span class="comment">//翻译加速键</span></span><br><span class="line">		&#123;</span><br><span class="line">			TranslateMessage(&amp;msg);</span><br><span class="line">			DispatchMessage(&amp;msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">AskConfirmation</span><span class="params">(HWND hwnd)</span><span class="comment">//关闭父窗口时的询问</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> MessageBox(hwnd, TEXT(<span class="string">&quot;Really want to close PopPad2?&quot;</span>),</span><br><span class="line">		szAppName, MB_YESNO | MB_ICONQUESTION);</span><br><span class="line">&#125;</span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> HWND hwndEdit;</span><br><span class="line">	<span class="type">int</span> iSelect, iEnable;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (message)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_CREATE:</span><br><span class="line">		hwndEdit = CreateWindow(TEXT(<span class="string">&quot;edit&quot;</span>), <span class="literal">NULL</span>,<span class="comment">//创建子窗口,父窗口过程管理子窗口过程,子窗口是预定义好的编辑控件</span></span><br><span class="line">			WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL |<span class="comment">//子窗口|可见|横竖滚动|边框|左对齐|多行|自动滚动</span></span><br><span class="line">			WS_BORDER | ES_LEFT | ES_MULTILINE |</span><br><span class="line">			ES_AUTOHSCROLL | ES_AUTOVSCROLL,</span><br><span class="line">			<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, hwnd, (HMENU)ID_EDIT,<span class="comment">//子窗口ID</span></span><br><span class="line">			((LPCREATESTRUCT)lParam)-&gt;hInstance, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_SETFOCUS:</span><br><span class="line">		SetFocus(hwndEdit);<span class="comment">//父窗口将焦点让给子窗口</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_SIZE:</span><br><span class="line">		MoveWindow(hwndEdit, <span class="number">0</span>, <span class="number">0</span>, LOWORD(lParam), HIWORD(lParam),TRUE);<span class="comment">//父窗口移动子窗口,始终填充整个父窗口的客户区</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_INITMENUPOPUP:<span class="comment">//初始化弹出菜单,每次点击顶级菜单时,在接收到WM_COMMAND之前先接收到WM_INITMENUPOPUP</span></span><br><span class="line">		<span class="keyword">if</span> (lParam == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			EnableMenuItem(</span><br><span class="line">				(HMENU)wParam,IDM_EDIT_UNDO,</span><br><span class="line">				SendMessage(hwndEdit, EM_CANUNDO, <span class="number">0</span>, <span class="number">0</span>) ?</span><br><span class="line">				MF_ENABLED : MF_GRAYED</span><br><span class="line">			);</span><br><span class="line"></span><br><span class="line">			EnableMenuItem((HMENU)wParam,</span><br><span class="line">				IDM_EDIT_PASTE,</span><br><span class="line">				IsClipboardFormatAvailable(CF_TEXT) ?<span class="comment">//询问剪切板状态,决定使能还是灰化粘贴键</span></span><br><span class="line">				MF_ENABLED : MF_GRAYED);</span><br><span class="line"></span><br><span class="line">			iSelect = SendMessage(hwndEdit, EM_GETSEL,<span class="number">0</span>, <span class="number">0</span>);<span class="comment">//获取高亮选中位置</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (HIWORD(iSelect) == LOWORD(iSelect))<span class="comment">//LOWORD(iSelect)指向开始高亮的地方,HIWORD(iSelect)指向结束高亮的地方</span></span><br><span class="line">				iEnable = MF_GRAYED;<span class="comment">//如果开始==结束说明没有选中东西</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				iEnable = MF_ENABLED;<span class="comment">//如果开始!=结束说明选中东西了</span></span><br><span class="line"></span><br><span class="line">			EnableMenuItem((HMENU)wParam, IDM_EDIT_CUT, iEnable);<span class="comment">//根据有没有选中东西决定复制,剪切,粘贴是否使能</span></span><br><span class="line">			EnableMenuItem((HMENU)wParam, IDM_EDIT_COPY, iEnable);</span><br><span class="line">			EnableMenuItem((HMENU)wParam, IDM_EDIT_CLEAR, iEnable);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">		<span class="keyword">if</span> (lParam)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (LOWORD(lParam) == ID_EDIT &amp;&amp;</span><br><span class="line">				(HIWORD(wParam) == EN_ERRSPACE ||</span><br><span class="line">					HIWORD(wParam) == EN_MAXTEXT))</span><br><span class="line">				MessageBox(hwnd, TEXT(<span class="string">&quot;Edit control out of space.&quot;</span>),</span><br><span class="line">					szAppName, MB_OK | MB_ICONSTOP);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">switch</span> (LOWORD(wParam))</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> IDM_FILE_NEW:</span><br><span class="line">		<span class="keyword">case</span> IDM_FILE_OPEN:</span><br><span class="line">		<span class="keyword">case</span> IDM_FILE_SAVE:</span><br><span class="line">		<span class="keyword">case</span> IDM_FILE_SAVE_AS:</span><br><span class="line">		<span class="keyword">case</span> IDM_FILE_PRINT:</span><br><span class="line">			MessageBeep(<span class="number">0</span>);<span class="comment">//尚未实现</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> IDM_APP_EXIT:</span><br><span class="line">			SendMessage(hwnd, WM_CLOSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">case</span> IDM_EDIT_UNDO:</span><br><span class="line">			SendMessage(hwndEdit, WM_UNDO, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//编辑控件的预定义动作</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> IDM_EDIT_CUT:</span><br><span class="line">			SendMessage(hwndEdit, WM_CUT, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//预定义动作,剪切,不需要手动实现</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> IDM_EDIT_COPY:</span><br><span class="line">			SendMessage(hwndEdit, WM_COPY, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">case</span> IDM_EDIT_PASTE:</span><br><span class="line">			SendMessage(hwndEdit, WM_PASTE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> IDM_EDIT_CLEAR:</span><br><span class="line">			SendMessage(hwndEdit, WM_CLEAR, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">case</span> IDM_EDIT_SELECT_ALL:<span class="comment">//Ctrl+A</span></span><br><span class="line">			SendMessage(hwndEdit, EM_SETSEL, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> IDM_HELP_HELP:</span><br><span class="line">			MessageBox(hwnd, TEXT(<span class="string">&quot;Help not yet implemented!&quot;</span>), </span><br><span class="line">				szAppName, MB_OK | MB_ICONEXCLAMATION);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> IDM_APP_ABOUT:</span><br><span class="line">			MessageBox(hwnd, TEXT(<span class="string">&quot;dustball&#x27;s 卑鄙 notepad&quot;</span>),</span><br><span class="line">				szAppName, MB_OK | MB_ICONINFORMATION);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">		<span class="keyword">if</span> (IDYES == AskConfirmation(hwnd))</span><br><span class="line">			DestroyWindow(hwnd);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_QUERYENDSESSION:</span><br><span class="line">		<span class="keyword">if</span> (IDYES == AskConfirmation(hwnd))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">		PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>未实现的保存,打开,新建等功能需要等到学了对话框再说了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/08/20/windows%20SDK%20chapter%2021%20%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/20/windows%20SDK%20chapter%2021%20%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" class="post-title-link" itemprop="url">win32程序设计-chapter21 动态链接库与消息钩取</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-20 09:40:00 / Modified: 16:34:30" itemprop="dateCreated datePublished" datetime="2022-08-20T09:40:00+08:00">2022-08-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="windows-SDK-chapter-21-动态链接库"><a href="#windows-SDK-chapter-21-动态链接库" class="headerlink" title="windows SDK chapter 21 动态链接库"></a>windows SDK chapter 21 动态链接库</h1><h2 id="库的类型"><a href="#库的类型" class="headerlink" title="库的类型"></a>库的类型</h2><table>
<thead>
<tr>
<th>库类型</th>
<th>拓展名</th>
<th>作用</th>
<th>举例</th>
<th>使用时期</th>
<th>是否链接进入可执行目标文件</th>
</tr>
</thead>
<tbody><tr>
<td>对象库(静态库)</td>
<td>.lib</td>
<td>.obj目标模块集合</td>
<td>LIBC.lib</td>
<td>开发时</td>
<td>是</td>
</tr>
<tr>
<td>导入库</td>
<td>.lib</td>
<td>链接器使用它解析函数调用</td>
<td>kernel32.lib</td>
<td>开发时</td>
<td>是</td>
</tr>
<tr>
<td>动态链接库</td>
<td>.dll</td>
<td>运行时提供支持</td>
<td>kernel32.dll</td>
<td>运行时</td>
<td>否</td>
</tr>
</tbody></table>
<h2 id="库的位置"><a href="#库的位置" class="headerlink" title="库的位置"></a>库的位置</h2><p>类似于头文件的搜索顺序,当一个exe程序需要dll支持的时候,windows搜索dll也是有顺序的,编译链接时不需要指定动态库位置</p>
<p>1.exe文件同在的目录</p>
<p>2.shell的当前目录(pwd)</p>
<p>3.windows系统目录,即C:&#x2F;&#x2F;Windows&#x2F;system32文件夹</p>
<p>4.windows目录,即C:&#x2F;&#x2F;Windows文件夹</p>
<p>5.DOS环境下PATH环境变量</p>
<p>如果在某一步找到则不再继续寻找</p>
<h2 id="Visual-C-和Visual-Studio"><a href="#Visual-C-和Visual-Studio" class="headerlink" title="Visual C++和Visual Studio"></a>Visual C++和Visual Studio</h2><p>由于这本书年代比较久远,当时的集成开发环境还是VC++,而现在win11上装一个兼容的VC++都不容易了</p>
<p>VC++中的”workspace”对应到VS上就是解决方案”solution”</p>
<p>一个工作区&#x2F;解决方案 下面可以建立多个项目,一个项目对应一个应用程序或者一个DLL</p>
<h2 id="Linux上的链接与库"><a href="#Linux上的链接与库" class="headerlink" title="Linux上的链接与库"></a>Linux上的链接与库</h2><p>此部分在CSAPP-chapter -7链接已经学过,在此只回顾一下GNU GCC命令</p>
<h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>预编译,将源文件.c或者.cpp的宏定义展开成.i文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpp main.c &gt; main.i</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要输出重定向到main.i,否则cpp命令默认输出到屏幕</p>
</blockquote>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>汇编,将源文件汇编成汇编语言文件.s</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -S</span><br></pre></td></tr></table></figure>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译,将源文件编译成可重定位目标文件.o</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -c -o main.o</span><br></pre></td></tr></table></figure>

<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>将多个可重定位目标模块链接成可执行目标模块.out</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.o func.o -o main.out</span><br></pre></td></tr></table></figure>

<h3 id="创建静态库"><a href="#创建静态库" class="headerlink" title="创建静态库"></a>创建静态库</h3><p>将一个或多个可重定位目标模块.o,创建成静态库.a(归档文件)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libmain.a main.o</span><br></pre></td></tr></table></figure>

<h3 id="创建动态库"><a href="#创建动态库" class="headerlink" title="创建动态库"></a>创建动态库</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC main.c -o main.so</span><br></pre></td></tr></table></figure>



<h2 id="Visual-Studio-创建使用库"><a href="#Visual-Studio-创建使用库" class="headerlink" title="Visual Studio 创建使用库"></a>Visual Studio 创建使用库</h2><p>Microsoft Visual Studio 2022</p>
<h3 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a>静态库的使用</h3><h4 id="创建静态库-1"><a href="#创建静态库-1" class="headerlink" title="创建静态库"></a>创建静态库</h4><h5 id="1-新建空白解决方案"><a href="#1-新建空白解决方案" class="headerlink" title="1.新建空白解决方案"></a>1.新建空白解决方案</h5><p>(在VC++上”解决方案”叫做workspace工作区)</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721155939293.png" alt="image-20220721155939293"></p>
<h5 id="2-配置新”项目”"><a href="#2-配置新”项目”" class="headerlink" title="2.配置新”项目”"></a>2.配置新”项目”</h5><p>解决方案名称就叫做”MATHTOOLS”吧,</p>
<p>一个解决方案可以包含多个项目,但是新建解决方案时也是通过”新建项目”选项卡实现的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721160058473.png" alt="image-20220721160058473"></p>
<h5 id="3-新建静态库工程"><a href="#3-新建静态库工程" class="headerlink" title="3.新建静态库工程"></a>3.新建静态库工程</h5><p>在”解决方案资源管理器”中(视图-&gt;解决方案资源管理器或者Ctrl+Alt+L唤醒),</p>
<p>在”解决方案’MATHTOOLS’(0个项目)”上右键-&gt;新建项目</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721160318596.png" alt="image-20220721160318596"></p>
<h5 id="4-在添加新项目搜索框中搜索”静态库”"><a href="#4-在添加新项目搜索框中搜索”静态库”" class="headerlink" title="4.在添加新项目搜索框中搜索”静态库”"></a>4.在添加新项目搜索框中搜索”静态库”</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721160358962.png" alt="image-20220721160358962"></p>
<h5 id="5-配置静态库项目"><a href="#5-配置静态库项目" class="headerlink" title="5.配置静态库项目"></a>5.配置静态库项目</h5><p>起个名,然后创建</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721160433974.png" alt="image-20220721160433974"></p>
<h5 id="6-建立静态库项目之后的解决方案资源管理器"><a href="#6-建立静态库项目之后的解决方案资源管理器" class="headerlink" title="6.建立静态库项目之后的解决方案资源管理器"></a>6.建立静态库项目之后的解决方案资源管理器</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721160547138.png" alt="image-20220721160547138"></p>
<p>有一些vs自动帮我们生成的文件,比如<code>pch.h,framework.h,pch.cpp,MATHLIB.cpp</code></p>
<p>然而这些都是可有可无的</p>
<h5 id="7-不使用预编译头"><a href="#7-不使用预编译头" class="headerlink" title="7.不使用预编译头"></a>7.不使用预编译头</h5><p>在解决方案资源管理器-&gt;MATHLIB项目 上右键,属性</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721160748513.png" alt="image-20220721160748513"></p>
<p>在弹出的属性页中将陪着和平台都改成所有的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721160818483.png" alt="image-20220721160818483"></p>
<p>然后配置属性-&gt;C&#x2F;C++-&gt;预编译头-&gt;不使用预编译头</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721160906154.png" alt="image-20220721160906154"></p>
<h5 id="8-新建MathLib-h和MathLib-cpp"><a href="#8-新建MathLib-h和MathLib-cpp" class="headerlink" title="8.新建MathLib.h和MathLib.cpp"></a>8.新建MathLib.h和MathLib.cpp</h5><p>删掉头文件和源文件中vs帮我们建立好的文件,然后在头文件和源文件夹下面分别新建MathLib.h和MathLib.cpp</p>
<p><code>MathLib.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">	<span class="type">double</span> x;</span><br><span class="line">	<span class="type">double</span> y;</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">const</span> <span class="type">double</span> &amp;x,<span class="type">const</span> <span class="type">double</span> &amp;y);</span><br><span class="line">	<span class="built_in">Point</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setCoordinate</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; x, <span class="type">const</span> <span class="type">double</span>&amp; y)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">double</span>&amp; <span class="title">X</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">double</span>&amp; <span class="title">Y</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">double</span> <span class="title">getEuclidianDistance</span><span class="params">(<span class="type">const</span> Point&amp; p)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">double</span> <span class="title">getManHatonDistance</span><span class="params">(<span class="type">const</span> Point&amp; p)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">getSlope</span><span class="params">(<span class="type">const</span> Point&amp; p)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Point&amp; p);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span> &#123;</span><br><span class="line">	Point a;</span><br><span class="line">	Point b;</span><br><span class="line">	<span class="built_in">Line</span>();</span><br><span class="line">	<span class="built_in">Line</span>(<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b);</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">length</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function">Point &amp;<span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Point &amp;<span class="title">B</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">getSlope</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Line&amp; l);</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isParallel</span><span class="params">(<span class="type">const</span> Line &amp;l)</span><span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>MathLib.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MathLib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">const</span> <span class="type">double</span>&amp; x, <span class="type">const</span> <span class="type">double</span>&amp; y) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">	<span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">	&#125;</span><br><span class="line">Point::<span class="built_in">Point</span>() &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;y = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::setCoordinate</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; x, <span class="type">const</span> <span class="type">double</span>&amp; y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">	<span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="type">double</span>&amp; <span class="title">Point::X</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;x;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="type">double</span>&amp; <span class="title">Point::Y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;y;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> <span class="title">Point::getEuclidianDistance</span><span class="params">(<span class="type">const</span> Point&amp; p)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="number">1.0</span>*(x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> <span class="title">Point::getManHatonDistance</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">abs</span>(x - p.x) + <span class="built_in">abs</span>(y - p.y);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Point::getSlope</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1.0</span>*(y - p.y) / (x - p.x);</span><br><span class="line">	&#125;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Point&amp; p) &#123;</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	Line::<span class="built_in">Line</span>() &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	Line::<span class="built_in">Line</span>(<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">Line::length</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.<span class="built_in">getEuclidianDistance</span>(b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Point&amp; <span class="title">Line::A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Point&amp; <span class="title">Line::B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">Line::getSlope</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.<span class="built_in">getSlope</span>(b);</span><br><span class="line">	&#125;</span><br><span class="line">	std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Line&amp; l )&#123;</span><br><span class="line">		os &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; l.a &lt;&lt; <span class="string">&quot;;&quot;</span> &lt;&lt; l.b &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> os;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Line::isParallel</span><span class="params">(<span class="type">const</span> Line&amp; l)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">abs</span>(<span class="built_in">getSlope</span>() - l.<span class="built_in">getSlope</span>()) &lt; <span class="number">0.001</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="9-重新生成解决方案"><a href="#9-重新生成解决方案" class="headerlink" title="9.重新生成解决方案"></a>9.重新生成解决方案</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721164200557.png" alt="image-20220721164200557"></p>
<p>如果生成成功</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721164221010.png" alt="image-20220721164221010"></p>
<h4 id="链接静态库"><a href="#链接静态库" class="headerlink" title="链接静态库"></a>链接静态库</h4><h5 id="1-往解决方案中添加新项目"><a href="#1-往解决方案中添加新项目" class="headerlink" title="1.往解决方案中添加新项目"></a>1.往解决方案中添加新项目</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721164306283.png" alt="image-20220721164306283"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721164320309.png" alt="image-20220721164320309"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721164341661.png" alt="image-20220721164341661"></p>
<p>新项目名叫MATHTEST</p>
<h5 id="2-添加引用"><a href="#2-添加引用" class="headerlink" title="2.添加引用"></a>2.添加引用</h5><p>此步的作用是</p>
<ol>
<li>在链接A时，自动带上 b.lib，debug&#x2F;release能够自动区分</li>
<li>当B项目有变化时，若编译A项目前先编译B项目</li>
</ol>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721170149106.png" alt="image-20220721170149106"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721170201234.png" alt="image-20220721170201234"></p>
<h5 id="3-修改包含目录"><a href="#3-修改包含目录" class="headerlink" title="3.修改包含目录"></a>3.修改包含目录</h5><p>此步的作用是给<code>#include &quot;MathLib.h&quot;</code>找到包含路径,即MathLib.h在哪里</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721170408179.png" alt="image-20220721170408179"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721170458649.png" alt="image-20220721170458649"></p>
<p>到此MATHTEST中的源文件就能找到需要包含的MathLib.h头文件在哪里,链接器也能知道MathLib.lib在哪里了</p>
<h5 id="4-测试静态库"><a href="#4-测试静态库" class="headerlink" title="4.测试静态库"></a>4.测试静态库</h5><p>在MATHTEST项目中新建一个源文件(或者利用自动创建的MATHTEST.cpp)</p>
<p>随便写点测试静态库的东西</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MathLib.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">A1</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">B1</span><span class="params">(<span class="number">4</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">A2</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">B2</span><span class="params">(<span class="number">15</span>, <span class="number">29</span>)</span></span>;</span><br><span class="line">    <span class="function">Line <span class="title">L1</span><span class="params">(A1, B1)</span></span>;</span><br><span class="line">    <span class="function">Line <span class="title">L2</span><span class="params">(A2, B2)</span></span>;</span><br><span class="line">    cout &lt;&lt; L<span class="number">1.</span><span class="built_in">isParallel</span>(L2)&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; A<span class="number">1.</span><span class="built_in">getEuclidianDistance</span>(B1) &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; L<span class="number">1.l</span>ength() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; A1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; L1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将MATHTEST项目设置为启动项目(如果让MATHLIB库项目作为启动项目根本起不来)</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721171411117.png" alt="image-20220721171411117"></p>
<p>然后Ctrl+F5开始运行(不调试)</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721171456970.png" alt="image-20220721171456970"></p>
<h4 id="解决方案的结构"><a href="#解决方案的结构" class="headerlink" title="解决方案的结构"></a>解决方案的结构</h4><p>可以在解决方案根目录下面,终端上用<code>tree /f</code>命令打印整个结构</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%A0%B9%E7%9B%AE%E5%BD%95.png" alt="解决方案根目录"></p>
<h3 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h3><h4 id="创建动态库-1"><a href="#创建动态库-1" class="headerlink" title="创建动态库"></a>创建动态库</h4><h5 id="1-建立空白解决方案"><a href="#1-建立空白解决方案" class="headerlink" title="1.建立空白解决方案"></a>1.建立空白解决方案</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721182820966.png" alt="image-20220721182820966"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721182929764.png" alt="image-20220721182929764"></p>
<h5 id="2-建立动态库项目"><a href="#2-建立动态库项目" class="headerlink" title="2.建立动态库项目"></a>2.建立动态库项目</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721182953735.png" alt="image-20220721182953735"></p>
<p>具有导出项的动态库</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721183016050.png" alt="image-20220721183016050"></p>
<p>项目名称MATHDLL</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721183052585.png" alt="image-20220721183052585"></p>
<p>属性页设置不使用预编译头</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721183151901.png" alt="image-20220721183151901"></p>
<p>删除掉多余的pch等自动生成的文件之后,解决方案资源管理器是这样的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721183358281.png" alt="image-20220721183358281"></p>
<h5 id="3-充实头文件MATHDLL-h和原文件MATHDLL-cpp"><a href="#3-充实头文件MATHDLL-h和原文件MATHDLL-cpp" class="headerlink" title="3.充实头文件MATHDLL.h和原文件MATHDLL.cpp"></a>3.充实头文件MATHDLL.h和原文件MATHDLL.cpp</h5><p>自动生成的MATHDLL.h中有一个实用的宏定义<code>MATHDLL_API</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下列 ifdef 块是创建使从 DLL 导出更简单的</span></span><br><span class="line"><span class="comment">// 宏的标准方法。此 DLL 中的所有文件都是用命令行上定义的 MATHDLL_EXPORTS</span></span><br><span class="line"><span class="comment">// 符号编译的。在使用此 DLL 的</span></span><br><span class="line"><span class="comment">// 任何项目上不应定义此符号。这样，源文件中包含此文件的任何其他项目都会将</span></span><br><span class="line"><span class="comment">// MATHDLL_API 函数视为是从 DLL 导入的，而此 DLL 则将用此宏定义的</span></span><br><span class="line"><span class="comment">// 符号视为是被导出的。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MATHDLL_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATHDLL_API __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATHDLL_API __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此类是从 dll 导出的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MATHDLL_API</span> <span class="title">CMATHDLL</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">	CMATHDLL(<span class="type">void</span>);</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处添加方法。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> MATHDLL_API <span class="type">int</span> nMATHDLL;</span><br><span class="line"></span><br><span class="line">MATHDLL_API <span class="type">int</span> <span class="title function_">fnMATHDLL</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>MATHDLL_API</code>这个宏定义,对于DLL库的头文件来说被翻译为<code>__declspec(dllexport)</code>,</p>
<p>而对于包含该头文件的其他项目的源文件来说被翻译为<code>__declspec(dllimport)</code></p>
<p>关于<code>__declspec(dllexport)</code>干了啥事,现在不想知道,只需要知道导出函数时必须</p>
<p><code>MATHDLL.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下列 ifdef 块是创建使从 DLL 导出更简单的</span></span><br><span class="line"><span class="comment">// 宏的标准方法。此 DLL 中的所有文件都是用命令行上定义的 MATHDLL_EXPORTS</span></span><br><span class="line"><span class="comment">// 符号编译的。在使用此 DLL 的</span></span><br><span class="line"><span class="comment">// 任何项目上不应定义此符号。这样，源文件中包含此文件的任何其他项目都会将</span></span><br><span class="line"><span class="comment">// MATHDLL_API 函数视为是从 DLL 导入的，而此 DLL 则将用此宏定义的</span></span><br><span class="line"><span class="comment">// 符号视为是被导出的。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MATHDLL_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATHDLL_API __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATHDLL_API __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MATHDLL_API</span> <span class="title">Point</span> &#123;</span><span class="comment">//使用MATHDLL_API修饰意思是导出类</span></span><br><span class="line">	<span class="type">double</span> x;</span><br><span class="line">	<span class="type">double</span> y;</span><br><span class="line">	Point(<span class="type">const</span> <span class="type">double</span>&amp; x, <span class="type">const</span> <span class="type">double</span>&amp; y);</span><br><span class="line">	Point();</span><br><span class="line">	<span class="type">void</span> <span class="title function_">setCoordinate</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; x, <span class="type">const</span> <span class="type">double</span>&amp; y)</span>;</span><br><span class="line">	<span class="type">double</span>&amp; <span class="title function_">X</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">double</span>&amp; <span class="title function_">Y</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">double</span> <span class="title function_">getEuclidianDistance</span><span class="params">(<span class="type">const</span> Point&amp; p)</span><span class="type">const</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">double</span> <span class="title function_">getManHatonDistance</span><span class="params">(<span class="type">const</span> Point&amp; p)</span><span class="type">const</span>;</span><br><span class="line">	<span class="type">double</span> <span class="title function_">getSlope</span><span class="params">(<span class="type">const</span> Point&amp; p)</span><span class="type">const</span>;</span><br><span class="line">	friend <span class="built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="type">const</span> Point&amp; p);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MATHDLL_API</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">	Point a;</span><br><span class="line">	Point b;</span><br><span class="line">	Line();</span><br><span class="line">	Line(<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b);</span><br><span class="line">	<span class="type">double</span> <span class="title function_">length</span><span class="params">()</span><span class="type">const</span>;</span><br><span class="line">	Point&amp; <span class="title function_">A</span><span class="params">()</span>;</span><br><span class="line">	Point&amp; <span class="title function_">B</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">double</span> <span class="title function_">getSlope</span><span class="params">()</span><span class="type">const</span>;</span><br><span class="line">	friend <span class="built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="type">const</span> Line&amp; l);</span><br><span class="line">	<span class="type">bool</span> <span class="title function_">isParallel</span><span class="params">(<span class="type">const</span> Line&amp; l)</span><span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//extern MATHDLL_API int nMATHDLL;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MATHDLL_API int fnMATHDLL(void);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>MATHDLL.cpp</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MATHDLL.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Point::Point(<span class="type">const</span> <span class="type">double</span>&amp; x, <span class="type">const</span> <span class="type">double</span>&amp; y) &#123;</span><br><span class="line">	this-&gt;x = x;</span><br><span class="line">	this-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line">Point::Point() &#123;</span><br><span class="line">	this-&gt;x = <span class="number">0</span>;</span><br><span class="line">	this-&gt;y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Point::setCoordinate</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; x, <span class="type">const</span> <span class="type">double</span>&amp; y)</span> &#123;</span><br><span class="line">	this-&gt;x = x;</span><br><span class="line">	this-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span>&amp; <span class="title function_">Point::X</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this-&gt;x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span>&amp; <span class="title function_">Point::Y</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this-&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> <span class="title function_">Point::getEuclidianDistance</span><span class="params">(<span class="type">const</span> Point&amp; p)</span><span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="number">1.0</span> * (x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> <span class="title function_">Point::getManHatonDistance</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> <span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">abs</span>(x - p.x) + <span class="built_in">abs</span>(y - p.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">Point::getSlope</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> <span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1.0</span> * (y - p.y) / (x - p.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="type">const</span> Point&amp; p) &#123;</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::Line() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Line::Line(<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b) &#123;</span><br><span class="line">	this-&gt;a = a;</span><br><span class="line">	this-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">Line::length</span><span class="params">()</span><span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a.getEuclidianDistance(b);</span><br><span class="line">&#125;</span><br><span class="line">Point&amp; <span class="title function_">Line::A</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">Point&amp; <span class="title function_">Line::B</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">Line::getSlope</span><span class="params">()</span><span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a.getSlope(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="type">const</span> Line&amp; l) &#123;</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; l.a &lt;&lt; <span class="string">&quot;;&quot;</span> &lt;&lt; l.b &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Line::isParallel</span><span class="params">(<span class="type">const</span> Line&amp; l)</span><span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">abs</span>(getSlope() - l.getSlope()) &lt; <span class="number">0.001</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>dllMain.cpp</code>保持原样不用管</p>
<p>此时重新生成解决方案没有错误,则动态库创建完毕了</p>
<p>此时在<code>MATHTOOLS/debug/</code>下面生成四个文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\testDLL\MATHTOOLS\Debug&gt; <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: C:\Users\86135\Desktop\testDLL\MATHTOOLS\Debug</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">-a----         2022/7/21     19:01          52736 MATHDLL.dll</span><br><span class="line">-a----         2022/7/21     19:01           3532 MATHDLL.exp</span><br><span class="line">-a----         2022/7/21     19:01           6308 MATHDLL.lib</span><br><span class="line">-a----         2022/7/21     19:01        1200128 MATHDLL.pdb</span><br></pre></td></tr></table></figure>

<p>有动态库dll这不足为奇,我们要的就是它</p>
<p>有pdb数据库也不足为奇,调试时用的符号就存在这个数据库里</p>
<p>那exp和lib是来干啥的?留作后话</p>
<p>到此动态库创建完毕,下面新建测试项目</p>
<h4 id="链接动态库"><a href="#链接动态库" class="headerlink" title="链接动态库"></a>链接动态库</h4><p>链接一个动态库好麻烦,需要三个东西</p>
<p>1.包含头文件路径</p>
<p>2.lib导入库的路径</p>
<p>3.dll本尊的路径</p>
<p>其中头文件在编译的时候给一个符号,lib是一个药引子,它干了啥事留作后话</p>
<h5 id="1-新建控制台测试项目"><a href="#1-新建控制台测试项目" class="headerlink" title="1.新建控制台测试项目"></a>1.新建控制台测试项目</h5><p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721190552713.png" alt="image-20220721190552713"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721190612424.png" alt="image-20220721190612424"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721190626516.png" alt="image-20220721190626516"></p>
<h5 id="2-添加引用-1"><a href="#2-添加引用-1" class="headerlink" title="2.添加引用"></a>2.添加引用</h5><p>在MATHTEST的引用上添加引用,作用同静态库时的用法,即将lib文件链接进入exe文件</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721190715859.png" alt="image-20220721190715859"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721190737071.png" alt="image-20220721190737071"></p>
<p>此步的作用是添加dll库文件本身的路径</p>
<h5 id="3-添加头文件包含路径"><a href="#3-添加头文件包含路径" class="headerlink" title="3.添加头文件包含路径"></a>3.添加头文件包含路径</h5><p>头文件的作用是提供符号引用,只是提供引用的作用,没有其他作用了,不用想太多</p>
<blockquote>
<p> 有时甚至不包含头文件只链接对应源文件也不会链接报错,警告罢了</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721190917081.png" alt="image-20220721190917081"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721190857128.png" alt="image-20220721190857128"></p>
<h5 id="4-添加导入库-lib文件-路径"><a href="#4-添加导入库-lib文件-路径" class="headerlink" title="4.添加导入库(lib文件)路径"></a>4.添加导入库(lib文件)路径</h5><p>此处需要在链接器-&gt;输入-&gt;附加依赖项  还有  链接器-&gt;常规-&gt;附加库目录两个地方进行添加</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721191127957.png" alt="image-20220721191127957"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721192104087.png" alt="image-20220721192104087"></p>
<p>到此程序就可以运行了</p>
<h3 id="obj-lib-dll"><a href="#obj-lib-dll" class="headerlink" title=".obj-&gt;.lib-&gt;.dll"></a><code>.obj-&gt;.lib-&gt;.dll</code></h3><p>两种库的制作过程中,都有.lib文件,但是静态库中.lib是最终产品,动态库中.lib是一个药引子导入库</p>
<h2 id="MSVC创建使用库"><a href="#MSVC创建使用库" class="headerlink" title="MSVC创建使用库"></a>MSVC创建使用库</h2><p>用Vscode打开一个文件夹作为工作目录,然后在本文件夹下面写EDRLIB.C和EDRLIB.H,EDRTEST.C</p>
<h3 id="制作动态库"><a href="#制作动态库" class="headerlink" title="制作动态库"></a>制作动态库</h3><p>首先在本目录下面编写<code>EDRLIB.H,EDRLIB.C</code>两个源代码文件</p>
<p><code>EDRLIB.H</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus <span class="comment">//防止C++的命名重整,使得本库文件可以被C和C++程序使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT extern <span class="string">&quot;C&quot;</span> __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">EXPORT BOOL CALLBACK <span class="title function_">EdrCenterTextA</span><span class="params">(HDC,PRECT,PCSTR)</span>;</span><br><span class="line">EXPORT BOOL CALLBACK <span class="title function_">EdrCenterTextW</span><span class="params">(HDC,PRECT,PCWSTR)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EdrCenterText EdrCenterTextW</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EdrCenterText EdrCenterTextA</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p><code>EDRLIB.C</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EDRLIB.H&quot;</span></span></span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span>;</span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, <span class="type">int</span> iCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> TCHAR szAppName[] = TEXT(<span class="string">&quot;StrProg&quot;</span>);</span><br><span class="line">    HWND hwnd;</span><br><span class="line">    MSG msg;</span><br><span class="line"></span><br><span class="line">    WNDCLASS wndclass;</span><br><span class="line">    wndclass.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    wndclass.lpfnWndProc = WndProc;</span><br><span class="line">    wndclass.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">    wndclass.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">    wndclass.hInstance = hInstance;</span><br><span class="line">    wndclass.hIcon = LoadIcon(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line">    wndclass.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);</span><br><span class="line">    wndclass.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">    wndclass.lpszClassName = szAppName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RegisterClass(&amp;wndclass))</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;requires Windows NT&quot;</span>), szAppName, MB_ICONERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hwnd = CreateWindow(</span><br><span class="line">        szAppName,</span><br><span class="line">        TEXT(<span class="string">&quot;DLL Demonstrate Program&quot;</span>),</span><br><span class="line">        WS_OVERLAPPEDWINDOW,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        hInstance,</span><br><span class="line">        <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    ShowWindow(hwnd, iCmdShow);</span><br><span class="line">    UpdateWindow(hwnd);</span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    HDC hdc;</span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    RECT rect;</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line">        GetClientRect(hwnd, &amp;rect);</span><br><span class="line">        EdrCenterText(hdc, &amp;rect, TEXT(<span class="string">&quot;in DLLLLLLLer&quot;</span>));</span><br><span class="line">        EndPaint(hwnd, &amp;ps);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用MSVC编译链接制作动态库</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cl /c EDRLIB.C</span><br><span class="line">link /dll EDRLIB.obj user32.lib kernel32.lib gdi32.lib</span><br></pre></td></tr></table></figure>

<p>到此本目录下面就生成了dll动态库文件和lib导入库文件</p>
<h3 id="链接导入库"><a href="#链接导入库" class="headerlink" title="链接导入库"></a>链接导入库</h3><p>编写测试程序<code>EDRTEST.C</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EDRLIB.H&quot;</span></span></span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span>;</span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, <span class="type">int</span> iCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> TCHAR szAppName[] = TEXT(<span class="string">&quot;StrProg&quot;</span>);</span><br><span class="line">    HWND hwnd;</span><br><span class="line">    MSG msg;</span><br><span class="line"></span><br><span class="line">    WNDCLASS wndclass;</span><br><span class="line">    wndclass.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    wndclass.lpfnWndProc = WndProc;</span><br><span class="line">    wndclass.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">    wndclass.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">    wndclass.hInstance = hInstance;</span><br><span class="line">    wndclass.hIcon = LoadIcon(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line">    wndclass.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);</span><br><span class="line">    wndclass.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">    wndclass.lpszClassName = szAppName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RegisterClass(&amp;wndclass))</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;requires Windows NT&quot;</span>), szAppName, MB_ICONERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hwnd = CreateWindow(</span><br><span class="line">        szAppName,</span><br><span class="line">        TEXT(<span class="string">&quot;DLL Demonstrate Program&quot;</span>),</span><br><span class="line">        WS_OVERLAPPEDWINDOW,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        hInstance,</span><br><span class="line">        <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    ShowWindow(hwnd, iCmdShow);</span><br><span class="line">    UpdateWindow(hwnd);</span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    HDC hdc;</span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    RECT rect;</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line">        GetClientRect(hwnd, &amp;rect);</span><br><span class="line">        EdrCenterText(hdc, &amp;rect, TEXT(<span class="string">&quot;in DLLLLLLLer&quot;</span>));</span><br><span class="line">        EndPaint(hwnd, &amp;ps);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MSVC编译链接导入库</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cl /c EDRTEST.c</span><br><span class="line">link EDRTEST.obj EDRLIB.lib kernel32.lib user32.lib gdi32.lib</span><br></pre></td></tr></table></figure>

<h3 id="运行时使用动态库"><a href="#运行时使用动态库" class="headerlink" title="运行时使用动态库"></a>运行时使用动态库</h3><p>由于EDRTEST.exe和EDRLIB.dll在同一目录下,因此装载器可以找到EDRLIB.dll,直接运行即可</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220819155710984.png" alt="image-20220819155710984"></p>
<h2 id="TDM-GCC创建使用库"><a href="#TDM-GCC创建使用库" class="headerlink" title="TDM-GCC创建使用库"></a>TDM-GCC创建使用库</h2><p>我电脑上这个TDM-GCC来自于Dev-Cpp,把TDM-GCC的bin目录添加到环境变量path即可在终端上使用</p>
<p>文件都不变</p>
<h3 id="制作动态库-1"><a href="#制作动态库-1" class="headerlink" title="制作动态库"></a>制作动态库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared EDRLIB.C -o EDRLIB.dll -luser32 -lgdi32 -lkernel32 </span><br></pre></td></tr></table></figure>

<p>然而这一步完成之后只生成了dll动态库文件,没有生成lib导入库文件</p>
<h3 id="链接动态库-1"><a href="#链接动态库-1" class="headerlink" title="链接动态库"></a>链接动态库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc EDRTEST.C -o EDRTEST.exe -lkernel32 -lgdi32 -luser32 -L./ -lEDRLIB ;执行在当前目录下寻找库文件,库文件名EDRLIB</span><br></pre></td></tr></table></figure>



<h3 id="运行时使用动态库-1"><a href="#运行时使用动态库-1" class="headerlink" title="运行时使用动态库"></a>运行时使用动态库</h3><p>dll和exe同目录,可以直接运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./EDRTEST.exe</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220819161937488.png" alt="image-20220819161937488"></p>
<p>效果和MSVC相同</p>
<p>如果把MSVC形成的exe和TDM-GCC形成的dll放在同一目录则运行报错,反过来也这样,总之就是谁的exe就得有谁的dll支持</p>
<h2 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain"></a>DllMain</h2><p>Dll文件也可以有入口点,DllMain函数,该函数会在Dll被装载或者卸载等等各时期被调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hInstance,DWORD fdwReason,PVOID pvReserved)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数意义"><a href="#参数意义" class="headerlink" title="参数意义"></a>参数意义</h3><p>hInstance是本DLL模块的句柄,实际上是本模块加载进入进程地址空间中的基地址</p>
<p>fdwReason本DllMain函数被调用的原因</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>DLL_PROCESS_ATTACH</strong>(1)</td>
<td align="left">由于进程启动或调用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya"><strong>LoadLibrary</strong></a>，DLL 正在加载到当前进程的虚拟地址空间中。 DLL 可以使用此机会初始化任何实例数据，或使用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlsalloc"><strong>TlsAlloc</strong></a> 函数分配线程本地存储 (TLS) 索引。 <em>lpvReserved</em> 参数指示是静态还是动态加载 DLL。</td>
</tr>
<tr>
<td align="left"><strong>DLL_PROCESS_DETACH</strong>(0)</td>
<td align="left">DLL 正在从调用进程的虚拟地址空间中卸载，因为它加载失败，或者引用计数已达到零， (进程每次调用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary"><strong>LoadLibrary</strong></a>) 时，都会终止或调用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya"><strong>FreeLibrary</strong></a> 。 <em>lpvReserved</em> 参数指示是否由于 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary"><strong>FreeLibrary</strong></a> 调用、加载失败或进程终止而卸载 DLL。 DLL 可以使用此机会调用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlsfree"><strong>TlsFree</strong></a> 函数，以释放使用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlsalloc"><strong>TlsAlloc</strong></a> 分配的任何 TLS 索引，并释放任何线程本地数据。 请注意，接收 <strong>DLL_PROCESS_DETACH</strong> 通知的线程不一定是接收 <strong>DLL_PROCESS_ATTACH通知的</strong> 线程。</td>
</tr>
<tr>
<td align="left"><strong>DLL_THREAD_ATTACH</strong>(2)</td>
<td align="left">当前进程正在创建新线程。 发生这种情况时，系统会调用当前附加到进程的所有 DLL 的入口点函数。 调用是在新线程的上下文中进行的。 DLL 可以使用此机会初始化线程的 TLS 槽。 使用 <strong>DLL_PROCESS_ATTACH</strong> 调用 DLL 入口点函数的线程不会使用 <strong>DLL_THREAD_ATTACH</strong> 调用 DLL 入口点函数。 请注意，DLL 的入口点函数仅由进程加载 DLL 后创建的线程调用此值。 使用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya"><strong>LoadLibrary</strong></a> 加载 DLL 时，现有线程不会调用新加载 DLL 的入口点函数。</td>
</tr>
<tr>
<td align="left"><strong>DLL_THREAD_DETACH</strong>(3)</td>
<td align="left">线程已干净退出。 如果 DLL 已存储指向 TLS 槽中已分配内存的指针，则应使用此机会释放内存。 系统使用此值调用当前加载的所有 DLL 的入口点函数。 调用是在退出线程的上下文中进行的。</td>
</tr>
</tbody></table>
<p>pvReserved尚未使用</p>
<h3 id="分拣消息"><a href="#分拣消息" class="headerlink" title="分拣消息"></a>分拣消息</h3><p>DllMain的调用,和窗口过程函数WndProc的调用方式很像,</p>
<p>WndProc调用时,message参数记录消息类型.</p>
<p>DllMain调用时,fdwReason记录调用原因</p>
<p>因此DllMain中可以根据调用原因的不同,设计不同的处理过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(</span></span><br><span class="line"><span class="params">    HINSTANCE hinstDLL,  <span class="comment">// handle to DLL module</span></span></span><br><span class="line"><span class="params">    DWORD fdwReason,     <span class="comment">// reason for calling function</span></span></span><br><span class="line"><span class="params">    LPVOID lpReserved )</span>  <span class="comment">// reserved</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Perform actions based on the reason for calling.</span></span><br><span class="line">    <span class="keyword">switch</span>( fdwReason ) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">         <span class="comment">// Initialize once for each new process.</span></span><br><span class="line">         <span class="comment">// Return FALSE to fail DLL load.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">         <span class="comment">// Do thread-specific initialization.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">         <span class="comment">// Do thread-specific cleanup.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">         <span class="comment">// Perform any necessary cleanup.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;  <span class="comment">// Successful DLL_PROCESS_ATTACH.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Windows消息钩取-Dll注入"><a href="#Windows消息钩取-Dll注入" class="headerlink" title="Windows消息钩取(Dll注入)"></a>Windows消息钩取(Dll注入)</h2><p>学习windows程序设计有一段时间了,我就知道了一个事,即消息会从操作系统的消息队列分发到应用程序的消息队列.比如键盘按下之后操作系统首先捕捉该消息,然后看看焦点窗口是谁,再把这个消息发给焦点窗口.</p>
<p>而消息钩取就发生在这个消息分发的过程中,钩子程序可以监视从操作系统消息队列发往应用程序消息队列的所有消息</p>
<h3 id="windows消息流"><a href="#windows消息流" class="headerlink" title="windows消息流"></a>windows消息流</h3><p>当发生键盘按下的时间时,WM_KEYDOWN消息首先被添加到操作系统消息队列</p>
<p>操作系统判断是哪个应用程序发生的事件,然后从自己的消息队列中取出这个消息添加到对应应用程序的消息队列</p>
<p>应用程序的消息循环不停地从自己的消息队列中取出消息并调用相应的事件处理程序(即窗口过程)</p>
<blockquote>
<p>这里窗口过程是回调形式的,因为同一个应用程序可以有多个窗口,自然可以有多个窗口过程,消息循环中的<code>DispatchMessage(&amp;msg);</code>可以决定将消息发往哪个窗口过程</p>
</blockquote>
<p>消息钩取发生在消息从OS消息队列到应用消息队列的路上</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220819173944182.png" alt="image-20220819173944182"></p>
<h3 id="SetWindowsHookEx数注册钩子"><a href="#SetWindowsHookEx数注册钩子" class="headerlink" title="SetWindowsHookEx数注册钩子"></a>SetWindowsHookEx数注册钩子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HHOOK <span class="title function_">SetWindowsHookEx</span><span class="params">(</span></span><br><span class="line"><span class="params">   <span class="type">int</span> idHook,   <span class="comment">//hook type</span></span></span><br><span class="line"><span class="params">   HOOKPROC lpfn,  <span class="comment">//hook procedure</span></span></span><br><span class="line"><span class="params">   HINSTANCE hMod,  <span class="comment">//hook procedure所属的DLL句柄</span></span></span><br><span class="line"><span class="params">   DWORD dwThreadId <span class="comment">//将要挂钩的目标线程ID</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<h4 id="参数意义-1"><a href="#参数意义-1" class="headerlink" title="参数意义"></a>参数意义</h4><h5 id="idHook"><a href="#idHook" class="headerlink" title="idHook"></a>idHook</h5><p>钩子类型,决定钩子的类型和范围</p>
<p><img src="https://github.com/DeutschBall/DeutschBall/blob/main/20191231092715762.png?raw=true" alt="img"></p>
<h5 id="lpfn"><a href="#lpfn" class="headerlink" title="lpfn"></a>lpfn</h5><p>钩子过程函数,需要存在于某个DLL内部</p>
<p>该函数是一个回调函数,有固定的参数,返回值要求</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK HookProc<span class="comment">//程序员对于钩子过程的名字还是有支配权的</span></span><br><span class="line">(</span><br><span class="line">  <span class="type">int</span> nCode,<span class="comment">//钩子代码,一种代码对应一种情况,钩子过程可以根据情况就事论事</span></span><br><span class="line">  WPARAM wParam,<span class="comment">//两个附属参数都是nCode的更详细信息,nCode确定了wParam才有意义</span></span><br><span class="line">  LPARAM lParam,</span><br><span class="line">);<span class="comment">//返回值一般直接写返回CallNextHookEx的返回值就行了,根WndProc返回DefWndProc差不多</span></span><br></pre></td></tr></table></figure>

<p>这里(nCode,wParam,lParam)的消息组合起始和WndProc中的(message,wParam,lParam)很像</p>
<p>nCode&#x2F;message指定消息类型,wParam和lParam是具体的解释</p>
<h5 id="hMod"><a href="#hMod" class="headerlink" title="hMod"></a>hMod</h5><p>钩子函数所在实例的句柄,即lpfn所在的DLL句柄</p>
<p>如果是本地钩子,并且钩子就写在本程序中,那么hMod可以是本程序实例句柄,此时lpfn注册的函数也在本程序中,编译之后一运行,程序和钩子都在同一个进程地址空间,钩子可以猥琐欲为</p>
<p>然而远程钩子,即这个进程钩取那个进程消息这种,就一定需要把钩子放在dll中,然后指望操作系统把这个dll,注入到远程进程的地址空间中了</p>
<h5 id="dwThreadId"><a href="#dwThreadId" class="headerlink" title="dwThreadId"></a>dwThreadId</h5><p>挂钩的线程ID</p>
<p>若该值为0则全局钩子,影响所有进程</p>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>HHOOK类型,即钩子句柄,钩子实际上也是一种内核数据结构,通过HHOOK句柄可以索引到该钩子</p>
<p>SetWindowsHookEx如果调用成功则返回其注册的钩子,方便后来使用完毕后删除钩子</p>
<h3 id="UnhookWindowsHookEx删除钩子"><a href="#UnhookWindowsHookEx删除钩子" class="headerlink" title="UnhookWindowsHookEx删除钩子"></a>UnhookWindowsHookEx删除钩子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">UnhookWindowsHookEx</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HHOOK hhk</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>只需要一个钩子句柄HHOOK,这个值是SetWindowsHookEx的返回值,即可注销这次SetWindowsHookEx注册的钩子</p>
<h3 id="钩链"><a href="#钩链" class="headerlink" title="钩链"></a>钩链</h3><p>每调用一次SetWindowsHookEx就会注册一层钩子,调用多了就形成一条钩链,</p>
<p>最新注册的钩子<strong>最先</strong>截获消息</p>
<p>当前钩子回调函数处理完成之后调用CallNextHookEx将消息传递给钩链上下一个钩子回调函数进行处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">HookProc</span><span class="params">(<span class="type">int</span> nCode,WPARAM wParam,LPARAM lParam)</span>&#123;<span class="comment">//钩子过程,回调函数</span></span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">return</span> CallNextHookEx(g_hHook,nCode,wParam,lParam);<span class="comment">//轮到下一个钩子了,如果这里不再调用下一个钩子则一般情况下钩链到此为止(但是就有那特殊情况)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="钩取notepad-exe键盘消息"><a href="#钩取notepad-exe键盘消息" class="headerlink" title="钩取notepad.exe键盘消息"></a>钩取notepad.exe键盘消息</h3><p>当钩子和CPU架构不同的时候容易死机,死了n次得到的规律,64位的电脑上就老实编译64位程序,开64位notepad做实验吧</p>
<h4 id="钩子模块KeyHook-dll"><a href="#钩子模块KeyHook-dll" class="headerlink" title="钩子模块KeyHook.dll"></a>钩子模块KeyHook.dll</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_PROCESS_NAME <span class="string">&quot;notepad.exe&quot;</span></span></span><br><span class="line"></span><br><span class="line">HINSTANCE g_hInstance = <span class="literal">NULL</span>;</span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;<span class="comment">//钩子句柄,由本模块自己维护</span></span><br><span class="line">HWND g_hWnd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hInstDLL, DWORD dwReason, LPVOID lpvReserved)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (dwReason)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:<span class="comment">//如果是因为进程附加则g_hInstance获取hInstDLL值</span></span><br><span class="line">        g_hInstance = hInstDLL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK <span class="title function_">KeyBoardProc</span><span class="params">(<span class="type">int</span> nCode,WPARAM wParam,LPARAM lParam)</span>&#123;<span class="comment">//钩子过程,回调函数</span></span><br><span class="line">    <span class="type">char</span> szPath[MAX_PATH]=&#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    <span class="type">char</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(nCode=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(lParam&amp;<span class="number">0x80000000</span>))&#123;</span><br><span class="line">            GetModuleFileNameA(<span class="literal">NULL</span>,szPath,MAX_PATH);</span><br><span class="line">            p=<span class="built_in">strrchr</span>(szPath,<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!_stricmp(p+<span class="number">1</span>,DEF_PROCESS_NAME))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CallNextHookEx(g_hHook,nCode,wParam,lParam);<span class="comment">//轮到狗链上的下一个钩子了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus <span class="comment">//防止C++的命名重整,使得本库文件可以被C和C++程序使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT extern <span class="string">&quot;C&quot;</span> __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">EXPORT <span class="type">void</span> <span class="title function_">HookStart</span><span class="params">()</span>&#123;<span class="comment">//导出函数,启动钩子</span></span><br><span class="line">    g_hHook=SetWindowsHookEx(WH_KEYBOARD,KeyBoardProc,g_hInstance,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT <span class="type">void</span> <span class="title function_">HookStop</span><span class="params">()</span>&#123;<span class="comment">//导出函数,停止钩子</span></span><br><span class="line">    <span class="keyword">if</span>(g_hHook)&#123;</span><br><span class="line">        UnhookWindowsHookEx(g_hHook);</span><br><span class="line">        g_hHook=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc KeyHook.cpp -shared -o KeyHook.dll</span><br></pre></td></tr></table></figure>

<p>本模块导出了两个函数,注册和注销钩子</p>
<p>HookStart设置钩子类型为键盘型,并且注册了钩子过程回调函数KeyBoardProc,设置本模块为钩子所在模块,钩最后一个参数为0表明本钩子模块将被注入所有进程的地址空间</p>
<p>关键在于钩子过程回调函数KeyBoardProc,这个回调函数的返回值,参数个数,类型,意义,都是有固定要求的,除了函数名可以随便写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">KeyBoardProc</span><span class="params">(<span class="type">int</span> nCode,WPARAM wParam,LPARAM lParam)</span>&#123;<span class="comment">//钩子过程,回调函数</span></span><br><span class="line">    <span class="type">char</span> szPath[MAX_PATH]=&#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    <span class="type">char</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(nCode==<span class="number">0</span>)&#123;<span class="comment">//当nCode=时对应键盘消息</span></span><br><span class="line">        <span class="keyword">if</span>(!(lParam&amp;<span class="number">0x80000000</span>))&#123;</span><br><span class="line">            GetModuleFileNameA(<span class="literal">NULL</span>,szPath,MAX_PATH);</span><br><span class="line">            p=<span class="built_in">strrchr</span>(szPath,<span class="string">&#x27;\\&#x27;</span>);<span class="comment">//返回szpath中最后一次出现&#x27;\&#x27;的位置</span></span><br><span class="line">            <span class="keyword">if</span>(!_stricmp(p+<span class="number">1</span>,DEF_PROCESS_NAME))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CallNextHookEx(g_hHook,nCode,wParam,lParam);<span class="comment">//轮到下一个钩链了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当GetMessage或者PeekMessage被调用时或者键盘消息发生时(WM_KEYUP,WM_KEYDOWN),操作系统会调用KeyBoardProc函数</p>
<blockquote>
<p>这个函数叫啥无所谓,KeyBoardProc,HookProc等等,只要是SetWindowsEx把他注册上就行</p>
</blockquote>
<p>对于键盘类型的钩子,其nCode有两种</p>
<p>HC_ACTION(0)和HC_NOREMOVE(3)</p>
<p>当nCode&#x3D;HC_ACTION,此时wParam和lParam携带击键信息,和击键消息时的作用差不多</p>
<p>当nCode&#x3D;HC_NOREMOVE,此时wParam和lParam携带击键信息,并且该消息尚未被从应用程序消息队列中移除</p>
<p>wParam是虚拟键编码</p>
<p>lParam</p>
<table>
<thead>
<tr>
<th align="left">Bits</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0-15</td>
<td align="left">重复击键次数</td>
</tr>
<tr>
<td align="left">16-23</td>
<td align="left">OEM扫描码,基本用不到了</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">是否为拓展键</td>
</tr>
<tr>
<td align="left">25-28</td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left">如果Alt按下则为1</td>
</tr>
<tr>
<td align="left">30</td>
<td align="left">本键的先前状态,如果先前按下则为1</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left">本键状态,如果正在按下则为0</td>
</tr>
</tbody></table>
</blockquote>
<h5 id="if-nCode-0"><a href="#if-nCode-0" class="headerlink" title="if(nCode&#x3D;&#x3D;0)"></a>if(nCode&#x3D;&#x3D;0)</h5><p>例子中首先判断nCode&#x3D;&#x3D;0,这就确定了lParam和wParam代表的意义</p>
<h5 id="if-lParam-0x80000000"><a href="#if-lParam-0x80000000" class="headerlink" title="if(!(lParam&amp;0x80000000))"></a>if(!(lParam&amp;0x80000000))</h5><p>然后判断lParam的第31位是否是0,如果是0即对应键正在按下,则通过判断</p>
<h5 id="GetModuleFileNameA-NULL-szPath-MAX-PATH"><a href="#GetModuleFileNameA-NULL-szPath-MAX-PATH" class="headerlink" title="GetModuleFileNameA(NULL,szPath,MAX_PATH);"></a>GetModuleFileNameA(NULL,szPath,MAX_PATH);</h5><p>本函数用于获取本进程已经加载的模块的完整路径名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">GetModuleFileNameA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional] HMODULE hModule,</span></span><br><span class="line"><span class="params">  [out]          LPSTR   lpFilename,</span></span><br><span class="line"><span class="params">  [in]           DWORD   nSize</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>hModule指定一个本进程已经加载的模块,如果是NULL则返回当前exe应用程序的完整路径</p>
<p>lpFilename用于承载本函数返回的路径的缓冲区</p>
<p>nSize指定lpFilename的大小,防止缓冲区溢出</p>
<p>本例子中这样写<code>GetModuleFileNameA(NULL,szPath,MAX_PATH);</code></p>
<p>意思就是获取当前exe程序完整路径,放到szPath字符串数组中,该路径最长不能超过MAX_PATH长度</p>
<h5 id="p-strrchr-szPath"><a href="#p-strrchr-szPath" class="headerlink" title="p=strrchr(szPath,&#39;\\&#39;)"></a><code>p=strrchr(szPath,&#39;\\&#39;)</code></h5><p>strrchr用于返回szPath字符串中最后一次出现<code>\</code>字符的指针位置</p>
<blockquote>
<p>这里写了两个斜杠,第一个斜杠是转义的意思</p>
</blockquote>
<h5 id="if-stricmp-p-1-DEF-PROCESS-NAME"><a href="#if-stricmp-p-1-DEF-PROCESS-NAME" class="headerlink" title="if(!_stricmp(p+1,DEF_PROCESS_NAME))"></a>if(!_stricmp(p+1,DEF_PROCESS_NAME))</h5><p>stricmp相对于strcmp来说不区分字母大小写</p>
<p>这里DEF_PROCESS_NAME宏定义为”notepad.exe”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_PROCESS_NAME <span class="string">&quot;notepad.exe&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>即这里判断了刚才返回的本exe文件的名称是否是”notepad.exe”</p>
<p>如果是则返回1,那么该键盘消息就在钩链上中止了,无法到达notepad应用程序的消息队列了,自然表现为无法获取键盘输入</p>
<blockquote>
<p>这里钩子函数明明在KeyHook.dll中,那么怎么获取”本exe文件的名称”呢?</p>
<p>这是因为后来本dll文件会被操作系统强行注入exe进程的地址空间</p>
</blockquote>
<p>前面进行了三次判断,要求</p>
<p>nCode&#x3D;&#x3D;1表示键盘消息</p>
<p>lParam最高位为0表示键按下</p>
<p>当前应用程序名叫”notepad.exe”</p>
<p>如果有一次不满足则</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> CallNextHookEx(g_hHook,nCode,wParam,lParam);</span><br></pre></td></tr></table></figure>

<p>如果都满足则不再继续钩子,直接返回1</p>
<h4 id="HookMain-exe"><a href="#HookMain-exe" class="headerlink" title="HookMain.exe"></a>HookMain.exe</h4><p>钩子以dll模块的形式打包,HookMain.exe相当于一个注射器,只要HookMain.exe以运行,钩子模块就会被注入所有进程的地址空间.</p>
<p>钩子自己判断了当前注入的进程,是不是notepad进程,如果是则中断键盘消息的传送,否则继续传递键盘消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_DLL_NAME <span class="string">&quot;KeyHook.dll&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_HOOKSTART <span class="string">&quot;HookStart&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_HOOKSTOP <span class="string">&quot;HookStop&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*PFN_HOOKSTART)</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*PFN_HOOKSTOP)</span><span class="params">()</span>;</span><br><span class="line">PFN_HOOKSTART HookStart = <span class="literal">NULL</span>;</span><br><span class="line">PFN_HOOKSTOP HookStop = <span class="literal">NULL</span>;</span><br><span class="line">HMODULE hDll = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    hDll = LoadLibraryA(DEF_DLL_NAME);</span><br><span class="line"></span><br><span class="line">    HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);</span><br><span class="line">    HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);</span><br><span class="line"></span><br><span class="line">    HookStart();<span class="comment">//注册钩子</span></span><br><span class="line">    getchar();<span class="comment">//如果不输入则钩子一直起作用</span></span><br><span class="line">    HookStop();</span><br><span class="line">    FreeLibrary(hDll);<span class="comment">//注销钩子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc HookMain.cpp -o HookMain.exe </span><br></pre></td></tr></table></figure>








      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/08/19/lib%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/19/lib%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">程序员的自我修养 chapter 9 LIB</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-19 11:13:00 / Modified: 11:13:36" itemprop="dateCreated datePublished" datetime="2022-08-19T11:13:00+08:00">2022-08-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="windows-LIB文件格式"><a href="#windows-LIB文件格式" class="headerlink" title="windows LIB文件格式"></a>windows LIB文件格式</h1><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>以Math.c为例,将其分别编译静态库文件libMath.lib</p>
<p>Math.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__declspec(dllexport) <span class="type">double</span> <span class="title function_">Add</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">__declspec(dllexport) <span class="type">double</span> <span class="title function_">Sub</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line">__declspec(dllexport) <span class="type">double</span> <span class="title function_">Mul</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>制作静态库</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lib Math.c /NAME:libMath.lib</span><br></pre></td></tr></table></figure>

<p>lib以一个文件魔数<code>!&lt;arch&gt;\n</code>开头,</p>
<p>接下来顺次是First Section,Second Section,Long Section,Obj Section.</p>
<p>如果本lib文件中包括了多个obj文件则ObjSection可以有多个.</p>
<p>Long Section用来存放太长的obj名称,如果没有超过16个字节的obj名则该节不存在</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220818165031140.png" alt="libMath.lib的结构"></p>
<h3 id="文件头魔数"><a href="#文件头魔数" class="headerlink" title="文件头魔数"></a>文件头魔数</h3><p>不管是静态库还是导入库, 只要是lib文件,开头八个字节都得是文件魔数,</p>
<p>arch,archieve,归档</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220818144331204.png" alt="image-20220818144331204"></p>
<h3 id="节区"><a href="#节区" class="headerlink" title="节区"></a>节区</h3><p>每个节区都是以一个结构体开始,可以认为是”节区头”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SectionHeader</span>&#123;</span></span><br><span class="line">        <span class="type">char</span> Name[<span class="number">16</span>];      <span class="comment">// 节名称,即obj文件名</span></span><br><span class="line">        <span class="type">char</span> Time[<span class="number">12</span>];      <span class="comment">// 时间</span></span><br><span class="line">        <span class="type">char</span> UserID[<span class="number">6</span>];     <span class="comment">// 用户ID</span></span><br><span class="line">        <span class="type">char</span> GroupID[<span class="number">6</span>];    <span class="comment">// 组ID</span></span><br><span class="line">        <span class="type">char</span> Mode[<span class="number">8</span>];       <span class="comment">// 模式</span></span><br><span class="line">        <span class="type">char</span> Size[<span class="number">10</span>];      <span class="comment">// 节区正文长度</span></span><br><span class="line">        <span class="type">char</span> EndOfHeader[<span class="number">2</span>];<span class="comment">// 节头结束符</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>

<p>全都是字符串格式用字节存储,其好处是不管大小端机器,都可以兼容</p>
<p>很奇怪的是FirstSection采用大端模式,到了SecondSection就又成了小端存储了</p>
<p>节区头后面紧跟着是该节的节区正文</p>
<p>即每个节区都是节区头+节区正文格式</p>
<p>相邻两个节区之间可能存在<del>胸垫</del>填充,比如FirstSection的节区正文结束和SecondSection的节头开始之间就存在一个字节的填充</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220818164735293.png" alt="image-20220818164735293"></p>
<p>怎么判断有没有填充呢?怎么寻找下一个节的开始位置呢?</p>
<p>每个节头大小是固定的60字节,最后两个字节一定是endMarker[2]&#x3D;”\60 \0A”</p>
<h4 id="First-Section"><a href="#First-Section" class="headerlink" title="First Section"></a>First Section</h4><p><strong>大端模式</strong></p>
<p>包含库中<strong>所有</strong>符号名以及这些符号所在目标文件在本lib库文件中的偏移量</p>
<blockquote>
<p>此处”所有”是指参与组成本lib文件的所有目标文件中的所有符号,不只是一个目标文件中的所有符号</p>
</blockquote>
<p>其节名就用了一个字符”&#x2F;“</p>
<p>Size指明了本节正文占用了多少个字节</p>
<p>节正文结构:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FirstSection</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> SymbolNum;<span class="comment">//大端存储的符号数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> SymbolOffset[SymbolNum];<span class="comment">//符号所在目标节的偏移</span></span><br><span class="line">    <span class="type">char</span> StrTable[m];<span class="comment">//符号名称字符串表,m取决于所有符号的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于libMath.lib的第FirstSection,其节区正文的16进制表示为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SymbolNum = 00 00 00 03 </span><br><span class="line"></span><br><span class="line">SymbolOffset[SymbolNum] = </span><br><span class="line">	00 00 00 C2 </span><br><span class="line">	00 00 00 C2 </span><br><span class="line">	00 00 00 C2</span><br><span class="line"></span><br><span class="line">StrTable[m] = </span><br><span class="line">	5F 41 64 64 00 </span><br><span class="line">	5F 4D 75 6C 00 </span><br><span class="line">	5F 53 75 62 00</span><br></pre></td></tr></table></figure>

<p>在32位机器上long和int一样长都是32位,因此unsigned long占用了前4个字节</p>
<p>由于大端存储因此03在最高位(最右侧)</p>
<p><code>SymbolNum=3</code>,这与Math.c中正好有三个函数符号相吻合</p>
<p><code>SymbolOffset[3]=&#123;C2,C2,C2&#125;</code>这表明三个符号同属于一个目标模块,这个目标模块在本lib文件中的偏移量是C2</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220818152323244.png" alt="image-20220818152323244"></p>
<p>C2位置确实是第一个也是唯一一个ObjSection的偏移量,这个ObjSection就是Math.obj</p>
<p><code>StrTable[m]=_Add._Mul._Sub.</code>即所有符号名,每个符号名都以00结尾</p>
<h4 id="Second-Section"><a href="#Second-Section" class="headerlink" title="Second Section"></a>Second Section</h4><p><strong>小端模式</strong></p>
<p>内容和FirstSection相同,但是是一个有序表,查这个比查First Section来的快</p>
<p>名字也和FirstSection相同,都是”&#x2F;“</p>
<p>正文结构:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SecondSection</span>&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ObjNum;<span class="comment">//本库文件中的Obj节数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ObjOffset[ObjNum];<span class="comment">//每个Obj节分别的偏移量,</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> SymbolNum;<span class="comment">//所有符号数量,作用和FirstSection.SymbolNum相同</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> SymbolIdx[SymbolNum];<span class="comment">//第i个符号所在的Obj节下标</span></span><br><span class="line">	<span class="type">char</span> StrTable[m];<span class="comment">//符号名表,同FirstSection.StrTable,第i个符号的符号名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ObjNum= 01 00 00 00 </span><br><span class="line">ObjOffset[ObjNum] = C2 00 00 00 </span><br><span class="line">SymbolNum = 03 00 00 00 </span><br><span class="line">SymbolIdx[SymbolNum] = </span><br><span class="line">	01 00 </span><br><span class="line">	01 00</span><br><span class="line">	01 00 </span><br><span class="line">StrTable[SymbolNum] = </span><br><span class="line">	5F 41 64 64 00 		_Add\0</span><br><span class="line">	5F 4D 75 6C 00 		_Mul\0</span><br><span class="line">	5F 53 75 62 00		_Sum\0</span><br></pre></td></tr></table></figure>

<p>比较FirstSection和SecondSection</p>
<table>
<thead>
<tr>
<th></th>
<th>FirstSection</th>
<th>SecondSection</th>
<th>意义是否相同</th>
</tr>
</thead>
<tbody><tr>
<td>存储方式</td>
<td>大端</td>
<td>小端</td>
<td></td>
</tr>
<tr>
<td>记录符号个数</td>
<td>SymbolNum</td>
<td>SymbolNum</td>
<td>相同</td>
</tr>
<tr>
<td>记录符号位置</td>
<td>SymbolOffset[i]第i个符号所在obj的节偏移量</td>
<td>SymbolIdx[i]第i个符号所在的obj节是第几个obj节</td>
<td>不同</td>
</tr>
<tr>
<td>记录符号名</td>
<td>StrTable[m]</td>
<td>StrTable[m]</td>
<td>相同</td>
</tr>
<tr>
<td>记录Obj节数</td>
<td>无</td>
<td>ObjNum</td>
<td></td>
</tr>
<tr>
<td>记录每个Obj节的偏移量</td>
<td>无</td>
<td>ObjOffset[ObjNum]</td>
<td></td>
</tr>
</tbody></table>
<h4 id="Long-Section"><a href="#Long-Section" class="headerlink" title="Long Section"></a>Long Section</h4><p>长名称节,存放太长的obj名</p>
<p>每个节开始时的SectionHeader会记录该节的信息,但是SectionHeader.Name只有16字节,如果一个obj文件名比如”LinkedDoubleList.obj”长度就超过了16字节,用Name[16]显然放不下,就得放到Long section节里,Name[16]存放的是”<code>/&lt;LongSection中的偏移量&gt;</code>“表明该节名需要去Long Section找,并且给出了相对于该节的位置</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220818154931447.png" alt="image-20220818154931447"></p>
<p>Math.obj显然不够16个字节,本lib文件中没有该节</p>
<h4 id="Obj-Section"><a href="#Obj-Section" class="headerlink" title="Obj Section"></a>Obj Section</h4><p>目标文件节,存放不同的目标文件的原始数据.</p>
<p>本节的节区正文相当于把COFF文件直接乎过来了</p>
<p>节头:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220818154534122.png" alt="image-20220818154534122"></p>
<p>从名称上可以看出Math.obj&#x2F;</p>
<p>Size&#x3D;794本节正文长794个字节</p>
<p>节区正文是直接抄的obj文件</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220818155306689.png" alt="节区正文"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220818155335088.png" alt="Math.obj"></p>
<p>节区正文和Math.obj完全相同</p>
<h2 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h2><p>还是以Math.c制作动态库时形成的导入库Math.lib为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__declspec(dllexport) <span class="type">double</span> <span class="title function_">Add</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">__declspec(dllexport) <span class="type">double</span> <span class="title function_">Sub</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line">__declspec(dllexport) <span class="type">double</span> <span class="title function_">Mul</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cl Math.c /c</span><br><span class="line">link /dll Math.obj</span><br></pre></td></tr></table></figure>

<p>编译链接完成后同一目录下面形成Math.lib和Math.dll</p>
<p>此Math.lib就是导入库</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220818165520115.png" alt="image-20220818165520115"></p>
<p>从节头名看,前两个节分别是FirstSection和SecondSection,后面就都是目标文件了</p>
<h3 id="文件头魔数-1"><a href="#文件头魔数-1" class="headerlink" title="文件头魔数"></a>文件头魔数</h3><p>所有lib文件不管是静态库还是导入库都一样<code>!&lt;arch&gt;</code></p>
<h3 id="节区-1"><a href="#节区-1" class="headerlink" title="节区"></a>节区</h3><h4 id="First-Section-1"><a href="#First-Section-1" class="headerlink" title="First Section"></a>First Section</h4><p>节头除了本节正文大小之外就没有什么有效信息了主要是看节区:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FirstSection</span>&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> SymbolNum;<span class="comment">//大端存储的符号数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> SymbolOffset[SymbolNum];<span class="comment">//符号所在目标节的偏移</span></span><br><span class="line">    <span class="type">char</span> StrTable[m];<span class="comment">//符号名称字符串表,m取决于所有符号的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SymbolNum = 00 00 00 09 </span><br><span class="line">SymbolOffset[SymbolNum] = </span><br><span class="line">00 00 01 CA </span><br><span class="line">00 00 03 E8 </span><br><span class="line">00 00 05 1C</span><br><span class="line">00 00 06 68 </span><br><span class="line">00 00 06 68 </span><br><span class="line">00 00 07 24 </span><br><span class="line">00 00 07 24</span><br><span class="line">00 00 06 C6 </span><br><span class="line">00 00 06 C6 </span><br><span class="line">StrTable[m] = </span><br><span class="line">__IMPORT_DESCRIPTOR_Math: 5F 5F 49 4D 50 4F 52 54 5F 44 45 53 43 52 49 50 54 4F 52 5F 4D 61 74 68 00 </span><br><span class="line">__NULL_IMPORT_DESCRIPTOR: 5F 5F 4E 55 4C 4C 5F 49 4D 50 4F 52 54 5F 44 45 53 43 52 49 50 54 4F 52 00 </span><br><span class="line">Math_NULL_THUNK_DATA: 7F 4D 61 74 68 5F 4E 55 4C 4C 5F 54 48 55 4E 4B 5F 44 41 54 41 00</span><br><span class="line">_Add: 5F 41 64 64 00 </span><br><span class="line">__imp__Add: 5F 5F 69 6D 70 5F 5F 41 64 64 00</span><br><span class="line">_Sub: 5F 53 75 62 00 </span><br><span class="line">__imp__Sub: 5F 5F 69 6D 70 5F 5F 53 75 62 00</span><br><span class="line">_Mul: 5F 4D 75 6C 00 </span><br><span class="line">__imp__Mul: 5F 5F 69 6D 70 5F 5F 4D 75 6C 00</span><br></pre></td></tr></table></figure>

<p>可以看出本导入库中有9个符号,前三个符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__IMPORT_DESCRIPTOR_Math</span><br><span class="line">__NULL_IMPORT_DESCRIPTOR </span><br><span class="line">Math_NULL_THUNK_DATA</span><br></pre></td></tr></table></figure>

<p>是预定义的,就算我们啥也不写,照样有这三个符号</p>
<p>然后每个我们自己写的函数都有两个名字,比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_Add</span><br><span class="line">__imp__Add</span><br></pre></td></tr></table></figure>

<p>这是x64符号名修饰造成的,实际上两个符号指向同一函数</p>
<h4 id="Second-Section-1"><a href="#Second-Section-1" class="headerlink" title="Second Section"></a>Second Section</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SecondSection</span>&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ObjNum;<span class="comment">//本库文件中的Obj节数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ObjOffset[ObjNum];<span class="comment">//每个Obj节分别的偏移量,</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> SymbolNum;<span class="comment">//所有符号数量,作用和FirstSection.SymbolNum相同</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> SymbolIdx[SymbolNum];<span class="comment">//第i个符号所在的Obj节下标</span></span><br><span class="line">	<span class="type">char</span> StrTable[m];<span class="comment">//符号名表,同FirstSection.StrTable,第i个符号的符号名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ObjNum = 06 00 00 00 </span><br><span class="line">ObjOffset[ObjNum]=</span><br><span class="line">	CA 01 00 00 </span><br><span class="line">	E8 03 00 00 </span><br><span class="line">	1C 05 00 00</span><br><span class="line">	68 06 00 00 </span><br><span class="line">	24 07 00 00 </span><br><span class="line">	C6 06 00 00 </span><br><span class="line">SymbolNum=09 00 00 00</span><br><span class="line">SymbolIdx[SymbolNum]=</span><br><span class="line">	04 00 </span><br><span class="line">	06 00 </span><br><span class="line">	05 00 </span><br><span class="line">	01 00 </span><br><span class="line">	02 00 </span><br><span class="line">	04 00 </span><br><span class="line">	06 00 </span><br><span class="line">	05 00</span><br><span class="line">	03 00 </span><br><span class="line">StrTable[m]=</span><br><span class="line">5F 41 64 64 00 </span><br><span class="line">5F 4D 75 6C 00 </span><br><span class="line">5F 53 75 62 00 </span><br><span class="line">5F 5F 49 4D 50 4F 52 54 5F 44 45 53 43 52 49 50 54 4F 52 5F 4D 61 74 68 00 </span><br><span class="line">5F 5F 4E 55 4C 4C 5F 49 4D 50 4F 52 54 5F 44 45 53 43 52 49 50 54 4F 52 00 </span><br><span class="line">5F 5F 69 6D 70 5F 5F 41 64 64 00 </span><br><span class="line">5F 5F 69 6D 70 5F 5F 4D 75 6C 00 </span><br><span class="line">5F 5F 69 6D 70 5F 5F 53 75 62 00 </span><br><span class="line">7F 4D 61 74 68 5F 4E 55 4C 4C 5F 54 48 55 4E 4B 5F 44 41 54 41 00</span><br></pre></td></tr></table></figure>

<p>共有6个ObjSection段</p>
<p>每个ObjSection的节头中的名字都叫”Math.dll”</p>
<h4 id="Obj-Section-1"><a href="#Obj-Section-1" class="headerlink" title="Obj Section"></a>Obj Section</h4><p>前三个Obj节都是关于三个预定义符号的,所有的导入库中他仨基本相同</p>
<p>后面三个Obj节是关于我们自定义的函数的,每个自定义函数自成一节,这也就解释了为啥默认状态下动态库的链接是以函数为单位,而静态库的链接是以模块为单位的了.导入库中每个函数自成一个模块</p>
<p>下面炎鸠后三节的结构,参考<a target="_blank" rel="noopener" href="https://www.codeproject.com/Articles/1253835/The-Structure-of-import-Library-File-lib">The Structure of import Library File (.lib) - CodeProject</a></p>
<p>以Add函数所在节为例</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220819104759118.png" alt="image-20220819104759118"></p>
<p>节头表明正文部分有34字节</p>
<p>描述正文的结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SYMBOL_DESCRIPTOR</span>          // <span class="title">size</span> =</span> <span class="number">0x14</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD a;</span><br><span class="line">    WORD b;</span><br><span class="line">    WORD c;</span><br><span class="line">    WORD Architecture;<span class="comment">//程序可以运行的体系结构,比如x86,x86_64</span></span><br><span class="line">    DWORD Id;<span class="comment">//随机生成的ID</span></span><br><span class="line">    DWORD Length;<span class="comment">//符号名和库名 字符串总长度</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        WORD Hint;<span class="comment">//最有可能的序号</span></span><br><span class="line">        WORD Ordinal;</span><br><span class="line">        WORD Value;</span><br><span class="line">    &#125;</span><br><span class="line">    WORD Type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00 00 </span><br><span class="line">FF FF </span><br><span class="line">00 00 </span><br><span class="line">4C 01 //Architecture,x86</span><br><span class="line">F2 29 95 FA //随机数</span><br><span class="line">0E 00 00 00 //_Add\0Math.dll\0 两个字符串的总长度(包括00)</span><br><span class="line">00 00 //Hint=0,表示AddressOfNames中的下标</span><br><span class="line">08 00 //Type=8,表示x86 __cdecl调用约定</span><br><span class="line"></span><br><span class="line">5F 41 64 64 00 //_Add </span><br><span class="line">4D 61 74 68 2E 64 6C 6C 00 //Math.dll </span><br></pre></td></tr></table></figure>



<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="MSVC"><a href="#MSVC" class="headerlink" title="MSVC"></a>MSVC</h3><h4 id="cl-c-只编译-不链接-生成目标模块"><a href="#cl-c-只编译-不链接-生成目标模块" class="headerlink" title="cl &#x2F;c 只编译,不链接,生成目标模块"></a>cl &#x2F;c 只编译,不链接,生成目标模块</h4><h4 id="lib-EXTRACT-OUT-从lib文件中提取obj文件"><a href="#lib-EXTRACT-OUT-从lib文件中提取obj文件" class="headerlink" title="lib &#x2F;EXTRACT:&lt;目标文件&gt; &#x2F;OUT:&lt;目标文件&gt; 从lib文件中提取obj文件"></a>lib &#x2F;EXTRACT:&lt;目标文件&gt; &#x2F;OUT:&lt;目标文件&gt; 从lib文件中提取obj文件</h4><h4 id="lib-Math-c-NAME-libMath-lib-制作静态库"><a href="#lib-Math-c-NAME-libMath-lib-制作静态库" class="headerlink" title="lib Math.c &#x2F;NAME:libMath.lib 制作静态库"></a>lib Math.c &#x2F;NAME:libMath.lib 制作静态库</h4><h4 id="link-dll-Math-obj-制作动态库"><a href="#link-dll-Math-obj-制作动态库" class="headerlink" title="link &#x2F;dll Math.obj 制作动态库"></a>link &#x2F;dll Math.obj 制作动态库</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/08/18/DLL%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/18/DLL%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/" class="post-title-link" itemprop="url">程序员的自我修养 chapter 9 DLL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-18 10:15:00" itemprop="dateCreated datePublished" datetime="2022-08-18T10:15:00+08:00">2022-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-17 01:16:47" itemprop="dateModified" datetime="2024-10-17T01:16:47+08:00">2024-10-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="多练练"><a href="#多练练" class="headerlink" title="多练练"></a>多练练</h1><blockquote>
<p>菜就DLL</p>
</blockquote>
<p>DLL刚用起来的时候感觉狠抽象</p>
<p>用MSVC编译生成DLL的同时还会伴随形成两个文件</p>
<p>dll,exp,lib他仨就跟那黄金三镖客似的</p>
<p>使用link命令链接的时候却不用指定dll文件,只需要指定lib文件.</p>
<p>但是运行的时候dll还得和exe在同一个目录下面,否则就报告缺少哪个哪个dll</p>
<p>要是用gcc链接吧,就可以直接链接dll,什么exp什么lib根本用不到</p>
<p>到底怎么才算是一个标准的写法?DLL怎么写,怎么编译,怎么链接.都是问题</p>
<h2 id="DLL"><a href="#DLL" class="headerlink" title="DLL"></a>DLL</h2><p>windows上的动态库,特点不用废话了</p>
<h3 id="创建DLL"><a href="#创建DLL" class="headerlink" title="创建DLL"></a>创建DLL</h3><h4 id="declspec-dllexport"><a href="#declspec-dllexport" class="headerlink" title="__declspec(dllexport)"></a>__declspec(dllexport)</h4><p>表示该符号(函数或者全局变量)是要从本DLL中导出的.</p>
<blockquote>
<p>就DLL屁事多,创建so动态库的时候也没见声明为导出函数</p>
</blockquote>
<blockquote>
<p>可以不使用<code>__declspec(dllexport)</code>,改为使用链接脚本导出符号</p>
<h4 id="使用链接脚本"><a href="#使用链接脚本" class="headerlink" title="使用链接脚本"></a>使用链接脚本</h4><p>除了用<code>__declspec</code>声明导入导出函数,还可以使用.def文件控制链接过程</p>
<p><code>Math.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">Add</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">Sub</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">Mul</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Math.def</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY Math</span><br><span class="line">EXPORTS</span><br><span class="line">Add</span><br><span class="line">Sub</span><br><span class="line">Mul</span><br></pre></td></tr></table></figure>

<p>使用链接脚本编译<code>Math.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl Math.c /LD /DEF Math.def</span><br></pre></td></tr></table></figure>

<p>此步执行后还是生成了老四样</p>
<p>之后链接就按照”使用DLL”进行</p>
</blockquote>
<h4 id="Math-c"><a href="#Math-c" class="headerlink" title="Math.c"></a>Math.c</h4><p>一个很简单的DLL文件<code>Math.c</code>,这里使用<code>__declspec(dllexport)</code>声明导出符号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__declspec(dllexport) <span class="type">double</span> <span class="title function_">Add</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">__declspec(dllexport) <span class="type">double</span> <span class="title function_">Sub</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line">__declspec(dllexport) <span class="type">double</span> <span class="title function_">Mul</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里所有的函数都是用<code>__declspec(dllexport)</code>修饰为导出函数,作用是给链接器提供信息,如果不声明为导出函数,编译链接运行也都不会出错,但是运行的时候啥也不会发生</p>
</blockquote>
<h4 id="编译Math-c"><a href="#编译Math-c" class="headerlink" title="编译Math.c"></a>编译Math.c</h4><p>使用MSVC工具编译生成dll文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /LDd Math.c</span><br></pre></td></tr></table></figure>

<p>此后生成了四个文件,obj,lib,exp,dll</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\desktop\testDLL&gt; <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: C:\Users\<span class="number">86135</span>\desktop\testDLL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line"><span class="literal">----</span>                 <span class="literal">-------------</span>         <span class="literal">------</span> <span class="literal">----</span></span><br><span class="line"><span class="literal">-a----</span>          <span class="number">2022</span>/<span class="number">8</span>/<span class="number">8</span>     <span class="number">15</span>:<span class="number">47</span>            <span class="number">222</span> Math.c</span><br><span class="line"><span class="literal">-a----</span>          <span class="number">2022</span>/<span class="number">8</span>/<span class="number">8</span>     <span class="number">15</span>:<span class="number">48</span>         <span class="number">339968</span> Math.dll</span><br><span class="line"><span class="literal">-a----</span>          <span class="number">2022</span>/<span class="number">8</span>/<span class="number">8</span>     <span class="number">15</span>:<span class="number">48</span>            <span class="number">810</span> Math.exp</span><br><span class="line"><span class="literal">-a----</span>          <span class="number">2022</span>/<span class="number">8</span>/<span class="number">8</span>     <span class="number">15</span>:<span class="number">48</span>           <span class="number">1918</span> Math.lib</span><br><span class="line"><span class="literal">-a----</span>          <span class="number">2022</span>/<span class="number">8</span>/<span class="number">8</span>     <span class="number">15</span>:<span class="number">48</span>            <span class="number">779</span> Math.obj</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Math.obj</td>
<td>编译阶段完成的产物,目标文件</td>
</tr>
<tr>
<td>Math.lib</td>
<td>导入库,起到胶水作用</td>
</tr>
<tr>
<td>Math.exp</td>
<td></td>
</tr>
<tr>
<td>Math.dll</td>
<td>动态库本尊</td>
</tr>
</tbody></table>
<h3 id="使用DLL"><a href="#使用DLL" class="headerlink" title="使用DLL"></a>使用DLL</h3><h4 id="declspec-dllimport"><a href="#declspec-dllimport" class="headerlink" title="__declspec(dllimport)"></a>__declspec(dllimport)</h4><p>表示该符号是从其他DLL中导入的</p>
<p>使用DLL的过程就是引入DLL导出符号的过程,即导入过程</p>
<h4 id="TestMath-c"><a href="#TestMath-c" class="headerlink" title="TestMath.c"></a>TestMath.c</h4><p>同一目录下<code>TestMath.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">__declspec(dllimport) <span class="type">double</span> <span class="title function_">Sub</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">double</span> result=Sub(<span class="number">1.0</span>,<span class="number">8.9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result=%.2f&quot;</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编译TestMath-c"><a href="#编译TestMath-c" class="headerlink" title="编译TestMath.c"></a>编译TestMath.c</h4><p>首先将<code>TestMath.c</code>编译成目标文件<code>TestMath.obj</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /c TestMath.c</span><br></pre></td></tr></table></figure>

<h4 id="链接导入库"><a href="#链接导入库" class="headerlink" title="链接导入库"></a>链接导入库</h4><p>然后将<code>TestMath.obj</code>与刚才的库文件链接</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link TestMath.obj Math.lib</span><br></pre></td></tr></table></figure>

<p>生成了TestMath.exe</p>
<p>这就很奇怪了,为啥参与链接的是<code>Math.lib</code>一个静态库文件,而不是<code>Math.dll</code>动态库文件?</p>
<blockquote>
<p>甚至直接链接dll文件会报错</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\desktop\testDLL&gt; link TestMath.obj Math.dll</span><br><span class="line">Microsoft (<span class="built_in">R</span>) Incremental Linker Version <span class="number">14.31</span>.<span class="number">31106.2</span></span><br><span class="line">Copyright (C) Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line">Math.dll : fatal error LNK1107: 文件无效或损坏: 无法在 <span class="number">0</span>x300 处读取</span><br></pre></td></tr></table></figure>

<p>直接链接exp文件也会出错</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220808160800411.png" alt="image-20220808160800411"></p>
<h4 id="运行TestMath-exe"><a href="#运行TestMath-exe" class="headerlink" title="运行TestMath.exe"></a>运行TestMath.exe</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./TestMath.exe</span><br><span class="line">result=-7.90</span><br></pre></td></tr></table></figure>







<h3 id="运行时链接"><a href="#运行时链接" class="headerlink" title="运行时链接"></a>运行时链接</h3><p>前面使用DLL是装载时导入动态库.</p>
<p>现在要在运行时导入动态库</p>
<h4 id="LoadLibray"><a href="#LoadLibray" class="headerlink" title="LoadLibray"></a>LoadLibray</h4><p>装载一个dll到进程的地址空间,作用类似于linux上的dlopen</p>
<h4 id="GetProcAddress"><a href="#GetProcAddress" class="headerlink" title="GetProcAddress"></a>GetProcAddress</h4><p>查找某dll库中的某个符号的地址,作用类似于linux上的dlsym</p>
<h4 id="FreeLibrary"><a href="#FreeLibrary" class="headerlink" title="FreeLibrary"></a>FreeLibrary</h4><p>卸载一个已经加载过的dll库,作用类似于dlclose</p>
<h4 id="运行时链接-1"><a href="#运行时链接-1" class="headerlink" title="运行时链接"></a>运行时链接</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">double</span> <span class="params">(*Func)</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span>;</span><br><span class="line">Func <span class="title function_">getFunction</span><span class="params">(<span class="type">char</span> *DllName,<span class="type">char</span> *FuncName)</span>&#123;</span><br><span class="line"></span><br><span class="line">    HINSTANCE hinstLib=LoadLibrary(DllName);</span><br><span class="line">    <span class="keyword">if</span>(hinstLib==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR: loading failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Func function =(Func)GetProcAddress(hinstLib,FuncName);</span><br><span class="line">    <span class="keyword">if</span>(!function)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no such function in this module\n&quot;</span>);</span><br><span class="line">        FreeLibrary(hinstLib);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> function;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Func Add=getFunction(<span class="string">&quot;Math.dll&quot;</span>,<span class="string">&quot;Add&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!Add)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;load function failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> Sum=Add(<span class="number">5</span>,<span class="number">7.9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum=%.2f\n&quot;</span>,Sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl Math.c</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./Math.exe</span><br><span class="line">Sum=<span class="number">12.90</span></span><br></pre></td></tr></table></figure>







<h2 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h2><h3 id="DataDirectory-0"><a href="#DataDirectory-0" class="headerlink" title="DataDirectory[0]"></a>DataDirectory[0]</h3><p>导出符号表是PE文件头的DataDirectory结构数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PE头-&gt;</span><br><span class="line">	NT头-&gt;</span><br><span class="line">		NT可选头-&gt;</span><br><span class="line">			DataDirectory[0]-&gt;</span><br><span class="line">				IMAGE_EXPORT_DIRECTORY-&gt;</span><br><span class="line">					-&gt;AddressOfFunctions</span><br><span class="line">					-&gt;AddressOfNames</span><br><span class="line">					-&gt;AddressOfOrdinals</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">  DWORD VirtualAddress;</span><br><span class="line">  DWORD Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>这个数组的第一项就是导出表信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DataDirectory[<span class="number">0</span>]&#123;</span><br><span class="line">	VirtualAddress导出表的相对虚拟地址</span><br><span class="line">	Size 导出表的大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IMAGE-EXPORT-DIRECTORY"><a href="#IMAGE-EXPORT-DIRECTORY" class="headerlink" title="IMAGE_EXPORT_DIRECTORY"></a>IMAGE_EXPORT_DIRECTORY</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">  DWORD Characteristics;</span><br><span class="line">  DWORD TimeDateStamp;</span><br><span class="line">  WORD MajorVersion;</span><br><span class="line">  WORD MinorVersion;</span><br><span class="line">  DWORD Name;<span class="comment">//本模块名字,指向&quot;Math.dll&quot;字符串</span></span><br><span class="line">  DWORD Base;<span class="comment">//</span></span><br><span class="line">  DWORD NumberOfFunctions;<span class="comment">//导出函数总数</span></span><br><span class="line">  DWORD NumberOfNames;<span class="comment">//导出符号总数</span></span><br><span class="line">  DWORD AddressOfFunctions;<span class="comment">//导出地址表EAT</span></span><br><span class="line">  DWORD AddressOfNames;<span class="comment">//符号名表,保存导出函数的名字,按照字典序排列,方便按图索骥</span></span><br><span class="line">  DWORD AddressOfNameOrdinals;<span class="comment">//名字序号对应表</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>

<h4 id="导出地址表"><a href="#导出地址表" class="headerlink" title="导出地址表"></a>导出地址表</h4><p>导出地址表Export Address Table,EAT,存放的是导出函数在本库中的RVA</p>
<p>用IDA64观察这个位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.rdata:<span class="number">000000018004F</span>5B8 ; Export Address Table <span class="keyword">for</span> Math.dll</span><br><span class="line">.rdata:<span class="number">000000018004F</span>5B8 ;</span><br><span class="line">.rdata:<span class="number">000000018004F</span>5B8 off_18004F5B8   dd rva Add, rva Mul, rva Sub</span><br><span class="line">.rdata:<span class="number">000000018004F</span>5B8                                         ; DATA XREF: .rdata:<span class="number">000000018004F</span>5AC↑o</span><br></pre></td></tr></table></figure>

<p>可以发现<code>dd rva Add,rva Mul,rva Sub</code>字样,意思就是Add,Mul,Sub三个函数相对虚拟地址,双击可以直接跳转到该函数的定义</p>
<p>转化成WORD数组得到:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> off_18004F5B8[<span class="number">6</span>] = &#123;</span><br><span class="line">    <span class="number">0x1000</span>, <span class="number">0x0000</span>, <span class="number">0x1040</span>, <span class="number">0x0000</span>, <span class="number">0x1020</span>, <span class="number">0x0000</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于imagebase&#x3D;0x180000000,因此RVA&#x3D;0x1000对应VA&#x3D;0x180001000,正好就是Add函数的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000180001000</span> Add             proc near    </span><br></pre></td></tr></table></figure>

<p>然而如果不借助ida64,我们只能知道这里是一个函数的开始,但是不知道这里是哪个函数.</p>
<h4 id="函数名表"><a href="#函数名表" class="headerlink" title="函数名表"></a>函数名表</h4><p>函数名表中实际存放的就是字符串的指针数组,只不过这些字符串是函数的名字罢了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rdata:<span class="number">000000018004F</span>5C4 ; Export Names Table <span class="keyword">for</span> Math.dll</span><br><span class="line">.rdata:<span class="number">000000018004F</span>5C4 ;</span><br><span class="line">.rdata:<span class="number">000000018004F</span>5C4 off_18004F5C4   dd rva aAdd, rva aMul, rva aSub</span><br></pre></td></tr></table></figure>

<p>ida给出的解释是,0x18004F5C4这个位置是Math.dll的导出函数名表,其中有三个名字,分别是aAdd,aMul,aSub,</p>
<p>貌似导出地址表和函数名表建立了一一对应的关系.</p>
<p>导出地址表的第0项是Add函数的地址,符号名表的第0项恰好又是Add函数名字字符串的指针</p>
<p>导出地址表的第1项是aMul函数的地址,符号名表的第1项又恰好是Mul函数名字字符串的指针</p>
<p>这是因为所有的导出函数都有一个名字.如果有匿名的导出函数就堆不起来了.匿名函数必须要有一个导出地址但是不一定有导出符号,因此导出地址表的表项数是大于等于函数名表的表项数的.</p>
<p>那么如果有匿名函数时,再怎样建立其函数地址和函数名的关联呢?</p>
<p>通过第三张表,符号序号对应表</p>
<h4 id="函数名符号对应表"><a href="#函数名符号对应表" class="headerlink" title="函数名符号对应表"></a>函数名符号对应表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rdata:<span class="number">000000018004F</span>5D0 ; Export Ordinals Table <span class="keyword">for</span> Math.dll</span><br><span class="line">.rdata:<span class="number">000000018004F</span>5D0 ;</span><br><span class="line">.rdata:<span class="number">000000018004F</span>5D0 word_18004F5D0  dw <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>              ; DATA XREF: .rdata:<span class="number">000000018004F</span>5B4↑o</span><br></pre></td></tr></table></figure>

<p>由于Math.dll中每个函数都具名,因此此时这个函数名符号对应表很奇怪,或者说很弱智</p>
<p>它的第i项上的值是i</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ordinals[0]=0</span><br><span class="line">Ordinals[1]=1</span><br><span class="line">Ordinals[2]=2</span><br></pre></td></tr></table></figure>

<p>为啥要这样呢?这是一个历史遗留问题</p>
<h5 id="历史遗留问题"><a href="#历史遗留问题" class="headerlink" title="历史遗留问题"></a>历史遗留问题</h5><p>早期的计算机内存很小,使用函数名就得存放字符串,这会占用大量内存.</p>
<p>因此当时函数导出不能使用函数名,而是使用函数序号.</p>
<blockquote>
<p> 这就相当于啥呢,监狱里给犯人编号,不管哪个狱警只要含1000号都是指同一个犯人.</p>
</blockquote>
<p>函数序号是怎么编号的呢?一个函数在地址导出表中的下标假设是x,那么它的序号就是IMAGE_EXPORT_DIRECTORY.Base+x</p>
<p>如果一个exe程序需要导入这个函数,</p>
<p>它的导入表中只需要记录IMAGE_EXPORT_DIRECTORY.Base+x,</p>
<p>然后减去IMAGE_EXPORT_DIRECTORY.Base得到对应函数在Math.dll地址导出表EAT中的下标,</p>
<p>拿这个下标一查EAT表就得到了对应函数的相对虚拟地址了</p>
<p>然而为啥要加一个Base再减去他呢?这不多此一举吗?</p>
<blockquote>
<p>书上并没有给出解释,我的想法是,假设A库有1000个导出函数,B库有500个刀殂函数,A库的Base&#x3D;1,那么A库的函数序号会占用1~1000,如果B库和A库统一编号,则B库的Base就是1001.</p>
</blockquote>
<h5 id="现在的解决方案"><a href="#现在的解决方案" class="headerlink" title="现在的解决方案"></a>现在的解决方案</h5><blockquote>
<p>在现在PC机都能达到4G,8G,16G内存的时代,显然没必要这么抠门.</p>
<p>但是以前的机器内存是以K或者M为单位的,以1976年的8086为例,它的内存有1M&#x3D;1000K.</p>
<p>一个字符占用1B,假设一个库文件中有1K个函数,每个函数名字长10个字符,这就是10kB,已经占用了内存总量的1&#x2F;100.</p>
<p>对于今天的x86_64一个16G内存的计算机,10K根本不算东西</p>
</blockquote>
<p>于是现在使用符号导出,向后兼容保留了序号导入的方式</p>
<p>一个exe文件的导入表中保存的是符号名,如果要调用这个库函数,需要</p>
<p>先查对应库的函数名表,得到对应函数名字符串在函数名表中的下标i0,</p>
<p>用这个下标i0作为符号名序号对应表的下标去查这个Ordinals表,Ordinals[i0]-IMAGE_EXPORT_DIRECTORY.Base得到的又是一个下标i1</p>
<p>然后拿着这个新下标i1去查导出地址表EAT,EAT[i1]上面放着的就是对应函数的相对虚拟地址了</p>
<blockquote>
<p>以书上给出的例子推导一遍</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220815165550845.png" alt="image-20220815165550845"></p>
<p>现在需要调用Mul函数,</p>
<p>首先去AddressOfNames指向的函数名表查,由于这里的函数名是按照字典序排列的,可以使用二分查找加速.不管怎么,这里查找的结果是AddressOfNames[2]&#x3D;Mul,也就是说,下标为2对应的是Mul</p>
<p>然后去AddressOfNames指向的符号序号对应表查AddressOfNames[2]&#x3D;2,减去base(1)得到1,也就是说Mul在导出地址表EAT中的下标是1</p>
<p>然后去查AddressOfFunctions指向的导出地址表,AddressOfFunctions[1]&#x3D;0x1020即Mul相对于其所在库基址的虚拟地址</p>
</blockquote>
<h5 id="向后兼容问题"><a href="#向后兼容问题" class="headerlink" title="向后兼容问题"></a>向后兼容问题</h5><p>为了兼容以前的序号导入,需要保证已有的函数序号不改变,</p>
<p>还得保证所有函数名在AddressOfNames这个函数名表中按照字典序排列</p>
<p>如何同时满足这两点要求呢?</p>
<p><strong>现在时光回溯到七八十年代</strong>,假设Math.dll是当时开发的</p>
<p>假设<strong>原来的库</strong>有三个导出函数Add,Mul,Sub,一开始的时候没有符号名表(或者说有也不用),因此一开始没有导出符号,</p>
<p>老头子程序员(当时他还是个年轻人)给这三个函数手工编序号1,2,3(这个编号随意,只不过这样编最方便)考虑到base默认为1,那么分别对应导出地址表中的下标就得是0,1,2</p>
<p>于是AddressOfFunctions[0]&#x3D;0x1000就是1号函数的地址,即Add函数在其库中的相对虚拟地址</p>
<blockquote>
<p>函数的序号先后对函数的<strong>地址大小</strong>有要求吗?</p>
<p>没有,在编写math.c源代码时,哪一个函数先写哪一个的相对虚拟地址就小,</p>
<p>比如这里Mul在符号表中排第2比Sub的第3靠前,但是Mul的地址0x1020比Sub的地址0x1010大</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220815170420215.png" alt="image-20220815170420215"></p>
<p><strong>现在时光来到2202年</strong></p>
<p>如今的程序员在符号名表中给这仨个函数加上了名字,此时已有的序号不能改,因此查符号表中Mul得到的下标一定得是1,同理符号表中查Add一定得到下标0,于是这三个函数的名字安排很简单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AddressOfNames[<span class="number">0</span>]=<span class="string">&quot;Add&quot;</span>;</span><br><span class="line">AddressOfNames[<span class="number">1</span>]=<span class="string">&quot;Mul&quot;</span>;</span><br><span class="line">AddressOfNames[<span class="number">2</span>]=<span class="string">&quot;Sub&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>到此完美解决了历史问题,即函数只有序号没有名字这个问题</p>
<p>下面考虑新增的函数怎么安排</p>
<p>假设要增加一个”Div”函数,这个字符串的字典序在”Add”和”Mul”之间.</p>
<p>因此安排上它之后AddressOfNames这个符号名表应该是</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220815171746124.png" alt="image-20220815171746124"></p>
<p>原来查这个表中的Mul得到的下标是1,现在Div把它往后挤了一个位置,再查Mul得到的下标成2了,显然不能再拿着2去查原来的符号序号对照表了,因为原来的符号序号对照表的第2个是Sub的序号</p>
<p>这时候应该咋办呢?</p>
<p>新函数Div插入了AddressOfNames[1],那么原来的AddressOfNames[1]之后的各项顺延一个,AddressOfOrdinals数组中对应项也跟着顺延</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i=length(AddressOfNames);i&gt;1;--i)&#123;</span><br><span class="line">	AddressOfNames[i]=AddressOfNames[i-1];</span><br><span class="line">	AddressOfOrdinals[i]=AddressOfOrdinals[i-1];</span><br><span class="line">&#125;</span><br><span class="line">AddressOfNames[1]=&quot;Div&quot;;</span><br><span class="line">AddressOfOrdinals[1]=4</span><br></pre></td></tr></table></figure>

<p>这样查在AddressOfNames[i]中查Mul得到2,用2查AddressOfOrdinals[2]-base得到的还是原来的AddressOfFunctions中的下标.这就对应上了</p>
<p>还有一个问题没有解决, 新的函数怎么编号,新的函数放到地址导出表的那里?</p>
<p>地址导出表中的位置取决于编号,编号-base就是地址导出表中的下标,因此只需要确定编号</p>
<p>原来的编号已经有1,2,3了,那么4及之后的编号都可是使用,那么新函数Div可以获取任意一个大于等于4的编号.</p>
<p>假如给他的编号是4,那么4-base&#x3D;4-1&#x3D;3,那么导出地址表的AddressOfFunctions[3]就得是Div的相对虚拟地址</p>
<p>假如给他的编号是5,那么5-base&#x3D;5-1&#x3D;4,那么导出地址表的AddressOfFunctions[4]就得是Div的相对虚拟地址</p>
<p>…以此类推</p>
<p>如果给他的编号是5,那么4没有被使用,并且AddressOfFunctions[3]没有被使用,这合理吗?合理,由于编号4未使用,只要是日后再有新函数加进来,就可以给他分一个编号4,其相对虚拟地址就放在AddressOfFunctions[3].不流失不蒸发零浪费</p>
<p>书上这里就给了Div编号为5的情况</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220815172959162.png" alt="image-20220815172959162"></p>
<h3 id="指定导出符号"><a href="#指定导出符号" class="headerlink" title="指定导出符号"></a>指定导出符号</h3><p>指定导出符号有多种方法,比如<code>__declspec(dllexport)</code>编译器拓展修饰符或者def链接脚本,或者link命令行上直接指定</p>
<h4 id="declspec-dllexport-1"><a href="#declspec-dllexport-1" class="headerlink" title="__declspec(dllexport)"></a>__declspec(dllexport)</h4><p>此种方法编译器会,在只编译不链接形成的,obj文件中的.drectve段中,加入链接指示(实际上就是命令行参数)</p>
<p>链接器处理obj文件时会把.drectve中的信息提取出来放到命令行上当作链接命令</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\desktop\math&gt; cl /c Math.c</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SECTION HEADER <span class="comment">#1</span></span><br><span class="line">.drectve name</span><br><span class="line">       0 physical address</span><br><span class="line">       0 virtual address</span><br><span class="line">      53 size of raw data</span><br><span class="line">      B4 file pointer to raw data (000000B4 to 00000106)</span><br><span class="line">       0 file pointer to relocation table</span><br><span class="line">       0 file pointer to line numbers</span><br><span class="line">       0 number of relocations</span><br><span class="line">       0 number of line numbers</span><br><span class="line">  100A00 flags</span><br><span class="line">         Info</span><br><span class="line">         Remove</span><br><span class="line">         1 byte align</span><br><span class="line"></span><br><span class="line">RAW DATA <span class="comment">#1</span></span><br><span class="line">  00000000: 20 20 20 2F 44 45 46 41 55 4C 54 4C 49 42 3A 22     /DEFAULTLIB:<span class="string">&quot;</span></span><br><span class="line"><span class="string">  00000010: 4C 49 42 43 4D 54 22 20 2F 44 45 46 41 55 4C 54  LIBCMT&quot;</span> /DEFAULT</span><br><span class="line">  00000020: 4C 49 42 3A 22 4F 4C 44 4E 41 4D 45 53 22 20 2F  LIB:<span class="string">&quot;OLDNAMES&quot;</span> /</span><br><span class="line">  00000030: 45 58 50 4F 52 54 3A 41 64 64 20 2F 45 58 50 4F  EXPORT:Add /EXPO</span><br><span class="line">  00000040: 52 54 3A 53 75 62 20 2F 45 58 50 4F 52 54 3A 4D  RT:Sub /EXPORT:M</span><br><span class="line">  00000050: 75 6C 20                                         ul</span><br><span class="line"></span><br><span class="line">   Linker Directives</span><br><span class="line">   -----------------</span><br><span class="line">   /DEFAULTLIB:LIBCMT</span><br><span class="line">   /DEFAULTLIB:OLDNAMES</span><br><span class="line">   /EXPORT:Add</span><br><span class="line">   /EXPORT:Sub</span><br><span class="line">   /EXPORT:Mul</span><br></pre></td></tr></table></figure>

<p>因此这里使用编译器拓展修饰符的作用就<strong>相当于不写拓展修饰,但是使用link命令行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cl /c Math.c</span><br><span class="line">link /dll Math.obj /EXPORT:Add /EXPORT:Sub /EXPORT:Mul /DEFAULTLIB:LIBCMT /DEFAULTLIB:OLDNAMES</span><br></pre></td></tr></table></figure>

<p>后面这个<code>/DEFAULTLIB:</code>不写也可以,默认自带.LIBCMT全称Library C multithreaded,及VC的多线程C库</p>
<h4 id="link命令行"><a href="#link命令行" class="headerlink" title="link命令行"></a>link命令行</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cl /c Math.c</span><br><span class="line">link /dll Math.obj /EXPORT:Add /EXPORT:Sub /EXPORT:Mul</span><br></pre></td></tr></table></figure>

<p>&#x2F;EXPORT:&lt;函数名&gt;指定这个函数为导出函数</p>
<h4 id="def链接脚本"><a href="#def链接脚本" class="headerlink" title=".def链接脚本"></a>.def链接脚本</h4><p><code>Math.def</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY MATH</span><br><span class="line">EXPORTS</span><br><span class="line">Add</span><br><span class="line">Sub</span><br><span class="line">Mul</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl Math.c /LD /DEF Math.def</span><br></pre></td></tr></table></figure>

<h4 id="def链接脚本指定符号序号"><a href="#def链接脚本指定符号序号" class="headerlink" title="def链接脚本指定符号序号"></a>def链接脚本指定符号序号</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY Math</span><br><span class="line">EXPORTS</span><br><span class="line">Add@1</span><br><span class="line">Sub@2</span><br><span class="line">Mul@3</span><br><span class="line">Div @4 NONAME   </span><br></pre></td></tr></table></figure>

<p>NONAME意思是匿名导出函数,只有序号没有名字</p>
<h2 id="exp文件"><a href="#exp文件" class="headerlink" title="exp文件"></a>exp文件</h2><p>创建Math.dll是总会跟着生成一个Math.lib和一个Math.exp.</p>
<p>其中Math.lib是导入库.</p>
<p>Math.exp只是一个中间过程产物,没有作用,即使删了也不影响Math.lib和TestMath.obj的链接.</p>
<p>那这个玩意儿是干啥用的呢?</p>
<p>链接器创建DLL文件时会进行两遍扫描.</p>
<p>第一遍扫描会遍历所有的目标文件,收集所有导出符号以创建DLL导出表,</p>
<p>这第一遍扫描只是为了建立一个导出表,为了方便就直接创建了一个exp文件存放这个导出表.这个exp文件也是一个标准PE&#x2F;COFF文件</p>
<p>第二次扫描的时候该exp文件就和其他目标文件一样链接进入DLL.由于该exp文件中只有导出表,只读属性,因此exp文件的内容会合并到DLL的.rdata只读数据段</p>
<p>dll文件的导出表结构基本上是从exp照搬过来的</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220815223152579.png" alt="左exp右dll导出表"></p>
<p>exp文件的整个.edata区就只有一个导出表还有它指向的三个数组的信息</p>
<h4 id="exp-edata"><a href="#exp-edata" class="headerlink" title="exp.edata"></a>exp.edata</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.edata:<span class="number">0000000000000000</span> _edata          segment para public <span class="string">&#x27;DATA&#x27;</span> use64</span><br><span class="line">.edata:<span class="number">0000000000000000</span>                 assume cs:_edata</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//0x0到0x27是IMAGE_EXPORT_DIRECTORY结构体</span></span><br><span class="line">.edata:<span class="number">0000000000000000</span>                 dd <span class="number">0</span></span><br><span class="line">.edata:<span class="number">0000000000000004</span>                 dd <span class="number">0F</span>FFFFFFFh</span><br><span class="line">.edata:<span class="number">0000000000000008</span>                 dw <span class="number">0</span></span><br><span class="line">.edata:<span class="number">000000000000000</span>A                 dw <span class="number">0</span></span><br><span class="line">.edata:<span class="number">000000000000000</span>C                 dd offset szName        ; <span class="string">&quot;Math.dll&quot;</span>	;<span class="number">0x46</span></span><br><span class="line">.edata:<span class="number">0000000000000010</span>                 dd <span class="number">1</span></span><br><span class="line">.edata:<span class="number">0000000000000014</span>                 dd <span class="number">3</span></span><br><span class="line">.edata:<span class="number">0000000000000018</span>                 dd <span class="number">3</span></span><br><span class="line">.edata:<span class="number">000000000000001</span>C                 dd offset rgpv	;<span class="number">0x28</span></span><br><span class="line">.edata:<span class="number">0000000000000020</span>                 dd offset rgszName	;<span class="number">0x34</span></span><br><span class="line">.edata:<span class="number">0000000000000024</span>                 dd offset rgwOrd	;<span class="number">0x40</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">.edata:<span class="number">0000000000000028</span> rgpv            dd offset Add           ; DATA XREF: .edata:<span class="number">000000000000001</span>C↑o</span><br><span class="line">.edata:<span class="number">000000000000002</span>C                 dd offset Mul</span><br><span class="line">.edata:<span class="number">0000000000000030</span>                 dd offset Sub</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">.edata:<span class="number">0000000000000034</span> rgszName        dd offset $N00001       ; DATA XREF: .edata:<span class="number">0000000000000020</span>↑o</span><br><span class="line">.edata:<span class="number">0000000000000034</span>                                         ; <span class="string">&quot;Add&quot;</span></span><br><span class="line">.edata:<span class="number">0000000000000038</span>                 dd offset $N00002       ; <span class="string">&quot;Mul&quot;</span></span><br><span class="line">.edata:<span class="number">000000000000003</span>C                 dd offset $N00003       ; <span class="string">&quot;Sub&quot;</span></span><br><span class="line">    </span><br><span class="line">.edata:<span class="number">0000000000000040</span> rgwOrd          dw <span class="number">0</span>                    ; DATA XREF: .edata:<span class="number">0000000000000024</span>↑o</span><br><span class="line">.edata:<span class="number">0000000000000042</span>                 dw <span class="number">1</span></span><br><span class="line">.edata:<span class="number">0000000000000044</span>                 dw <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">.edata:<span class="number">0000000000000046</span> ; TCHAR szName[<span class="number">40</span>]</span><br><span class="line">.edata:<span class="number">0000000000000046</span> szName          db <span class="string">&#x27;Math.dll&#x27;</span>,<span class="number">0</span>         ; DATA XREF: .edata:<span class="number">000000000000000</span>C↑o</span><br><span class="line">.edata:<span class="number">000000000000004F</span> $N00001         db <span class="string">&#x27;Add&#x27;</span>,<span class="number">0</span>   ;<span class="number">4f</span>h           ; DATA XREF: .edata:rgszName↑o</span><br><span class="line">.edata:<span class="number">0000000000000053</span> $N00002         db <span class="string">&#x27;Mul&#x27;</span>,<span class="number">0</span>   ;           ; DATA XREF: .edata:<span class="number">0000000000000038</span>↑o</span><br><span class="line">.edata:<span class="number">0000000000000057</span> $N00003         db <span class="string">&#x27;Sub&#x27;</span>,<span class="number">0</span>              ; DATA XREF: .edata:<span class="number">000000000000003</span>C↑o</span><br><span class="line">.edata:<span class="number">0000000000000057</span> _edata          ends</span><br></pre></td></tr></table></figure>

<h5 id="0-0x58-edata段"><a href="#0-0x58-edata段" class="headerlink" title="[0,0x58)edata段"></a>[0,0x58)edata段</h5><p>edata段的文件偏移为0,到0x57字节结束,一共0x58个字节,其中</p>
<h5 id="0-0x28-IMAGE-EXPORT-DIRECTORY"><a href="#0-0x28-IMAGE-EXPORT-DIRECTORY" class="headerlink" title="[0,0x28) IMAGE_EXPORT_DIRECTORY"></a>[0,0x28) IMAGE_EXPORT_DIRECTORY</h5><p>0到0x27共40个字节是IMAGE_EXPORT_DIRECTORY结构体,也就是DataDirectory[0].VirtualAddress指向的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">  DWORD Characteristics;</span><br><span class="line">  DWORD TimeDateStamp;</span><br><span class="line">  WORD MajorVersion;</span><br><span class="line">  WORD MinorVersion;</span><br><span class="line">  DWORD Name;</span><br><span class="line">  DWORD Base;</span><br><span class="line">  DWORD NumberOfFunctions;</span><br><span class="line">  DWORD NumberOfNames;</span><br><span class="line">  DWORD AddressOfFunctions;</span><br><span class="line">  DWORD AddressOfNames;</span><br><span class="line">  DWORD AddressOfNameOrdinals;</span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>

<h5 id="0x28-0x34-导出地址表"><a href="#0x28-0x34-导出地址表" class="headerlink" title="[0x28,0x34) 导出地址表"></a>[0x28,0x34) 导出地址表</h5><p>0x28到0x33这12个字节是IMAGE_EXPORT_DIRECTORY.AddressOfFunctions指向的地址导出表EAT</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AddressOfFunctions[0]=0x60</span><br><span class="line">AddressOfFunctions[1]=0x68</span><br><span class="line">AddressOfFunctions[2]=0x70</span><br></pre></td></tr></table></figure>

<p>这里0x60,0x68,0x70指向的是.edata段之后的UNDEF部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UNDEF:<span class="number">0000000000000060</span> ; Segment type: Externs</span><br><span class="line">UNDEF:<span class="number">0000000000000060</span> ; UNDEF</span><br><span class="line">UNDEF:<span class="number">0000000000000060</span>                 extrn Add:near          ; DATA XREF: .edata:rgpv↑o</span><br><span class="line">UNDEF:<span class="number">0000000000000068</span>                 extrn Mul:near          ; DATA XREF: .edata:<span class="number">000000000000002</span>C↑o</span><br><span class="line">UNDEF:<span class="number">0000000000000070</span>                 extrn Sub:near          ; DATA XREF: .edata:<span class="number">0000000000000030</span>↑o</span><br></pre></td></tr></table></figure>

<p>每一项8个字节,是64位机器上一个指针的长度,看来应该是存放一个函数地址的地方.</p>
<p>显然这里是一个桩代码,因为exp文件不含这三个函数的定义,因此需要等到进入dll后才能确定三个函数的位置</p>
<h5 id="0x34-0x40-函数名表"><a href="#0x34-0x40-函数名表" class="headerlink" title="[0x34,0x40) 函数名表"></a>[0x34,0x40) 函数名表</h5><p>0x34到0x3F这12个字节是IMAGE_EXPORT_DIRECTORY.AddressOfNames指向的函数名表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_EXPORT_DIRECTORY.AddressOfNames[0]=0x4F</span><br><span class="line">IMAGE_EXPORT_DIRECTORY.AddressOfNames[0]=0x53</span><br><span class="line">IMAGE_EXPORT_DIRECTORY.AddressOfNames[0]=0x57</span><br></pre></td></tr></table></figure>

<p>而0x4F开始正好是三个函数名 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.edata:<span class="number">000000000000004F</span> $N00001         db <span class="string">&#x27;Add&#x27;</span>,<span class="number">0</span>              ; DATA XREF: .edata:rgszName↑o</span><br><span class="line">.edata:<span class="number">0000000000000053</span> $N00002         db <span class="string">&#x27;Mul&#x27;</span>,<span class="number">0</span>              ; DATA XREF: .edata:<span class="number">0000000000000038</span>↑o</span><br><span class="line">.edata:<span class="number">0000000000000057</span> $N00003         db <span class="string">&#x27;Sub&#x27;</span>,<span class="number">0</span>              ; DATA XREF: .edata:<span class="number">000000000000003</span>C↑o</span><br></pre></td></tr></table></figure>

<h5 id="0x40-0x46-符号序号对应表"><a href="#0x40-0x46-符号序号对应表" class="headerlink" title="[0x40,0x46) 符号序号对应表"></a>[0x40,0x46) 符号序号对应表</h5><p>0x40到0x45这6个字节是IMAGE_EXPORT_DIRECTORY.AddressOfOrdinals指向的符号序号对照表</p>
<p>这个表的表项是字类型的序号整数值,因此三个表项占用三个字,六个字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_EXPORT_DIRECTORY.AddressOfOrdinals[0]=0</span><br><span class="line">IMAGE_EXPORT_DIRECTORY.AddressOfOrdinals[1]=1</span><br><span class="line">IMAGE_EXPORT_DIRECTORY.AddressOfOrdinals[1]=1</span><br></pre></td></tr></table></figure>

<h5 id="0x46-0x58-字符串表"><a href="#0x46-0x58-字符串表" class="headerlink" title="[0x46,0x58) 字符串表"></a>[0x46,0x58) 字符串表</h5><p>最后一段,用来存放字符串表,包括dll名,三个函数名</p>
<h4 id="dll-rdata-导出表"><a href="#dll-rdata-导出表" class="headerlink" title="dll.rdata.导出表"></a>dll.rdata.导出表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.rdata:<span class="number">0000000180017</span>DE0 ; Export directory <span class="keyword">for</span> Math.dll</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DE0 ;</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DE0                 dd <span class="number">0</span>                    ; Characteristics</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DE4                 dd <span class="number">0F</span>FFFFFFFh           ; TimeDateStamp</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DE8                 dw <span class="number">0</span>                    ; MajorVersion</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DEA                 dw <span class="number">0</span>                    ; MinorVersion</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DEC                 dd rva aMathDll         ; Name</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DF0                 dd <span class="number">1</span>                    ; Base</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DF4                 dd <span class="number">3</span>                    ; NumberOfFunctions</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DF8                 dd <span class="number">3</span>                    ; NumberOfNames</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DFC                 dd rva off_180017E08    ; AddressOfFunctions</span><br><span class="line">.rdata:<span class="number">0000000180017E00</span>                 dd rva off_180017E14    ; AddressOfNames</span><br><span class="line">.rdata:<span class="number">0000000180017E04</span>                 dd rva word_180017E20   ; AddressOfNameOrdinals</span><br><span class="line">.rdata:<span class="number">0000000180017E08</span> ;</span><br><span class="line">.rdata:<span class="number">0000000180017E08</span> ; Export Address Table <span class="keyword">for</span> Math.dll</span><br><span class="line">.rdata:<span class="number">0000000180017E08</span> ;</span><br><span class="line">.rdata:<span class="number">0000000180017E08</span> off_180017E08   dd rva Add, rva Mul, rva Sub</span><br><span class="line">.rdata:<span class="number">0000000180017E08</span>                                         ; DATA XREF: .rdata:<span class="number">0000000180017</span>DFC↑o</span><br><span class="line">.rdata:<span class="number">0000000180017E14</span> ;</span><br><span class="line">.rdata:<span class="number">0000000180017E14</span> ; Export Names Table <span class="keyword">for</span> Math.dll</span><br><span class="line">.rdata:<span class="number">0000000180017E14</span> ;</span><br><span class="line">.rdata:<span class="number">0000000180017E14</span> off_180017E14   dd rva aAdd, rva aMul, rva aSub</span><br><span class="line">.rdata:<span class="number">0000000180017E14</span>                                         ; DATA XREF: .rdata:<span class="number">0000000180017E00</span>↑o</span><br><span class="line">.rdata:<span class="number">0000000180017E14</span>                                         ; <span class="string">&quot;Add&quot;</span> ...</span><br><span class="line">.rdata:<span class="number">0000000180017E20</span> ;</span><br><span class="line">.rdata:<span class="number">0000000180017E20</span> ; Export Ordinals Table <span class="keyword">for</span> Math.dll</span><br><span class="line">.rdata:<span class="number">0000000180017E20</span> ;</span><br><span class="line">.rdata:<span class="number">0000000180017E20</span> word_180017E20  dw <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>              ; DATA XREF: .rdata:<span class="number">0000000180017E04</span>↑o</span><br><span class="line">.rdata:<span class="number">0000000180017E26</span> aMathDll        db <span class="string">&#x27;Math.dll&#x27;</span>,<span class="number">0</span>         ; DATA XREF: .rdata:<span class="number">0000000180017</span>DEC↑o</span><br><span class="line">.rdata:<span class="number">0000000180017E2</span>F aAdd            db <span class="string">&#x27;Add&#x27;</span>,<span class="number">0</span>              ; DATA XREF: .rdata:off_180017E14↑o</span><br><span class="line">.rdata:<span class="number">0000000180017E33</span> aMul            db <span class="string">&#x27;Mul&#x27;</span>,<span class="number">0</span>              ; DATA XREF: .rdata:off_180017E14↑o</span><br><span class="line">.rdata:<span class="number">0000000180017E37</span> aSub            db <span class="string">&#x27;Sub&#x27;</span>,<span class="number">0</span>              ; DATA XREF: .rdata:off_180017E14↑o</span><br></pre></td></tr></table></figure>

<h5 id="0x180017DE0-0x180017E38"><a href="#0x180017DE0-0x180017E38" class="headerlink" title="[0x180017DE0,0x180017E38)"></a>[0x180017DE0,0x180017E38)</h5><p>共58个字节,正好和exp.edata段对应,甚至每个字节意义都对应</p>
<table>
<thead>
<tr>
<th>成分</th>
<th>exp.edata</th>
<th>dll.idata.导出表</th>
</tr>
</thead>
<tbody><tr>
<td>IMAGE_EXPORT_DIRECTORY结构体</td>
<td>[0,0x28)</td>
<td>[0x180017DE0,0x180017E08)</td>
</tr>
<tr>
<td>导出地址表</td>
<td>[0x28,0x34)</td>
<td>[0x180017E08,0x180017E14)</td>
</tr>
<tr>
<td>函数名表</td>
<td>[0x34,0x40)</td>
<td>[0x180017E14,0x180017E20)</td>
</tr>
<tr>
<td>符号序号对应表</td>
<td>[0x40,0x46)</td>
<td>[0x180017E20,0x180017E26)</td>
</tr>
<tr>
<td>字符串表</td>
<td>[0x46,0x58)</td>
<td>[0x180017E26,0x180017E38)</td>
</tr>
</tbody></table>
<p>相当于把exp.edata段照搬到dll的0x180017DE0处,然后修改了到处地址表指向的函数地址.显然这个事应该是运行时动态链接器干的.</p>
<p>类似于GOT和PLT的机制</p>
<h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><p>使用dumpbin观察Math.dll的导入表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="number">86135</span>\desktop\Math&gt; dumpbin /IMPORTS Math.dll</span><br><span class="line"><span class="title function_">Microsoft</span> <span class="params">(R)</span> COFF/PE Dumper Version 14.31.31106.2</span><br><span class="line"><span class="title function_">Copyright</span> <span class="params">(C)</span> Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dump of file Math.dll</span><br><span class="line"></span><br><span class="line">File Type: DLL</span><br><span class="line"></span><br><span class="line">  Section contains the following imports:</span><br><span class="line"></span><br><span class="line">    KERNEL32.dll</span><br><span class="line">             18000F000 Import Address Table</span><br><span class="line">             180017E68 Import Name Table</span><br><span class="line">                     0 time date stamp</span><br><span class="line">                     0 Index of first forwarder reference</span><br><span class="line"></span><br><span class="line">                         470 QueryPerformanceCounter</span><br><span class="line">                         233 GetCurrentProcessId</span><br><span class="line">                         237 GetCurrentThreadId</span><br><span class="line">							...</span><br><span class="line">                          DA CreateFileW</span><br><span class="line">                          94 CloseHandle</span><br></pre></td></tr></table></figure>

<p>Math.dll自己偷着导入了kernel32.dll等库中的函数,然而我们并没有显式调用这些函数,也没有在链接的时候指定要链接kernel32.lib导入库.</p>
<p>这是因为kernel32包含的C基本运行库是自动链接的</p>
<p>装载器会尽量少导入函数但是保证满足所有依赖.</p>
<h3 id="DataDirectory-1"><a href="#DataDirectory-1" class="headerlink" title="DataDirectory[1]"></a>DataDirectory[1]</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PE头-&gt;</span><br><span class="line">	NT头-&gt;</span><br><span class="line">		NT可选头-&gt;</span><br><span class="line">			DataDirectory[<span class="number">1</span>]-&gt;</span><br><span class="line">				IMAGE_IMPORT_DESCRIPTOR[]-&gt;</span><br><span class="line">    				FirstThunk-&gt;IMAGE_IMPORT_BY_NAME</span><br><span class="line">    					</span><br><span class="line">    				</span><br></pre></td></tr></table></figure>

<p>PE&#x2F;COFF文件的NT可选头的DataDirectory[1]就是导入表的数据目录</p>
<p><code>DataDirectory[1].VirtualAddress</code>指向的是一个IMAGE_IMPORT_DESCRIPTOR[]结构体数组,该结构体数组以一个全空的结构体元素结尾</p>
<p><code>DataDirectory[1].Size</code>表明该结构体数组的总大小</p>
<p>因此可以得到这样的公式<br>$$<br>\frac{DataDirectory[1].Size}{sizeof(IMAGE_IMPORT_DESCRIPTOR)}-1&#x3D;有意义的导入描述符个数<br>$$</p>
<h3 id="IMAGE-IMPORT-DESCRIPTOR"><a href="#IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="IMAGE_IMPORT_DESCRIPTOR"></a>IMAGE_IMPORT_DESCRIPTOR</h3><p>每一个需要导入的<strong>库</strong>都会对应一个IMAGE_IMPORT_DESCRIPTOR导入描述符</p>
<p>DataDirectory[1].VirtualAddress[0]就是kernel32.dll的导入描述符结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">     __C89_NAMELESS <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">DWORD Characteristics;</span><br><span class="line">DWORD OriginalFirstThunk;<span class="comment">//导入名称表INT,import name table</span></span><br><span class="line">     &#125; DUMMYUNIONNAME;</span><br><span class="line">     DWORD TimeDateStamp;</span><br><span class="line"></span><br><span class="line">     DWORD ForwarderChain;</span><br><span class="line">     DWORD Name;	<span class="comment">//导入库名指针</span></span><br><span class="line">     DWORD FirstThunk;<span class="comment">//导入地址表IAT,import address table</span></span><br><span class="line">   &#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>一开始时,OriginalFirstThunk和FirstThunk都是各自指向一个IMAGE_THUNK_DATA结构体数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">DWORD ForwarderString;</span><br><span class="line">DWORD Function;</span><br><span class="line">DWORD Ordinal;<span class="comment">//序号</span></span><br><span class="line">DWORD AddressOfData;<span class="comment">//指向IMAGE_IMPORT_BY_NAME</span></span><br><span class="line">     &#125; u1;</span><br><span class="line">   &#125; IMAGE_THUNK_DATA32;</span><br><span class="line">   <span class="keyword">typedef</span> IMAGE_THUNK_DATA32 *PIMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure>

<p>后来INT还是指向这个结构体数组不变,但是IAT需要填上函数的实际地址</p>
<h3 id="IMAGE-IMPORT-BY-NAME"><a href="#IMAGE-IMPORT-BY-NAME" class="headerlink" title="IMAGE_IMPORT_BY_NAME"></a>IMAGE_IMPORT_BY_NAME</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">  WORD Hint;<span class="comment">//该符号最有可能的序号</span></span><br><span class="line">  CHAR Name[<span class="number">1</span>];<span class="comment">//该符号的符号名</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME,*PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>

<p>动态链接器拿到符号名之后还得先去查对应库导出的函数名表,用得到的下标再去查符号序号对应表,得到的值才是序号,减去base再查导出地址表得到真正的函数地址</p>
<p>如果Hint就是目标符号的序号,则直接减去base就可以查出导出地址了</p>
<p>因此动态链接器会首先尝试使用Hint作为目标符号的序号,减去base去查导出地址表.但是这种方法不一定命中,因为导入时认为的函数序号和库中的序号可能不同.因此需要验证是否命中.</p>
<blockquote>
<p>书上没有给出验证方法,我的猜测是,用Hint查符号名称对应表得到的下标,拿去直接访问符号名表,看看对应符号名是否和IMAGE_IMPORT_BY_NAME.name相同,相同则命中</p>
</blockquote>
<p>如果没有命中再用符号名从头查,符号名是最靠谱的</p>
<h3 id="间接调用指令"><a href="#间接调用指令" class="headerlink" title="间接调用指令"></a>间接调用指令</h3><p>TestMath主函数中调用了Math库的Sub函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> result=Sub(<span class="number">1.0</span>,<span class="number">8.9</span>);</span><br></pre></td></tr></table></figure>

<p>其反汇编指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">140001014</span>:	ff <span class="number">15</span> <span class="number">3</span>e <span class="number">52</span> <span class="number">01</span> <span class="number">00</span>    	call   QWORD PTR [rip+<span class="number">0x1523e</span>]        # <span class="number">0x140016258</span></span><br><span class="line"><span class="number">14000101</span>a:	f2 <span class="number">0f</span> <span class="number">11</span> <span class="number">44</span> <span class="number">24</span> <span class="number">20</span>    	movsd  QWORD PTR [rsp+<span class="number">0x20</span>],xmm0</span><br></pre></td></tr></table></figure>

<p>这有一个间接调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call   QWORD PTR [rip+<span class="number">0x1523e</span>]</span><br></pre></td></tr></table></figure>

<p>把内存中rip+0x1523e这个地址上的四字拿出来再当作一个64位内存地址,调用该地址</p>
<blockquote>
<p>如果写成<code>call  rip+0x1523e</code>就相当于直接调用<code>rip+0x1523e</code>这个地址</p>
</blockquote>
<p>0x140016258这个地方是啥呢?IAT</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.idata:<span class="number">0000000140016258</span> ; Imports from Math.dll</span><br><span class="line">.idata:<span class="number">0000000140016258</span> ;</span><br><span class="line">.idata:<span class="number">0000000140016258</span>                 extrn Sub:qword         ; CODE XREF: main+<span class="number">14</span>↑p</span><br></pre></td></tr></table></figure>

<p>idata段,给Math.dll建立的的导入地址表IAT,其中只有一项,Sub的桩代码,占用四字64个字节</p>
<p>显然日后这个位置需要填入正确的函数地址,这样看IAT表就相当于GOT表</p>
<h3 id="declspec-dllimport-1"><a href="#declspec-dllimport-1" class="headerlink" title="__declspec(dllimport)"></a>__declspec(dllimport)</h3><p>TestMath.exe针对Math.dll的导入地址表IAT中只有一项,是因为在TestMath.c中只声明导入了一个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__declspec(dllimport) <span class="type">double</span> <span class="title function_">Sub</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这个声明告诉编译器Sub符号是从外部导入的,关于它的调用指令啃腚是间接调用.</p>
<blockquote>
<p>在引入<code>__desclpec</code>关键字之前,编译器是不知道一个函数是本地的还是导入的,它统一都生成直接调用指令.</p>
<p>如果是本模块的函数,则编译器给他写上正确的地址.如果本模块中没有</p>
<p>这个直接调用的操作数是一个桩地址,其上只有一条指令,跳转指令,跳转到真正的函数地址.这个真正的函数地址是链接器填上的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CALL 0x0040100C </span><br><span class="line">    ... </span><br><span class="line">0x0040100C: JMP DWORD PTR [0x0040D11C]</span><br></pre></td></tr></table></figure>

<p>0x4D11C还是在IAT表中,<code>DWORD PTR [0x0040D11C]</code>才是真正的函数地址</p>
</blockquote>
<h2 id="导入函数的定位过程"><a href="#导入函数的定位过程" class="headerlink" title="导入函数的定位过程"></a>导入函数的定位过程</h2><p><img src="https://img-blog.csdnimg.cn/20200229233124198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzY3MzMzMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>装载前,OriginalFirstThunk和FirstThunk指向不同的地方,但是其中的数据相同</p>
<p>装载结束后,导入函数定位完成,OriginalFirstThunk指向的INT表不变,但是FirstThunk指向的IAT变成了函数的实际地址</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/20170820114205491" alt="这里写图片描述"></p>
<h2 id="装载时重定位"><a href="#装载时重定位" class="headerlink" title="装载时重定位"></a>装载时重定位</h2><p>Rebasing,重定基地址</p>
<p>DLL中的代码段不是地址无关的,都是以DLL的基地址为基准,计算位置.</p>
<p>一般情况下,EXE程序是第一个装载进入虚拟内存的,没人和他争抢虚拟地址空间,exe程序就可以准确的装载进入ImageBase指定的基地址.在32位windows上这个地址通常是0x400000</p>
<p>而DLL就没有这么幸运了,DLL的默认基地址是0x10000000,假设第一个DLL需要装载时其基地址没有被占用.当第二个DLL需要装载时,其ImageBase恰好和第一个DLL相同,但是这个坑已经有人占了,那么第二个DLL应该放到哪里呢?</p>
<p>满足地址16K对齐要求的前提下找一个能放开此DLL的地方塞进去.</p>
<p>但是问题又来了.</p>
<p>对于64位Math.dll,其基地址是0x180000000,对于需要rip相对寻址的符号比如函数尚且好说.</p>
<p>但是对于需要绝对寻址的符号比如全局变量,假设其原地址为0x180001000,现在由于其他库早于Math.dll装载进入了0x180000000这个位置,那么Math.dll就得另寻他处,比如0x180010000,那么这个全局变量就得放到0x180011000.</p>
<p>所有引用到它的指令都需要被重定位,将该全局变量的位置从0x180001000修改为0x180011000<br>$$<br>新符号位置-旧符号位置&#x3D;新ImageBase-旧ImageBase<br>$$<br>问题又来了</p>
<p>如果一个DLL装载进入A进程地址空间的0x180000000,装载进入B进程地址空间的0x180011000,那么该DLL中的一个需要绝对寻址的符号,在A进程地址空间中所有关于它的指令的操作数都得是0x180001000,在B进程地址空间中是0x180011000.</p>
<p>那么两个进程就得各自持有一份DLL的拷贝,这与linux上位置无关的so动态库不同.so只需要在物理内存中存在一份,映射进入多个进程的地址空间.DLL得有几个进程就得在物理内存中有几个拷贝</p>
<h3 id="系统DLL"><a href="#系统DLL" class="headerlink" title="系统DLL"></a>系统DLL</h3><p>系统DLL比如kernel32.dll,user32.dll,gdi32.dll等等</p>
<p>开发人员在设计操作系统的时候就已经给他们刻意安排了一个基地址,不大容易和其他dll冲突</p>
<table>
<thead>
<tr>
<th>windows XP 32位 系统dll</th>
<th>imagebase</th>
</tr>
</thead>
<tbody><tr>
<td>user32</td>
<td>77D10000h</td>
</tr>
<tr>
<td>kernel32</td>
<td>77E40000h</td>
</tr>
<tr>
<td>shell32</td>
<td>773A0000h</td>
</tr>
<tr>
<td>gdi32</td>
<td>77C40000h</td>
</tr>
</tbody></table>
<h3 id="导入函数绑定"><a href="#导入函数绑定" class="headerlink" title="导入函数绑定"></a>导入函数绑定</h3><p>系统DLL每次加载进入进程地址空间的位置基本是不变的,一个函数今天加载到0x1800001000,明天又加载到0x1800001000,后天,大后天,一辈子都是这个位置.那么每次程序运行时都进行符号解析重定位多是一件废事儿啊</p>
<p>可以在运行之间就”确定”库函数的地址,即地址绑定.如果真的在装载时发生重定位,那时候再重新计算符号的真正地址也不迟.</p>
<p>绑定前的导入表:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\86135\Desktop\math&gt;dumpbin TestMath.exe /IMPORTS</span><br><span class="line">Microsoft (R) COFF/PE Dumper Version 14.31.31106.2</span><br><span class="line">Copyright (C) Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dump of file TestMath.exe</span><br><span class="line"></span><br><span class="line">File Type: EXECUTABLE IMAGE</span><br><span class="line"></span><br><span class="line">  Section contains the following imports:</span><br><span class="line"></span><br><span class="line">    MATH.dll</span><br><span class="line">                414110 Import Address Table</span><br><span class="line">                41A640 Import Name Table</span><br><span class="line">                     0 time date stamp</span><br><span class="line">                     0 Index of first forwarder reference</span><br><span class="line"></span><br><span class="line">                    2 Sub</span><br><span class="line"></span><br><span class="line">    KERNEL32.dll</span><br><span class="line">                414000 Import Address Table</span><br><span class="line">                41A530 Import Name Table</span><br><span class="line">                     0 time date stamp</span><br><span class="line">                     0 Index of first forwarder reference</span><br><span class="line"></span><br><span class="line">                  367 HeapFree</span><br><span class="line">                  639 WriteConsoleW</span><br><span class="line">                  46D QueryPerformanceCounter</span><br><span class="line">                  ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>地址绑定后的导入表:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\<span class="number">86135</span>\Desktop\math&gt;dumpbin TestMath.exe /IMPORTS</span><br><span class="line"><span class="title function_">Microsoft</span> <span class="params">(R)</span> COFF/PE Dumper Version 14.31.31106.2</span><br><span class="line"><span class="title function_">Copyright</span> <span class="params">(C)</span> Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dump of file TestMath.exe</span><br><span class="line"></span><br><span class="line">File Type: EXECUTABLE IMAGE</span><br><span class="line"></span><br><span class="line">  Section contains the following imports:</span><br><span class="line"></span><br><span class="line">    MATH.dll</span><br><span class="line">                414110 Import Address Table</span><br><span class="line">                41A640 Import Name Table</span><br><span class="line">              FFFFFFFF time date stamp</span><br><span class="line">              FFFFFFFF Index of first forwarder reference</span><br><span class="line"></span><br><span class="line">      10001020      2 Sub</span><br><span class="line"></span><br><span class="line">    KERNEL32.dll</span><br><span class="line">                414000 Import Address Table</span><br><span class="line">                41A530 Import Name Table</span><br><span class="line">              FFFFFFFF time date stamp</span><br><span class="line">              FFFFFFFF Index of first forwarder reference</span><br><span class="line"></span><br><span class="line">      6B815FE0    367 HeapFree</span><br><span class="line">      6B81F1F0    63A WriteConsoleW</span><br><span class="line">      6B819970    46D QueryPerformanceCounter</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以发现每个导入函数都有了一个绝对地址,然而此时还是在文件中,没有加载进入内存,就已经预料到导入符号的地址了</p>
<blockquote>
<p>然而这个关闭ASLR之后用od调试运行TestMath.exe可以发现实际上kernel32.dll和Math.dll并没有装载进入这里的位置</p>
</blockquote>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="MSVC"><a href="#MSVC" class="headerlink" title="MSVC"></a>MSVC</h3><h4 id="调整MSVC环境变量"><a href="#调整MSVC环境变量" class="headerlink" title="调整MSVC环境变量"></a>调整MSVC环境变量</h4><p>现在的x86_64机器上MSVC默认将源代码编译成64位程序,如果需要编译成32位程序,则需要调整环境</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft Visual Studio\<span class="number">2017</span>\Community\VC\Auxiliary\Build</span><br></pre></td></tr></table></figure>

<p>这个文件夹下有几个写好的修改环境的bat文件(微软不建议自己手敲代码修改环境,因为需要修改的变量比较多)</p>
<p>执行其中一共bat就可以修改环境</p>
<p>或者直接运行相应环境的shell工具</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220817095545711.png" alt="image-20220817095545711"></p>
<h4 id="cl-c-只编译不链接"><a href="#cl-c-只编译不链接" class="headerlink" title="cl &#x2F;c 只编译不链接"></a>cl &#x2F;c 只编译不链接</h4><h4 id="cl-LD-创建动态库文件"><a href="#cl-LD-创建动态库文件" class="headerlink" title="cl &#x2F;LD 创建动态库文件"></a>cl &#x2F;LD 创建动态库文件</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\desktop\testDLL&gt; cl /LDd Math.c</span><br><span class="line">用于 x64 的 Microsoft (<span class="built_in">R</span>) C/C++ 优化编译器 <span class="number">19.31</span>.<span class="number">31106.2</span> 版</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">Math.c</span><br><span class="line">Microsoft (<span class="built_in">R</span>) Incremental Linker Version <span class="number">14.31</span>.<span class="number">31106.2</span></span><br><span class="line">Copyright (C) Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line">/out:Math.dll</span><br><span class="line">/dll</span><br><span class="line">/implib:Math.lib</span><br><span class="line">Math.obj</span><br><span class="line">  正在创建库 Math.lib 和对象 Math.exp</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /LDd Math.c  #创建带有调试信息的Math.dll动态库</span><br></pre></td></tr></table></figure>

<h4 id="link-dll-将obj文件制作为动态库"><a href="#link-dll-将obj文件制作为动态库" class="headerlink" title="link &#x2F;dll 将obj文件制作为动态库"></a>link &#x2F;dll 将obj文件制作为动态库</h4><h4 id="link-dll-EXPORT-设置导出符号"><a href="#link-dll-EXPORT-设置导出符号" class="headerlink" title="link &#x2F;dll &#x2F;EXPORT:&lt;符号名&gt; 设置导出符号"></a>link &#x2F;dll &#x2F;EXPORT:&lt;符号名&gt; 设置导出符号</h4><h4 id="link-dll-FIXED-禁止产生重定位信息"><a href="#link-dll-FIXED-禁止产生重定位信息" class="headerlink" title="link &#x2F;dll &#x2F;FIXED 禁止产生重定位信息"></a>link &#x2F;dll &#x2F;FIXED 禁止产生重定位信息</h4><h4 id="link-dll-BASE-指定基地址"><a href="#link-dll-BASE-指定基地址" class="headerlink" title="link &#x2F;dll &#x2F;BASE 指定基地址"></a>link &#x2F;dll &#x2F;BASE 指定基地址</h4><h3 id="dumpbin"><a href="#dumpbin" class="headerlink" title="dumpbin"></a>dumpbin</h3><h4 id="dumpbin-EXPORTS观察导出符号"><a href="#dumpbin-EXPORTS观察导出符号" class="headerlink" title="dumpbin &#x2F;EXPORTS观察导出符号"></a>dumpbin &#x2F;EXPORTS观察导出符号</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\desktop\testDLL&gt; dumpbin /EXPORTS Math.dll</span><br><span class="line">Microsoft (<span class="built_in">R</span>) COFF/PE Dumper Version <span class="number">14.31</span>.<span class="number">31106.2</span></span><br><span class="line">Copyright (C) Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dump of file Math.dll</span><br><span class="line"></span><br><span class="line">File <span class="built_in">Type</span>: DLL</span><br><span class="line"></span><br><span class="line">  Section contains the following exports <span class="keyword">for</span> Math.dll</span><br><span class="line"></span><br><span class="line">    <span class="number">00000000</span> characteristics</span><br><span class="line">    FFFFFFFF time date stamp</span><br><span class="line">        <span class="number">0.00</span> version</span><br><span class="line">           <span class="number">1</span> ordinal base</span><br><span class="line">           <span class="number">3</span> number of functions</span><br><span class="line">           <span class="number">3</span> number of names</span><br><span class="line"></span><br><span class="line">    ordinal hint RVA      name</span><br><span class="line"></span><br><span class="line">          <span class="number">1</span>    <span class="number">0</span> <span class="number">00001000</span> Add</span><br><span class="line">          <span class="number">2</span>    <span class="number">1</span> <span class="number">00001040</span> Mul</span><br><span class="line">          <span class="number">3</span>    <span class="number">2</span> <span class="number">00001020</span> Sub</span><br><span class="line"></span><br><span class="line">  Summary</span><br><span class="line"></span><br><span class="line">        <span class="number">3000</span> .data</span><br><span class="line">        <span class="number">3000</span> .pdata</span><br><span class="line">       <span class="number">13000</span> .rdata</span><br><span class="line">        <span class="number">1000</span> .reloc</span><br><span class="line">       <span class="number">3</span>C000 .text</span><br><span class="line">        <span class="number">1000</span> _RDATA</span><br></pre></td></tr></table></figure>

<h4 id="dumpbin-IMPORTS-观察导入符号"><a href="#dumpbin-IMPORTS-观察导入符号" class="headerlink" title="dumpbin &#x2F;IMPORTS 观察导入符号"></a>dumpbin &#x2F;IMPORTS 观察导入符号</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="number">86135</span>\desktop\Math&gt; dumpbin /IMPORTS Math.dll</span><br><span class="line"><span class="title function_">Microsoft</span> <span class="params">(R)</span> COFF/PE Dumper Version 14.31.31106.2</span><br><span class="line"><span class="title function_">Copyright</span> <span class="params">(C)</span> Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dump of file Math.dll</span><br><span class="line"></span><br><span class="line">File Type: DLL</span><br><span class="line"></span><br><span class="line">  Section contains the following imports:</span><br><span class="line"></span><br><span class="line">    KERNEL32.dll</span><br><span class="line">             18000F000 Import Address Table</span><br><span class="line">             180017E68 Import Name Table</span><br><span class="line">                     0 time date stamp</span><br><span class="line">                     0 Index of first forwarder reference</span><br><span class="line"></span><br><span class="line">                         470 QueryPerformanceCounter</span><br><span class="line">                         233 GetCurrentProcessId</span><br><span class="line">                         237 GetCurrentThreadId</span><br><span class="line">						...</span><br><span class="line">                          DA CreateFileW</span><br><span class="line">                          94 CloseHandle</span><br><span class="line"></span><br><span class="line">  Summary</span><br><span class="line"></span><br><span class="line">        2000 .data</span><br><span class="line">        1000 .pdata</span><br><span class="line">        A000 .rdata</span><br><span class="line">        1000 .reloc</span><br><span class="line">        E000 .text</span><br><span class="line">        1000 _RDATA</span><br></pre></td></tr></table></figure>





<h4 id="dumpbin-RELOCATIONS-观察重定位信息"><a href="#dumpbin-RELOCATIONS-观察重定位信息" class="headerlink" title="dumpbin &#x2F;RELOCATIONS 观察重定位信息"></a>dumpbin &#x2F;RELOCATIONS 观察重定位信息</h4><h3 id="editbin"><a href="#editbin" class="headerlink" title="editbin"></a>editbin</h3><h4 id="editbin-REBASE-BASE-修改基地址"><a href="#editbin-REBASE-BASE-修改基地址" class="headerlink" title="editbin &#x2F;REBASE:BASE&#x3D;&lt;新基址&gt; 修改基地址"></a>editbin &#x2F;REBASE:BASE&#x3D;&lt;新基址&gt; 修改基地址</h4><h4 id="editbin-BIND-绑定导入函数"><a href="#editbin-BIND-绑定导入函数" class="headerlink" title="editbin &#x2F;BIND 绑定导入函数"></a>editbin &#x2F;BIND 绑定导入函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="number">86135</span>\desktop\Math&gt; dumpbin /IMPORTS TestMath.exe</span><br><span class="line"><span class="title function_">Microsoft</span> <span class="params">(R)</span> COFF/PE Dumper Version 14.31.31106.2</span><br><span class="line"><span class="title function_">Copyright</span> <span class="params">(C)</span> Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dump of file TestMath.exe</span><br><span class="line"></span><br><span class="line">File Type: EXECUTABLE IMAGE</span><br><span class="line"></span><br><span class="line">  Section contains the following imports:</span><br><span class="line"></span><br><span class="line">    Math.dll</span><br><span class="line">             140016258 Import Address Table</span><br><span class="line">             140020060 Import Name Table</span><br><span class="line">                     0 time date stamp</span><br><span class="line">                     0 Index of first forwarder reference</span><br><span class="line"></span><br><span class="line">                           2 Sub</span><br><span class="line"></span><br><span class="line">    KERNEL32.dll</span><br><span class="line">             140016000 Import Address Table</span><br><span class="line">             14001FE08 Import Name Table</span><br><span class="line">                     0 time date stamp</span><br><span class="line">                     0 Index of first forwarder reference</span><br><span class="line"></span><br><span class="line">                         370 HeapFree</span><br><span class="line">                         64A WriteConsoleW</span><br><span class="line">                         470 QueryPerformanceCounter</span><br><span class="line">                         233 GetCurrentProcessId</span><br><span class="line">                         237 GetCurrentThreadId</span><br><span class="line">                         30A GetSystemTimeAsFileTime</span><br><span class="line">                         38A InitializeSListHead</span><br><span class="line">                         4F5 RtlCaptureContext</span><br><span class="line">                         4FD RtlLookupFunctionEntry</span><br><span class="line">                         504 RtlVirtualUnwind</span><br><span class="line">                         3A0 IsDebuggerPresent</span><br><span class="line">                         5E6 UnhandledExceptionFilter</span><br><span class="line">                         5A4 SetUnhandledExceptionFilter</span><br><span class="line">                         2F1 GetStartupInfoW</span><br><span class="line">                         3A8 IsProcessorFeaturePresent</span><br><span class="line">                         295 GetModuleHandleW</span><br><span class="line">                          DA CreateFileW</span><br><span class="line">                         503 RtlUnwindEx</span><br><span class="line">                         27D GetLastError</span><br><span class="line">                         564 SetLastError</span><br><span class="line">                         149 EnterCriticalSection</span><br><span class="line">                         3E0 LeaveCriticalSection</span><br><span class="line">                         123 DeleteCriticalSection</span><br><span class="line">                         386 InitializeCriticalSectionAndSpinCount</span><br><span class="line">                         5D6 TlsAlloc</span><br><span class="line">                         5D8 TlsGetValue</span><br><span class="line">                         5D9 TlsSetValue</span><br><span class="line">                         5D7 TlsFree</span><br><span class="line">                         1C5 FreeLibrary</span><br><span class="line">                         2CD GetProcAddress</span><br><span class="line">                         3E6 LoadLibraryExW</span><br><span class="line">                         145 EncodePointer</span><br><span class="line">                         487 RaiseException</span><br><span class="line">                         4FF RtlPcToFileHeader</span><br><span class="line">                         2F3 GetStdHandle</span><br><span class="line">                         64B WriteFile</span><br><span class="line">                         291 GetModuleFileNameW</span><br><span class="line">                         232 GetCurrentProcess</span><br><span class="line">                         178 ExitProcess</span><br><span class="line">                         5C4 TerminateProcess</span><br><span class="line">                         294 GetModuleHandleExW</span><br><span class="line">                         1F0 GetCommandLineA</span><br><span class="line">                         1F1 GetCommandLineW</span><br><span class="line">                         36C HeapAlloc</span><br><span class="line">                         1B4 FlsAlloc</span><br><span class="line">                         1B6 FlsGetValue</span><br><span class="line">                         1B7 FlsSetValue</span><br><span class="line">                         1B5 FlsFree</span><br><span class="line">                          AA CompareStringW</span><br><span class="line">                         3D4 LCMapStringW</span><br><span class="line">                         26A GetFileType</span><br><span class="line">                         18F FindClose</span><br><span class="line">                         195 FindFirstFileExW</span><br><span class="line">                         1A6 FindNextFileW</span><br><span class="line">                         3AE IsValidCodePage</span><br><span class="line">                         1CC GetACP</span><br><span class="line">                         2B6 GetOEMCP</span><br><span class="line">                         1DB GetCPInfo</span><br><span class="line">                         412 MultiByteToWideChar</span><br><span class="line">                         637 WideCharToMultiByte</span><br><span class="line">                         253 GetEnvironmentStringsW</span><br><span class="line">                         1C4 FreeEnvironmentStringsW</span><br><span class="line">                         546 SetEnvironmentVariableW</span><br><span class="line">                         57F SetStdHandle</span><br><span class="line">                         2F8 GetStringTypeW</span><br><span class="line">                         2D4 GetProcessHeap</span><br><span class="line">                         1B9 FlushFileBuffers</span><br><span class="line">                         21A GetConsoleOutputCP</span><br><span class="line">                         216 GetConsoleMode</span><br><span class="line">                         268 GetFileSizeEx</span><br><span class="line">                         555 SetFilePointerEx</span><br><span class="line">                         375 HeapSize</span><br><span class="line">                         373 HeapReAlloc</span><br><span class="line">                          94 CloseHandle</span><br><span class="line"></span><br><span class="line">  Summary</span><br><span class="line"></span><br><span class="line">        2000 .data</span><br><span class="line">        2000 .pdata</span><br><span class="line">        B000 .rdata</span><br><span class="line">        1000 .reloc</span><br><span class="line">       15000 .text</span><br><span class="line">        1000 _RDATA</span><br></pre></td></tr></table></figure>








      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/08/17/windows%20SDK%20chapter%207%20mouse/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/17/windows%20SDK%20chapter%207%20mouse/" class="post-title-link" itemprop="url">win32程序设计-chapter7 鼠标</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-17 10:19:00" itemprop="dateCreated datePublished" datetime="2022-08-17T10:19:00+08:00">2022-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-18 10:19:51" itemprop="dateModified" datetime="2022-08-18T10:19:51+08:00">2022-08-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="windows-SDK-chapter-7-mouse"><a href="#windows-SDK-chapter-7-mouse" class="headerlink" title="windows SDK chapter 7 mouse"></a>windows SDK chapter 7 mouse</h1><h2 id="鼠标的基本信息"><a href="#鼠标的基本信息" class="headerlink" title="鼠标的基本信息"></a>鼠标的基本信息</h2><h3 id="是否在线"><a href="#是否在线" class="headerlink" title="是否在线"></a>是否在线</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fMouse=GetSystemMetrics(SM_MOUSEPRESENT);</span><br></pre></td></tr></table></figure>

<p>如果鼠标都不在线(和鼠标共用接口的输入设备也有可能被作为鼠标),则该函数返回0.</p>
<p>如果至少有一个鼠标在线则函数返回非零值</p>
<h3 id="单键双键"><a href="#单键双键" class="headerlink" title="单键双键"></a>单键双键</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cButtons = GetSystemMetrics(SM_CMOUSEBUTTONS);</span><br></pre></td></tr></table></figure>

<p>但是在我的笔记本电脑上,这个值是8,而我的鼠标就四个键</p>
<p>可能是触摸板加上了两指三指四指动作,等等各种使用方法?</p>
<h3 id="鼠标样式"><a href="#鼠标样式" class="headerlink" title="鼠标样式"></a>鼠标样式</h3><p>鼠标样式最常见的就是斜向箭头,当程序忙的时候可能变成沙漏或者左箭头右沙漏</p>
<p>当绘图的时候鼠标可能会变成十字</p>
<p>实际上这个图标就是一个小的位图结构,点击鼠标时有效的位置只有一个像素点,叫做”焦点”</p>
<p>斜向箭头的焦点在顶点上.十字的焦点在十字路口</p>
<p>设置鼠标样式</p>
<p>在实例化窗口对象的时候就指定过一次鼠标样式了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wndclass.hCursor  = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br></pre></td></tr></table></figure>

<p>IDC_ARROW就是最常见的斜向箭头样式</p>
<table>
<thead>
<tr>
<th align="left">Value</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>IDC_APPSTARTING</strong>MAKEINTRESOURCE(32650)</td>
<td align="left">Standard arrow and small hourglass</td>
</tr>
<tr>
<td align="left"><strong>IDC_ARROW</strong>MAKEINTRESOURCE(32512)</td>
<td align="left">Standard arrow</td>
</tr>
<tr>
<td align="left"><strong>IDC_CROSS</strong>MAKEINTRESOURCE(32515)</td>
<td align="left">Crosshair</td>
</tr>
<tr>
<td align="left"><strong>IDC_HAND</strong>MAKEINTRESOURCE(32649)</td>
<td align="left">Hand</td>
</tr>
<tr>
<td align="left"><strong>IDC_HELP</strong>MAKEINTRESOURCE(32651)</td>
<td align="left">Arrow and question mark</td>
</tr>
<tr>
<td align="left"><strong>IDC_IBEAM</strong>MAKEINTRESOURCE(32513)</td>
<td align="left">I-beam</td>
</tr>
<tr>
<td align="left"><strong>IDC_ICON</strong>MAKEINTRESOURCE(32641)</td>
<td align="left">Obsolete for applications marked version 4.0 or later.</td>
</tr>
<tr>
<td align="left"><strong>IDC_NO</strong>MAKEINTRESOURCE(32648)</td>
<td align="left">Slashed circle</td>
</tr>
<tr>
<td align="left"><strong>IDC_SIZE</strong>MAKEINTRESOURCE(32640)</td>
<td align="left">Obsolete for applications marked version 4.0 or later. Use <strong>IDC_SIZEALL</strong>.</td>
</tr>
<tr>
<td align="left"><strong>IDC_SIZEALL</strong>MAKEINTRESOURCE(32646)</td>
<td align="left">Four-pointed arrow pointing north, south, east, and west</td>
</tr>
<tr>
<td align="left"><strong>IDC_SIZENESW</strong>MAKEINTRESOURCE(32643)</td>
<td align="left">Double-pointed arrow pointing northeast and southwest</td>
</tr>
<tr>
<td align="left"><strong>IDC_SIZENS</strong>MAKEINTRESOURCE(32645)</td>
<td align="left">Double-pointed arrow pointing north and south</td>
</tr>
<tr>
<td align="left"><strong>IDC_SIZENWSE</strong>MAKEINTRESOURCE(32642)</td>
<td align="left">Double-pointed arrow pointing northwest and southeast</td>
</tr>
<tr>
<td align="left"><strong>IDC_SIZEWE</strong>MAKEINTRESOURCE(32644)</td>
<td align="left">Double-pointed arrow pointing west and east</td>
</tr>
<tr>
<td align="left"><strong>IDC_UPARROW</strong>MAKEINTRESOURCE(32516)</td>
<td align="left">Vertical arrow</td>
</tr>
<tr>
<td align="left"><strong>IDC_WAIT</strong>MAKEINTRESOURCE(32514)</td>
<td align="left">Hourglass</td>
</tr>
</tbody></table>
<p>然而在我的win11笔记本上,除了斜向箭头和转圈,其他鼠标样式都加载不出来,或者都加载成转圈或者斜向箭头</p>
<h2 id="客户区鼠标消息"><a href="#客户区鼠标消息" class="headerlink" title="客户区鼠标消息"></a>客户区鼠标消息</h2><p>windows只把键盘消息发往具有输入焦点的窗口,但是鼠标不同</p>
<p>只要鼠标经过某个窗口,windows就会对齐发送一个WM_MOUSEMOVE的消息</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220813092214535.png" alt="image-20220813092214535"></p>
<p>其中双击信息许哟啊在创建窗口实例的时候指明风格使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wndclass.style=CS_DBLCLKS | ...</span><br></pre></td></tr></table></figure>

<p>带有CS_DBLCLKS风格的窗口才可以接收WM_LBUTTONDBLCLK这种双击消息</p>
<p>对于鼠标消息(hwnd,message,wParam,lParam)</p>
<h3 id="lParam"><a href="#lParam" class="headerlink" title="lParam"></a>lParam</h3><p>包含鼠标的位置信息,低字表示x坐标,高字表示y坐标</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=LOWORD(lParam);</span><br><span class="line">y=HIWORD(lParam);</span><br></pre></td></tr></table></figure>

<h3 id="wParam"><a href="#wParam" class="headerlink" title="wParam"></a>wParam</h3><h3 id="包含了鼠标哪个键-还有此时Ctrl和Shift的状态"><a href="#包含了鼠标哪个键-还有此时Ctrl和Shift的状态" class="headerlink" title="包含了鼠标哪个键,还有此时Ctrl和Shift的状态."></a>包含了鼠标哪个键,还有此时Ctrl和Shift的状态.</h3><p>令wParam和宏定义按位与即可测试相应状态</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NOKEYSTATES</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MK_LBUTTON 0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MK_RBUTTON 0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MK_SHIFT 0x0004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MK_CONTROL 0x0008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MK_MBUTTON 0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MK_XBUTTON1 0x0020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MK_XBUTTON2 0x0040</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h2 id="MOUSEMOVE的速度"><a href="#MOUSEMOVE的速度" class="headerlink" title="MOUSEMOVE的速度"></a>MOUSEMOVE的速度</h2><p>windows不会给鼠标经过的每个像素点都产生一个WM_MOUSEMOVE消息,这取决于应用程序处理WM_MOUSEMOVE的速度,当应用程序的消息队列中还有WM_MOUSEMOVE的消息时就不能接收第二个WM_MOUSEMOVE消息</p>
<p>书上在此给出了一个例子.</p>
<p>凡是WM_MOUSEMOVE捕获的点都会被计入点集,点集中任意两个点连一条线</p>
<p>分析一下其过程函数WndProc</p>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> POINT pt[MAXPOINTS];<span class="comment">//存储已经捕获的点集</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> iCount;<span class="comment">//记录已经捕获的点数量</span></span><br><span class="line">HDC hdc;<span class="comment">//设备环境句柄</span></span><br><span class="line"><span class="type">int</span> i, j;<span class="comment">//循环变量</span></span><br><span class="line">PAINTSTRUCT ps;<span class="comment">//绘图结构</span></span><br></pre></td></tr></table></figure>

<h3 id="鼠标信息处理"><a href="#鼠标信息处理" class="headerlink" title="鼠标信息处理"></a>鼠标信息处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">	iCount = <span class="number">0</span>;<span class="comment">//左键按下时清零重新记录</span></span><br><span class="line">	InvalidateRect(hwnd, <span class="literal">NULL</span>, TRUE);<span class="comment">//清零后重绘</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line">	<span class="keyword">if</span> (wParam &amp; MK_LBUTTON &amp;&amp; iCount &lt; MAXPOINTS)<span class="comment">//如果是左键按下的移动状态并且目前点集未满则捕获新点</span></span><br><span class="line">	&#123;</span><br><span class="line">		pt[iCount].x = LOWORD(lParam);<span class="comment">//捕获新点</span></span><br><span class="line">		pt[iCount++].y = HIWORD(lParam);</span><br><span class="line"></span><br><span class="line">		hdc = GetDC(hwnd);</span><br><span class="line">		SetPixel(hdc, LOWORD(lParam), HIWORD(lParam), <span class="number">0</span>);<span class="comment">//将该新点的位置打印成一个黑点</span></span><br><span class="line">		ReleaseDC(hwnd, hdc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line">	InvalidateRect(hwnd, <span class="literal">NULL</span>, FALSE);<span class="comment">//左键松开,立刻通知处理WM_PAINT函数,重绘点集</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="绘图消息"><a href="#绘图消息" class="headerlink" title="绘图消息"></a>绘图消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">	hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line"></span><br><span class="line">	SetCursor(LoadCursor(<span class="literal">NULL</span>, IDC_WAIT));<span class="comment">//由于绘图可能时间较长,因此此时将光标样式换成等待</span></span><br><span class="line">	ShowCursor(TRUE);<span class="comment">//显示光标</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; iCount - <span class="number">1</span>; i++)<span class="comment">//每两个点之间握手一次</span></span><br><span class="line">		<span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; iCount; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			MoveToEx(hdc, pt[i].x, pt[i].y, <span class="literal">NULL</span>);<span class="comment">//从pt[i]到pt[j]连线</span></span><br><span class="line">			LineTo(hdc, pt[j].x, pt[j].y);</span><br><span class="line">		&#125;</span><br><span class="line">	ShowCursor(FALSE);</span><br><span class="line">	SetCursor(LoadCursor(<span class="literal">NULL</span>, IDC_ARROW));<span class="comment">//绘图完毕,光标从忙状态换成指针状态</span></span><br><span class="line">	EndPaint(hwnd, &amp;ps);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h3 id="窗口销毁消息"><a href="#窗口销毁消息" class="headerlink" title="窗口销毁消息"></a>窗口销毁消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">	PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220813102524348.png" alt="左鼠标移速快,右鼠标移速慢"></p>
<h2 id="双击"><a href="#双击" class="headerlink" title="双击"></a>双击</h2><p>只有创建窗口实例时,风格上允许双击的窗口才可以接受双击信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wndclass.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于没有双击风格的窗口,双击动作造成的消息:</p>
<p>WM_LBUTTONDOWN 左键第一次按下</p>
<p> WM_LBUTTONUP 左键第一次起来</p>
<p> WM_LBUTTONDOWN 左键第二次按下</p>
<p> WM_LBUTTONUP  左键起来</p>
<p>对于有双击风格的窗口,双击造成的信息:</p>
<p> WM_LBUTTONDOWN </p>
<p> WM_LBUTTONUP </p>
<p> WM_LBUTTONDBLCLK 第二次按下被替换为WM_LBUTTONDBLCLK</p>
<p> WM_LBUTTONUP </p>
</blockquote>
<h2 id="非客户区鼠标消息"><a href="#非客户区鼠标消息" class="headerlink" title="非客户区鼠标消息"></a>非客户区鼠标消息</h2><p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220813105023942.png" alt="image-20220813105023942"></p>
<p>非客户区的消息在WM_前缀之后又加了一个NC前缀(not client)</p>
<h3 id="参数意义"><a href="#参数意义" class="headerlink" title="参数意义"></a>参数意义</h3><h4 id="lParam-1"><a href="#lParam-1" class="headerlink" title="lParam"></a>lParam</h4><p>低字为x坐标,高字为y坐标,此处的坐标是相对于整个屏幕的坐标</p>
<p>而客户区的鼠标信息中lParam携带的坐标是相对于客户区左上角的坐标</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220813105412718.png" alt="image-20220813105412718"></p>
<p>屏幕坐标和客户区坐标的互换:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">ScreenToClient</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HWND    hWnd,</span></span><br><span class="line"><span class="params">       LPPOINT lpPoint</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">BOOL <span class="title function_">ClientToScreen</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]      HWND    hWnd,</span></span><br><span class="line"><span class="params">  [in, out] LPPOINT lpPoint</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>白刀子进,红刀子出</p>
</blockquote>
<p>使用pt带着原坐标进去,带着转换坐标出来</p>
<h4 id="wParam-1"><a href="#wParam-1" class="headerlink" title="wParam"></a>wParam</h4><p>非客户区鼠标移动或者单击的位置(不是坐标),一个标识符</p>
<h2 id="击中测试"><a href="#击中测试" class="headerlink" title="击中测试"></a>击中测试</h2><h3 id="WM-NCHITTEST"><a href="#WM-NCHITTEST" class="headerlink" title="WM_NCHITTEST"></a>WM_NCHITTEST</h3><p>关于鼠标的最后一个消息类型</p>
<p>这个消息优先级高于所有客户区和非客户区的鼠标消息</p>
<h4 id="lParam-2"><a href="#lParam-2" class="headerlink" title="lParam"></a>lParam</h4><p>鼠标位置的屏幕坐标</p>
<h4 id="wParam-2"><a href="#wParam-2" class="headerlink" title="wParam"></a>wParam</h4><p>没有用到</p>
<p>这条消息应该被直接传递给DefWindowProc,操作系统负责将屏幕坐标翻译为客户区坐标之后,产生一个客户区鼠标消息发送给应用程序</p>
<p>那么如果捕获该消息并且不让他传递给DefWindowProc,就阻断了所有鼠标消息.所有本窗口的鼠标动作将失效</p>
<h3 id="什么是击中测试"><a href="#什么是击中测试" class="headerlink" title="什么是击中测试"></a>什么是击中测试</h3><p>在文件浏览器中双击某个文件时,文件浏览器会进入该目录或者打开该文件.</p>
<p>可是文件浏览器是怎么知道应该打开哪个文件的呢?</p>
<p>他需要获取鼠标位置然后判断这个位置落在哪里</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220814083834575.png" alt="image-20220814083834575"></p>
<p>考虑实现一个简单的文件浏览器,以列表形式列出当前目录下的所有文件和子文件夹</p>
<p>每个文件占一行,放不下就用滚动条</p>
<p>客户区的点击动作就需要将纵坐标换算为行数,再根据卷动情况判断是指向的哪一行</p>
<p>根据确定的行号作为下标查文件名表,查到之后打开该文件,如果是文件夹则打开该文件夹</p>
<h3 id="击中测试例程"><a href="#击中测试例程" class="headerlink" title="击中测试例程"></a>击中测试例程</h3><p>书上在此给出了一个击中测试的例程,分析其过程函数WndProc</p>
<h4 id="变量定义-1"><a href="#变量定义-1" class="headerlink" title="变量定义"></a>变量定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DIVISIONS 5<span class="comment">//整个客户区分成5*5=25个矩形区域</span></span></span><br><span class="line">...</span><br><span class="line">	<span class="type">static</span> BOOL fState[DIVISIONS][DIVISIONS];<span class="comment">//状态数组,fState[x][y]记录第x行低y列的格子状态</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cxBlock, cyBlock;<span class="comment">//一个格子的宽度和高度</span></span><br><span class="line">    HDC hdc;</span><br><span class="line">    <span class="type">int</span> x, y;<span class="comment">//临时变量,作为下标遍历每个格子</span></span><br><span class="line">    PAINTSTRUCT ps;</span><br></pre></td></tr></table></figure>



<h4 id="尺寸变化消息"><a href="#尺寸变化消息" class="headerlink" title="尺寸变化消息"></a>尺寸变化消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SIZE:</span><br><span class="line">    cxBlock = LOWORD(lParam) / DIVISIONS;<span class="comment">//lParam携带的是当前客户区大小,cxBlocks计算的是平均每个矩形的宽度</span></span><br><span class="line">    cyBlock = HIWORD(lParam) / DIVISIONS;<span class="comment">//平均每个矩形的高度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>尽量用整个客户区打印所有方格</p>
<h4 id="左键单击消息"><a href="#左键单击消息" class="headerlink" title="左键单击消息"></a>左键单击消息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">case WM_LBUTTONDOWN:</span><br><span class="line">    x = LOWORD(lParam) / cxBlock;//鼠标的横坐标落在哪一列</span><br><span class="line">    y = HIWORD(lParam) / cyBlock;//鼠标的纵坐标落在哪一行</span><br><span class="line">    if (x &lt; DIVISIONS &amp;&amp; y &lt; DIVISIONS) &#123;//x,y都在合法范围之内</span><br><span class="line">        fState[x][y] ^= 1;//修改fState[x][y]的状态,1变0,0变1</span><br><span class="line">        rect.left = x * cxBlock;</span><br><span class="line">        rect.top = y * cyBlock;</span><br><span class="line">        rect.right = (x + 1) * cxBlock;</span><br><span class="line">        rect.bottom = (y + 1) * cyBlock;</span><br><span class="line">        //InvalidateRect(hwnd, &amp;rect, TRUE);//rect对应区域失效</span><br><span class="line">        InvalidateRect(hwnd, NULL, TRUE);//全区域失效重绘</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else &#123;</span><br><span class="line">        MessageBeep(0);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br></pre></td></tr></table></figure>

<h4 id="绘图消息-1"><a href="#绘图消息-1" class="headerlink" title="绘图消息"></a>绘图消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">    hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line">    <span class="comment">//HBRUSH hBrushBlack=(HBRUSH)</span></span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; DIVISIONS; ++x) &#123;<span class="comment">//遍历每个矩形区域</span></span><br><span class="line">        <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; DIVISIONS; ++y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fState[x][y]) &#123;<span class="comment">//1则表示这个格子是按下的状态,刷成灰色</span></span><br><span class="line">                SelectObject(hdc, (HBRUSH)GetStockObject(LTGRAY_BRUSH));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//0则表示这个格子没有按下,刷成白色</span></span><br><span class="line">                SelectObject(hdc, (HBRUSH)GetStockObject(WHITE_BRUSH));</span><br><span class="line">            &#125;</span><br><span class="line">            Rectangle(hdc, x * cxBlock, y * cyBlock, (x + <span class="number">1</span>) * cxBlock, (y + <span class="number">1</span>) * cyBlock);<span class="comment">//每个区域绘制矩形</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    EndPaint(hwnd, &amp;ps);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="键盘模仿鼠标"><a href="#键盘模仿鼠标" class="headerlink" title="键盘模仿鼠标"></a>键盘模仿鼠标</h2><p>使用方向键移动鼠标光标.使用Enter确认按下</p>
<p>这样即使计算机没有连接鼠标也能使用键盘模拟鼠标动作</p>
<p>比如windows桌面上如果有一个图标是高亮的,那么右方向键会使同行右侧的图标高亮,可以用隐藏光标,然后捕获位置进行击中测试,决定高亮哪个图标.</p>
<h3 id="显示计数"><a href="#显示计数" class="headerlink" title="显示计数"></a>显示计数</h3><p>书上扯了大半天,实际上就说了一个有用的东西</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ShowCursor</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] BOOL bShow</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>当bShow为False则不显示鼠标光标</p>
<p>当bShow为True则显示鼠标光标</p>
<h3 id="指针位置"><a href="#指针位置" class="headerlink" title="指针位置"></a>指针位置</h3><p>不管有没有接鼠标,鼠标指针都是存在的,一般开机时位于屏幕正中间.即使不使用鼠标移动指针位置,也可以使用键盘做到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">GetCursorPos</span><span class="params">(</span></span><br><span class="line"><span class="params">  [out] LPPOINT lpPoint<span class="comment">//lpPoint承接返回值,指针位置的坐标结构体</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">BOOL <span class="title function_">SetCursorPos</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span> X,<span class="comment">//设置指针位置(X,Y)</span></span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span> Y</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>两个函数中涉及到的坐标都是屏幕坐标,如果需要客户区坐标,可以使用坐标转换函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">ScreenToClient</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HWND    hWnd,</span></span><br><span class="line"><span class="params">       LPPOINT lpPoint</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">BOOL <span class="title function_">ClientToScreen</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]      HWND    hWnd,</span></span><br><span class="line"><span class="params">  [in, out] LPPOINT lpPoint</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<p>使用GetCursorPos并且用ScreenToClient转换得到的指针位置和鼠标消息中的指针位置不同</p>
<p>前者是啥时候调用函数啥时候取得指针位置,后者指针位置是产生该条消息时指针的位置</p>
<h3 id="击中测试-1"><a href="#击中测试-1" class="headerlink" title="击中测试"></a>击中测试</h3><h4 id="变量定义-2"><a href="#变量定义-2" class="headerlink" title="变量定义"></a>变量定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DIVISIONS 5<span class="comment">//客户区划分为5*5=25个区域</span></span></span><br><span class="line">...</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> fState[DIVISIONS][DIVISIONS];<span class="comment">//记录每个格子的状态</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cxBlock, cyBlock;<span class="comment">//每个格子的宽度和高度</span></span><br><span class="line">    HDC hdc;</span><br><span class="line">    <span class="type">int</span> x, y;<span class="comment">//临时变量,用来遍历fState</span></span><br><span class="line">    PAINTSTRUCT ps;<span class="comment">//BeginPaint和EndPaint需要使用</span></span><br><span class="line">    POINT point;记录鼠标位置</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="窗口焦点信息"><a href="#窗口焦点信息" class="headerlink" title="窗口焦点信息"></a>窗口焦点信息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SETFOCUS:<span class="comment">//获得焦点</span></span><br><span class="line">    ShowCursor(TRUE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> WM_KILLFOCUS:<span class="comment">//失去焦点</span></span><br><span class="line">    ShowCursor(FALSE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>当窗口获得焦点的时候显示光标,失去焦点的时候隐藏光标</p>
<h4 id="尺寸调整信息"><a href="#尺寸调整信息" class="headerlink" title="尺寸调整信息"></a>尺寸调整信息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SIZE:<span class="comment">//客户区重新计算块大小</span></span><br><span class="line">    cxBlock = LOWORD(lParam) / DIVISIONS;</span><br><span class="line">    cyBlock = HIWORD(lParam) / DIVISIONS;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>当客户区尺寸发生变化的时候调整区块的大小</p>
<p>使得5*5个区块尽量占满整个客户区</p>
<h4 id="虚拟键信息"><a href="#虚拟键信息" class="headerlink" title="虚拟键信息"></a>虚拟键信息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KEYDOWN:<span class="comment">//虚拟键按下</span></span><br><span class="line">    GetCursorPos(&amp;point);<span class="comment">//获取当前鼠标位置</span></span><br><span class="line">    ScreenToClient(hWnd, &amp;point);<span class="comment">//转换屏幕坐标为客户区坐标</span></span><br><span class="line">    x = max(<span class="number">0</span>, min(DIVISIONS - <span class="number">1</span>, point.x / cxBlock));<span class="comment">//计算当前光标所在行</span></span><br><span class="line">    y = max(<span class="number">0</span>, min(DIVISIONS - <span class="number">1</span>, point.y / cyBlock));<span class="comment">//计算当前光标所在列</span></span><br><span class="line">    <span class="keyword">switch</span> (wParam) &#123;</span><br><span class="line">    <span class="keyword">case</span> VK_UP:<span class="comment">//方向键上键</span></span><br><span class="line">        --y;<span class="comment">//y的单位是列,上键按下之后纵坐标应该上移一个格子的高度</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VK_DOWN:</span><br><span class="line">        ++y;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VK_LEFT:</span><br><span class="line">        --x;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VK_HOME:<span class="comment">//Home键,光标回到左上角</span></span><br><span class="line">        x = y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VK_RIGHT:</span><br><span class="line">        ++x;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VK_END:</span><br><span class="line">        x = y = DIVISIONS - <span class="number">1</span>;<span class="comment">//End键,光标跳到右下格</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VK_RETURN:<span class="comment">//回车和空格的作用相同,都相当于在当前格的左上角按下鼠标左键</span></span><br><span class="line">    <span class="keyword">case</span> VK_SPACE:</span><br><span class="line">        SendMessage(hWnd, WM_LBUTTONDOWN, MK_LBUTTON, MAKELONG(x * cxBlock, y * cyBlock));<span class="comment">//通知</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = (x + DIVISIONS) % DIVISIONS;<span class="comment">//计算当前指向方格</span></span><br><span class="line">    y = (y + DIVISIONS) % DIVISIONS;</span><br><span class="line">    point.x = x * cxBlock + cxBlock / <span class="number">2</span>;<span class="comment">//光标放在这个格的正中间位置</span></span><br><span class="line">    point.y = y * cyBlock + cyBlock / <span class="number">2</span>;</span><br><span class="line">    ClientToScreen(hWnd, &amp;point);<span class="comment">//转换坐标</span></span><br><span class="line">    SetCursorPos(point.x, point.y);<span class="comment">//设置新光标位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h2 id="使用子窗口"><a href="#使用子窗口" class="headerlink" title="使用子窗口"></a>使用子窗口</h2><p>每个子窗口都有自己的句柄,客户区,窗口过程函数.</p>
<p>多个子窗口将整个客户区划分成几个小的矩形区域</p>
<p>对于子窗口的鼠标消息,lParam参数包含相对于该子窗口左上角的坐标</p>
<p>本来我们的程序中使用了一个<code>fState[DIVISIONS][DIVISIONS]</code>二维数组保存每个区块的状态,整个程序就一个窗口过程,它遍历打印每个窗口的状态.</p>
<p>现在使用子窗口,使得每个区块成为一个子窗口,每个子窗口自己处理发生在自己身上的鼠标键盘动作</p>
<h3 id="注册父窗口类"><a href="#注册父窗口类" class="headerlink" title="注册父窗口类"></a>注册父窗口类</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> TCHAR szAppName[] = TEXT(<span class="string">&quot;Checker4&quot;</span>);<span class="comment">//将要作为父窗口类名</span></span><br><span class="line">HWND hwnd;</span><br><span class="line">MSG msg;</span><br><span class="line">WNDCLASS wndclass;</span><br><span class="line"></span><br><span class="line">wndclass.style = CS_HREDRAW | CS_VREDRAW;<span class="comment">//填写父窗口类信息</span></span><br><span class="line">wndclass.lpfnWndProc = WndProc;</span><br><span class="line">wndclass.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wndclass.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">wndclass.hInstance = hInstance;</span><br><span class="line">wndclass.hIcon = LoadIcon(<span class="literal">NULL</span>,</span><br><span class="line">	IDI_APPLICATION);</span><br><span class="line">wndclass.hCursor = LoadCursor(<span class="literal">NULL</span>,</span><br><span class="line">	IDC_ARROW);</span><br><span class="line">wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);</span><br><span class="line">wndclass.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wndclass.lpszClassName = szAppName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!RegisterClass(&amp;wndclass))<span class="comment">//注册父窗口类</span></span><br><span class="line">&#123;</span><br><span class="line">	MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;Program requires Windows NT!&quot;</span>),</span><br><span class="line">		szAppName,</span><br><span class="line">		MB_ICONERROR);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="注册子窗口类"><a href="#注册子窗口类" class="headerlink" title="注册子窗口类"></a>注册子窗口类</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wndclass.lpfnWndProc = ChildWndProc;<span class="comment">//修改一下wndclass的部分信息,填写子窗口类信息</span></span><br><span class="line">wndclass.cbWndExtra = <span class="keyword">sizeof</span>(<span class="type">long</span>);</span><br><span class="line">wndclass.hIcon = <span class="literal">NULL</span>;</span><br><span class="line">wndclass.lpszClassName = szChildClass;<span class="comment">//此处绑定了szChildClass字符串作为子窗口类的索引值</span></span><br><span class="line"></span><br><span class="line">RegisterClass(&amp;wndclass);<span class="comment">//注册子窗口类</span></span><br></pre></td></tr></table></figure>

<p>此处注册子窗口类,但是并不在winmain函数中创建实例,而是当父窗口起来之后,在其WM_CREATE消息处理中创建25个szChildClass指向的子窗口实例</p>
<h3 id="创建父窗口实例-显示父窗口消息循环"><a href="#创建父窗口实例-显示父窗口消息循环" class="headerlink" title="创建父窗口实例,显示父窗口消息循环"></a>创建父窗口实例,显示父窗口消息循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hwnd = CreateWindow(szAppName, TEXT(<span class="string">&quot;Checker4 Mouse Hit-Test Demo&quot;</span>),</span><br><span class="line">	WS_OVERLAPPEDWINDOW,</span><br><span class="line">	CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">	CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">	<span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">ShowWindow(hwnd, iCmdShow);</span><br><span class="line">UpdateWindow(hwnd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">	TranslateMessage(&amp;msg);</span><br><span class="line">	DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> msg.wParam;</span><br></pre></td></tr></table></figure>









<h3 id="父窗口过程WndProc"><a href="#父窗口过程WndProc" class="headerlink" title="父窗口过程WndProc"></a>父窗口过程WndProc</h3><h4 id="变量定义-3"><a href="#变量定义-3" class="headerlink" title="变量定义"></a>变量定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> HWND hwndChild[DIVISIONS][DIVISIONS];<span class="comment">//子窗口句柄数组,hwndChild[x][y]为第x行第y列子窗口的句柄</span></span><br><span class="line"><span class="type">int</span> cxBlock, cyBlock, x, y;<span class="comment">//cxBlock每个子窗口的尺寸,x遍历子窗口数组使用的下标</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>区分HWND句柄和HINSTANCE句柄</p>
<p>整个win32程序只有一个引用程序句柄HINSTANCE,</p>
<p>着一个程序可以有很多个窗口,每个窗口都有一个独一无二的窗口句柄HWND</p>
</blockquote>
<h4 id="窗口创建消息"><a href="#窗口创建消息" class="headerlink" title="窗口创建消息"></a>窗口创建消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CREATE:<span class="comment">//主窗口创建消息,此时为创建子窗口的最佳时机</span></span><br><span class="line">	<span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; DIVISIONS; x++)<span class="comment">//遍历创建每一个子窗口</span></span><br><span class="line">		<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; DIVISIONS; y++)</span><br><span class="line">			hwndChild[x][y] = </span><br><span class="line">			CreateWindow(</span><br><span class="line">				szChildClass, <span class="comment">//子窗口名</span></span><br><span class="line">				<span class="literal">NULL</span>,<span class="comment">//子窗口标题为空</span></span><br><span class="line">				WS_CHILDWINDOW | WS_VISIBLE,<span class="comment">//子窗口风格</span></span><br><span class="line">				<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,<span class="comment">//子窗口坐标(相对于父窗口客户区左上角),初始位置</span></span><br><span class="line">				hwnd, <span class="comment">//父窗口句柄</span></span><br><span class="line">				(HMENU)(y &lt;&lt; <span class="number">8</span> | x),<span class="comment">//子窗口的菜单句柄,作用是给父窗口提供索引,在GetDlgItem 获取子窗口句柄时有重要作用</span></span><br><span class="line">				(HINSTANCE) GetWindowLong(hwnd, GWL_HINSTANCE),<span class="comment">//从windows那里获取一个应用此程序实例句柄</span></span><br><span class="line">				<span class="literal">NULL</span><span class="comment">//通过WM_CREATE的lParam参数传递给子窗口的值的指针</span></span><br><span class="line">			);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h5 id="CreateWindow"><a href="#CreateWindow" class="headerlink" title="CreateWindow"></a>CreateWindow</h5><p>创建父窗口实例时也使用了该函数,返回值是一个窗口实例的句柄</p>
<blockquote>
<p>创建并显示窗口三个过程:</p>
<p>RegisterClass注册窗口类,该窗口类的类名作为句柄</p>
<p>CreateWindow创建窗口实例,可以使用刚才的窗口类名填充窗口的基本信息</p>
<p>ShowWindow显示窗口类</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HWND <span class="title function_">CreateWindowA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional]  lpClassName,<span class="comment">//子窗口使用的类名</span></span></span><br><span class="line"><span class="params">  [in, optional]  lpWindowName,<span class="comment">//子窗口名</span></span></span><br><span class="line"><span class="params">  [in]            dwStyle,<span class="comment">//子窗口风格</span></span></span><br><span class="line"><span class="params">  [in]            x,<span class="comment">//子窗口位置(相对于父窗口的客户区)</span></span></span><br><span class="line"><span class="params">  [in]            y,</span></span><br><span class="line"><span class="params">  [in]            nWidth,<span class="comment">//子窗口的尺寸</span></span></span><br><span class="line"><span class="params">  [in]            nHeight,</span></span><br><span class="line"><span class="params">  [in, optional]  hWndParent,<span class="comment">//父窗口的句柄</span></span></span><br><span class="line"><span class="params">  [in, optional]  hMenu,<span class="comment">//子窗口标识符</span></span></span><br><span class="line"><span class="params">  [in, optional]  hInstance,<span class="comment">//程序实例的句柄</span></span></span><br><span class="line"><span class="params">  [in, optional]  lpParam<span class="comment">//父窗口要传递给子窗口WM_CREATE消息,lParam参数的信息</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>





<h4 id="调整尺寸消息"><a href="#调整尺寸消息" class="headerlink" title="调整尺寸消息"></a>调整尺寸消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SIZE:</span><br><span class="line">	cxBlock = LOWORD(lParam) / DIVISIONS;<span class="comment">//重新计算区块大小</span></span><br><span class="line">	cyBlock = HIWORD(lParam) / DIVISIONS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; DIVISIONS; x++)</span><br><span class="line">		<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; DIVISIONS; y++)</span><br><span class="line">			MoveWindow(hwndChild[x][y],<span class="comment">//调整子窗口的位置和大小</span></span><br><span class="line">				x * cxBlock, y * cyBlock,</span><br><span class="line">				cxBlock, cyBlock, TRUE);<span class="comment">//大小是cxBlock宽,cyBlock高</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="MoveWindow"><a href="#MoveWindow" class="headerlink" title="MoveWindow"></a>MoveWindow</h5><p>对于子窗口来说,该函数中指定的坐标都是相对于父窗口客户区左上角的</p>
<p>对于非子窗口来说,该函数中的坐标是屏幕坐标</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">MoveWindow</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HWND hWnd,<span class="comment">//需要移动位置的窗口句柄,一般用于父窗口过程移动子窗口</span></span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>  X,</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>  Y,</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>  nWidth,<span class="comment">//移动顺便设置尺寸</span></span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>  nHeight,</span></span><br><span class="line"><span class="params">  [in] BOOL bRepaint<span class="comment">//是否重绘,TRUE则hWnd指向的窗口收到WM_PAINT消息</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<h4 id="左键按下消息"><a href="#左键按下消息" class="headerlink" title="左键按下消息"></a>左键按下消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">	MessageBeep(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>理论上25个子窗口尽量铺满父窗口的客户区,但是父窗口客户区的最右边和最下边可能有留白,因此当鼠标点击到这些地方的时候父窗口就会接到WM_LBUTTONDOWN消息</p>
<p>父窗口对这种消息的处理是发出一条蜂鸣声实际上是一个wav波形文件,还有一些系统定义好了的蜂鸣声,作用不大不展开了</p>
<h4 id="获得焦点消息"><a href="#获得焦点消息" class="headerlink" title="获得焦点消息"></a>获得焦点消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SETFOCUS:<span class="comment">//父窗口获取焦点之后通知它上次获得焦点的子窗口继续获得焦点</span></span><br><span class="line">	SetFocus(GetDlgItem(hwnd, idFocus));<span class="comment">//通知哪一个子窗口获得焦点,全局变量idFocus在WM_KEYDOWN被设置</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>父窗口获得焦点之后,应该把最后一次获得焦点的子窗口作为焦点窗口</p>
<p>但是处理本消息时并没有体现获得idFocus,原因是该全局变量idFocus在WM_KEYDOWN中更新,显然没有按下键盘,通过鼠标点选也可以获得焦点,获得焦点的时候就需要指定让子窗口获得焦点</p>
<p>而现在父窗口掌握着25个子窗口句柄,应该怎么把焦点交给其中之一的子窗口呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HWND <span class="title function_">GetDlgItem</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional] HWND hDlg,<span class="comment">//父窗口句柄</span></span></span><br><span class="line"><span class="params">  [in]           <span class="type">int</span>  nIDDlgItem<span class="comment">//子窗口的索引值</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数的作用是,返回父窗口的一个子窗口的句柄</p>
<p>这里nIDDlgItem这个值是父窗口注册子窗口是在CreateWindow函数的hMenu上指定的,其中第x行第y列的子窗口是这样索引的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(HMENU)(y &lt;&lt; <span class="number">8</span> | x)</span><br></pre></td></tr></table></figure>

<p>既然要获取子窗口的句柄,父窗口不是实例化子窗口时就维护了一个子窗口句柄数组吗?</p>
<p>为啥还要额外维护一个值托管这个句柄呢?</p>
<p>只有一个子窗口句柄数组不能知道最近获得焦点的子窗口是谁,因此idFocus就起到了一个寄存器的作用</p>
<h4 id="虚拟键消息"><a href="#虚拟键消息" class="headerlink" title="虚拟键消息"></a>虚拟键消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">	x = idFocus &amp; <span class="number">0xFF</span>;<span class="comment">//x保存原来的焦点位置(子窗口下标)</span></span><br><span class="line">	y = idFocus &gt;&gt; <span class="number">8</span>;<span class="comment">//y保存原来的焦点位置</span></span><br><span class="line">	<span class="keyword">switch</span> (wParam)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> VK_UP: </span><br><span class="line">		y--;<span class="comment">//焦点上移</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_DOWN: </span><br><span class="line">		y++;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_LEFT: </span><br><span class="line">		x--;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_RIGHT: </span><br><span class="line">		x++; </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_HOME: </span><br><span class="line">		x = y = <span class="number">0</span>; </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_END: </span><br><span class="line">		x = y = DIVISIONS - <span class="number">1</span>; </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">       x = (x + DIVISIONS) % DIVISIONS;</span><br><span class="line">	y = (y + DIVISIONS) % DIVISIONS;</span><br><span class="line">	idFocus = y &lt;&lt; <span class="number">8</span> | x;<span class="comment">//调整新焦点</span></span><br><span class="line">	SetFocus(GetDlgItem(hwnd, idFocus));<span class="comment">//设置新焦点</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这里计算x,y坐标的方式根HMENU参数的定义方式相反,互为逆运算</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">		x = idFocus &amp; <span class="number">0xFF</span>;<span class="comment">//x保存原来的焦点位置</span></span><br><span class="line">		y = idFocus &gt;&gt; <span class="number">8</span>;<span class="comment">//y保存原来的焦点位置</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    	idFocus = y &lt;&lt; <span class="number">8</span> | x;<span class="comment">//调整新焦点</span></span><br></pre></td></tr></table></figure>

<p><code>WM_KEYDOWN</code>消息执行完毕后立刻设置当前子窗口为焦点窗口</p>
<h4 id="窗口销毁消息-1"><a href="#窗口销毁消息-1" class="headerlink" title="窗口销毁消息"></a>窗口销毁消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">	PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="子窗口过程ChildWndProc"><a href="#子窗口过程ChildWndProc" class="headerlink" title="子窗口过程ChildWndProc"></a>子窗口过程ChildWndProc</h3><h4 id="子窗口创建消息"><a href="#子窗口创建消息" class="headerlink" title="子窗口创建消息"></a>子窗口创建消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line">	SetWindowLong(hwnd, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// on/off flag ,刚创建时本窗口的开关状态置0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>修改窗口的一个属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LONG <span class="title function_">SetWindowLongA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HWND hWnd,<span class="comment">//窗口句柄</span></span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>  nIndex,<span class="comment">//指定要修改的窗口属性</span></span></span><br><span class="line"><span class="params">  [in] LONG dwNewLong<span class="comment">//该窗口属性的新值</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>例子中修改的是下标为0的属性,对应的宏定义是DWL_MSGRESULT(0)</p>
<p>设置对话框过程的返回值,设置成了0.</p>
<p>实际上子窗口也不需要把这个值返回给父窗口看,它自己就可以决定把自己绘制成什么颜色</p>
<p>因此只是借用了一个线程的窗口属性来放置自己应该是按下还是起来的状态</p>
<h4 id="子窗口键鼠消息"><a href="#子窗口键鼠消息" class="headerlink" title="子窗口键鼠消息"></a>子窗口键鼠消息</h4><p>由于父窗口中会主动将焦点下放到子窗口,因此焦点子窗口可获取键鼠的输入.</p>
<p>父窗口只能等子窗口吃完了然后吃剩下的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">	<span class="comment">// Send most key presses to the parent window </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wParam != VK_RETURN &amp;&amp; wParam != VK_SPACE)<span class="comment">//子窗口只负责拦截并处理空格回车消息,其他键盘消息丢给父窗口</span></span><br><span class="line">	&#123;</span><br><span class="line">		SendMessage(GetParent(hwnd), message, wParam, lParam);<span class="comment">//其他键盘消息传递给父窗口</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// For Return and Space, fall through to toggle the square</span></span><br><span class="line">	<span class="comment">//如果是空格和回车则相当于鼠标左键按下,一起处理</span></span><br><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:<span class="comment">//左键单击按下</span></span><br><span class="line">	SetWindowLong(hwnd, <span class="number">0</span>, <span class="number">1</span> ^ GetWindowLong(hwnd, <span class="number">0</span>));<span class="comment">//子窗口开关状态置反</span></span><br><span class="line">	SetFocus(hwnd);<span class="comment">//本子窗口获取焦点</span></span><br><span class="line">	InvalidateRect(hwnd, <span class="literal">NULL</span>, FALSE);<span class="comment">//立刻重绘</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// For focus messages, invalidate the window for repaint </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里子窗口就处理里两个虚拟键消息,空格和回车,其他的消息通过</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SendMessage</span>(<span class="built_in">GetParent</span>(hwnd), message, wParam, lParam);</span><br></pre></td></tr></table></figure>

<p>转发给父窗口</p>
<p>空格,回车,左键单击一视同仁,首先本子窗口的属性置反</p>
<p>然后设置本窗口为焦点窗口</p>
<p>然后使窗口无效,导致重绘</p>
<h4 id="子窗口获取-失去焦点消息"><a href="#子窗口获取-失去焦点消息" class="headerlink" title="子窗口获取&#x2F;失去焦点消息"></a>子窗口获取&#x2F;失去焦点消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SETFOCUS:</span><br><span class="line">	idFocus = GetWindowLong(hwnd, GWL_ID);</span><br><span class="line">	<span class="comment">// Fall through </span></span><br><span class="line"><span class="keyword">case</span> WM_KILLFOCUS:</span><br><span class="line">	InvalidateRect(hwnd, <span class="literal">NULL</span>, TRUE);<span class="comment">//失效重绘,因为子窗口获得焦点的时候会有绘制方框提示,因此失去焦点时应当不再提示</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="GetWindowLong-获取窗口属性"><a href="#GetWindowLong-获取窗口属性" class="headerlink" title="GetWindowLong 获取窗口属性"></a>GetWindowLong 获取窗口属性</h5><p>由于窗口属性都是LONG类型的值,因此该函数取名”GetWindowLong”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LONG <span class="title function_">GetWindowLongA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HWND hWnd,<span class="comment">//指定要获取信息的窗口句柄</span></span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>  nIndex<span class="comment">//指定要获取该窗口的哪个属性</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<table>
<thead>
<tr>
<th align="left">Value</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>GWL_EXSTYLE</strong>-20</td>
<td align="left">获取窗口实例的拓展风格,即CreateWindow函数指定的dwExStyle</td>
</tr>
<tr>
<td align="left"><strong>GWL_HINSTANCE</strong>-6</td>
<td align="left">获取应用程序句柄</td>
</tr>
<tr>
<td align="left"><strong>GWL_HWNDPARENT</strong>-8</td>
<td align="left">获取父窗口句柄</td>
</tr>
<tr>
<td align="left"><strong>GWL_ID</strong>-12</td>
<td align="left">获取本窗口的索引值,即CreateWindow函数指定的HMENU值</td>
</tr>
<tr>
<td align="left"><strong>GWL_STYLE</strong>-16</td>
<td align="left">获取窗口实例的风格,这个风格就是CreateWindow指定的dwStyle</td>
</tr>
<tr>
<td align="left"><strong>GWL_USERDATA</strong>-21</td>
<td align="left">Retrieves the user data associated with the window. This data is intended for use by the application that created the window. Its value is initially zero.</td>
</tr>
<tr>
<td align="left"><strong>GWL_WNDPROC</strong>-4</td>
<td align="left">Retrieves the address of the window procedure, or a handle representing the address of the window procedure. You must use the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-callwindowproca">CallWindowProc</a> function to call the window procedure.</td>
</tr>
</tbody></table>
<p>The following values are also available when the <em>hWnd</em> parameter identifies a dialog box.</p>
<table>
<thead>
<tr>
<th align="left">Value</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>DWL_DLGPROC</strong>DWLP_MSGRESULT + sizeof(LRESULT)</td>
<td align="left">Retrieves the address of the dialog box procedure, or a handle representing the address of the dialog box procedure. You must use the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-callwindowproca">CallWindowProc</a> function to call the dialog box procedure.</td>
</tr>
<tr>
<td align="left"><strong>DWL_MSGRESULT</strong>0</td>
<td align="left">Retrieves the return value of a message processed in the dialog box procedure.</td>
</tr>
<tr>
<td align="left"><strong>DWL_USER</strong>DWLP_DLGPROC + sizeof(DLGPROC)</td>
<td align="left">Retrieves extra information private to the application, such as handles or pointers.</td>
</tr>
</tbody></table>
</blockquote>
<p>例子中获取的是子窗口的HMENU索引值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idFocus = GetWindowLong(hwnd, GWL_ID);</span><br></pre></td></tr></table></figure>

<p>这句的意思就是子窗口将idFocus当前焦点窗口寄存器设置为子窗口自己</p>
<p>当子窗口失去焦点的时候需要通知失效重绘,其原因是WM_PAINT中获得焦点的子窗口会多绘制一些提示信息,那么当它失去焦点的时候就得擦除提示信息了</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220814172257251.png" alt="image-20220814172257251"></p>
<h4 id="子窗口绘图消息"><a href="#子窗口绘图消息" class="headerlink" title="子窗口绘图消息"></a>子窗口绘图消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">	hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line"></span><br><span class="line">	GetClientRect(hwnd, &amp;rect);</span><br><span class="line">	Rectangle(hdc, <span class="number">0</span>, <span class="number">0</span>, rect.right, rect.bottom);<span class="comment">//绘制边框</span></span><br><span class="line">	<span class="comment">// Draw the &quot;x&quot; mark</span></span><br><span class="line">	<span class="keyword">if</span> (GetWindowLong(hwnd, <span class="number">0</span>))<span class="comment">//通过0号属性观察本窗口应该是按下还是起来的状态,</span></span><br><span class="line">	&#123;<span class="comment">//如果应该按下则本子窗口画出对角线</span></span><br><span class="line">		MoveToEx(hdc, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">		LineTo(hdc, rect.right, rect.bottom);</span><br><span class="line">		MoveToEx(hdc, <span class="number">0</span>, rect.bottom, <span class="literal">NULL</span>);</span><br><span class="line">		LineTo(hdc, rect.right, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Draw the &quot;focus&quot; rectangle </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hwnd == GetFocus())<span class="comment">//如果当前子窗口正在获得焦点,那么额外画出提示信息</span></span><br><span class="line">	&#123;</span><br><span class="line">		rect.left += rect.right / <span class="number">10</span>;<span class="comment">//设置内方框信息</span></span><br><span class="line">		rect.right -= rect.left;</span><br><span class="line">		rect.top += rect.bottom / <span class="number">10</span>;</span><br><span class="line">		rect.bottom -= rect.top;</span><br><span class="line">		SelectObject(hdc, GetStockObject(NULL_BRUSH));<span class="comment">//不使用画刷</span></span><br><span class="line">		SelectObject(hdc, CreatePen(PS_DASH, <span class="number">0</span>, <span class="number">0</span>));<span class="comment">//画笔改成虚线模式</span></span><br><span class="line">		Rectangle(hdc, rect.left, rect.top, rect.right,rect.bottom);</span><br><span class="line">		DeleteObject(SelectObject(hdc, GetStockObject(BLACK_PEN)));<span class="comment">//删除刚才创建的逻辑画笔实例</span></span><br><span class="line">	&#125;</span><br><span class="line">	EndPaint(hwnd, &amp;ps);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>





<h2 id="捕获鼠标"><a href="#捕获鼠标" class="headerlink" title="捕获鼠标"></a>捕获鼠标</h2><p>书上举了一个例子,一个绘图程序,假如要绘制一个矩形,鼠标左键按下之后确定矩形一个点,不松开拖着鼠标移动则实时绘制矩形边框,(好像这个边框叫做橡皮线)</p>
<p>当鼠标左键松开时确定整个矩形,此时填充矩形表明完成绘制</p>
<h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><h4 id="绘制边框橡皮线函数"><a href="#绘制边框橡皮线函数" class="headerlink" title="绘制边框橡皮线函数"></a>绘制边框橡皮线函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DrawBoxOutline</span><span class="params">(HWND hwnd, POINT ptBeg, POINT ptEnd)</span><span class="comment">//正常情况下客户区内松开左键时调用,填充矩形</span></span><br><span class="line">&#123;</span><br><span class="line">	HDC hdc;</span><br><span class="line">	hdc = GetDC(hwnd);</span><br><span class="line">	SetROP2(hdc, R2_NOT);<span class="comment">//该函数的作用是,只要是绘图,当前背景色取反,原来是白板,取反得黑,交替使用绘图函数会呈现一白一黑</span></span><br><span class="line">	SelectObject(hdc, GetStockObject(NULL_BRUSH));<span class="comment">//设置画笔无色,用ROP2反色下一次画出黑色</span></span><br><span class="line">	Rectangle(hdc, ptBeg.x, ptBeg.y, ptEnd.x, ptEnd.y);</span><br><span class="line">	ReleaseDC(hwnd, hdc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ptBeg和ptEnd都是相对于hwnd的客户区而言的,意思是在hwnd中绘制一个左上角ptBeg到右下角的ptEnd矩形边框</p>
<h4 id="SetROP2"><a href="#SetROP2" class="headerlink" title="SetROP2"></a>SetROP2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SetROP2</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HDC hdc,</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span> rop2<span class="comment">//样式</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The <strong>SetROP2</strong> function sets the current foreground mix mode. GDI uses the foreground mix mode to combine pens and interiors of filled objects with the colors already on the screen. The foreground mix mode defines how colors from the brush or pen and the colors in the existing image are to be combined.</p>
</blockquote>
<p>SetROP2函数设置当前前景的混合模式.</p>
<p>GDI使用前景混合模式,作用是将画笔画刷的行为和先前已有的颜色结合起来.也就是说本次绘画会影响之前的绘画,rop2参数指定怎么个影响方法,是将像素点的颜色异或还是按位与还是直接擦除先前颜色等等</p>
<blockquote>
<p>前景和背景是相反的,背景在正文图层的下面,前景在正文图层的上面</p>
</blockquote>
<p>rop2的可选值:</p>
<table>
<thead>
<tr>
<th align="left">Mix mode</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>R2_BLACK</strong></td>
<td align="left">直接画黑,不考虑很多,不使用画笔颜色,相当于设置了一个寂寞</td>
</tr>
<tr>
<td align="left"><strong>R2_COPYPEN</strong></td>
<td align="left">继续使用画笔颜色,相当于设置了一个寂寞</td>
</tr>
<tr>
<td align="left"><strong>R2_MASKNOTPEN</strong></td>
<td align="left">原屏幕颜色和画笔反色的结合</td>
</tr>
<tr>
<td align="left"><strong>R2_MASKPEN</strong></td>
<td align="left">Pixel is a combination of the colors common to both the pen and the screen.</td>
</tr>
<tr>
<td align="left"><strong>R2_MASKPENNOT</strong></td>
<td align="left">Pixel is a combination of the colors common to both the pen and the inverse of the screen.</td>
</tr>
<tr>
<td align="left"><strong>R2_MERGENOTPEN</strong></td>
<td align="left">Pixel is a combination of the screen color and the inverse of the pen color.</td>
</tr>
<tr>
<td align="left"><strong>R2_MERGEPEN</strong></td>
<td align="left">Pixel is a combination of the pen color and the screen color.</td>
</tr>
<tr>
<td align="left"><strong>R2_MERGEPENNOT</strong></td>
<td align="left">Pixel is a combination of the pen color and the inverse of the screen color.</td>
</tr>
<tr>
<td align="left"><strong>R2_NOP</strong></td>
<td align="left">啥也不改变,更是个寂寞</td>
</tr>
<tr>
<td align="left"><strong>R2_NOT</strong></td>
<td align="left">和原屏幕颜色相反</td>
</tr>
<tr>
<td align="left"><strong>R2_NOTCOPYPEN</strong></td>
<td align="left">笔的反色</td>
</tr>
<tr>
<td align="left"><strong>R2_NOTMASKPEN</strong></td>
<td align="left">Pixel is the inverse of the R2_MASKPEN color.</td>
</tr>
<tr>
<td align="left"><strong>R2_NOTMERGEPEN</strong></td>
<td align="left">Pixel is the inverse of the R2_MERGEPEN color.</td>
</tr>
<tr>
<td align="left"><strong>R2_NOTXORPEN</strong></td>
<td align="left">Pixel is the inverse of the R2_XORPEN color.</td>
</tr>
<tr>
<td align="left"><strong>R2_WHITE</strong></td>
<td align="left">Pixel is always 1.</td>
</tr>
<tr>
<td align="left"><strong>R2_XORPEN</strong></td>
<td align="left">Pixel is a combination of the colors in the pen and in the screen, but not in both.</td>
</tr>
</tbody></table>
<h4 id="左键按下消息-1"><a href="#左键按下消息-1" class="headerlink" title="左键按下消息"></a>左键按下消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">	ptBeg.x = ptEnd.x = LOWORD(lParam);<span class="comment">//ptBeg获取当前鼠标位置</span></span><br><span class="line">	ptBeg.y = ptEnd.y = HIWORD(lParam);</span><br><span class="line"></span><br><span class="line">	DrawBoxOutline(hwnd, ptBeg, ptEnd);<span class="comment">//描矩形边.使用ptBeg,ptEnd指定主对角线的矩形</span></span><br><span class="line"></span><br><span class="line">	SetCursor(LoadCursor(<span class="literal">NULL</span>, IDC_CROSS));<span class="comment">//左键按下后进入绘制状态,鼠标变成十字提示绘图</span></span><br><span class="line"></span><br><span class="line">	fBlocking = TRUE;<span class="comment">//一个flag,表征鼠标是否一直按下,这个状态会被Esc键修改,表示终止绘图</span></span><br><span class="line">	SetCapture(hwnd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>左键按下时就已经开始绘图了,首先绘制一个点,即左键按下时的鼠标位置,</p>
<p>fBlocking变量用来记录绘图过程中有没有被Esc打断过.</p>
<p>SetCapture(hwnd)意思是从调用该函数开始,所有鼠标动作,包括不在本客户区的鼠标动作,全都被本程序捕获.这种状态需要到ReleaseCapture解出</p>
<h5 id="Set-ReleaseCapture"><a href="#Set-ReleaseCapture" class="headerlink" title="Set&#x2F;ReleaseCapture"></a>Set&#x2F;ReleaseCapture</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SetCapture(hwnd);//此函数执行之后所有的鼠标动作将被hwnd指向的窗口捕获</span><br><span class="line">ReleaseCapture();//直到本函数执行之后鼠标动作才会恢复正常</span><br></pre></td></tr></table></figure>





<h4 id="鼠标移动消息"><a href="#鼠标移动消息" class="headerlink" title="鼠标移动消息"></a>鼠标移动消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line">	<span class="keyword">if</span> (fBlocking)</span><br><span class="line">	&#123;</span><br><span class="line">		SetCursor(LoadCursor(<span class="literal">NULL</span>, IDC_CROSS));</span><br><span class="line"></span><br><span class="line">		DrawBoxOutline(hwnd, ptBeg, ptEnd);</span><br><span class="line"></span><br><span class="line">		ptEnd.x = LOWORD(lParam);</span><br><span class="line">		ptEnd.y = HIWORD(lParam);</span><br><span class="line"></span><br><span class="line">		DrawBoxOutline(hwnd, ptBeg, ptEnd);<span class="comment">//这里矩形边框画了两次,是因为后来这一次会更新前面那一次,由于SetROP2已经设置了黑白交替绘画,</span></span><br><span class="line">		<span class="comment">//当前一次是黑笔是,后一次是白笔就擦除了前面的绘制</span></span><br><span class="line">		<span class="comment">//如此做到只能看到一个实时边框,否则只绘制一次会导致很多重影</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>由于左键起来之后会进行结算,因此绘图时的鼠标移动是压着左键移动的</p>
<p>首先判断了fBlocking的状态,如果被Esc打断则直接退出,不做处理</p>
<p>这里调用了两次<code>DrawBoxOutline</code>,其作用是:</p>
<p>由于<code>SetROP2(hdc, R2_NOT)</code>这个设置,会导致相邻两次绘图使用的颜色相反</p>
<p>如果本次使用黑色,那么下一次就使用白色</p>
<p>这样交替绘制的意义是:刚用黑色绘制出边框,接着逻辑上擦除它,但是在屏幕上不显示擦除,这就是压着黑笔停下时仍然能看到过期的客户区上有边框线.当画笔再次移动时,先前的边框已经被逻辑擦除,此时再画新线保证只有新线,不会有重影.这就实现了橡皮线的效果</p>
<p>这里两次调用<code>DrawBoxOutline</code>,头一次的ptEnd没有被修改,也就是上一次绘图使用的ptEnd,那么重绘这个矩形,相当于擦除了上一次的绘制</p>
<h4 id="左键起来消息"><a href="#左键起来消息" class="headerlink" title="左键起来消息"></a>左键起来消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line">	<span class="keyword">if</span> (fBlocking)<span class="comment">//如果fBlocking==1说明左键按下没有起来过并且没有被Esc中断过</span></span><br><span class="line">	&#123;</span><br><span class="line">		DrawBoxOutline(hwnd, ptBeg, ptEnd);<span class="comment">//这里只调用了一次,是因为这一次要固定边框位置了,直接描黑</span></span><br><span class="line"></span><br><span class="line">		ptBoxBeg = ptBeg;</span><br><span class="line">		ptBoxEnd.x = LOWORD(lParam);<span class="comment">//准备好需要填充的矩形范围</span></span><br><span class="line">		ptBoxEnd.y = HIWORD(lParam);</span><br><span class="line">		</span><br><span class="line">		ReleaseCapture();</span><br><span class="line">		SetCursor(LoadCursor(<span class="literal">NULL</span>, IDC_ARROW));<span class="comment">//放下屠刀之后,鼠标变成了斜向箭头样式</span></span><br><span class="line">		fBlocking = FALSE;<span class="comment">//关闭中断标志,为下一次绘图做准备</span></span><br><span class="line">		fValidBox = TRUE;<span class="comment">//设置填充区域有效,可以填充,为WM_PAINT做准备</span></span><br><span class="line"></span><br><span class="line">		InvalidateRect(hwnd, <span class="literal">NULL</span>, TRUE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>首先判断fBlocking状态,如果中途被Esc打断过则不做处理</p>
<p>调用一次<code>DrawBoxOutline</code>擦除最后一次<code>WM_MOUSEMOVE</code>留下的边框.但是最后一次WM_MOUSEMOVE和WM_LBUTTONUP的到达时间非常接近,拉不开差距,因此这个函数调用与否意义不大,除非电脑很卡</p>
<p>释放对鼠标的捕获状态,程序对于客户区以外的鼠标动作不再处理</p>
<p>鼠标样式还原为斜向箭头</p>
<p>重置中断标志,设置绘图标志有效,提醒WM_PAINT应该绘制填充矩形了</p>
<h4 id="Esc中断消息"><a href="#Esc中断消息" class="headerlink" title="Esc中断消息"></a>Esc中断消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CHAR:</span><br><span class="line">	<span class="keyword">if</span> (fBlocking &amp; wParam == <span class="string">&#x27;\x1B&#x27;</span>) <span class="comment">// i.e., Escape //按下Esc终止绘制矩形,即使左键正在按下</span></span><br><span class="line">	&#123;</span><br><span class="line">		DrawBoxOutline(hwnd, ptBeg, ptEnd);</span><br><span class="line"></span><br><span class="line">		SetCursor(LoadCursor(<span class="literal">NULL</span>, IDC_ARROW));</span><br><span class="line"></span><br><span class="line">		fBlocking = FALSE;<span class="comment">//Esc中止逻辑修改了一个fBlocking,就可以让程序知道左键按下起来之间有没有被中断过</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>对于该消息,例子采用的是处理字符消息,而不是处理虚拟键消息</p>
<p>如果出现Esc消息并且fBlocking表明正在绘图,那么设置fBlocking绘图无效</p>
<p>此后由于WM_MOUSEMOVE需要判断fBlocking正在绘图才继续绘制边框,因此Esc出现之后矩形边框橡皮线立刻消失</p>
<p>然而这种绘制失效的状态需要等到<strong>左键起来</strong>才能完全恢复</p>
<p>WM_LBUTTONUP也会先判断fBlocking是否还有效.无效则啥也不处理</p>
<p>此时所有标志都恢复原状(fValidBox压根没有被改变过,fBlocking被Esc重置为假)</p>
<h4 id="绘图消息-2"><a href="#绘图消息-2" class="headerlink" title="绘图消息"></a>绘图消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">	hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line">	<span class="keyword">if</span> (fValidBox)<span class="comment">//这个值只能通过鼠标左键起来修改,表明确实有过画图</span></span><br><span class="line">	&#123;</span><br><span class="line">		SelectObject(hdc, GetStockObject(BLACK_BRUSH));</span><br><span class="line">		Rectangle(hdc, ptBoxBeg.x, ptBoxBeg.y,ptBoxEnd.x, ptBoxEnd.y);<span class="comment">//填充</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fBlocking)<span class="comment">//fBlocking=1表明正在绘图,应当打印边框</span></span><br><span class="line">	&#123;</span><br><span class="line">		SetROP2(hdc, R2_NOT);</span><br><span class="line">		SelectObject(hdc, GetStockObject(NULL_BRUSH));</span><br><span class="line">		Rectangle(hdc, ptBeg.x, ptBeg.y, ptEnd.x,ptEnd.y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	EndPaint(hwnd, &amp;ps);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>fValidBox是LBUTTONUP准备好的绘制标志,如果绘画中途没有Esc中断则LBUTTONUP消息处理中,会把fValidBox置有效,提醒WM_PAINT应该画图了</p>
<p>修改画刷为黑色画刷然后填充最后确定的矩形</p>
<p>如果fBlocking为有效说明仍然没有确定矩形的另一个点,此时WM_PAINT也打印矩形边框橡皮线,然而是多次一句,因为WM_MOUSEMOVE已经把这件事干了.</p>
<h4 id="窗口销毁消息-2"><a href="#窗口销毁消息-2" class="headerlink" title="窗口销毁消息"></a>窗口销毁消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">	PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="鼠标滚动"><a href="#鼠标滚动" class="headerlink" title="鼠标滚动"></a>鼠标滚动</h2><h3 id="鼠标滚动消息WM-MOUSEWHEEL"><a href="#鼠标滚动消息WM-MOUSEWHEEL" class="headerlink" title="鼠标滚动消息WM_MOUSEWHEEL"></a>鼠标滚动消息WM_MOUSEWHEEL</h3><p>当鼠标滚轮滚动时,该消息将被发往<strong>焦点窗口</strong>,</p>
<p>参数意义:</p>
<h4 id="wParam-3"><a href="#wParam-3" class="headerlink" title="wParam"></a>wParam</h4><p>高字表明滚动增量</p>
<p>低字表明同时按下的虚拟键</p>
<table>
<thead>
<tr>
<th align="left">Value</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>MK_CONTROL</strong>0x0008</td>
<td align="left">The CTRL key is down.</td>
</tr>
<tr>
<td align="left"><strong>MK_LBUTTON</strong>0x0001</td>
<td align="left">The left mouse button is down.</td>
</tr>
<tr>
<td align="left"><strong>MK_MBUTTON</strong>0x0010</td>
<td align="left">The middle mouse button is down.</td>
</tr>
<tr>
<td align="left"><strong>MK_RBUTTON</strong>0x0002</td>
<td align="left">The right mouse button is down.</td>
</tr>
<tr>
<td align="left"><strong>MK_SHIFT</strong>0x0004</td>
<td align="left">The SHIFT key is down.</td>
</tr>
<tr>
<td align="left"><strong>MK_XBUTTON1</strong>0x0020</td>
<td align="left">The first X button is down.</td>
</tr>
<tr>
<td align="left"><strong>MK_XBUTTON2</strong>0x0040</td>
<td align="left">The second X button is down.</td>
</tr>
</tbody></table>
<h4 id="lParam-3"><a href="#lParam-3" class="headerlink" title="lParam"></a>lParam</h4><p>低字表明此时鼠标位置横坐标,屏幕坐标</p>
<p>高字表明纵坐标</p>
<h3 id="滚动增量"><a href="#滚动增量" class="headerlink" title="滚动增量"></a>滚动增量</h3><p>衡量滚得狠不狠的参数,如果一下子转了好几圈显然增量很大,如果只发生了很少的转动,那么这点增量几乎不能导致程序卷动</p>
<p>在控制面板中我们可以设置滚动灵敏度,相同的滚动增量,假设都转一圈,可能灵敏度高的可以滚动一整页,灵敏度低的滚了三行,这是怎么实现的呢?</p>
<p>用滚动增量除以一个灵敏度系数,不妨给这个量起名<strong>灵敏后增量</strong>(我乱起的)</p>
<p>比如滚动增量为120,除以3得到40就是灵敏后增量.</p>
<p>在程序中我们可以设置一个<strong>单位行增量</strong>,意思是多少滚动增量可以导致程序卷动一个行,比如说设置为40</p>
<p>那么当灵敏度系数为3,那么初始时的120滚动增量就可以得到40 的灵敏后增量,刚好可以卷动一行</p>
<p>如果灵敏度系数为1,则灵敏后增量就是120.可以卷动三行</p>
<p>这就体现出不同灵敏度的区别了</p>
<h3 id="加装滚动动作的Sysmets程序"><a href="#加装滚动动作的Sysmets程序" class="headerlink" title="加装滚动动作的Sysmets程序"></a>加装滚动动作的Sysmets程序</h3><h4 id="滚动相关变量"><a href="#滚动相关变量" class="headerlink" title="滚动相关变量"></a>滚动相关变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> iDeltaPerLine, iAccumDelta;</span><br><span class="line">ULONG ulScrollLines;</span><br></pre></td></tr></table></figure>

<p>iDeltaPerLine即单位行增量</p>
<p>iAccumDelta表示先前的滚动效果的累加,可以理解为初始滚动量</p>
<p>ulScrollLines存放灵敏度系数</p>
<h4 id="滚动消息"><a href="#滚动消息" class="headerlink" title="滚动消息"></a>滚动消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_MOUSEWHEEL:</span><br><span class="line">	<span class="keyword">if</span> (iDeltaPerLine == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">	iAccumDelta += (<span class="type">short</span>)HIWORD(wParam);<span class="comment">//累计滚动量</span></span><br><span class="line">	<span class="keyword">while</span> (iAccumDelta &gt;= iDeltaPerLine) &#123;<span class="comment">//能滚就滚</span></span><br><span class="line">		SendMessage(hwnd, WM_VSCROLL, SB_LINEUP, <span class="number">0</span>);<span class="comment">//滚一行</span></span><br><span class="line">		iAccumDelta -= iDeltaPerLine;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (iAccumDelta &lt;= -iDeltaPerLine) &#123;<span class="comment">//倒着能滚就滚</span></span><br><span class="line">		SendMessage(hwnd, WM_VSCROLL, SB_LINEDOWN, <span class="number">0</span>);</span><br><span class="line">		iAccumDelta += iDeltaPerLine;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>








































      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/08/12/windows%20SDK%20chapter%206%20keyboard/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/12/windows%20SDK%20chapter%206%20keyboard/" class="post-title-link" itemprop="url">win32程序设计-chapter6 键盘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-12 23:38:00 / Modified: 23:46:10" itemprop="dateCreated datePublished" datetime="2022-08-12T23:38:00+08:00">2022-08-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="windows-SDK-chapter-6-keyboard"><a href="#windows-SDK-chapter-6-keyboard" class="headerlink" title="windows SDK chapter 6 keyboard"></a>windows SDK chapter 6 keyboard</h1><h2 id="键盘基础"><a href="#键盘基础" class="headerlink" title="键盘基础"></a>键盘基础</h2><h3 id="who-is-using-the-keyboard"><a href="#who-is-using-the-keyboard" class="headerlink" title="who is using the keyboard?"></a>who is using the keyboard?</h3><p>正在使用键盘的窗口,称为有输入焦点的窗口</p>
<p>windows操作系统上处于最顶层的窗口往往是焦点窗口,然而存在两分屏看似并列的情况,实际上这时候可以从多方面判断哪个窗口是焦点窗口</p>
<p>比如从任务栏</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812083837696.png" alt="image-20220812083837696"></p>
<p>这里Typora上有高亮,就是焦点窗口,</p>
<p>windows终端,DEVC++,VisualStudio等等都是黑色的,不是焦点窗口</p>
<p>又如从标题栏</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812083907654.png" alt="image-20220812083907654"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812083932266.png" alt="左侧typora为焦点窗口,其标题栏为深色."></p>
<p>在word,wps等等文字编辑器中,是否获得焦点更加明显,只要光标在闪烁就意味着持有焦点</p>
<p>实际上窗口过程通过处理<code>WM_SETFOCUS,WM_KILLFOCUS</code>两个消息来判断自己有没有焦点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SETFOCUS:</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;focused&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> WM_KILLFOCUS:</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;left&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="number">86135</span>\desktop\myWin32&gt; g++ main.cpp -O0 -o main -lkernel32 -lgdi32 -luser32 -m32</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812084229815.png" alt="焦点在windows终端"></p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812084241047.png" alt="焦点在the Hello Program"></p>
<h3 id="队列与同步"><a href="#队列与同步" class="headerlink" title="队列与同步"></a>队列与同步</h3><p>键盘动作由键盘驱动程序转化为格式化的消息之后,首先发往windows消息队列,不会直接发往焦点窗口</p>
<p>这是因为,有的键盘消息具有修改焦点窗口的功能,比如Alt+F4可关闭当前窗口.又比如win+r可以打开运行框,此时窗口焦点自动放在运行框上</p>
<p>windows需要先看一看键盘消息是针对当前焦点窗口的还是针对整个系统的.</p>
<p>如果发生了焦点转移,那么windows需要保证后续的相应键盘消息指向新的焦点窗口</p>
<h2 id="击键消息"><a href="#击键消息" class="headerlink" title="击键消息"></a>击键消息</h2><p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812085353287.png" alt="image-20220812085353287"></p>
<p>其中系统键一般是Alt+其他键的组合键,比如Alt+Tab,切换任务窗口.</p>
<p>键按下之后如果不松开,会间隔一定时间(这个间隔在系统启动时BIOS中设置)之后进入连续输入状态(连续输入的速度也取决于BIOS中的设置),此时应用程序会收到一连串的WM_KEYDOWN或者WM_SYSKEYDOWN消息</p>
<p>系统键对于windows操作系统来说更加重要,应用程序一般忽略系统键信息,交给DefWindowProc处理.windows会处理所有Alt组合键信息</p>
<p>如果非得在应用程序中处理Alt消息,并且处理完成之后立刻返回,不调用DefWindowProc,那么系统键消息将会被应用程序截胡,不能发给操作系统.此时按下Alt+F4就无法关闭该窗口了</p>
<p>比如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SYSKEYDOWN:</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sysKey down&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> WM_SYSKEYUP:</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sysKey up&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>此时只会在终端上打印一下,但是只要时Alt键的消息都不会发往windows</p>
<p>当组合键中没有Alt时,不会产生系统键消息,顶多产生WM_KEYDOWN和WM_KEYUP,应用程序可以根据自己的兴趣选择处理其中的部分消息,如果应用程序不做处理,windows也不做处理</p>
<p>不管是系统键消息还是非系统键消息,不管是按下还是起来,所有的键盘消息都会伴随着wParam表示虚拟键代码,lParam包含本次击键的其他数据</p>
<h3 id="虚拟键代码wParam"><a href="#虚拟键代码wParam" class="headerlink" title="虚拟键代码wParam"></a>虚拟键代码wParam</h3><p>捕获WM_KEYDOWN或者WM_KEYUP消息只能说明非系统键被按下或者松开了,单凭着一个信息无法判断谁被按下或者松开了.wParam就提供了更多的细节</p>
<p>该案件消息是一个枚举类型,大多数都以VK_开头</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VK_LBUTTON 0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_RBUTTON 0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_CANCEL 0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_MBUTTON 0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_XBUTTON1 0x05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_XBUTTON2 0x06</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_BACK 0x08</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_TAB 0x09</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_CLEAR 0x0C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_RETURN 0x0D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_SHIFT 0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_CONTROL 0x11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_MENU 0x12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_PAUSE 0x13</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>前两个鼠标动作貌似通过处理不到</p>
<p>数字键(不是右侧数字键盘,是左侧主键盘上一长条的数字键)和字母键:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812092101119.png" alt="image-20220812092101119"></p>
<p>虽然键盘可以接收到键盘上<code>@#$%*</code>这种字符的消息,但是这是对于英语键盘而言的,对于欧洲人来说欧元符号比美元符号更加重要,如果要写出地区无关的代码,那么我们需要和windows操作系统协作处理键盘消息,对于有意义的字符的处理,<strong>一般使用字符消息,不使用击键消息</strong></p>
<p>微软键盘特有:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812092200252.png" alt="image-20220812092200252"></p>
<p>需要给哪个键安排任务的时候就去查它的宏定义编码即可</p>
<h3 id="其他消息lParam"><a href="#其他消息lParam" class="headerlink" title="其他消息lParam"></a>其他消息lParam</h3><p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812094137721.png" alt="image-20220812094137721"></p>
<h4 id="重复计数Repeat-Count"><a href="#重复计数Repeat-Count" class="headerlink" title="重复计数Repeat Count"></a>重复计数Repeat Count</h4><p>低16位为重复计数,当一个键按下一直不松开时,应用程序会接收到一大串WM_KEYDOWN消息.如果窗口过程的处理速度跟不上,那么windows会把多个WM_KEYDOWN消息合并成一条消息,然后修改其lParam的低16位,决定这条消息重复了多少次</p>
<p>在比较卡顿的电脑上使用word有过这种体验,一直按着某个键不放,计算机可能不会实时跟着显示字符,但是一段时间后呼哧出来一摊这个字符</p>
<h4 id="OEM扫描码"><a href="#OEM扫描码" class="headerlink" title="OEM扫描码"></a>OEM扫描码</h4><p>历史古董了,现在几乎不用了</p>
<h4 id="拓展键标记Extended-Key-Flag"><a href="#拓展键标记Extended-Key-Flag" class="headerlink" title="拓展键标记Extended Key Flag"></a>拓展键标记Extended Key Flag</h4><p>对于IBM拓展键盘才有用,一般的键盘上已经有足够多的键用了,不需要拓展了</p>
<h4 id="内容代码Context-Code"><a href="#内容代码Context-Code" class="headerlink" title="内容代码Context Code"></a>内容代码Context Code</h4><p>如果Alt键被按下,则相应的键盘消息中该值为1</p>
<h4 id="先前状态Previous-Key-State"><a href="#先前状态Previous-Key-State" class="headerlink" title="先前状态Previous Key State"></a>先前状态Previous Key State</h4><p>如果先前改键是松开的则该值为0</p>
<p>如果先前该键是按下的则该值为1</p>
<p>这个值可以用来去除重复输入,比如老年人动作缓慢,本来就只想输入一个A结果按下A忘了松开了 ,可以判断先前该键的状态,如果也是按下的则抛弃</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">    <span class="keyword">if</span>((lParam&gt;&gt;<span class="number">30</span>)&amp;<span class="number">1</span>)&#123;<span class="comment">//lParam第31位是键先前状态,右移30位之后成为最低位,和1按位与只保留该位</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="转换状态Transition-State"><a href="#转换状态Transition-State" class="headerlink" title="转换状态Transition State"></a>转换状态Transition State</h4><p>键正在被按下则转换状态为0</p>
<p>键正在被释放则转换状态为1</p>
<h3 id="转义状态"><a href="#转义状态" class="headerlink" title="转义状态"></a>转义状态</h3><p>转义键:Shift,Alt,Ctrl</p>
<p>切换键:Caps Lock,Num Lock,Scroll Lock</p>
<p>区分主键盘上大小写输入就要看这些键的状态</p>
<p>考虑如何判断一套组合键都有谁按下了呢?比如Ctrl+F,首先按下的是Ctrl,然后按下F,但是按下F的时候引用程序已经处理过了Ctrl,现在只知道按下了F.这样看来是不是还得开一些变量记录刚才按下了谁呢?当Ctrl松开的时候这个变量置零,当Ctrl按下的时候这个变量置1.</p>
<p>windows操作系统确实是按照这个思想做的,它给我们代劳了.我们要判断Ctrl的状态,只需要<code>GetKeyState(VK_CONTROL);</code>就可以获取windows帮我们记录好的Ctrl状态了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHORT <span class="title function_">GetKeyState</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span> nVirtKey</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>当需要查询状态的键处于按下时,该函数返回负值.否则最低位置1</p>
<p>可以通过是否小于0或者和1按位与判断状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(wParam&lt;=<span class="number">0x5A</span>&amp;&amp;wParam&gt;=<span class="number">0x41</span>)&#123;<span class="comment">//首先判断是不是英文字母</span></span><br><span class="line">    <span class="keyword">if</span>(GetKeyState(VK_CAPITAL))&#123;</span><br><span class="line">        szBuffer[cnt_keys]=wParam;<span class="comment">//大写字母添加进入缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        szBuffer[cnt_keys]=wParam-<span class="string">&#x27;A&#x27;</span>+<span class="string">&#x27;a&#x27;</span>;<span class="comment">//小写字母添加进入缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    ++cnt_keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>给滚动条添加键盘动作:</p>
<p>按下PgUp往前翻页,按下PgDn往后翻页</p>
<p>按上下键滚动一行</p>
<p>按左右键左右滚动一个字符的宽度</p>
<p>实际上直接发送信息处理滚动条消息即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">	<span class="keyword">switch</span> (wParam) &#123;</span><br><span class="line">	<span class="keyword">case</span> VK_HOME:</span><br><span class="line">		SendMessage(hwnd, WM_VSCROLL, SB_BOTTOM, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_END:</span><br><span class="line">		SendMessage(hwnd, WM_VSCROLL, SB_TOP, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_PRIOR:</span><br><span class="line">		SendMessage(hwnd, WM_VSCROLL, SB_PAGEUP, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_NEXT:</span><br><span class="line">		SendMessage(hwnd, WM_VSCROLL, SB_PAGEDOWN, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">case</span> VK_UP:</span><br><span class="line">		SendMessage(hwnd, WM_VSCROLL, SB_LINEUP, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_DOWN:</span><br><span class="line">		SendMessage(hwnd, WM_VSCROLL, SB_LINEDOWN, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_RIGHT:</span><br><span class="line">		SendMessage(hwnd, WM_HSCROLL, SB_LINERIGHT, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_LEFT:</span><br><span class="line">		SendMessage(hwnd, WM_HSCROLL, SB_LINELEFT, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="字符消息"><a href="#字符消息" class="headerlink" title="字符消息"></a>字符消息</h2><h3 id="再看消息循环"><a href="#再看消息循环" class="headerlink" title="再看消息循环"></a>再看消息循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    TranslateMessage(&amp;msg);</span><br><span class="line">    DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主函数的最后,返回之前,像定式一样必须要有一个消息循环.</p>
<p>其中GetMessage从应用程序的消息队列中,获取一条新消息,用msg承载该消息</p>
<p>DispatchMessage将该消息分拣交给相应窗口</p>
<p>TranslageMessage将<strong>可打印字符</strong>的击键消息转换为<strong>字符消息</strong>,然后将该字符消息放入应用程序的消息队列</p>
<blockquote>
<p>可打印字符包括英文字母,阿拉伯数字,标点符号,运算符号等等</p>
<p>不包括Ctrl,Shift,Insert,Delete,Alt</p>
</blockquote>
<p>字符消息的种类:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812105605047.png" alt="image-20220812105605047"></p>
<p>死字符只对需要重音符号的语言键盘有用,比如德语.可以忽略</p>
<p>应用程序主要就处理WM_CHAR消息,该消息从WM_KEYDOWN翻译而来.</p>
<p>WM_SYSCHAR消息从WM_SYSKEYDOWN翻译而来</p>
<h3 id="参数意义"><a href="#参数意义" class="headerlink" title="参数意义"></a>参数意义</h3><p>对于字符消息,lParam参数的含义和击键消息相同</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812201421640.png" alt="image-20220812201421640"></p>
<p>wParam是ANSI或者Unicode编码的字符码,这一点和击键消息中不同</p>
<p>具体是用的ANSI还是Unicode编码,要看注册窗口类的时候调用的是RegisterClassA还是RegisterClassW</p>
<blockquote>
<p>如果使用RegisterClass,最近的windows操作系统上会被宏定义为RegisterClassW.因为Windows 2000之后Unicode标识符就被定义了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RegisterClass  RegisterClassW</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RegisterClass  RegisterClassA</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !UNICODE</span></span></span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="先来后到"><a href="#先来后到" class="headerlink" title="先来后到"></a>先来后到</h3><p>当字符键盘比如’A’按下后,对于应用程序的消息队列</p>
<p>首先收到的是’A’的击键消息WM_KEYDOWN,虚拟键代码wParam&#x3D;0x41</p>
<p>然后收到的是’A’的字符消息WM_CHAR,字符编码wParam&#x3D;0x61</p>
<p>然后’A’松开时收到击键消息WM_KEYUP,虚拟键代码wParam&#x3D;0x41</p>
<h3 id="各司其职"><a href="#各司其职" class="headerlink" title="各司其职"></a>各司其职</h3><p>对于功能键比如Ctrl,Shift等等,作为虚拟键,需要处理WM_KEYDOWN消息</p>
<p>对于可打印字符就需要处理字符消息WM_CHAR</p>
<p>Tab,回车,空格,Esc作为控制字符也处理WM_CHAR</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812203020207.png" alt="image-20220812203020207"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CHAR:</span><br><span class="line">    <span class="keyword">switch</span> (wParam)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\b&#x27;</span>:</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;space down&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Tab down&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Ctrl+Enter down&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter down&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><p>windows程序设计在此给出了一个例子,记录键盘动作并且输出到屏幕</p>
<p>分析其过程函数WndProc</p>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">	<span class="type">static</span> <span class="type">int</span> cxClientMax, cyClientMax, cxClient, cyClient, cxChar, cyChar;</span><br><span class="line"><span class="comment">//cxClientMax为客户区最大宽度,根据该值决定保存显示哪一部分消息</span></span><br><span class="line"><span class="comment">//cxClient是客户区宽度</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> cLinesMax, cLines;<span class="comment">//当前客户区最大能打印多少行,已经使用了多少行</span></span><br><span class="line">	<span class="type">static</span> PMSG pmsg;<span class="comment">//消息结构体</span></span><br><span class="line">	<span class="type">static</span> RECT rectScroll;<span class="comment">//客户区矩形</span></span><br><span class="line">	<span class="type">static</span> TCHAR szTop[] = TEXT(<span class="string">&quot;Message Key Char &quot;</span>)	TEXT(<span class="string">&quot;Repeat Scan Ext ALT Prev Tran&quot;</span>);<span class="comment">//顶部栏目</span></span><br><span class="line">	<span class="type">static</span> TCHAR szUnd[] = TEXT(<span class="string">&quot;_______ ___ ____ &quot;</span>)	TEXT(<span class="string">&quot;______ ____ ___ ___ ____ ____&quot;</span>);<span class="comment">//下划线 </span></span><br><span class="line">	<span class="type">static</span> TCHAR  szFormat[<span class="number">2</span>][<span class="number">100</span>] = &#123;<span class="comment">//格式化字符串,用于szTop和szUnd的打印格式</span></span><br><span class="line">		TEXT(<span class="string">&quot;%-13s %3d %-15s%c%6u %4d %3s %3s %4s %4s&quot;</span>),</span><br><span class="line">		TEXT(<span class="string">&quot;%-13s 0x%04X%1s%c %6u %4d %3s %3s %4s %4s&quot;</span>)</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> TCHAR  szYes[] = TEXT(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">	<span class="type">static</span> TCHAR szNo[] = TEXT(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">	<span class="type">static</span> TCHAR  szDown[] = TEXT(<span class="string">&quot;Down&quot;</span>);</span><br><span class="line">	<span class="type">static</span> TCHAR  szUp[] = TEXT(<span class="string">&quot;Up&quot;</span>);</span><br><span class="line">	<span class="type">static</span> TCHAR  szMessage[<span class="number">8</span>][<span class="number">100</span>] = &#123;<span class="comment">//八种键盘消息</span></span><br><span class="line">		TEXT(<span class="string">&quot;WM_KEYDOWN&quot;</span>), TEXT(<span class="string">&quot;WM_KEYUP&quot;</span>),</span><br><span class="line">		TEXT(<span class="string">&quot;WM_CHAR&quot;</span>), TEXT(<span class="string">&quot;WM_DEADCHAR&quot;</span>),</span><br><span class="line">		TEXT(<span class="string">&quot;WM_SYSKEYDOWN&quot;</span>),TEXT(<span class="string">&quot;WM_SYSKEYUP&quot;</span>),</span><br><span class="line">		TEXT(<span class="string">&quot;WM_SYSCHAR&quot;</span>), TEXT(<span class="string">&quot;WM_SYSDEADCHAR&quot;</span>) </span><br><span class="line">	&#125;;</span><br><span class="line">	HDC hdc;<span class="comment">//设备环境句柄</span></span><br><span class="line">	<span class="type">int</span> i, iType;<span class="comment">//循环变量,</span></span><br><span class="line">	PAINTSTRUCT ps;</span><br><span class="line">	TCHAR szBuffer[<span class="number">128</span>], szKeyName[<span class="number">32</span>];</span><br><span class="line">	TEXTMETRIC tm;<span class="comment">//字符信息结构体</span></span><br></pre></td></tr></table></figure>

<h4 id="pmsg"><a href="#pmsg" class="headerlink" title="pmsg"></a>pmsg</h4><p>存放消息的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMSG</span> &#123;</span></span><br><span class="line">    HWND        hwnd;</span><br><span class="line">    UINT        message;</span><br><span class="line">    WPARAM      wParam;</span><br><span class="line">    LPARAM      lParam;</span><br><span class="line">    DWORD       time;</span><br><span class="line">    POINT       pt;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MAC</span></span><br><span class="line">    DWORD       lPrivate;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; MSG, *PMSG, NEAR *NPMSG, FAR *LPMSG;</span><br></pre></td></tr></table></figure>

<p>其前四个参数和WndProc窗口过程函数相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK    <span class="title function_">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span>;</span><br></pre></td></tr></table></figure>

<p>该结构体的作用就是完整记录一条消息,甚至连消息产生时间time都有记录</p>
<p>POINT pt记录的是发生该消息时鼠标的位置(相对于整块屏幕的坐标)</p>
<h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>记录绘画信息的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPAINTSTRUCT</span> &#123;</span></span><br><span class="line">    HDC         hdc;</span><br><span class="line">    BOOL        fErase;</span><br><span class="line">    RECT        rcPaint;</span><br><span class="line">    BOOL        fRestore;</span><br><span class="line">    BOOL        fIncUpdate;</span><br><span class="line">    BYTE        rgbReserved[<span class="number">32</span>];</span><br><span class="line">&#125; PAINTSTRUCT, *PPAINTSTRUCT, *NPPAINTSTRUCT, *LPPAINTSTRUCT;</span><br></pre></td></tr></table></figure>

<h5 id="hdc"><a href="#hdc" class="headerlink" title="hdc"></a>hdc</h5><p>设备环境句柄</p>
<h5 id="fErase"><a href="#fErase" class="headerlink" title="fErase"></a>fErase</h5><p>表明背景是否擦除,非0则擦除</p>
<h5 id="rcPaint"><a href="#rcPaint" class="headerlink" title="rcPaint"></a>rcPaint</h5><p>需要重绘的矩形范围</p>
<p>剩下三个成员尚未使用</p>
<h3 id="窗口创建和变形消息"><a href="#窗口创建和变形消息" class="headerlink" title="窗口创建和变形消息"></a>窗口创建和变形消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line"><span class="keyword">case</span> WM_DISPLAYCHANGE:<span class="comment">//窗口最大化还有普通状态变化时获取该消息</span></span><br><span class="line">	<span class="comment">// Get maximum size of client area </span></span><br><span class="line">	cxClientMax = GetSystemMetrics(SM_CXMAXIMIZED);<span class="comment">//顶层窗口最大化时的宽度(像素)</span></span><br><span class="line">	cyClientMax = GetSystemMetrics(SM_CYMAXIMIZED);</span><br><span class="line">	<span class="comment">// Get character size for fixed-pitch font </span></span><br><span class="line">	hdc = GetDC(hwnd);</span><br><span class="line">	SelectObject(hdc, GetStockObject(SYSTEM_FIXED_FONT));<span class="comment">//使用系统等宽字体</span></span><br><span class="line">	GetTextMetrics(hdc, &amp;tm);<span class="comment">//获取系统等宽字体信息</span></span><br><span class="line">	cxChar = tm.tmAveCharWidth;<span class="comment">//字符宽度,列宽度</span></span><br><span class="line">	cyChar = tm.tmHeight+tm.tmExternalLeading;<span class="comment">//行高度</span></span><br><span class="line">	ReleaseDC(hwnd, hdc);</span><br><span class="line">	<span class="comment">// Allocate memory for display lines </span></span><br><span class="line">	<span class="keyword">if</span> (pmsg)<span class="comment">//如果pmsg非NULL则表明先前已经给他分配过堆空间,那么本次需要重新分配,先把以前的扬了</span></span><br><span class="line">		<span class="built_in">free</span>(pmsg);</span><br><span class="line">	cLinesMax = cyClientMax / cyChar;<span class="comment">//计算行数</span></span><br><span class="line">	pmsg = (PMSG)<span class="built_in">malloc</span>(cLinesMax * <span class="keyword">sizeof</span>(MSG));<span class="comment">//根据当前客户区大小决定pmsg数组大小</span></span><br><span class="line">	cLines = <span class="number">0</span>;<span class="comment">//已使用行数清零</span></span><br><span class="line">	<span class="comment">// fall through </span></span><br><span class="line">	<span class="comment">//此处没有返回直接继续执行case WM_SIZE标签中的内容</span></span><br><span class="line"><span class="keyword">case</span> WM_SIZE:</span><br><span class="line">	<span class="keyword">if</span> (message == WM_SIZE)<span class="comment">//由于能够到达此块的不止WM_SIZE消息,还有可能时WM_CREATE和WM_DISPLAYCHANGE</span></span><br><span class="line">	&#123;</span><br><span class="line">		cxClient = LOWORD(lParam);<span class="comment">//只有窗口尺寸发生变化时才重新获取客户区尺寸</span></span><br><span class="line">		cyClient = HIWORD(lParam);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Calculate scrolling rectangle </span></span><br><span class="line">	<span class="comment">//滚动矩形的</span></span><br><span class="line">	rectScroll.left = <span class="number">0</span>;</span><br><span class="line">	rectScroll.right = cxClient;</span><br><span class="line">	rectScroll.top = cyChar;<span class="comment">//滚动矩形起点是第一行,第0行用于打印栏目常量</span></span><br><span class="line">	rectScroll.bottom = cyChar * (cyClient / cyChar);<span class="comment">//滚动矩形的底是客户区最多能容纳的那一行</span></span><br><span class="line">	InvalidateRect(hwnd, <span class="literal">NULL</span>, TRUE);<span class="comment">//一旦客户区尺寸变化则重绘整个客户区</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="键盘消息"><a href="#键盘消息" class="headerlink" title="键盘消息"></a>键盘消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//所有的键盘动作,包括击键消息和字符消息还有系统键消息都记录下来</span></span><br><span class="line"><span class="keyword">case</span> WM_KEYDOWN:<span class="comment">//键盘按下</span></span><br><span class="line"><span class="keyword">case</span> WM_KEYUP:<span class="comment">//键盘起来</span></span><br><span class="line"><span class="keyword">case</span> WM_CHAR:<span class="comment">//字符消息</span></span><br><span class="line"><span class="keyword">case</span> WM_DEADCHAR:<span class="comment">//死字符消息</span></span><br><span class="line"><span class="keyword">case</span> WM_SYSKEYDOWN:<span class="comment">//系统键Alt按下</span></span><br><span class="line"><span class="keyword">case</span> WM_SYSKEYUP:<span class="comment">//系统键起来</span></span><br><span class="line"><span class="keyword">case</span> WM_SYSCHAR:<span class="comment">//系统字符消息</span></span><br><span class="line"><span class="keyword">case</span> WM_SYSDEADCHAR:<span class="comment">//系统死字符消息</span></span><br><span class="line">	<span class="comment">// Rearrange storage array </span></span><br><span class="line">	<span class="keyword">for</span> (i = cLinesMax - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		pmsg[i] = pmsg[i - <span class="number">1</span>];<span class="comment">//新的键盘记录放到pmsg[0],历史消息都顺次后移一个</span></span><br><span class="line">           <span class="comment">//如果消息总数超过了cLinesMax则丢弃早些时候到达的消息,实际上维护了一个队列</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Store new message </span></span><br><span class="line">	pmsg[<span class="number">0</span>].hwnd = hwnd;<span class="comment">//记录最新键盘消息</span></span><br><span class="line">	pmsg[<span class="number">0</span>].message = message;</span><br><span class="line">	pmsg[<span class="number">0</span>].wParam = wParam;</span><br><span class="line">	pmsg[<span class="number">0</span>].lParam = lParam;</span><br><span class="line">	cLines = min(cLines + <span class="number">1</span>, cLinesMax);<span class="comment">//更新 &quot;已使用行数&quot; ,但是最大值不能超过最大行数</span></span><br><span class="line">	<span class="comment">// Scroll up the display </span></span><br><span class="line">	ScrollWindow(hwnd, <span class="number">0</span>, -cyChar, &amp;rectScroll, &amp;rectScroll);<span class="comment">//滚动rectScroll对应区域,实际上整个网上平移cyChar即一行的高度</span></span><br><span class="line">	<span class="keyword">break</span>; <span class="comment">// i.e., call DefWindowProc so Sys messages work</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>“i.e., call DefWindowProc so Sys messages work”翻译成人话:</p>
<p>“也就是说,调用DefWindowProc”处理系统键消息</p>
</blockquote>
<p>最后这里用的是break不是return,意味着只是看看键盘消息是谁而不进行拦截,记录一下接着丢给系统做取舍,保证Alt系统消息能够被正确处理</p>
<h3 id="绘图消息"><a href="#绘图消息" class="headerlink" title="绘图消息"></a>绘图消息</h3><p>前面的一切消息处理都是在给绘图消息的处理做准备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">	hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line">	SelectObject(hdc, GetStockObject(SYSTEM_FIXED_FONT));</span><br><span class="line">	SetBkMode(hdc, TRANSPARENT);</span><br><span class="line">	TextOut(hdc, <span class="number">0</span>, <span class="number">0</span>, szTop, lstrlen(szTop));<span class="comment">//打印最顶上第0行</span></span><br><span class="line">	TextOut(hdc, <span class="number">0</span>, <span class="number">0</span>, szUnd, lstrlen(szUnd));</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; min(cLines, cyClient / cyChar - <span class="number">1</span>); i++)<span class="comment">//一共打印cLines行,但是不能超过客户区总行数</span></span><br><span class="line">	&#123;</span><br><span class="line">		iType = pmsg[i].message == WM_CHAR ||<span class="comment">//如果是字符消息则iType=1否则为0</span></span><br><span class="line">			pmsg[i].message == WM_SYSCHAR ||</span><br><span class="line">			pmsg[i].message == WM_DEADCHAR ||</span><br><span class="line">			pmsg[i].message == WM_SYSDEADCHAR;</span><br><span class="line">		GetKeyNameText(pmsg[i].lParam, szKeyName,</span><br><span class="line">			<span class="keyword">sizeof</span>(szKeyName) / <span class="keyword">sizeof</span>(TCHAR));<span class="comment">//获取表示键名的字符串</span></span><br><span class="line">		TextOut(hdc, <span class="number">0</span>, (cyClient / cyChar - <span class="number">1</span> - i) * cyChar, szBuffer,</span><br><span class="line">			wsprintf(szBuffer, szFormat[iType],<span class="comment">//根据szFormat[iType]格式化字符串进行打印,即区分字符消息和虚拟键消息</span></span><br><span class="line">				szMessage[pmsg[i].message - WM_KEYFIRST],<span class="comment">///如此计算出来正好得到消息类型</span></span><br><span class="line">				pmsg[i].wParam,</span><br><span class="line">				(PTSTR)(iType ? TEXT(<span class="string">&quot; &quot;</span>) : szKeyName),<span class="comment">//如果是字符类型则打印空字符串否则打印键名</span></span><br><span class="line">				(TCHAR)(iType ? pmsg[i].wParam : <span class="string">&#x27; &#x27;</span>),<span class="comment">//如果是字符类型则打印该字符,否则打印空串</span></span><br><span class="line">				LOWORD(pmsg[i].lParam),</span><br><span class="line">				HIWORD(pmsg[i].lParam) &amp; <span class="number">0xFF</span>,</span><br><span class="line">				<span class="number">0x01000000</span> &amp; pmsg[i].lParam ? szYes : szNo,</span><br><span class="line">				<span class="number">0x20000000</span> &amp; pmsg[i].lParam ? szYes : szNo,</span><br><span class="line">				<span class="number">0x40000000</span> &amp; pmsg[i].lParam ? szDown : szUp,</span><br><span class="line">				<span class="number">0x80000000</span> &amp; pmsg[i].lParam ? szUp : szDown));</span><br><span class="line">	&#125;</span><br><span class="line">	EndPaint(hwnd, &amp;ps);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>其中<code>szMessage[pmsg[i].message - WM_KEYFIRST]</code>很巧妙</p>
<p>szMessage在WndProc一开始有定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> TCHAR  szMessage[<span class="number">8</span>][<span class="number">100</span>] = &#123;</span><br><span class="line">	TEXT(<span class="string">&quot;WM_KEYDOWN&quot;</span>), TEXT(<span class="string">&quot;WM_KEYUP&quot;</span>),</span><br><span class="line">	TEXT(<span class="string">&quot;WM_CHAR&quot;</span>), TEXT(<span class="string">&quot;WM_DEADCHAR&quot;</span>),</span><br><span class="line">	TEXT(<span class="string">&quot;WM_SYSKEYDOWN&quot;</span>),TEXT(<span class="string">&quot;WM_SYSKEYUP&quot;</span>),</span><br><span class="line">	TEXT(<span class="string">&quot;WM_SYSCHAR&quot;</span>), TEXT(<span class="string">&quot;WM_SYSDEADCHAR&quot;</span>) </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WM_KEYFIRST                     0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_KEYDOWN                      0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_KEYUP                        0x0101</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_CHAR                         0x0102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_DEADCHAR                     0x0103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_SYSKEYDOWN                   0x0104</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_SYSKEYUP                     0x0105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_SYSCHAR                      0x0106</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_SYSDEADCHAR                  0x0107</span></span><br></pre></td></tr></table></figure>

<p>WM_KEYFIRST表示WM消息的第一个,WM_KEYDOWN-WM_KEYFIRSST&#x3D;0x100-0x100&#x3D;0</p>
<p>正好对应szMessage下标为0的的成员TEXT(“WM_KEYDOWN”)</p>
<h3 id="窗口销毁消息"><a href="#窗口销毁消息" class="headerlink" title="窗口销毁消息"></a>窗口销毁消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">	PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="插入符号"><a href="#插入符号" class="headerlink" title="插入符号"></a>插入符号</h2><p>向文本编辑器中输入文本时,当前输入位置会有一个方格或者竖线或者下划线闪烁,</p>
<p>这个闪烁的玩意儿叫做”插入符号(caret)”,而不是”光标(cursor)”,光标是指鼠标位置</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812221958812.png" alt="windows终端中的插入符号"></p>
<p>windowsAPI提供了插入符号的现成的函数,</p>
<blockquote>
<p>在此之前我还以为这个闪烁效果得是行尾一个竖线|和空格交替重绘.客户区其他部位一直重绘.显然客户区重新打印一遍太耗时了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CreateCaret 建立与视窗有关的插入符号</span><br><span class="line">SetCaretPos 在视窗中设定插入符号的位置</span><br><span class="line">ShowCaret 显示插入符号</span><br><span class="line">HideCaret 隐藏插入符号</span><br><span class="line">DestroyCaret 撤消插入符号</span><br><span class="line">GetCaretPos 获取当前插入符号位置</span><br><span class="line">GetCaretBlinkTime 获取符号闪烁时间</span><br><span class="line">SetCaretBlinkTime 设置符号闪烁时间</span><br></pre></td></tr></table></figure>

<h3 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h3><p>插入符号的作用就是提示用户当前输入位置,显然这个正在被输入的窗口是焦点窗口</p>
<p>而一个窗口过程可能负责多个窗口的消息处理,那么插入符号的改变应该是窗口特定的,不应是窗口过程特定的</p>
<p>因此最好的处理时机是WM_SETFOCUS和WM_KILLFOCUS消息</p>
<p>在处理WM_SETFOCUS时调用CreateCaret,在处理WM_KILLFOCUS消息时调用DestoryCaret</p>
<p>创建插入符号之后并没有立刻输出到屏幕,需要再挑一个适当的时候调用ShowCaret显示它</p>
<p>在处理WM_PAINT时调用CreateCaret,在处理其他需要绘图的消息时调用HideCaret暂时隐藏插入符号.其他消息处理完成之后再调用CreateCaret重新显示插入符号</p>
<p>HideCaret的效果叠加,假设连续调用了10次HideCaret函数,那么就需要调用ShowCaret函数10次才可以把插入符号拽出来.</p>
<h2 id="baby-notepad"><a href="#baby-notepad" class="headerlink" title="baby notepad"></a>baby notepad</h2><p>“弟弟军训完了,非要给我露一手”</p>
<p>书上在这里给出了一个例子,一个婴儿版的文本编辑器</p>
<p>分析一下它的窗口过程WndProc函数</p>
<h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER(x,y) *(pBuffer + y * cxBuffer + x)</span></span><br></pre></td></tr></table></figure>

<p>本定义用于取缓冲区的第x行第y列这个字符.</p>
<p>实际上用了一个一维数组模拟二维数组,<code>BUFFER(x,y)</code>相当于<code>buffer[x][y]</code></p>
<h3 id="变量定义-1"><a href="#变量定义-1" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> DWORD dwCharSet = DEFAULT_CHARSET;<span class="comment">//字符集标志</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cxChar, cyChar, cxClient, cyClient, cxBuffer, cyBuffer,</span><br><span class="line">	xCaret, yCaret;</span><br><span class="line"><span class="type">static</span> TCHAR* pBuffer = <span class="literal">NULL</span>;</span><br><span class="line">HDC hdc;</span><br><span class="line"><span class="type">int</span> x, y, i;</span><br><span class="line">PAINTSTRUCT ps;</span><br><span class="line">TEXTMETRIC tm;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="字符集变换-窗口创建-尺寸变化消息"><a href="#字符集变换-窗口创建-尺寸变化消息" class="headerlink" title="字符集变换,窗口创建,尺寸变化消息"></a>字符集变换,窗口创建,尺寸变化消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">case</span> WM_INPUTLANGCHANGE:</span><br><span class="line">		dwCharSet = wParam;<span class="comment">//字符集,和输入法有关,默认是DEFAULT_CHARSET</span></span><br><span class="line">		<span class="comment">// fall through </span></span><br><span class="line">	<span class="keyword">case</span> WM_CREATE:</span><br><span class="line">		hdc = GetDC(hwnd);</span><br><span class="line">		SelectObject(hdc, CreateFont(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">			dwCharSet, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, FIXED_PITCH, <span class="literal">NULL</span>));</span><br><span class="line"><span class="comment">//输入法改变或者窗口创建时都需要重新设置字符集,字符集是字体的一部分</span></span><br><span class="line"></span><br><span class="line">		GetTextMetrics(hdc, &amp;tm);</span><br><span class="line">		cxChar = tm.tmAveCharWidth;<span class="comment">//获取字符宽度</span></span><br><span class="line">		cyChar = tm.tmHeight;<span class="comment">//字符高度</span></span><br><span class="line"></span><br><span class="line">		DeleteObject(SelectObject(hdc, GetStockObject(SYSTEM_FONT)));<span class="comment">//使用系统字体</span></span><br><span class="line">		ReleaseDC(hwnd, hdc);</span><br><span class="line">		<span class="comment">// fall through </span></span><br><span class="line">	<span class="keyword">case</span> WM_SIZE:</span><br><span class="line">		<span class="comment">// obtain window size in pixels </span></span><br><span class="line">		<span class="keyword">if</span> (message == WM_SIZE)</span><br><span class="line">		&#123;</span><br><span class="line">			cxClient = LOWORD(lParam);<span class="comment">//更新客户区尺寸记录</span></span><br><span class="line">			cyClient = HIWORD(lParam);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// calculate window size in characters </span></span><br><span class="line"></span><br><span class="line">		cxBuffer = max(<span class="number">1</span>, cxClient / cxChar);<span class="comment">//横向最多打印cxClient/cxChar列</span></span><br><span class="line">		cyBuffer = max(<span class="number">1</span>, cyClient / cyChar);<span class="comment">//纵向最多打印cyClient/cyChar行</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// allocate memory for buffer and clear it </span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pBuffer != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">free</span>(pBuffer);</span><br><span class="line">		pBuffer = (TCHAR*)<span class="built_in">malloc</span>(cxBuffer * cyBuffer * <span class="keyword">sizeof</span>(TCHAR));<span class="comment">//pBuffer为需要打印到屏幕的缓冲区,其大小按照cxBuffer*cyBuffer分配</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; cyBuffer; y++)</span><br><span class="line">			<span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; cxBuffer; x++)</span><br><span class="line">				BUFFER(x, y) = <span class="string">&#x27; &#x27;</span>;<span class="comment">//初始化buffer全为空格</span></span><br><span class="line">		<span class="comment">// set caret to upper left corner </span></span><br><span class="line">		xCaret = <span class="number">0</span>;<span class="comment">//初始插入字符位置(0,0)</span></span><br><span class="line">		yCaret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (hwnd == GetFocus())<span class="comment">//判断当前窗口是否为焦点窗口</span></span><br><span class="line">			SetCaretPos(xCaret * cxChar, yCaret * cyChar);<span class="comment">//如果是已经是焦点窗口了则设置当前插入字符位置</span></span><br><span class="line">		InvalidateRect(hwnd, <span class="literal">NULL</span>, TRUE);<span class="comment">//重绘整个客户区</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h3 id="获取焦点消息"><a href="#获取焦点消息" class="headerlink" title="获取焦点消息"></a>获取焦点消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SETFOCUS:</span><br><span class="line">	<span class="comment">// create and show the caret </span></span><br><span class="line">	CreateCaret(hwnd, <span class="literal">NULL</span>, cxChar, cyChar);<span class="comment">//当前窗口获取焦点,此时创建插入字符</span></span><br><span class="line">	SetCaretPos(xCaret * cxChar, yCaret * cyChar);<span class="comment">//设置好插入字符的位置,这个位置可以通过方向键等改变</span></span><br><span class="line">	ShowCaret(hwnd);<span class="comment">//显示插入字符</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h3 id="失去焦点消息"><a href="#失去焦点消息" class="headerlink" title="失去焦点消息"></a>失去焦点消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KILLFOCUS:</span><br><span class="line">	<span class="comment">// hide and destroy the caret </span></span><br><span class="line">	HideCaret(hwnd);<span class="comment">//失去焦点,隐藏插入符号</span></span><br><span class="line">	DestroyCaret();<span class="comment">//删除插入符号</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="键盘消息-1"><a href="#键盘消息-1" class="headerlink" title="键盘消息"></a>键盘消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">	<span class="keyword">switch</span> (wParam)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> VK_HOME:<span class="comment">//各种移动插入符号位置</span></span><br><span class="line">		xCaret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VK_END:</span><br><span class="line">		xCaret = cxBuffer - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VK_PRIOR:</span><br><span class="line">		yCaret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VK_NEXT:</span><br><span class="line">		yCaret = cyBuffer - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VK_LEFT:</span><br><span class="line">		xCaret = max(xCaret - <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//最左不能移出客户区</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VK_RIGHT:</span><br><span class="line">		xCaret = min(xCaret + <span class="number">1</span>, cxBuffer - <span class="number">1</span>);<span class="comment">//最右不能移出客户区</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VK_UP:</span><br><span class="line">		yCaret = max(yCaret - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VK_DOWN:</span><br><span class="line">		yCaret = min(yCaret + <span class="number">1</span>, cyBuffer - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VK_DELETE:<span class="comment">//退格键</span></span><br><span class="line">		<span class="keyword">for</span> (x = xCaret; x &lt; cxBuffer - <span class="number">1</span>; x++)<span class="comment">//退格键的作用是当前行当前位置之后的所有字符前移一个字符的宽度,删除当前字符</span></span><br><span class="line">			BUFFER(x, yCaret) = BUFFER(x + <span class="number">1</span>, yCaret);</span><br><span class="line"></span><br><span class="line">		BUFFER(cxBuffer - <span class="number">1</span>, yCaret) = <span class="string">&#x27; &#x27;</span>;<span class="comment">//退格前本行最后一个字符置空格</span></span><br><span class="line"></span><br><span class="line">		HideCaret(hwnd);<span class="comment">//临时隐藏插入字符,必须的操作,否则插入字符后面会拖着个黑框</span></span><br><span class="line">		hdc = GetDC(hwnd);</span><br><span class="line"></span><br><span class="line">		SelectObject(hdc, CreateFont(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">			dwCharSet, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, FIXED_PITCH, <span class="literal">NULL</span>));</span><br><span class="line">		TextOut(hdc, xCaret * cxChar, yCaret * cyChar,</span><br><span class="line">			&amp;BUFFER(xCaret, yCaret),</span><br><span class="line">			cxBuffer - xCaret);<span class="comment">//重新打印该行</span></span><br><span class="line">		DeleteObject(SelectObject(hdc, GetStockObject</span><br><span class="line">		(SYSTEM_FONT)));<span class="comment">//这句话写不写无所谓</span></span><br><span class="line">		ReleaseDC(hwnd, hdc);</span><br><span class="line">		ShowCaret(hwnd);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	SetCaretPos(xCaret * cxChar, yCaret * cyChar);<span class="comment">//设置插入字符的位置</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h3 id="字符消息-1"><a href="#字符消息-1" class="headerlink" title="字符消息"></a>字符消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CHAR:</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)LOWORD(lParam); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span> (wParam)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;\b&#x27;</span>: <span class="comment">// backspace </span></span><br><span class="line">			<span class="keyword">if</span> (xCaret &gt; <span class="number">0</span>)<span class="comment">//退格最多退到本行开始</span></span><br><span class="line">			&#123;</span><br><span class="line">				xCaret--;<span class="comment">//插入符号的位置左移</span></span><br><span class="line">				SendMessage(hwnd, WM_KEYDOWN, VK_DELETE,</span><br><span class="line">					<span class="number">1</span>);<span class="comment">//发生退格的时候要删除字符</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>: <span class="comment">// tab </span></span><br><span class="line">			<span class="keyword">do</span></span><br><span class="line">			&#123;</span><br><span class="line">				SendMessage(hwnd, WM_CHAR, <span class="string">&#x27; &#x27;</span>, <span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">while</span> (xCaret % <span class="number">8</span> != <span class="number">0</span>);<span class="comment">//右移直到xCaret位置8字符对齐</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>: <span class="comment">// line feed </span></span><br><span class="line">			<span class="keyword">if</span> (++yCaret == cyBuffer)<span class="comment">//回车后需要跳到下一行相同x位置</span></span><br><span class="line">				yCaret = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>: <span class="comment">// carriage return </span></span><br><span class="line">			xCaret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (++yCaret == cyBuffer)</span><br><span class="line">				yCaret = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;\x1B&#x27;</span>: <span class="comment">// escape ,清空缓冲区</span></span><br><span class="line">			<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; cyBuffer; y++)</span><br><span class="line">				<span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; cxBuffer; x++)</span><br><span class="line">					BUFFER(x, y) = <span class="string">&#x27; &#x27;</span>;<span class="comment">//遍历清空缓冲区</span></span><br><span class="line"></span><br><span class="line">			xCaret = <span class="number">0</span>;</span><br><span class="line">			yCaret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			InvalidateRect(hwnd, <span class="literal">NULL</span>, FALSE);<span class="comment">//清空缓冲区后立刻重绘</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>: <span class="comment">// character codes ,其他字符看作可打印字符,存入缓冲区</span></span><br><span class="line">			BUFFER(xCaret, yCaret) = (TCHAR)wParam;</span><br><span class="line"></span><br><span class="line">			HideCaret(hwnd);</span><br><span class="line">			hdc = GetDC(hwnd);</span><br><span class="line"></span><br><span class="line">			SelectObject(hdc, CreateFont(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">				dwCharSet, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, FIXED_PITCH, <span class="literal">NULL</span>));</span><br><span class="line">			TextOut(hdc, xCaret * cxChar, yCaret * cyChar,</span><br><span class="line">				&amp;BUFFER(xCaret, yCaret), <span class="number">1</span>);</span><br><span class="line">			DeleteObject(</span><br><span class="line">				SelectObject(hdc, GetStockObject(SYSTEM_FONT)));</span><br><span class="line">			ReleaseDC(hwnd, hdc);</span><br><span class="line">			ShowCaret(hwnd);</span><br><span class="line">			<span class="keyword">if</span> (++xCaret == cxBuffer)<span class="comment">//本行到头了,需要换行</span></span><br><span class="line">			&#123;</span><br><span class="line">				xCaret = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (++yCaret == cyBuffer)</span><br><span class="line">					yCaret = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SetCaretPos(xCaret * cxChar, yCaret * cyChar);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h3 id="绘图消息-1"><a href="#绘图消息-1" class="headerlink" title="绘图消息"></a>绘图消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">	hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line"></span><br><span class="line">	SelectObject(hdc, CreateFont(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">		dwCharSet, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, FIXED_PITCH, <span class="literal">NULL</span>));<span class="comment">//等宽字体,FIXED_PITCH等宽间距</span></span><br><span class="line">	<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; cyBuffer; y++)<span class="comment">//按行遍历,每次打印一整行</span></span><br><span class="line">		TextOut(hdc, <span class="number">0</span>, y * cyChar, &amp;BUFFER(<span class="number">0</span>, y), cxBuffer);</span><br><span class="line">	DeleteObject(SelectObject(hdc,GetStockObject(SYSTEM_FONT)));</span><br><span class="line">	EndPaint(hwnd, &amp;ps);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h3 id="窗口销毁消息-1"><a href="#窗口销毁消息-1" class="headerlink" title="窗口销毁消息"></a>窗口销毁消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">	PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>














      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/impossible/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/impossible/">1</a><span class="space">&hellip;</span><a class="page-number" href="/impossible/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/impossible/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/impossible/page/10/">10</a><a class="extend next" rel="next" href="/impossible/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
