<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","width":500,"display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="计算机网络-数据链路层 数据链路层 数据链路层的任务 数据链路层的功能:成帧,流量控制,差错控制,通信 成帧:多个数据帧之间如何区分?添加标志位,比如011111,如果接收方发现一个0后面连着5个1,就认为这和刚才接收到的数据不是一个帧的. 流量控制用于,限制发送方在等到确认之前发送的数据数量 差错控制指望重发,说官话就是&quot;自动重复请求&quot;(ARQ,Automatic Repeat R">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络-数据链路层">
<meta property="og:url" content="http://deutschball.github.io/2023/02/08/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="计算机网络-数据链路层 数据链路层 数据链路层的任务 数据链路层的功能:成帧,流量控制,差错控制,通信 成帧:多个数据帧之间如何区分?添加标志位,比如011111,如果接收方发现一个0后面连着5个1,就认为这和刚才接收到的数据不是一个帧的. 流量控制用于,限制发送方在等到确认之前发送的数据数量 差错控制指望重发,说官话就是&quot;自动重复请求&quot;(ARQ,Automatic Repeat R">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207151820663.png">
<meta property="og:image" content="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207211056989.png">
<meta property="og:image" content="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207163904317.png">
<meta property="article:published_time" content="2023-02-08T07:22:00.000Z">
<meta property="article:modified_time" content="2023-02-12T10:43:43.444Z">
<meta property="article:author" content="dustball">
<meta property="article:tag" content="计网">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207151820663.png">

<link rel="canonical" href="http://deutschball.github.io/2023/02/08/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>计算机网络-数据链路层 | dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2023/02/08/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络-数据链路层
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-08 15:22:00" itemprop="dateCreated datePublished" datetime="2023-02-08T15:22:00+08:00">2023-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-12 18:43:43" itemprop="dateModified" datetime="2023-02-12T18:43:43+08:00">2023-02-12</time>
              </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="计算机网络-数据链路层">计算机网络-数据链路层</h1>
<h2 id="数据链路层">数据链路层</h2>
<h3 id="数据链路层的任务">数据链路层的任务</h3>
<p>数据链路层的功能:成帧,流量控制,差错控制,通信</p>
<p>成帧:多个数据帧之间如何区分?添加标志位,比如011111,如果接收方发现一个0后面连着5个1,就认为这和刚才接收到的数据不是一个帧的.</p>
<p>流量控制用于,限制发送方在等到确认之前发送的数据数量</p>
<p>差错控制指望重发,说官话就是"自动重复请求"(ARQ,Automatic Repeat
Request)</p>
<h3 id="冗余编码">冗余编码</h3>
<p>冗余:Redundancy</p>
<p>冗余本是多余的意思,在计算机中,冗余量和业务逻辑无关,没有冗余照样执行业务</p>
<p>但是冗余可以增强非业务性能,比如信息论上的冗余可以提高发现错误和纠正错误的能力</p>
<blockquote>
<p>考虑8个工件有一个坏件,质量和其他的不同(具体重了还是清了不知道)</p>
<p>最快多少次找到?这实际上就是尽量减少冗余,尽最大可能利用信息熵的问题</p>
<p>采用二分需要单调性,即知道这个坏件轻了还是重了,现在不知道,没法二分</p>
<p>三分?3v3v2,还是那个问题,3v3不知道哪个是标准</p>
<p>四分?(2v2)v(2v2).其中必有一组2v2都是标准件,天平平衡</p>
<p>不妨设前一个2v2平等,说明坏件一定在后面的2v2中,并且前面四个都是标准件,可以用来参考</p>
<p>后面的2v2就不用称了,每个2直接和两个标准件比较</p>
<p>必然有一组不平衡,这就意味着另一组必定平衡,从不平衡组任意拿出一个,和标准件对比</p>
<p>如果是坏件则天平不平衡,否则如果是好件,则同组另一件必定坏件</p>
</blockquote>
<h4 id="块编码">块编码</h4>
<blockquote>
<p>数据字+冗余=码字</p>
<p>什么思想呢?</p>
<p>假如原来要传输一个比特,要么是0要么是1</p>
<p>但是路上可能发生各种变故导致1变成0.但是接收方不知道发生了变故,它认为人家就是发送的0,于是错误接收了0</p>
<p>为了增加检错能力</p>
<p>添加一位冗余,比如数据字为0,码字就为00.数据字为1,码字就为11</p>
<p>这样如果有一位发生突变(认为两位同突变的概率低),会形成01或者10这种无效码字,发现错误</p>
<p>那么问题又来了,如果接到01,怎么确定它是00还是11变来的?两者都只需要突变一位就能形成01,因而只添加一位冗余无法纠错</p>
<p>于是再添加一位冗余,只有000和111合法</p>
<p>那么接到100,认为它是000突变来的,这个概率要比他是从111突变来的大.</p>
<p>于是就有了纠错能力.</p>
</blockquote>
<p>实际上的块编码,是多位为一个数据字</p>
<p>整个报文划分为弱干块,每块k位,称为数据字</p>
<p>每块中假如r个冗余位,块长度变为n=k+r,形成这个n位的块叫做码字</p>
<p>码字有<span
class="math inline">\(2^n\)</span>种,但是其中实际承载数据字的只有<span
class="math inline">\(2^k\)</span>种</p>
<p>如果一个承载数据的码字,其中的一位或者几位发生突变,突变之后的码字:</p>
<p>如果如果不承载数据,则可以被检错</p>
<p>如果也是承载数据的码字,则无法检错</p>
<p>比如4B/5B编码(部分)中:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208093738919.png"
alt="image-20230208093738919" />
<figcaption aria-hidden="true">image-20230208093738919</figcaption>
</figure>
<p>如果0100的编码01010最后一位发生突变,编程了01011,这是0101的编码.那么错误就检查不出来了,接收方会认为发送方一开始就是发的0101</p>
<p>下面推导,检错能力和纠错能力的条件是什么</p>
<h5 id="汉明距离">汉明距离</h5>
<p>假设只有一位突变</p>
<p>如果两个有效码字只有一位不同,这样不具备检错能力</p>
<p>如果任何两个有效码字至少有两位不同.这样才具备检错能力,但是不具备纠错能力</p>
<p>如果任何两个有效码字至少有三位不同.这样才具备纠错一位的能力,也可以检错两位</p>
<p>定义两个长度相同的字x,y的汉明距离是对应位不同的数量,记作<span
class="math inline">\(d(x,y)\)</span> <span class="math display">\[
d(x,y)=x\oplus y 结果中1的数量
\]</span> 最小汉明距离:一组字所有对中最小的汉明距离</p>
<h5 id="编码方案">编码方案</h5>
<p>块编码方案记为<span class="math inline">\(C(n,k)\ with\
d_{min}=x\)</span></p>
<p>其中n是码字长度,k是数据字长度.<span
class="math inline">\(d_{min}\)</span>是<strong>有效</strong>码字的最小汉明距离</p>
<p>当可以检错<span class="math inline">\(s\)</span>个错误时,要求<span
class="math inline">\(d_{min}=s+1\)</span></p>
<p>当可以纠错<span class="math inline">\(s\)</span>个错误时,要求<span
class="math inline">\(d_{min}&gt; 2s\)</span>,也就是<span
class="math inline">\(d_{min}=2s+1\)</span></p>
<blockquote>
<p>因此最好采用奇数长度的码字</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208100459337.png"
alt="image-20230208100459337" />
<figcaption aria-hidden="true">image-20230208100459337</figcaption>
</figure>
<p>x和y两个有效码字,有相同的概率突变为同一个错误码字,因而无法纠错</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208101051053.png"
alt="image-20230208101051053" />
<figcaption aria-hidden="true">image-20230208101051053</figcaption>
</figure>
<p>x突变s位之后依然落在半径为s的圈里,而任意两个圈相离,也就是说一个错误码字一定有一个概率最大的突变来源.</p>
<p>这就有了纠错能力</p>
<h4 id="线性块编码">线性块编码</h4>
<p>线性块编码:任何两个有效码字的异或生成另一个有效码字.比如:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208101612648.png"
alt="image-20230208101612648" />
<figcaption aria-hidden="true">image-20230208101612648</figcaption>
</figure>
<h5 id="最小汉明距离">最小汉明距离</h5>
<p>线性快编码的最小汉明距离:1的个数最少的非零有效码字中的1的个数</p>
<p>还是以上图为例</p>
<table>
<thead>
<tr>
<th>非零码字</th>
<th>1的个数</th>
</tr>
</thead>
<tbody>
<tr>
<td>01011</td>
<td>3</td>
</tr>
<tr>
<td>10101</td>
<td>3</td>
</tr>
<tr>
<td>11110</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>因此<span class="math inline">\(d_{min}=3\)</span></p>
<h5 id="简单奇偶校验编码">简单奇偶校验编码</h5>
<p><span class="math inline">\(n=k+1,d_{min}=2\)</span></p>
<p>只有一位校验位</p>
<p>比如<span class="math inline">\(C(5,4)\)</span></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208102201761.png"
alt="image-20230208102201761" />
<figcaption aria-hidden="true">image-20230208102201761</figcaption>
</figure>
<p>突变奇数位可以被检查出</p>
<p>突变偶数位不可以</p>
<h5 id="二维奇偶校验">二维奇偶校验</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208102627543.png"
alt="image-20230208102627543" />
<figcaption aria-hidden="true">image-20230208102627543</figcaption>
</figure>
<p>两维奇偶校验能检测出所有3位或3位以下的错误（因为此时至少在某一行或某一列上有一位错）、奇数位错以及很大一部分偶数位错。</p>
<h4 id="汉明编码">汉明编码</h4>
<p>对于汉明编码<span
class="math inline">\(C(n,k),d_{min}=3\)</span>,有如下关系: <span
class="math display">\[
\begin{cases}
n=2^m-1\\
k=n-m\\
r=m
\end{cases}
\]</span> 比如<span class="math inline">\(C(7,4)\)</span>中,<span
class="math inline">\(n=7=2^m-1\)</span>得到m=3</p>
<p><span class="math inline">\(k=n-m=7-3=4\)</span>即数据字位数</p>
<p><span class="math inline">\(r=m=3\)</span>即冗余位数</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208103155013.png"
alt="image-20230208103155013" />
<figcaption aria-hidden="true">image-20230208103155013</figcaption>
</figure>
<p>如何检错?</p>
比如数据字0111,计算冗余校验位: $$
<span class="math display">\[\begin{cases}
r_0=a_2+a_1+a_0=1+1+1=1\\
r_1=a_3+a_2+a_1=0+1+1=0\\
r_2=a_1+a_0+a_3=1+1+0=0

\end{cases}\]</span>
<p>$$ 得到码字<span class="math inline">\(0111001\)</span></p>
<p>如果码字没有错误,那么接收方计算得到的q2q1q0应该全零</p>
<p>如果码字有一位出现错误,变成<span
class="math inline">\(0110001\)</span></p>
<p>在接收方(接收方认为顶多有一位发生错误): <span class="math display">\[
q_0=b_2+b_1+b_0+q_0=1+1+0+1=1
\]</span>
此时已经发现错误了,但是不能确认是b2,b1,b0,q0这四位中的哪一位出现的差错</p>
<p>然后又算得 <span class="math display">\[
q_1=b_3+b_2+b_1+q_1=0+1+1+0=0
\]</span> 说明b3b2b1q1都没错误,那么只有b0,q0中有错误</p>
<p>然后又算得 <span class="math display">\[
q_2=b_1+b_0+b_3+q_2=1+0+0+0=1
\]</span> 可以肯定是<span class="math inline">\(b_0\)</span>的错误了</p>
<blockquote>
<p>如果数据字至少是7位,计算满足一位检错条件的汉明编码方案 <span
class="math display">\[
\begin{cases}
n=2^m-1\\
k=n-m\\
r=m
\end{cases}
\]</span></p>
<p><span class="math display">\[
k=n-m=2^m-1-m\ge7
\]</span></p>
<p>解得</p>
<p><span class="math inline">\(m=4,n=15,k=11\)</span></p>
<p>因此满足条件的编码方案是<span
class="math inline">\(C(15,11)\)</span></p>
</blockquote>
<h4 id="循环冗余编码">循环冗余编码</h4>
<p>Cyclic Redundancy Check,CRC</p>
<p><span class="math inline">\(C(n,k)\)</span></p>
<p>n位的码字,其中k位数据字,最右边加上n-k个0作为校正子的初始值,这样n位传递给生成器</p>
<p>生成器用长度n-k+1的除数去除码字</p>
<p>得到n-k位余数,填到校正子上</p>
<p>真码字(数据字:校正子)就计算完毕了,然后传输,然后被接收</p>
<p>接收方校验器用相同除数除码字</p>
<p>如果得到n-k位余数是0则无误,码字前k位就是数据字</p>
<p>否则丢弃</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208110416498.png"
alt="image-20230208110416498" />
<figcaption aria-hidden="true">image-20230208110416498</figcaption>
</figure>
<p>计算过程</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208111036131.png"
alt="image-20230208111036131" />
<figcaption aria-hidden="true">image-20230208111036131</figcaption>
</figure>
<h5 id="多项式">多项式</h5>
<p>CRC的除数称为生成多项式,简称生成子或者生成器<span
class="math inline">\(g(x)\)</span></p>
<p>码字<span
class="math inline">\(c(x)=d(x):s(x)\)</span>,码字就是数据字和校正子的增广</p>
<p>差错<span class="math inline">\(e(x)\)</span></p>
<p>校验原理:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230208111438640.png"
alt="image-20230208111438640" />
<figcaption aria-hidden="true">image-20230208111438640</figcaption>
</figure>
<p>在发送端计算完的真码字一定满足<span
class="math inline">\(\frac{c(x)}{g(x)}=0\)</span></p>
<p>因此对接收方的码字除以<span
class="math inline">\(g(x)\)</span>,如果不为零,说明一定存在<span
class="math inline">\(\frac{e(x)}{g(x)}\)</span>这一项,也就是说分子不为零,即存在<span
class="math inline">\(e(x)\)</span>这一项,即存在差错</p>
<p>生成多项式的形式决定了检错能力</p>
<h5 id="单个位差错">单个位差错</h5>
<p>单个位差错是指<span class="math inline">\(e(x)=x^i\)</span>的情形</p>
<p>检测单个位差错需要保证<span
class="math inline">\(e(x)\)</span>不能被<span
class="math inline">\(g(x)\)</span>整除</p>
<p>比如如果设置<span
class="math inline">\(g(x)=1\)</span>,则任何多项式都被<span
class="math inline">\(g(x)\)</span>整除,这就查不出任何错误来</p>
<p>如果生成多项式至少有两项,并且有1这一项(也就是<span
class="math inline">\(x^0\)</span>这一项),那么所有单比特错误都可以检出</p>
<p><strong>也就是说,<span
class="math inline">\(g(x)\)</span>的作用是,出现差错时,<span
class="math inline">\(e(x)\)</span>无法被<span
class="math inline">\(g(x)\)</span>整除</strong></p>
<h5 id="两独立位差错">两独立位差错</h5>
<p>两独立位差错指<span class="math inline">\(e(x)=x^i+x^j\)</span>的情形
<span class="math display">\[
e(x)=x^i+x^j=x^i(x^{j-i}+1)=x^i(x^t+1)
\]</span> 如果生成多项式<span
class="math inline">\(g(x)\)</span>无法整除<span
class="math inline">\(x^t+1\)</span>则所有独立两位错误都可以检查出来</p>
<p>比如<span
class="math inline">\(x+1\)</span>不能检查出两个相邻位的错误</p>
<p><span
class="math inline">\(x^4+1\)</span>无法检查出两个相隔4位的错误</p>
<p><span
class="math inline">\(x^3+x^2+1\)</span>就可以检查所有两个独立位错误</p>
<h5 id="奇数个位差错">奇数个位差错</h5>
<p>奇数个位错误指: <span class="math display">\[
e(x)=x^{i1}+x^{i2}+...+x^{ik}
\]</span> 其中k是奇数</p>
<p>只要是<span class="math inline">\(g(x)\)</span>包含<span
class="math inline">\(x+1\)</span>因式,就可以检查出<span
class="math inline">\(e(x)\)</span>,证明:</p>
<p>假设检查不出来,即<span class="math inline">\(g(x)|e(x)\)</span> <span
class="math display">\[
g(x)|e(x),x+1|g(x)\rightarrow x+1|e(x)
\]</span> 只需要证明<span
class="math inline">\(x+1|e(x)\)</span>不能成立</p>
<p>如果任何一个偶数项多项式都可以被<span
class="math inline">\(x+1\)</span>整除,那么任何奇数项多项式,就可以拆成一个偶数项多项式加一个单独的多项式.那么问题转化为单个比特错误</p>
<p>于是只需要证明任何偶数项多项式可以被<span
class="math inline">\(x+1\)</span>整除</p>
<p>由于任何偶数项多项式,都可以转化为若干个这种形式的和 <span
class="math display">\[
x^a(x^t+1)
\]</span></p>
<p>由于多项式系数在<strong>模2域上,</strong>因此上式又可以写为 <span
class="math display">\[
x^n(1-x+x^2-x^3+...)=x^n\frac{1-(-x)^t}{1-(-x)}
\]</span> 当t是奇数时由上式得到 <span class="math display">\[
x^t+1=(x+1)(x^{t-1}-x^{t-2}+x^{t-3}-...)
\]</span> 当t不是奇数,是偶数比如<span
class="math inline">\(e(x)=x^2+1\)</span>,此时t=2是偶数</p>
<p>这就可以利用系数在模2域上的性质了</p>
<p>此时<span
class="math inline">\(e(x)=x^2+1=x^2+2x+1=(x+1)^2\)</span></p>
<p>推广一下,可以得到<span
class="math inline">\(x^t+1=(x+1)^t\)</span>其中t是偶数,并且系数在模2域上</p>
<p>这就证明了<span
class="math inline">\(x+1\)</span>整除任何偶数项多项式</p>
<h5 id="突发性错误">突发性错误</h5>
<p>突发恶疾指接连几个bit位都可能发生错误 <span class="math display">\[
e(x)=x^j+...x^i=x^j(1+...+x^{i-j})
\]</span> 令<span
class="math inline">\(e&#39;(x)=1+...+x^{i-j}\)</span></p>
<p>意思时,起码两头的i,j两位是有错误的,中间的位可能有错误也可能无误,但是无所谓</p>
<p>设<span
class="math inline">\(L=i-j+1\)</span>,意思是突发性错误的长度</p>
<p>这L位中,提出公因式<span
class="math inline">\(x^j\)</span>之后,最低次项是1,最高次项是<span
class="math inline">\(x^{i-j}\)</span>,这两项肯定得有</p>
<p>设<span
class="math inline">\(g(x)=x^r+...+1\)</span>表示生成多项式,它至少包含<span
class="math inline">\(x^r+1\)</span>两项,这保证了可以检测任何单比特错误.其他比r低次的项可有可无.</p>
<p><strong>如果<span class="math inline">\(g(x)\)</span>阶比<span
class="math inline">\(e&#39;(x)\)</span>大</strong>,即r&gt;L-1,显然<span
class="math inline">\(\frac{e&#39;(x)}{g(x)}\)</span>是有余数的,此时任何差错都可以检查出来</p>
<p><strong>如果<span class="math inline">\(g(x)\)</span>和<span
class="math inline">\(e&#39;(x)\)</span>同阶</strong>,即r=L-1,</p>
<p>此时只有<span
class="math inline">\(e&#39;(x)=g(x)\)</span>只有这种情况没有余数,这个概率是多大呢?</p>
<p>要求<span class="math inline">\(g(x)\)</span>和<span
class="math inline">\(e&#39;(x)\)</span>的每一项系数都相同,根据概率论独立事件乘法原则,这个概率是
<span class="math display">\[
P(g(x)=e&#39;(x))=(\frac{1}{2})^{L-2}=(\frac{1}{2})^{r-1}
\]</span></p>
<blockquote>
<p>这里L-2的原因是,<span
class="math inline">\(g(x),e&#39;(x)\)</span>最高次项和常数项1都已经是相同的了,只需要考虑中间各项的情况</p>
</blockquote>
<p>因此r=L-1时,能够检查出错误的概率是<span
class="math inline">\(1-(\frac{1}{2})^{r-1}\)</span></p>
<p><strong>如果<span class="math inline">\(g(x)\)</span>比<span
class="math inline">\(e&#39;(x)\)</span>阶小</strong>,即L&gt;r+1时,考虑啥情况检查不出错误?</p>
<p>比如<span class="math inline">\(e(x)=x^6+x^5+x+1\)</span>,<span
class="math inline">\(g(x)=x^5+1\)</span></p>
<p>此时<span
class="math inline">\(\frac{e(x)}{g(x)}=x+1\)</span>可以被整除,无法检查出错误</p>
<p>考虑对于任意一个<span
class="math inline">\(g(x)\)</span>,只要是其阶比<span
class="math inline">\(e&#39;(x)\)</span>小,一定存在<span
class="math inline">\(e&#39;(x)\)</span>,使得<span
class="math inline">\(g(x)|e&#39;(x)\)</span>吗?</p>
<p>确实如此,只需要构造<span
class="math inline">\(e&#39;(x)=x^{L-1-r}g(x)+g(x)=(x^{L-1-r}+1)g(x)\)</span></p>
<p>这是一个临界条件,保证了阶是L-1并且存在常数项1</p>
<p>还可以往里随便加<span
class="math inline">\(x^kg(x),k\in(0,L-1-r)\)</span>项</p>
<p>这样满足条件的构造共有<span
class="math inline">\(2^{L-2-r}\)</span>种</p>
<p>而L-1阶含常数项1的多项式共有<span
class="math inline">\(2^{L-2}\)</span>个</p>
<p>因此构造的出现概率就是<span
class="math inline">\(\frac{2^{L-2-r}}{2^{L-2}}=(\frac{1}{2})^r\)</span>,也就是检不出错误的概率</p>
<p>那么能够检查出错误的概率就是<span
class="math inline">\(1-(\frac{1}{2})^r\)</span></p>
<p>总结:</p>
<p>所有$L ≤ r $的突发性差错均可被检测到。</p>
<p>所有$L = r + 1 $的突发性差错有$1 – (1/2)r–1 $的概率被检测到。</p>
<p>所有$L &gt; r + 1 $的突发性差错有$1 – (1/2)r $ 的概率被检测到。</p>
<h5 id="高性能多项式特性">高性能多项式特性</h5>
<ol type="1">
<li>至少有两项,要有常数项1,保证检查一位错误</li>
<li>不能整除 <span class="math inline">\(x^t + 1(2 ≤ t ≤ n −
1)\)</span>,保证检查两个独立位错误</li>
<li>应当有因子 <span class="math inline">\(x +
1\)</span>,保证检查所有奇数位数错误</li>
</ol>
<h4 id="校验和">校验和</h4>
<p>脚丫子都知道怎么算,注意结果要取反</p>
<h3 id="数据链路层协议">数据链路层协议:</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230204191849501.png"
alt="image-20230204191849501" />
<figcaption aria-hidden="true">image-20230204191849501</figcaption>
</figure>
<p>只要带上ARQ的肯定有差错控制功能</p>
<p>noiseless
channel是没有噪声,不会丢包,不会重复,无损坏帧的理想信道,最简单协议和停止等待协议只是最初的一厢情愿</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 42%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr>
<th>协议</th>
<th>特点</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>simplest</td>
<td>纯纯理想环境,<br />发送方不需要考虑丢包坏帧的情况,要说啥只说一遍,不多废话<br />接收方就洗耳恭听,也不需要回复收到</td>
<td></td>
</tr>
<tr>
<td>stop-and-wait</td>
<td>发送方发<strong>一个</strong>帧,就等着接收方回复收到<br />如果没有收到回复,那么可能是网络阻塞或者接收方死球了<br />长时间没有收到回复就认为超时了,重发该帧<br />啥时候收到回复确认,啥时候发下一帧</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Stop-and-wait ARQ</td>
<td>停等ARQ协议中,每个帧要么编号1要么编号0(原序号模2得到)<br />如果收到0号帧,则下一个期望的就是1号帧<br />如果接收方接收到的帧不是期望帧,回复自己期望的那一帧<br />已发送的帧会被保留副本,如果超时没有收到该帧的确认(或者说下一帧的期待)<br />则重发超时帧</td>
<td><img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230204193901028.png"
alt="image-20230204193901028" /></td>
</tr>
<tr>
<td>Go-Back-N ARQ</td>
<td>实际上是Stop-and-wait ARQ的增强版<br />Stop-and-wait
ARQ协议中没发一个包都要确认一下<br />现在可以<strong>发一组</strong>包然后确认一下<br />让确认这种控制信息比重更少</td>
<td></td>
</tr>
<tr>
<td>Selective Repeat ARQ</td>
<td>Go-Back-N ARQ的增强版<br />Go-Back-N
ARQ中接收方窗口为1,<br />本算法中将接收方窗口增强到和发送方窗口一样大<br />但是窗口大小更小了,为<span
class="math inline">\(2^{m-1}\)</span><br />(Go-Back-N
ARQ中发送方窗口是<span class="math inline">\(2^m-1\)</span>)</td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="回退n帧自动重发请求">回退N帧自动重发请求</h5>
<p>Go-Back-N Automatic Repeat Request</p>
<p>在帧头部设置一个帧序号字段,假设这个字段使用m位,那么可以编号<span
class="math inline">\([0,2^m)\)</span>,即帧序号是模<span
class="math inline">\(2^m\)</span>的</p>
<p>发送窗口:</p>
<p>发送方的发送窗口大小就设置为<span
class="math inline">\(S_{size}=2^m-1\)</span>,</p>
<blockquote>
<p>为什么要设置成这个值呢?为什么不设置成<span
class="math inline">\(2^m\)</span>?留作后话</p>
</blockquote>
<p>比如帧序号字段占用4bit,那么发送方滑动窗口大小就是16-1=15</p>
<p>两个指针,</p>
<p>其中<span
class="math inline">\(S_f\)</span>永远指向最早没有被确认的窗口</p>
<p><span
class="math inline">\(S_n\)</span>指向当前发送方应该发送的窗口位置</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230204195038189.png"
alt="发送窗口" />
<figcaption aria-hidden="true">发送窗口</figcaption>
</figure>
<p>接收窗口:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230204195932727.png"
alt="image-20230204195932727" />
<figcaption aria-hidden="true">image-20230204195932727</figcaption>
</figure>
<p>接收方只需要一个指针即可,只需要记录下一个期待接收的窗口</p>
<p><strong>两个窗口如何交互?</strong></p>
<p>假设发送方连续发了0到14帧,这几个帧是陆续到达的,接收方收到第n帧就会回复期待n+1帧.也可能一股脑收到了n,n+1,n+2这三帧,此时接收方直接回复一个累计确认,期望第n+3帧</p>
<p>考虑有丢包,可能接收方对0到5帧的确认都丢了,但是对第6帧的确认没丢,被发送方收到了,这时发送方Sf指针直接移动到第7帧,也就是发送方窗口右移,此时发送方就可以继续发送第15,16,17等等帧了</p>
<p>也可能发送方第0帧就在路上丢包了,第1,2,等等帧都到了,但是接收方不要,就要第一帧,于是接收方直接丢弃并保持沉默,</p>
<p>发送方发现从第0帧往后,一直长时间没有收到回应,就要从第0帧这里开始重发0到14帧</p>
<p><strong>发送方滑动窗口大小设为<span
class="math inline">\(2^m-1\)</span></strong>的目的</p>
<blockquote>
<p>假设m=4,即帧的编号<span class="math inline">\(\in[0,15]\)</span></p>
<p>并且假设滑动窗口大小大于等于<span
class="math inline">\(2^m=16\)</span>,不妨就设置为16</p>
<p>好,现在一个大文件成帧之后</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0 1 2 3 4 5 6 7 8 9 10 11 12 13
14 15...</p>
<p>滑动窗口要是16就会包含[0,15],假设发送方这16帧全都发出去了,但是网络太垃圾了,没有收到任何回复,而接收方实际上全都回复了,并且接收方已经准备接收下一个0号帧了</p>
<p>此时发送方认为接收方本次[0,15]全都没有收到,于是从0开始重发,但是接收方期望的是下一个0号帧</p>
<p>但是两个帧都是编号0,接收方无法发现错误,于是就错误地接受了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230204201039834.png"
alt="image-20230204201039834" />
<figcaption aria-hidden="true">image-20230204201039834</figcaption>
</figure>
</blockquote>
<h5 id="选择性重传">选择性重传</h5>
<p>在回退N帧自动重发中只有发送方会累计确认</p>
<p>在选择性重传中,发送方和接收方都会累计确认</p>
<p>解决了啥问题呢?</p>
<p>发送方如果发送了<span
class="math inline">\([0,14]\)</span>这些帧,接收方可能就得发送15个确认回复,回复太多这是其一</p>
<p>其二是,如果发送方已经接到了[1,14],唯独0号帧路上丢包了,在回退N帧自动重发中,发送方就得从0开始重发[0,14]</p>
<p>而实际上只需要重发一个0就足够了,但是接收方脑子太小了,只认一个数,[1,14]已经忘记了.</p>
<p>于是就改进成<strong>选择性重传算法</strong></p>
<p>接收方加上了窗口,就有了缓存的能力</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206220446089.png"
alt="image-20230206220446089" />
<figcaption aria-hidden="true">image-20230206220446089</figcaption>
</figure>
<p>关键注意1号帧在发送途中丢包,但是2号帧顺利抵达,此时接收方回复NAK1,意思是期望1.然而在发送方针对NAK1的回应到达之前,3号帧也顺利抵达了,此时接收方默默收下,但是啥回复都没有</p>
<p>然后发送方的针对NAK1的回复1号帧到了,</p>
<p>此时接收方回复的是ACK4,通知发送方,3之前已经都接收到了,可以发送4及之后的帧了,</p>
<p>发送方接收到ACK4之后会调整自己的发送窗口,然后继续发送4,5,...号帧</p>
<p><strong>为啥发送方和接收方的窗口都得是<span
class="math inline">\(2^{m-1}\)</span></strong>呢?</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230204204344648.png"
alt="image-20230204204344648" />
<figcaption aria-hidden="true">image-20230204204344648</figcaption>
</figure>
<p>假设m=2,那么帧编号就是<span
class="math inline">\([0,3]\)</span>此时窗口大小最大为2,否则,假设是3</p>
<p>发送方发送0,1,2三帧之后,都被接收方收到,但是所有回复都丢包了</p>
<p>此时接收方已经后移了接收窗口,此时接收方窗口内的期待0号帧是下一个0号帧.</p>
<p>但是发送方超时重发了刚才的0号帧</p>
<p>于是接收方就把刚才的0号帧当成下一个0号帧错误接收了</p>
<h5 id="带捎带的n步返回nrq">带捎带的N步返回NRQ</h5>
<p>捎带:将控制报文,比如NAK,ACK等等,附带到数据报文中一起发送</p>
<h4 id="带宽利用率">带宽利用率</h4>
<p>首先计算整个链路充满数据,能放开多少数据,也就是带宽时延积</p>
<p>然后使用的协议在传播时间内最多能有多少帧,多少bit上到信道上传输</p>
<p>做比即可</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206221303181.png"
alt="image-20230206221303181" />
<figcaption aria-hidden="true">image-20230206221303181</figcaption>
</figure>
<h3 id="多路访问">多路访问</h3>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230206222507328.png"
alt="image-20230206222507328" />
<figcaption aria-hidden="true">image-20230206222507328</figcaption>
</figure>
<h4 id="随机访问协议">随机访问协议</h4>
<p>所有站点低位相同,任何站点都不能组织其他站点说话</p>
<p>有话要说就根据自己的协议说</p>
<h5 id="aloha">AlOHA</h5>
<p>任何站点,在任何时间,想说啥就说啥</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207093146683.png"
alt="image-20230207093146683" />
<figcaption aria-hidden="true">image-20230207093146683</figcaption>
</figure>
<p>只要同一时间在信道上有两个帧,就会造成冲突,发生冲突的帧都会废掉</p>
<p>ALOHA协议流程:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207093619308.png"
alt="image-20230207093619308" />
<figcaption aria-hidden="true">image-20230207093619308</figcaption>
</figure>
<p>最多重发<span
class="math inline">\(K_{max}\)</span>次,如果一直没有收到ACK回复则放弃</p>
<p>每次发送之后等待<span class="math inline">\(2\times
T_{p}\)</span>,这是接收ACK的窗口期</p>
<p>如果没有收到,则等待一个随机数的时间<span class="math inline">\(T_{B}=
T_{p}\times R,r\in[0,2^k)\)</span>.然后再重发</p>
<h6 id="传输和传播">传输和传播</h6>
<p>传输,transmission,又可以翻译为发射,是发送方将信号全放到信道上用的时间
<span class="math display">\[
传输时间=\frac{帧长}{带宽}
\]</span></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207093935960.png"
alt="image-20230207093935960" />
<figcaption aria-hidden="true">image-20230207093935960</figcaption>
</figure>
<p>传播,propagation,信号的一位经过信道用时 <span class="math display">\[
传播时间=\frac{电缆长度}{信号速度(一般是光速)}
\]</span></p>
<h6 id="冲突时间">冲突时间:</h6>
<p>假设各帧长度相同,ALOHA的冲突时间是传输时间的两倍</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207094413864.png"
alt="image-20230207094413864" />
<figcaption aria-hidden="true">image-20230207094413864</figcaption>
</figure>
<p>即在<span
class="math inline">\([t-T_{fr},t+T_{fr}]\)</span>这期间,不允许有第二个帧</p>
<h6 id="吞吐量">吞吐量</h6>
<p><span class="math display">\[
S=G\times e^{-2G}
\]</span></p>
<p>单位:帧</p>
<blockquote>
<p>注意这里的吞吐量单位不是bps</p>
</blockquote>
<p>当且仅当<span class="math inline">\(G=\frac{1}{2}\)</span>,<span
class="math inline">\(S_{max}=0.184\)</span></p>
<p>G是帧传输时间内系统平均产生帧的数量</p>
<p>对于<span
class="math inline">\(G=\frac{1}{2}\)</span>也好立即,因为冲突时间就是两个帧传输时间,如果整个系统在一个传输时间内产生的帧数均值是<span
class="math inline">\(G=\frac{1}{2}\)</span>,则冲突事件内产生的帧数均值就是1</p>
<p>如果<span
class="math inline">\(G&gt;\frac{1}{2}\)</span>则冲突的概率增大,一旦发生冲突,两个帧都是废物</p>
<p>而吞吐量的定义是:单位时间内<strong>成功</strong>传送的数据量.</p>
<p>两个废物帧都不是成功传送,因此导致了吞吐量降低</p>
<blockquote>
<p>推导<span class="math inline">\(S=G\times e^{-2G}\)</span></p>
<p>假设传输时间是T,当一个帧发射之后,在T时间内,系统中又发送帧数均值是G</p>
<p>也就是说,T时间内系统又发送一帧的概率为<span
class="math inline">\(G\)</span></p>
<p>首先考虑吞吐量怎么计算</p>
<p>定义吞吐量:传输时间内,能够成功传输的帧数,则有: <span
class="math display">\[
S=GP_0
\]</span> 其中<span
class="math inline">\(P_0\)</span>为一帧发送成功的概率,也就是冲突时间内没有第二个帧的概率.</p>
<p><span
class="math inline">\(G\)</span>是T时间内系统发送帧数的<strong>均值</strong></p>
<p><span class="math inline">\(P_0\)</span>是成功率</p>
<p>那么<span
class="math inline">\(S=GP_0\)</span>就计算了T时间内发送成功的帧数的<strong>均值</strong></p>
<p>下面考虑<span class="math inline">\(P_0\)</span>怎么算</p>
<p>计算一帧成功传输的概率,也就是发送一帧之后2T时间内没有其他帧的概率</p>
<p>假设T时间内有其他X个帧发射.显然<span class="math inline">\(X\sim
P(G)\)</span>泊松分布,则分布律为 <span class="math display">\[
P(X=k)=\frac{G ^k}{k!}e^{-G}
\]</span></p>
<p>在2T时间即冲突时间内,不发生冲突,意味着没有其他帧发送,其概率是 <span
class="math display">\[
P(X=0)\times P(X=0)=(\frac{G^0}{0!}e^{-G})^2=e^{-2G}
\]</span></p>
<p>带入<span class="math inline">\(P_0=P(X=0)\times
P(X=0)=e^{-2G}\)</span>得到 <span class="math display">\[
S=GP_0=Ge^{-2G}
\]</span></p>
<p>如果定义吞吐量为:传输时间内成功传输的帧数.那么算到这里就结束了</p>
<p>如果定义吞吐量为:单位时间内成功传输的帧数.那么<span
class="math inline">\(S=\frac{G{e^{-2G}}}{T}\)</span></p>
<p>如果定义吞吐量为:单位时间内成功传输的bit数.那么<span
class="math inline">\(S=\frac{G{e^{-2G}}}{T}\times 帧大小\)</span></p>
</blockquote>
<h5 id="时隙aloha">时隙ALOHA</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207102708453.png"
alt="image-20230207102708453" />
<figcaption aria-hidden="true">image-20230207102708453</figcaption>
</figure>
<p>规定只能在每个Slotn一开始发送,每个帧顶多占用一个Slot,不会影响其他Slot</p>
<p>那么冲突只会发生在一个Slot之内,并且一旦发生冲突,一定是两个帧在时间上完全重合</p>
<h6 id="吞吐量-1">吞吐量</h6>
<p>假设每个Slot开始时,系统中传输帧的均值为G帧,则Slot时间内又发送的帧数还是满足泊松分布</p>
<p>只不过冲突时间降为一个Slot,成功发送一帧的概率变为 <span
class="math display">\[
P_0=P(X=0)=e^{-G}
\]</span> 吞吐量就是<span
class="math inline">\(S=GP_0=Ge^{-G}\)</span></p>
<h5 id="csma">CSMA</h5>
<p>Carrier Sense Multiple Access</p>
<p>载波侦听 多路访问</p>
<p>发送前首先侦听,看看有没有其他帧在发送,可以缓解冲突,但是不能解决冲突</p>
<p>因为一个站点侦听时,可能另一个站点已经传输了信号,但是由于<strong>传播</strong>延迟,没有被本站点侦听到,如图所示:</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207103600938.png"
alt="image-20230207103600938" />
<figcaption aria-hidden="true">image-20230207103600938</figcaption>
</figure>
<p>B站点在t1时刻传输一个信号,C在t2时刻要发送一个信号,但是t2时刻信号尚未传播到C处,因此C在t2传输一个信号,就会和B传输的信号发生冲突</p>
<h6 id="冲突时间-1">冲突时间</h6>
<p>在B开始传输消息,到消息传播到其他站点之前,这段时间是不能有第二个消息传播的</p>
<p>因此冲突时间就等于传播时间</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207104138197.png"
alt="image-20230207104138197" />
<figcaption aria-hidden="true">image-20230207104138197</figcaption>
</figure>
<h6 id="冲突缓解方法">冲突缓解方法</h6>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207104446245.png"
alt="image-20230207104446245" />
<figcaption aria-hidden="true">image-20230207104446245</figcaption>
</figure>
<h5 id="csmacd">CSMA/CD</h5>
<p>Carrier Sense Multiple Access with Collision
Detection,带冲突检测的载波侦听多路访问</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207105245273.png"
alt="image-20230207105245273" />
<figcaption aria-hidden="true">image-20230207105245273</figcaption>
</figure>
<p>之前CSMA协议中,一个站点只会在发送前进行检查,如果信道空闲就发送</p>
<p>现在CSMA/CD在CSMA的基础上,一个站点会在发送时同时检查,如果侦测到信道中有其他信号,立刻终止发送</p>
<p>因为起码顺着该信号的传播方向上,如果再发送信号肯定是冲突了,那就不如立刻闭嘴不发了</p>
<h6 id="冲突检测时间">冲突检测时间</h6>
<p>首先考虑如图所示情况</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207110344621.png"
alt="image-20230207110344621" />
<figcaption aria-hidden="true">image-20230207110344621</figcaption>
</figure>
<p>如果传输时间很短但是传播延迟很长,可能就存在双方均检测不到冲突或者只有一方能够检测到冲突的情形</p>
<p>此时冲突废帧会被错误交付</p>
<p>为了避免这种情况,就需要传输时间和传播时间有约束关系</p>
<p>直接考虑距离最远的两个站点A,B的情况即可</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207111015408.png"
alt="image-20230207111015408" />
<figcaption aria-hidden="true">image-20230207111015408</figcaption>
</figure>
<p>如果B在A的信号马上就要发到时才开始发送,直到B的信号被A侦听到时,A必须仍在发送</p>
<p>也就是说<strong>最小传输时间应为最大传播时间的两倍</strong>,如下图</p>
<blockquote>
<p>因为A,B是两个距离最远的站点,因此是最大传播时间</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207111728369.png"
alt="image-20230207111728369" />
<figcaption aria-hidden="true">image-20230207111728369</figcaption>
</figure>
<blockquote>
<p>CSMA/CD网络中，带宽10Mbps，最大传播时间为25.6us，那么最小帧长度是多少？</p>
<p>假设帧长是x,则传输时间是<span
class="math inline">\(T_{fr}=\frac{x}{10M}\)</span></p>
<p>由<span class="math inline">\(T_{fr}\ge 2T_p\)</span>得到 <span
class="math display">\[
\frac{x}{10\times 10^6}\ge 25.6\times 10^{-6}\times 2
\]</span> 即<span class="math inline">\(x\ge 512bit\)</span></p>
<p>因此帧长最小为512比特</p>
</blockquote>
<h6 id="csmacd算法流程">CSMA/CD算法流程</h6>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207112317356.png"
alt="image-20230207112317356" />
<figcaption aria-hidden="true">image-20230207112317356</figcaption>
</figure>
<h5 id="csmaca">CSMA/CA</h5>
<p>Carrier Sense Multiple Access with Collision
Avoidance,带冲突避免的载波侦听多路访问</p>
<p>这个协议挺有意思</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207151754370.png"
alt="image-20230207151754370" />
<figcaption aria-hidden="true">image-20230207151754370</figcaption>
</figure>
<p>IFS:Interframe Space,IFS 帧间间隔</p>
<blockquote>
<p>IFS用于定义一个站点的优先权,优先权高的站点,其IFS就短</p>
<p>为啥IFS短了就意味着优先权高呢?这就需要了解协议如何工作的</p>
</blockquote>
<p>Contention Window 竞争窗口</p>
<p>工作流程:</p>
<p><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207151820663.png" alt="CSMA/CA" style="zoom:25%;" /></p>
<p>1.首先检查信道是否空闲,如果不是,重新检查</p>
<p>2.如果信道空闲,等待IFS时间</p>
<p>3.等完了再检查一下信道是否空闲,如果忙,退回1.</p>
<p>4.挑一个随机数<span
class="math inline">\(R\in[0,2^K)\)</span>,也就是在竞争窗口中抓阄</p>
<p>5.等R个时间片,然后检查信道是否忙,如果忙,就等会不忙了再发送.如果不忙就发送</p>
<p>6.发完了设置窗口期等待ACK回复,如果收到,则通信成功,否则K++,回头从1开始,如果K&gt;15则不再尝试,通信事变</p>
<h3 id="以太网">以太网</h3>
<p>低层协议的组成</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207155541312.png"
alt="image-20230207155541312" />
<figcaption aria-hidden="true">image-20230207155541312</figcaption>
</figure>
<p>OSI规定的数据链路层分成两个子层,一个是LLC层,一个是MAC层.前者承上后者启下</p>
<p>以太网是MAC的一种实现方式,并且是目前最成功的实现方式</p>
<h4 id="mac地址">MAC地址</h4>
<h5 id="mac地址规定">MAC地址规定</h5>
<p>以太网地址是一个6字节数,每个网卡都有一个固定的MAC地址</p>
<p>一个计算机可能由多张网卡,因此计算机可以有多个MAC地址</p>
<p><code>ipconfig /all</code>即可查看</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">以太网适配器 以太网:</span><br><span class="line"></span><br><span class="line">   媒体状态  . . . . . . . . . . . . : 媒体已断开连接</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   描述. . . . . . . . . . . . . . . : Realtek PCIe GbE Family Controller</span><br><span class="line">   物理地址. . . . . . . . . . . . . : 84-A9-38-F4-9B-69</span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line">无线局域网适配器 WLAN:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   描述. . . . . . . . . . . . . . . : Intel(R) Wi-Fi 6 AX201 160MHz</span><br><span class="line">   物理地址. . . . . . . . . . . . . : 2C-6D-C1-98-7D-03</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>以<code>2C-6D-C1-98-7D-03</code>为例子,最左边是最高位,</p>
<p>称"第一个字节"为最左边的0x2C,第二个就是0x6D</p>
<h5 id="特殊地址">特殊地址</h5>
<p>如果一个MAC地址第一个字节的最低为是0,则该地址是一个单播地址,是1则为多播地址</p>
<p>特殊的,如果MAC addr=FF:FF:FF:FF:FF:FF,则该地址是一个广播地址</p>
<p>0x2C=00101100b,显然所有的物理网卡地址必然是一个单播地址</p>
<p>怎么观察广播地址呢?可以观察ARP协议需要在以太网中广播寻找目标IP地址的主机</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207160905292.png"
alt="image-20230207160905292" />
<figcaption aria-hidden="true">image-20230207160905292</figcaption>
</figure>
<p>源地址就是本机WLAN网卡的地址2C-6D-C1-98-7D-03,目的地址12个F,显然是一个广播</p>
<p>wireshark已经自动根据本机WLAN网卡的<strong>前三个字节</strong>判断出本网卡产自Intel公司</p>
<p>再一查好家伙made in 马来西亚</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207161145923.png"
alt="image-20230207161145923" />
<figcaption aria-hidden="true">image-20230207161145923</figcaption>
</figure>
<p>同理华为公司也会买下前三个字节用来标志自己公司的网卡</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207161443085.png"
alt="image-20230207161443085" />
<figcaption aria-hidden="true">image-20230207161443085</figcaption>
</figure>
<p>如果前三个字节是公司编号</p>
<p>那么一个公司编号最多能够产<span
class="math inline">\(2^{24}\approx400万\)</span>张网卡</p>
<p>如果一部手机使用一个wifi网卡,光中国就有13亿人,假设有1亿人用华为手机,显然一个公司编号是不够用的</p>
<h5 id="网络序">网络序</h5>
<p>字节序不变,但是每个字节内的比特位分别调转(不是取反,是前后调转)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207161313727.png"
alt="image-20230207161313727" />
<figcaption aria-hidden="true">image-20230207161313727</figcaption>
</figure>
<h4 id="mac帧格式">MAC帧格式</h4>
<p>MAC帧有两种格式,</p>
<p>不常用的802.2LLC帧,这是IEEE802工作组制定的答辩</p>
<p>最常用的EthernetV2帧</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207162023980.png"
alt="image-20230207162023980" />
<figcaption aria-hidden="true">image-20230207162023980</figcaption>
</figure>
<p>MAC帧=MAC头+MAC数据+FCS</p>
<p>其中MAC头包括目的地址,源地址,MAC数据类型</p>
<p>FCS就是校验和</p>
<p>MAC数据一般是IP数据报,包括IPv4包或者IPv6数据包</p>
<h5 id="不合法的mac帧">不合法的MAC帧</h5>
<p>以下有一则为不合法MAC帧</p>
<p>数据字段的长度与长度字段的值不一致；</p>
<p>帧的长度不是整数个字节；</p>
<p>用收到的帧检验序列 FCS 查出有差错；</p>
<p><strong>数据字段的长度不在 46 ~ 1500 字节之间；</strong></p>
<p><strong>MAC 帧长度不在64 ~ 1518 字节之间；</strong></p>
<p>对于检查出的无效 MAC
帧就简单地丢弃，以太网<strong>不负责重传丢弃的帧。</strong></p>
<p>这里对帧长度有一个规定,[64,1518]为啥会有这两头的限制呢?</p>
<h5 id="合法帧长度">合法帧长度</h5>
<p>[64,1518]bytes</p>
<p>由于有限以太网使用CSMA/CD协议,因此需要保证最小传输时间大于等于两倍的最大传播时间</p>
<p>而这两个时间的关系,关乎帧长度啥事呢?</p>
<p>显然帧长越长,传输时间就越长,可以推测帧长为64bytes时达到临界值</p>
<p>根据802.3规定,以太网最长2500米,带宽10Mbps,四个中继器,最坏情况下,往返时间(也就是两倍的最长传播时间)大约是50μs.</p>
<p>那么传输速度应该大于50μs.</p>
<p>又带宽是10Mbps,在50微妙内能够发送<span class="math inline">\(50\times
10^{-6}s\times 10\times 10^6bps=500bit\)</span></p>
<p>增加安全边际,往上取整到512bit=64byte</p>
<p>因此规定最小帧长就是64byte</p>
<p>那么又为啥限制最长帧长为1500呢?</p>
<p>因为网络是多台计算机共享的,如果一台主机一直喋喋不休地说,其他主机就得等着,因此一句话不能说太长</p>
<p>于是人为规定为最长1518byte</p>
<p>那么在以太网上的IP包长度就跟着被限制到[48,1500]字节</p>
<p>这个1500字节也就是MTU,最大传输单元</p>
<h3 id="网络连接">网络连接</h3>
<h4 id="数据链路层设备">数据链路层设备</h4>
<p>网桥,集线器,二层交换机都是链路层设备</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 47%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr>
<th>一层设备</th>
<th>结构</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>中继器</td>
<td><img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207210513001.png"
alt="image-20230207210513001" /></td>
<td>再生信号(不是放大信号),延长通信距离</td>
</tr>
<tr>
<td>集线器</td>
<td><img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207210909500.png"
alt="image-20230207210909500" /><br />所有计算机同处于一个冲突域<br />集线器从一个端口进来的包会被无脑拷贝到所有的出端口</td>
<td>只是把多个主机联通,<br />相当于多通水管<br />多端口的中继器</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 46%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr>
<th>二层设备</th>
<th>结构</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>网桥</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207211056989.png" alt="image-20230207211056989" style="zoom:25%;" /><br />网桥可以检查目标地址,根据自己学习建立的转发表,决定从哪个端口转发,相对集线器聪明了不少</td>
<td>减小冲突域,网桥的一个接口是一个冲突域<br />但是所有达到接口都在同一个广播域</td>
</tr>
<tr>
<td>二层交换机</td>
<td><img src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207163904317.png" alt="image-20230207163904317" style="zoom:25%;" /></td>
<td>消除冲突域,从此不再有冲突<br />相当于带阀门的多通水管<br />但是所有接口都在同一广播域</td>
</tr>
</tbody>
</table>
<p>区分两个术语:广播域,冲突域</p>
<p>广播域:能够接收广播帧的所有设备的集合</p>
<p>冲突域:所有共享介质(比如电缆)都是冲突域</p>
<p>显然广播域的范围要大于等于冲突域</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207213901157.png"
alt="image-20230207213901157" />
<figcaption aria-hidden="true">image-20230207213901157</figcaption>
</figure>
<p>以太网:有线局域网的一种实现,链路层使用CSMA/CD技术</p>
<h5 id="网桥">网桥</h5>
<h6 id="爱学习の网桥">爱学习の网桥</h6>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207211927143.png"
alt="image-20230207211927143" />
<figcaption aria-hidden="true">image-20230207211927143</figcaption>
</figure>
<p>刚接入局域网的网桥是个傻子,啥也不知道,但是他很快就会知道</p>
<p>一开始他的MAC:Port映射表是空的</p>
<p>当A@LAN1 向
D@LAN2发送一个数据帧之后,这个帧显然必须从网桥的1号端口进入.网桥从帧中得知,源地址A在1端口对应的LAN上,于是将A:1写入映射表</p>
<p>如果D回复A收到,立刻就会把D的MAC暴露给网桥,网桥就会记录D:2</p>
<p>D不回复也没关系,反正D只要一说话立刻就会被网桥学会</p>
<h6 id="环路问题">环路问题</h6>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207212358099.png"
alt="image-20230207212358099" />
<figcaption aria-hidden="true">image-20230207212358099</figcaption>
</figure>
<p>如果有两个网桥同时连接了两个LAN</p>
<p>那么一个LAN发出的帧会同时被两个网桥转发,导致另一个LAN中出现两次该帧</p>
<h6 id="生成树算法">生成树算法</h6>
<p>生成树算法用于建立多个LAN的最优联通路径</p>
<p>这里的最优可能是最小跳数,最小延迟,最大带宽等等</p>
<p>假设从网桥到LAN跳数为1，从LAN到网桥跳数为0。</p>
<blockquote>
<p>为啥要这样假设呢?</p>
<p>因为网桥不会主动向一个LAN发送帧,除非该帧的目的在这个LAN中</p>
<p>而一个LAN的帧要想传送到另一个LAN,必须要经过网桥</p>
<p>也就是说,网桥转发帧需要一定的代价,应该尽量减少转发量</p>
<p>而LAN向网桥发送帧这是不可阻阻挡的,几乎没有代价</p>
<p>因此有这么一个假设</p>
</blockquote>
<p>首先将网桥和LAN进行有向图建模,并标注边权</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207212859184.png"
alt="image-20230207212859184" />
<figcaption aria-hidden="true">image-20230207212859184</figcaption>
</figure>
<blockquote>
<p>为啥没有两个网桥直接连接?或者两个LAN直接连接?</p>
<p>这不废话吗</p>
<p>两个网桥连接和只用一个网桥不一样吗?</p>
<p>两个LAN连接就是一个LAN</p>
<blockquote>
<p>两个LAN连接也得使用网桥啊(</p>
</blockquote>
</blockquote>
<p>生成树算法:</p>
<p>spanning tree algorithm:</p>
<p>1.每个网桥广播ID,选择最小的ID作为根网桥</p>
<p><strong>2.找出从根网桥到其它网桥或LAN的最短路径</strong></p>
<p>3.最短路径组合生成最短的树</p>
<p>4.标记转发端口和阻塞端口</p>
<p>注意生成树算法目的是,找出从根网桥到其他网桥和LAN的最短路,</p>
<p>而不是为每个LAN找出到其他各个LAN的最短路</p>
<p>使用生成树算法之后,阻塞端口不再使用,转发端口活跃</p>
<h5 id="交换机">交换机</h5>
<p>交换机相对于集线器的优点:</p>
<p>1.每个端口是一个冲突域</p>
<p>2.根据目标MAC地址查转发表,决定发往哪个端口</p>
<p>3.全双工,由于没有冲突域,不需要CSMA/CD协议</p>
<p>4.有缓存,各个接口的带宽可以不同</p>
<h4 id="网络层设备">网络层设备</h4>
<p>链路层设备关心帧的MAC地址</p>
<p>网络层设备关心包的IP地址</p>
<p>三层设备就一个三层交换机和一个路由器</p>
<p>这个三层交换机不伦不类,它既有二层交换机那个交换转发的功能,也有路由器的路由功能</p>
<p>两者本身上的区别是,三层交换机主要是硬件驱动的,但是路由器是CPU+操作系统软件驱动的.这就导致三层交换机的效率远快于路由器</p>
<p>两者功能上的区别是,三层交换机用于连接相同性质的网络,比如连接两个LAN:192.168.2.1/24和192.168.1.1/24</p>
<p>但是路由器主要用于不同类型的网络连接,比如因特网和局域网的连接,入户网线可能给一个互联网的公网地址,需要使用一个路由器NAT转化为一个LAN.并且实际上的路由选择,负荷分担,链路备份,和其他网络交换路由信息,都是路由器实现的</p>
<p>路由功能:当IP报文抵达路由器时,决定转发给哪一个下一跳路由器</p>
<p>这个决策是基于路由器的路由表做出的</p>
<p>路由表可以人工填写静态的,也可以让路由器自己学,就跟网桥交换机的转发表差不多</p>
<h4 id="网关">网关</h4>
<p>比较特殊的路由器</p>
<p>一个LAN内的主机如果想要跨LAN访问另一个主机,只通过二层交换机是做不到的,因为二层交换机是连IP地址都不知道的傻子.网关就是一个LAN和外部网络连接的关口.LAN内的主机只要是想和外部通信,无脑往网关发包就可以了,网关负责决定这个包如何路由</p>
<h4 id="虚拟局域网">虚拟局域网</h4>
<p>交换机可以隔离冲突域但是无法隔离广播域</p>
<p>划分虚拟局域网之后可以隔离冲突域和广播域</p>
<p>在一个交换机上划分了VLAN,实际上相当于虚拟出多个交换机,每个交换机都分别连接到路由器上,形成多个LAN,并且这几个LAN互不连通.这个路由器就是各个LAN的网关</p>
<h5 id="等效结构">等效结构</h5>
<p>如图所示</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207220800643.png"
alt="image-20230207220800643" />
<figcaption aria-hidden="true">image-20230207220800643</figcaption>
</figure>
<p>这实际上就相当于</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207220913692.png"
alt="image-20230207220913692" />
<figcaption aria-hidden="true">image-20230207220913692</figcaption>
</figure>
<h5 id="如何实现">如何实现</h5>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207221014728.png"
alt="image-20230207221014728" />
<figcaption aria-hidden="true">image-20230207221014728</figcaption>
</figure>
<p>如果一个VLAN跨越了两个交换机,那么这个VLAN中两个计算机通过交换机通信时,交换机在发往另一个交换机之前,检查A计算机所处VLAN,然后在链路层帧后面加上VLAN标志,这样另一个交换机就知道把改帧转发给哪一个目标VLAN了</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207223219150.png"
alt="image-20230207223219150" />
<figcaption aria-hidden="true">image-20230207223219150</figcaption>
</figure>
<p>如图所示的拓扑中,经过实验,PC9@192.168.10.1 ping
PC13@192.168.10.3时,ICMP报文会被LSW5交换机准确地从GE0/0/4口转发到GE0/0/2端口,报文中也没有体现VLAN</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207223605022.png"
alt="image-20230207223605022" />
<figcaption aria-hidden="true">image-20230207223605022</figcaption>
</figure>
<p>PC13@192.168.10.3 ping
PC11@192.168.10.2时会经过两个路由器的Trunk端口,其报文中,以太网头和IP头之间加上了VLAN编号,占用四个字节,这个玩意叫做tag(标签)</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20230207223506096.png"
alt="image-20230207223506096" />
<figcaption aria-hidden="true">image-20230207223506096</figcaption>
</figure>
<h5 id="交换机端口类型">交换机端口类型</h5>
<p>access类型,只属于一个VLAN,用于连接计算机</p>
<p>trunk类型,主干道,可以设置允许哪些VLAN通过,用于连接交换机</p>
<p>hybrid类型,类似于trunk,但是hybrid允许通过改接口的帧不带VLAN
tag,而trunk要求必须带VLAN tag(除了缺省VLAN,默认是VLAN
1,的帧不需要带tag)</p>
<p>当端口接收到不带VLAN
Tag的报文后，则将报文转发到<strong>属于缺省VLAN的端口</strong>(如果设置了端口的缺省VLAN
ID,默认是VLAN 1)。</p>
<p>当端口发送带有VLAN Tag的报文时，如果该报文的VLAN ID与端口缺省的VLAN
ID相同，则系统将去掉报文的VLAN Tag，然后再发送该报文。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>dustball
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="http://deutschball.github.io/2023/02/08/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" title="计算机网络-数据链路层">http://deutschball.github.io/2023/02/08/数据链路层/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%BD%91/" rel="tag"># 计网</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/01/30/Spring/" rel="prev" title="Spring Core">
      <i class="fa fa-chevron-left"></i> Spring Core
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/08/%E4%BC%A0%E8%BE%93%E5%B1%82/" rel="next" title="计算机网络-传输层">
      计算机网络-传输层 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-number">1.</span> <span class="nav-text">计算机网络-数据链路层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-number">1.1.</span> <span class="nav-text">数据链路层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.1.1.</span> <span class="nav-text">数据链路层的任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%97%E4%BD%99%E7%BC%96%E7%A0%81"><span class="nav-number">1.1.2.</span> <span class="nav-text">冗余编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%97%E7%BC%96%E7%A0%81"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">块编码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB"><span class="nav-number">1.1.2.1.1.</span> <span class="nav-text">汉明距离</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E6%96%B9%E6%A1%88"><span class="nav-number">1.1.2.1.2.</span> <span class="nav-text">编码方案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%9D%97%E7%BC%96%E7%A0%81"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">线性块编码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB"><span class="nav-number">1.1.2.2.1.</span> <span class="nav-text">最小汉明距离</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E7%BC%96%E7%A0%81"><span class="nav-number">1.1.2.2.2.</span> <span class="nav-text">简单奇偶校验编码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="nav-number">1.1.2.2.3.</span> <span class="nav-text">二维奇偶校验</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%89%E6%98%8E%E7%BC%96%E7%A0%81"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">汉明编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E7%BC%96%E7%A0%81"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">循环冗余编码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="nav-number">1.1.2.4.1.</span> <span class="nav-text">多项式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E4%B8%AA%E4%BD%8D%E5%B7%AE%E9%94%99"><span class="nav-number">1.1.2.4.2.</span> <span class="nav-text">单个位差错</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E7%8B%AC%E7%AB%8B%E4%BD%8D%E5%B7%AE%E9%94%99"><span class="nav-number">1.1.2.4.3.</span> <span class="nav-text">两独立位差错</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A5%87%E6%95%B0%E4%B8%AA%E4%BD%8D%E5%B7%AE%E9%94%99"><span class="nav-number">1.1.2.4.4.</span> <span class="nav-text">奇数个位差错</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AA%81%E5%8F%91%E6%80%A7%E9%94%99%E8%AF%AF"><span class="nav-number">1.1.2.4.5.</span> <span class="nav-text">突发性错误</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.2.4.6.</span> <span class="nav-text">高性能多项式特性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">校验和</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.1.3.</span> <span class="nav-text">数据链路层协议:</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9E%E9%80%80n%E5%B8%A7%E8%87%AA%E5%8A%A8%E9%87%8D%E5%8F%91%E8%AF%B7%E6%B1%82"><span class="nav-number">1.1.3.0.1.</span> <span class="nav-text">回退N帧自动重发请求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%80%A7%E9%87%8D%E4%BC%A0"><span class="nav-number">1.1.3.0.2.</span> <span class="nav-text">选择性重传</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%A6%E6%8D%8E%E5%B8%A6%E7%9A%84n%E6%AD%A5%E8%BF%94%E5%9B%9Enrq"><span class="nav-number">1.1.3.0.3.</span> <span class="nav-text">带捎带的N步返回NRQ</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E5%AE%BD%E5%88%A9%E7%94%A8%E7%8E%87"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">带宽利用率</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE"><span class="nav-number">1.1.4.</span> <span class="nav-text">多路访问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">随机访问协议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#aloha"><span class="nav-number">1.1.4.1.1.</span> <span class="nav-text">AlOHA</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%92%8C%E4%BC%A0%E6%92%AD"><span class="nav-number">1.1.4.1.1.1.</span> <span class="nav-text">传输和传播</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%86%B2%E7%AA%81%E6%97%B6%E9%97%B4"><span class="nav-number">1.1.4.1.1.2.</span> <span class="nav-text">冲突时间:</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-number">1.1.4.1.1.3.</span> <span class="nav-text">吞吐量</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%B6%E9%9A%99aloha"><span class="nav-number">1.1.4.1.2.</span> <span class="nav-text">时隙ALOHA</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%9E%E5%90%90%E9%87%8F-1"><span class="nav-number">1.1.4.1.2.1.</span> <span class="nav-text">吞吐量</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#csma"><span class="nav-number">1.1.4.1.3.</span> <span class="nav-text">CSMA</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%86%B2%E7%AA%81%E6%97%B6%E9%97%B4-1"><span class="nav-number">1.1.4.1.3.1.</span> <span class="nav-text">冲突时间</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%86%B2%E7%AA%81%E7%BC%93%E8%A7%A3%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.4.1.3.2.</span> <span class="nav-text">冲突缓解方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#csmacd"><span class="nav-number">1.1.4.1.4.</span> <span class="nav-text">CSMA&#x2F;CD</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%86%B2%E7%AA%81%E6%A3%80%E6%B5%8B%E6%97%B6%E9%97%B4"><span class="nav-number">1.1.4.1.4.1.</span> <span class="nav-text">冲突检测时间</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#csmacd%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="nav-number">1.1.4.1.4.2.</span> <span class="nav-text">CSMA&#x2F;CD算法流程</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#csmaca"><span class="nav-number">1.1.4.1.5.</span> <span class="nav-text">CSMA&#x2F;CA</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="nav-number">1.1.5.</span> <span class="nav-text">以太网</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mac%E5%9C%B0%E5%9D%80"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">MAC地址</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#mac%E5%9C%B0%E5%9D%80%E8%A7%84%E5%AE%9A"><span class="nav-number">1.1.5.1.1.</span> <span class="nav-text">MAC地址规定</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E5%9C%B0%E5%9D%80"><span class="nav-number">1.1.5.1.2.</span> <span class="nav-text">特殊地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%BA%8F"><span class="nav-number">1.1.5.1.3.</span> <span class="nav-text">网络序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mac%E5%B8%A7%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">MAC帧格式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%90%88%E6%B3%95%E7%9A%84mac%E5%B8%A7"><span class="nav-number">1.1.5.2.1.</span> <span class="nav-text">不合法的MAC帧</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%88%E6%B3%95%E5%B8%A7%E9%95%BF%E5%BA%A6"><span class="nav-number">1.1.5.2.2.</span> <span class="nav-text">合法帧长度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.1.6.</span> <span class="nav-text">网络连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E8%AE%BE%E5%A4%87"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">数据链路层设备</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E6%A1%A5"><span class="nav-number">1.1.6.1.1.</span> <span class="nav-text">网桥</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%88%B1%E5%AD%A6%E4%B9%A0%E3%81%AE%E7%BD%91%E6%A1%A5"><span class="nav-number">1.1.6.1.1.1.</span> <span class="nav-text">爱学习の网桥</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%8E%AF%E8%B7%AF%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.6.1.1.2.</span> <span class="nav-text">环路问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.6.1.1.3.</span> <span class="nav-text">生成树算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="nav-number">1.1.6.1.2.</span> <span class="nav-text">交换机</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E5%A4%87"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">网络层设备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E5%85%B3"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">网关</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="nav-number">1.1.6.4.</span> <span class="nav-text">虚拟局域网</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%89%E6%95%88%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.6.4.1.</span> <span class="nav-text">等效结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.6.4.2.</span> <span class="nav-text">如何实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%AB%AF%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.6.4.3.</span> <span class="nav-text">交换机端口类型</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
