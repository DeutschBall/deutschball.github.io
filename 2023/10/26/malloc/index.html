<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dustball.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Dive Into Ptmalloc2 基于glibc2.23的ptmalloc2源码分析 datastructure malloc_chunk 堆空间管理的最小单元 每个堆块由元数据和数据两部分组成 元数据记录了该堆块的物理前块大小,本块大小,分配区,前块使用,是否mmap块状态,以及空闲状态下的前驱后继指针 数据就是返回给用户的可用空间 123456789101112struc">
<meta property="og:type" content="article">
<meta property="og:title" content="glibc2.23 Ptmalloc2 源码分析">
<meta property="og:url" content="http://dustball.top/2023/10/26/malloc/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="Dive Into Ptmalloc2 基于glibc2.23的ptmalloc2源码分析 datastructure malloc_chunk 堆空间管理的最小单元 每个堆块由元数据和数据两部分组成 元数据记录了该堆块的物理前块大小,本块大小,分配区,前块使用,是否mmap块状态,以及空闲状态下的前驱后继指针 数据就是返回给用户的可用空间 123456789101112struc">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-10-26T14:03:00.000Z">
<meta property="article:modified_time" content="2023-10-26T14:04:01.976Z">
<meta property="article:author" content="dustball">
<meta property="article:tag" content="堆">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://dustball.top/2023/10/26/malloc/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>glibc2.23 Ptmalloc2 源码分析 | dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://dustball.top/2023/10/26/malloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          glibc2.23 Ptmalloc2 源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-10-26 22:03:00 / Modified: 22:04:01" itemprop="dateCreated datePublished" datetime="2023-10-26T22:03:00+08:00">2023-10-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="dive-into-ptmalloc2">Dive Into Ptmalloc2</h1>
<p><del>基于glibc2.23的ptmalloc2源码分析</del></p>
<h2 id="datastructure">datastructure</h2>
<h3 id="malloc_chunk">malloc_chunk</h3>
<p>堆空间管理的最小单元</p>
<p>每个堆块由元数据和数据两部分组成</p>
<p>元数据记录了该堆块的物理前块大小,本块大小,分配区,前块使用,是否<code>mmap</code>块状态,以及空闲状态下的前驱后继指针</p>
<p>数据就是返回给用户的可用空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="字段意义">字段意义</h4>
<h5 id="prev_size">prev_size</h5>
<p>如果物理上紧挨着的一个<code>chunk</code>空闲的话,则该值为物理上前面紧挨着的那个<code>chunk</code>的大小.</p>
<p>如果物理上紧挨着的一个<code>chunk</code>占用的话,则该值可以被物理上紧挨着的那个<code>chunk</code>使用(空间复用)</p>
<h5 id="size">size</h5>
<p>本chunk的大小,包括chunk头和<code>chunk</code>数据</p>
<blockquote>
<p>其中chunk头就是<code>malloc_chunk</code>结构体,chunk数据就是返回给用户使用的内存空间</p>
</blockquote>
<p>每个<code>chunk</code>的大小都必须是<code>2*SIZE_SZ</code>整数倍</p>
<p>32位系统中size_sz=4,64位系统中size_sz=8</p>
<p>因此32位系统上chunk大小是8的倍数,64位上chunk是16的倍数</p>
<p>诚如是,则size的低3位永远用不到,为了节省空间,ptmalloc的实现中,这三个低位表示三个符号A,M,P</p>
<h5 id="fdbk">fd,bk</h5>
<p>当本chunk空闲并且挂在bin上,此时fd,bk分别是前向和后向chunk的指针,相当于双向链表.</p>
<p>注意是逻辑上相邻,也就是链表相连,不是物理上相邻</p>
<h5 id="fd_nextsizebk_nextsize">fd_nextsize,bk_nextsize</h5>
<p>当chunk空闲并且挂在large bin中时,用于查找最近匹配的空闲chunk</p>
<p>怎么个用法呢?</p>
<p>large
bin中挂着的chunk是按照大小排序的,一个chunk逻辑上相连的chunk可能大小相同,也可能不同,fd_nextsize,bk_nextsize就指向第一个<strong>大小不同</strong>的chunk</p>
<p>这样说比较抽象,具体见后面的largebin结构</p>
<h4 id="空间复用">空间复用</h4>
<h5 id="分配时状态">分配时状态</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, <span class="keyword">if</span> <span class="title function_">unallocated</span> <span class="params">(P clear)</span>  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             <span class="params">(malloc_usable_size() bytes)</span>                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             <span class="params">(size of chunk, but used <span class="keyword">for</span> application data)</span>    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<h5 id="空闲时状态">空闲时状态</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">      |             Size of previous chunk                            |</span><br><span class="line">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    `head:<span class="string">&#x27; |             Size of chunk, in bytes                         |P|</span></span><br><span class="line"><span class="string">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">      |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="string">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">      |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="string">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">      |             Unused space (may be 0 bytes long)                .</span></span><br><span class="line"><span class="string">      .                                                               .</span></span><br><span class="line"><span class="string">      .                                                               |</span></span><br><span class="line"><span class="string">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">    `foot:&#x27;</span> |             Size of chunk, in bytes                           |</span><br><span class="line">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<h4 id="宏定义">宏定义</h4>
<h5 id="指针转换">指针转换</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)((char *) (mem) -2 * SIZE_SZ))</span></span><br></pre></td></tr></table></figure>
<p>mem就是数据区,chunk就是malloc_chunk的基地址,两者的关系在图上表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, <span class="keyword">if</span> <span class="title function_">unallocated</span> <span class="params">(P clear)</span>  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             <span class="params">(malloc_usable_size() bytes)</span>                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             <span class="params">(size of chunk, but used <span class="keyword">for</span> application data)</span>    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>显然mem网上数两个成员就是chunk,这两个成员都是INTERNAL_SIZE_T类型的,在32位平台上分别长4字节,在64位平台上分别长8字节</p>
<h5 id="最小chunk大小">最小chunk大小</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br></pre></td></tr></table></figure>
<p><code>offsetof(struct,struct.member);</code>作用是计算member成员在其所在的结构体struct中的偏移量</p>
<p>这表明最小的chunk至少要包含前四个成员,prev_size,size,fd,bk,后面两个可以没有</p>
<h5 id="最小申请的堆内存大小">最小申请的堆内存大小</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE                                                                \</span></span><br><span class="line"><span class="meta">    (unsigned long) (((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp;                   \</span></span><br><span class="line"><span class="meta">                      ~MALLOC_ALIGN_MASK))</span></span><br></pre></td></tr></table></figure>
<h5 id="检查对齐">检查对齐</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"><span class="comment">// MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> misaligned_chunk(p)                                                    \</span></span><br><span class="line"><span class="meta">    ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \</span></span><br><span class="line"><span class="meta">     MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure>
<h5 id="判断用户请求是否离谱">判断用户请求是否离谱</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br></pre></td></tr></table></figure>
<h5 id="规范化请求大小">规范化请求大小</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \<span class="comment">//如果用户请求的太小则直接用MINSIZE</span></span></span><br><span class="line">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)<span class="comment">//否则向上取整到满足对齐要求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span></span><br><span class="line"><span class="meta">        __set_errno(ENOMEM);                                                   \</span></span><br><span class="line"><span class="meta">        return 0;                                                              \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">    (sz) = request2size(req);</span></span><br></pre></td></tr></table></figure>
<h5 id="设置size最低三位标志位">设置size最低三位标志位</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_inuse(p) ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for chunk from main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark a chunk as not being on the main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">   macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">   cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">   people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure>
<h5 id="获取本chunk-size">获取本chunk size</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure>
<p>如果想要获得纯真的size,最低三位应该忽略标志位的影响,因此chunksize中用SIZE_BITS取反得到第三位全是0然后按位与,确保获得的size低三位必为0</p>
<p>而chunksize_nomask就没有忽略,相当于直接区的malloc_struct的第二个成员</p>
<h5 id="使用状态">使用状态</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)                                                               \</span></span><br><span class="line"><span class="meta">    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse(p)                                                           \</span></span><br><span class="line"><span class="meta">    ((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size |= PREV_INUSE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse(p)                                                         \</span></span><br><span class="line"><span class="meta">    ((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span></span><br></pre></td></tr></table></figure>
<h5 id="size大小">size大小</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="comment">// SIZE_BITS = 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head_size(p, s)                                                    \</span></span><br><span class="line"><span class="meta">    ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s) ((p)-&gt;mchunk_size = (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_foot(p, s)                                                         \</span></span><br><span class="line"><span class="meta">    (((mchunkptr)((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span></span><br></pre></td></tr></table></figure>
<p>这里set_foot干了啥?</p>
<p>p是chunk指针,s是该chunk的大小,p+s就指向了本chunk的结尾,</p>
<p>也就是下一个chunk的基地址,也就是下一个chunk的prev_size成员,</p>
<p>于是p+s强转为一个malloc_chunk类型指针,</p>
<p>然后取其第一个成员也就是prev_size,写上本chunk的大小</p>
<h5 id="指定偏移处认为是一个chunk">指定偏移处认为是一个chunk</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure>
<p>p指针加上s偏移量的地址视为一个chunk的基地址,返回一个malloc_chunk*指针</p>
<h3 id="malloc_state">malloc_state</h3>
<p>分配区结构,一个进程只能有一个主分配区,可以可以有多个非主分配区</p>
<p>当某个线程试图用<code>malloc</code>动态申请内存时,会首先对一个分配区上锁,如果主分配区忙则沿着<code>malloc_state-&gt;next</code>寻找下一个分配区,直到找到一个闲的分配区上锁使用.如果转一圈没发现闲的分配区则创建新的非主分配区,然后将其加入到这个分配区环状链表中上锁使用.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;<span class="comment">//互斥锁,保证临界区只有一个线程访问</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr      fastbins[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr        top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr        last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr        bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>     binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中管理堆块的手段有fastbin,topchunk,unsortedbin,smallbins,largebins这么几种</p>
<p>只考虑单线程的情况,也就是说不会产生非主分配区,只使用主分配区</p>
<p>最初只有很大一块topchunk,刚开始的malloc申请都是直接在malloc上切割使用</p>
<p>free释放时,如果对应堆块落在fastbin范围内则放到fastbin对应的链表中</p>
<p>否则一律放到unsortedbin中,等后面再次malloc时切割或者合并或者分拣</p>
<h4 id="fastbins">fastbins</h4>
<p>只会使用fd指针的单向链表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">A[&quot;fastbin[x]&quot;]</span><br><span class="line">A--fd--&gt;a--fd--&gt;b--fd--&gt;c</span><br></pre></td></tr></table></figure>
<h5 id="max_fast">max_fast</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_max_fast(s) \</span></span><br><span class="line"><span class="meta">  global_max_fast = (((s) == 0)						      \</span></span><br><span class="line"><span class="meta">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_max_fast() global_max_fast</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> INTERNAL_SIZE_T global_max_fast;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ &lt; __alignof__ (long double)      \</span></span><br><span class="line"><span class="meta">                                  ? __alignof__ (long double) : 2 *SIZE_SZ)</span></span><br></pre></td></tr></table></figure>
<p>对于x64平台,SIZE_SZ=8,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MALLOC_ALIGNMENT=2*SIZE_SZ=16=0b 10000</span><br><span class="line">MALLOC_ALIGN_MASK=15=0b 1111</span><br><span class="line"> ~MALLOC_ALIGN_MASK=111...111 0000</span><br></pre></td></tr></table></figure>
<p>这个<code>global_max_fast</code>在<code>malloc_init_state</code>时期被初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (av == &amp;main_arena)</span><br><span class="line">  set_max_fast (DEFAULT_MXFAST);</span><br><span class="line">  </span><br><span class="line">#define DEFAULT_MXFAST     (64 * SIZE_SZ / 4)</span><br></pre></td></tr></table></figure>
<p>对于<code>x64</code>平台,<code>SIZE_SZ=8</code>,那么<code>DEFAULT_MXFAST=128</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_max_fast(128):</span><br><span class="line">	  global_max_fast = ((128 + 8) &amp; 111...111 0000))</span><br><span class="line">	  =0b10001000&amp;0b111...111 0000</span><br><span class="line">	  =0b10000000</span><br><span class="line">	  =128</span><br></pre></td></tr></table></figure>
<p>也就是说,<code>nb&lt;=128</code>才可能在fastbin中取堆块</p>
<h5 id="fastbin_index">fastbin_index</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz)  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br></pre></td></tr></table></figure>
<p>在x64平台上,<code>SIZE_SZ=8</code>,而在x86平台上<code>SIZE_SZ=4</code></p>
<p>如果在x64平台上,则将sz右移4位,相当于除以16,然后-2,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastbin_index(sz)</span><br><span class="line">	=sz &gt;&gt; 4 - 2</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>sz</th>
<th>fastbin_index(sz) on x64</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[0b100000,0b110000)=[32,48)</code></td>
<td>0</td>
</tr>
<tr>
<td><code>[0b110000,0b1000000)=[48,64)</code></td>
<td>1</td>
</tr>
<tr>
<td><code>[0b1000000,0b1010000)=[64,80)</code></td>
<td>2</td>
</tr>
</tbody>
</table>
<p>比如用户期望分配0x10大小的空间,那么实际上的堆块大小是32字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastbin_index(0b100000)</span><br><span class="line">	=0b100000&gt;&gt;4 -2</span><br><span class="line">	=0b10-2</span><br><span class="line">	=0</span><br></pre></td></tr></table></figure>
<h5 id="fastbinidx">fastbin[idx]</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>fastbins结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct malloc_chunk *mfastbinptr;</span><br><span class="line">...</span><br><span class="line">struct malloc_state&#123;</span><br><span class="line">	...</span><br><span class="line">mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fastbins是一个链栈,先释放的堆块也会先被再次分配</p>
</blockquote>
<p>也就是说<code>mfastbinptr *fb = &amp;fastbin (av, idx);</code></p>
<p>这栈中的指针变量fb指向桶子头的地址,桶子头指向该桶子中的第一个堆块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">A[&quot;fastbin[x] @malloc_state&quot;]</span><br><span class="line">a2[&quot;1st chunk @heap&quot;]</span><br><span class="line">a1[&quot;2nd chunk @heap&quot;]</span><br><span class="line">a0[&quot;3rd chunk @heap&quot;]</span><br><span class="line">fb[&quot;fb句柄 @stack&quot;]----&gt;A--fd--&gt;a2--fd--&gt;a1--fd--&gt;a0</span><br></pre></td></tr></table></figure>
<h5
id="catomic_compare_and_exchange_val_acq-fb-victim-fd-victim">catomic_compare_and_exchange_val_acq
(fb, victim-&gt;fd, victim)</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#  <span class="keyword">define</span> catomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">  atomic_compare_and_exchange_val_acq (mem, newval, oldval)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">  (&#123; __typeof (mem) __gmemp = (mem);				      \</span></span><br><span class="line"><span class="meta">     __typeof (*mem) __gret = *__gmemp;				      \</span></span><br><span class="line"><span class="meta">     __typeof (*mem) __gnewval = (newval);			      \</span></span><br><span class="line"><span class="meta">								      \</span></span><br><span class="line"><span class="meta">     <span class="keyword">if</span> (__gret == (oldval))					      \</span></span><br><span class="line"><span class="meta">       *__gmemp = __gnewval;					      \</span></span><br><span class="line"><span class="meta">     __gret; &#125;)</span></span><br></pre></td></tr></table></figure>
<p>这个宏的作用是,</p>
<p>原本mem指向的是oldval,现在将oldval作为返回值,然后将men指向newval</p>
<p>放在原文中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim = pp;<span class="comment">//首先执行一次,如果第一次victim为空,说明这个桶子就是空的,也就不能用fastbin进行分配</span></span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">while</span> (</span><br><span class="line">		(pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)</span><br><span class="line">      )!= victim</span><br><span class="line">    <span class="comment">//victim指向链栈顶堆块,把他取下来,把原来的次顶堆块,也就是victim的后继堆块,挂到fb指针上,返回值pp是victim</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>fb这个桶子头原本是指向victim这个堆块的,</p>
<p>现在要让fb指向victim的后继堆块,然后返回victim给pp</p>
<p>显然pp必然等于victim,也就是顶多拿出堆顶来,while就结束了,while只会执行一次</p>
<p>至于为啥要这样写呢?压行</p>
<h5 id="check_remalloced_chunkapn">check_remalloced_chunk(A,P,N)</h5>
<p>对本应该属于A分配区的大小位S的堆块P进行检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> check_remalloced_chunk(A, P, N) do_check_remalloced_chunk (A, P, N)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_check_remalloced_chunk</span> <span class="params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span></span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line"><span class="comment">//提取p堆块结构体中存放的size,由于低三位是标志复用,现在需要将其盖住</span></span><br><span class="line">  <span class="keyword">if</span> (!chunk_is_mmapped (p))<span class="comment">//如果是mmap分配的堆块</span></span><br><span class="line">      <span class="comment">//如果是mmap分配的堆块,则</span></span><br><span class="line">    &#123;</span><br><span class="line">      assert (av == arena_for_chunk (p));<span class="comment">//首先检查给定的av是否是预期的p的所属分配区</span></span><br><span class="line">      <span class="keyword">if</span> (chunk_non_main_arena (p))<span class="comment">//如果p不是主分配区的</span></span><br><span class="line">        assert (av != &amp;main_arena);<span class="comment">//检查av是不是主分配区</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        assert (av == &amp;main_arena);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  do_check_inuse_chunk (av, p);<span class="comment">//检查本堆块是否正在使用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Legal size ... */</span></span><br><span class="line">  assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);<span class="comment">//检查sz大小是否对齐</span></span><br><span class="line">  assert ((<span class="type">unsigned</span> <span class="type">long</span>) (sz) &gt;= MINSIZE);<span class="comment">//检查sz大小是否大于最小分配大小</span></span><br><span class="line">  <span class="comment">/* ... and alignment */</span></span><br><span class="line">  assert (aligned_OK (chunk2mem (p)));<span class="comment">//检查p指向的地址是否对齐</span></span><br><span class="line">  <span class="comment">/* chunk is less than MINSIZE more than request */</span></span><br><span class="line">  assert ((<span class="type">long</span>) (sz) - (<span class="type">long</span>) (s) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert ((<span class="type">long</span>) (sz) - (<span class="type">long</span>) (s + MINSIZE) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="unsortedbins">unsortedbins</h4>
<p><code>smallbins</code>和<code>unsortedbins</code>中堆块的连接方式相同,都是双向链表</p>
<p>两者不同的是,<code>unsortedbin</code>中堆块可以大小各异,但是<code>smallbin</code>中一个桶子里的堆块必须相同</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/smallbin2.png"
alt="smallbin2" />
<figcaption aria-hidden="true">smallbin2</figcaption>
</figure>
<p><code>unsortedbin</code>的双向链表没有长短限制,采用头插法</p>
<h5 id="unsorted_chunksm-bin_atm-1">unsorted_chunks(M) (bin_at(M,
1))</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span></span><br></pre></td></tr></table></figure>
<p>取unsortedbin桶子头</p>
<h4 id="smallbins">smallbins</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define NSMALLBINS 64</span><br></pre></td></tr></table></figure>
<p>bins的下标是从0到253,其中每个桶子占用两个bins,分别作为fd和bk指针</p>
<p>smallbins占用64个桶子,</p>
<p>其中第1个桶子是unsortedbin,第2个到第63个桶子是smallbins</p>
<p>从第64个及以后的桶子就是largebins</p>
<h5 id="next_bin">next_bin</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_bin(b) ((mbinptr)((char *)(b) + (sizeof(mchunkptr) &lt;&lt; 1)))</span></span><br></pre></td></tr></table></figure>
<p>下一个bin就是<strong>mchunkptr指针</strong>的大小,也就是8个字节(在x64上)</p>
<p>左移一位也就是乘以2,因为每个Bin占用两个bin,分别作为fd和bk指针</p>
<h5 id="in_smallbin_range">in_smallbin_range</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define in_smallbin_range(sz)  \</span><br><span class="line">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span><br><span class="line">  </span><br><span class="line">#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br><span class="line"></span><br><span class="line">#define NBINS             128</span><br><span class="line">#define NSMALLBINS         64</span><br><span class="line">#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span><br><span class="line">#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span><br><span class="line"></span><br><span class="line">///MALLOC_ALIGNMENT=16</span><br><span class="line">SMALLBIN_CORRECTION=FALSE=0</span><br><span class="line">MIN_LARGE_SIZE=(64-0)*16=1024</span><br></pre></td></tr></table></figure>
<p>smallbins有(64-2=62)个桶子,最大管理的堆块为1023Bytes</p>
<p>再大一个字节都得放到largebin中</p>
<p>也就是说fastbins管理的堆块大小也在smallbin范围内,也就是说,<strong>fastbin相当于前部分比较小的smallbins的缓存</strong></p>
<h5 id="smallbin_index">smallbin_index</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))+ SMALLBIN_CORRECTION)</span></span><br><span class="line">	SMALLBIN_WIDTH=MALLOC_ALIGNMENT=<span class="number">16</span>字节</span><br><span class="line">    SMALLBIN_CORRECTION=<span class="number">0</span></span><br><span class="line">    smallbin_index(sz)=(sz&gt;&gt;<span class="number">4</span>)+<span class="number">0</span>=sz/<span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>这里参数sz是将请求大小换算成对应堆块整体大小之后的值,也就是包括了元数据</p>
<p>最小是0x20(元数据prev_size和size占用0x10,剩下的0x10是最小分配要求)</p>
<table>
<thead>
<tr>
<th>堆块大小(sz)</th>
<th>index</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>unsortedbin</strong></td>
<td>1</td>
</tr>
<tr>
<td><strong>smallbins</strong></td>
<td>[1,63]</td>
</tr>
<tr>
<td><code>[0x20,0x30)</code></td>
<td>2</td>
</tr>
<tr>
<td><code>[0x30,0x40)</code></td>
<td>3</td>
</tr>
<tr>
<td>....</td>
<td></td>
</tr>
<tr>
<td><code>[0x3f0,0x400)</code></td>
<td>63</td>
</tr>
<tr>
<td>&gt;0x400</td>
<td>largebins</td>
</tr>
</tbody>
</table>
<h5 id="bin_at">bin_at</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr)(((char *)&amp;((m)-&gt;bins[((i)-1) * 2])) - offsetof(struct malloc_chunk, fd))</span></span><br><span class="line">	<span class="comment">//(m)-&gt;bins[((i)-1) * 2]-16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(s,m) ((size_t)&amp;(((s*)0)-&gt;m))</span></span><br></pre></td></tr></table></figure>
<p>这里m是malloc_state结构,i是使用smallbin_index宏计算出的堆块在smallbin中的下标,i从2开始,因为bins[0]和bins[1]是unsortedbin的地盘</p>
<p><code>m-&gt;bins[2*(i-1)]</code>指向的是下标为(2*(i-1))的桶子的桶子头,减去<code>fd</code>成员在一个堆块中的偏移量,得到的是该桶子头基址往前16字节的内存地址</p>
<p>显然这个地方是未知的,这是为啥呢?</p>
<p>最后将该地址又交给一个mbinptr也就是malloc_chunk*指针保管</p>
<p>那么此时,新指针+16的位置刚好是修正后的fd</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/9c28ec87e40a4ea615599a26bafa58c.png"
alt="9c28ec87e40a4ea615599a26bafa58c" />
<figcaption
aria-hidden="true">9c28ec87e40a4ea615599a26bafa58c</figcaption>
</figure>
<p>而每个桶子头节点虽然也是malloc_chunk类型,但是只需要fd和bk两个指针,其他成员不需要</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/smallbinhead.png"
alt="smallbinhead" />
<figcaption aria-hidden="true">smallbinhead</figcaption>
</figure>
<h5 id="set_inuse_bit_at_offset">set_inuse_bit_at_offset</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse_bit_at_offset(p, s) \</span></span><br><span class="line"><span class="meta">  (((mchunkptr)(((char *)(p)) + (s)))-&gt;size |= PREV_INUSE)</span></span><br></pre></td></tr></table></figure>
<p>将size字段的flag位设置上PREV_INUSE=1,表示前一个物理相邻块正在被占用</p>
<h5 id="do_check_malloced_chunk">do_check_malloced_chunk</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> check_malloced_chunk(A, P, N) do_check_malloced_chunk(A, P, N)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_check_malloced_chunk</span><span class="params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span></span><br><span class="line">&#123;</span><br><span class="line">  do_check_remalloced_chunk(av, p, s);</span><br><span class="line">  assert(prev_inuse(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="largebins">largebins</h4>
<p>smallbins中的每两个相邻的桶子,其中堆块的大小相差0x16字节(在x64上)</p>
<p>Bin Index就是bin_at的计算结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">实际上largebins和smallbins可以看成一个整体,前<span class="number">64</span>个桶子是smallbins</span><br><span class="line">    前<span class="number">64</span>个桶子相邻两个桶子之间大小差<span class="number">8</span>字节</span><br><span class="line">   	然后<span class="number">32</span>个桶子相邻两个桶子之间大小差<span class="number">64</span>字节</span><br><span class="line">    然后<span class="number">16</span>个桶子相邻两个桶子之间大小差<span class="number">512</span>字节</span><br><span class="line">    ...</span><br><span class="line">	<span class="number">64</span> bins of size       <span class="number">8</span></span><br><span class="line">    <span class="number">32</span> bins of size      <span class="number">64</span></span><br><span class="line">    <span class="number">16</span> bins of size     <span class="number">512</span></span><br><span class="line">     <span class="number">8</span> bins of size    <span class="number">4096</span></span><br><span class="line">     <span class="number">4</span> bins of size   <span class="number">32768</span></span><br><span class="line">     <span class="number">2</span> bins of size  <span class="number">262144</span></span><br><span class="line">     <span class="number">1</span> bin  of size what<span class="number">&#x27;</span>s left</span><br></pre></td></tr></table></figure>
<h5 id="largebin_range">largebin_range</h5>
<p>malloc函数在分配时,超过smallbin_range大小的堆块才可能被放到largebin</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz) \</span></span><br><span class="line"><span class="meta">  ((unsigned long)(sz) &lt; (unsigned long)MIN_LARGE_SIZE)</span></span><br></pre></td></tr></table></figure>
<p>在x64上,MIN_LARGE_SIZE=1024</p>
<p>也就是说,大于等于1024的堆块才可能进入largebin</p>
<h5 id="largebin_index">largebin_index</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz)                              \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8             ? largebin_index_64(sz)     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big(sz) \ <span class="comment">//size_sz!=8并且对齐是16位,调用largebin_index_32_big</span></span></span><br><span class="line">                            : largebin_index_32(sz))		<span class="comment">//size_sz!=8并且对齐是8位,调用largebin_index_32</span></span><br><span class="line">x64上SIZE_SZ=<span class="number">8</span>(一个指针的大小),因此调用largebin_index_64(sz) 这个宏</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                                                                                            \</span></span><br><span class="line"><span class="meta">  (((((unsigned long)(sz)) &gt;&gt; 6) <span class="string">&lt;= 48) ? 48 + (((unsigned long)(sz)) &gt;</span>&gt; 6) : ((((unsigned long)(sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ? 91 + (((unsigned long)(sz)) &gt;</span>&gt; 9)   \</span></span><br><span class="line"><span class="meta">                                                                          : ((((unsigned long)(sz)) &gt;&gt; 12) <span class="string">&lt;= 10)  ? 110 + (((unsigned long)(sz)) &gt;</span>&gt; 12) \</span></span><br><span class="line"><span class="meta">                                                                          : ((((unsigned long)(sz)) &gt;&gt; 15) <span class="string">&lt;= 4)   ? 119 + (((unsigned long)(sz)) &gt;</span>&gt; 15) \</span></span><br><span class="line"><span class="meta">                                                                          : ((((unsigned long)(sz)) &gt;&gt; 18) <span class="string">&lt;= 2)   ? 124 + (((unsigned long)(sz)) &gt;</span>&gt; 18) \</span></span><br><span class="line"><span class="meta">                                                                                                                   : 126)</span></span><br></pre></td></tr></table></figure>
<p>这里的参数sz是包括元数据的整个堆块大小</p>
<p>又落在largebin范围内的堆块,最小是1024字节,因此sz右移6位后,最小是16,那么第一组从16到48,堆块的大小也就是从1024到3072</p>
<p>这些堆块对应的桶下标计算方式为,将其大小右移6位然后加上48,</p>
<p>也就是说,一个桶子中的堆块一样大,同一组内相邻两个桶子中堆块相差64B</p>
<table>
<thead>
<tr>
<th>largebins堆块大小</th>
<th>下标</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>[1024,1087)</td>
<td>64</td>
<td></td>
</tr>
<tr>
<td>[1088,1151)</td>
<td>65</td>
<td></td>
</tr>
<tr>
<td>...</td>
<td></td>
<td></td>
</tr>
<tr>
<td>[3072,3135)</td>
<td>96</td>
<td>这块儿到底塞到哪里我也不知道</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">64</span> bins of size       <span class="number">8</span></span><br><span class="line">   <span class="number">32</span> bins of size      <span class="number">64</span></span><br><span class="line">   <span class="number">16</span> bins of size     <span class="number">512</span></span><br><span class="line">    <span class="number">8</span> bins of size    <span class="number">4096</span></span><br><span class="line">    <span class="number">4</span> bins of size   <span class="number">32768</span></span><br><span class="line">    <span class="number">2</span> bins of size  <span class="number">262144</span></span><br><span class="line">    <span class="number">1</span> bin  of size what<span class="number">&#x27;</span>s left</span><br></pre></td></tr></table></figure>
<p>整个largebin中有6组桶子,第一组占用32个Bins,相邻两个桶子之间的堆块相差64B</p>
<p>第二组占用16个Bins,相邻两个桶子之间的堆块相差16B</p>
<p>...</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(sz/64&lt;=48)&#123;</span><br><span class="line">	return 48+sz/64</span><br><span class="line">&#125;else if(sz/512&lt;=20)&#123;</span><br><span class="line">	return 91+sz/512</span><br><span class="line">&#125;else if(sz/4096&lt;=10)&#123;</span><br><span class="line">	return 110+sz/4096</span><br><span class="line">&#125;else if(sz/)</span><br></pre></td></tr></table></figure>
<h4 id="binmap">binmap</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSHIFT 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITSPERMAP (1U &lt;&lt; BINMAPSHIFT)  </span></span><br><span class="line">	BITSPERMAP=<span class="number">32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSIZE (NBINS / BITSPERMAP)</span></span><br><span class="line">	BINMAPSIZE=<span class="number">128</span>/<span class="number">32</span>=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> binmap[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>binmap是一个4个int的数组,共32位,不管是x64还是x86都是32位,用于标记32个largebin中是否有空闲的堆块</p>
<p>用于加快largebin中分配堆块时的最适寻找工作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)</span></span><br></pre></td></tr></table></figure>
<p>i是largebins下标,右移5位也就是除以32计算得到属于i下标的桶子属于map[0]还是map[1],map[2],map[3]哪一个管理</p>
<p>一个block也就是8个桶子归一个map管</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br></pre></td></tr></table></figure>
<p>计算i下标的largebins桶子属于其对应block的哪一位管</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define mark_bin(m, i) ((m)-&gt;binmap[idx2block(i)] |= idx2bit(i))			//改,标记i下标的largebins有空闲堆块</span><br><span class="line">#define unmark_bin(m, i) ((m)-&gt;binmap[idx2block(i)] &amp;= ~(idx2bit(i)))		//删</span><br><span class="line">#define get_binmap(m, i) ((m)-&gt;binmap[idx2block(i)] &amp; idx2bit(i))			//查</span><br></pre></td></tr></table></figure>
<h2 id="algorithm">algorithm</h2>
<h3 id="malloc">malloc</h3>
<p>用户空间的malloc函数,实际上调用的是<code>__libc_malloc@glibc</code>,别名罢了</p>
<h4 id="libc_malloc">__libc_malloc</h4>
<p>用户程序调用的malloc函数,实际上调用的是<code>__libc_malloc</code></p>
<p>在<code>glibc/malloc/malloc.c</code>中有这么一个<code>alias</code>声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, <span class="built_in">malloc</span>)</span><br></pre></td></tr></table></figure>
<p>而<code>__libc_malloc</code>实际上做的事情就两句话</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line"><span class="keyword">return</span> victim;</span><br></pre></td></tr></table></figure>
<p>其他内容都是多线程上下锁,各种检查,编译优化了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;<span class="comment">//堆块指针</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));<span class="comment">//在实际调用int_malloc函数之前,首先调用钩子函数hook,hook指向__malloc_hook</span></span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);<span class="comment">//获取分配区指针,返回值交给ar_ptr,传递参数bytes的作用是判断分配区空间是否足够</span></span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);<span class="comment">//int_malloc函数是实际进行内存分配的函数</span></span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)<span class="comment">//分配失败并且没有获取到分配区</span></span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);<span class="comment">//分配区获取失败,重试一次</span></span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);<span class="comment">//重新获取分配区之后再次尝试切割堆块给victim</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)<span class="comment">//解锁,因为int_malloc中会对分配区上锁,解锁后方便其他线程分配内存</span></span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));<span class="comment">//最后一次检查</span></span><br><span class="line">    <span class="comment">//检查内容包括:</span></span><br><span class="line">        <span class="comment">//victim指针是否真的指向一个堆块</span></span><br><span class="line">        <span class="comment">//victim对应的堆块是否已经在bitmap中被标记</span></span><br><span class="line">        <span class="comment">//ar_ptr指向的分配区,是否是victim堆块所在的分配区</span></span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="atomic_forced_read">atomic_forced_read</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> atomic_forced_read(x) \</span></span><br><span class="line"><span class="meta">  (&#123; __typeof (x) __x; __asm (<span class="string">&quot;&quot;</span> : <span class="string">&quot;=r&quot;</span> (__x) : <span class="string">&quot;0&quot;</span> (x)); __x; &#125;)</span></span><br></pre></td></tr></table></figure>
<p>原子读,这段内联汇编应该这样断句:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__asm (</span><br><span class="line"> 	&quot;&quot; </span><br><span class="line"> 	: &quot;=r&quot; (__x) </span><br><span class="line"> 	: &quot;0&quot; (x)</span><br><span class="line"> ); </span><br></pre></td></tr></table></figure>
<p>首先""意思是没有一条指令,本内联代码块只需要使用输入输出约束</p>
<p><code>"=r" (__x)</code>输出操作数约束,意思是将<code>__x</code>视为输出变量,放到通用寄存器里</p>
<p><code>: "0" (x)</code>输入操作数约束,意思是x使用和第一个输出操作数(也就是<code>__x</code>)相同的约束</p>
<p>整个内联汇编的作用是将变量x拷贝到<code>__x</code>中</p>
<p>看完了也不知道"原子"如何保证的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>编译器分支预测优化</p>
<p><code>long __builtin_expect(long exp, long c);</code>期望exp表达式的值等于c</p>
<h5 id="malloc_hook">__malloc_hook</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static void *malloc_hook_ini(size_t sz,const void *caller) __THROW;</span><br><span class="line">void *weak_variable (*__malloc_hook)(size_t __size, const void *) = malloc_hook_ini;</span><br></pre></td></tr></table></figure>
<p>分配前钩子,如果有注册钩子函数,则调用该钩子函数进行分配,直接返回钩子函数的返回值给句柄,不会再调用glibc自己实现的int_malloc</p>
<p>可以考虑篡改malloc_hook钩子劫持控制流</p>
<p><a
target="_blank" rel="noopener" href="https://seanachao.github.io/2020/07/13/hook劫持/">malloc_hook以及free_hook劫持原理
| S3cana's Blog (seanachao.github.io)</a></p>
<h4 id="int_malloc">_int_malloc</h4>
<p>这个函数很长,因为GNU向来要求函数嵌套不能太深,因此这个一个函数综合了从fastbin,smallbin,bin,unsortedbin等各种地方申请堆块的操作</p>
<p>glibc2.23/malloc/malloc.c 第3318行开始</p>
<p>函数签名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void *_int_malloc (mstate av, size_t bytes);</span><br></pre></td></tr></table></figure>
<p>static决定本函数只能在malloc模块中可见,用户程序无法越级调用</p>
<p>void*返回值类型</p>
<p>两个参数,<code>mstate av</code>是分配区指针</p>
<p><code>size_t bytes</code>是企图分配的内存大小</p>
<h4 id="算法流程">算法流程</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/malloc.png"
alt="malloc" />
<figcaption aria-hidden="true">malloc</figcaption>
</figure>
<h4 id="局部变量">局部变量</h4>
<p>首先定义了一众局部变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span><span class="comment">//本变量是用户希望大小size的计算值,也就是实际的堆块大小</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* associated bin index */</span><span class="comment">//本变量用于记录nb大小的堆块属于的桶子下标</span></span><br><span class="line">mbinptr bin;                      <span class="comment">/* associated bin */</span>;<span class="comment">//桶子头指针</span></span><br><span class="line"></span><br><span class="line">mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span><span class="comment">//命中堆块</span></span><br><span class="line">INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span>	<span class="comment">//victim命中堆块本来的大小</span></span><br><span class="line"><span class="type">int</span> victim_index;                 <span class="comment">/* its bin index */</span>	<span class="comment">//victim_index命中堆块属于的桶子下标</span></span><br><span class="line"></span><br><span class="line">mchunkptr remainder;              <span class="comment">/* remainder from a split */</span>	<span class="comment">//切割一个大块,剩下的部分被称为remainder</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* its size */</span>	<span class="comment">//剩余部分的大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* bit map traverser */</span>	<span class="comment">//binmap下标,用于记录一个桶子属于四个block之一的哪一个</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* bit map traverser */</span>		<span class="comment">//用于记录一共桶子属于其block中的哪一位	</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span>	<span class="comment">//binmap[map],作为binmap的下标,有0,1,2,3四个取值</span></span><br><span class="line"></span><br><span class="line">mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span>		<span class="comment">//取桶子头之后一般会让bck指向之前的第一个堆块,fwd指向桶子头,然后头插</span></span><br><span class="line">mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="计算实际大小">计算实际大小</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checked_request2size (bytes, nb);</span><br></pre></td></tr></table></figure>
<p>这个宏的作用是将请求的bytes,按照对齐等规则,转化为实际上要申请的大小nb</p>
<p>经过此宏之后,int_malloc中使用的都是nb,不再使用bytes作为分配大小</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define checked_request2size(req, sz)                             \</span><br><span class="line">  if (REQUEST_OUT_OF_RANGE (req)) &#123;					      \</span><br><span class="line">      __set_errno (ENOMEM);						      \</span><br><span class="line">      return 0;								      \</span><br><span class="line">    &#125;									      \</span><br><span class="line">  (sz) = request2size (req);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  #define request2size(req)                                         \</span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  #define MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span><br><span class="line">  #  define MALLOC_ALIGNMENT       (2 *SIZE_SZ &lt; __alignof__ (long double)      \</span><br><span class="line">                                  ? __alignof__ (long double) : 2 *SIZE_SZ)</span><br></pre></td></tr></table></figure>
<p>如果请求大小req+SIZE_SZ+对齐掩码小于最小分配大小,则按照最小分配大小来</p>
<p>否则将上述值和对齐掩码的补码按位与</p>
<p>在x64上</p>
<p>MALLOC_ALIGNMENT=2*SIZE_SZ=16</p>
<p>MALLOC_ALIGN_MASK=15</p>
<p>request2size(req) =(req+8+15 )&amp;11111110000</p>
<p>假设req=0x10,即用户希望得到一块至少有0x10个字节的堆块则</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request2size(req) </span><br><span class="line">    =(<span class="number">16</span>+<span class="number">8</span>+<span class="number">15</span> )&amp;<span class="number">11111110000</span></span><br><span class="line">    =(<span class="number">0b10000</span>+<span class="number">0b1000</span>+<span class="number">0b1111</span>)&amp;<span class="number">111111110000</span></span><br><span class="line">    =<span class="number">0b100111</span>&amp;<span class="number">0b110000</span></span><br><span class="line">    =<span class="number">0b100000</span></span><br><span class="line">    =<span class="number">32</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="检查当前是否有可用分配区">检查当前是否有可用分配区</h4>
<p>然后检查av分配区指针是否为空,显然这里的编译器优化是期望其不空的</p>
<p>但是如果真的av为空,没有可用分配区的画,则调用sysmalloc直接解决分配问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果果真为空则调用sysmalloc函数,</p>
<p>sysmalloc被调用的情况是这样的:</p>
<p>当av分配区的topchunk大小不足以满足用户需求,调用sysmalloc扩大topchunk大小或者更换topchunk</p>
<p>比如调用sbrk系统调用扩大topchunk的大小</p>
<p>sysmalloc如果能成功分配堆块,则p指向该堆块,然后<code>alloc_perturb</code>将p指向堆块的用户空间的前bytes个字节,初始化为<code>perturb_byte^0xff</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> perturb_byte;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">alloc_perturb</span> <span class="params">(<span class="type">char</span> *p, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte ^ <span class="number">0xff</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fastbins区分配">fastbins区分配</h4>
<p>经过两个检查之后,如果控制流执行至此,说明需要分配的堆块不是很离谱,起码不用麻烦sbrk额外分配大块内存</p>
<p>那么首先尝试使用fastbins进行分配</p>
<blockquote>
<p>在该区分配的主要流程:</p>
<p>1.根据实际堆块大小nb计算应该落在哪个桶子里</p>
<p>2.从该桶子顶取出一个堆块交给用户</p>
<p>3.将该桶子中剩余的部分重新挂到桶子头上</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">  &#123;<span class="comment">//首先判断,nb这个大小,是否落在fastbins管理的堆块大小范围内</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//控制流至此说明nb大小适合fastbins分配,下面需要判断fastbins里面有没有空闲堆块</span></span><br><span class="line"></span><br><span class="line">    idx = fastbin_index (nb);<span class="comment">//根据nb大小计算落在fastbin的哪个桶里面,返回值是数组下标</span></span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);<span class="comment">//&amp;fastbins[idx]就是对应桶的桶子头</span></span><br><span class="line">    mchunkptr pp = *fb;<span class="comment">//*解引用,也就是拿出fastbins[idx]指向的第一个堆块,pp拷贝堆块的指针</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim = pp;<span class="comment">//如果上来victim就为空,说明桶子头fastbins[idx]指向NULL,也就是这个桶是空的</span></span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">    		(pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)</span><br><span class="line">          )!= victim</span><br><span class="line">        <span class="comment">//victim指向链栈顶,然后把他取下来,把原来的次顶堆块挂到fb指针上,返回值pp是victim</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>)<span class="comment">//如果victim不为0说明对应桶中确实有堆块,并且已经交给victim保管</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">          &#123;<span class="comment">//victim获取到的fastbin堆块,再检查一下发现不应该属于其原本的桶中,说明有鬼</span></span><br><span class="line">            errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">          errout:</span><br><span class="line">            malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        check_remalloced_chunk (av, victim, nb);<span class="comment">//重新分配的堆块检查,这里指的是从topchunk割下来然后free进入各种bins然后又被重新利用的堆块</span></span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//</span></span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="smallbins区分配">smallbins区分配</h4>
<p>bins数组中维护的是桶子头的fd,bk指针,一个smallbin头需要两个bins数组元素存放,一个记录fd,一个记录bk,</p>
<p>看图一眼顶针</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/smallbin1.png"
alt="smallbin1" />
<figcaption aria-hidden="true">smallbin1</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = smallbin_index (nb);<span class="comment">//计算nb所在的smallbins下标</span></span><br><span class="line">    bin = bin_at (av, idx);<span class="comment">//取smallbin[idx]桶子头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last (bin)) != bin)<span class="comment">//last(bin)=bin-&gt;fd,如果bin的指针还是指向bin说明这个桶子是空的</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">          malloc_consolidate (av);<span class="comment">//堆块合并</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;<span class="comment">//下面要将victim从双向链表上摘下来</span></span><br><span class="line">            bck = victim-&gt;bk;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<span class="comment">//检查victim-&gt;bk指向的堆块,其fd指针是否是victim</span></span><br><span class="line">              &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">              &#125;</span><br><span class="line">            set_inuse_bit_at_offset (victim, nb);<span class="comment">//经过malloc_consolidate后,如果本块和物理相邻的前块都没使用,则会合并起来</span></span><br><span class="line">            <span class="comment">//把victim抠下来,然后把桶子头和victim-&gt;bk连起来</span></span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">              victim-&gt;size |= NON_MAIN_ARENA;<span class="comment">//标记非主分配区</span></span><br><span class="line">            check_malloced_chunk (av, victim, nb);</span><br><span class="line">            <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//获取data基地址指针</span></span><br><span class="line">            alloc_perturb (p, bytes);<span class="comment">//填充</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="fastbin合并">fastbin合并</h4>
<p>注意有两种到达此处的可能,要么是一个<code>smallbin</code>的申请,但是没在<code>smallbin</code>中找到对应堆块,要么是一个largebin的申请</p>
<p>前者<strong>不会</strong>引起<code>fastbin</code>的合并,后者会首先合并<code>fastbin</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line"> &#123;</span><br><span class="line">...</span><br><span class="line">   <span class="keyword">if</span> ((victim = last(bin)) != bin) <span class="comment">// bin桶子中的最后一个,如果不是bin这个头节点自己,那么说明这个桶子里至少有一个空闲堆块</span></span><br><span class="line">   &#123;</span><br><span class="line">   ...</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">   idx = largebin_index(nb);</span><br><span class="line">   <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">     malloc_consolidate(av);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>fastbin</code>合并之后的堆块,都会被放到<code>unsortedbin</code>中,其目的是给<code>unsortedbin</code>区的尝试分配增大可能性</p>
<p>看上去此时将<code>fastbin</code>进行合并,有损效率,但这是为了防止<code>fastbin</code>截留堆块导致堆空间碎片化(<code>fastbin</code>中的堆块依然保持使用状态,不会被其他临近堆块向前或者向后合并.因此需要对其进行主动合并释放)</p>
<p>并且经验表明,一个程序要么主要使用<code>smallbin</code>大小的堆块,要么主要使用<code>largebin</code>大小的堆块</p>
<p>因此对<code>fastbin</code>的合并操作不会被经常调用</p>
<p>具体的<code>fastbin</code>合并过程,在<code>malloc_consolidate</code>中</p>
<h5 id="malloc_consolidate">malloc_consolidate</h5>
<blockquote>
<p>用于<code>fastbin</code>区的合并</p>
<p>两层循环,外层循环遍历<code>fastbin</code>桶子头</p>
<p>内层循环遍历挂载一个桶子头上的堆块链表</p>
<p>对每个堆块,尝试进行向前合并和向后合并,注意只会分别执行一次</p>
<p>如果尝试向后合并时发现和<code>topchunk</code>相邻则并入<code>topchunk</code></p>
<p>如果尝试向前合并和向后合并之后,没有并入topchunk会被头插法链接到<code>unsortedbin</code>的双向链表上</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mfastbinptr *fb;          <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr *maxfb;       <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr p;              <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr nextp;          <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr unsorted_bin;   <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr first_unsorted; <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="type">int</span> nextinuse;</span><br><span class="line">  mchunkptr bck;</span><br><span class="line">  mchunkptr fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast() != <span class="number">0</span>)<span class="comment">//如果max_faxt值为空,则说明堆还没有初始化</span></span><br><span class="line">  &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    maxfb = &amp;fastbin(av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin(av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      p = atomic_exchange_acq(fb, <span class="number">0</span>); <span class="comment">// p=fb,fb++</span></span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123; <span class="comment">// 释放快桶子p上挂着的所有堆块</span></span><br><span class="line">          check_inuse_chunk(av, p);</span><br><span class="line">          nextp = p-&gt;fd; <span class="comment">// 先取后继</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">          size = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA); <span class="comment">// 撤销flag</span></span><br><span class="line">          nextchunk = chunk_at_offset(p, size);            <span class="comment">// 物理上相邻的下一个堆块</span></span><br><span class="line">          nextsize = chunksize(nextchunk);   </span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!prev_inuse(p))<span class="comment">//向前合并</span></span><br><span class="line">          &#123;</span><br><span class="line">            prevsize = p-&gt;prev_size;</span><br><span class="line">            size += prevsize;</span><br><span class="line">            p = chunk_at_offset(p, -((<span class="type">long</span>)prevsize));<span class="comment">//取物理上前一个相邻的堆块基址,作为合并堆块的基址</span></span><br><span class="line">            unlink(av, p, bck, fwd);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (nextchunk != av-&gt;top)<span class="comment">//如果后面和topchunk相邻则和topchunk合并,否则尝试向后合并</span></span><br><span class="line">          &#123;</span><br><span class="line">            nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!nextinuse)</span><br><span class="line">            &#123;</span><br><span class="line">              size += nextsize;</span><br><span class="line">              unlink(av, nextchunk, bck, fwd);<span class="comment">//如果物理上后面相邻的堆块没在使用则向后合并</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            first_unsorted = unsorted_bin-&gt;fd;<span class="comment">//取第一个unsorted_bin上悬挂的堆块</span></span><br><span class="line">            unsorted_bin-&gt;fd = p;<span class="comment">//头插法</span></span><br><span class="line">            first_unsorted-&gt;bk = p;<span class="comment">//将p链接到unsorted_bin和p之间</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range(size))<span class="comment">//如果这个合并堆块在largebin范围内则初始化其nextsize指针</span></span><br><span class="line">            &#123;</span><br><span class="line">              p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            p-&gt;bk = unsorted_bin;</span><br><span class="line">            p-&gt;fd = first_unsorted;</span><br><span class="line">            set_foot(p, size);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            size += nextsize;</span><br><span class="line">            set_head(p, size | PREV_INUSE);<span class="comment">//p后面就是topchunk,p合并到topchunk</span></span><br><span class="line">            av-&gt;top = p;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> ((p = nextp) != <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);<span class="comment">//遍历整个fastbin,直到fastbin桶子头哨兵maxfb</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    malloc_init_state(av);<span class="comment">//初始化堆</span></span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="unsortedbin区分配">unsortedbin区分配</h4>
<h5 id="unsortedbin尝试分配-与-归类">unsortedbin尝试分配 与 归类</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av))<span class="comment">//检查unsortedbin中是否确实有堆块,有则从unsortedbin中拿下第一个堆块</span></span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;<span class="comment">//后继</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect(victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                        chunk2mem(victim), av);</span><br><span class="line">      size = chunksize(victim);<span class="comment">//根据size字段获取victim的大小</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">         only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">         runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">         exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">         no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp;<span class="comment">//如果是一个smallbin的分配申请</span></span><br><span class="line">          bck == unsorted_chunks(av) &amp;&amp;<span class="comment">//bck=victim-&gt;bk如果这个判断通过,说明刚从unsortedbin中拆下的堆块victim是unsoreted中唯一的堆块</span></span><br><span class="line">          victim == av-&gt;last_remainder &amp;&amp;<span class="comment">//如果victim是最近一次分配过的堆块,最近使用的堆块页面可能还在内存中,因此有这种优化</span></span><br><span class="line">          (<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE))<span class="comment">//如果这个victim堆块满足大小要求</span></span><br><span class="line">      &#123;<span class="comment">//这个victim通过了考察,下面将其分割,将满足大小要求的部分给用户,剩下的部分再放回unsortedbin</span></span><br><span class="line">        <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">        remainder_size = size - nb;<span class="comment">//剩余大小</span></span><br><span class="line">        remainder = chunk_at_offset(victim, nb);<span class="comment">//victim的前半部分将要分出去给用户,后面的剩下,remainder是剩下部分的基地址</span></span><br><span class="line">        unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;<span class="comment">//更新unsortedbin中这个唯一堆块的剩余状态</span></span><br><span class="line">        av-&gt;last_remainder = remainder;<span class="comment">//剩余堆块记为最近使用</span></span><br><span class="line">        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);<span class="comment">//设置前后指针都为unsortedbin桶子</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(remainder_size))<span class="comment">//如果剩下的部分属于largebin范围,则初始化两个指针</span></span><br><span class="line">        &#123;</span><br><span class="line">          remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);<span class="comment">//因为前块被分配,因此remainder的prev_inuse置1</span></span><br><span class="line">        set_foot(remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);<span class="comment">//p=victim+0x10指向data区域</span></span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">      unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = unsorted_chunks(av);<span class="comment">//将bin从unsortedbin中拿出来,然后将其前后驱连接</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size == nb)<span class="comment">//如果尝试分配的大小,恰好和这个unsortedbin堆块一样大则分配之</span></span><br><span class="line">      &#123;</span><br><span class="line">        set_inuse_bit_at_offset(victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(size))<span class="comment">//如果这个刚摘下来的unsortedbin堆块属于smallbin范围,计算好新的前后邻居</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim_index = smallbin_index(size);</span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span><span class="comment">//否则说明这unsortedbin堆块属于largebin范围,计算好新的前后邻居</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim_index = largebin_index(size);</span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">        <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">          size |= PREV_INUSE;</span><br><span class="line">          <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">          assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(bck-&gt;bk-&gt;size))</span><br><span class="line">          &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>)size &lt; fwd-&gt;size)</span><br><span class="line">            &#123;</span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)size == (<span class="type">unsigned</span> <span class="type">long</span>)fwd-&gt;size)</span><br><span class="line">              <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//结算,前面不管是largebin还是smallbin,都已经计算好了前后邻居bck,fwd,在此将诸位连接</span></span><br><span class="line">      mark_bin(av, victim_index);<span class="comment">//标记binmap</span></span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS 10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)<span class="comment">//顶多合并10000次,太多次合并会导致本次请求响应太慢</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="largebin申请">largebin申请</h5>
<p>如果到此还没有返回,也就是还没有申请到堆块下面再尝试使用largebin申请</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!in_smallbin_range(nb))<span class="comment">//如果是一个largebin的请求</span></span><br><span class="line"> &#123;</span><br><span class="line">   bin = bin_at(av, idx);<span class="comment">//取桶子头</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">   <span class="keyword">if</span> ((victim = first(bin)) != bin &amp;&amp;</span><br><span class="line">       (<span class="type">unsigned</span> <span class="type">long</span>)(victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb))</span><br><span class="line">   &#123;<span class="comment">//first(bin)=bin-&gt;fd,可以看出bin-&gt;fd应该是该桶子中最大的一个堆块,然后顺着fd指针越来越小</span></span><br><span class="line">       <span class="comment">//如果最大的堆块都不满足nb的需求,显然再往后找更小的无意义,因此首先需要判断最大的堆块是否能满足要求,</span></span><br><span class="line"><span class="comment">//当这个前提条件满足时,再向后找最佳适配的堆块</span></span><br><span class="line">     victim = victim-&gt;bk_nextsize;<span class="comment">//bk_nextsize是下一个比当前victim小的堆块,victim-&gt;bk可能和victim一样大,但是victim-&gt;bk_nextsize要么是桶子头,要么一定比当前堆块小</span></span><br><span class="line">     <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>)(size = chunksize(victim)) &lt;</span><br><span class="line">             (<span class="type">unsigned</span> <span class="type">long</span>)(nb)))</span><br><span class="line">       victim = victim-&gt;bk_nextsize;<span class="comment">//从小开始遍历直到第一个大于等于nb大小的堆块</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">        list does not have to be rerouted.  */</span></span><br><span class="line">     <span class="keyword">if</span> (victim != last(bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">       victim = victim-&gt;fd;<span class="comment">//避免移除跳表的最开始一个导致变更指针,首先尝试寻找该大小的堆块是否有第二块,如果有则放过跳表头</span></span><br><span class="line">		</span><br><span class="line">     remainder_size = size - nb;<span class="comment">//victim块比较抠,只分配nb大小左右,多余的不给</span></span><br><span class="line">     unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Exhaust */</span></span><br><span class="line">     <span class="keyword">if</span> (remainder_size &lt; MINSIZE)<span class="comment">//如果发现victim分割后的剩余部分都是下脚料就不抠了</span></span><br><span class="line">     &#123;</span><br><span class="line">       set_inuse_bit_at_offset(victim, size);</span><br><span class="line">       <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">         victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* Split */</span></span><br><span class="line">     <span class="keyword">else</span><span class="comment">//否则victim剩余部分放到unsortedbin</span></span><br><span class="line">     &#123;</span><br><span class="line">       remainder = chunk_at_offset(victim, nb);<span class="comment">//取victim切割nb字节之后的剩余部分</span></span><br><span class="line">       <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">          have to perform a complete insert here.  */</span></span><br><span class="line">       bck = unsorted_chunks(av);</span><br><span class="line">       fwd = bck-&gt;fd;</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">       &#123;</span><br><span class="line">         errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">         <span class="keyword">goto</span> errout;</span><br><span class="line">       &#125;</span><br><span class="line">       remainder-&gt;bk = bck;<span class="comment">//头插法</span></span><br><span class="line">       remainder-&gt;fd = fwd;</span><br><span class="line">       bck-&gt;fd = remainder;</span><br><span class="line">       fwd-&gt;bk = remainder;</span><br><span class="line">       <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">       &#123;</span><br><span class="line">         remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;<span class="comment">//如果剩余大小还是largebin大小,则此时预先将指针清零</span></span><br><span class="line">         remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">       set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">       set_foot(remainder, remainder_size);</span><br><span class="line">     &#125;</span><br><span class="line">     check_malloced_chunk(av, victim, nb);</span><br><span class="line">     <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">     alloc_perturb(p, bytes);</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="后续largebin申请">后续largebin申请</h5>
<p>如果到此还没有分配,说明当前largebin里面没有找到何时的,那么向后面的largebin桶子中找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">   bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">   (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">   that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">   The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">   when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">++idx;					<span class="comment">//取下一个桶子的下标</span></span><br><span class="line">bin = bin_at(av, idx);	<span class="comment">//首先查binmap,看看下一个桶子是否确实有空闲堆块</span></span><br><span class="line">block = idx2block(idx);</span><br><span class="line"><span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">bit = idx2bit(idx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">  <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)<span class="comment">//如果bit&gt;map只可能是map=0,也就是当前block是空的</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">        <span class="keyword">goto</span> use_top;<span class="comment">//如果发现block遍历了4个block,全是空的,也就是largebin空了,直接使用top_chunk分配</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);<span class="comment">//跳过所有空的largebin</span></span><br><span class="line"></span><br><span class="line">    bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">    bit = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">  <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)<span class="comment">//尝试找一个map对应block中有堆块的桶子</span></span><br><span class="line">  &#123;</span><br><span class="line">    bin = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;<span class="comment">//左移也就是往largebin更大的方向找</span></span><br><span class="line">    assert(bit != <span class="number">0</span>);</span><br><span class="line">  &#125;<span class="comment">//退出循环时,bin对应的桶子中一定有堆块</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">  victim = last(bin);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">  <span class="keyword">if</span> (victim == bin)<span class="comment">//检查是否该bin中至少有一个堆块,这是因为map是懒修改的</span></span><br><span class="line">  &#123;<span class="comment">//也就是说,map中标记有的不一定有,但是map中标记没有的一定没有</span></span><br><span class="line">    av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">      <span class="comment">//本桶子中确实没有,但也不是没有功劳,起码可以修改map,下一次查找一定不会查本桶子</span></span><br><span class="line">    bin = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;<span class="comment">//继续向更大的largebin桶子寻找</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span><span class="comment">//本桶子中确实有至少一个堆块</span></span><br><span class="line">  &#123;</span><br><span class="line">    size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">    assert((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb));</span><br><span class="line"></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlink */</span></span><br><span class="line">    unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exhaust */</span></span><br><span class="line">    <span class="keyword">if</span> (remainder_size &lt; MINSIZE)<span class="comment">//下脚料一起送人</span></span><br><span class="line">    &#123;</span><br><span class="line">      set_inuse_bit_at_offset(victim, size);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split */</span></span><br><span class="line">    <span class="keyword">else</span>		<span class="comment">//切割指定大小的堆块,剩下的送给unsortedbin</span></span><br><span class="line">    &#123;</span><br><span class="line">      remainder = chunk_at_offset(victim, nb);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">         have to perform a complete insert here.  */</span></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      remainder-&gt;bk = bck;</span><br><span class="line">      remainder-&gt;fd = fwd;</span><br><span class="line">      bck-&gt;fd = remainder; </span><br><span class="line">      fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">      &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                           (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">      set_foot(remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="unlink">unlink</h6>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/unlink.png"
alt="unlink" />
<figcaption aria-hidden="true">unlink</figcaption>
</figure>
<p>从双向链表上摘下一个堆块<code>P</code>,把它的前后驱重新链接起来</p>
<p>针对<code>smallbin</code>和<code>unsortedbin</code>,有如下检查</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;bk-&gt;fd==P</span><br><span class="line">P-&gt;fd-&gt;bk==P</span><br></pre></td></tr></table></figure>
<p>如果是一个<code>largebin</code>的堆块,还会有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;fd_nextsize-&gt;bk_nextsize==P</span><br><span class="line">P-&gt;bk_nextsize-&gt;fd_nextsize==P</span><br></pre></td></tr></table></figure>
<p>对于<code>smallbin</code>和<code>unsortedbin</code>,如果检查通过,则执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD-&gt;bk = BK;                                                                                                          \</span><br><span class="line">BK-&gt;fd = FD;     </span><br></pre></td></tr></table></figure>
<p>将P的前后驱连接起来</p>
<p>对于<code>largebin</code>的堆块,还会执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>)                                                                                        \</span><br><span class="line">&#123;                                                                                                                   \</span><br><span class="line">  <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                                                                          \</span><br><span class="line">    FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                                                                         \</span><br><span class="line">  <span class="keyword">else</span>                                                                                                              \</span><br><span class="line">  &#123;                                                                                                                 \</span><br><span class="line">    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                                                                               \</span><br><span class="line">    FD-&gt;bk_nextsize </span><br><span class="line">    = P-&gt;bk_nextsize;                                                                               \</span><br><span class="line">    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                                                                               \</span><br><span class="line">    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                                                                               \</span><br><span class="line">  &#125;                                                                                                                 \</span><br><span class="line">&#125;                                                                                                                   \</span><br><span class="line"><span class="keyword">else</span>                                                                                                                \</span><br><span class="line">&#123;                                                                                                                   \</span><br><span class="line">  P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                                                                     \</span><br><span class="line">  P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                                                                     \</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>完整代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD)                                                                                               \</span></span><br><span class="line"><span class="meta">  &#123;                                                                                                                         \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;                                                                                                             \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;                                                                                                             \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, 0))                                                                    \</span></span><br><span class="line"><span class="meta">      <span class="comment">//检查后继的前驱指针以及前驱的后继指针</span></span></span><br><span class="line">      malloc_printerr(check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);                                                 \</span><br><span class="line">    <span class="keyword">else</span>                                                                                                                    \</span><br><span class="line">    &#123;                                                                                                                       \</span><br><span class="line">      FD-&gt;bk = BK;                                                                                                          \</span><br><span class="line">      <span class="comment">//将前后驱堆块连接,解放P</span></span><br><span class="line">      BK-&gt;fd = FD;                                                                                                          \</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(P-&gt;size) &amp;&amp; __builtin_expect(P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>))                                       \</span><br><span class="line">      &#123;                                                                                                                     \</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>) || __builtin_expect(P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>)) \</span><br><span class="line">          malloc_printerr(check_action,                                                                                     \</span><br><span class="line">                          <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,                                                       \</span><br><span class="line">                          P, AV);                                                                                           \</span><br><span class="line">        <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>)                                                                                        \</span><br><span class="line">        &#123;                                                                                                                   \</span><br><span class="line">          <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                                                                          \</span><br><span class="line">            FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                                                                         \</span><br><span class="line">          <span class="keyword">else</span>                                                                                                              \</span><br><span class="line">          &#123;                                                                                                                 \</span><br><span class="line">            FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                                                                               \</span><br><span class="line">            FD-&gt;bk_nextsize </span><br><span class="line">            = P-&gt;bk_nextsize;                                                                               \</span><br><span class="line">            P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                                                                               \</span><br><span class="line">            P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                                                                               \</span><br><span class="line">          &#125;                                                                                                                 \</span><br><span class="line">        &#125;                                                                                                                   \</span><br><span class="line">        <span class="keyword">else</span>                                                                                                                \</span><br><span class="line">        &#123;                                                                                                                   \</span><br><span class="line">          P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                                                                     \</span><br><span class="line">          P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                                                                     \</span><br><span class="line">        &#125;                                                                                                                   \</span><br><span class="line">      &#125;                                                                                                                     \</span><br><span class="line">    &#125;                                                                                                                       \</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="topchunk申请">topchunk申请</h5>
<p>如果还不行,尝试使用topchunk分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">     (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">     search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">     less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">     be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">     limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">     MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">     exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">     reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">     to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset(victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">     here for all block sizes.  */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">  &#123;</span><br><span class="line">    malloc_consolidate(av);</span><br><span class="line">    <span class="comment">/* restore original bin index */</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">      idx = smallbin_index(nb);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      idx = largebin_index(nb);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="sysmalloc申请">sysmalloc申请</h5>
<p>如果还不行,尝试sysmalloc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="free">free</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strong_alias(__libc_free, __free) strong_alias(__libc_free, free)</span><br></pre></td></tr></table></figure>
<h4 id="libc_free">__libc_free</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __libc_free(<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p; <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (*hook)(<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *) = atomic_forced_read(__free_hook);<span class="comment">//首先尝试调用hook函数(如果有注册的话)</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>) <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk(mem);<span class="comment">//p指向堆块基址,mem指向数据区,也就是p+0x10</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">    <span class="keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">      mp_.mmap_threshold = chunksize(p);</span><br><span class="line">      mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">      LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                 mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    munmap_chunk(p);<span class="comment">//如果p堆块是mmap分配的则调用munmap释放</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk(p);</span><br><span class="line">  _int_free(ar_ptr, p, <span class="number">0</span>);<span class="comment">//调用glibc实现的_int_free,这也是默认释放过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="free_hook">__free_hook</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">weak_variable</span> <span class="params">(*__free_hook)</span><span class="params">(<span class="type">void</span> *__ptr,<span class="type">const</span> <span class="type">void</span> *)</span> = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>与<code>__malloc_hook</code>同理,如果本钩子函数有注册过则调用之进行释放,不会再调用glibc自己实现的<code>_int_free</code></p>
<h4 id="int_free">_int_free</h4>
<p>实际上调用的释放函数</p>
<h4 id="算法流程-1">算法流程</h4>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/picbed/main/free.png"
alt="free" />
<figcaption aria-hidden="true">free</figcaption>
</figure>
<p>整个流程要比分配<code>_int_malloc</code>简单点</p>
<h4 id="局部变量-1">局部变量</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INTERNAL_SIZE_T size;     <span class="comment">/* its size */</span>		<span class="comment">//用于保存请求堆块的整体大小(包括元数据)</span></span><br><span class="line">mfastbinptr *fb;          <span class="comment">/* associated fastbin */</span>		<span class="comment">//fastbin桶子</span></span><br><span class="line">mchunkptr nextchunk;      <span class="comment">/* next contiguous chunk */</span>		<span class="comment">//下一个堆块</span></span><br><span class="line">INTERNAL_SIZE_T nextsize; <span class="comment">/* its size */</span>					<span class="comment">//下一个堆块的大小</span></span><br><span class="line"><span class="type">int</span> nextinuse;            <span class="comment">/* true if nextchunk is used */</span>	<span class="comment">//下一个堆块是否在使用,合并堆块时用</span></span><br><span class="line">INTERNAL_SIZE_T prevsize; <span class="comment">/* size of previous contiguous chunk */</span>	<span class="comment">//前块大小</span></span><br><span class="line">mchunkptr bck;            <span class="comment">/* misc temp for linking */</span>		<span class="comment">//头插法前后邻居</span></span><br><span class="line">mchunkptr fwd;            <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> locked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">size = chunksize(p);		<span class="comment">//size当前要申请的堆块的大小(包括元数据)</span></span><br></pre></td></tr></table></figure>
<h4 id="释放前检查">释放前检查</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">   allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">   Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">   here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect((<span class="type">uintptr_t</span>)p &gt; (<span class="type">uintptr_t</span>)-size, <span class="number">0</span>) || __builtin_expect(misaligned_chunk(p), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">errout:</span><br><span class="line">  <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">  malloc_printerr(check_action, errstr, chunk2mem(p), av);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">   multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size)))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_inuse_chunk(av, p)</span><br></pre></td></tr></table></figure>
<p>检查锁和对齐,整个释放过程可以看成一个事务,由锁保证一致性</p>
<h4 id="fastbin区释放">fastbin区释放</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast())<span class="comment">//如果释放堆块大小落在fastbin范围内</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">  If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">  bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)<span class="comment">//检查后面是否和topchunk相邻,(如果相邻需要合并,不会进入fastbin)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  )</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    &#123;<span class="comment">//首先检查堆块大小是否比最小大小要大,并且是不是可以分配的范围内</span></span><br><span class="line">      <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">         of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">         after getting the lock.  */</span></span><br><span class="line">      <span class="keyword">if</span> (have_lock || (&#123;c</span><br><span class="line">            assert(locked == <span class="number">0</span>);</span><br><span class="line">            mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">            locked = <span class="number">1</span>;</span><br><span class="line">            chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ || chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">          &#125;))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      &#123;</span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//已获得锁</span></span><br><span class="line">    free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);<span class="comment">//堆块的mem数据区清零</span></span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);<span class="comment">//计算fastbin桶子下标</span></span><br><span class="line">    fb = &amp;fastbin(av, idx);<span class="comment">//获取fastbin桶子头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;<span class="comment">//old指向fastbin对应桶子的第一个堆块</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">         (i.e., double free).  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>))<span class="comment">//检查p是否已经被刚刚释放过一次</span></span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">         size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">         only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">         deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">      <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">        old_idx = fastbin_index(chunksize(old));</span><br><span class="line">      p-&gt;fd = old2 = old;<span class="comment">//把p挂到fastbin上(头插法),fastbin[idx]-&gt;p-&gt;old-&gt;...</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect(old_idx != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆块合并">堆块合并</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p))<span class="comment">//p不能是mmap映射的</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">    &#123;</span><br><span class="line">      (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);<span class="comment">//取物理上下一个相邻的堆块基地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(p == av-&gt;top))<span class="comment">//p不能是topchunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(contiguous(av) &amp;&amp; (<span class="type">char</span> *)nextchunk &gt;= ((<span class="type">char</span> *)av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">    &#123;<span class="comment">//如果下一个堆块溢出到topchunk内部了</span></span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk)))</span><br><span class="line">    &#123;<span class="comment">//如果物理上的后块没有记录本块的释放状态</span></span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);<span class="comment">//下一个堆块的大小</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    &#123;<span class="comment">//下一堆块的大小必须在合法范围(2*SIZE_SZ,av-&gt;system_mem)之内</span></span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);<span class="comment">//p数据区清零</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p))<span class="comment">//向前合并</span></span><br><span class="line">    &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>)prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top)<span class="comment">//如果后块时topchunk则合并到topchunk,否则尝试向后合并</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse)<span class="comment">//如果后一堆块空闲则向后合并</span></span><br><span class="line">      &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">  not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">  been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      bck = unsorted_chunks(av);<span class="comment">//释放的堆块放到unsortedbin中,下一次malloc才可能重新安排新去处</span></span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))<span class="comment">//如果是largebin的堆块则现在就把fd_nextsize和bk_nextsize清零</span></span><br><span class="line">      &#123;</span><br><span class="line">        p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span><span class="comment">//此else意味着向后与topchunk相邻,则合并到topchunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD)</span><br><span class="line">    &#123;<span class="comment">//如果size大于fastbin合并阈值65536</span></span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">        malloc_consolidate(av);<span class="comment">//清空fastbin,该合并合并,放到unsortedbin或者topchunk</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena)<span class="comment">//如果是主分配区</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))<span class="comment">//如果topchunk太大了就得修剪一下</span></span><br><span class="line">          systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span><span class="comment">//否则就是非主分配区的辅助堆</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">           large, because the corresponding heap might go away.  */</span></span><br><span class="line">        heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">        assert(heap-&gt;ar_ptr == av);</span><br><span class="line">        heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">    &#123;</span><br><span class="line">      assert(locked);<span class="comment">//保证事务完整性</span></span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="mmap映射区释放">mmap映射区释放</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  munmap_chunk(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%A0%86/" rel="tag"># 堆</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/05/31/Antlr/" rel="prev" title="Antlr4">
      <i class="fa fa-chevron-left"></i> Antlr4
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/10/28/tcache/" rel="next" title="glibc2.27 tcache">
      glibc2.27 tcache <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#dive-into-ptmalloc2"><span class="nav-number">1.</span> <span class="nav-text">Dive Into Ptmalloc2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#datastructure"><span class="nav-number">1.1.</span> <span class="nav-text">datastructure</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc_chunk"><span class="nav-number">1.1.1.</span> <span class="nav-text">malloc_chunk</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E6%84%8F%E4%B9%89"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">字段意义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#prev_size"><span class="nav-number">1.1.1.1.1.</span> <span class="nav-text">prev_size</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#size"><span class="nav-number">1.1.1.1.2.</span> <span class="nav-text">size</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fdbk"><span class="nav-number">1.1.1.1.3.</span> <span class="nav-text">fd,bk</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fd_nextsizebk_nextsize"><span class="nav-number">1.1.1.1.4.</span> <span class="nav-text">fd_nextsize,bk_nextsize</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E7%94%A8"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">空间复用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%97%B6%E7%8A%B6%E6%80%81"><span class="nav-number">1.1.1.2.1.</span> <span class="nav-text">分配时状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E6%97%B6%E7%8A%B6%E6%80%81"><span class="nav-number">1.1.1.2.2.</span> <span class="nav-text">空闲时状态</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">宏定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.1.1.3.1.</span> <span class="nav-text">指针转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%B0%8Fchunk%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.1.1.3.2.</span> <span class="nav-text">最小chunk大小</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%B3%E8%AF%B7%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.1.1.3.3.</span> <span class="nav-text">最小申请的堆内存大小</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%AF%B9%E9%BD%90"><span class="nav-number">1.1.1.3.4.</span> <span class="nav-text">检查对齐</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E7%94%A8%E6%88%B7%E8%AF%B7%E6%B1%82%E6%98%AF%E5%90%A6%E7%A6%BB%E8%B0%B1"><span class="nav-number">1.1.1.3.5.</span> <span class="nav-text">判断用户请求是否离谱</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%84%E8%8C%83%E5%8C%96%E8%AF%B7%E6%B1%82%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.1.1.3.6.</span> <span class="nav-text">规范化请求大小</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AEsize%E6%9C%80%E4%BD%8E%E4%B8%89%E4%BD%8D%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="nav-number">1.1.1.3.7.</span> <span class="nav-text">设置size最低三位标志位</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%9C%ACchunk-size"><span class="nav-number">1.1.1.3.8.</span> <span class="nav-text">获取本chunk size</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81"><span class="nav-number">1.1.1.3.9.</span> <span class="nav-text">使用状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#size%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.1.1.3.10.</span> <span class="nav-text">size大小</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E5%81%8F%E7%A7%BB%E5%A4%84%E8%AE%A4%E4%B8%BA%E6%98%AF%E4%B8%80%E4%B8%AAchunk"><span class="nav-number">1.1.1.3.11.</span> <span class="nav-text">指定偏移处认为是一个chunk</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc_state"><span class="nav-number">1.1.2.</span> <span class="nav-text">malloc_state</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fastbins"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">fastbins</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#max_fast"><span class="nav-number">1.1.2.1.1.</span> <span class="nav-text">max_fast</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fastbin_index"><span class="nav-number">1.1.2.1.2.</span> <span class="nav-text">fastbin_index</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fastbinidx"><span class="nav-number">1.1.2.1.3.</span> <span class="nav-text">fastbin[idx]</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#catomic_compare_and_exchange_val_acq-fb-victim-fd-victim"><span class="nav-number">1.1.2.1.4.</span> <span class="nav-text">catomic_compare_and_exchange_val_acq
(fb, victim-&gt;fd, victim)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#check_remalloced_chunkapn"><span class="nav-number">1.1.2.1.5.</span> <span class="nav-text">check_remalloced_chunk(A,P,N)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unsortedbins"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">unsortedbins</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#unsorted_chunksm-bin_atm-1"><span class="nav-number">1.1.2.2.1.</span> <span class="nav-text">unsorted_chunks(M) (bin_at(M,
1))</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#smallbins"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">smallbins</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#next_bin"><span class="nav-number">1.1.2.3.1.</span> <span class="nav-text">next_bin</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#in_smallbin_range"><span class="nav-number">1.1.2.3.2.</span> <span class="nav-text">in_smallbin_range</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#smallbin_index"><span class="nav-number">1.1.2.3.3.</span> <span class="nav-text">smallbin_index</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bin_at"><span class="nav-number">1.1.2.3.4.</span> <span class="nav-text">bin_at</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#set_inuse_bit_at_offset"><span class="nav-number">1.1.2.3.5.</span> <span class="nav-text">set_inuse_bit_at_offset</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#do_check_malloced_chunk"><span class="nav-number">1.1.2.3.6.</span> <span class="nav-text">do_check_malloced_chunk</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#largebins"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">largebins</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#largebin_range"><span class="nav-number">1.1.2.4.1.</span> <span class="nav-text">largebin_range</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#largebin_index"><span class="nav-number">1.1.2.4.2.</span> <span class="nav-text">largebin_index</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#binmap"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">binmap</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#algorithm"><span class="nav-number">1.2.</span> <span class="nav-text">algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc"><span class="nav-number">1.2.1.</span> <span class="nav-text">malloc</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#libc_malloc"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">__libc_malloc</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#atomic_forced_read"><span class="nav-number">1.2.1.1.1.</span> <span class="nav-text">atomic_forced_read</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#malloc_hook"><span class="nav-number">1.2.1.1.2.</span> <span class="nav-text">__malloc_hook</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#int_malloc"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">_int_malloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">算法流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">局部变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%AE%9E%E9%99%85%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">计算实际大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%BD%93%E5%89%8D%E6%98%AF%E5%90%A6%E6%9C%89%E5%8F%AF%E7%94%A8%E5%88%86%E9%85%8D%E5%8C%BA"><span class="nav-number">1.2.1.6.</span> <span class="nav-text">检查当前是否有可用分配区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fastbins%E5%8C%BA%E5%88%86%E9%85%8D"><span class="nav-number">1.2.1.7.</span> <span class="nav-text">fastbins区分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#smallbins%E5%8C%BA%E5%88%86%E9%85%8D"><span class="nav-number">1.2.1.8.</span> <span class="nav-text">smallbins区分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fastbin%E5%90%88%E5%B9%B6"><span class="nav-number">1.2.1.9.</span> <span class="nav-text">fastbin合并</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#malloc_consolidate"><span class="nav-number">1.2.1.9.1.</span> <span class="nav-text">malloc_consolidate</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unsortedbin%E5%8C%BA%E5%88%86%E9%85%8D"><span class="nav-number">1.2.1.10.</span> <span class="nav-text">unsortedbin区分配</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#unsortedbin%E5%B0%9D%E8%AF%95%E5%88%86%E9%85%8D-%E4%B8%8E-%E5%BD%92%E7%B1%BB"><span class="nav-number">1.2.1.10.1.</span> <span class="nav-text">unsortedbin尝试分配 与 归类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#largebin%E7%94%B3%E8%AF%B7"><span class="nav-number">1.2.1.10.2.</span> <span class="nav-text">largebin申请</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8E%E7%BB%ADlargebin%E7%94%B3%E8%AF%B7"><span class="nav-number">1.2.1.10.3.</span> <span class="nav-text">后续largebin申请</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#unlink"><span class="nav-number">1.2.1.10.3.1.</span> <span class="nav-text">unlink</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#topchunk%E7%94%B3%E8%AF%B7"><span class="nav-number">1.2.1.10.4.</span> <span class="nav-text">topchunk申请</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sysmalloc%E7%94%B3%E8%AF%B7"><span class="nav-number">1.2.1.10.5.</span> <span class="nav-text">sysmalloc申请</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free"><span class="nav-number">1.2.2.</span> <span class="nav-text">free</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#libc_free"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">__libc_free</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#free_hook"><span class="nav-number">1.2.2.1.1.</span> <span class="nav-text">__free_hook</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#int_free"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">_int_free</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-1"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">算法流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-1"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">局部变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E5%89%8D%E6%A3%80%E6%9F%A5"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">释放前检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fastbin%E5%8C%BA%E9%87%8A%E6%94%BE"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">fastbin区释放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E5%9D%97%E5%90%88%E5%B9%B6"><span class="nav-number">1.2.2.7.</span> <span class="nav-text">堆块合并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mmap%E6%98%A0%E5%B0%84%E5%8C%BA%E9%87%8A%E6%94%BE"><span class="nav-number">1.2.2.8.</span> <span class="nav-text">mmap映射区释放</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
